const moduleId = "tidy5e-sheet";
const CONSTANTS = {
  ALPHA_MODULE_ID: "tidy5e-sheet-kgar",
  MODULE_ID: moduleId,
  DND5E_SYSTEM_ID: "dnd5e",
  DOCUMENT_NAME_ACTOR: "Actor",
  ATTUNEMENT_OPTIONAL: "optional",
  ATTUNEMENT_REQUIRED: "required",
  ITEM_CAPACITY_TYPE_ITEMS: "items",
  ITEM_CAPACITY_TYPE_WEIGHT: "weight",
  ITEM_TYPE_BACKGROUND: "background",
  ITEM_TYPE_CLASS: "class",
  ITEM_TYPE_CONSUMABLE: "consumable",
  ITEM_TYPE_CONTAINER: "container",
  ITEM_TYPE_EQUIPMENT: "equipment",
  ITEM_TYPE_FEAT: "feat",
  ITEM_TYPE_LOOT: "loot",
  ITEM_TYPE_RACE: "race",
  ITEM_TYPE_SPELL: "spell",
  ITEM_TYPE_SUBCLASS: "subclass",
  ITEM_TYPE_TOOL: "tool",
  ITEM_TYPE_WEAPON: "weapon",
  ITEM_SYSTEM_TYPE_AMMO: "ammo",
  MESSAGE_BUS_COLLAPSE_ALL: "collapse-all",
  MESSAGE_BUS_EXPAND_ALL: "expand-all",
  /**
   * Main button pressed, usually the left button or the un-initialized state
   */
  MOUSE_BUTTON_MAIN: 0,
  /**
   * Auxiliary button pressed, usually the wheel button or the middle button (if present)
   */
  MOUSE_BUTTON_AUXILIARY: 1,
  /**
   * Secondary button pressed, usually the right button
   */
  MOUSE_BUTTON_SECONDARY: 2,
  CONTEXT_MENU_TYPE_EFFECTS: "effects",
  CONTEXT_MENU_TYPE_ITEMS: "items",
  CONTEXT_MENU_TYPE_ITEM_ADVANCEMENT: "item-advancement",
  DND5E_CLASSES: {
    artificer: "TIDY5E.Class.Artificer",
    barbarian: "TIDY5E.Class.Barbarian",
    bard: "TIDY5E.Class.Bard",
    cleric: "TIDY5E.Class.Cleric",
    druid: "TIDY5E.Class.Druid",
    fighter: "TIDY5E.Class.Fighter",
    monk: "TIDY5E.Class.Monk",
    paladin: "TIDY5E.Class.Paladin",
    ranger: "TIDY5E.Class.Ranger",
    rogue: "TIDY5E.Class.Rogue",
    sorcerer: "TIDY5E.Class.Sorcerer",
    warlock: "TIDY5E.Class.Warlock",
    wizard: "TIDY5E.Class.Wizard",
    custom: "TIDY5E.Class.Custom"
  },
  CHARACTER_FAVORITE_SECTION_GENERIC: "generic",
  CHARACTER_FEAT_SECTION_BACKGROUND: "background",
  CHARACTER_FEAT_SECTION_CLASSES: "classes",
  CHARACTER_FEAT_SECTION_ACTIVE: "active",
  CHARACTER_FEAT_SECTION_PASSIVE: "passive",
  CHARACTER_FEAT_SECTION_RACE: "race",
  NPC_ABILITY_SECTION_WEAPONS: "weapons",
  NPC_ABILITY_SECTION_ACTIONS: "actions",
  NPC_ABILITY_SECTION_PASSIVE: "passive",
  NPC_ABILITY_SECTION_EQUIPMENT: "equipment",
  NPC_ABILITY_SECTION_CLASSES: "classes",
  TAB_OPTION_CLASS: "tab-option",
  TAB_CONTAINER_CONTENTS: "contents",
  TAB_CONTAINER_SECTION_CONTENTS: "contents",
  TAB_ITEM_DESCRIPTION_ID: "description",
  TAB_ITEM_DETAILS_ID: "details",
  TAB_ITEM_ADVANCEMENT_ID: "advancement",
  TAB_ITEM_EFFECTS_ID: "effects",
  TAB_CHARACTER_ATTRIBUTES: "attributes",
  TAB_CHARACTER_INVENTORY: "inventory",
  TAB_CHARACTER_SPELLBOOK: "spellbook",
  TAB_CHARACTER_FEATURES: "features",
  TAB_CHARACTER_EFFECTS: "effects",
  TAB_CHARACTER_BIOGRAPHY: "biography",
  TAB_CHARACTER_JOURNAL: "journal",
  TAB_MIGRATIONS_V1_ONBOARDING: "v1-onboarding",
  TAB_MIGRATIONS_CHARACTER_BIOGRAPHY: "character-bio",
  TAB_MIGRATIONS_NPC_DEATH: "npc-death",
  TAB_MIGRATIONS_CCSS_TO_TIDY: "ccss-to-tidy",
  TAB_MIGRATIONS_FAVORITES_TO_SYSTEM: "favorites-to-system",
  TAB_MIGRATIONS_BONDS_IDEALS_FLAWS_TO_SYSTEM: "bonds-ideals-flaws-to-system",
  TAB_MIGRATIONS_SPELL_CLASS_TO_SOURCE_CLASS: "spell-class-to-source-class",
  TAB_MIGRATIONS_NPC_EXHAUSTION: "npc-exhaustion",
  TAB_NPC_ABILITIES: "attributes",
  TAB_NPC_INVENTORY: "inventory",
  TAB_NPC_SPELLBOOK: "spellbook",
  TAB_NPC_EFFECTS: "effects",
  TAB_NPC_BIOGRAPHY: "biography",
  TAB_NPC_JOURNAL: "journal",
  TAB_VEHICLE_ATTRIBUTES: "attributes",
  TAB_VEHICLE_CARGO_AND_CREW: "cargo",
  TAB_VEHICLE_EFFECTS: "effects",
  TAB_VEHICLE_DESCRIPTION: "biography",
  TAB_ACTOR_ACTIONS: "actions",
  TAB_WORLD_SETTINGS_CHARACTER: "world-settings-character",
  TAB_WORLD_SETTINGS_NPC: "world-settings-npc",
  TAB_WORLD_SETTINGS_VEHICLE: "world-settings-vehicle",
  TAB_WORLD_SETTINGS_ICONS: "world-settings-icons",
  TAB_WORLD_SETTINGS_ITEM: "world-settings-item",
  TAB_WORLD_SETTINGS_EXHAUSTION: "world-settings-exhaustion",
  TAB_WORLD_SETTINGS_SHEETLOCK: "world-settings-sheet-lock",
  TAB_WORLD_SETTINGS_MISC: "world-settings-misc",
  TAB_USER_SETTINGS_PLAYERS: "user-settings-players",
  TAB_USER_SETTINGS_NPCS: "user-settings-npcs",
  TAB_USER_SETTINGS_VEHICLES: "user-settings-vehicles",
  TAB_USER_SETTINGS_ACTIONS_LIST: "user-settings-actions-list",
  THEME_EXTENSION_WITH_DOT: ".tidy5e-theme",
  THEME_ID_DEFAULT_LIGHT: "light",
  THEME_ID_DEFAULT_DARK: "dark",
  THEME_ID_DEFAULT: "default",
  SHEET_TYPE_CHARACTER: "character",
  SHEET_TYPE_NPC: "npc",
  SHEET_TYPE_VEHICLE: "vehicle",
  SHEET_TYPE_CONTAINER: "container",
  SHEET_LAYOUT_ALL: "all",
  SHEET_LAYOUT_CLASSIC: "classic",
  CIRCULAR_PORTRAIT_OPTION_ALL: "all",
  CIRCULAR_PORTRAIT_OPTION_CHARACTER: "pc",
  CIRCULAR_PORTRAIT_OPTION_NPCVEHICLE: "npc-vehicle",
  CIRCULAR_PORTRAIT_OPTION_NONE: "none",
  SPELL_PREPARATION_MODE_INNATE: "innate",
  SPELL_PREPARATION_MODE_PREPARED: "prepared",
  SPELL_PREPARATION_MODE_ALWAYS: "always",
  SPELL_PREPARATION_MODE_PACT: "pact",
  SPELL_PREPARATION_MODE_ATWILL: "atwill",
  SPELL_PREPARATION_MODE_RITUAL: "ritual",
  SPELL_SLOT_TRACKER_MODE_PREFERENCE: "spellSlotTrackerMode",
  SPELL_SLOT_TRACKER_MODE_PIPS: "pips",
  SPELL_SLOT_TRACKER_MODE_VALUE_MAX: "value-max",
  CONTEXT_GRID_CELL_HOVER: "grid-cell-hover",
  CLASS_TIDY_USE_CORE_LISTENERS: "tidy-use-core-listeners",
  CLASS_SELECTOR_TIDY_USE_CORE_LISTENERS: ".tidy-use-core-listeners",
  CLASS_ACTOR_SHEET_5E: "ActorSheet5e",
  HTML_DYNAMIC_RENDERING_ATTRIBUTE: 'data-tidy-render-scheme="handlebars"',
  HTML_DYNAMIC_RENDERING_ATTRIBUTE_SELECTOR: '[data-tidy-render-scheme="handlebars"]',
  /** The attribute which indicates a particular part of a sheet. */
  SHEET_PART_ATTRIBUTE: "data-tidy-sheet-part",
  SHEET_PARTS: {
    /** An interactable control that can open configuration settings for a target ability. */
    ABILITY_CONFIGURATION_CONTROL: "ability-configuration-control",
    /** A rollable/interactable element which rolls an ability save or test. */
    ABILITY_ROLLER: "ability-roller",
    /** An interactable toggle for ability saving throw proficiency. */
    ABILITY_SAVE_PROFICIENCY_TOGGLE: "ability-save-proficiency-toggle",
    /** An ability score (e.g., "str", "dex", "wis", etc.), whether readonly or editable. */
    ABILITY_SCORE: "ability-score",
    /** A rollable/interactable element which rolls an ability save. */
    ABILITY_SAVE_ROLLER: "ability-save-roller",
    /** A container for a given ability score (e.g., "str", "dex", "wis", etc.). */
    ABILITY_SCORE_CONTAINER: "ability-score-container",
    /** A rollable/interactable element which rolls an ability test. */
    ABILITY_TEST_ROLLER: "ability-test-roller",
    /** A container which houses an actor portrait and other parts related to actor portrait features. */
    ACTOR_PORTRAIT_CONTAINER: "actor-portrait-container",
    /** An overlay element for an actor portrait which provides a visual representation of remaining health. */
    ACTOR_PORTRAIT_HEALTH_OVERLAY: "actor-portrait-health-overlay",
    /** An actor portrait image element. */
    ACTOR_PORTRAIT_IMAGE: "actor-portrait-image",
    /** An actor trait container, such as Senses, Languages, or Tools. */
    ACTOR_TRAIT: "actor-trait",
    /** The specific details of an actor trait container, such as Senses, Languages, or Tools. */
    ACTOR_TRAIT_DETAILS: "actor-trait-details",
    /** A control for toggling a condition */
    CONDITION_TOGGLE: "condition-toggle",
    /** A container for all form fields related to a given damage part. */
    DAMAGE_PART_CONTAINER: "damage-part-container",
    /** An interactable control which the user can execute to delete a damage part to an item. */
    DAMAGE_PART_DELETE_COMMAND: "damage-part-delete-command",
    /** An input element which contains a damage part formula, usually for an item. */
    DAMAGE_PART_FORMULA: "damage-part-formula",
    /** An input element which represents the damage type of a damage part, usually for an item. */
    DAMAGE_PART_TYPE: "damage-part-type",
    /** An input for the number of failed death saves an actor has. */
    DEATH_SAVE_FAILURES: "death-save-failures",
    /** A rollable/interactable element which rolls a death saving throw. */
    DEATH_SAVE_ROLLER: "death-save-roller",
    /** An input for the number of successful death saves an actor has. */
    DEATH_SAVE_SUCCESSES: "death-save-successes",
    /** An interactable element which toggles a view */
    EXPANSION_TOGGLE: "table-expansion-toggle",
    /** An interactable element which toggles an inline container's contents view */
    INLINE_CONTAINER_TOGGLE: "inline-container-toggle",
    /** An interactable control which the user can execute to create an item (e.g., consumable, feature, loot, spell, weapon, etc.). */
    ITEM_CREATE_COMMAND: "item-create-command",
    /** An image element for an item. */
    ITEM_IMAGE: "item-image",
    /** The container element for an item image. */
    ITEM_IMAGE_CONTAINER: "item-image-container",
    /** An element which contains the name of an item. */
    ITEM_NAME: "item-name",
    /** A list-based tabular representation of items (e.g., equipment, loot, spells, etc.). */
    ITEM_TABLE: "item-table",
    /** The header row of an item table. */
    ITEM_TABLE_HEADER_ROW: "item-table-header-row",
    /** A row in an item table. */
    ITEM_TABLE_ROW: "item-table-row",
    /** An interactable control which the user can execute to use an item (e.g., consumable, feature, loot, spell, weapon, etc.). */
    ITEM_USE_COMMAND: "item-use-command",
    /** A series of properties related to an item, to be found on item summaries, item cards, and other locations where read-only item information is given. */
    ITEM_PROPERTY_LIST: "item-property-list",
    /** A series of properties related to an item, viewed from that item's sheet. These include read-only properties, currency value, and other situational input. */
    ITEM_SHEET_PROPERTIES: "item-sheet-properties",
    /** A summary of an item, usually taken from the item's chat data. */
    ITEM_SUMMARY: "item-summary",
    /** A containing element for a series of item lists or grids. */
    ITEMS_CONTAINER: "items-container",
    /** The element which contains the modifier text for melee spell attacks. */
    MELEE_SPELL_ATTACK_MOD: "melee-spell-attack-mod",
    /**
     * A container for a sheet name. The sheet name is usually in input, and its container has some additional styles associated with it.
     * The container typically sits in a sheet header row with other header-related elements.
     */
    NAME_CONTAINER: "name-container",
    /** The sheet header row where the sheet name appears. */
    NAME_HEADER_ROW: "name-header-row",
    /** A containing element for a series of item lists related to the NPC Abilities tab. */
    NPC_ABILITIES_CONTAINER: "npc-abilities-list",
    /** The element which contains the modifier text for ranged spell attacks. */
    RANGED_SPELL_ATTACK_MOD: "ranged-spell-attack-mod",
    /** A container for a single resource (first, second, third, etc.). */
    RESOURCE: "resource",
    /** The container where all known resources (first, second, third, etc.) are kept. */
    RESOURCES_CONTAINER: "resources-container",
    /** An interactable element that can clear the search input it is associated with. */
    SEARCH_CLEAR: "search-clear",
    /** A container for a search input and its search clearing interactable element. */
    SEARCH_CONTAINER: "search-container",
    /** A user input for performing searches. */
    SEARCH_INPUT: "search-input",
    /** An interactable control that can open configuration settings for a target skill. */
    SKILL_CONFIGURATION_CONTROL: "skill-configuration-control",
    /** A container for a single skill, including its roller, proficiency toggle, and any other elements related to the skill. */
    SKILL_CONTAINER: "skill-container",
    /** An interactable toggle for skill proficiency. */
    SKILL_PROFICIENCY_TOGGLE: "skill-proficiency-toggle",
    /** A rollable/interactable element which rolls a skill check. */
    SKILL_ROLLER: "skill-roller",
    /** A list of skills for the target actor. */
    SKILLS_LIST: "skills-list",
    /** An interactable toggle for showing/hiding unproficienct skills. */
    SKILLS_SHOW_PROFICIENT_TOGGLE: "skills-show-proficiency-toggle",
    /** The element which contains the modifier text for spell attacks in general. This field is shown when melee and ranged spell attack mods are the same. */
    SPELL_ATTACK_MOD: "spell-attack-mod",
    /** The element which contains spell DC. */
    SPELL_DC: "spell-dc",
    /** A cell in a table row. */
    TABLE_CELL: "table-cell",
    /** A cell in a table's header row. */
    TABLE_HEADER_CELL: "table-header-cell",
    /** The header row in a table. */
    TABLE_HEADER_ROW: "table-header-row",
    /** A row in a table. */
    TABLE_ROW: "table-row",
    /** An interactable control that can open configuration settings for a target tool. */
    TOOL_CONFIGURATION_CONTROL: "tool-configuration-control",
    /** A container for a single tool, including its roller, proficiency toggle, and any other elements related to the tool. */
    TOOL_CONTAINER: "tool-container",
    /** An interactable toggle for tool proficiency. */
    TOOL_PROFICIENCY_TOGGLE: "tool-proficiency-toggle",
    /** A rollable/interactable element which rolls a tool check. */
    TOOL_ROLLER: "tool-roller",
    /** A list of tools for the target actor. */
    TOOLS_LIST: "tools-list",
    /** A toolbar that usually sits at the top of a section of content, providing features like search, filtering, etc. */
    UTILITY_TOOLBAR: "utility-toolbar",
    /** A toolbar command, usually a button */
    UTILITY_TOOLBAR_COMMAND: "utility-toolbar-command"
  },
  ACTIVATION_COST_ACTION: "action",
  ACTIVATION_COST_BONUS: "bonus",
  ACTIVATION_COST_CREW: "crew",
  ACTIVATION_COST_LAIR: "lair",
  ACTIVATION_COST_LEGENDARY: "legendary",
  ACTIVATION_COST_MYTHIC: "mythic",
  ACTIVATION_COST_NONE: "none",
  ACTIVATION_COST_REACTION: "reaction",
  ACTIVATION_COST_SPECIAL: "special",
  LIMITED_USES_PER_CHARGES: "charges",
  LIMITED_USES_PER_DAWN: "dawn",
  LIMITED_USES_PER_DAY: "day",
  LIMITED_USES_PER_DUSK: "dusk",
  LIMITED_USES_PER_LONG_REST: "lr",
  LIMITED_USES_PER_SHORT_REST: "sr",
  SHEET_SETTINGS_OPTION_NONE: "none",
  SHEET_SETTINGS_OPTION_GM_ONLY: "gm-only",
  SHEET_SETTINGS_OPTION_GM_AND_OWNERS: "gm-and-owners",
  TEXT_EDITOR_ACTIVATION_ELEMENT_SELECTOR: ".editor-content[data-edit]",
  SVELTE_CONTEXT: {
    ACCORDION_CONTEXT: "accordionContext",
    APP_ID: "appId",
    APPLY: "apply",
    BUTTON_MENU_CONTEXT: "buttonMenuContext",
    CARD: "card",
    CONFIRM: "confirm",
    CONTEXT: "context",
    CURRENT_TAB_ID: "currentTabId",
    EXPANDED_ITEM_DATA: "expandedItemData",
    EXPANDED_ITEMS: "expandedItems",
    FUNCTIONS: "functions",
    INITIAL_TAB_ID: "initialTabId",
    INLINE_CONTAINER_TOGGLE_SERVICE: "inlineContainerToggleService",
    ITEM_FILTER_SERVICE: "itemFilterService",
    ITEM_IDS_TO_SHOW: "itemIdsToShow",
    ITEM_TABLE_TOGGLES: "itemTableToggles",
    LOCATION: "location",
    MESSAGE_BUS: "messageBus",
    ON_FILTER_CLEAR_ALL: "onFilterClearAll",
    ON_FILTER: "onFilter",
    ON_ITEM_TABLE_TOGGLE: "onItemTableToggle",
    ON_ITEM_TOGGLED: "onItemToggled",
    ON_SEARCH: "onSearch",
    ON_TAB_SELECTED: "onTabSelected",
    SEARCH_FILTERS: "searchFilters",
    STATS: "stats",
    TAB_ID: "tabId",
    USE_DEFAULT: "useDefault",
    VALIDATE: "validate"
  }
};
function debug(msg, args) {
  if (SettingsProvider.settings.debug.get()) {
    let formattedMsg = `DEBUG | ${CONSTANTS.MODULE_ID} | ${msg}`;
    if (args !== void 0) {
      console.log(formattedMsg, args);
    } else {
      console.log(formattedMsg);
    }
  }
}
function log(message, args) {
  message = `${CONSTANTS.MODULE_ID} | ${message}`;
  const formattedLog = message.replace("<br>", "\n");
  {
    console.log(formattedLog);
  }
}
function warn(warning, notify2 = false, args) {
  warning = `${CONSTANTS.MODULE_ID} | ${warning}`;
  if (notify2) {
    ui.notifications?.warn(warning);
  }
  const formattedWarning = warning.replace("<br>", "\n");
  if (args !== void 0) {
    console.warn(formattedWarning, args);
  } else {
    console.warn(formattedWarning);
  }
}
function error(message, notify2 = true, args) {
  message = `${CONSTANTS.MODULE_ID} | ${message}`;
  if (notify2) {
    ui.notifications?.error(message);
  }
  if (args !== void 0) {
    console.error(message, args);
  } else {
    console.error(message);
  }
}
class ResetSettingsDialog extends FormApplication {
  constructor(...args) {
    super(...args);
    return new Dialog({
      title: FoundryAdapter.localize(`TIDY5E.Settings.Reset.dialogs.title`),
      content: '<p style="margin-bottom:1rem;">' + FoundryAdapter.localize(`TIDY5E.Settings.Reset.dialogs.content`) + "</p>",
      buttons: {
        confirm: {
          icon: '<i class="fas fa-check"></i>',
          label: FoundryAdapter.localize(`TIDY5E.Settings.Reset.dialogs.confirm`),
          callback: async () => {
            const storedSettings = game.settings.storage.get("world").filter(
              (setting) => setting.key.startsWith(`${CONSTANTS.MODULE_ID}.`)
            );
            for (let setting of storedSettings) {
              log(`Reset setting '${setting.key}'`);
              await setting.delete();
            }
          }
        },
        cancel: {
          icon: '<i class="fas fa-times"></i>',
          label: FoundryAdapter.localize(`TIDY5E.Settings.Reset.dialogs.cancel`)
        }
      },
      default: "cancel"
    });
  }
  async _updateObject(...args) {
  }
}
const defaultDarkTheme = {
  name: "TIDY5E.Settings.SheetTheme.dark",
  id: CONSTANTS.THEME_ID_DEFAULT_DARK,
  description: "The default Tidy 5e Dark theme.",
  variables: {
    "--t5e-title-font-family": "'Modesto Condensed', 'Palatino Linotype', serif",
    "--t5e-body-font-family": "'Signika', sans-serif",
    "--t5e-primary-font-color": "rgba(255, 255, 255, 0.8)",
    "--t5e-background": "rgba(30, 30, 30, 1)",
    "--t5e-faintest-color": "rgba(255, 255, 255, 0.05)",
    "--t5e-faint-color": "rgba(255, 255, 255, 0.1)",
    "--t5e-light-color": "rgba(255, 255, 255, 0.25)",
    "--t5e-primary-color": "rgba(255, 255, 255, 0.8)",
    "--t5e-secondary-color": "rgba(255, 255, 255, 0.65)",
    "--t5e-tertiary-color": "rgba(255, 255, 255, 0.4)",
    "--t5e-primary-accent-color": "hsl(23.53, 80%, 50%)",
    "--spell-level-button-available-slots-text-color": "white",
    "--t5e-white": "rgba(0, 0, 0, 1)",
    "--t5e-faint-white": "rgba(255, 255, 255, 0.2)",
    "--t5e-linked-accent-color": "rgba(0, 255, 0, 0.75)",
    "--t5e-unlinked-accent-color": "rgba(255, 0, 0, 0.75)",
    "--t5e-linked-light-color": "rgba(0, 255, 0, 0.4)",
    "--t5e-unlinked-light-color": "rgba(255, 0, 0, 0.4)",
    "--t5e-sheet-unlocked-icon-background": "rgba(0, 150, 100, 0.6)",
    "--t5e-sheet-locked-icon-background": "rgba(255, 0, 0, 0.6)",
    "--t5e-header-background": "rgba(255, 255, 255, 0.05)",
    "--t5e-prepareable-color": "rgba(119, 136, 153, 1)",
    "--t5e-equipped-background": "rgba(0, 250, 180, 0.3)",
    "--t5e-equipped-item-grid-tile-outline-color": "rgba(50, 205, 50, 1)",
    "--t5e-equipped-item-grid-tile-accent-color": "rgba(173, 255, 47, 1)",
    "--t5e-prepared-background": "rgba(0, 250, 180, 0.3)",
    "--t5e-prepared-item-grid-tile-outline-color": "rgba(50, 205, 50, 1)",
    "--t5e-prepared-item-grid-tile-accent-color": "rgba(173, 255, 47, 1)",
    "--t5e-pact-background": "rgba(250, 0, 180, 0.3)",
    "--t5e-pact-outline-color": "rgba(250, 50, 213, 1)",
    "--t5e-pact-accent-color": "rgba(198, 119, 193, 1)",
    "--t5e-atwill-background": "rgba(226, 246, 4, 0.3)",
    "--t5e-atwill-outline-color": "rgba(163, 165, 50, 1)",
    "--t5e-atwill-accent-color": "rgba(255, 242, 0, 1)",
    "--t5e-innate-background": "rgba(255, 0, 0, 0.3)",
    "--t5e-innate-outline": "rgba(231, 23, 23, 1)",
    "--t5e-innate-accent": "rgba(195, 69, 69, 1)",
    "--t5e-ritual-only-background": "hsl(260.36deg 50% 21.96%)",
    "--t5e-ritual-only-outline-color": "hsl(260.36deg 50% 21.96%)",
    "--t5e-ritual-only-accent-color": "hsl(260.36deg 50% 21.96%)",
    "--t5e-alwaysprepared-background": "rgba(0, 100, 255, 0.3)",
    "--t5e-alwaysprepared-outline-color": "rgba(65, 105, 225, 1)",
    "--t5e-alwaysprepared-accent-color": "rgba(0, 191, 255, 1)",
    "--t5e-magic-accent-color": "#ada11a",
    "--t5e-attunement-required-color": "var(--t5e-light-color)",
    "--t5e-attuned-color": "var(--t5e-primary-accent-color)",
    "--t5e-attuned-item-grid-icon-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-xp-bar-background": "rgba(94, 225, 146, 1)",
    "--t5e-encumbrance-bar-background": "rgba(108, 138, 165, 1)",
    "--t5e-encumbrance-bar-outline-color": "var(--t5e-separator-color)",
    "--t5e-encumbrance-outline-color": "rgba(0, 0, 0, 0.9)",
    "--t5e-encumbrance-text-color": "rgba(238, 238, 238, 1)",
    "--t5e-encumbrance-bar-text-shadow-color": "#000",
    "--t5e-warning-accent-color": "rgba(255, 30, 0, 0.65)",
    "--t5e-warning-accent-contrast-color": "rgba(255, 255, 255, 0.8)",
    "--t5e-icon-background": "rgba(30, 30, 30, 1)",
    "--t5e-icon-shadow-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-icon-outline-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-icon-font-color": "rgba(255, 255, 255, 0.4)",
    "--t5e-icon-hover-color": "rgba(255, 255, 255, 0.8)",
    "--t5e-ability-modifiers-hover-label-background": "rgba(0, 0, 0, 0.9)",
    "--t5e-exhaustion-severity1-background": "rgba(255, 230, 0, 1)",
    "--t5e-exhaustion-severity2-background": "rgba(255, 130, 0, 1)",
    "--t5e-exhaustion-severity3-background": "rgba(255, 50, 0, 1)",
    "--t5e-ability-accent-background": "rgb(80, 80, 80)",
    "--t5e-context-outline-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-context-shadow-color": "rgba(0, 0, 0, 0.65)",
    "--t5e-check-default-background-image": "url('../../modules/tidy5e-sheet/images/check-dark-unchecked.svg')",
    "--t5e-check-checked-background-image": "url('../../modules/tidy5e-sheet/images/check-light-checked.svg')",
    "--t5e-checkbox-font-color": "rgba(255, 255, 255, 0.8)",
    "--t5e-checkbox-outline-color": "rgba(50, 50, 50, 1)",
    "--t5e-checkbox-unchecked-color": "rgba(75, 75, 75, 1)",
    "--t5e-checkbox-checked-color": "hsl(120deg 100% 40% / 50%)",
    "--t5e-item-input-background": "rgba(255, 255, 255, 0.1)",
    "--t5e-item-input-hover-background": "rgba(255, 255, 255, 0.2)",
    "--t5e-death-save-icon-color": "rgba(255, 255, 255, 0.75)",
    "--t5e-death-save-text-color": "white",
    "--t5e-inspiration-hover-color": "rgba(255, 255, 255, 0.75)",
    "--t5e-inspiration-text-shadow-hover-color": "rgba(118, 228, 255, 0.5)",
    "--t5e-inspiration-inspired-text-shadow-color": "#76e4ff",
    "--t5e-inspiration-inspired-background": "rgba(153, 153, 153, 1)",
    "--t5e-vehicle-motion-hover-color": "rgba(255, 255, 255, 0.75)",
    "--t5e-vehicle-motion-text-shadow-hover-color": "rgba(118, 228, 255, 0.5)",
    "--t5e-vehicle-in-motion-text-shadow-color": "#76e4ff",
    "--t5e-vehicle-in-motion-background": "rgba(153, 153, 153, 1)",
    "--t5e-hp-bar-color": "rgba(50, 149, 50, 0.6)",
    "--t5e-resource-bar-color": "rgba(21, 51, 98, 1)",
    "--t5e-death-save-backdrop-background": "rgba(255, 0, 0, 0.5)",
    "--t5e-death-save-text-shadow-color": "rgb(34, 34, 34)",
    "--t5e-hp-overlay-background": "rgba(255, 0, 0, 1)",
    "--t5e-inventory-grid-image-contrast-text-shadow-color": "rgba(0, 0, 0, 1)",
    "--t5e-inventory-grid-hover-use-item-contrast-text-shadow-color": "rgba(255, 255, 255, 1)",
    "--t5e-sheet-background": "var(--t5e-background)",
    "--t5e-item-info-card-background": "var(--t5e-background)",
    "--t5e-content-entity-link-color": "var(--t5e-primary-font-color)",
    "--t5e-content-entity-link-hover-color": "var(--t5e-primary-font-color)",
    "--t5e-content-entity-link-background": "var(--t5e-faint-color)",
    "--t5e-content-entity-link-hover-background": "var(--t5e-primary-accent-color)",
    "--t5e-activated-profile-toggle-color": "var(--t5e-primary-font-color)",
    "--t5e-exhaustion-severity1-color": "var(--t5e-icon-outline-color)",
    "--t5e-exhaustion-severity2-color": "rgba(255, 255, 255, 0.7)",
    "--t5e-exhaustion-severity3-color": "rgba(255, 255, 255, 0.7)",
    "--t5e-tinymce-toolbar-background": "#fff",
    "--t5e-tinymce-sidebar-background": "var(--t5e-secondary-color)",
    "--t5e-tinyme-toolbar-button-color": "#222",
    "--t5e-prosemirror-button-color": "rgba(100, 100, 100, 1)",
    "--t5e-prosemirror-dropdown-item-hover-color": "rgba(50, 50, 50, 1)",
    "--t5e-item-info-card-box-shadow-color": "rgba(0, 0, 0, 0.5)",
    "--t5e-sheet-lock-icon-color": "rgba(255, 255, 255, 0.6)",
    "--t5e-grid-pane-favorite-icon-color": "rgba(0, 200, 100, 1)",
    "--t5e-settings-dialog-box-shadow-color": "rgba(0, 0, 0, 0.75)",
    "--t5e-sheet-lock-icon-hover-color": "#fff",
    "--t5e-settings-dialog-border-color": "#ff6400",
    "--t5e-spell-level-button-border-color": "#c9c7b8",
    "--t5e-ability-modifiers-label-text-color": "#fff",
    "--t5e-ability-mod-text-color": "#fff",
    "--t5e-ability-mod-save-text-hover-color": "#fff",
    "--t5e-button-menu-background": "var(--t5e-sheet-background)",
    "--t5e-button-menu-hover-color": "var(--t5e-faint-color)",
    "--t5e-button-menu-divider-color": "var(--t5e-separator-color)",
    "--t5e-focus-visible-box-shadow": "-0.0625rem -0.0625rem 0 var(--t5e-primary-accent-color), -0.0625rem 0.0625rem 0 var(--t5e-primary-accent-color), 0.0625rem 0.0625rem 0 var(--t5e-primary-accent-color), 0.0625rem -0.0625rem 0 var(--t5e-primary-accent-color)",
    "--t5e-button-background": "var(--t5e-faintest-color)",
    "--t5e-button-hover-background": "var(--t5e-faint-color)",
    "--t5e-button-disabled-color": "var(--t5e-light-color)",
    "--t5e-separator-color": "rgba(120, 120, 120, 0.1)",
    "--t5e-table-header-row-color": "#111111",
    "--t5e-table-header-row-border-color": "#111111",
    "--t5e-tab-strip-border-color": "transparent",
    "--t5e-tabs-background": "var(--t5e-header-background)",
    "--t5e-active-tab-background": "var(--t5e-sheet-background)",
    "--t5e-tab-background": "transparent",
    "--t5e-scrollbar-thumb-color": "#782e22",
    "--t5e-scrollbar-track-color": "#0000",
    "--t5e-spell-pip-active-background": "var(--t5e-primary-accent-color)",
    "--t5e-spell-pip-empty-background": "transparent",
    "--t5e-spell-pip-border-color": "var(--t5e-primary-accent-color)",
    "--t5e-switch-slider-color": "#DDD"
  },
  type: "dark"
};
const defaultLightTheme = {
  name: "TIDY5E.Settings.SheetTheme.light",
  id: CONSTANTS.THEME_ID_DEFAULT_LIGHT,
  description: "The default Tidy 5e Light theme.",
  variables: {
    "--t5e-title-font-family": "'Modesto Condensed', 'Palatino Linotype', serif",
    "--t5e-body-font-family": "'Signika', sans-serif",
    "--t5e-primary-font-color": "rgba(0, 0, 0, 0.9)",
    "--t5e-background": "#f1ebe8",
    "--t5e-faintest-color": "rgba(0, 0, 0, 0.05)",
    "--t5e-faint-color": "rgba(0, 0, 0, 0.1)",
    "--t5e-light-color": "rgba(0, 0, 0, 0.25)",
    "--t5e-primary-color": "rgba(0, 0, 0, 0.9)",
    "--t5e-secondary-color": "rgba(0, 0, 0, 0.65)",
    "--t5e-tertiary-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-primary-accent-color": "rgba(255, 100, 0, 1)",
    "--spell-level-button-available-slots-text-color": "white",
    "--t5e-white": "rgba(255, 255, 255, 1)",
    "--t5e-faint-white": "rgba(255, 255, 255, 0.2)",
    "--t5e-linked-accent-color": "rgba(0, 255, 0, 0.75)",
    "--t5e-unlinked-accent-color": "rgba(255, 0, 0, 0.75)",
    "--t5e-linked-light-color": "rgba(0, 255, 0, 0.4)",
    "--t5e-unlinked-light-color": "rgba(255, 0, 0, 0.4)",
    "--t5e-sheet-unlocked-icon-background": "rgba(0, 150, 100, 0.6)",
    "--t5e-sheet-locked-icon-background": "rgba(255, 0, 0, 0.6)",
    "--t5e-header-background": "rgba(255, 255, 255, 0.2)",
    "--t5e-prepareable-color": "rgba(119, 136, 153, 1)",
    "--t5e-equipped-background": "rgba(50, 205, 50, 0.3)",
    "--t5e-equipped-item-grid-tile-outline-color": "rgba(50, 205, 50, 1)",
    "--t5e-equipped-item-grid-tile-accent-color": "rgba(173, 255, 47, 1)",
    "--t5e-prepared-background": "rgba(50, 205, 50, 0.3)",
    "--t5e-prepared-item-grid-tile-outline-color": "rgba(50, 205, 50, 1)",
    "--t5e-prepared-item-grid-tile-accent-color": "rgba(173, 255, 47, 1)",
    "--t5e-pact-background": "rgba(250, 0, 180, 0.3)",
    "--t5e-pact-outline-color": "rgba(250, 50, 213, 1)",
    "--t5e-pact-accent-color": "rgba(198, 119, 193, 1)",
    "--t5e-atwill-background": "rgba(226, 246, 4, 0.3)",
    "--t5e-atwill-outline-color": "rgba(163, 165, 50, 1)",
    "--t5e-atwill-accent-color": "rgba(255, 242, 0, 1)",
    "--t5e-innate-background": "rgba(255, 0, 0, 0.3)",
    "--t5e-innate-outline": "rgba(231, 23, 23, 1)",
    "--t5e-innate-accent": "rgba(195, 69, 69, 1)",
    "--t5e-ritual-only-background": "hsl(260.09deg 100% 45.1% / 25.88%)",
    "--t5e-ritual-only-outline-color": "hsl(260.09deg 100% 45.1% / 25.88%)",
    "--t5e-ritual-only-accent-color": "hsl(260.09deg 100% 45.1% / 25.88%)",
    "--t5e-alwaysprepared-background": "rgba(0, 0, 255, 0.15)",
    "--t5e-alwaysprepared-outline-color": "rgba(65, 105, 225, 1)",
    "--t5e-alwaysprepared-accent-color": "rgba(0, 191, 255, 1)",
    "--t5e-magic-accent-color": "#ada11a",
    "--t5e-attunement-required-color": "var(--t5e-light-color)",
    "--t5e-attuned-color": "var(--t5e-primary-accent-color)",
    "--t5e-attuned-item-grid-icon-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-xp-bar-background": "rgba(94, 225, 146, 1)",
    "--t5e-encumbrance-bar-background": "rgba(108, 138, 165, 1)",
    "--t5e-encumbrance-bar-outline-color": "var(--t5e-separator-color)",
    "--t5e-encumbrance-outline-color": "rgba(0, 0, 0, 0.9)",
    "--t5e-encumbrance-text-color": "rgba(238, 238, 238, 1)",
    "--t5e-encumbrance-bar-text-shadow-color": "#000",
    "--t5e-warning-accent-color": "rgba(255, 0, 0, 0.6)",
    "--t5e-warning-accent-contrast-color": "rgba(255, 255, 255, 0.8)",
    "--t5e-icon-background": "rgba(236, 233, 223, 1)",
    "--t5e-icon-shadow-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-icon-outline-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-icon-font-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-icon-hover-color": "rgba(0, 0, 0, 0.9)",
    "--t5e-ability-modifiers-hover-label-background": "rgba(0, 0, 0, 0.9)",
    "--t5e-exhaustion-severity1-background": "rgba(255, 230, 0, 1)",
    "--t5e-exhaustion-severity2-background": "rgba(255, 130, 0, 1)",
    "--t5e-exhaustion-severity3-background": "rgba(255, 50, 0, 1)",
    "--t5e-ability-accent-background": "darkslategrey",
    "--t5e-context-outline-color": "rgba(0, 0, 0, 0.4)",
    "--t5e-context-shadow-color": "rgba(0, 0, 0, 0.65)",
    "--t5e-check-default-background-image": "url('../../modules/tidy5e-sheet/images/check-dark-unchecked.svg')",
    "--t5e-check-checked-background-image": "url('../../modules/tidy5e-sheet/images/check-dark-checked.svg')",
    "--t5e-checkbox-font-color": "rgba(0, 0, 0, 0.9)",
    "--t5e-checkbox-outline-color": "rgba(150, 150, 150, 1)",
    "--t5e-checkbox-unchecked-color": "#d8d7d1",
    "--t5e-checkbox-checked-color": "rgba(0, 255, 0, 0.3)",
    "--t5e-item-input-background": "rgba(255, 255, 255, 0.3)",
    "--t5e-item-input-hover-background": "rgba(255, 255, 255, 0.5)",
    "--t5e-death-save-icon-color": "rgba(255, 255, 255, 0.75)",
    "--t5e-death-save-text-color": "white",
    "--t5e-inspiration-hover-color": "rgba(255, 255, 255, 0.75)",
    "--t5e-inspiration-text-shadow-hover-color": "rgba(118, 228, 255, 0.5)",
    "--t5e-inspiration-inspired-text-shadow-color": "#76e4ff",
    "--t5e-inspiration-inspired-background": "rgba(153, 153, 153, 1)",
    "--t5e-vehicle-motion-hover-color": "rgba(255, 255, 255, 0.75)",
    "--t5e-vehicle-motion-text-shadow-hover-color": "rgba(118, 228, 255, 0.5)",
    "--t5e-vehicle-in-motion-text-shadow-color": "#76e4ff",
    "--t5e-vehicle-in-motion-background": "rgba(153, 153, 153, 1)",
    "--t5e-hp-bar-color": "rgba(0, 200, 0, 0.6)",
    "--t5e-resource-bar-color": "rgba(120, 167, 242, 1)",
    "--t5e-death-save-backdrop-background": "rgba(255, 0, 0, 0.5)",
    "--t5e-death-save-text-shadow-color": "rgb(34, 34, 34)",
    "--t5e-hp-overlay-background": "rgba(255, 0, 0, 1)",
    "--t5e-inventory-grid-image-contrast-text-shadow-color": "rgba(0, 0, 0, 1)",
    "--t5e-inventory-grid-hover-use-item-contrast-text-shadow-color": "rgba(255, 255, 255, 1)",
    "--t5e-item-info-card-background": `url(../../modules/tidy5e-sheet/images/parchment-texture-top.webp) no-repeat top center / 150% auto, #f1ebe8 url(../../modules/tidy5e-sheet/images/parchment-texture-bottom.webp) no-repeat bottom center / 150% auto;`,
    "--t5e-content-entity-link-color": "var(--t5e-primary-font-color)",
    "--t5e-content-entity-link-hover-color": "var(--t5e-white)",
    "--t5e-content-entity-link-background": "var(--t5e-faintest-color)",
    "--t5e-content-entity-link-hover-background": "var(--t5e-primary-accent-color)",
    "--t5e-activated-profile-toggle-color": "var(--t5e-white)",
    "--t5e-exhaustion-severity1-color": "var(--t5e-icon-font-color)",
    "--t5e-exhaustion-severity2-color": "rgba(255, 255, 255, 0.7)",
    "--t5e-exhaustion-severity3-color": "rgba(255, 255, 255, 0.7)",
    "--t5e-tinymce-toolbar-background": "transparent",
    "--t5e-prosemirror-button-color": "#deded3",
    "--t5e-prosemirror-dropdown-item-hover-color": "var(--t5e-faint-color)",
    "--t5e-item-info-card-box-shadow-color": "rgba(0, 0, 0, 0.5)",
    "--t5e-sheet-lock-icon-color": "rgba(255, 255, 255, 0.6)",
    "--t5e-grid-pane-favorite-icon-color": "rgba(0, 200, 100, 1)",
    "--t5e-settings-dialog-box-shadow-color": "rgba(0, 0, 0, 0.75)",
    "--t5e-sheet-lock-icon-hover-color": "#fff",
    "--t5e-settings-dialog-border-color": "#ff6400",
    "--t5e-spell-level-button-border-color": "#c9c7b8",
    "--t5e-ability-modifiers-label-text-color": "#fff",
    "--t5e-ability-mod-text-color": "#fff",
    "--t5e-ability-mod-save-text-hover-color": "#fff",
    "--t5e-button-menu-background": "var(--t5e-background)",
    "--t5e-button-menu-hover-color": "var(--t5e-faint-color)",
    "--t5e-button-menu-divider-color": "var(--t5e-separator-color)",
    "--t5e-focus-visible-box-shadow": "-0.0625rem -0.0625rem 0 var(--t5e-primary-accent-color), -0.0625rem 0.0625rem 0 var(--t5e-primary-accent-color), 0.0625rem 0.0625rem 0 var(--t5e-primary-accent-color), 0.0625rem -0.0625rem 0 var(--t5e-primary-accent-color)",
    "--t5e-button-background": "var(--t5e-faint-color)",
    "--t5e-button-hover-background": "var(--t5e-faintest-color)",
    "--t5e-button-disabled-color": "var(--t5e-light-color)",
    "--t5e-separator-color": "var(--t5e-light-color)",
    "--t5e-table-header-row-color": "var(--t5e-faint-color)",
    "--t5e-table-header-row-border-color": "var(--t5e-light-color)",
    "--t5e-tab-strip-border-color": "rgba(0, 0, 0, 0.25)",
    "--t5e-active-tab-background": "transparent",
    "--t5e-tab-background": "var(--t5e-header-background)",
    "--t5e-scrollbar-thumb-color": "#782e22",
    "--t5e-scrollbar-track-color": "#0000",
    "--t5e-spell-pip-active-background": "var(--t5e-primary-accent-color)",
    "--t5e-spell-pip-empty-background": "transparent",
    "--t5e-spell-pip-border-color": "var(--t5e-primary-accent-color)",
    "--t5e-switch-slider-color": "#FFF"
  },
  type: "light"
};
function getCoreThemes(includeDefault) {
  let themes = {};
  if (includeDefault) {
    themes[CONSTANTS.THEME_ID_DEFAULT] = "TIDY5E.Settings.SheetTheme.default";
  }
  themes[CONSTANTS.THEME_ID_DEFAULT_LIGHT] = defaultLightTheme.name;
  themes[CONSTANTS.THEME_ID_DEFAULT_DARK] = defaultDarkTheme.name;
  return themes;
}
function getThemes() {
  return {
    [CONSTANTS.THEME_ID_DEFAULT_LIGHT]: defaultLightTheme,
    [CONSTANTS.THEME_ID_DEFAULT_DARK]: defaultDarkTheme
  };
}
const themeVariables = {
  "--t5e-title-font-family": {
    type: "todo",
    group: "todo"
  },
  "--t5e-body-font-family": {
    type: "todo",
    group: "todo"
  },
  "--t5e-primary-font-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-faintest-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-faint-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-light-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-primary-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-secondary-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-tertiary-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-primary-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--spell-level-button-available-slots-text-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-white": {
    type: "todo",
    group: "todo"
  },
  "--t5e-faint-white": {
    type: "todo",
    group: "todo"
  },
  "--t5e-linked-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-unlinked-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-linked-light-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-unlinked-light-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-sheet-unlocked-icon-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-sheet-locked-icon-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-header-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-prepareable-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-equipped-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-equipped-item-grid-tile-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-equipped-item-grid-tile-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-prepared-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-prepared-item-grid-tile-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-prepared-item-grid-tile-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-pact-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-pact-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-pact-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-atwill-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-atwill-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-atwill-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-ritual-only-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-ritual-only-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-ritual-only-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-innate-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-innate-outline": {
    type: "todo",
    group: "todo"
  },
  "--t5e-innate-accent": {
    type: "todo",
    group: "todo"
  },
  "--t5e-alwaysprepared-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-alwaysprepared-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-alwaysprepared-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-magic-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-attunement-required-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-attuned-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-attuned-item-grid-icon-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-xp-bar-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-encumbrance-bar-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-encumbrance-bar-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-encumbrance-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-warning-accent-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-warning-accent-contrast-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-icon-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-icon-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-icon-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-icon-font-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-icon-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-ability-modifiers-hover-label-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-exhaustion-severity1-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-exhaustion-severity2-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-exhaustion-severity3-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-ability-accent-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-context-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-context-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-check-default-background-image": {
    type: "todo",
    group: "todo"
  },
  "--t5e-check-checked-background-image": {
    type: "todo",
    group: "todo"
  },
  "--t5e-checkbox-font-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-checkbox-outline-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-checkbox-unchecked-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-checkbox-checked-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-item-input-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-item-input-hover-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-encumbrance-text-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-death-save-icon-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-inspiration-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-inspiration-text-shadow-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-inspiration-inspired-text-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-inspiration-inspired-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-vehicle-motion-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-vehicle-motion-text-shadow-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-vehicle-in-motion-text-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-vehicle-in-motion-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-hp-bar-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-resource-bar-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-death-save-backdrop-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-death-save-text-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-hp-overlay-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-inventory-grid-image-contrast-text-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-inventory-grid-hover-use-item-contrast-text-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-sheet-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-item-info-card-background": {
    type: "todo",
    group: "todo,"
  },
  "--t5e-content-entity-link-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-content-entity-link-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-content-entity-link-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-content-entity-link-hover-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-activated-profile-toggle-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-exhaustion-severity1-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-exhaustion-severity2-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-exhaustion-severity3-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-death-save-text-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-tinymce-toolbar-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-tinymce-sidebar-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-tinyme-toolbar-button-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-prosemirror-button-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-prosemirror-dropdown-item-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-item-info-card-box-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-sheet-lock-icon-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-grid-pane-favorite-icon-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-settings-dialog-box-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-sheet-lock-icon-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-settings-dialog-border-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-spell-level-button-border-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-ability-modifiers-label-text-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-ability-mod-text-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-ability-mod-save-text-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-encumbrance-bar-text-shadow-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-button-menu-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-button-menu-hover-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-button-menu-divider-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-focus-visible-box-shadow": {
    type: "todo",
    group: "todo"
  },
  "--t5e-button-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-button-hover-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-button-disabled-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-separator-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-table-header-row-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-table-header-row-border-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-tab-strip-border-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-tabs-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-active-tab-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-tab-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-scrollbar-thumb-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-scrollbar-track-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-spell-pip-active-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-spell-pip-empty-background": {
    type: "todo",
    group: "todo"
  },
  "--t5e-spell-pip-border-color": {
    type: "todo",
    group: "todo"
  },
  "--t5e-switch-slider-color": {
    type: "todo",
    group: "todo"
  }
};
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, t = function(r2) {
  return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
}, n = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
}, e = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
}, u = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
}, a = function(r2) {
  return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
}, o = function(r2) {
  return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
}, i = /^#([0-9a-f]{3,8})$/i, s = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
}, h = function(r2) {
  var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
}, b = function(r2) {
  var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
  t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
  var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
  return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
}, g = function(r2) {
  return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
}, d = function(r2) {
  return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
}, f = function(r2) {
  return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
  var t2, n2, e2;
}, c = function(r2) {
  return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e2, u2;
}, l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, y = { string: [[function(r2) {
  var t2 = i.exec(r2);
  return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r2) {
  var t2 = v.exec(r2) || m.exec(r2);
  return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t2) {
  var n2 = l.exec(t2) || p.exec(t2);
  if (!n2) return null;
  var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return f(a2);
}, "hsl"]], object: [[function(r2) {
  var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
  return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
}, "rgb"], [function(r2) {
  var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
  if (!t(n2) || !t(e2) || !t(u2)) return null;
  var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
  return f(i2);
}, "hsl"], [function(r2) {
  var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
  if (!t(n2) || !t(a2) || !t(o2)) return null;
  var h2 = function(r3) {
    return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
  }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
  return b(h2);
}, "hsv"]] }, N = function(r2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var e2 = t2[n2][0](r2);
    if (e2) return [e2, t2[n2][1]];
  }
  return [null, void 0];
}, x = function(r2) {
  return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
}, M = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
}, H = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
}, $$1 = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
}, j = function() {
  function r2(r3) {
    this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r2.prototype.isValid = function() {
    return null !== this.parsed;
  }, r2.prototype.brightness = function() {
    return n(H(this.rgba), 2);
  }, r2.prototype.isDark = function() {
    return H(this.rgba) < 0.5;
  }, r2.prototype.isLight = function() {
    return H(this.rgba) >= 0.5;
  }, r2.prototype.toHex = function() {
    return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
    var r3, t2, e2, u2, a2, i2;
  }, r2.prototype.toRgb = function() {
    return o(this.rgba);
  }, r2.prototype.toRgbString = function() {
    return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsl = function() {
    return d(c(this.rgba));
  }, r2.prototype.toHslString = function() {
    return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsv = function() {
    return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
    var r3;
  }, r2.prototype.invert = function() {
    return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
    var r3;
  }, r2.prototype.saturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
  }, r2.prototype.desaturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
  }, r2.prototype.grayscale = function() {
    return w(M(this.rgba, -1));
  }, r2.prototype.lighten = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w($$1(this.rgba, r3));
  }, r2.prototype.darken = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w($$1(this.rgba, -r3));
  }, r2.prototype.rotate = function(r3) {
    return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
  }, r2.prototype.alpha = function(r3) {
    return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
    var t2;
  }, r2.prototype.hue = function(r3) {
    var t2 = c(this.rgba);
    return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
  }, r2.prototype.isEqual = function(r3) {
    return this.toHex() === w(r3).toHex();
  }, r2;
}(), w = function(r2) {
  return r2 instanceof j ? r2 : new j(r2);
};
function applyTheme(theme, colorPickerEnabledOverride = null) {
  try {
    const styleTagId = "tidy5e-sheet-theme";
    let existingThemeStyle = document.getElementById(styleTagId);
    if (existingThemeStyle) {
      existingThemeStyle.remove();
    }
    const overrideBaseTheme = colorPickerEnabledOverride === null && SettingsProvider.settings.colorPickerEnabled.get() || colorPickerEnabledOverride;
    if (overrideBaseTheme) {
      theme = overrideColorPickerSettings(theme);
    }
    document.head.insertAdjacentHTML(
      "beforeend",
      `
    <style id="${styleTagId}">
      :root {
        ${Object.entries(theme.variables).filter(([variable]) => variable in themeVariables).map(([variable, value]) => `${variable}: ${value};`).join("\n")}
      }
    </style>
    `
    );
  } catch (e2) {
    console.error(e2);
    debug(
      "Unable to apply Tidy 5e style tag; falling back to root style properties."
    );
    Object.keys(themeVariables).forEach((variable) => {
      document.documentElement.style.setProperty(
        variable,
        theme.variables[variable] ?? null
      );
    });
  }
}
function overrideColorPickerSettings(theme) {
  const overriddenTheme = structuredClone(theme);
  const themeableColors = getThemeableColors();
  for (let color of themeableColors) {
    overriddenTheme.variables[color.cssVariable] = SettingsProvider.settings[color.key].get()?.toString();
  }
  return overriddenTheme;
}
function applyCurrentTheme(colorPickerEnabledOverride = null) {
  const currentTheme = SettingsProvider.settings.colorScheme.get();
  SettingsProvider.settings.colorScheme.options.onChange(
    currentTheme,
    colorPickerEnabledOverride
  );
}
function getThemeableColors() {
  return Object.entries(SettingsProvider.settings).filter(([, value]) => "representsCssVariable" in value).map(([key, value]) => ({
    key,
    name: value.options.name,
    hint: "hint" in value.options ? value.options.hint : "",
    cssVariable: "representsCssVariable" in value ? value.representsCssVariable : ""
  }));
}
function getThemeOrDefault(themeId) {
  if (themeId === CONSTANTS.THEME_ID_DEFAULT) {
    const defaultThemeId = SettingsProvider.settings.defaultTheme.get();
    themeId = defaultThemeId;
  }
  const themes = {
    light: defaultLightTheme,
    dark: defaultDarkTheme
    // TODO: Aggregate all other available themes
  };
  return themes[themeId] ?? defaultLightTheme;
}
function trySetRootCssVariable(cssVariable, value, colorPickerEnabled) {
  if (colorPickerEnabled) {
    document.documentElement.style.setProperty(cssVariable, value);
  }
}
function clearTidy5eRootCssVariables() {
  Object.keys(themeVariables).forEach(
    (key) => document.documentElement.style.removeProperty(key)
  );
}
function colorToHexaString(color) {
  if (color?.isValid()) {
    return color.toHex();
  }
  return "";
}
function settingValueToHexaString(value) {
  const result = colorToHexaString(new j(value.toString()));
  if (result !== "") {
    return {
      original: value?.toString() ?? "",
      hexa: result,
      parsed: true
    };
  }
  var ctx = document.createElement("canvas").getContext("2d");
  if (ctx) {
    ctx.fillStyle = value?.toString() ?? "";
    return {
      original: value,
      hexa: ctx.fillStyle,
      parsed: true
    };
  }
  return {
    original: value,
    parsed: true
  };
}
function extractSettingsUpdateDeltaFromTheme(theme, themeableColors) {
  return Object.keys(theme.variables).reduce(
    (prev, key) => {
      const themeableColor = themeableColors.find((c2) => c2.cssVariable === key);
      if (themeableColor) {
        prev[themeableColor.key] = theme.variables[key];
      }
      return prev;
    },
    {}
  );
}
function validateImportFile(theme) {
  return theme.version === 1 && typeof theme.variables === "object";
}
function noop$1() {
}
const identity = (x2) => x2;
function assign(tar, src) {
  for (const k in src) tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 && typeof a2 === "object" || typeof a2 === "function";
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url) return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop$1;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props) if (k[0] !== "$") result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props) if (!keys.has(k) && k[0] !== "$") rest[k] = props[k];
  return rest;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
}
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$1;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0) raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0) raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function append(target, node) {
  target.appendChild(node);
}
function get_root_for_style(node) {
  if (!node) return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2]) iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function object_without_properties(obj, exclude) {
  const target = (
    /** @type {Pick<T, Exclude<keyof T, K>>} */
    {}
  );
  for (const k in obj) {
    if (has_prop(obj, k) && // @ts-ignore
    exclude.indexOf(k) === -1) {
      target[k] = obj[k];
    }
  }
  return target;
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function self(fn) {
  return function(event) {
    if (event.target === this) fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_custom_element_data_map(node, data_map) {
  Object.keys(data_map).forEach((key) => {
    set_custom_element_data(node, key, data_map[key]);
  });
}
function set_custom_element_data(node, prop, value) {
  const lower = prop.toLowerCase();
  if (lower in node) {
    node[lower] = typeof node[lower] === "boolean" && value === "" ? true : value;
  } else if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function set_dynamic_element_data(tag) {
  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data) return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, "");
  }
}
function select_option(select, value, mounting) {
  for (let i2 = 0; i2 < select.options.length; i2 += 1) {
    const option = select.options[i2];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_options(select, value) {
  for (let i2 = 0; i2 < select.options.length; i2 += 1) {
    const option = select.options[i2];
    option.selected = ~value.indexOf(option.__value);
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
class HtmlTag {
  /**
   * @private
   * @default false
   */
  is_svg = false;
  /** parent for creating node */
  e = void 0;
  /** html tag nodes */
  n = void 0;
  /** target */
  t = void 0;
  /** anchor */
  a = void 0;
  constructor(is_svg = false) {
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i2 = 0; i2 < this.n.length; i2 += 1) {
      insert(this.t, this.n[i2], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(component, props) {
  return new component(props);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i2 = str.length;
  while (i2--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i2);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a2, b2, duration, delay2, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t2 = a2 + (b2 - a2) * ease(p2);
    keyframes += p2 * 100 + `%{${fn(t2, 1 - t2)}}
`;
  }
  const rule = keyframes + `100% {${fn(b2, 1 - b2)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay2}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active) clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active) return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode) detach(ownerNode);
    });
    managed_styles.clear();
  });
}
function create_animation(node, from, fn, params) {
  if (!from) return noop$1;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
    return noop$1;
  const {
    delay: delay2 = 0,
    duration = 300,
    easing = identity,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay2,
    // @ts-ignore todo:
    end = start_time + duration,
    tick = noop$1,
    css
  } = fn(node, { from, to }, params);
  let running = true;
  let started = false;
  let name;
  function start() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay2, easing, css);
    }
    if (!delay2) {
      started = true;
    }
  }
  function stop() {
    if (css) delete_rule(node, name);
    running = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end) {
      tick(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p2 = now2 - start_time;
      const t2 = 0 + 1 * easing(p2 / duration);
      tick(t2, 1 - t2);
    }
    return true;
  });
  start();
  tick(0, 1);
  return stop;
}
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width, height } = style;
    const a2 = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a2);
  }
}
function add_transform(node, a2) {
  const b2 = node.getBoundingClientRect();
  if (a2.left !== b2.left || a2.top !== b2.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a2.left - b2.left}px, ${a2.top - b2.top}px)`;
  }
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function getAllContexts() {
  return get_current_component().$$.context;
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e2) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e2;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
  targets.forEach((c2) => c2());
  render_callbacks = filtered;
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  const options = { direction: "in" };
  let config = fn(node, params, options);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name) delete_rule(node, animation_name);
  }
  function go() {
    const {
      delay: delay2 = 0,
      duration = 300,
      easing = identity,
      tick = noop$1,
      css
    } = config || null_transition;
    if (css) animation_name = create_rule(node, 0, 1, duration, delay2, easing, css, uid++);
    tick(0, 1);
    const start_time = now() + delay2;
    const end_time = start_time + duration;
    if (task) task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t2 = easing((now2 - start_time) / duration);
          tick(t2, 1 - t2);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started) return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn, params) {
  const options = { direction: "out" };
  let config = fn(node, params, options);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  let original_inert_value;
  function go() {
    const {
      delay: delay2 = 0,
      duration = 300,
      easing = identity,
      tick = noop$1,
      css
    } = config || null_transition;
    if (css) animation_name = create_rule(node, 1, 0, duration, delay2, easing, css);
    const start_time = now() + delay2;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    if ("inert" in node) {
      original_inert_value = /** @type {HTMLElement} */
      node.inert;
      node.inert = true;
    }
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t2 = easing((now2 - start_time) / duration);
          tick(1 - t2, t2);
        }
      }
      return running;
    });
  }
  if (is_function(config)) {
    wait().then(() => {
      config = config(options);
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && "inert" in node) {
        node.inert = original_inert_value;
      }
      if (reset && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name) delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t2 = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name) delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d2 = (
      /** @type {Program['d']} */
      program.b - t2
    );
    duration *= Math.abs(d2);
    return {
      a: t2,
      b: program.b,
      d: d2,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b2) {
    const {
      delay: delay2 = 0,
      duration = 300,
      easing = identity,
      tick = noop$1,
      css
    } = config || null_transition;
    const program = {
      start: now() + delay2,
      b: b2
    };
    if (!b2) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b2) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t2, b2, duration, delay2, easing, css);
      }
      if (b2) tick(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b2, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t2,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick(t2 = running_program.b, 1 - t2);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r) run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p2 = now2 - running_program.start;
            t2 = running_program.a + running_program.d * easing(p2 / running_program.duration);
            tick(t2, 1 - t2);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b2) {
      if (is_function(config)) {
        wait().then(() => {
          const opts = { direction: b2 ? "in" : "out" };
          config = config(opts);
          go(b2);
        });
      } else {
        go(b2);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context2) {
  let o2 = old_blocks.length;
  let n2 = list.length;
  let i2 = o2;
  const old_indexes = {};
  while (i2--) old_indexes[old_blocks[i2].key] = i2;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i2 = n2;
  while (i2--) {
    const child_ctx = get_context2(ctx, list, i2);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i2] = block);
    if (key in old_indexes) deltas.set(key, Math.abs(i2 - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o2 && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o2 - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o2--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o2--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o2--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o2--;
    }
  }
  while (o2--) {
    const old_block = old_blocks[o2];
    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
  }
  while (n2) insert2(new_blocks[n2 - 1]);
  run_all(updates);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o2 = levels[i2];
    const n2 = updates[i2];
    if (n2) {
      for (const key in o2) {
        if (!(key in n2)) to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n2;
    } else {
      for (const key in o2) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2)) update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop$1,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2]) $$.bound[i2](value);
      if (ready) make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  /**
   * ### PRIVATE API
   *
   * Do not use, may change at any time
   *
   * @type {any}
   */
  $$ = void 0;
  /**
   * ### PRIVATE API
   *
   * Do not use, may change at any time
   *
   * @type {any}
   */
  $$set = void 0;
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$1;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop$1;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
const subscriber_queue = [];
function writable(value, start = noop$1) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
class SvelteFormApplicationBase extends FormApplication {
  component;
  staticExtraApplicationClasses = [];
  constructor(...args) {
    super(...args);
  }
  static get defaultOptions() {
    return {
      ...super.defaultOptions,
      classes: ["tidy5e-sheet", "application-shell"],
      submitOnClose: false,
      minimizable: true,
      popOut: true,
      resizable: true
    };
  }
  get template() {
    return FoundryAdapter.getTemplate("empty-form-template.hbs");
  }
  activateListeners(html) {
    const node = html.get(0);
    this.refreshContext();
    this.component = this.createComponent(node);
  }
  close(options = {}) {
    this.component?.$destroy();
    return super.close(options);
  }
  render(force = false, ...args) {
    if (force) {
      this.component?.$destroy();
      super.render(force, ...args);
      return this;
    }
    this.refreshContext();
    return this;
  }
  refreshContext() {
  }
  async _updateObject() {
  }
}
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const get_tab_end_slot_changes = (dirty) => ({});
const get_tab_end_slot_context = (ctx) => ({});
function get_each_context$1a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  child_ctx[23] = i2;
  return child_ctx;
}
function create_if_block$1U(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*tabs*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*tab*/
    ctx2[21].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1a(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1a(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*tabs, $settingStore, selectedTabId, $$slots, selectTab, onKeyDown, localize*/
      1955) {
        each_value = ensure_array_like(
          /*tabs*/
          ctx2[1]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$1a, each_1_anchor, get_each_context$1a);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$1a(key_1, ctx) {
  let button;
  let t0_value = (
    /*localize*/
    ctx[9](
      /*tab*/
      ctx[21].title
    ) + ""
  );
  let t0;
  let t1;
  let button_data_tab_id_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[14](
        /*tab*/
        ctx[21]
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[15](
        /*i*/
        ctx[23],
        ...args
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      attr(button, "type", "button");
      attr(button, "class", CONSTANTS.TAB_OPTION_CLASS + " inline-transparent-button svelte-18up2de");
      attr(button, "data-tab-id", button_data_tab_id_value = /*tab*/
      ctx[21].id);
      attr(button, "role", "tab");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      toggle_class(
        button,
        "active",
        /*tab*/
        ctx[21].id === /*selectedTabId*/
        ctx[0]
      );
      toggle_class(
        button,
        "first-tab",
        /*i*/
        ctx[23] === 0
      );
      toggle_class(button, "no-border-on-last-tab", !/*$$slots*/
      ctx[10]["tab-end"] && /*i*/
      ctx[23] === /*tabs*/
      ctx[1].length - 1);
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = [
          listen(button, "click", click_handler),
          listen(button, "keydown", keydown_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tabs*/
      2 && t0_value !== (t0_value = /*localize*/
      ctx[9](
        /*tab*/
        ctx[21].title
      ) + "")) set_data(t0, t0_value);
      if (dirty & /*tabs*/
      2 && button_data_tab_id_value !== (button_data_tab_id_value = /*tab*/
      ctx[21].id)) {
        attr(button, "data-tab-id", button_data_tab_id_value);
      }
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*tabs, selectedTabId*/
      3) {
        toggle_class(
          button,
          "active",
          /*tab*/
          ctx[21].id === /*selectedTabId*/
          ctx[0]
        );
      }
      if (dirty & /*tabs*/
      2) {
        toggle_class(
          button,
          "first-tab",
          /*i*/
          ctx[23] === 0
        );
      }
      if (dirty & /*$$slots, tabs*/
      1026) {
        toggle_class(button, "no-border-on-last-tab", !/*$$slots*/
        ctx[10]["tab-end"] && /*i*/
        ctx[23] === /*tabs*/
        ctx[1].length - 1);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$4p(ctx) {
  let nav_1;
  let t2;
  let nav_1_class_value;
  let current;
  let if_block = (
    /*tabs*/
    ctx[1].length > 1 && create_if_block$1U(ctx)
  );
  const tab_end_slot_template = (
    /*#slots*/
    ctx[13]["tab-end"]
  );
  const tab_end_slot = create_slot(
    tab_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_tab_end_slot_context
  );
  return {
    c() {
      nav_1 = element("nav");
      if (if_block) if_block.c();
      t2 = space();
      if (tab_end_slot) tab_end_slot.c();
      attr(nav_1, "class", nav_1_class_value = "tidy-tabs " + /*cssClass*/
      ctx[2] + " svelte-18up2de");
      toggle_class(
        nav_1,
        "vertical",
        /*orientation*/
        ctx[3] === "vertical"
      );
    },
    m(target, anchor) {
      insert(target, nav_1, anchor);
      if (if_block) if_block.m(nav_1, null);
      append(nav_1, t2);
      if (tab_end_slot) {
        tab_end_slot.m(nav_1, null);
      }
      ctx[16](nav_1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*tabs*/
        ctx2[1].length > 1
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1U(ctx2);
          if_block.c();
          if_block.m(nav_1, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (tab_end_slot) {
        if (tab_end_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            tab_end_slot,
            tab_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              tab_end_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_tab_end_slot_changes
            ),
            get_tab_end_slot_context
          );
        }
      }
      if (!current || dirty & /*cssClass*/
      4 && nav_1_class_value !== (nav_1_class_value = "tidy-tabs " + /*cssClass*/
      ctx2[2] + " svelte-18up2de")) {
        attr(nav_1, "class", nav_1_class_value);
      }
      if (!current || dirty & /*cssClass, orientation*/
      12) {
        toggle_class(
          nav_1,
          "vertical",
          /*orientation*/
          ctx2[3] === "vertical"
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(tab_end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tab_end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(nav_1);
      }
      if (if_block) if_block.d();
      if (tab_end_slot) tab_end_slot.d(detaching);
      ctx[16](null);
    }
  };
}
function instance$4o($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { tabs } = $$props;
  let { selectedTabId = void 0 } = $$props;
  let { cssClass = "" } = $$props;
  let { orientation = "horizontal" } = $$props;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(17, $context = value));
  const onTabSelected = getContext(CONSTANTS.SVELTE_CONTEXT.ON_TAB_SELECTED);
  const dispatcher = createEventDispatcher();
  let nav;
  function selectTab(tab) {
    const sheet = $context?.actor?.sheet ?? $context?.item?.sheet;
    if (sheet && !FoundryAdapter.onTabSelecting(sheet, tab.id)) {
      return;
    }
    $$invalidate(0, selectedTabId = tab.id);
    dispatcher("tabSelected", tab);
    onTabSelected?.(tab.id);
  }
  function onKeyDown(ev, i2) {
    switch (ev.key) {
      case "ArrowRight":
      case "ArrowDown":
        const nextTab = tabs[(i2 + 1) % tabs.length];
        selectTab(nextTab);
        setTimeout(() => {
          nav.querySelector(`[data-tab-id='${nextTab.id}']`)?.focus();
        });
        break;
      case "ArrowLeft":
      case "ArrowUp":
        const previousTab = tabs.at(i2 - 1);
        if (previousTab) {
          selectTab(previousTab);
          setTimeout(() => {
            nav.querySelector(`[data-tab-id='${previousTab.id}']`)?.focus();
          });
        }
        break;
    }
  }
  const localize = FoundryAdapter.localize;
  const currentTabId = getContext(CONSTANTS.SVELTE_CONTEXT.CURRENT_TAB_ID);
  let mounted = false;
  onMount(() => {
    const initialTab = tabs.find((t2) => t2.id === currentTabId);
    if (initialTab) {
      selectTab(initialTab);
    }
    $$invalidate(11, mounted = true);
  });
  const click_handler = (tab) => selectTab(tab);
  const keydown_handler = (i2, ev) => onKeyDown(ev, i2);
  function nav_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nav = $$value;
      $$invalidate(4, nav);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tabs" in $$props2) $$invalidate(1, tabs = $$props2.tabs);
    if ("selectedTabId" in $$props2) $$invalidate(0, selectedTabId = $$props2.selectedTabId);
    if ("cssClass" in $$props2) $$invalidate(2, cssClass = $$props2.cssClass);
    if ("orientation" in $$props2) $$invalidate(3, orientation = $$props2.orientation);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*mounted, tabs, selectedTabId*/
    2051) {
      {
        if (mounted && !tabs.some((tab) => tab.id === selectedTabId)) {
          selectTab(tabs[0]);
        }
      }
    }
  };
  return [
    selectedTabId,
    tabs,
    cssClass,
    orientation,
    nav,
    $settingStore,
    context,
    selectTab,
    onKeyDown,
    localize,
    $$slots,
    mounted,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    nav_1_binding
  ];
}
class Tabs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4o, create_fragment$4p, safe_not_equal, {
      tabs: 1,
      selectedTabId: 0,
      cssClass: 2,
      orientation: 3
    });
  }
}
function declareLocation(...segments) {
  if (segments.length === 0) {
    return;
  }
  const location = getContext(CONSTANTS.SVELTE_CONTEXT.LOCATION) ?? "";
  setContext(
    CONSTANTS.SVELTE_CONTEXT.LOCATION,
    [location, ...segments].join("/")
  );
}
function create_fragment$4o(ctx) {
  let div;
  let div_class_value;
  let div_data_tab_contents_for_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "tidy-tab " + /*tab*/
      ctx[0].id + " " + /*cssClass*/
      ctx[2] + " " + /*tab*/
      (ctx[0].content.cssClass ?? "") + " " + /*useCoreListenersClass*/
      ctx[4] + " svelte-7hmddg");
      attr(div, "data-tab-contents-for", div_data_tab_contents_for_value = /*tab*/
      ctx[0].id);
      toggle_class(
        div,
        "active",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[6](div);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tab, cssClass, useCoreListenersClass*/
      21 && div_class_value !== (div_class_value = "tidy-tab " + /*tab*/
      ctx2[0].id + " " + /*cssClass*/
      ctx2[2] + " " + /*tab*/
      (ctx2[0].content.cssClass ?? "") + " " + /*useCoreListenersClass*/
      ctx2[4] + " svelte-7hmddg")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*tab*/
      1 && div_data_tab_contents_for_value !== (div_data_tab_contents_for_value = /*tab*/
      ctx2[0].id)) {
        attr(div, "data-tab-contents-for", div_data_tab_contents_for_value);
      }
      if (dirty & /*tab, cssClass, useCoreListenersClass, active*/
      23) {
        toggle_class(
          div,
          "active",
          /*active*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[6](null);
    }
  };
}
function instance$4n($$self, $$props, $$invalidate) {
  let useCoreListenersClass;
  let $context;
  let { tab } = $$props;
  let { active: active2 } = $$props;
  let { cssClass = "" } = $$props;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(7, $context = value));
  const allContexts = getAllContexts();
  declareLocation("tab", tab.id);
  setContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID, tab.id);
  let tidyTab;
  onMount(() => {
    if (tab.content.type !== "svelte") {
      return;
    }
    try {
      const props = tab.content.getProps?.($context) ?? {};
      const tabComponentContext = tab.content.getContext?.(allContexts) ?? allContexts;
      const svelteTabComponent = new tab.content.component({
        target: tidyTab,
        context: tabComponentContext,
        props
      });
      return () => {
        svelteTabComponent.$destroy();
      };
    } catch (e2) {
      error("Failed to render svelte tab", false, e2);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tidyTab = $$value;
      $$invalidate(3, tidyTab);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tab" in $$props2) $$invalidate(0, tab = $$props2.tab);
    if ("active" in $$props2) $$invalidate(1, active2 = $$props2.active);
    if ("cssClass" in $$props2) $$invalidate(2, cssClass = $$props2.cssClass);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tab*/
    1) {
      $$invalidate(4, useCoreListenersClass = tab.activateDefaultSheetListeners ? CONSTANTS.CLASS_TIDY_USE_CORE_LISTENERS : "");
    }
  };
  return [tab, active2, cssClass, tidyTab, useCoreListenersClass, context, div_binding];
}
class TabContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4n, create_fragment$4o, safe_not_equal, { tab: 0, active: 1, cssClass: 2 });
  }
}
function get_each_context$19(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_each_block$19(key_1, ctx) {
  let first;
  let tabcontent;
  let current;
  tabcontent = new TabContent({
    props: {
      active: (
        /*selectedTabId*/
        ctx[1] === /*tab*/
        ctx[3].id
      ),
      tab: (
        /*tab*/
        ctx[3]
      ),
      cssClass: (
        /*cssClass*/
        ctx[2]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tabcontent.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tabcontent, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tabcontent_changes = {};
      if (dirty & /*selectedTabId, tabs*/
      3) tabcontent_changes.active = /*selectedTabId*/
      ctx[1] === /*tab*/
      ctx[3].id;
      if (dirty & /*tabs*/
      1) tabcontent_changes.tab = /*tab*/
      ctx[3];
      if (dirty & /*cssClass*/
      4) tabcontent_changes.cssClass = /*cssClass*/
      ctx[2];
      tabcontent.$set(tabcontent_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tabcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(tabcontent, detaching);
    }
  };
}
function create_fragment$4n(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*tabs*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*tab*/
    ctx2[3].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$19(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$19(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*selectedTabId, tabs, cssClass*/
      7) {
        each_value = ensure_array_like(
          /*tabs*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$19, each_1_anchor, get_each_context$19);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function instance$4m($$self, $$props, $$invalidate) {
  let { tabs } = $$props;
  let { selectedTabId } = $$props;
  let { cssClass = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("tabs" in $$props2) $$invalidate(0, tabs = $$props2.tabs);
    if ("selectedTabId" in $$props2) $$invalidate(1, selectedTabId = $$props2.selectedTabId);
    if ("cssClass" in $$props2) $$invalidate(2, cssClass = $$props2.cssClass);
  };
  return [tabs, selectedTabId, cssClass];
}
class TabContents extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4m, create_fragment$4n, safe_not_equal, { tabs: 0, selectedTabId: 1, cssClass: 2 });
  }
}
function create_fragment$4m(ctx) {
  let article;
  let input;
  let input_id_value;
  let t0;
  let div;
  let label;
  let t1_value = (
    /*localize*/
    ctx[5](
      /*name*/
      ctx[1]
    ) + ""
  );
  let t1;
  let label_for_value;
  let t2;
  let p2;
  let t3_value = (
    /*localize*/
    ctx[5](
      /*hint*/
      ctx[2]
    ) + ""
  );
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      article = element("article");
      input = element("input");
      t0 = space();
      div = element("div");
      label = element("label");
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      t3 = text(t3_value);
      attr(input, "type", "checkbox");
      attr(input, "id", input_id_value = /*id*/
      ctx[3] + "-" + /*appId*/
      ctx[4]);
      attr(label, "for", label_for_value = /*id*/
      ctx[3] + "-" + /*appId*/
      ctx[4]);
      attr(p2, "class", "tidy5e-notes");
      attr(div, "class", "description");
      attr(article, "class", "setting");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, input);
      input.checked = /*value*/
      ctx[0];
      append(article, t0);
      append(article, div);
      append(div, label);
      append(label, t1);
      append(div, t2);
      append(div, p2);
      append(p2, t3);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*id*/
      8 && input_id_value !== (input_id_value = /*id*/
      ctx2[3] + "-" + /*appId*/
      ctx2[4])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*value*/
      1) {
        input.checked = /*value*/
        ctx2[0];
      }
      if (dirty & /*name*/
      2 && t1_value !== (t1_value = /*localize*/
      ctx2[5](
        /*name*/
        ctx2[1]
      ) + "")) set_data(t1, t1_value);
      if (dirty & /*id*/
      8 && label_for_value !== (label_for_value = /*id*/
      ctx2[3] + "-" + /*appId*/
      ctx2[4])) {
        attr(label, "for", label_for_value);
      }
      if (dirty & /*hint*/
      4 && t3_value !== (t3_value = /*localize*/
      ctx2[5](
        /*hint*/
        ctx2[2]
      ) + "")) set_data(t3, t3_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4l($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { name } = $$props;
  let { hint } = $$props;
  let { id } = $$props;
  const appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  const localize = FoundryAdapter.localize;
  function input_change_handler() {
    value = this.checked;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("name" in $$props2) $$invalidate(1, name = $$props2.name);
    if ("hint" in $$props2) $$invalidate(2, hint = $$props2.hint);
    if ("id" in $$props2) $$invalidate(3, id = $$props2.id);
  };
  return [value, name, hint, id, appId, localize, input_change_handler];
}
class CheckboxSetting extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4l, create_fragment$4m, safe_not_equal, { value: 0, name: 1, hint: 2, id: 3 });
  }
}
const get_additional_inputs_slot_changes$1 = (dirty) => ({});
const get_additional_inputs_slot_context$1 = (ctx) => ({});
function create_fragment$4l(ctx) {
  let article1;
  let div2;
  let div0;
  let label;
  let t0_value = (
    /*localize*/
    ctx[4](
      /*name*/
      ctx[1]
    ) + ""
  );
  let t0;
  let t1;
  let p2;
  let t2_value = (
    /*localize*/
    ctx[4](
      /*hint*/
      ctx[2]
    ) + ""
  );
  let t2;
  let t3;
  let div1;
  let article0;
  let input;
  let t4;
  let current;
  let mounted;
  let dispose;
  const additional_inputs_slot_template = (
    /*#slots*/
    ctx[7]["additional-inputs"]
  );
  const additional_inputs_slot = create_slot(
    additional_inputs_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_additional_inputs_slot_context$1
  );
  return {
    c() {
      article1 = element("article");
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      t2 = text(t2_value);
      t3 = space();
      div1 = element("div");
      article0 = element("article");
      input = element("input");
      t4 = space();
      if (additional_inputs_slot) additional_inputs_slot.c();
      attr(
        label,
        "for",
        /*calculatedId*/
        ctx[3]
      );
      attr(p2, "class", "tidy5e-notes");
      attr(div0, "class", "description");
      attr(input, "type", "text");
      attr(
        input,
        "id",
        /*calculatedId*/
        ctx[3]
      );
      attr(div1, "class", "settings-group");
      attr(article1, "class", "setting group");
    },
    m(target, anchor) {
      insert(target, article1, anchor);
      append(article1, div2);
      append(div2, div0);
      append(div0, label);
      append(label, t0);
      append(div0, t1);
      append(div0, p2);
      append(p2, t2);
      append(div2, t3);
      append(div2, div1);
      append(div1, article0);
      append(article0, input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append(div1, t4);
      if (additional_inputs_slot) {
        additional_inputs_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*name*/
      2) && t0_value !== (t0_value = /*localize*/
      ctx2[4](
        /*name*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if (!current || dirty & /*calculatedId*/
      8) {
        attr(
          label,
          "for",
          /*calculatedId*/
          ctx2[3]
        );
      }
      if ((!current || dirty & /*hint*/
      4) && t2_value !== (t2_value = /*localize*/
      ctx2[4](
        /*hint*/
        ctx2[2]
      ) + "")) set_data(t2, t2_value);
      if (!current || dirty & /*calculatedId*/
      8) {
        attr(
          input,
          "id",
          /*calculatedId*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (additional_inputs_slot) {
        if (additional_inputs_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            additional_inputs_slot,
            additional_inputs_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              additional_inputs_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_additional_inputs_slot_changes$1
            ),
            get_additional_inputs_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(additional_inputs_slot, local);
      current = true;
    },
    o(local) {
      transition_out(additional_inputs_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article1);
      }
      if (additional_inputs_slot) additional_inputs_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$4k($$self, $$props, $$invalidate) {
  let calculatedId;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { value } = $$props;
  let { name } = $$props;
  let { hint } = $$props;
  let { id } = $$props;
  const appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  const localize = FoundryAdapter.localize;
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("name" in $$props2) $$invalidate(1, name = $$props2.name);
    if ("hint" in $$props2) $$invalidate(2, hint = $$props2.hint);
    if ("id" in $$props2) $$invalidate(5, id = $$props2.id);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    32) {
      $$invalidate(3, calculatedId = `${id}-${appId}`);
    }
  };
  return [
    value,
    name,
    hint,
    calculatedId,
    localize,
    id,
    $$scope,
    slots,
    input_input_handler
  ];
}
class TextInputSetting extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4k, create_fragment$4l, safe_not_equal, { value: 0, name: 1, hint: 2, id: 5 });
  }
}
function create_fragment$4k(ctx) {
  let h2;
  let t1;
  let checkboxsetting0;
  let updating_value;
  let t2;
  let checkboxsetting1;
  let updating_value_1;
  let t3;
  let checkboxsetting2;
  let updating_value_2;
  let t4;
  let checkboxsetting3;
  let updating_value_3;
  let t5;
  let checkboxsetting4;
  let updating_value_4;
  let t6;
  let checkboxsetting5;
  let updating_value_5;
  let t7;
  let checkboxsetting6;
  let updating_value_6;
  let t8;
  let checkboxsetting7;
  let updating_value_7;
  let t9;
  let checkboxsetting8;
  let updating_value_8;
  let t10;
  let checkboxsetting9;
  let updating_value_9;
  let t11;
  let checkboxsetting10;
  let updating_value_10;
  let t12;
  let checkboxsetting11;
  let updating_value_11;
  let t13;
  let checkboxsetting12;
  let updating_value_12;
  let t14;
  let checkboxsetting13;
  let updating_value_13;
  let t15;
  let h3;
  let t17;
  let checkboxsetting14;
  let updating_value_14;
  let t18;
  let checkboxsetting15;
  let updating_value_15;
  let current;
  function checkboxsetting0_value_binding(value) {
    ctx[3](value);
  }
  let checkboxsetting0_props = {
    name: SettingsProvider.settings.useClassicControlsForCharacter.options.name,
    hint: SettingsProvider.settings.useClassicControlsForCharacter.options.hint,
    id: "useClassicControlsForCharacter"
  };
  if (
    /*$context*/
    ctx[0].settings.useClassicControlsForCharacter !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.useClassicControlsForCharacter;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[4](value);
  }
  let checkboxsetting1_props = {
    name: SettingsProvider.settings.showClassList.options.name,
    hint: SettingsProvider.settings.showClassList.options.hint,
    id: "showClassList"
  };
  if (
    /*$context*/
    ctx[0].settings.showClassList !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.showClassList;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  function checkboxsetting2_value_binding(value) {
    ctx[5](value);
  }
  let checkboxsetting2_props = {
    name: SettingsProvider.settings.animateInspiration.options.name,
    hint: SettingsProvider.settings.animateInspiration.options.hint,
    id: "animateInspiration"
  };
  if (
    /*$context*/
    ctx[0].settings.animateInspiration !== void 0
  ) {
    checkboxsetting2_props.value = /*$context*/
    ctx[0].settings.animateInspiration;
  }
  checkboxsetting2 = new CheckboxSetting({ props: checkboxsetting2_props });
  binding_callbacks.push(() => bind(checkboxsetting2, "value", checkboxsetting2_value_binding));
  function checkboxsetting3_value_binding(value) {
    ctx[6](value);
  }
  let checkboxsetting3_props = {
    name: SettingsProvider.settings.hideIfZero.options.name,
    hint: SettingsProvider.settings.hideIfZero.options.hint,
    id: "hideIfZero"
  };
  if (
    /*$context*/
    ctx[0].settings.hideIfZero !== void 0
  ) {
    checkboxsetting3_props.value = /*$context*/
    ctx[0].settings.hideIfZero;
  }
  checkboxsetting3 = new CheckboxSetting({ props: checkboxsetting3_props });
  binding_callbacks.push(() => bind(checkboxsetting3, "value", checkboxsetting3_value_binding));
  function checkboxsetting4_value_binding(value) {
    ctx[7](value);
  }
  let checkboxsetting4_props = {
    name: SettingsProvider.settings.showInspirationOnHover.options.name,
    hint: SettingsProvider.settings.showInspirationOnHover.options.hint,
    id: "showInspirationOnHover"
  };
  if (
    /*$context*/
    ctx[0].settings.showInspirationOnHover !== void 0
  ) {
    checkboxsetting4_props.value = /*$context*/
    ctx[0].settings.showInspirationOnHover;
  }
  checkboxsetting4 = new CheckboxSetting({ props: checkboxsetting4_props });
  binding_callbacks.push(() => bind(checkboxsetting4, "value", checkboxsetting4_value_binding));
  function checkboxsetting5_value_binding(value) {
    ctx[8](value);
  }
  let checkboxsetting5_props = {
    name: SettingsProvider.settings.showExhaustionOnHover.options.name,
    hint: SettingsProvider.settings.showExhaustionOnHover.options.hint,
    id: "showExhaustionOnHover"
  };
  if (
    /*$context*/
    ctx[0].settings.showExhaustionOnHover !== void 0
  ) {
    checkboxsetting5_props.value = /*$context*/
    ctx[0].settings.showExhaustionOnHover;
  }
  checkboxsetting5 = new CheckboxSetting({ props: checkboxsetting5_props });
  binding_callbacks.push(() => bind(checkboxsetting5, "value", checkboxsetting5_value_binding));
  function checkboxsetting6_value_binding(value) {
    ctx[9](value);
  }
  let checkboxsetting6_props = {
    name: SettingsProvider.settings.useHpBar.options.name,
    hint: SettingsProvider.settings.useHpBar.options.hint,
    id: "useHpBar"
  };
  if (
    /*$context*/
    ctx[0].settings.useHpBar !== void 0
  ) {
    checkboxsetting6_props.value = /*$context*/
    ctx[0].settings.useHpBar;
  }
  checkboxsetting6 = new CheckboxSetting({ props: checkboxsetting6_props });
  binding_callbacks.push(() => bind(checkboxsetting6, "value", checkboxsetting6_value_binding));
  function checkboxsetting7_value_binding(value) {
    ctx[10](value);
  }
  let checkboxsetting7_props = {
    name: SettingsProvider.settings.useHpOverlay.options.name,
    hint: SettingsProvider.settings.useHpOverlay.options.hint,
    id: "useHpOverlay"
  };
  if (
    /*$context*/
    ctx[0].settings.useHpOverlay !== void 0
  ) {
    checkboxsetting7_props.value = /*$context*/
    ctx[0].settings.useHpOverlay;
  }
  checkboxsetting7 = new CheckboxSetting({ props: checkboxsetting7_props });
  binding_callbacks.push(() => bind(checkboxsetting7, "value", checkboxsetting7_value_binding));
  function checkboxsetting8_value_binding(value) {
    ctx[11](value);
  }
  let checkboxsetting8_props = {
    name: SettingsProvider.settings.toggleEmptyCharacterSkills.options.name,
    hint: SettingsProvider.settings.toggleEmptyCharacterSkills.options.hint,
    id: "toggleEmptyCharacterSkills"
  };
  if (
    /*$context*/
    ctx[0].settings.toggleEmptyCharacterSkills !== void 0
  ) {
    checkboxsetting8_props.value = /*$context*/
    ctx[0].settings.toggleEmptyCharacterSkills;
  }
  checkboxsetting8 = new CheckboxSetting({ props: checkboxsetting8_props });
  binding_callbacks.push(() => bind(checkboxsetting8, "value", checkboxsetting8_value_binding));
  function checkboxsetting9_value_binding(value) {
    ctx[12](value);
  }
  let checkboxsetting9_props = {
    name: SettingsProvider.settings.toggleEmptyCharacterTraits.options.name,
    hint: SettingsProvider.settings.toggleEmptyCharacterTraits.options.hint,
    id: "toggleEmptyCharacterTraits"
  };
  if (
    /*$context*/
    ctx[0].settings.toggleEmptyCharacterTraits !== void 0
  ) {
    checkboxsetting9_props.value = /*$context*/
    ctx[0].settings.toggleEmptyCharacterTraits;
  }
  checkboxsetting9 = new CheckboxSetting({ props: checkboxsetting9_props });
  binding_callbacks.push(() => bind(checkboxsetting9, "value", checkboxsetting9_value_binding));
  function checkboxsetting10_value_binding(value) {
    ctx[13](value);
  }
  let checkboxsetting10_props = {
    name: SettingsProvider.settings.moveTraitsBelowCharacterResources.options.name,
    hint: SettingsProvider.settings.moveTraitsBelowCharacterResources.options.hint,
    id: "moveTraitsBelowCharacterResources"
  };
  if (
    /*$context*/
    ctx[0].settings.moveTraitsBelowCharacterResources !== void 0
  ) {
    checkboxsetting10_props.value = /*$context*/
    ctx[0].settings.moveTraitsBelowCharacterResources;
  }
  checkboxsetting10 = new CheckboxSetting({ props: checkboxsetting10_props });
  binding_callbacks.push(() => bind(checkboxsetting10, "value", checkboxsetting10_value_binding));
  function checkboxsetting11_value_binding(value) {
    ctx[14](value);
  }
  let checkboxsetting11_props = {
    name: SettingsProvider.settings.showEquippedAmmoOnly.options.name,
    hint: SettingsProvider.settings.showEquippedAmmoOnly.options.hint,
    id: "showEquippedAmmoOnly"
  };
  if (
    /*$context*/
    ctx[0].settings.showEquippedAmmoOnly !== void 0
  ) {
    checkboxsetting11_props.value = /*$context*/
    ctx[0].settings.showEquippedAmmoOnly;
  }
  checkboxsetting11 = new CheckboxSetting({ props: checkboxsetting11_props });
  binding_callbacks.push(() => bind(checkboxsetting11, "value", checkboxsetting11_value_binding));
  function checkboxsetting12_value_binding(value) {
    ctx[15](value);
  }
  let checkboxsetting12_props = {
    name: SettingsProvider.settings.useContextMenu.options.name,
    hint: SettingsProvider.settings.useContextMenu.options.hint,
    id: "useContextMenu"
  };
  if (
    /*$context*/
    ctx[0].settings.useContextMenu !== void 0
  ) {
    checkboxsetting12_props.value = /*$context*/
    ctx[0].settings.useContextMenu;
  }
  checkboxsetting12 = new CheckboxSetting({ props: checkboxsetting12_props });
  binding_callbacks.push(() => bind(checkboxsetting12, "value", checkboxsetting12_value_binding));
  function checkboxsetting13_value_binding(value) {
    ctx[16](value);
  }
  let checkboxsetting13_props = {
    name: SettingsProvider.settings.showIconsNextToTheItemName.options.name,
    hint: SettingsProvider.settings.showIconsNextToTheItemName.options.hint,
    id: "showIconsNextToTheItemName"
  };
  if (
    /*$context*/
    ctx[0].settings.showIconsNextToTheItemName !== void 0
  ) {
    checkboxsetting13_props.value = /*$context*/
    ctx[0].settings.showIconsNextToTheItemName;
  }
  checkboxsetting13 = new CheckboxSetting({ props: checkboxsetting13_props });
  binding_callbacks.push(() => bind(checkboxsetting13, "value", checkboxsetting13_value_binding));
  function checkboxsetting14_value_binding(value) {
    ctx[17](value);
  }
  let checkboxsetting14_props = {
    name: SettingsProvider.settings.useMulticlassSpellbookFilter.options.name,
    hint: SettingsProvider.settings.useMulticlassSpellbookFilter.options.hint,
    id: "useMulticlassSpellbookFilter"
  };
  if (
    /*$context*/
    ctx[0].settings.useMulticlassSpellbookFilter !== void 0
  ) {
    checkboxsetting14_props.value = /*$context*/
    ctx[0].settings.useMulticlassSpellbookFilter;
  }
  checkboxsetting14 = new CheckboxSetting({ props: checkboxsetting14_props });
  binding_callbacks.push(() => bind(checkboxsetting14, "value", checkboxsetting14_value_binding));
  function checkboxsetting15_value_binding(value) {
    ctx[18](value);
  }
  let checkboxsetting15_props = {
    name: SettingsProvider.settings.useSpellClassFilterIcons.options.name,
    hint: SettingsProvider.settings.useSpellClassFilterIcons.options.hint,
    id: "useSpellClassFilterIcons"
  };
  if (
    /*$context*/
    ctx[0].settings.useSpellClassFilterIcons !== void 0
  ) {
    checkboxsetting15_props.value = /*$context*/
    ctx[0].settings.useSpellClassFilterIcons;
  }
  checkboxsetting15 = new CheckboxSetting({ props: checkboxsetting15_props });
  binding_callbacks.push(() => bind(checkboxsetting15, "value", checkboxsetting15_value_binding));
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[2]("TIDY5E.UserSettings.TabPlayers.header")}`;
      t1 = space();
      create_component(checkboxsetting0.$$.fragment);
      t2 = space();
      create_component(checkboxsetting1.$$.fragment);
      t3 = space();
      create_component(checkboxsetting2.$$.fragment);
      t4 = space();
      create_component(checkboxsetting3.$$.fragment);
      t5 = space();
      create_component(checkboxsetting4.$$.fragment);
      t6 = space();
      create_component(checkboxsetting5.$$.fragment);
      t7 = space();
      create_component(checkboxsetting6.$$.fragment);
      t8 = space();
      create_component(checkboxsetting7.$$.fragment);
      t9 = space();
      create_component(checkboxsetting8.$$.fragment);
      t10 = space();
      create_component(checkboxsetting9.$$.fragment);
      t11 = space();
      create_component(checkboxsetting10.$$.fragment);
      t12 = space();
      create_component(checkboxsetting11.$$.fragment);
      t13 = space();
      create_component(checkboxsetting12.$$.fragment);
      t14 = space();
      create_component(checkboxsetting13.$$.fragment);
      t15 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[2]("TIDY5E.Settings.MulticlassSpellbookFilterLabel")}`;
      t17 = space();
      create_component(checkboxsetting14.$$.fragment);
      t18 = space();
      create_component(checkboxsetting15.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, t1, anchor);
      mount_component(checkboxsetting0, target, anchor);
      insert(target, t2, anchor);
      mount_component(checkboxsetting1, target, anchor);
      insert(target, t3, anchor);
      mount_component(checkboxsetting2, target, anchor);
      insert(target, t4, anchor);
      mount_component(checkboxsetting3, target, anchor);
      insert(target, t5, anchor);
      mount_component(checkboxsetting4, target, anchor);
      insert(target, t6, anchor);
      mount_component(checkboxsetting5, target, anchor);
      insert(target, t7, anchor);
      mount_component(checkboxsetting6, target, anchor);
      insert(target, t8, anchor);
      mount_component(checkboxsetting7, target, anchor);
      insert(target, t9, anchor);
      mount_component(checkboxsetting8, target, anchor);
      insert(target, t10, anchor);
      mount_component(checkboxsetting9, target, anchor);
      insert(target, t11, anchor);
      mount_component(checkboxsetting10, target, anchor);
      insert(target, t12, anchor);
      mount_component(checkboxsetting11, target, anchor);
      insert(target, t13, anchor);
      mount_component(checkboxsetting12, target, anchor);
      insert(target, t14, anchor);
      mount_component(checkboxsetting13, target, anchor);
      insert(target, t15, anchor);
      insert(target, h3, anchor);
      insert(target, t17, anchor);
      mount_component(checkboxsetting14, target, anchor);
      insert(target, t18, anchor);
      mount_component(checkboxsetting15, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkboxsetting0_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.useClassicControlsForCharacter;
        add_flush_callback(() => updating_value = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.showClassList;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
      const checkboxsetting2_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        checkboxsetting2_changes.value = /*$context*/
        ctx2[0].settings.animateInspiration;
        add_flush_callback(() => updating_value_2 = false);
      }
      checkboxsetting2.$set(checkboxsetting2_changes);
      const checkboxsetting3_changes = {};
      if (!updating_value_3 && dirty & /*$context*/
      1) {
        updating_value_3 = true;
        checkboxsetting3_changes.value = /*$context*/
        ctx2[0].settings.hideIfZero;
        add_flush_callback(() => updating_value_3 = false);
      }
      checkboxsetting3.$set(checkboxsetting3_changes);
      const checkboxsetting4_changes = {};
      if (!updating_value_4 && dirty & /*$context*/
      1) {
        updating_value_4 = true;
        checkboxsetting4_changes.value = /*$context*/
        ctx2[0].settings.showInspirationOnHover;
        add_flush_callback(() => updating_value_4 = false);
      }
      checkboxsetting4.$set(checkboxsetting4_changes);
      const checkboxsetting5_changes = {};
      if (!updating_value_5 && dirty & /*$context*/
      1) {
        updating_value_5 = true;
        checkboxsetting5_changes.value = /*$context*/
        ctx2[0].settings.showExhaustionOnHover;
        add_flush_callback(() => updating_value_5 = false);
      }
      checkboxsetting5.$set(checkboxsetting5_changes);
      const checkboxsetting6_changes = {};
      if (!updating_value_6 && dirty & /*$context*/
      1) {
        updating_value_6 = true;
        checkboxsetting6_changes.value = /*$context*/
        ctx2[0].settings.useHpBar;
        add_flush_callback(() => updating_value_6 = false);
      }
      checkboxsetting6.$set(checkboxsetting6_changes);
      const checkboxsetting7_changes = {};
      if (!updating_value_7 && dirty & /*$context*/
      1) {
        updating_value_7 = true;
        checkboxsetting7_changes.value = /*$context*/
        ctx2[0].settings.useHpOverlay;
        add_flush_callback(() => updating_value_7 = false);
      }
      checkboxsetting7.$set(checkboxsetting7_changes);
      const checkboxsetting8_changes = {};
      if (!updating_value_8 && dirty & /*$context*/
      1) {
        updating_value_8 = true;
        checkboxsetting8_changes.value = /*$context*/
        ctx2[0].settings.toggleEmptyCharacterSkills;
        add_flush_callback(() => updating_value_8 = false);
      }
      checkboxsetting8.$set(checkboxsetting8_changes);
      const checkboxsetting9_changes = {};
      if (!updating_value_9 && dirty & /*$context*/
      1) {
        updating_value_9 = true;
        checkboxsetting9_changes.value = /*$context*/
        ctx2[0].settings.toggleEmptyCharacterTraits;
        add_flush_callback(() => updating_value_9 = false);
      }
      checkboxsetting9.$set(checkboxsetting9_changes);
      const checkboxsetting10_changes = {};
      if (!updating_value_10 && dirty & /*$context*/
      1) {
        updating_value_10 = true;
        checkboxsetting10_changes.value = /*$context*/
        ctx2[0].settings.moveTraitsBelowCharacterResources;
        add_flush_callback(() => updating_value_10 = false);
      }
      checkboxsetting10.$set(checkboxsetting10_changes);
      const checkboxsetting11_changes = {};
      if (!updating_value_11 && dirty & /*$context*/
      1) {
        updating_value_11 = true;
        checkboxsetting11_changes.value = /*$context*/
        ctx2[0].settings.showEquippedAmmoOnly;
        add_flush_callback(() => updating_value_11 = false);
      }
      checkboxsetting11.$set(checkboxsetting11_changes);
      const checkboxsetting12_changes = {};
      if (!updating_value_12 && dirty & /*$context*/
      1) {
        updating_value_12 = true;
        checkboxsetting12_changes.value = /*$context*/
        ctx2[0].settings.useContextMenu;
        add_flush_callback(() => updating_value_12 = false);
      }
      checkboxsetting12.$set(checkboxsetting12_changes);
      const checkboxsetting13_changes = {};
      if (!updating_value_13 && dirty & /*$context*/
      1) {
        updating_value_13 = true;
        checkboxsetting13_changes.value = /*$context*/
        ctx2[0].settings.showIconsNextToTheItemName;
        add_flush_callback(() => updating_value_13 = false);
      }
      checkboxsetting13.$set(checkboxsetting13_changes);
      const checkboxsetting14_changes = {};
      if (!updating_value_14 && dirty & /*$context*/
      1) {
        updating_value_14 = true;
        checkboxsetting14_changes.value = /*$context*/
        ctx2[0].settings.useMulticlassSpellbookFilter;
        add_flush_callback(() => updating_value_14 = false);
      }
      checkboxsetting14.$set(checkboxsetting14_changes);
      const checkboxsetting15_changes = {};
      if (!updating_value_15 && dirty & /*$context*/
      1) {
        updating_value_15 = true;
        checkboxsetting15_changes.value = /*$context*/
        ctx2[0].settings.useSpellClassFilterIcons;
        add_flush_callback(() => updating_value_15 = false);
      }
      checkboxsetting15.$set(checkboxsetting15_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      transition_in(checkboxsetting2.$$.fragment, local);
      transition_in(checkboxsetting3.$$.fragment, local);
      transition_in(checkboxsetting4.$$.fragment, local);
      transition_in(checkboxsetting5.$$.fragment, local);
      transition_in(checkboxsetting6.$$.fragment, local);
      transition_in(checkboxsetting7.$$.fragment, local);
      transition_in(checkboxsetting8.$$.fragment, local);
      transition_in(checkboxsetting9.$$.fragment, local);
      transition_in(checkboxsetting10.$$.fragment, local);
      transition_in(checkboxsetting11.$$.fragment, local);
      transition_in(checkboxsetting12.$$.fragment, local);
      transition_in(checkboxsetting13.$$.fragment, local);
      transition_in(checkboxsetting14.$$.fragment, local);
      transition_in(checkboxsetting15.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      transition_out(checkboxsetting2.$$.fragment, local);
      transition_out(checkboxsetting3.$$.fragment, local);
      transition_out(checkboxsetting4.$$.fragment, local);
      transition_out(checkboxsetting5.$$.fragment, local);
      transition_out(checkboxsetting6.$$.fragment, local);
      transition_out(checkboxsetting7.$$.fragment, local);
      transition_out(checkboxsetting8.$$.fragment, local);
      transition_out(checkboxsetting9.$$.fragment, local);
      transition_out(checkboxsetting10.$$.fragment, local);
      transition_out(checkboxsetting11.$$.fragment, local);
      transition_out(checkboxsetting12.$$.fragment, local);
      transition_out(checkboxsetting13.$$.fragment, local);
      transition_out(checkboxsetting14.$$.fragment, local);
      transition_out(checkboxsetting15.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(t9);
        detach(t10);
        detach(t11);
        detach(t12);
        detach(t13);
        detach(t14);
        detach(t15);
        detach(h3);
        detach(t17);
        detach(t18);
      }
      destroy_component(checkboxsetting0, detaching);
      destroy_component(checkboxsetting1, detaching);
      destroy_component(checkboxsetting2, detaching);
      destroy_component(checkboxsetting3, detaching);
      destroy_component(checkboxsetting4, detaching);
      destroy_component(checkboxsetting5, detaching);
      destroy_component(checkboxsetting6, detaching);
      destroy_component(checkboxsetting7, detaching);
      destroy_component(checkboxsetting8, detaching);
      destroy_component(checkboxsetting9, detaching);
      destroy_component(checkboxsetting10, detaching);
      destroy_component(checkboxsetting11, detaching);
      destroy_component(checkboxsetting12, detaching);
      destroy_component(checkboxsetting13, detaching);
      destroy_component(checkboxsetting14, detaching);
      destroy_component(checkboxsetting15, detaching);
    }
  };
}
function instance$4j($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useClassicControlsForCharacter, value)) {
      $context.settings.useClassicControlsForCharacter = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showClassList, value)) {
      $context.settings.showClassList = value;
      context.set($context);
    }
  }
  function checkboxsetting2_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.animateInspiration, value)) {
      $context.settings.animateInspiration = value;
      context.set($context);
    }
  }
  function checkboxsetting3_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.hideIfZero, value)) {
      $context.settings.hideIfZero = value;
      context.set($context);
    }
  }
  function checkboxsetting4_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showInspirationOnHover, value)) {
      $context.settings.showInspirationOnHover = value;
      context.set($context);
    }
  }
  function checkboxsetting5_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showExhaustionOnHover, value)) {
      $context.settings.showExhaustionOnHover = value;
      context.set($context);
    }
  }
  function checkboxsetting6_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useHpBar, value)) {
      $context.settings.useHpBar = value;
      context.set($context);
    }
  }
  function checkboxsetting7_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useHpOverlay, value)) {
      $context.settings.useHpOverlay = value;
      context.set($context);
    }
  }
  function checkboxsetting8_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.toggleEmptyCharacterSkills, value)) {
      $context.settings.toggleEmptyCharacterSkills = value;
      context.set($context);
    }
  }
  function checkboxsetting9_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.toggleEmptyCharacterTraits, value)) {
      $context.settings.toggleEmptyCharacterTraits = value;
      context.set($context);
    }
  }
  function checkboxsetting10_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.moveTraitsBelowCharacterResources, value)) {
      $context.settings.moveTraitsBelowCharacterResources = value;
      context.set($context);
    }
  }
  function checkboxsetting11_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showEquippedAmmoOnly, value)) {
      $context.settings.showEquippedAmmoOnly = value;
      context.set($context);
    }
  }
  function checkboxsetting12_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useContextMenu, value)) {
      $context.settings.useContextMenu = value;
      context.set($context);
    }
  }
  function checkboxsetting13_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showIconsNextToTheItemName, value)) {
      $context.settings.showIconsNextToTheItemName = value;
      context.set($context);
    }
  }
  function checkboxsetting14_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useMulticlassSpellbookFilter, value)) {
      $context.settings.useMulticlassSpellbookFilter = value;
      context.set($context);
    }
  }
  function checkboxsetting15_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useSpellClassFilterIcons, value)) {
      $context.settings.useSpellClassFilterIcons = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    localize,
    checkboxsetting0_value_binding,
    checkboxsetting1_value_binding,
    checkboxsetting2_value_binding,
    checkboxsetting3_value_binding,
    checkboxsetting4_value_binding,
    checkboxsetting5_value_binding,
    checkboxsetting6_value_binding,
    checkboxsetting7_value_binding,
    checkboxsetting8_value_binding,
    checkboxsetting9_value_binding,
    checkboxsetting10_value_binding,
    checkboxsetting11_value_binding,
    checkboxsetting12_value_binding,
    checkboxsetting13_value_binding,
    checkboxsetting14_value_binding,
    checkboxsetting15_value_binding
  ];
}
class PlayerSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4j, create_fragment$4k, safe_not_equal, {});
  }
}
function create_fragment$4j(ctx) {
  let h2;
  let t1;
  let checkboxsetting0;
  let updating_value;
  let t2;
  let checkboxsetting1;
  let updating_value_1;
  let t3;
  let checkboxsetting2;
  let updating_value_2;
  let t4;
  let checkboxsetting3;
  let updating_value_3;
  let t5;
  let checkboxsetting4;
  let updating_value_4;
  let t6;
  let checkboxsetting5;
  let updating_value_5;
  let t7;
  let checkboxsetting6;
  let updating_value_6;
  let current;
  function checkboxsetting0_value_binding(value) {
    ctx[3](value);
  }
  let checkboxsetting0_props = {
    name: SettingsProvider.settings.useClassicControlsForNpc.options.name,
    hint: SettingsProvider.settings.useClassicControlsForNpc.options.hint,
    id: "useClassicControlsForNpc"
  };
  if (
    /*$context*/
    ctx[0].settings.useClassicControlsForNpc !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.useClassicControlsForNpc;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[4](value);
  }
  let checkboxsetting1_props = {
    name: SettingsProvider.settings.useHpBarNpc.options.name,
    hint: SettingsProvider.settings.useHpBarNpc.options.hint,
    id: "useHpBarNpc"
  };
  if (
    /*$context*/
    ctx[0].settings.useHpBarNpc !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.useHpBarNpc;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  function checkboxsetting2_value_binding(value) {
    ctx[5](value);
  }
  let checkboxsetting2_props = {
    name: SettingsProvider.settings.useHpOverlayNpc.options.name,
    hint: SettingsProvider.settings.useHpOverlayNpc.options.hint,
    id: "useHpOverlayNpc"
  };
  if (
    /*$context*/
    ctx[0].settings.useHpOverlayNpc !== void 0
  ) {
    checkboxsetting2_props.value = /*$context*/
    ctx[0].settings.useHpOverlayNpc;
  }
  checkboxsetting2 = new CheckboxSetting({ props: checkboxsetting2_props });
  binding_callbacks.push(() => bind(checkboxsetting2, "value", checkboxsetting2_value_binding));
  function checkboxsetting3_value_binding(value) {
    ctx[6](value);
  }
  let checkboxsetting3_props = {
    name: SettingsProvider.settings.alwaysShowNpcTraits.options.name,
    hint: SettingsProvider.settings.alwaysShowNpcTraits.options.hint,
    id: "alwaysShowNpcTraits"
  };
  if (
    /*$context*/
    ctx[0].settings.alwaysShowNpcTraits !== void 0
  ) {
    checkboxsetting3_props.value = /*$context*/
    ctx[0].settings.alwaysShowNpcTraits;
  }
  checkboxsetting3 = new CheckboxSetting({ props: checkboxsetting3_props });
  binding_callbacks.push(() => bind(checkboxsetting3, "value", checkboxsetting3_value_binding));
  function checkboxsetting4_value_binding(value) {
    ctx[7](value);
  }
  let checkboxsetting4_props = {
    name: SettingsProvider.settings.moveTraitsBelowNpcResources.options.name,
    hint: SettingsProvider.settings.moveTraitsBelowNpcResources.options.hint,
    id: "moveTraitsBelowNpcResources"
  };
  if (
    /*$context*/
    ctx[0].settings.moveTraitsBelowNpcResources !== void 0
  ) {
    checkboxsetting4_props.value = /*$context*/
    ctx[0].settings.moveTraitsBelowNpcResources;
  }
  checkboxsetting4 = new CheckboxSetting({ props: checkboxsetting4_props });
  binding_callbacks.push(() => bind(checkboxsetting4, "value", checkboxsetting4_value_binding));
  function checkboxsetting5_value_binding(value) {
    ctx[8](value);
  }
  let checkboxsetting5_props = {
    name: SettingsProvider.settings.alwaysShowNpcSkills.options.name,
    hint: SettingsProvider.settings.alwaysShowNpcSkills.options.hint,
    id: "alwaysShowNpcSkills"
  };
  if (
    /*$context*/
    ctx[0].settings.alwaysShowNpcSkills !== void 0
  ) {
    checkboxsetting5_props.value = /*$context*/
    ctx[0].settings.alwaysShowNpcSkills;
  }
  checkboxsetting5 = new CheckboxSetting({ props: checkboxsetting5_props });
  binding_callbacks.push(() => bind(checkboxsetting5, "value", checkboxsetting5_value_binding));
  function checkboxsetting6_value_binding(value) {
    ctx[9](value);
  }
  let checkboxsetting6_props = {
    name: SettingsProvider.settings.showSpellbookTabNpc.options.name,
    hint: SettingsProvider.settings.showSpellbookTabNpc.options.hint,
    id: "showSpellbookTabNpc"
  };
  if (
    /*$context*/
    ctx[0].settings.showSpellbookTabNpc !== void 0
  ) {
    checkboxsetting6_props.value = /*$context*/
    ctx[0].settings.showSpellbookTabNpc;
  }
  checkboxsetting6 = new CheckboxSetting({ props: checkboxsetting6_props });
  binding_callbacks.push(() => bind(checkboxsetting6, "value", checkboxsetting6_value_binding));
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[2]("TIDY5E.UserSettings.TabNPCs.header")}`;
      t1 = space();
      create_component(checkboxsetting0.$$.fragment);
      t2 = space();
      create_component(checkboxsetting1.$$.fragment);
      t3 = space();
      create_component(checkboxsetting2.$$.fragment);
      t4 = space();
      create_component(checkboxsetting3.$$.fragment);
      t5 = space();
      create_component(checkboxsetting4.$$.fragment);
      t6 = space();
      create_component(checkboxsetting5.$$.fragment);
      t7 = space();
      create_component(checkboxsetting6.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, t1, anchor);
      mount_component(checkboxsetting0, target, anchor);
      insert(target, t2, anchor);
      mount_component(checkboxsetting1, target, anchor);
      insert(target, t3, anchor);
      mount_component(checkboxsetting2, target, anchor);
      insert(target, t4, anchor);
      mount_component(checkboxsetting3, target, anchor);
      insert(target, t5, anchor);
      mount_component(checkboxsetting4, target, anchor);
      insert(target, t6, anchor);
      mount_component(checkboxsetting5, target, anchor);
      insert(target, t7, anchor);
      mount_component(checkboxsetting6, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkboxsetting0_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.useClassicControlsForNpc;
        add_flush_callback(() => updating_value = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.useHpBarNpc;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
      const checkboxsetting2_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        checkboxsetting2_changes.value = /*$context*/
        ctx2[0].settings.useHpOverlayNpc;
        add_flush_callback(() => updating_value_2 = false);
      }
      checkboxsetting2.$set(checkboxsetting2_changes);
      const checkboxsetting3_changes = {};
      if (!updating_value_3 && dirty & /*$context*/
      1) {
        updating_value_3 = true;
        checkboxsetting3_changes.value = /*$context*/
        ctx2[0].settings.alwaysShowNpcTraits;
        add_flush_callback(() => updating_value_3 = false);
      }
      checkboxsetting3.$set(checkboxsetting3_changes);
      const checkboxsetting4_changes = {};
      if (!updating_value_4 && dirty & /*$context*/
      1) {
        updating_value_4 = true;
        checkboxsetting4_changes.value = /*$context*/
        ctx2[0].settings.moveTraitsBelowNpcResources;
        add_flush_callback(() => updating_value_4 = false);
      }
      checkboxsetting4.$set(checkboxsetting4_changes);
      const checkboxsetting5_changes = {};
      if (!updating_value_5 && dirty & /*$context*/
      1) {
        updating_value_5 = true;
        checkboxsetting5_changes.value = /*$context*/
        ctx2[0].settings.alwaysShowNpcSkills;
        add_flush_callback(() => updating_value_5 = false);
      }
      checkboxsetting5.$set(checkboxsetting5_changes);
      const checkboxsetting6_changes = {};
      if (!updating_value_6 && dirty & /*$context*/
      1) {
        updating_value_6 = true;
        checkboxsetting6_changes.value = /*$context*/
        ctx2[0].settings.showSpellbookTabNpc;
        add_flush_callback(() => updating_value_6 = false);
      }
      checkboxsetting6.$set(checkboxsetting6_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      transition_in(checkboxsetting2.$$.fragment, local);
      transition_in(checkboxsetting3.$$.fragment, local);
      transition_in(checkboxsetting4.$$.fragment, local);
      transition_in(checkboxsetting5.$$.fragment, local);
      transition_in(checkboxsetting6.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      transition_out(checkboxsetting2.$$.fragment, local);
      transition_out(checkboxsetting3.$$.fragment, local);
      transition_out(checkboxsetting4.$$.fragment, local);
      transition_out(checkboxsetting5.$$.fragment, local);
      transition_out(checkboxsetting6.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
      }
      destroy_component(checkboxsetting0, detaching);
      destroy_component(checkboxsetting1, detaching);
      destroy_component(checkboxsetting2, detaching);
      destroy_component(checkboxsetting3, detaching);
      destroy_component(checkboxsetting4, detaching);
      destroy_component(checkboxsetting5, detaching);
      destroy_component(checkboxsetting6, detaching);
    }
  };
}
function instance$4i($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useClassicControlsForNpc, value)) {
      $context.settings.useClassicControlsForNpc = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useHpBarNpc, value)) {
      $context.settings.useHpBarNpc = value;
      context.set($context);
    }
  }
  function checkboxsetting2_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useHpOverlayNpc, value)) {
      $context.settings.useHpOverlayNpc = value;
      context.set($context);
    }
  }
  function checkboxsetting3_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.alwaysShowNpcTraits, value)) {
      $context.settings.alwaysShowNpcTraits = value;
      context.set($context);
    }
  }
  function checkboxsetting4_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.moveTraitsBelowNpcResources, value)) {
      $context.settings.moveTraitsBelowNpcResources = value;
      context.set($context);
    }
  }
  function checkboxsetting5_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.alwaysShowNpcSkills, value)) {
      $context.settings.alwaysShowNpcSkills = value;
      context.set($context);
    }
  }
  function checkboxsetting6_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showSpellbookTabNpc, value)) {
      $context.settings.showSpellbookTabNpc = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    localize,
    checkboxsetting0_value_binding,
    checkboxsetting1_value_binding,
    checkboxsetting2_value_binding,
    checkboxsetting3_value_binding,
    checkboxsetting4_value_binding,
    checkboxsetting5_value_binding,
    checkboxsetting6_value_binding
  ];
}
class NpcSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4i, create_fragment$4j, safe_not_equal, {});
  }
}
function create_fragment$4i(ctx) {
  let h2;
  let t1;
  let checkboxsetting0;
  let updating_value;
  let t2;
  let checkboxsetting1;
  let updating_value_1;
  let t3;
  let checkboxsetting2;
  let updating_value_2;
  let current;
  function checkboxsetting0_value_binding(value) {
    ctx[3](value);
  }
  let checkboxsetting0_props = {
    name: SettingsProvider.settings.useClassicControlsForVehicle.options.name,
    hint: SettingsProvider.settings.useClassicControlsForVehicle.options.hint,
    id: "useClassicControlsForVehicle"
  };
  if (
    /*$context*/
    ctx[0].settings.useClassicControlsForVehicle !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.useClassicControlsForVehicle;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[4](value);
  }
  let checkboxsetting1_props = {
    name: SettingsProvider.settings.useHpBarVehicle.options.name,
    hint: SettingsProvider.settings.useHpBarVehicle.options.hint,
    id: "useHpBarVehicle"
  };
  if (
    /*$context*/
    ctx[0].settings.useHpBarVehicle !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.useHpBarVehicle;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  function checkboxsetting2_value_binding(value) {
    ctx[5](value);
  }
  let checkboxsetting2_props = {
    name: SettingsProvider.settings.useHpOverlayVehicle.options.name,
    hint: SettingsProvider.settings.useHpOverlayVehicle.options.hint,
    id: "useHpOverlayVehicle"
  };
  if (
    /*$context*/
    ctx[0].settings.useHpOverlayVehicle !== void 0
  ) {
    checkboxsetting2_props.value = /*$context*/
    ctx[0].settings.useHpOverlayVehicle;
  }
  checkboxsetting2 = new CheckboxSetting({ props: checkboxsetting2_props });
  binding_callbacks.push(() => bind(checkboxsetting2, "value", checkboxsetting2_value_binding));
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[2]("TIDY5E.UserSettings.TabVehicles.header")}`;
      t1 = space();
      create_component(checkboxsetting0.$$.fragment);
      t2 = space();
      create_component(checkboxsetting1.$$.fragment);
      t3 = space();
      create_component(checkboxsetting2.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, t1, anchor);
      mount_component(checkboxsetting0, target, anchor);
      insert(target, t2, anchor);
      mount_component(checkboxsetting1, target, anchor);
      insert(target, t3, anchor);
      mount_component(checkboxsetting2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkboxsetting0_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.useClassicControlsForVehicle;
        add_flush_callback(() => updating_value = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.useHpBarVehicle;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
      const checkboxsetting2_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        checkboxsetting2_changes.value = /*$context*/
        ctx2[0].settings.useHpOverlayVehicle;
        add_flush_callback(() => updating_value_2 = false);
      }
      checkboxsetting2.$set(checkboxsetting2_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      transition_in(checkboxsetting2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      transition_out(checkboxsetting2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t1);
        detach(t2);
        detach(t3);
      }
      destroy_component(checkboxsetting0, detaching);
      destroy_component(checkboxsetting1, detaching);
      destroy_component(checkboxsetting2, detaching);
    }
  };
}
function instance$4h($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useClassicControlsForVehicle, value)) {
      $context.settings.useClassicControlsForVehicle = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useHpBarVehicle, value)) {
      $context.settings.useHpBarVehicle = value;
      context.set($context);
    }
  }
  function checkboxsetting2_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useHpOverlayVehicle, value)) {
      $context.settings.useHpOverlayVehicle = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    localize,
    checkboxsetting0_value_binding,
    checkboxsetting1_value_binding,
    checkboxsetting2_value_binding
  ];
}
class VehicleSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4h, create_fragment$4i, safe_not_equal, {});
  }
}
function create_fragment$4h(ctx) {
  let h2;
  let t1;
  let checkboxsetting0;
  let updating_value;
  let t2;
  let checkboxsetting1;
  let updating_value_1;
  let t3;
  let checkboxsetting2;
  let updating_value_2;
  let t4;
  let checkboxsetting3;
  let updating_value_3;
  let t5;
  let checkboxsetting4;
  let updating_value_4;
  let current;
  function checkboxsetting0_value_binding(value) {
    ctx[3](value);
  }
  let checkboxsetting0_props = {
    name: SettingsProvider.settings.actionListLimitActionsToCantrips.options.name,
    hint: SettingsProvider.settings.actionListLimitActionsToCantrips.options.hint,
    id: "actionListLimitActionsToCantrips"
  };
  if (
    /*$context*/
    ctx[0].settings.actionListLimitActionsToCantrips !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.actionListLimitActionsToCantrips;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[4](value);
  }
  let checkboxsetting1_props = {
    name: SettingsProvider.settings.actionListIncludeMinuteLongSpellsAsActions.options.name,
    hint: SettingsProvider.settings.actionListIncludeMinuteLongSpellsAsActions.options.hint,
    id: "actionListIncludeMinuteLongSpellsAsActions"
  };
  if (
    /*$context*/
    ctx[0].settings.actionListIncludeMinuteLongSpellsAsActions !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.actionListIncludeMinuteLongSpellsAsActions;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  function checkboxsetting2_value_binding(value) {
    ctx[5](value);
  }
  let checkboxsetting2_props = {
    name: SettingsProvider.settings.actionListIncludeSpellsWithActiveEffects.options.name,
    hint: SettingsProvider.settings.actionListIncludeSpellsWithActiveEffects.options.hint,
    id: "actionListIncludeSpellsWithActiveEffects"
  };
  if (
    /*$context*/
    ctx[0].settings.actionListIncludeSpellsWithActiveEffects !== void 0
  ) {
    checkboxsetting2_props.value = /*$context*/
    ctx[0].settings.actionListIncludeSpellsWithActiveEffects;
  }
  checkboxsetting2 = new CheckboxSetting({ props: checkboxsetting2_props });
  binding_callbacks.push(() => bind(checkboxsetting2, "value", checkboxsetting2_value_binding));
  function checkboxsetting3_value_binding(value) {
    ctx[6](value);
  }
  let checkboxsetting3_props = {
    name: SettingsProvider.settings.actionListIncludeConsumables.options.name,
    hint: SettingsProvider.settings.actionListIncludeConsumables.options.hint,
    id: "actionListIncludeConsumables"
  };
  if (
    /*$context*/
    ctx[0].settings.actionListIncludeConsumables !== void 0
  ) {
    checkboxsetting3_props.value = /*$context*/
    ctx[0].settings.actionListIncludeConsumables;
  }
  checkboxsetting3 = new CheckboxSetting({ props: checkboxsetting3_props });
  binding_callbacks.push(() => bind(checkboxsetting3, "value", checkboxsetting3_value_binding));
  function checkboxsetting4_value_binding(value) {
    ctx[7](value);
  }
  let checkboxsetting4_props = {
    name: SettingsProvider.settings.actionListScaleCantripDamage.options.name,
    hint: SettingsProvider.settings.actionListScaleCantripDamage.options.hint,
    id: "actionListScaleCantripDamage"
  };
  if (
    /*$context*/
    ctx[0].settings.actionListScaleCantripDamage !== void 0
  ) {
    checkboxsetting4_props.value = /*$context*/
    ctx[0].settings.actionListScaleCantripDamage;
  }
  checkboxsetting4 = new CheckboxSetting({ props: checkboxsetting4_props });
  binding_callbacks.push(() => bind(checkboxsetting4, "value", checkboxsetting4_value_binding));
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[2]("TIDY5E.Settings.ActionList.Header")}`;
      t1 = space();
      create_component(checkboxsetting0.$$.fragment);
      t2 = space();
      create_component(checkboxsetting1.$$.fragment);
      t3 = space();
      create_component(checkboxsetting2.$$.fragment);
      t4 = space();
      create_component(checkboxsetting3.$$.fragment);
      t5 = space();
      create_component(checkboxsetting4.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, t1, anchor);
      mount_component(checkboxsetting0, target, anchor);
      insert(target, t2, anchor);
      mount_component(checkboxsetting1, target, anchor);
      insert(target, t3, anchor);
      mount_component(checkboxsetting2, target, anchor);
      insert(target, t4, anchor);
      mount_component(checkboxsetting3, target, anchor);
      insert(target, t5, anchor);
      mount_component(checkboxsetting4, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkboxsetting0_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.actionListLimitActionsToCantrips;
        add_flush_callback(() => updating_value = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.actionListIncludeMinuteLongSpellsAsActions;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
      const checkboxsetting2_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        checkboxsetting2_changes.value = /*$context*/
        ctx2[0].settings.actionListIncludeSpellsWithActiveEffects;
        add_flush_callback(() => updating_value_2 = false);
      }
      checkboxsetting2.$set(checkboxsetting2_changes);
      const checkboxsetting3_changes = {};
      if (!updating_value_3 && dirty & /*$context*/
      1) {
        updating_value_3 = true;
        checkboxsetting3_changes.value = /*$context*/
        ctx2[0].settings.actionListIncludeConsumables;
        add_flush_callback(() => updating_value_3 = false);
      }
      checkboxsetting3.$set(checkboxsetting3_changes);
      const checkboxsetting4_changes = {};
      if (!updating_value_4 && dirty & /*$context*/
      1) {
        updating_value_4 = true;
        checkboxsetting4_changes.value = /*$context*/
        ctx2[0].settings.actionListScaleCantripDamage;
        add_flush_callback(() => updating_value_4 = false);
      }
      checkboxsetting4.$set(checkboxsetting4_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      transition_in(checkboxsetting2.$$.fragment, local);
      transition_in(checkboxsetting3.$$.fragment, local);
      transition_in(checkboxsetting4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      transition_out(checkboxsetting2.$$.fragment, local);
      transition_out(checkboxsetting3.$$.fragment, local);
      transition_out(checkboxsetting4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
      }
      destroy_component(checkboxsetting0, detaching);
      destroy_component(checkboxsetting1, detaching);
      destroy_component(checkboxsetting2, detaching);
      destroy_component(checkboxsetting3, detaching);
      destroy_component(checkboxsetting4, detaching);
    }
  };
}
function instance$4g($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.actionListLimitActionsToCantrips, value)) {
      $context.settings.actionListLimitActionsToCantrips = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.actionListIncludeMinuteLongSpellsAsActions, value)) {
      $context.settings.actionListIncludeMinuteLongSpellsAsActions = value;
      context.set($context);
    }
  }
  function checkboxsetting2_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.actionListIncludeSpellsWithActiveEffects, value)) {
      $context.settings.actionListIncludeSpellsWithActiveEffects = value;
      context.set($context);
    }
  }
  function checkboxsetting3_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.actionListIncludeConsumables, value)) {
      $context.settings.actionListIncludeConsumables = value;
      context.set($context);
    }
  }
  function checkboxsetting4_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.actionListScaleCantripDamage, value)) {
      $context.settings.actionListScaleCantripDamage = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    localize,
    checkboxsetting0_value_binding,
    checkboxsetting1_value_binding,
    checkboxsetting2_value_binding,
    checkboxsetting3_value_binding,
    checkboxsetting4_value_binding
  ];
}
class ActionsListSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4g, create_fragment$4h, safe_not_equal, {});
  }
}
function create_fragment$4g(ctx) {
  let div3;
  let div1;
  let tabs_1;
  let updating_selectedTabId;
  let t0;
  let div0;
  let t1;
  let tabcontents;
  let t2;
  let div2;
  let button0;
  let i0;
  let t3;
  let t4_value = (
    /*localize*/
    ctx[6]("TIDY5E.SaveChanges") + ""
  );
  let t4;
  let t5;
  let button1;
  let i1;
  let t6;
  let t7_value = (
    /*localize*/
    ctx[6]("TIDY5E.ApplyChanges") + ""
  );
  let t7;
  let current;
  let mounted;
  let dispose;
  function tabs_1_selectedTabId_binding(value) {
    ctx[7](value);
  }
  let tabs_1_props = {
    tabs: (
      /*tabs*/
      ctx[1]
    ),
    orientation: "vertical"
  };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_1_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "selectedTabId", tabs_1_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*tabs*/
        ctx[1]
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      ),
      cssClass: "tidy-sheet-body"
    }
  });
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      create_component(tabs_1.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = space();
      create_component(tabcontents.$$.fragment);
      t2 = space();
      div2 = element("div");
      button0 = element("button");
      i0 = element("i");
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      button1 = element("button");
      i1 = element("i");
      t6 = space();
      t7 = text(t7_value);
      attr(div0, "role", "presentation");
      attr(div0, "class", "remaining-vertical-space svelte-1ya24fr");
      attr(div1, "role", "presentation");
      attr(div1, "class", "vertical-tab-container flex-column no-gap svelte-1ya24fr");
      attr(i0, "class", "fas fa-save");
      attr(button0, "type", "button");
      attr(button0, "class", "save-changes-btn");
      button0.disabled = /*applyingChanges*/
      ctx[2];
      attr(i1, "class", "fas fa-check");
      attr(button1, "type", "button");
      attr(button1, "class", "apply-changes-btn");
      button1.disabled = /*applyingChanges*/
      ctx[2];
      attr(div2, "class", "button-bar svelte-1ya24fr");
      attr(div3, "class", "settings-form svelte-1ya24fr");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      mount_component(tabs_1, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div3, t1);
      mount_component(tabcontents, div3, null);
      append(div3, t2);
      append(div3, div2);
      append(div2, button0);
      append(button0, i0);
      append(button0, t3);
      append(button0, t4);
      append(div2, t5);
      append(div2, button1);
      append(button1, i1);
      append(button1, t6);
      append(button1, t7);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*save*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*apply*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const tabs_1_changes = {};
      if (dirty & /*tabs*/
      2) tabs_1_changes.tabs = /*tabs*/
      ctx2[1];
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_1_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabcontents_changes = {};
      if (dirty & /*tabs*/
      2) tabcontents_changes.tabs = /*tabs*/
      ctx2[1];
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
      if (!current || dirty & /*applyingChanges*/
      4) {
        button0.disabled = /*applyingChanges*/
        ctx2[2];
      }
      if (!current || dirty & /*applyingChanges*/
      4) {
        button1.disabled = /*applyingChanges*/
        ctx2[2];
      }
    },
    i(local) {
      if (current) return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(tabs_1);
      destroy_component(tabcontents);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4f($$self, $$props, $$invalidate) {
  let $context;
  let selectedTabId = getContext(CONSTANTS.SVELTE_CONTEXT.INITIAL_TAB_ID);
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(8, $context = value));
  let functions = getContext(CONSTANTS.SVELTE_CONTEXT.FUNCTIONS);
  let tabs = [];
  tabs = [
    {
      id: CONSTANTS.TAB_USER_SETTINGS_PLAYERS,
      title: "TIDY5E.UserSettings.TabPlayers.tabLabel",
      content: {
        component: PlayerSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_USER_SETTINGS_NPCS,
      title: "TIDY5E.UserSettings.TabNPCs.tabLabel",
      content: {
        component: NpcSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_USER_SETTINGS_VEHICLES,
      title: "TIDY5E.UserSettings.TabVehicles.tabLabel",
      content: {
        component: VehicleSettingsTab,
        type: "svelte"
      }
    }
  ];
  tabs.push({
    id: CONSTANTS.TAB_USER_SETTINGS_ACTIONS_LIST,
    title: "TIDY5E.UserSettings.TabActionsList.tabLabel",
    content: {
      component: ActionsListSettingsTab,
      type: "svelte"
    }
  });
  selectedTabId ??= tabs[0].id;
  let applyingChanges = false;
  async function save() {
    $$invalidate(2, applyingChanges = true);
    try {
      await functions.save($context);
    } finally {
      $$invalidate(2, applyingChanges = false);
    }
  }
  async function apply() {
    $$invalidate(2, applyingChanges = true);
    try {
      await functions.apply($context);
    } finally {
      $$invalidate(2, applyingChanges = false);
    }
  }
  const localize = FoundryAdapter.localize;
  function tabs_1_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [
    selectedTabId,
    tabs,
    applyingChanges,
    context,
    save,
    apply,
    localize,
    tabs_1_selectedTabId_binding
  ];
}
class UserSettings extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4f, create_fragment$4g, safe_not_equal, {});
  }
}
class UserSettingsFormApplication extends SvelteFormApplicationBase {
  initialTabId;
  constructor(initialTabId, ...args) {
    super(...args);
    this.initialTabId = initialTabId ?? CONSTANTS.TAB_USER_SETTINGS_PLAYERS;
  }
  static get defaultOptions() {
    return {
      ...super.defaultOptions,
      height: 750,
      width: 750,
      classes: [...super.defaultOptions.classes, "settings"],
      id: "tidy-5e-sheets-user-settings",
      popOut: true
    };
  }
  get template() {
    return FoundryAdapter.getTemplate("empty-form-template.hbs");
  }
  get title() {
    return FoundryAdapter.localize("TIDY5E.UserSettings.Menu.title", {
      userName: game.user.name
    });
  }
  getData() {
    const currentSettings = getCurrentSettings();
    return {
      settings: {
        actionListIncludeConsumables: currentSettings.actionListIncludeConsumables,
        actionListIncludeMinuteLongSpellsAsActions: currentSettings.actionListIncludeMinuteLongSpellsAsActions,
        actionListIncludeSpellsWithActiveEffects: currentSettings.actionListIncludeSpellsWithActiveEffects,
        actionListLimitActionsToCantrips: currentSettings.actionListLimitActionsToCantrips,
        actionListScaleCantripDamage: currentSettings.actionListScaleCantripDamage,
        alwaysShowNpcSkills: currentSettings.alwaysShowNpcSkills,
        alwaysShowNpcTraits: currentSettings.alwaysShowNpcTraits,
        animateInspiration: currentSettings.animateInspiration,
        hideIfZero: currentSettings.hideIfZero,
        moveTraitsBelowCharacterResources: currentSettings.moveTraitsBelowCharacterResources,
        moveTraitsBelowNpcResources: currentSettings.moveTraitsBelowNpcResources,
        showClassList: currentSettings.showClassList,
        showEquippedAmmoOnly: currentSettings.showEquippedAmmoOnly,
        showExhaustionOnHover: currentSettings.showExhaustionOnHover,
        showIconsNextToTheItemName: currentSettings.showIconsNextToTheItemName,
        showInspirationOnHover: currentSettings.showInspirationOnHover,
        showSpellbookTabNpc: currentSettings.showSpellbookTabNpc,
        toggleEmptyCharacterSkills: currentSettings.toggleEmptyCharacterSkills,
        toggleEmptyCharacterTraits: currentSettings.toggleEmptyCharacterTraits,
        useClassicControlsForCharacter: currentSettings.useClassicControlsForCharacter,
        useClassicControlsForNpc: currentSettings.useClassicControlsForNpc,
        useClassicControlsForVehicle: currentSettings.useClassicControlsForVehicle,
        useContextMenu: currentSettings.useContextMenu,
        useHpBar: currentSettings.useHpBar,
        useHpBarNpc: currentSettings.useHpBarNpc,
        useHpBarVehicle: currentSettings.useHpBarVehicle,
        useHpOverlay: currentSettings.useHpOverlay,
        useHpOverlayNpc: currentSettings.useHpOverlayNpc,
        useHpOverlayVehicle: currentSettings.useHpOverlayVehicle,
        useMulticlassSpellbookFilter: currentSettings.useMulticlassSpellbookFilter,
        useSpellClassFilterIcons: currentSettings.useSpellClassFilterIcons
      }
    };
  }
  createComponent(node) {
    const data = this.getData();
    debug("Sheet Settings context data", data);
    return new UserSettings({
      target: node,
      context: /* @__PURE__ */ new Map([
        ["context", writable(data)],
        [
          "functions",
          {
            save: this.saveChangedSettings.bind(this),
            apply: this.applyChangedSettings.bind(this),
            validate: this.validate.bind(this)
          }
        ],
        ["appId", this.appId],
        ["initialTabId", this.initialTabId]
      ])
    });
  }
  validate(context) {
    let valid = true;
    return valid;
  }
  async applyChangedSettings(context) {
    if (!this.validate(context)) {
      return false;
    }
    const newSettings = {
      ...context.settings
    };
    const currentSettings = getCurrentSettings();
    const keys = Object.keys(newSettings);
    for (let key of keys) {
      const currentValue = currentSettings[key];
      const newValue = newSettings[key];
      if (currentValue !== newValue) {
        await FoundryAdapter.setTidySetting(key, newValue);
        debug(`Updated ${key} to ${newValue}`);
      }
    }
    return true;
  }
  async saveChangedSettings(context) {
    const changesApplied = await this.applyChangedSettings(context);
    if (!changesApplied) {
      return;
    }
    this.close();
  }
}
function get_each_context$18(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2][0];
  child_ctx[8] = list[i2][1];
  return child_ctx;
}
function create_if_block$1T(ctx) {
  let option;
  let t_value = (
    /*localize*/
    ctx[4](
      /*blank*/
      ctx[1]
    ) + ""
  );
  let t2;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = "";
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*blank*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[4](
        /*blank*/
        ctx2[1]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block$18(ctx) {
  let option;
  let t_value = (
    /*localize*/
    ctx[4](
      /*getLabel*/
      ctx[2](
        /*value*/
        ctx[8]
      )
    ) + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*getValue*/
      ctx[3](
        /*key*/
        ctx[7],
        /*value*/
        ctx[8]
      );
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*data*/
      1 && t_value !== (t_value = /*localize*/
      ctx2[4](
        /*getLabel*/
        ctx2[2](
          /*value*/
          ctx2[8]
        )
      ) + "")) set_data(t2, t_value);
      if (dirty & /*data*/
      1 && option_value_value !== (option_value_value = /*getValue*/
      ctx2[3](
        /*key*/
        ctx2[7],
        /*value*/
        ctx2[8]
      ))) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment$4f(ctx) {
  let t2;
  let each_1_anchor;
  let if_block = (
    /*blank*/
    ctx[1] !== null && create_if_block$1T(ctx)
  );
  let each_value = ensure_array_like(Object.entries(
    /*data*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$18(get_each_context$18(ctx, each_value, i2));
  }
  return {
    c() {
      if (if_block) if_block.c();
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*blank*/
        ctx2[1] !== null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1T(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*getValue, Object, data, localize, getLabel*/
      29) {
        each_value = ensure_array_like(Object.entries(
          /*data*/
          ctx2[0]
        ));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$18(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$18(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(each_1_anchor);
      }
      if (if_block) if_block.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$4e($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { valueProp = null } = $$props;
  let { labelProp = null } = $$props;
  let { blank = null } = $$props;
  function getLabel(value) {
    if (labelProp !== null && value !== null && typeof value === "object" && labelProp in value) {
      return value[labelProp]?.toString() ?? "";
    }
    return value?.toString() ?? "";
  }
  function getValue(key, value) {
    if (valueProp !== null && value !== null && typeof value === "object" && valueProp in value) {
      return value[valueProp]?.toString() ?? "";
    }
    return key;
  }
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(0, data = $$props2.data);
    if ("valueProp" in $$props2) $$invalidate(5, valueProp = $$props2.valueProp);
    if ("labelProp" in $$props2) $$invalidate(6, labelProp = $$props2.labelProp);
    if ("blank" in $$props2) $$invalidate(1, blank = $$props2.blank);
  };
  return [data, blank, getLabel, getValue, localize, valueProp, labelProp];
}
class SelectOptions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4e, create_fragment$4f, safe_not_equal, {
      data: 0,
      valueProp: 5,
      labelProp: 6,
      blank: 1
    });
  }
}
const get_additional_inputs_slot_changes = (dirty) => ({});
const get_additional_inputs_slot_context = (ctx) => ({});
function create_fragment$4e(ctx) {
  let article;
  let section;
  let div0;
  let label;
  let t0_value = (
    /*localize*/
    ctx[6](
      /*name*/
      ctx[1]
    ) + ""
  );
  let t0;
  let label_for_value;
  let t1;
  let p2;
  let t2_value = (
    /*localize*/
    ctx[6](
      /*hint*/
      ctx[2]
    ) + ""
  );
  let t2;
  let t3;
  let div1;
  let select;
  let selectoptions;
  let select_id_value;
  let t4;
  let current;
  let mounted;
  let dispose;
  selectoptions = new SelectOptions({ props: { data: (
    /*options*/
    ctx[4]
  ) } });
  const additional_inputs_slot_template = (
    /*#slots*/
    ctx[8]["additional-inputs"]
  );
  const additional_inputs_slot = create_slot(
    additional_inputs_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_additional_inputs_slot_context
  );
  return {
    c() {
      article = element("article");
      section = element("section");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      t2 = text(t2_value);
      t3 = space();
      div1 = element("div");
      select = element("select");
      create_component(selectoptions.$$.fragment);
      t4 = space();
      if (additional_inputs_slot) additional_inputs_slot.c();
      attr(label, "for", label_for_value = /*id*/
      ctx[3] + "-" + /*appId*/
      ctx[5]);
      attr(p2, "class", "tidy5e-notes");
      attr(div0, "class", "description");
      attr(select, "id", select_id_value = /*id*/
      ctx[3] + "-" + /*appId*/
      ctx[5]);
      if (
        /*value*/
        ctx[0] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[9].call(select)
      ));
      attr(div1, "class", "settings-group");
      attr(article, "class", "setting group");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, section);
      append(section, div0);
      append(div0, label);
      append(label, t0);
      append(div0, t1);
      append(div0, p2);
      append(p2, t2);
      append(section, t3);
      append(section, div1);
      append(div1, select);
      mount_component(selectoptions, select, null);
      select_option(
        select,
        /*value*/
        ctx[0],
        true
      );
      append(div1, t4);
      if (additional_inputs_slot) {
        additional_inputs_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*name*/
      2) && t0_value !== (t0_value = /*localize*/
      ctx2[6](
        /*name*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if (!current || dirty & /*id*/
      8 && label_for_value !== (label_for_value = /*id*/
      ctx2[3] + "-" + /*appId*/
      ctx2[5])) {
        attr(label, "for", label_for_value);
      }
      if ((!current || dirty & /*hint*/
      4) && t2_value !== (t2_value = /*localize*/
      ctx2[6](
        /*hint*/
        ctx2[2]
      ) + "")) set_data(t2, t2_value);
      const selectoptions_changes = {};
      if (dirty & /*options*/
      16) selectoptions_changes.data = /*options*/
      ctx2[4];
      selectoptions.$set(selectoptions_changes);
      if (!current || dirty & /*id*/
      8 && select_id_value !== (select_id_value = /*id*/
      ctx2[3] + "-" + /*appId*/
      ctx2[5])) {
        attr(select, "id", select_id_value);
      }
      if (dirty & /*value*/
      1) {
        select_option(
          select,
          /*value*/
          ctx2[0]
        );
      }
      if (additional_inputs_slot) {
        if (additional_inputs_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            additional_inputs_slot,
            additional_inputs_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              additional_inputs_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_additional_inputs_slot_changes
            ),
            get_additional_inputs_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      transition_in(additional_inputs_slot, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      transition_out(additional_inputs_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(selectoptions);
      if (additional_inputs_slot) additional_inputs_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$4d($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { value } = $$props;
  let { name } = $$props;
  let { hint } = $$props;
  let { id } = $$props;
  let { options } = $$props;
  const appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  const localize = FoundryAdapter.localize;
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("name" in $$props2) $$invalidate(1, name = $$props2.name);
    if ("hint" in $$props2) $$invalidate(2, hint = $$props2.hint);
    if ("id" in $$props2) $$invalidate(3, id = $$props2.id);
    if ("options" in $$props2) $$invalidate(4, options = $$props2.options);
    if ("$$scope" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [
    value,
    name,
    hint,
    id,
    options,
    appId,
    localize,
    $$scope,
    slots,
    select_change_handler
  ];
}
class SelectSetting extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4d, create_fragment$4e, safe_not_equal, {
      value: 0,
      name: 1,
      hint: 2,
      id: 3,
      options: 4
    });
  }
}
function create_fragment$4d(ctx) {
  let checkboxsetting0;
  let updating_value;
  let t0;
  let checkboxsetting1;
  let updating_value_1;
  let t1;
  let textinputsetting;
  let updating_value_2;
  let t2;
  let selectsetting;
  let updating_value_3;
  let t3;
  let checkboxsetting2;
  let updating_value_4;
  let t4;
  let checkboxsetting3;
  let updating_value_5;
  let t5;
  let checkboxsetting4;
  let updating_value_6;
  let t6;
  let checkboxsetting5;
  let updating_value_7;
  let current;
  function checkboxsetting0_value_binding(value) {
    ctx[2](value);
  }
  let checkboxsetting0_props = {
    name: "TIDY5E.Settings.HideDeathSavesFromPlayers.name",
    hint: "TIDY5E.Settings.HideDeathSavesFromPlayers.hint",
    id: "hideDeathSavesFromPlayers"
  };
  if (
    /*$context*/
    ctx[0].settings.hideDeathSavesFromPlayers !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.hideDeathSavesFromPlayers;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[3](value);
  }
  let checkboxsetting1_props = {
    name: "TIDY5E.Settings.ShowExpandedLimitedView.name",
    hint: "TIDY5E.Settings.ShowExpandedLimitedView.hint",
    id: "showExpandedLimitedView"
  };
  if (
    /*$context*/
    ctx[0].settings.showExpandedLimitedView !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.showExpandedLimitedView;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  function textinputsetting_value_binding(value) {
    ctx[4](value);
  }
  let textinputsetting_props = {
    name: "TIDY5E.Settings.ItemCardsFixKey.name",
    hint: "TIDY5E.Settings.ItemCardsFixKey.hint",
    id: "itemCardsFixKey"
  };
  if (
    /*$context*/
    ctx[0].settings.itemCardsFixKey !== void 0
  ) {
    textinputsetting_props.value = /*$context*/
    ctx[0].settings.itemCardsFixKey;
  }
  textinputsetting = new TextInputSetting({ props: textinputsetting_props });
  binding_callbacks.push(() => bind(textinputsetting, "value", textinputsetting_value_binding));
  function selectsetting_value_binding(value) {
    ctx[5](value);
  }
  let selectsetting_props = {
    options: SettingsProvider.settings.useCircularPortraitStyle.options.choices,
    name: "TIDY5E.Settings.UseCircularPortraitStyle.name",
    hint: "TIDY5E.Settings.UseCircularPortraitStyle.hint",
    id: "useCircularPortraitStyle"
  };
  if (
    /*$context*/
    ctx[0].settings.useCircularPortraitStyle !== void 0
  ) {
    selectsetting_props.value = /*$context*/
    ctx[0].settings.useCircularPortraitStyle;
  }
  selectsetting = new SelectSetting({ props: selectsetting_props });
  binding_callbacks.push(() => bind(selectsetting, "value", selectsetting_value_binding));
  function checkboxsetting2_value_binding(value) {
    ctx[6](value);
  }
  let checkboxsetting2_props = {
    name: "TIDY5E.Settings.LimitEffectsManagementToGM.name",
    hint: "TIDY5E.Settings.LimitEffectsManagementToGM.hint",
    id: "limitEffectsManagementToGm"
  };
  if (
    /*$context*/
    ctx[0].settings.limitEffectsManagementToGm !== void 0
  ) {
    checkboxsetting2_props.value = /*$context*/
    ctx[0].settings.limitEffectsManagementToGm;
  }
  checkboxsetting2 = new CheckboxSetting({ props: checkboxsetting2_props });
  binding_callbacks.push(() => bind(checkboxsetting2, "value", checkboxsetting2_value_binding));
  function checkboxsetting3_value_binding(value) {
    ctx[7](value);
  }
  let checkboxsetting3_props = {
    name: "TIDY5E.Settings.ShowTraitLabels.name",
    hint: "TIDY5E.Settings.ShowTraitLabels.hint",
    id: "showTraitLabels"
  };
  if (
    /*$context*/
    ctx[0].settings.showTraitLabels !== void 0
  ) {
    checkboxsetting3_props.value = /*$context*/
    ctx[0].settings.showTraitLabels;
  }
  checkboxsetting3 = new CheckboxSetting({ props: checkboxsetting3_props });
  binding_callbacks.push(() => bind(checkboxsetting3, "value", checkboxsetting3_value_binding));
  function checkboxsetting4_value_binding(value) {
    ctx[8](value);
  }
  let checkboxsetting4_props = {
    name: "TIDY5E.Settings.AllowCantripsToBePrepared.name",
    hint: "TIDY5E.Settings.AllowCantripsToBePrepared.hint",
    id: "allowCantripsToBePrepared"
  };
  if (
    /*$context*/
    ctx[0].settings.allowCantripsToBePrepared !== void 0
  ) {
    checkboxsetting4_props.value = /*$context*/
    ctx[0].settings.allowCantripsToBePrepared;
  }
  checkboxsetting4 = new CheckboxSetting({ props: checkboxsetting4_props });
  binding_callbacks.push(() => bind(checkboxsetting4, "value", checkboxsetting4_value_binding));
  function checkboxsetting5_value_binding(value) {
    ctx[9](value);
  }
  let checkboxsetting5_props = {
    name: "TIDY5E.Settings.ShowActiveEffectsMarker.name",
    hint: "TIDY5E.Settings.ShowActiveEffectsMarker.hint",
    id: "showActiveEffectsMarker"
  };
  if (
    /*$context*/
    ctx[0].settings.showActiveEffectsMarker !== void 0
  ) {
    checkboxsetting5_props.value = /*$context*/
    ctx[0].settings.showActiveEffectsMarker;
  }
  checkboxsetting5 = new CheckboxSetting({ props: checkboxsetting5_props });
  binding_callbacks.push(() => bind(checkboxsetting5, "value", checkboxsetting5_value_binding));
  return {
    c() {
      create_component(checkboxsetting0.$$.fragment);
      t0 = space();
      create_component(checkboxsetting1.$$.fragment);
      t1 = space();
      create_component(textinputsetting.$$.fragment);
      t2 = space();
      create_component(selectsetting.$$.fragment);
      t3 = space();
      create_component(checkboxsetting2.$$.fragment);
      t4 = space();
      create_component(checkboxsetting3.$$.fragment);
      t5 = space();
      create_component(checkboxsetting4.$$.fragment);
      t6 = space();
      create_component(checkboxsetting5.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkboxsetting0, target, anchor);
      insert(target, t0, anchor);
      mount_component(checkboxsetting1, target, anchor);
      insert(target, t1, anchor);
      mount_component(textinputsetting, target, anchor);
      insert(target, t2, anchor);
      mount_component(selectsetting, target, anchor);
      insert(target, t3, anchor);
      mount_component(checkboxsetting2, target, anchor);
      insert(target, t4, anchor);
      mount_component(checkboxsetting3, target, anchor);
      insert(target, t5, anchor);
      mount_component(checkboxsetting4, target, anchor);
      insert(target, t6, anchor);
      mount_component(checkboxsetting5, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkboxsetting0_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.hideDeathSavesFromPlayers;
        add_flush_callback(() => updating_value = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.showExpandedLimitedView;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
      const textinputsetting_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        textinputsetting_changes.value = /*$context*/
        ctx2[0].settings.itemCardsFixKey;
        add_flush_callback(() => updating_value_2 = false);
      }
      textinputsetting.$set(textinputsetting_changes);
      const selectsetting_changes = {};
      if (!updating_value_3 && dirty & /*$context*/
      1) {
        updating_value_3 = true;
        selectsetting_changes.value = /*$context*/
        ctx2[0].settings.useCircularPortraitStyle;
        add_flush_callback(() => updating_value_3 = false);
      }
      selectsetting.$set(selectsetting_changes);
      const checkboxsetting2_changes = {};
      if (!updating_value_4 && dirty & /*$context*/
      1) {
        updating_value_4 = true;
        checkboxsetting2_changes.value = /*$context*/
        ctx2[0].settings.limitEffectsManagementToGm;
        add_flush_callback(() => updating_value_4 = false);
      }
      checkboxsetting2.$set(checkboxsetting2_changes);
      const checkboxsetting3_changes = {};
      if (!updating_value_5 && dirty & /*$context*/
      1) {
        updating_value_5 = true;
        checkboxsetting3_changes.value = /*$context*/
        ctx2[0].settings.showTraitLabels;
        add_flush_callback(() => updating_value_5 = false);
      }
      checkboxsetting3.$set(checkboxsetting3_changes);
      const checkboxsetting4_changes = {};
      if (!updating_value_6 && dirty & /*$context*/
      1) {
        updating_value_6 = true;
        checkboxsetting4_changes.value = /*$context*/
        ctx2[0].settings.allowCantripsToBePrepared;
        add_flush_callback(() => updating_value_6 = false);
      }
      checkboxsetting4.$set(checkboxsetting4_changes);
      const checkboxsetting5_changes = {};
      if (!updating_value_7 && dirty & /*$context*/
      1) {
        updating_value_7 = true;
        checkboxsetting5_changes.value = /*$context*/
        ctx2[0].settings.showActiveEffectsMarker;
        add_flush_callback(() => updating_value_7 = false);
      }
      checkboxsetting5.$set(checkboxsetting5_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      transition_in(textinputsetting.$$.fragment, local);
      transition_in(selectsetting.$$.fragment, local);
      transition_in(checkboxsetting2.$$.fragment, local);
      transition_in(checkboxsetting3.$$.fragment, local);
      transition_in(checkboxsetting4.$$.fragment, local);
      transition_in(checkboxsetting5.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      transition_out(textinputsetting.$$.fragment, local);
      transition_out(selectsetting.$$.fragment, local);
      transition_out(checkboxsetting2.$$.fragment, local);
      transition_out(checkboxsetting3.$$.fragment, local);
      transition_out(checkboxsetting4.$$.fragment, local);
      transition_out(checkboxsetting5.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
      }
      destroy_component(checkboxsetting0, detaching);
      destroy_component(checkboxsetting1, detaching);
      destroy_component(textinputsetting, detaching);
      destroy_component(selectsetting, detaching);
      destroy_component(checkboxsetting2, detaching);
      destroy_component(checkboxsetting3, detaching);
      destroy_component(checkboxsetting4, detaching);
      destroy_component(checkboxsetting5, detaching);
    }
  };
}
function instance$4c($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.hideDeathSavesFromPlayers, value)) {
      $context.settings.hideDeathSavesFromPlayers = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showExpandedLimitedView, value)) {
      $context.settings.showExpandedLimitedView = value;
      context.set($context);
    }
  }
  function textinputsetting_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.itemCardsFixKey, value)) {
      $context.settings.itemCardsFixKey = value;
      context.set($context);
    }
  }
  function selectsetting_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useCircularPortraitStyle, value)) {
      $context.settings.useCircularPortraitStyle = value;
      context.set($context);
    }
  }
  function checkboxsetting2_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.limitEffectsManagementToGm, value)) {
      $context.settings.limitEffectsManagementToGm = value;
      context.set($context);
    }
  }
  function checkboxsetting3_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showTraitLabels, value)) {
      $context.settings.showTraitLabels = value;
      context.set($context);
    }
  }
  function checkboxsetting4_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.allowCantripsToBePrepared, value)) {
      $context.settings.allowCantripsToBePrepared = value;
      context.set($context);
    }
  }
  function checkboxsetting5_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showActiveEffectsMarker, value)) {
      $context.settings.showActiveEffectsMarker = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    checkboxsetting0_value_binding,
    checkboxsetting1_value_binding,
    textinputsetting_value_binding,
    selectsetting_value_binding,
    checkboxsetting2_value_binding,
    checkboxsetting3_value_binding,
    checkboxsetting4_value_binding,
    checkboxsetting5_value_binding
  ];
}
class MiscWorldSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4c, create_fragment$4d, safe_not_equal, {});
  }
}
function cubicOut(t2) {
  const f2 = t2 - 1;
  return f2 * f2 * f2 + 1;
}
function quadInOut(t2) {
  t2 /= 0.5;
  if (t2 < 1) return 0.5 * t2 * t2;
  t2--;
  return -0.5 * (t2 * (t2 - 2) - 1);
}
function flip(node, { from, to }, params = {}) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  const dx = from.left + from.width * ox / to.width - (to.left + ox);
  const dy = from.top + from.height * oy / to.height - (to.top + oy);
  const { delay: delay2 = 0, duration = (d2) => Math.sqrt(d2) * 120, easing = cubicOut } = params;
  return {
    delay: delay2,
    duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
    easing,
    css: (t2, u2) => {
      const x2 = u2 * dx;
      const y2 = u2 * dy;
      const sx = t2 + u2 * from.width / to.width;
      const sy = t2 + u2 * from.height / to.height;
      return `transform: ${transform} translate(${x2}px, ${y2}px) scale(${sx}, ${sy});`;
    }
  };
}
function fade(node, { delay: delay2 = 0, duration = 400, easing = identity } = {}) {
  const o2 = +getComputedStyle(node).opacity;
  return {
    delay: delay2,
    duration,
    easing,
    css: (t2) => `opacity: ${t2 * o2}`
  };
}
function slide(node, { delay: delay2 = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map(
    (e2) => `${e2[0].toUpperCase()}${e2.slice(1)}`
  );
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(
    style[`border${capitalized_secondary_properties[0]}Width`]
  );
  const border_width_end_value = parseFloat(
    style[`border${capitalized_secondary_properties[1]}Width`]
  );
  return {
    delay: delay2,
    duration,
    easing,
    css: (t2) => `overflow: hidden;opacity: ${Math.min(t2 * 20, 1) * opacity};${primary_property}: ${t2 * primary_property_value}px;padding-${secondary_properties[0]}: ${t2 * padding_start_value}px;padding-${secondary_properties[1]}: ${t2 * padding_end_value}px;margin-${secondary_properties[0]}: ${t2 * margin_start_value}px;margin-${secondary_properties[1]}: ${t2 * margin_end_value}px;border-${secondary_properties[0]}-width: ${t2 * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t2 * border_width_end_value}px;`
  };
}
function crossfade({ fallback, ...defaults }) {
  const to_receive = /* @__PURE__ */ new Map();
  const to_send = /* @__PURE__ */ new Map();
  function crossfade2(from_node, node, params) {
    const {
      delay: delay2 = 0,
      duration = (d3) => Math.sqrt(d3) * 30,
      easing = cubicOut
    } = assign(assign({}, defaults), params);
    const from = from_node.getBoundingClientRect();
    const to = node.getBoundingClientRect();
    const dx = from.left - to.left;
    const dy = from.top - to.top;
    const dw = from.width / to.width;
    const dh = from.height / to.height;
    const d2 = Math.sqrt(dx * dx + dy * dy);
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    const opacity = +style.opacity;
    return {
      delay: delay2,
      duration: is_function(duration) ? duration(d2) : duration,
      easing,
      css: (t2, u2) => `
				opacity: ${t2 * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u2 * dx}px,${u2 * dy}px) scale(${t2 + (1 - t2) * dw}, ${t2 + (1 - t2) * dh});
			`
    };
  }
  function transition(items, counterparts, intro) {
    return (node, params) => {
      items.set(params.key, node);
      return () => {
        if (counterparts.has(params.key)) {
          const other_node = counterparts.get(params.key);
          counterparts.delete(params.key);
          return crossfade2(other_node, node, params);
        }
        items.delete(params.key);
        return fallback && fallback(node, params, intro);
      };
    };
  }
  return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];
}
function get_each_context$17(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  child_ctx[27] = i2;
  return child_ctx;
}
const get_default_slot_changes$5 = (dirty) => ({ item: dirty & /*items*/
2 });
const get_default_slot_context$5 = (ctx) => ({ item: (
  /*item*/
  ctx[25]
) });
function create_if_block$1S(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "drag-grip fa-solid fa-grip-lines fa-fw svelte-17rnve7");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function fallback_block$1(ctx) {
  let t_value = (
    /*item*/
    ctx[25][
      /*labelProp*/
      ctx[2]
    ] + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*items, labelProp*/
      6 && t_value !== (t_value = /*item*/
      ctx2[25][
        /*labelProp*/
        ctx2[2]
      ] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block$17(key_1, ctx) {
  let li;
  let t0;
  let t1;
  let li_id_value;
  let li_aria_selected_value;
  let li_intro;
  let li_outro;
  let rect;
  let stop_animation = noop$1;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*draggable*/
    ctx[4] && create_if_block$1S()
  );
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context$5
  );
  const default_slot_or_fallback = default_slot || fallback_block$1(ctx);
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*i*/
        ctx[27]
      )
    );
  }
  function dragstart_handler(...args) {
    return (
      /*dragstart_handler*/
      ctx[17](
        /*item*/
        ctx[25],
        /*i*/
        ctx[27],
        ...args
      )
    );
  }
  function dragend_handler(...args) {
    return (
      /*dragend_handler*/
      ctx[18](
        /*item*/
        ctx[25],
        /*i*/
        ctx[27],
        ...args
      )
    );
  }
  function drop_handler(...args) {
    return (
      /*drop_handler*/
      ctx[19](
        /*item*/
        ctx[25],
        /*i*/
        ctx[27],
        ...args
      )
    );
  }
  function dragover_handler(...args) {
    return (
      /*dragover_handler*/
      ctx[20](
        /*item*/
        ctx[25],
        /*i*/
        ctx[27],
        ...args
      )
    );
  }
  function dragenter_handler(...args) {
    return (
      /*dragenter_handler*/
      ctx[21](
        /*item*/
        ctx[25],
        /*i*/
        ctx[27],
        ...args
      )
    );
  }
  function dragleave_handler(...args) {
    return (
      /*dragleave_handler*/
      ctx[22](
        /*item*/
        ctx[25],
        /*i*/
        ctx[27],
        ...args
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      if (if_block) if_block.c();
      t0 = space();
      if (default_slot_or_fallback) default_slot_or_fallback.c();
      t1 = space();
      attr(li, "id", li_id_value = "listbox-item-" + /*i*/
      ctx[27] + "-" + /*idRandomizer*/
      ctx[8]);
      attr(li, "role", "option");
      attr(li, "aria-selected", li_aria_selected_value = /*selectedItemIndex*/
      ctx[0] === /*i*/
      ctx[27]);
      attr(li, "class", "flex-row small-gap align-items-center svelte-17rnve7");
      attr(
        li,
        "draggable",
        /*draggable*/
        ctx[4]
      );
      toggle_class(
        li,
        "focused",
        /*selectedItemIndex*/
        ctx[0] === /*i*/
        ctx[27]
      );
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block) if_block.m(li, null);
      append(li, t0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(li, null);
      }
      append(li, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(li, "click", click_handler),
          listen(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[16]
          ),
          listen(li, "dragstart", dragstart_handler),
          listen(li, "dragend", dragend_handler),
          listen(li, "drop", drop_handler),
          listen(li, "dragover", dragover_handler),
          listen(li, "dragenter", dragenter_handler),
          listen(li, "dragleave", dragleave_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*draggable*/
        ctx[4]
      ) {
        if (if_block) ;
        else {
          if_block = create_if_block$1S();
          if_block.c();
          if_block.m(li, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, items*/
        8194)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[13],
              dirty,
              get_default_slot_changes$5
            ),
            get_default_slot_context$5
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*items, labelProp*/
        6)) {
          default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*items*/
      2 && li_id_value !== (li_id_value = "listbox-item-" + /*i*/
      ctx[27] + "-" + /*idRandomizer*/
      ctx[8])) {
        attr(li, "id", li_id_value);
      }
      if (!current || dirty & /*selectedItemIndex, items*/
      3 && li_aria_selected_value !== (li_aria_selected_value = /*selectedItemIndex*/
      ctx[0] === /*i*/
      ctx[27])) {
        attr(li, "aria-selected", li_aria_selected_value);
      }
      if (!current || dirty & /*draggable*/
      16) {
        attr(
          li,
          "draggable",
          /*draggable*/
          ctx[4]
        );
      }
      if (!current || dirty & /*selectedItemIndex, items*/
      3) {
        toggle_class(
          li,
          "focused",
          /*selectedItemIndex*/
          ctx[0] === /*i*/
          ctx[27]
        );
      }
    },
    r() {
      rect = li.getBoundingClientRect();
    },
    f() {
      fix_position(li);
      stop_animation();
      add_transform(li, rect);
    },
    a() {
      stop_animation();
      stop_animation = create_animation(li, rect, flip, { duration: 150 });
    },
    i(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (li_outro) li_outro.end(1);
          li_intro = create_in_transition(
            li,
            /*receive*/
            ctx[7],
            {
              key: (
                /*item*/
                ctx[25][
                  /*valueProp*/
                  ctx[3]
                ]
              )
            }
          );
          li_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      if (li_intro) li_intro.invalidate();
      if (local) {
        li_outro = create_out_transition(
          li,
          /*send*/
          ctx[6],
          {
            key: (
              /*item*/
              ctx[25][
                /*valueProp*/
                ctx[3]
              ]
            )
          }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block) if_block.d();
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
      if (detaching && li_outro) li_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$4c(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let ul_class_value;
  let ul_aria_activedescendant_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*items*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[25][
      /*valueProp*/
      ctx2[3]
    ]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$17(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$17(key, child_ctx));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "role", "listbox");
      attr(ul, "class", ul_class_value = "listbox " + /*$$props*/
      (ctx[12].class ?? "") + " svelte-17rnve7");
      attr(ul, "aria-activedescendant", ul_aria_activedescendant_value = /*selectedItemIndex*/
      ctx[0] !== null ? `listbox-item-${/*selectedItemIndex*/
      ctx[0]}-${/*idRandomizer*/
      ctx[8]}` : null);
      attr(ul, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      ctx[23](ul);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            ul,
            "keydown",
            /*handleListboxKeyDown*/
            ctx[10]
          ),
          listen(
            ul,
            "drop",
            /*drop_handler_1*/
            ctx[24]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*items, idRandomizer, selectedItemIndex, draggable, valueProp, selectItemAt, handleListboxKeyDown, dispatcher, labelProp, $$scope*/
      12063) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[1]
        );
        group_outros();
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) each_blocks[i2].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block$17, null, get_each_context$17);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1) each_blocks[i2].a();
        check_outros();
      }
      if (!current || dirty & /*$$props*/
      4096 && ul_class_value !== (ul_class_value = "listbox " + /*$$props*/
      (ctx2[12].class ?? "") + " svelte-17rnve7")) {
        attr(ul, "class", ul_class_value);
      }
      if (!current || dirty & /*selectedItemIndex*/
      1 && ul_aria_activedescendant_value !== (ul_aria_activedescendant_value = /*selectedItemIndex*/
      ctx2[0] !== null ? `listbox-item-${/*selectedItemIndex*/
      ctx2[0]}-${/*idRandomizer*/
      ctx2[8]}` : null)) {
        attr(ul, "aria-activedescendant", ul_aria_activedescendant_value);
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4b($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const [send, receive] = crossfade({});
  let { items } = $$props;
  let { labelProp } = $$props;
  let { valueProp } = $$props;
  let { selectedItemIndex = null } = $$props;
  let { draggable = false } = $$props;
  let idRandomizer = Math.random().toString().substring(2);
  const dispatcher = createEventDispatcher();
  let listbox;
  function handleListboxKeyDown(ev) {
    if (items.length) {
      const currentIndex = selectedItemIndex ?? -1;
      if (ev.key === "ArrowUp" && !ev.altKey) {
        selectItemAt(Math.max(0, currentIndex - 1));
        ev.preventDefault();
      } else if (ev.key === "ArrowDown" && !ev.altKey) {
        selectItemAt(Math.min(items.length - 1, currentIndex + 1));
        ev.preventDefault();
      } else if (ev.key === "Home") {
        selectItemAt(0);
        ev.preventDefault();
      } else if (ev.key === "End") {
        selectItemAt(items.length - 1);
        ev.preventDefault();
      }
      listbox.querySelector(`#listbox-item-${selectedItemIndex}-${idRandomizer}`)?.scrollIntoView({ block: "nearest" });
    }
    dispatcher("keydown", ev);
  }
  function selectItemAt(index) {
    $$invalidate(0, selectedItemIndex = index);
    dispatcher("select", index);
  }
  const click_handler = (i2) => selectItemAt(i2);
  const keydown_handler = (ev) => handleListboxKeyDown(ev);
  const dragstart_handler = (item, i2, ev) => dispatcher("dragstart", { event: ev, item, index: i2 });
  const dragend_handler = (item, i2, ev) => dispatcher("dragend", { event: ev, item, index: i2 });
  const drop_handler = (item, i2, ev) => dispatcher("drop", { event: ev, item, index: i2 });
  const dragover_handler = (item, i2, ev) => dispatcher("dragover", { event: ev, item, index: i2 });
  const dragenter_handler = (item, i2, ev) => dispatcher("dragenter", { event: ev, item, index: i2 });
  const dragleave_handler = (item, i2, ev) => dispatcher("dragleave", { event: ev, item, index: i2 });
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      listbox = $$value;
      $$invalidate(5, listbox);
    });
  }
  const drop_handler_1 = (ev) => dispatcher("listboxDrop", { event: ev });
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("items" in $$new_props) $$invalidate(1, items = $$new_props.items);
    if ("labelProp" in $$new_props) $$invalidate(2, labelProp = $$new_props.labelProp);
    if ("valueProp" in $$new_props) $$invalidate(3, valueProp = $$new_props.valueProp);
    if ("selectedItemIndex" in $$new_props) $$invalidate(0, selectedItemIndex = $$new_props.selectedItemIndex);
    if ("draggable" in $$new_props) $$invalidate(4, draggable = $$new_props.draggable);
    if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    selectedItemIndex,
    items,
    labelProp,
    valueProp,
    draggable,
    listbox,
    send,
    receive,
    idRandomizer,
    dispatcher,
    handleListboxKeyDown,
    selectItemAt,
    $$props,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    dragstart_handler,
    dragend_handler,
    drop_handler,
    dragover_handler,
    dragenter_handler,
    dragleave_handler,
    ul_binding,
    drop_handler_1
  ];
}
class Listbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4b, create_fragment$4c, safe_not_equal, {
      items: 1,
      labelProp: 2,
      valueProp: 3,
      selectedItemIndex: 0,
      draggable: 4
    });
  }
}
function create_fragment$4b(ctx) {
  let div;
  let button0;
  let i0;
  let t0;
  let button1;
  let i1;
  let t1;
  let button2;
  let i2;
  let t2;
  let button3;
  let i3;
  let t3;
  let button4;
  let i4;
  let t4;
  let button5;
  let i5;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      i0 = element("i");
      t0 = space();
      button1 = element("button");
      i1 = element("i");
      t1 = space();
      button2 = element("button");
      i2 = element("i");
      t2 = space();
      button3 = element("button");
      i3 = element("i");
      t3 = space();
      button4 = element("button");
      i4 = element("i");
      t4 = space();
      button5 = element("button");
      i5 = element("i");
      attr(i0, "class", "fas fa-angle-up");
      attr(
        button0,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.Listbox.MoveUp")
      );
      attr(button0, "type", "button");
      button0.disabled = /*moveUpDisabled*/
      ctx[1];
      attr(button0, "class", "svelte-1crdbkz");
      attr(i1, "class", "fas fa-angle-down");
      attr(
        button1,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.Listbox.MoveDown")
      );
      attr(button1, "type", "button");
      button1.disabled = /*moveDownDisabled*/
      ctx[2];
      attr(button1, "class", "svelte-1crdbkz");
      attr(i2, "class", "fas fa-angle-left");
      attr(
        button2,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.Listbox.MoveLeft")
      );
      attr(button2, "type", "button");
      button2.disabled = /*moveLeftDisabled*/
      ctx[3];
      attr(button2, "class", "svelte-1crdbkz");
      attr(i3, "class", "fas fa-angle-right");
      attr(
        button3,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.Listbox.MoveRight")
      );
      attr(button3, "type", "button");
      button3.disabled = /*moveRightDisabled*/
      ctx[4];
      attr(button3, "class", "svelte-1crdbkz");
      attr(i4, "class", "fas fa-angles-left");
      attr(
        button4,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.Listbox.MoveAllLeft")
      );
      attr(button4, "type", "button");
      button4.disabled = /*moveAllToTheLeftDisabled*/
      ctx[0];
      attr(button4, "class", "svelte-1crdbkz");
      attr(i5, "class", "fas fa-angles-right");
      attr(
        button5,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.Listbox.MoveAllRight")
      );
      attr(button5, "type", "button");
      button5.disabled = /*moveAllToTheRightDisabled*/
      ctx[5];
      attr(button5, "class", "svelte-1crdbkz");
      attr(div, "class", div_class_value = "selection-listbox-toolbar " + /*$$props*/
      (ctx[8].class ?? "") + " svelte-1crdbkz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, i0);
      append(div, t0);
      append(div, button1);
      append(button1, i1);
      append(div, t1);
      append(div, button2);
      append(button2, i2);
      append(div, t2);
      append(div, button3);
      append(button3, i3);
      append(div, t3);
      append(div, button4);
      append(button4, i4);
      append(div, t4);
      append(div, button5);
      append(button5, i5);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[9]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[10]
          ),
          listen(
            button2,
            "click",
            /*click_handler_2*/
            ctx[11]
          ),
          listen(
            button3,
            "click",
            /*click_handler_3*/
            ctx[12]
          ),
          listen(
            button4,
            "click",
            /*click_handler_4*/
            ctx[13]
          ),
          listen(
            button5,
            "click",
            /*click_handler_5*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*moveUpDisabled*/
      2) {
        button0.disabled = /*moveUpDisabled*/
        ctx2[1];
      }
      if (dirty & /*moveDownDisabled*/
      4) {
        button1.disabled = /*moveDownDisabled*/
        ctx2[2];
      }
      if (dirty & /*moveLeftDisabled*/
      8) {
        button2.disabled = /*moveLeftDisabled*/
        ctx2[3];
      }
      if (dirty & /*moveRightDisabled*/
      16) {
        button3.disabled = /*moveRightDisabled*/
        ctx2[4];
      }
      if (dirty & /*moveAllToTheLeftDisabled*/
      1) {
        button4.disabled = /*moveAllToTheLeftDisabled*/
        ctx2[0];
      }
      if (dirty & /*moveAllToTheRightDisabled*/
      32) {
        button5.disabled = /*moveAllToTheRightDisabled*/
        ctx2[5];
      }
      if (dirty & /*$$props*/
      256 && div_class_value !== (div_class_value = "selection-listbox-toolbar " + /*$$props*/
      (ctx2[8].class ?? "") + " svelte-1crdbkz")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4a($$self, $$props, $$invalidate) {
  let { moveAllToTheLeftDisabled } = $$props;
  let { moveUpDisabled } = $$props;
  let { moveDownDisabled } = $$props;
  let { moveLeftDisabled } = $$props;
  let { moveRightDisabled } = $$props;
  let { moveAllToTheRightDisabled } = $$props;
  const dispatcher = createEventDispatcher();
  const localize = FoundryAdapter.localize;
  const click_handler = () => dispatcher("moveUp");
  const click_handler_1 = () => dispatcher("moveDown");
  const click_handler_2 = () => dispatcher("moveLeft");
  const click_handler_3 = () => dispatcher("moveRight");
  const click_handler_4 = () => dispatcher("moveAllToTheLeft");
  const click_handler_5 = () => dispatcher("moveAllToTheRight");
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("moveAllToTheLeftDisabled" in $$new_props) $$invalidate(0, moveAllToTheLeftDisabled = $$new_props.moveAllToTheLeftDisabled);
    if ("moveUpDisabled" in $$new_props) $$invalidate(1, moveUpDisabled = $$new_props.moveUpDisabled);
    if ("moveDownDisabled" in $$new_props) $$invalidate(2, moveDownDisabled = $$new_props.moveDownDisabled);
    if ("moveLeftDisabled" in $$new_props) $$invalidate(3, moveLeftDisabled = $$new_props.moveLeftDisabled);
    if ("moveRightDisabled" in $$new_props) $$invalidate(4, moveRightDisabled = $$new_props.moveRightDisabled);
    if ("moveAllToTheRightDisabled" in $$new_props) $$invalidate(5, moveAllToTheRightDisabled = $$new_props.moveAllToTheRightDisabled);
  };
  $$props = exclude_internal_props($$props);
  return [
    moveAllToTheLeftDisabled,
    moveUpDisabled,
    moveDownDisabled,
    moveLeftDisabled,
    moveRightDisabled,
    moveAllToTheRightDisabled,
    dispatcher,
    localize,
    $$props,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5
  ];
}
class SelectionListboxToolbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4a, create_fragment$4b, safe_not_equal, {
      moveAllToTheLeftDisabled: 0,
      moveUpDisabled: 1,
      moveDownDisabled: 2,
      moveLeftDisabled: 3,
      moveRightDisabled: 4,
      moveAllToTheRightDisabled: 5
    });
  }
}
const get_right_header_slot_changes = (dirty) => ({});
const get_right_header_slot_context = (ctx) => ({});
const get_left_header_slot_changes = (dirty) => ({});
const get_left_header_slot_context = (ctx) => ({});
function create_if_block$1R(ctx) {
  let div0;
  let t2;
  let div1;
  let current;
  const left_header_slot_template = (
    /*#slots*/
    ctx[20]["left-header"]
  );
  const left_header_slot = create_slot(
    left_header_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_left_header_slot_context
  );
  const right_header_slot_template = (
    /*#slots*/
    ctx[20]["right-header"]
  );
  const right_header_slot = create_slot(
    right_header_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_right_header_slot_context
  );
  return {
    c() {
      div0 = element("div");
      if (left_header_slot) left_header_slot.c();
      t2 = space();
      div1 = element("div");
      if (right_header_slot) right_header_slot.c();
      attr(div0, "class", "column-1");
      attr(div1, "class", "column-3");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if (left_header_slot) {
        left_header_slot.m(div0, null);
      }
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      if (right_header_slot) {
        right_header_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (left_header_slot) {
        if (left_header_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            left_header_slot,
            left_header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              left_header_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_left_header_slot_changes
            ),
            get_left_header_slot_context
          );
        }
      }
      if (right_header_slot) {
        if (right_header_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            right_header_slot,
            right_header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              right_header_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_right_header_slot_changes
            ),
            get_right_header_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(left_header_slot, local);
      transition_in(right_header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(left_header_slot, local);
      transition_out(right_header_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      if (left_header_slot) left_header_slot.d(detaching);
      if (right_header_slot) right_header_slot.d(detaching);
    }
  };
}
function create_fragment$4a(ctx) {
  let div;
  let t0;
  let listbox0;
  let updating_items;
  let updating_selectedItemIndex;
  let t1;
  let selectionlistboxtoolbar;
  let t2;
  let listbox1;
  let updating_items_1;
  let updating_selectedItemIndex_1;
  let div_class_value;
  let current;
  let if_block = (
    /*$$slots*/
    (ctx[18]["left-header"] || /*$$slots*/
    ctx[18]["right-header"]) && create_if_block$1R(ctx)
  );
  function listbox0_items_binding(value) {
    ctx[21](value);
  }
  function listbox0_selectedItemIndex_binding(value) {
    ctx[22](value);
  }
  let listbox0_props = {
    labelProp: (
      /*labelProp*/
      ctx[4]
    ),
    valueProp: (
      /*valueProp*/
      ctx[5]
    ),
    class: "column-1 " + /*listboxCssClass*/
    ctx[6]
  };
  if (
    /*leftItems*/
    ctx[0] !== void 0
  ) {
    listbox0_props.items = /*leftItems*/
    ctx[0];
  }
  if (
    /*selectedLeftItemIndex*/
    ctx[1] !== void 0
  ) {
    listbox0_props.selectedItemIndex = /*selectedLeftItemIndex*/
    ctx[1];
  }
  listbox0 = new Listbox({ props: listbox0_props });
  binding_callbacks.push(() => bind(listbox0, "items", listbox0_items_binding));
  binding_callbacks.push(() => bind(listbox0, "selectedItemIndex", listbox0_selectedItemIndex_binding));
  listbox0.$on(
    "select",
    /*select_handler*/
    ctx[23]
  );
  listbox0.$on(
    "keydown",
    /*handleLeftListboxKeydown*/
    ctx[15]
  );
  selectionlistboxtoolbar = new SelectionListboxToolbar({
    props: {
      moveUpDisabled: (
        /*selectedItemIndex*/
        ctx[7] === null || /*selectedItemIndex*/
        ctx[7] === 0
      ),
      moveDownDisabled: (
        /*selectedItemIndex*/
        ctx[7] === null || /*selectedArray*/
        ctx[8] === null || /*selectedItemIndex*/
        ctx[7] >= /*selectedArray*/
        ctx[8].length - 1
      ),
      moveLeftDisabled: (
        /*selectedLeftItemIndex*/
        ctx[1] !== null || /*selectedRightItemIndex*/
        ctx[3] === null
      ),
      moveRightDisabled: (
        /*selectedLeftItemIndex*/
        ctx[1] === null || /*selectedRightItemIndex*/
        ctx[3] !== null
      ),
      moveAllToTheLeftDisabled: (
        /*rightItems*/
        ctx[2].length === 0
      ),
      moveAllToTheRightDisabled: (
        /*leftItems*/
        ctx[0].length === 0
      ),
      class: "column-2"
    }
  });
  selectionlistboxtoolbar.$on(
    "moveUp",
    /*moveUp*/
    ctx[10]
  );
  selectionlistboxtoolbar.$on(
    "moveDown",
    /*moveDown*/
    ctx[11]
  );
  selectionlistboxtoolbar.$on(
    "moveLeft",
    /*moveLeft*/
    ctx[12]
  );
  selectionlistboxtoolbar.$on(
    "moveRight",
    /*moveRight*/
    ctx[13]
  );
  selectionlistboxtoolbar.$on(
    "moveAllToTheLeft",
    /*moveAllToTheLeft*/
    ctx[9]
  );
  selectionlistboxtoolbar.$on(
    "moveAllToTheRight",
    /*moveAllToTheRight*/
    ctx[14]
  );
  function listbox1_items_binding(value) {
    ctx[24](value);
  }
  function listbox1_selectedItemIndex_binding(value) {
    ctx[25](value);
  }
  let listbox1_props = {
    labelProp: (
      /*labelProp*/
      ctx[4]
    ),
    valueProp: (
      /*valueProp*/
      ctx[5]
    ),
    class: "column-3 " + /*listboxCssClass*/
    ctx[6]
  };
  if (
    /*rightItems*/
    ctx[2] !== void 0
  ) {
    listbox1_props.items = /*rightItems*/
    ctx[2];
  }
  if (
    /*selectedRightItemIndex*/
    ctx[3] !== void 0
  ) {
    listbox1_props.selectedItemIndex = /*selectedRightItemIndex*/
    ctx[3];
  }
  listbox1 = new Listbox({ props: listbox1_props });
  binding_callbacks.push(() => bind(listbox1, "items", listbox1_items_binding));
  binding_callbacks.push(() => bind(listbox1, "selectedItemIndex", listbox1_selectedItemIndex_binding));
  listbox1.$on(
    "select",
    /*select_handler_1*/
    ctx[26]
  );
  listbox1.$on(
    "keydown",
    /*handleRightListboxKeydown*/
    ctx[16]
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t0 = space();
      create_component(listbox0.$$.fragment);
      t1 = space();
      create_component(selectionlistboxtoolbar.$$.fragment);
      t2 = space();
      create_component(listbox1.$$.fragment);
      attr(div, "class", div_class_value = "selection-listbox " + /*$$props*/
      (ctx[17].class ?? "") + " svelte-12k9wjz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t0);
      mount_component(listbox0, div, null);
      append(div, t1);
      mount_component(selectionlistboxtoolbar, div, null);
      append(div, t2);
      mount_component(listbox1, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[18]["left-header"] || /*$$slots*/
        ctx2[18]["right-header"]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          262144) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1R(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const listbox0_changes = {};
      if (dirty & /*labelProp*/
      16) listbox0_changes.labelProp = /*labelProp*/
      ctx2[4];
      if (dirty & /*valueProp*/
      32) listbox0_changes.valueProp = /*valueProp*/
      ctx2[5];
      if (dirty & /*listboxCssClass*/
      64) listbox0_changes.class = "column-1 " + /*listboxCssClass*/
      ctx2[6];
      if (!updating_items && dirty & /*leftItems*/
      1) {
        updating_items = true;
        listbox0_changes.items = /*leftItems*/
        ctx2[0];
        add_flush_callback(() => updating_items = false);
      }
      if (!updating_selectedItemIndex && dirty & /*selectedLeftItemIndex*/
      2) {
        updating_selectedItemIndex = true;
        listbox0_changes.selectedItemIndex = /*selectedLeftItemIndex*/
        ctx2[1];
        add_flush_callback(() => updating_selectedItemIndex = false);
      }
      listbox0.$set(listbox0_changes);
      const selectionlistboxtoolbar_changes = {};
      if (dirty & /*selectedItemIndex*/
      128) selectionlistboxtoolbar_changes.moveUpDisabled = /*selectedItemIndex*/
      ctx2[7] === null || /*selectedItemIndex*/
      ctx2[7] === 0;
      if (dirty & /*selectedItemIndex, selectedArray*/
      384) selectionlistboxtoolbar_changes.moveDownDisabled = /*selectedItemIndex*/
      ctx2[7] === null || /*selectedArray*/
      ctx2[8] === null || /*selectedItemIndex*/
      ctx2[7] >= /*selectedArray*/
      ctx2[8].length - 1;
      if (dirty & /*selectedLeftItemIndex, selectedRightItemIndex*/
      10) selectionlistboxtoolbar_changes.moveLeftDisabled = /*selectedLeftItemIndex*/
      ctx2[1] !== null || /*selectedRightItemIndex*/
      ctx2[3] === null;
      if (dirty & /*selectedLeftItemIndex, selectedRightItemIndex*/
      10) selectionlistboxtoolbar_changes.moveRightDisabled = /*selectedLeftItemIndex*/
      ctx2[1] === null || /*selectedRightItemIndex*/
      ctx2[3] !== null;
      if (dirty & /*rightItems*/
      4) selectionlistboxtoolbar_changes.moveAllToTheLeftDisabled = /*rightItems*/
      ctx2[2].length === 0;
      if (dirty & /*leftItems*/
      1) selectionlistboxtoolbar_changes.moveAllToTheRightDisabled = /*leftItems*/
      ctx2[0].length === 0;
      selectionlistboxtoolbar.$set(selectionlistboxtoolbar_changes);
      const listbox1_changes = {};
      if (dirty & /*labelProp*/
      16) listbox1_changes.labelProp = /*labelProp*/
      ctx2[4];
      if (dirty & /*valueProp*/
      32) listbox1_changes.valueProp = /*valueProp*/
      ctx2[5];
      if (dirty & /*listboxCssClass*/
      64) listbox1_changes.class = "column-3 " + /*listboxCssClass*/
      ctx2[6];
      if (!updating_items_1 && dirty & /*rightItems*/
      4) {
        updating_items_1 = true;
        listbox1_changes.items = /*rightItems*/
        ctx2[2];
        add_flush_callback(() => updating_items_1 = false);
      }
      if (!updating_selectedItemIndex_1 && dirty & /*selectedRightItemIndex*/
      8) {
        updating_selectedItemIndex_1 = true;
        listbox1_changes.selectedItemIndex = /*selectedRightItemIndex*/
        ctx2[3];
        add_flush_callback(() => updating_selectedItemIndex_1 = false);
      }
      listbox1.$set(listbox1_changes);
      if (!current || dirty & /*$$props*/
      131072 && div_class_value !== (div_class_value = "selection-listbox " + /*$$props*/
      (ctx2[17].class ?? "") + " svelte-12k9wjz")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(listbox0.$$.fragment, local);
      transition_in(selectionlistboxtoolbar.$$.fragment, local);
      transition_in(listbox1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(listbox0.$$.fragment, local);
      transition_out(selectionlistboxtoolbar.$$.fragment, local);
      transition_out(listbox1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      destroy_component(listbox0);
      destroy_component(selectionlistboxtoolbar);
      destroy_component(listbox1);
    }
  };
}
function instance$49($$self, $$props, $$invalidate) {
  let selectedItemIndex;
  let selectedArray;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { leftItems } = $$props;
  let { selectedLeftItemIndex = null } = $$props;
  let { rightItems } = $$props;
  let { selectedRightItemIndex = null } = $$props;
  let { labelProp } = $$props;
  let { valueProp } = $$props;
  let { listboxCssClass = "" } = $$props;
  function moveAllToTheLeft() {
    $$invalidate(0, leftItems = [...leftItems, ...rightItems]);
    $$invalidate(2, rightItems = []);
    itemsMoved();
  }
  function moveUp() {
    if (selectedItemIndex === null || selectedItemIndex === 0 || selectedArray === null) {
      return;
    }
    const topValue = selectedArray[selectedItemIndex - 1];
    const bottomValue = selectedArray[selectedItemIndex];
    $$invalidate(8, selectedArray[selectedItemIndex - 1] = bottomValue, selectedArray);
    $$invalidate(8, selectedArray[selectedItemIndex] = topValue, selectedArray);
    if (selectedLeftItemIndex) {
      $$invalidate(1, selectedLeftItemIndex -= 1);
      $$invalidate(0, leftItems);
    } else if (selectedRightItemIndex) {
      $$invalidate(3, selectedRightItemIndex -= 1);
      $$invalidate(2, rightItems);
    }
    itemsMoved();
  }
  function moveDown() {
    if (selectedArray === null || selectedItemIndex === null || selectedItemIndex >= selectedArray.length - 1) {
      return;
    }
    const topValue = selectedArray[selectedItemIndex];
    const bottomValue = selectedArray[selectedItemIndex + 1];
    $$invalidate(8, selectedArray[selectedItemIndex] = bottomValue, selectedArray);
    $$invalidate(8, selectedArray[selectedItemIndex + 1] = topValue, selectedArray);
    if (selectedLeftItemIndex !== null) {
      $$invalidate(1, selectedLeftItemIndex += 1);
      $$invalidate(0, leftItems);
    } else if (selectedRightItemIndex !== null) {
      $$invalidate(3, selectedRightItemIndex += 1);
      $$invalidate(2, rightItems);
    }
    itemsMoved();
  }
  function moveLeft() {
    if (selectedRightItemIndex === null) {
      return;
    }
    const itemToMove = rightItems.splice(selectedRightItemIndex, 1)[0];
    if (!itemToMove) {
      return;
    }
    $$invalidate(2, rightItems);
    leftItems.push(itemToMove);
    $$invalidate(0, leftItems);
    itemsMoved();
  }
  function moveRight() {
    if (selectedLeftItemIndex === null) {
      return;
    }
    const itemToMove = leftItems.splice(selectedLeftItemIndex, 1)[0];
    if (!itemToMove) {
      return;
    }
    $$invalidate(0, leftItems);
    rightItems.push(itemToMove);
    $$invalidate(2, rightItems);
    itemsMoved();
  }
  function moveAllToTheRight() {
    $$invalidate(2, rightItems = [...rightItems, ...leftItems]);
    $$invalidate(0, leftItems = []);
    itemsMoved();
  }
  function itemsMoved(options) {
    if (selectedLeftItemIndex !== null && leftItems.at(selectedLeftItemIndex) === void 0) {
      $$invalidate(1, selectedLeftItemIndex = leftItems.length ? leftItems.length - 1 : null);
    }
    if (selectedRightItemIndex !== null && rightItems.at(selectedRightItemIndex) === void 0) {
      $$invalidate(3, selectedRightItemIndex = rightItems.length ? rightItems.length - 1 : null);
    }
  }
  function handleLeftListboxKeydown(e2) {
    if (e2.detail.code === "Space") {
      moveRight();
      e2.detail.preventDefault();
    } else if (e2.detail.key === "ArrowUp" && e2.detail.altKey) {
      moveUp();
    } else if (e2.detail.key === "ArrowDown" && e2.detail.altKey) {
      moveDown();
    }
  }
  function handleRightListboxKeydown(e2) {
    if (e2.detail.code === "Space") {
      moveLeft();
      e2.detail.preventDefault();
    } else if (e2.detail.key === "ArrowUp" && e2.detail.altKey) {
      moveUp();
    } else if (e2.detail.key === "ArrowDown" && e2.detail.altKey) {
      moveDown();
    }
  }
  function listbox0_items_binding(value) {
    leftItems = value;
    $$invalidate(0, leftItems);
  }
  function listbox0_selectedItemIndex_binding(value) {
    selectedLeftItemIndex = value;
    $$invalidate(1, selectedLeftItemIndex);
  }
  const select_handler = () => {
    $$invalidate(3, selectedRightItemIndex = null);
  };
  function listbox1_items_binding(value) {
    rightItems = value;
    $$invalidate(2, rightItems);
  }
  function listbox1_selectedItemIndex_binding(value) {
    selectedRightItemIndex = value;
    $$invalidate(3, selectedRightItemIndex);
  }
  const select_handler_1 = () => {
    $$invalidate(1, selectedLeftItemIndex = null);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("leftItems" in $$new_props) $$invalidate(0, leftItems = $$new_props.leftItems);
    if ("selectedLeftItemIndex" in $$new_props) $$invalidate(1, selectedLeftItemIndex = $$new_props.selectedLeftItemIndex);
    if ("rightItems" in $$new_props) $$invalidate(2, rightItems = $$new_props.rightItems);
    if ("selectedRightItemIndex" in $$new_props) $$invalidate(3, selectedRightItemIndex = $$new_props.selectedRightItemIndex);
    if ("labelProp" in $$new_props) $$invalidate(4, labelProp = $$new_props.labelProp);
    if ("valueProp" in $$new_props) $$invalidate(5, valueProp = $$new_props.valueProp);
    if ("listboxCssClass" in $$new_props) $$invalidate(6, listboxCssClass = $$new_props.listboxCssClass);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selectedLeftItemIndex, selectedRightItemIndex*/
    10) {
      $$invalidate(7, selectedItemIndex = selectedLeftItemIndex ?? selectedRightItemIndex);
    }
    if ($$self.$$.dirty & /*selectedLeftItemIndex, leftItems, selectedRightItemIndex, rightItems*/
    15) {
      $$invalidate(8, selectedArray = selectedLeftItemIndex !== null ? leftItems : selectedRightItemIndex !== null ? rightItems : null);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    leftItems,
    selectedLeftItemIndex,
    rightItems,
    selectedRightItemIndex,
    labelProp,
    valueProp,
    listboxCssClass,
    selectedItemIndex,
    selectedArray,
    moveAllToTheLeft,
    moveUp,
    moveDown,
    moveLeft,
    moveRight,
    moveAllToTheRight,
    handleLeftListboxKeydown,
    handleRightListboxKeydown,
    $$props,
    $$slots,
    $$scope,
    slots,
    listbox0_items_binding,
    listbox0_selectedItemIndex_binding,
    select_handler,
    listbox1_items_binding,
    listbox1_selectedItemIndex_binding,
    select_handler_1
  ];
}
class SelectionListbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$49, create_fragment$4a, safe_not_equal, {
      leftItems: 0,
      selectedLeftItemIndex: 1,
      rightItems: 2,
      selectedRightItemIndex: 3,
      labelProp: 4,
      valueProp: 5,
      listboxCssClass: 6
    });
  }
}
const get_below_listbox_slot_changes = (dirty) => ({});
const get_below_listbox_slot_context = (ctx) => ({});
function create_left_header_slot$1(ctx) {
  let b2;
  let t_value = (
    /*localize*/
    ctx[8](
      /*leftHeader*/
      ctx[4]
    ) + ""
  );
  let t2;
  return {
    c() {
      b2 = element("b");
      t2 = text(t_value);
      attr(b2, "slot", "left-header");
    },
    m(target, anchor) {
      insert(target, b2, anchor);
      append(b2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*leftHeader*/
      16 && t_value !== (t_value = /*localize*/
      ctx2[8](
        /*leftHeader*/
        ctx2[4]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(b2);
      }
    }
  };
}
function create_right_header_slot$1(ctx) {
  let b2;
  let t_value = (
    /*localize*/
    ctx[8](
      /*rightHeader*/
      ctx[5]
    ) + ""
  );
  let t2;
  return {
    c() {
      b2 = element("b");
      t2 = text(t_value);
      attr(b2, "slot", "right-header");
    },
    m(target, anchor) {
      insert(target, b2, anchor);
      append(b2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*rightHeader*/
      32 && t_value !== (t_value = /*localize*/
      ctx2[8](
        /*rightHeader*/
        ctx2[5]
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(b2);
      }
    }
  };
}
function create_fragment$49(ctx) {
  let article;
  let div1;
  let b2;
  let t0_value = (
    /*localize*/
    ctx[8](
      /*name*/
      ctx[2]
    ) + ""
  );
  let t0;
  let t1;
  let p2;
  let t2_value = (
    /*localize*/
    ctx[8](
      /*hint*/
      ctx[3]
    ) + ""
  );
  let t2;
  let t3;
  let div0;
  let selectionlistbox;
  let updating_leftItems;
  let updating_rightItems;
  let t4;
  let current;
  function selectionlistbox_leftItems_binding(value) {
    ctx[10](value);
  }
  function selectionlistbox_rightItems_binding(value) {
    ctx[11](value);
  }
  let selectionlistbox_props = {
    labelProp: (
      /*labelProp*/
      ctx[6]
    ),
    valueProp: (
      /*valueProp*/
      ctx[7]
    ),
    $$slots: {
      "right-header": [create_right_header_slot$1],
      "left-header": [create_left_header_slot$1]
    },
    $$scope: { ctx }
  };
  if (
    /*leftItems*/
    ctx[0] !== void 0
  ) {
    selectionlistbox_props.leftItems = /*leftItems*/
    ctx[0];
  }
  if (
    /*rightItems*/
    ctx[1] !== void 0
  ) {
    selectionlistbox_props.rightItems = /*rightItems*/
    ctx[1];
  }
  selectionlistbox = new SelectionListbox({ props: selectionlistbox_props });
  binding_callbacks.push(() => bind(selectionlistbox, "leftItems", selectionlistbox_leftItems_binding));
  binding_callbacks.push(() => bind(selectionlistbox, "rightItems", selectionlistbox_rightItems_binding));
  const below_listbox_slot_template = (
    /*#slots*/
    ctx[9]["below-listbox"]
  );
  const below_listbox_slot = create_slot(
    below_listbox_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_below_listbox_slot_context
  );
  return {
    c() {
      article = element("article");
      div1 = element("div");
      b2 = element("b");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      t2 = text(t2_value);
      t3 = space();
      div0 = element("div");
      create_component(selectionlistbox.$$.fragment);
      t4 = space();
      if (below_listbox_slot) below_listbox_slot.c();
      attr(div0, "class", "flex-column small-gap");
      attr(div1, "class", "description flex-1");
      attr(article, "class", "setting group");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div1);
      append(div1, b2);
      append(b2, t0);
      append(div1, t1);
      append(div1, p2);
      append(p2, t2);
      append(div1, t3);
      append(div1, div0);
      mount_component(selectionlistbox, div0, null);
      append(div0, t4);
      if (below_listbox_slot) {
        below_listbox_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*name*/
      4) && t0_value !== (t0_value = /*localize*/
      ctx2[8](
        /*name*/
        ctx2[2]
      ) + "")) set_data(t0, t0_value);
      if ((!current || dirty & /*hint*/
      8) && t2_value !== (t2_value = /*localize*/
      ctx2[8](
        /*hint*/
        ctx2[3]
      ) + "")) set_data(t2, t2_value);
      const selectionlistbox_changes = {};
      if (dirty & /*labelProp*/
      64) selectionlistbox_changes.labelProp = /*labelProp*/
      ctx2[6];
      if (dirty & /*valueProp*/
      128) selectionlistbox_changes.valueProp = /*valueProp*/
      ctx2[7];
      if (dirty & /*$$scope, rightHeader, leftHeader*/
      4144) {
        selectionlistbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_leftItems && dirty & /*leftItems*/
      1) {
        updating_leftItems = true;
        selectionlistbox_changes.leftItems = /*leftItems*/
        ctx2[0];
        add_flush_callback(() => updating_leftItems = false);
      }
      if (!updating_rightItems && dirty & /*rightItems*/
      2) {
        updating_rightItems = true;
        selectionlistbox_changes.rightItems = /*rightItems*/
        ctx2[1];
        add_flush_callback(() => updating_rightItems = false);
      }
      selectionlistbox.$set(selectionlistbox_changes);
      if (below_listbox_slot) {
        if (below_listbox_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            below_listbox_slot,
            below_listbox_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              below_listbox_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_below_listbox_slot_changes
            ),
            get_below_listbox_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(selectionlistbox.$$.fragment, local);
      transition_in(below_listbox_slot, local);
      current = true;
    },
    o(local) {
      transition_out(selectionlistbox.$$.fragment, local);
      transition_out(below_listbox_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(selectionlistbox);
      if (below_listbox_slot) below_listbox_slot.d(detaching);
    }
  };
}
function instance$48($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { hint } = $$props;
  let { leftHeader = "" } = $$props;
  let { leftItems } = $$props;
  let { rightHeader = "" } = $$props;
  let { rightItems } = $$props;
  let { labelProp } = $$props;
  let { valueProp } = $$props;
  const localize = FoundryAdapter.localize;
  function selectionlistbox_leftItems_binding(value) {
    leftItems = value;
    $$invalidate(0, leftItems);
  }
  function selectionlistbox_rightItems_binding(value) {
    rightItems = value;
    $$invalidate(1, rightItems);
  }
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2) $$invalidate(2, name = $$props2.name);
    if ("hint" in $$props2) $$invalidate(3, hint = $$props2.hint);
    if ("leftHeader" in $$props2) $$invalidate(4, leftHeader = $$props2.leftHeader);
    if ("leftItems" in $$props2) $$invalidate(0, leftItems = $$props2.leftItems);
    if ("rightHeader" in $$props2) $$invalidate(5, rightHeader = $$props2.rightHeader);
    if ("rightItems" in $$props2) $$invalidate(1, rightItems = $$props2.rightItems);
    if ("labelProp" in $$props2) $$invalidate(6, labelProp = $$props2.labelProp);
    if ("valueProp" in $$props2) $$invalidate(7, valueProp = $$props2.valueProp);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  return [
    leftItems,
    rightItems,
    name,
    hint,
    leftHeader,
    rightHeader,
    labelProp,
    valueProp,
    localize,
    slots,
    selectionlistbox_leftItems_binding,
    selectionlistbox_rightItems_binding,
    $$scope
  ];
}
class ListboxSetting extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$48, create_fragment$49, safe_not_equal, {
      name: 2,
      hint: 3,
      leftHeader: 4,
      leftItems: 0,
      rightHeader: 5,
      rightItems: 1,
      labelProp: 6,
      valueProp: 7
    });
  }
}
function create_below_listbox_slot$2(ctx) {
  let div;
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[3]("TIDY5E.Reset") + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-rotate-right");
      attr(button, "type", "button");
      attr(div, "slot", "below-listbox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$48(ctx) {
  let div;
  let selectsetting;
  let updating_value;
  let t0;
  let listboxsetting;
  let updating_leftItems;
  let updating_rightItems;
  let t1;
  let checkboxsetting0;
  let updating_value_1;
  let t2;
  let checkboxsetting1;
  let updating_value_2;
  let t3;
  let checkboxsetting2;
  let updating_value_3;
  let t4;
  let checkboxsetting3;
  let updating_value_4;
  let current;
  function selectsetting_value_binding(value) {
    ctx[4](value);
  }
  let selectsetting_props = {
    options: SettingsProvider.settings.initialCharacterSheetTab.options.choices(),
    name: SettingsProvider.settings.initialCharacterSheetTab.options.name,
    hint: SettingsProvider.settings.initialCharacterSheetTab.options.hint,
    id: "initialCharacterSheetTab"
  };
  if (
    /*$context*/
    ctx[0].settings.initialCharacterSheetTab !== void 0
  ) {
    selectsetting_props.value = /*$context*/
    ctx[0].settings.initialCharacterSheetTab;
  }
  selectsetting = new SelectSetting({ props: selectsetting_props });
  binding_callbacks.push(() => bind(selectsetting, "value", selectsetting_value_binding));
  function listboxsetting_leftItems_binding(value) {
    ctx[6](value);
  }
  function listboxsetting_rightItems_binding(value) {
    ctx[7](value);
  }
  let listboxsetting_props = {
    name: SettingsProvider.settings.defaultCharacterSheetTabs.options.name,
    hint: SettingsProvider.settings.defaultCharacterSheetTabs.options.hint,
    leftHeader: "TIDY5E.Settings.DefaultSheetTabs.AvailableHeader",
    rightHeader: "TIDY5E.Settings.DefaultSheetTabs.SelectedHeader",
    labelProp: "label",
    valueProp: "id",
    $$slots: {
      "below-listbox": [create_below_listbox_slot$2]
    },
    $$scope: { ctx }
  };
  if (
    /*$context*/
    ctx[0].defaultCharacterTabs.available !== void 0
  ) {
    listboxsetting_props.leftItems = /*$context*/
    ctx[0].defaultCharacterTabs.available;
  }
  if (
    /*$context*/
    ctx[0].defaultCharacterTabs.selected !== void 0
  ) {
    listboxsetting_props.rightItems = /*$context*/
    ctx[0].defaultCharacterTabs.selected;
  }
  listboxsetting = new ListboxSetting({ props: listboxsetting_props });
  binding_callbacks.push(() => bind(listboxsetting, "leftItems", listboxsetting_leftItems_binding));
  binding_callbacks.push(() => bind(listboxsetting, "rightItems", listboxsetting_rightItems_binding));
  function checkboxsetting0_value_binding(value) {
    ctx[8](value);
  }
  let checkboxsetting0_props = {
    name: SettingsProvider.settings.useCharacterEncumbranceBar.options.name,
    hint: SettingsProvider.settings.useCharacterEncumbranceBar.options.hint,
    id: "useCharacterEncumbranceBar"
  };
  if (
    /*$context*/
    ctx[0].settings.useCharacterEncumbranceBar !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.useCharacterEncumbranceBar;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[9](value);
  }
  let checkboxsetting1_props = {
    name: "TIDY5E.Settings.ShowPlayerName.name",
    hint: "TIDY5E.Settings.ShowPlayerName.hint",
    id: "showPlayerName"
  };
  if (
    /*$context*/
    ctx[0].settings.showPlayerName !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.showPlayerName;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  function checkboxsetting2_value_binding(value) {
    ctx[10](value);
  }
  let checkboxsetting2_props = {
    name: "TIDY5E.Settings.UseInspiration.name",
    hint: "TIDY5E.Settings.UseInspiration.hint",
    id: "useCharacterInspiration"
  };
  if (
    /*$context*/
    ctx[0].settings.useCharacterInspiration !== void 0
  ) {
    checkboxsetting2_props.value = /*$context*/
    ctx[0].settings.useCharacterInspiration;
  }
  checkboxsetting2 = new CheckboxSetting({ props: checkboxsetting2_props });
  binding_callbacks.push(() => bind(checkboxsetting2, "value", checkboxsetting2_value_binding));
  function checkboxsetting3_value_binding(value) {
    ctx[11](value);
  }
  let checkboxsetting3_props = {
    name: "TIDY5E.Settings.AllowHpMaxOverride.name",
    hint: "TIDY5E.Settings.AllowHpMaxOverride.hint",
    id: "allowHpMaxOverride"
  };
  if (
    /*$context*/
    ctx[0].settings.allowHpMaxOverride !== void 0
  ) {
    checkboxsetting3_props.value = /*$context*/
    ctx[0].settings.allowHpMaxOverride;
  }
  checkboxsetting3 = new CheckboxSetting({ props: checkboxsetting3_props });
  binding_callbacks.push(() => bind(checkboxsetting3, "value", checkboxsetting3_value_binding));
  return {
    c() {
      div = element("div");
      create_component(selectsetting.$$.fragment);
      t0 = space();
      create_component(listboxsetting.$$.fragment);
      t1 = space();
      create_component(checkboxsetting0.$$.fragment);
      t2 = space();
      create_component(checkboxsetting1.$$.fragment);
      t3 = space();
      create_component(checkboxsetting2.$$.fragment);
      t4 = space();
      create_component(checkboxsetting3.$$.fragment);
      attr(div, "class", "settings-form");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(selectsetting, div, null);
      append(div, t0);
      mount_component(listboxsetting, div, null);
      append(div, t1);
      mount_component(checkboxsetting0, div, null);
      append(div, t2);
      mount_component(checkboxsetting1, div, null);
      append(div, t3);
      mount_component(checkboxsetting2, div, null);
      append(div, t4);
      mount_component(checkboxsetting3, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const selectsetting_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        selectsetting_changes.value = /*$context*/
        ctx2[0].settings.initialCharacterSheetTab;
        add_flush_callback(() => updating_value = false);
      }
      selectsetting.$set(selectsetting_changes);
      const listboxsetting_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        listboxsetting_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_leftItems && dirty & /*$context*/
      1) {
        updating_leftItems = true;
        listboxsetting_changes.leftItems = /*$context*/
        ctx2[0].defaultCharacterTabs.available;
        add_flush_callback(() => updating_leftItems = false);
      }
      if (!updating_rightItems && dirty & /*$context*/
      1) {
        updating_rightItems = true;
        listboxsetting_changes.rightItems = /*$context*/
        ctx2[0].defaultCharacterTabs.selected;
        add_flush_callback(() => updating_rightItems = false);
      }
      listboxsetting.$set(listboxsetting_changes);
      const checkboxsetting0_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.useCharacterEncumbranceBar;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.showPlayerName;
        add_flush_callback(() => updating_value_2 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
      const checkboxsetting2_changes = {};
      if (!updating_value_3 && dirty & /*$context*/
      1) {
        updating_value_3 = true;
        checkboxsetting2_changes.value = /*$context*/
        ctx2[0].settings.useCharacterInspiration;
        add_flush_callback(() => updating_value_3 = false);
      }
      checkboxsetting2.$set(checkboxsetting2_changes);
      const checkboxsetting3_changes = {};
      if (!updating_value_4 && dirty & /*$context*/
      1) {
        updating_value_4 = true;
        checkboxsetting3_changes.value = /*$context*/
        ctx2[0].settings.allowHpMaxOverride;
        add_flush_callback(() => updating_value_4 = false);
      }
      checkboxsetting3.$set(checkboxsetting3_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectsetting.$$.fragment, local);
      transition_in(listboxsetting.$$.fragment, local);
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      transition_in(checkboxsetting2.$$.fragment, local);
      transition_in(checkboxsetting3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsetting.$$.fragment, local);
      transition_out(listboxsetting.$$.fragment, local);
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      transition_out(checkboxsetting2.$$.fragment, local);
      transition_out(checkboxsetting3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(selectsetting);
      destroy_component(listboxsetting);
      destroy_component(checkboxsetting0);
      destroy_component(checkboxsetting1);
      destroy_component(checkboxsetting2);
      destroy_component(checkboxsetting3);
    }
  };
}
function instance$47($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let functions = getContext(CONSTANTS.SVELTE_CONTEXT.FUNCTIONS);
  const localize = FoundryAdapter.localize;
  function selectsetting_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.initialCharacterSheetTab, value)) {
      $context.settings.initialCharacterSheetTab = value;
      context.set($context);
    }
  }
  const click_handler = () => functions.resetDefaultTabs(context, CONSTANTS.SHEET_TYPE_CHARACTER);
  function listboxsetting_leftItems_binding(value) {
    if ($$self.$$.not_equal($context.defaultCharacterTabs.available, value)) {
      $context.defaultCharacterTabs.available = value;
      context.set($context);
    }
  }
  function listboxsetting_rightItems_binding(value) {
    if ($$self.$$.not_equal($context.defaultCharacterTabs.selected, value)) {
      $context.defaultCharacterTabs.selected = value;
      context.set($context);
    }
  }
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useCharacterEncumbranceBar, value)) {
      $context.settings.useCharacterEncumbranceBar = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showPlayerName, value)) {
      $context.settings.showPlayerName = value;
      context.set($context);
    }
  }
  function checkboxsetting2_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useCharacterInspiration, value)) {
      $context.settings.useCharacterInspiration = value;
      context.set($context);
    }
  }
  function checkboxsetting3_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.allowHpMaxOverride, value)) {
      $context.settings.allowHpMaxOverride = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    functions,
    localize,
    selectsetting_value_binding,
    click_handler,
    listboxsetting_leftItems_binding,
    listboxsetting_rightItems_binding,
    checkboxsetting0_value_binding,
    checkboxsetting1_value_binding,
    checkboxsetting2_value_binding,
    checkboxsetting3_value_binding
  ];
}
class CharacterWorldSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$47, create_fragment$48, safe_not_equal, {});
  }
}
function create_below_listbox_slot$1(ctx) {
  let div;
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[3]("TIDY5E.Reset") + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-rotate-right");
      attr(button, "type", "button");
      attr(div, "slot", "below-listbox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$47(ctx) {
  let div;
  let selectsetting0;
  let updating_value;
  let t0;
  let listboxsetting;
  let updating_leftItems;
  let updating_rightItems;
  let t1;
  let checkboxsetting0;
  let updating_value_1;
  let t2;
  let selectsetting1;
  let updating_value_2;
  let t3;
  let checkboxsetting1;
  let updating_value_3;
  let current;
  function selectsetting0_value_binding(value) {
    ctx[4](value);
  }
  let selectsetting0_props = {
    options: SettingsProvider.settings.initialNpcSheetTab.options.choices(),
    name: SettingsProvider.settings.initialNpcSheetTab.options.name,
    hint: SettingsProvider.settings.initialNpcSheetTab.options.hint,
    id: "initialNpcSheetTab"
  };
  if (
    /*$context*/
    ctx[0].settings.initialNpcSheetTab !== void 0
  ) {
    selectsetting0_props.value = /*$context*/
    ctx[0].settings.initialNpcSheetTab;
  }
  selectsetting0 = new SelectSetting({ props: selectsetting0_props });
  binding_callbacks.push(() => bind(selectsetting0, "value", selectsetting0_value_binding));
  function listboxsetting_leftItems_binding(value) {
    ctx[6](value);
  }
  function listboxsetting_rightItems_binding(value) {
    ctx[7](value);
  }
  let listboxsetting_props = {
    name: SettingsProvider.settings.defaultNpcSheetTabs.options.name,
    hint: SettingsProvider.settings.defaultNpcSheetTabs.options.hint,
    leftHeader: "TIDY5E.Settings.DefaultSheetTabs.AvailableHeader",
    rightHeader: "TIDY5E.Settings.DefaultSheetTabs.SelectedHeader",
    labelProp: "label",
    valueProp: "id",
    $$slots: {
      "below-listbox": [create_below_listbox_slot$1]
    },
    $$scope: { ctx }
  };
  if (
    /*$context*/
    ctx[0].defaultNpcTabs.available !== void 0
  ) {
    listboxsetting_props.leftItems = /*$context*/
    ctx[0].defaultNpcTabs.available;
  }
  if (
    /*$context*/
    ctx[0].defaultNpcTabs.selected !== void 0
  ) {
    listboxsetting_props.rightItems = /*$context*/
    ctx[0].defaultNpcTabs.selected;
  }
  listboxsetting = new ListboxSetting({ props: listboxsetting_props });
  binding_callbacks.push(() => bind(listboxsetting, "leftItems", listboxsetting_leftItems_binding));
  binding_callbacks.push(() => bind(listboxsetting, "rightItems", listboxsetting_rightItems_binding));
  function checkboxsetting0_value_binding(value) {
    ctx[8](value);
  }
  let checkboxsetting0_props = {
    name: "TIDY5E.Settings.ShowNPCRestInChat.name",
    hint: "TIDY5E.Settings.ShowNPCRestInChat.hint",
    id: "showNpcRestInChat"
  };
  if (
    /*$context*/
    ctx[0].settings.showNpcRestInChat !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.showNpcRestInChat;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function selectsetting1_value_binding(value) {
    ctx[9](value);
  }
  let selectsetting1_props = {
    options: {
      default: "TIDY5E.Settings.ShowNPCActorLinkMarker.default",
      unlinked: "TIDY5E.Settings.ShowNPCActorLinkMarker.unlinked",
      both: "TIDY5E.Settings.ShowNPCActorLinkMarker.both"
    },
    name: "TIDY5E.Settings.ShowNPCActorLinkMarker.name",
    hint: "TIDY5E.Settings.ShowNPCActorLinkMarker.hint",
    id: "showNpcActorLinkMarker"
  };
  if (
    /*$context*/
    ctx[0].settings.showNpcActorLinkMarker !== void 0
  ) {
    selectsetting1_props.value = /*$context*/
    ctx[0].settings.showNpcActorLinkMarker;
  }
  selectsetting1 = new SelectSetting({ props: selectsetting1_props });
  binding_callbacks.push(() => bind(selectsetting1, "value", selectsetting1_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[10](value);
  }
  let checkboxsetting1_props = {
    name: SettingsProvider.settings.useNpcEncumbranceBar.options.name,
    hint: SettingsProvider.settings.useNpcEncumbranceBar.options.hint,
    id: "useNpcEncumbranceBar"
  };
  if (
    /*$context*/
    ctx[0].settings.useNpcEncumbranceBar !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.useNpcEncumbranceBar;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  return {
    c() {
      div = element("div");
      create_component(selectsetting0.$$.fragment);
      t0 = space();
      create_component(listboxsetting.$$.fragment);
      t1 = space();
      create_component(checkboxsetting0.$$.fragment);
      t2 = space();
      create_component(selectsetting1.$$.fragment);
      t3 = space();
      create_component(checkboxsetting1.$$.fragment);
      attr(div, "class", "settings-form");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(selectsetting0, div, null);
      append(div, t0);
      mount_component(listboxsetting, div, null);
      append(div, t1);
      mount_component(checkboxsetting0, div, null);
      append(div, t2);
      mount_component(selectsetting1, div, null);
      append(div, t3);
      mount_component(checkboxsetting1, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const selectsetting0_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        selectsetting0_changes.value = /*$context*/
        ctx2[0].settings.initialNpcSheetTab;
        add_flush_callback(() => updating_value = false);
      }
      selectsetting0.$set(selectsetting0_changes);
      const listboxsetting_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        listboxsetting_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_leftItems && dirty & /*$context*/
      1) {
        updating_leftItems = true;
        listboxsetting_changes.leftItems = /*$context*/
        ctx2[0].defaultNpcTabs.available;
        add_flush_callback(() => updating_leftItems = false);
      }
      if (!updating_rightItems && dirty & /*$context*/
      1) {
        updating_rightItems = true;
        listboxsetting_changes.rightItems = /*$context*/
        ctx2[0].defaultNpcTabs.selected;
        add_flush_callback(() => updating_rightItems = false);
      }
      listboxsetting.$set(listboxsetting_changes);
      const checkboxsetting0_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.showNpcRestInChat;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const selectsetting1_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        selectsetting1_changes.value = /*$context*/
        ctx2[0].settings.showNpcActorLinkMarker;
        add_flush_callback(() => updating_value_2 = false);
      }
      selectsetting1.$set(selectsetting1_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_3 && dirty & /*$context*/
      1) {
        updating_value_3 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.useNpcEncumbranceBar;
        add_flush_callback(() => updating_value_3 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectsetting0.$$.fragment, local);
      transition_in(listboxsetting.$$.fragment, local);
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(selectsetting1.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsetting0.$$.fragment, local);
      transition_out(listboxsetting.$$.fragment, local);
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(selectsetting1.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(selectsetting0);
      destroy_component(listboxsetting);
      destroy_component(checkboxsetting0);
      destroy_component(selectsetting1);
      destroy_component(checkboxsetting1);
    }
  };
}
function instance$46($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let functions = getContext(CONSTANTS.SVELTE_CONTEXT.FUNCTIONS);
  const localize = FoundryAdapter.localize;
  function selectsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.initialNpcSheetTab, value)) {
      $context.settings.initialNpcSheetTab = value;
      context.set($context);
    }
  }
  const click_handler = () => functions.resetDefaultTabs(context, CONSTANTS.SHEET_TYPE_NPC);
  function listboxsetting_leftItems_binding(value) {
    if ($$self.$$.not_equal($context.defaultNpcTabs.available, value)) {
      $context.defaultNpcTabs.available = value;
      context.set($context);
    }
  }
  function listboxsetting_rightItems_binding(value) {
    if ($$self.$$.not_equal($context.defaultNpcTabs.selected, value)) {
      $context.defaultNpcTabs.selected = value;
      context.set($context);
    }
  }
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showNpcRestInChat, value)) {
      $context.settings.showNpcRestInChat = value;
      context.set($context);
    }
  }
  function selectsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.showNpcActorLinkMarker, value)) {
      $context.settings.showNpcActorLinkMarker = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useNpcEncumbranceBar, value)) {
      $context.settings.useNpcEncumbranceBar = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    functions,
    localize,
    selectsetting0_value_binding,
    click_handler,
    listboxsetting_leftItems_binding,
    listboxsetting_rightItems_binding,
    checkboxsetting0_value_binding,
    selectsetting1_value_binding,
    checkboxsetting1_value_binding
  ];
}
class NpcWorldSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$46, create_fragment$47, safe_not_equal, {});
  }
}
function create_below_listbox_slot(ctx) {
  let div;
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[3]("TIDY5E.Reset") + ""
  );
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-rotate-right");
      attr(button, "type", "button");
      attr(div, "slot", "below-listbox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$46(ctx) {
  let div;
  let selectsetting;
  let updating_value;
  let t0;
  let listboxsetting;
  let updating_leftItems;
  let updating_rightItems;
  let t1;
  let checkboxsetting0;
  let updating_value_1;
  let t2;
  let checkboxsetting1;
  let updating_value_2;
  let current;
  function selectsetting_value_binding(value) {
    ctx[4](value);
  }
  let selectsetting_props = {
    options: SettingsProvider.settings.initialVehicleSheetTab.options.choices(),
    name: SettingsProvider.settings.initialVehicleSheetTab.options.name,
    hint: SettingsProvider.settings.initialVehicleSheetTab.options.hint,
    id: "initialVehicleSheetTab"
  };
  if (
    /*$context*/
    ctx[0].settings.initialVehicleSheetTab !== void 0
  ) {
    selectsetting_props.value = /*$context*/
    ctx[0].settings.initialVehicleSheetTab;
  }
  selectsetting = new SelectSetting({ props: selectsetting_props });
  binding_callbacks.push(() => bind(selectsetting, "value", selectsetting_value_binding));
  function listboxsetting_leftItems_binding(value) {
    ctx[6](value);
  }
  function listboxsetting_rightItems_binding(value) {
    ctx[7](value);
  }
  let listboxsetting_props = {
    name: SettingsProvider.settings.defaultVehicleSheetTabs.options.name,
    hint: SettingsProvider.settings.defaultVehicleSheetTabs.options.hint,
    leftHeader: "TIDY5E.Settings.DefaultSheetTabs.AvailableHeader",
    rightHeader: "TIDY5E.Settings.DefaultSheetTabs.SelectedHeader",
    labelProp: "label",
    valueProp: "id",
    $$slots: {
      "below-listbox": [create_below_listbox_slot]
    },
    $$scope: { ctx }
  };
  if (
    /*$context*/
    ctx[0].defaultVehicleTabs.available !== void 0
  ) {
    listboxsetting_props.leftItems = /*$context*/
    ctx[0].defaultVehicleTabs.available;
  }
  if (
    /*$context*/
    ctx[0].defaultVehicleTabs.selected !== void 0
  ) {
    listboxsetting_props.rightItems = /*$context*/
    ctx[0].defaultVehicleTabs.selected;
  }
  listboxsetting = new ListboxSetting({ props: listboxsetting_props });
  binding_callbacks.push(() => bind(listboxsetting, "leftItems", listboxsetting_leftItems_binding));
  binding_callbacks.push(() => bind(listboxsetting, "rightItems", listboxsetting_rightItems_binding));
  function checkboxsetting0_value_binding(value) {
    ctx[8](value);
  }
  let checkboxsetting0_props = {
    name: SettingsProvider.settings.useVehicleEncumbranceBar.options.name,
    hint: SettingsProvider.settings.useVehicleEncumbranceBar.options.hint,
    id: "useVehicleEncumbranceBar"
  };
  if (
    /*$context*/
    ctx[0].settings.useVehicleEncumbranceBar !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.useVehicleEncumbranceBar;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[9](value);
  }
  let checkboxsetting1_props = {
    name: "TIDY5E.Settings.UseVehicleMotion.name",
    hint: "TIDY5E.Settings.UseVehicleMotion.hint",
    id: "useVehicleMotion"
  };
  if (
    /*$context*/
    ctx[0].settings.useVehicleMotion !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.useVehicleMotion;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  return {
    c() {
      div = element("div");
      create_component(selectsetting.$$.fragment);
      t0 = space();
      create_component(listboxsetting.$$.fragment);
      t1 = space();
      create_component(checkboxsetting0.$$.fragment);
      t2 = space();
      create_component(checkboxsetting1.$$.fragment);
      attr(div, "class", "settings-form");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(selectsetting, div, null);
      append(div, t0);
      mount_component(listboxsetting, div, null);
      append(div, t1);
      mount_component(checkboxsetting0, div, null);
      append(div, t2);
      mount_component(checkboxsetting1, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const selectsetting_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        selectsetting_changes.value = /*$context*/
        ctx2[0].settings.initialVehicleSheetTab;
        add_flush_callback(() => updating_value = false);
      }
      selectsetting.$set(selectsetting_changes);
      const listboxsetting_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        listboxsetting_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_leftItems && dirty & /*$context*/
      1) {
        updating_leftItems = true;
        listboxsetting_changes.leftItems = /*$context*/
        ctx2[0].defaultVehicleTabs.available;
        add_flush_callback(() => updating_leftItems = false);
      }
      if (!updating_rightItems && dirty & /*$context*/
      1) {
        updating_rightItems = true;
        listboxsetting_changes.rightItems = /*$context*/
        ctx2[0].defaultVehicleTabs.selected;
        add_flush_callback(() => updating_rightItems = false);
      }
      listboxsetting.$set(listboxsetting_changes);
      const checkboxsetting0_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.useVehicleEncumbranceBar;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.useVehicleMotion;
        add_flush_callback(() => updating_value_2 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectsetting.$$.fragment, local);
      transition_in(listboxsetting.$$.fragment, local);
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsetting.$$.fragment, local);
      transition_out(listboxsetting.$$.fragment, local);
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(selectsetting);
      destroy_component(listboxsetting);
      destroy_component(checkboxsetting0);
      destroy_component(checkboxsetting1);
    }
  };
}
function instance$45($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let functions = getContext(CONSTANTS.SVELTE_CONTEXT.FUNCTIONS);
  const localize = FoundryAdapter.localize;
  function selectsetting_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.initialVehicleSheetTab, value)) {
      $context.settings.initialVehicleSheetTab = value;
      context.set($context);
    }
  }
  const click_handler = () => functions.resetDefaultTabs(context, CONSTANTS.SHEET_TYPE_VEHICLE);
  function listboxsetting_leftItems_binding(value) {
    if ($$self.$$.not_equal($context.defaultVehicleTabs.available, value)) {
      $context.defaultVehicleTabs.available = value;
      context.set($context);
    }
  }
  function listboxsetting_rightItems_binding(value) {
    if ($$self.$$.not_equal($context.defaultVehicleTabs.selected, value)) {
      $context.defaultVehicleTabs.selected = value;
      context.set($context);
    }
  }
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useVehicleEncumbranceBar, value)) {
      $context.settings.useVehicleEncumbranceBar = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useVehicleMotion, value)) {
      $context.settings.useVehicleMotion = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    functions,
    localize,
    selectsetting_value_binding,
    click_handler,
    listboxsetting_leftItems_binding,
    listboxsetting_rightItems_binding,
    checkboxsetting0_value_binding,
    checkboxsetting1_value_binding
  ];
}
class VehicleWorldSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$45, create_fragment$46, safe_not_equal, {});
  }
}
function create_fragment$45(ctx) {
  let div;
  let selectsetting;
  let updating_value;
  let t2;
  let checkboxsetting;
  let updating_value_1;
  let current;
  function selectsetting_value_binding(value) {
    ctx[2](value);
  }
  let selectsetting_props = {
    options: SettingsProvider.settings.itemIdentificationPermission.options.choices,
    name: SettingsProvider.settings.itemIdentificationPermission.options.name,
    hint: SettingsProvider.settings.itemIdentificationPermission.options.hint,
    id: "initialCharacterSheetTab"
  };
  if (
    /*$context*/
    ctx[0].settings.itemIdentificationPermission !== void 0
  ) {
    selectsetting_props.value = /*$context*/
    ctx[0].settings.itemIdentificationPermission;
  }
  selectsetting = new SelectSetting({ props: selectsetting_props });
  binding_callbacks.push(() => bind(selectsetting, "value", selectsetting_value_binding));
  function checkboxsetting_value_binding(value) {
    ctx[3](value);
  }
  let checkboxsetting_props = {
    name: SettingsProvider.settings.includeFlagsInSpellScrollCreation.options.name,
    hint: SettingsProvider.settings.includeFlagsInSpellScrollCreation.options.hint,
    id: "includeFlagsInSpellScrollCreation"
  };
  if (
    /*$context*/
    ctx[0].settings.includeFlagsInSpellScrollCreation !== void 0
  ) {
    checkboxsetting_props.value = /*$context*/
    ctx[0].settings.includeFlagsInSpellScrollCreation;
  }
  checkboxsetting = new CheckboxSetting({ props: checkboxsetting_props });
  binding_callbacks.push(() => bind(checkboxsetting, "value", checkboxsetting_value_binding));
  return {
    c() {
      div = element("div");
      create_component(selectsetting.$$.fragment);
      t2 = space();
      create_component(checkboxsetting.$$.fragment);
      attr(div, "class", "settings-form");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(selectsetting, div, null);
      append(div, t2);
      mount_component(checkboxsetting, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const selectsetting_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        selectsetting_changes.value = /*$context*/
        ctx2[0].settings.itemIdentificationPermission;
        add_flush_callback(() => updating_value = false);
      }
      selectsetting.$set(selectsetting_changes);
      const checkboxsetting_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting_changes.value = /*$context*/
        ctx2[0].settings.includeFlagsInSpellScrollCreation;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting.$set(checkboxsetting_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectsetting.$$.fragment, local);
      transition_in(checkboxsetting.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsetting.$$.fragment, local);
      transition_out(checkboxsetting.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(selectsetting);
      destroy_component(checkboxsetting);
    }
  };
}
function instance$44($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  function selectsetting_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.itemIdentificationPermission, value)) {
      $context.settings.itemIdentificationPermission = value;
      context.set($context);
    }
  }
  function checkboxsetting_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.includeFlagsInSpellScrollCreation, value)) {
      $context.settings.includeFlagsInSpellScrollCreation = value;
      context.set($context);
    }
  }
  return [$context, context, selectsetting_value_binding, checkboxsetting_value_binding];
}
class ItemWorldSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$44, create_fragment$45, safe_not_equal, {});
  }
}
function get_each_context$16(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  child_ctx[10] = list;
  child_ctx[11] = i2;
  return child_ctx;
}
function create_if_block_2$T(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[5]("TIDY5E.WorldSettings.Exhaustion.options.open.explanation")}`;
      attr(p2, "class", "tidy5e-notes");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(p2);
      }
    }
  };
}
function create_if_block$1Q(ctx) {
  let article;
  let section;
  let div0;
  let label;
  let t0_value = (
    /*localize*/
    ctx[5]("TIDY5E.WorldSettings.Exhaustion.options.specific.levels.name") + ""
  );
  let t0;
  let t1;
  let p2;
  let t3;
  let div1;
  let input;
  let t4;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = (
    /*config*/
    ctx[0].type === "specific" && create_if_block_1$16(ctx)
  );
  return {
    c() {
      article = element("article");
      section = element("section");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[5]("TIDY5E.WorldSettings.Exhaustion.options.specific.levels.hint")}`;
      t3 = space();
      div1 = element("div");
      input = element("input");
      t4 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(label, "for", "exhaustionConfigTypeLevels-" + /*appId*/
      ctx[4]);
      attr(p2, "class", "tidy5e-notes");
      attr(div0, "class", "description");
      attr(input, "type", "number");
      attr(input, "min", "1");
      attr(div1, "class", "settings-group");
      attr(article, "class", "setting group");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, section);
      append(section, div0);
      append(div0, label);
      append(label, t0);
      append(div0, t1);
      append(div0, p2);
      append(section, t3);
      append(section, div1);
      append(div1, input);
      set_input_value(
        input,
        /*config*/
        ctx[0].levels
      );
      insert(target, t4, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*config*/
      1 && to_number(input.value) !== /*config*/
      ctx2[0].levels) {
        set_input_value(
          input,
          /*config*/
          ctx2[0].levels
        );
      }
      if (
        /*config*/
        ctx2[0].type === "specific"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$16(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(article);
        detach(t4);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$16(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*levelsIterator*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*i*/
    ctx2[11]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$16(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$16(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*levelsIterator, appId, config, localize*/
      57) {
        each_value = ensure_array_like(
          /*levelsIterator*/
          ctx2[3]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$16, each_1_anchor, get_each_context$16);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$16(key_1, ctx) {
  let article;
  let section;
  let div0;
  let label;
  let t0_value = (
    /*localize*/
    ctx[5]("TIDY5E.WorldSettings.Exhaustion.options.specific.levels.tooltip.name", { level: (
      /*i*/
      ctx[11]
    ) }) + ""
  );
  let t0;
  let t1;
  let i_1;
  let label_for_value;
  let label_title_value;
  let t2;
  let p2;
  let t4;
  let div1;
  let input;
  let input_id_value;
  let t5;
  let mounted;
  let dispose;
  function input_input_handler_1() {
    ctx[8].call(
      input,
      /*i*/
      ctx[11]
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      article = element("article");
      section = element("section");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      i_1 = element("i");
      t2 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[5]("TIDY5E.WorldSettings.Exhaustion.options.specific.levels.tooltip.hint")}`;
      t4 = space();
      div1 = element("div");
      input = element("input");
      t5 = space();
      attr(i_1, "class", "fas fa-info-circle");
      attr(label, "for", label_for_value = "exhaustion-level-" + /*i*/
      ctx[11] + "-" + /*appId*/
      ctx[4]);
      attr(label, "title", label_title_value = /*localize*/
      ctx[5](
        /*config*/
        ctx[0].hints[
          /*i*/
          ctx[11]
        ]
      ));
      attr(label, "class", "flex-row small-gap align-items-center");
      attr(p2, "class", "tidy5e-notes");
      attr(div0, "class", "description");
      attr(input, "type", "text");
      attr(input, "id", input_id_value = "exhaustion-level-" + /*i*/
      ctx[11] + "-" + /*appId*/
      ctx[4]);
      attr(div1, "class", "settings-group");
      attr(section, "class", "");
      attr(article, "class", "setting group");
      this.first = article;
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, section);
      append(section, div0);
      append(div0, label);
      append(label, t0);
      append(label, t1);
      append(label, i_1);
      append(div0, t2);
      append(div0, p2);
      append(section, t4);
      append(section, div1);
      append(div1, input);
      set_input_value(
        input,
        /*config*/
        ctx[0].hints[
          /*i*/
          ctx[11]
        ]
      );
      append(article, t5);
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*levelsIterator*/
      8 && t0_value !== (t0_value = /*localize*/
      ctx[5]("TIDY5E.WorldSettings.Exhaustion.options.specific.levels.tooltip.name", { level: (
        /*i*/
        ctx[11]
      ) }) + "")) set_data(t0, t0_value);
      if (dirty & /*levelsIterator*/
      8 && label_for_value !== (label_for_value = "exhaustion-level-" + /*i*/
      ctx[11] + "-" + /*appId*/
      ctx[4])) {
        attr(label, "for", label_for_value);
      }
      if (dirty & /*config, levelsIterator*/
      9 && label_title_value !== (label_title_value = /*localize*/
      ctx[5](
        /*config*/
        ctx[0].hints[
          /*i*/
          ctx[11]
        ]
      ))) {
        attr(label, "title", label_title_value);
      }
      if (dirty & /*levelsIterator*/
      8 && input_id_value !== (input_id_value = "exhaustion-level-" + /*i*/
      ctx[11] + "-" + /*appId*/
      ctx[4])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*config, levelsIterator*/
      9 && input.value !== /*config*/
      ctx[0].hints[
        /*i*/
        ctx[11]
      ]) {
        set_input_value(
          input,
          /*config*/
          ctx[0].hints[
            /*i*/
            ctx[11]
          ]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$44(ctx) {
  let article;
  let section;
  let div0;
  let label;
  let t0_value = (
    /*localize*/
    ctx[5](
      /*name*/
      ctx[1]
    ) + ""
  );
  let t0;
  let t1;
  let p2;
  let t2_value = (
    /*localize*/
    ctx[5](
      /*hint*/
      ctx[2]
    ) + ""
  );
  let t2;
  let t3;
  let div1;
  let select;
  let selectoptions;
  let t4;
  let t5;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  selectoptions = new SelectOptions({
    props: {
      data: {
        specific: "TIDY5E.WorldSettings.Exhaustion.options.specific.text",
        open: "TIDY5E.WorldSettings.Exhaustion.options.open.text"
      }
    }
  });
  let if_block0 = (
    /*config*/
    ctx[0].type === "open" && create_if_block_2$T(ctx)
  );
  let if_block1 = (
    /*config*/
    ctx[0].type === "specific" && create_if_block$1Q(ctx)
  );
  return {
    c() {
      article = element("article");
      section = element("section");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      p2 = element("p");
      t2 = text(t2_value);
      t3 = space();
      div1 = element("div");
      select = element("select");
      create_component(selectoptions.$$.fragment);
      t4 = space();
      if (if_block0) if_block0.c();
      t5 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
      attr(label, "for", "exhaustionConfigType-" + /*appId*/
      ctx[4]);
      attr(p2, "class", "tidy5e-notes");
      attr(div0, "class", "description");
      attr(select, "id", "exhaustionConfigType-" + /*appId*/
      ctx[4]);
      if (
        /*config*/
        ctx[0].type === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[6].call(select)
      ));
      attr(div1, "class", "settings-group");
      attr(article, "class", "setting group");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, section);
      append(section, div0);
      append(div0, label);
      append(label, t0);
      append(div0, t1);
      append(div0, p2);
      append(p2, t2);
      append(section, t3);
      append(section, div1);
      append(div1, select);
      mount_component(selectoptions, select, null);
      select_option(
        select,
        /*config*/
        ctx[0].type,
        true
      );
      append(div1, t4);
      if (if_block0) if_block0.m(div1, null);
      insert(target, t5, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*name*/
      2) && t0_value !== (t0_value = /*localize*/
      ctx2[5](
        /*name*/
        ctx2[1]
      ) + "")) set_data(t0, t0_value);
      if ((!current || dirty & /*hint*/
      4) && t2_value !== (t2_value = /*localize*/
      ctx2[5](
        /*hint*/
        ctx2[2]
      ) + "")) set_data(t2, t2_value);
      if (dirty & /*config*/
      1) {
        select_option(
          select,
          /*config*/
          ctx2[0].type
        );
      }
      if (
        /*config*/
        ctx2[0].type === "open"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$T(ctx2);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*config*/
        ctx2[0].type === "specific"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1Q(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
        detach(t5);
        detach(if_block1_anchor);
      }
      destroy_component(selectoptions);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$43($$self, $$props, $$invalidate) {
  let levelsIterator;
  let { name } = $$props;
  let { hint } = $$props;
  let { config } = $$props;
  let appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  const localize = FoundryAdapter.localize;
  function select_change_handler() {
    config.type = select_value(this);
    $$invalidate(0, config);
  }
  function input_input_handler() {
    config.levels = to_number(this.value);
    $$invalidate(0, config);
  }
  function input_input_handler_1(i2) {
    config.hints[i2] = this.value;
    $$invalidate(0, config);
  }
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2) $$invalidate(1, name = $$props2.name);
    if ("hint" in $$props2) $$invalidate(2, hint = $$props2.hint);
    if ("config" in $$props2) $$invalidate(0, config = $$props2.config);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*config*/
    1) {
      $$invalidate(3, levelsIterator = config.type === "specific" ? Array(config.levels + 1).fill(0) : []);
    }
  };
  return [
    config,
    name,
    hint,
    levelsIterator,
    appId,
    localize,
    select_change_handler,
    input_input_handler,
    input_input_handler_1
  ];
}
class ExhaustionSetting extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$43, create_fragment$44, safe_not_equal, { name: 1, hint: 2, config: 0 });
  }
}
function getStandardExhaustionConfig() {
  return {
    type: "specific",
    levels: 6,
    hints: [
      "TIDY5E.StandardExhaustion0",
      "TIDY5E.StandardExhaustion1",
      "TIDY5E.StandardExhaustion2",
      "TIDY5E.StandardExhaustion3",
      "TIDY5E.StandardExhaustion4",
      "TIDY5E.StandardExhaustion5",
      "TIDY5E.StandardExhaustion6"
    ]
  };
}
function getOneDnDExhaustionConfig() {
  return {
    type: "specific",
    levels: 11,
    hints: [
      "TIDY5E.OneDnDExhaustion0",
      "TIDY5E.OneDnDExhaustion1",
      "TIDY5E.OneDnDExhaustion2",
      "TIDY5E.OneDnDExhaustion3",
      "TIDY5E.OneDnDExhaustion4",
      "TIDY5E.OneDnDExhaustion5",
      "TIDY5E.OneDnDExhaustion6",
      "TIDY5E.OneDnDExhaustion7",
      "TIDY5E.OneDnDExhaustion8",
      "TIDY5E.OneDnDExhaustion9",
      "TIDY5E.OneDnDExhaustion10",
      "TIDY5E.OneDnDExhaustion11"
    ]
  };
}
function getStandardVehicleExhaustionConfig() {
  return {
    type: "specific",
    levels: 6,
    hints: [
      "TIDY5E.StandardVehicleExhaustion0",
      "TIDY5E.StandardVehicleExhaustion1",
      "TIDY5E.StandardVehicleExhaustion2",
      "TIDY5E.StandardVehicleExhaustion3",
      "TIDY5E.StandardVehicleExhaustion4",
      "TIDY5E.StandardVehicleExhaustion5",
      "TIDY5E.StandardVehicleExhaustion6"
    ]
  };
}
const iconsWithSeverity = [
  { iconCssClass: "far fa-grin", severity: 0 },
  { iconCssClass: "far fa-smile", severity: 1 },
  { iconCssClass: "far fa-meh", severity: 1 },
  { iconCssClass: "far fa-frown", severity: 2 },
  { iconCssClass: "far fa-frown-open", severity: 2 },
  { iconCssClass: "far fa-tired", severity: 3 },
  { iconCssClass: "far fa-dizzy", severity: 3 }
];
function getExhaustionIconsWithSeverity(levels) {
  const levelsIncludingZero = levels + 1;
  if (levelsIncludingZero === 0) {
    return [];
  }
  const lastIconWithSeverity = iconsWithSeverity[iconsWithSeverity.length - 1];
  if (levelsIncludingZero === 1) {
    return [iconsWithSeverity[0]];
  }
  if (levelsIncludingZero === 2) {
    return [iconsWithSeverity[0], lastIconWithSeverity];
  }
  const middleIcons = iconsWithSeverity.slice(1, iconsWithSeverity.length - 1);
  const middleIconsLength = middleIcons.length;
  let distributedIcons = [];
  for (let index = 0; index < levelsIncludingZero - 2; index++) {
    const iconIndex = index % middleIconsLength;
    distributedIcons.push({
      iconWithSeverity: middleIcons[iconIndex],
      order: iconIndex
    });
  }
  return [
    iconsWithSeverity[0],
    ...distributedIcons.sort((a2, b2) => a2.order - b2.order).map((q) => q.iconWithSeverity),
    lastIconWithSeverity
  ];
}
function create_fragment$43(ctx) {
  let div;
  let checkboxsetting;
  let updating_value;
  let t0;
  let h20;
  let t2;
  let article0;
  let button0;
  let t4;
  let button1;
  let t6;
  let exhaustionsetting0;
  let updating_config;
  let t7;
  let h21;
  let t9;
  let article1;
  let button2;
  let t11;
  let exhaustionsetting1;
  let updating_config_1;
  let current;
  let mounted;
  let dispose;
  function checkboxsetting_value_binding(value) {
    ctx[3](value);
  }
  let checkboxsetting_props = {
    name: "TIDY5E.Settings.UseExhaustion.name",
    hint: "TIDY5E.Settings.UseExhaustion.hint",
    id: "useExhaustion"
  };
  if (
    /*$context*/
    ctx[0].settings.useExhaustion !== void 0
  ) {
    checkboxsetting_props.value = /*$context*/
    ctx[0].settings.useExhaustion;
  }
  checkboxsetting = new CheckboxSetting({ props: checkboxsetting_props });
  binding_callbacks.push(() => bind(checkboxsetting, "value", checkboxsetting_value_binding));
  function exhaustionsetting0_config_binding(value) {
    ctx[6](value);
  }
  let exhaustionsetting0_props = {
    name: "TIDY5E.WorldSettings.Exhaustion.name",
    hint: "TIDY5E.WorldSettings.Exhaustion.hint"
  };
  if (
    /*$context*/
    ctx[0].exhaustionConfig !== void 0
  ) {
    exhaustionsetting0_props.config = /*$context*/
    ctx[0].exhaustionConfig;
  }
  exhaustionsetting0 = new ExhaustionSetting({ props: exhaustionsetting0_props });
  binding_callbacks.push(() => bind(exhaustionsetting0, "config", exhaustionsetting0_config_binding));
  function exhaustionsetting1_config_binding(value) {
    ctx[8](value);
  }
  let exhaustionsetting1_props = {
    name: "TIDY5E.WorldSettings.VehicleExhaustion.name",
    hint: "TIDY5E.WorldSettings.VehicleExhaustion.hint"
  };
  if (
    /*$context*/
    ctx[0].vehicleExhaustionConfig !== void 0
  ) {
    exhaustionsetting1_props.config = /*$context*/
    ctx[0].vehicleExhaustionConfig;
  }
  exhaustionsetting1 = new ExhaustionSetting({ props: exhaustionsetting1_props });
  binding_callbacks.push(() => bind(exhaustionsetting1, "config", exhaustionsetting1_config_binding));
  return {
    c() {
      div = element("div");
      create_component(checkboxsetting.$$.fragment);
      t0 = space();
      h20 = element("h2");
      h20.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.Exhaustion.Header")}`;
      t2 = space();
      article0 = element("article");
      button0 = element("button");
      button0.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.Exhaustion.useStandardExhaustion")}`;
      t4 = space();
      button1 = element("button");
      button1.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.Exhaustion.useOneDnDExhaustion")}`;
      t6 = space();
      create_component(exhaustionsetting0.$$.fragment);
      t7 = space();
      h21 = element("h2");
      h21.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.VehicleExhaustion.Header")}`;
      t9 = space();
      article1 = element("article");
      button2 = element("button");
      button2.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.Exhaustion.useStandardExhaustion")}`;
      t11 = space();
      create_component(exhaustionsetting1.$$.fragment);
      attr(button0, "type", "button");
      attr(button1, "type", "button");
      attr(article0, "class", "setting buttons");
      attr(button2, "type", "button");
      attr(article1, "class", "setting buttons");
      attr(div, "class", "settings-form");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkboxsetting, div, null);
      append(div, t0);
      append(div, h20);
      append(div, t2);
      append(div, article0);
      append(article0, button0);
      append(article0, t4);
      append(article0, button1);
      append(div, t6);
      mount_component(exhaustionsetting0, div, null);
      append(div, t7);
      append(div, h21);
      append(div, t9);
      append(div, article1);
      append(article1, button2);
      append(div, t11);
      mount_component(exhaustionsetting1, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[5]
          ),
          listen(
            button2,
            "click",
            /*click_handler_2*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const checkboxsetting_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        checkboxsetting_changes.value = /*$context*/
        ctx2[0].settings.useExhaustion;
        add_flush_callback(() => updating_value = false);
      }
      checkboxsetting.$set(checkboxsetting_changes);
      const exhaustionsetting0_changes = {};
      if (!updating_config && dirty & /*$context*/
      1) {
        updating_config = true;
        exhaustionsetting0_changes.config = /*$context*/
        ctx2[0].exhaustionConfig;
        add_flush_callback(() => updating_config = false);
      }
      exhaustionsetting0.$set(exhaustionsetting0_changes);
      const exhaustionsetting1_changes = {};
      if (!updating_config_1 && dirty & /*$context*/
      1) {
        updating_config_1 = true;
        exhaustionsetting1_changes.config = /*$context*/
        ctx2[0].vehicleExhaustionConfig;
        add_flush_callback(() => updating_config_1 = false);
      }
      exhaustionsetting1.$set(exhaustionsetting1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkboxsetting.$$.fragment, local);
      transition_in(exhaustionsetting0.$$.fragment, local);
      transition_in(exhaustionsetting1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxsetting.$$.fragment, local);
      transition_out(exhaustionsetting0.$$.fragment, local);
      transition_out(exhaustionsetting1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(checkboxsetting);
      destroy_component(exhaustionsetting0);
      destroy_component(exhaustionsetting1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$42($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function checkboxsetting_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useExhaustion, value)) {
      $context.settings.useExhaustion = value;
      context.set($context);
    }
  }
  const click_handler = () => set_store_value(context, $context.exhaustionConfig = getStandardExhaustionConfig(), $context);
  const click_handler_1 = () => set_store_value(context, $context.exhaustionConfig = getOneDnDExhaustionConfig(), $context);
  function exhaustionsetting0_config_binding(value) {
    if ($$self.$$.not_equal($context.exhaustionConfig, value)) {
      $context.exhaustionConfig = value;
      context.set($context);
    }
  }
  const click_handler_2 = () => set_store_value(context, $context.vehicleExhaustionConfig = getStandardVehicleExhaustionConfig(), $context);
  function exhaustionsetting1_config_binding(value) {
    if ($$self.$$.not_equal($context.vehicleExhaustionConfig, value)) {
      $context.vehicleExhaustionConfig = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    localize,
    checkboxsetting_value_binding,
    click_handler,
    click_handler_1,
    exhaustionsetting0_config_binding,
    click_handler_2,
    exhaustionsetting1_config_binding
  ];
}
class ExhaustionWorldSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$42, create_fragment$43, safe_not_equal, {});
  }
}
function create_fragment$42(ctx) {
  let div;
  let checkboxsetting0;
  let updating_value;
  let t0;
  let checkboxsetting1;
  let updating_value_1;
  let t1;
  let checkboxsetting2;
  let updating_value_2;
  let t2;
  let h2;
  let t4;
  let p0;
  let t6;
  let p1;
  let t8;
  let checkboxsetting3;
  let updating_value_3;
  let t9;
  let h30;
  let t11;
  let checkboxsetting4;
  let updating_value_4;
  let t12;
  let checkboxsetting5;
  let updating_value_5;
  let t13;
  let checkboxsetting6;
  let updating_value_6;
  let t14;
  let h31;
  let t16;
  let checkboxsetting7;
  let updating_value_7;
  let t17;
  let h32;
  let t19;
  let checkboxsetting8;
  let updating_value_8;
  let t20;
  let checkboxsetting9;
  let updating_value_9;
  let current;
  function checkboxsetting0_value_binding(value) {
    ctx[3](value);
  }
  let checkboxsetting0_props = {
    name: "TIDY5E.Settings.PermanentlyUnlockCharacterSheetForGM.name",
    hint: "TIDY5E.Settings.PermanentlyUnlockCharacterSheetForGM.hint",
    id: "permanentlyUnlockCharacterSheetForGm"
  };
  if (
    /*$context*/
    ctx[0].settings.permanentlyUnlockCharacterSheetForGm !== void 0
  ) {
    checkboxsetting0_props.value = /*$context*/
    ctx[0].settings.permanentlyUnlockCharacterSheetForGm;
  }
  checkboxsetting0 = new CheckboxSetting({ props: checkboxsetting0_props });
  binding_callbacks.push(() => bind(checkboxsetting0, "value", checkboxsetting0_value_binding));
  function checkboxsetting1_value_binding(value) {
    ctx[4](value);
  }
  let checkboxsetting1_props = {
    name: "TIDY5E.Settings.PermanentlyUnlockNPCSheetForGM.name",
    hint: "TIDY5E.Settings.PermanentlyUnlockNPCSheetForGM.hint",
    id: "permanentlyUnlockNpcSheetForGm"
  };
  if (
    /*$context*/
    ctx[0].settings.permanentlyUnlockNpcSheetForGm !== void 0
  ) {
    checkboxsetting1_props.value = /*$context*/
    ctx[0].settings.permanentlyUnlockNpcSheetForGm;
  }
  checkboxsetting1 = new CheckboxSetting({ props: checkboxsetting1_props });
  binding_callbacks.push(() => bind(checkboxsetting1, "value", checkboxsetting1_value_binding));
  function checkboxsetting2_value_binding(value) {
    ctx[5](value);
  }
  let checkboxsetting2_props = {
    name: "TIDY5E.Settings.PermanentlyUnlockVehicleSheetForGM.name",
    hint: "TIDY5E.Settings.PermanentlyUnlockVehicleSheetForGM.hint",
    id: "permanentlyUnlockVehicleSheetForGm"
  };
  if (
    /*$context*/
    ctx[0].settings.permanentlyUnlockVehicleSheetForGm !== void 0
  ) {
    checkboxsetting2_props.value = /*$context*/
    ctx[0].settings.permanentlyUnlockVehicleSheetForGm;
  }
  checkboxsetting2 = new CheckboxSetting({ props: checkboxsetting2_props });
  binding_callbacks.push(() => bind(checkboxsetting2, "value", checkboxsetting2_value_binding));
  function checkboxsetting3_value_binding(value) {
    ctx[6](value);
  }
  let checkboxsetting3_props = {
    name: "TIDY5E.Settings.UseTotalSheetLock.name",
    hint: "TIDY5E.Settings.UseTotalSheetLock.hint",
    id: "useTotalSheetLock"
  };
  if (
    /*$context*/
    ctx[0].settings.useTotalSheetLock !== void 0
  ) {
    checkboxsetting3_props.value = /*$context*/
    ctx[0].settings.useTotalSheetLock;
  }
  checkboxsetting3 = new CheckboxSetting({ props: checkboxsetting3_props });
  binding_callbacks.push(() => bind(checkboxsetting3, "value", checkboxsetting3_value_binding));
  function checkboxsetting4_value_binding(value) {
    ctx[7](value);
  }
  let checkboxsetting4_props = {
    name: "TIDY5E.Settings.LockExpChanges.name",
    hint: "TIDY5E.Settings.LockExpChanges.hint",
    id: "lockExpChanges"
  };
  if (
    /*$context*/
    ctx[0].settings.lockExpChanges !== void 0
  ) {
    checkboxsetting4_props.value = /*$context*/
    ctx[0].settings.lockExpChanges;
  }
  checkboxsetting4 = new CheckboxSetting({ props: checkboxsetting4_props });
  binding_callbacks.push(() => bind(checkboxsetting4, "value", checkboxsetting4_value_binding));
  function checkboxsetting5_value_binding(value) {
    ctx[8](value);
  }
  let checkboxsetting5_props = {
    name: "TIDY5E.Settings.LockHpMaxChanges.name",
    hint: "TIDY5E.Settings.LockHpMaxChanges.hint",
    id: "lockHpMaxChanges"
  };
  if (
    /*$context*/
    ctx[0].settings.lockHpMaxChanges !== void 0
  ) {
    checkboxsetting5_props.value = /*$context*/
    ctx[0].settings.lockHpMaxChanges;
  }
  checkboxsetting5 = new CheckboxSetting({ props: checkboxsetting5_props });
  binding_callbacks.push(() => bind(checkboxsetting5, "value", checkboxsetting5_value_binding));
  function checkboxsetting6_value_binding(value) {
    ctx[9](value);
  }
  let checkboxsetting6_props = {
    name: "TIDY5E.Settings.LockConfigureSheet.name",
    hint: "TIDY5E.Settings.LockConfigureSheet.hint",
    id: "lockConfigureSheet"
  };
  if (
    /*$context*/
    ctx[0].settings.lockConfigureSheet !== void 0
  ) {
    checkboxsetting6_props.value = /*$context*/
    ctx[0].settings.lockConfigureSheet;
  }
  checkboxsetting6 = new CheckboxSetting({ props: checkboxsetting6_props });
  binding_callbacks.push(() => bind(checkboxsetting6, "value", checkboxsetting6_value_binding));
  function checkboxsetting7_value_binding(value) {
    ctx[10](value);
  }
  let checkboxsetting7_props = {
    name: "TIDY5E.Settings.LockMoneyChanges.name",
    hint: "TIDY5E.Settings.LockMoneyChanges.hint",
    id: "lockMoneyChanges"
  };
  if (
    /*$context*/
    ctx[0].settings.lockMoneyChanges !== void 0
  ) {
    checkboxsetting7_props.value = /*$context*/
    ctx[0].settings.lockMoneyChanges;
  }
  checkboxsetting7 = new CheckboxSetting({ props: checkboxsetting7_props });
  binding_callbacks.push(() => bind(checkboxsetting7, "value", checkboxsetting7_value_binding));
  function checkboxsetting8_value_binding(value) {
    ctx[11](value);
  }
  let checkboxsetting8_props = {
    name: "TIDY5E.Settings.LockLevelSelector.name",
    hint: "TIDY5E.Settings.LockLevelSelector.hint",
    id: "lockLevelSelector"
  };
  if (
    /*$context*/
    ctx[0].settings.lockLevelSelector !== void 0
  ) {
    checkboxsetting8_props.value = /*$context*/
    ctx[0].settings.lockLevelSelector;
  }
  checkboxsetting8 = new CheckboxSetting({ props: checkboxsetting8_props });
  binding_callbacks.push(() => bind(checkboxsetting8, "value", checkboxsetting8_value_binding));
  function checkboxsetting9_value_binding(value) {
    ctx[12](value);
  }
  let checkboxsetting9_props = {
    name: "TIDY5E.Settings.LockItemQuantity.name",
    hint: "TIDY5E.Settings.LockItemQuantity.hint",
    id: "lockItemQuantity"
  };
  if (
    /*$context*/
    ctx[0].settings.lockItemQuantity !== void 0
  ) {
    checkboxsetting9_props.value = /*$context*/
    ctx[0].settings.lockItemQuantity;
  }
  checkboxsetting9 = new CheckboxSetting({ props: checkboxsetting9_props });
  binding_callbacks.push(() => bind(checkboxsetting9, "value", checkboxsetting9_value_binding));
  return {
    c() {
      div = element("div");
      create_component(checkboxsetting0.$$.fragment);
      t0 = space();
      create_component(checkboxsetting1.$$.fragment);
      t1 = space();
      create_component(checkboxsetting2.$$.fragment);
      t2 = space();
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.TabSheetLock.header")}`;
      t4 = space();
      p0 = element("p");
      p0.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.TabSheetLock.hint")}`;
      t6 = space();
      p1 = element("p");
      p1.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.TabSheetLock.hint2")}`;
      t8 = space();
      create_component(checkboxsetting3.$$.fragment);
      t9 = space();
      h30 = element("h3");
      h30.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.TabSheetLock.labelGeneralLocks")}`;
      t11 = space();
      create_component(checkboxsetting4.$$.fragment);
      t12 = space();
      create_component(checkboxsetting5.$$.fragment);
      t13 = space();
      create_component(checkboxsetting6.$$.fragment);
      t14 = space();
      h31 = element("h3");
      h31.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.TabSheetLock.labelInventoryLocks")}`;
      t16 = space();
      create_component(checkboxsetting7.$$.fragment);
      t17 = space();
      h32 = element("h3");
      h32.textContent = `${/*localize*/
      ctx[2]("TIDY5E.WorldSettings.TabSheetLock.labelFeaturesLocks")}`;
      t19 = space();
      create_component(checkboxsetting8.$$.fragment);
      t20 = space();
      create_component(checkboxsetting9.$$.fragment);
      attr(p0, "class", "tab-notes");
      attr(p1, "class", "tab-notes");
      attr(div, "class", "settings-form");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkboxsetting0, div, null);
      append(div, t0);
      mount_component(checkboxsetting1, div, null);
      append(div, t1);
      mount_component(checkboxsetting2, div, null);
      append(div, t2);
      append(div, h2);
      append(div, t4);
      append(div, p0);
      append(div, t6);
      append(div, p1);
      append(div, t8);
      mount_component(checkboxsetting3, div, null);
      append(div, t9);
      append(div, h30);
      append(div, t11);
      mount_component(checkboxsetting4, div, null);
      append(div, t12);
      mount_component(checkboxsetting5, div, null);
      append(div, t13);
      mount_component(checkboxsetting6, div, null);
      append(div, t14);
      append(div, h31);
      append(div, t16);
      mount_component(checkboxsetting7, div, null);
      append(div, t17);
      append(div, h32);
      append(div, t19);
      mount_component(checkboxsetting8, div, null);
      append(div, t20);
      mount_component(checkboxsetting9, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkboxsetting0_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        checkboxsetting0_changes.value = /*$context*/
        ctx2[0].settings.permanentlyUnlockCharacterSheetForGm;
        add_flush_callback(() => updating_value = false);
      }
      checkboxsetting0.$set(checkboxsetting0_changes);
      const checkboxsetting1_changes = {};
      if (!updating_value_1 && dirty & /*$context*/
      1) {
        updating_value_1 = true;
        checkboxsetting1_changes.value = /*$context*/
        ctx2[0].settings.permanentlyUnlockNpcSheetForGm;
        add_flush_callback(() => updating_value_1 = false);
      }
      checkboxsetting1.$set(checkboxsetting1_changes);
      const checkboxsetting2_changes = {};
      if (!updating_value_2 && dirty & /*$context*/
      1) {
        updating_value_2 = true;
        checkboxsetting2_changes.value = /*$context*/
        ctx2[0].settings.permanentlyUnlockVehicleSheetForGm;
        add_flush_callback(() => updating_value_2 = false);
      }
      checkboxsetting2.$set(checkboxsetting2_changes);
      const checkboxsetting3_changes = {};
      if (!updating_value_3 && dirty & /*$context*/
      1) {
        updating_value_3 = true;
        checkboxsetting3_changes.value = /*$context*/
        ctx2[0].settings.useTotalSheetLock;
        add_flush_callback(() => updating_value_3 = false);
      }
      checkboxsetting3.$set(checkboxsetting3_changes);
      const checkboxsetting4_changes = {};
      if (!updating_value_4 && dirty & /*$context*/
      1) {
        updating_value_4 = true;
        checkboxsetting4_changes.value = /*$context*/
        ctx2[0].settings.lockExpChanges;
        add_flush_callback(() => updating_value_4 = false);
      }
      checkboxsetting4.$set(checkboxsetting4_changes);
      const checkboxsetting5_changes = {};
      if (!updating_value_5 && dirty & /*$context*/
      1) {
        updating_value_5 = true;
        checkboxsetting5_changes.value = /*$context*/
        ctx2[0].settings.lockHpMaxChanges;
        add_flush_callback(() => updating_value_5 = false);
      }
      checkboxsetting5.$set(checkboxsetting5_changes);
      const checkboxsetting6_changes = {};
      if (!updating_value_6 && dirty & /*$context*/
      1) {
        updating_value_6 = true;
        checkboxsetting6_changes.value = /*$context*/
        ctx2[0].settings.lockConfigureSheet;
        add_flush_callback(() => updating_value_6 = false);
      }
      checkboxsetting6.$set(checkboxsetting6_changes);
      const checkboxsetting7_changes = {};
      if (!updating_value_7 && dirty & /*$context*/
      1) {
        updating_value_7 = true;
        checkboxsetting7_changes.value = /*$context*/
        ctx2[0].settings.lockMoneyChanges;
        add_flush_callback(() => updating_value_7 = false);
      }
      checkboxsetting7.$set(checkboxsetting7_changes);
      const checkboxsetting8_changes = {};
      if (!updating_value_8 && dirty & /*$context*/
      1) {
        updating_value_8 = true;
        checkboxsetting8_changes.value = /*$context*/
        ctx2[0].settings.lockLevelSelector;
        add_flush_callback(() => updating_value_8 = false);
      }
      checkboxsetting8.$set(checkboxsetting8_changes);
      const checkboxsetting9_changes = {};
      if (!updating_value_9 && dirty & /*$context*/
      1) {
        updating_value_9 = true;
        checkboxsetting9_changes.value = /*$context*/
        ctx2[0].settings.lockItemQuantity;
        add_flush_callback(() => updating_value_9 = false);
      }
      checkboxsetting9.$set(checkboxsetting9_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkboxsetting0.$$.fragment, local);
      transition_in(checkboxsetting1.$$.fragment, local);
      transition_in(checkboxsetting2.$$.fragment, local);
      transition_in(checkboxsetting3.$$.fragment, local);
      transition_in(checkboxsetting4.$$.fragment, local);
      transition_in(checkboxsetting5.$$.fragment, local);
      transition_in(checkboxsetting6.$$.fragment, local);
      transition_in(checkboxsetting7.$$.fragment, local);
      transition_in(checkboxsetting8.$$.fragment, local);
      transition_in(checkboxsetting9.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxsetting0.$$.fragment, local);
      transition_out(checkboxsetting1.$$.fragment, local);
      transition_out(checkboxsetting2.$$.fragment, local);
      transition_out(checkboxsetting3.$$.fragment, local);
      transition_out(checkboxsetting4.$$.fragment, local);
      transition_out(checkboxsetting5.$$.fragment, local);
      transition_out(checkboxsetting6.$$.fragment, local);
      transition_out(checkboxsetting7.$$.fragment, local);
      transition_out(checkboxsetting8.$$.fragment, local);
      transition_out(checkboxsetting9.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(checkboxsetting0);
      destroy_component(checkboxsetting1);
      destroy_component(checkboxsetting2);
      destroy_component(checkboxsetting3);
      destroy_component(checkboxsetting4);
      destroy_component(checkboxsetting5);
      destroy_component(checkboxsetting6);
      destroy_component(checkboxsetting7);
      destroy_component(checkboxsetting8);
      destroy_component(checkboxsetting9);
    }
  };
}
function instance$41($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function checkboxsetting0_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.permanentlyUnlockCharacterSheetForGm, value)) {
      $context.settings.permanentlyUnlockCharacterSheetForGm = value;
      context.set($context);
    }
  }
  function checkboxsetting1_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.permanentlyUnlockNpcSheetForGm, value)) {
      $context.settings.permanentlyUnlockNpcSheetForGm = value;
      context.set($context);
    }
  }
  function checkboxsetting2_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.permanentlyUnlockVehicleSheetForGm, value)) {
      $context.settings.permanentlyUnlockVehicleSheetForGm = value;
      context.set($context);
    }
  }
  function checkboxsetting3_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useTotalSheetLock, value)) {
      $context.settings.useTotalSheetLock = value;
      context.set($context);
    }
  }
  function checkboxsetting4_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.lockExpChanges, value)) {
      $context.settings.lockExpChanges = value;
      context.set($context);
    }
  }
  function checkboxsetting5_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.lockHpMaxChanges, value)) {
      $context.settings.lockHpMaxChanges = value;
      context.set($context);
    }
  }
  function checkboxsetting6_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.lockConfigureSheet, value)) {
      $context.settings.lockConfigureSheet = value;
      context.set($context);
    }
  }
  function checkboxsetting7_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.lockMoneyChanges, value)) {
      $context.settings.lockMoneyChanges = value;
      context.set($context);
    }
  }
  function checkboxsetting8_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.lockLevelSelector, value)) {
      $context.settings.lockLevelSelector = value;
      context.set($context);
    }
  }
  function checkboxsetting9_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.lockItemQuantity, value)) {
      $context.settings.lockItemQuantity = value;
      context.set($context);
    }
  }
  return [
    $context,
    context,
    localize,
    checkboxsetting0_value_binding,
    checkboxsetting1_value_binding,
    checkboxsetting2_value_binding,
    checkboxsetting3_value_binding,
    checkboxsetting4_value_binding,
    checkboxsetting5_value_binding,
    checkboxsetting6_value_binding,
    checkboxsetting7_value_binding,
    checkboxsetting8_value_binding,
    checkboxsetting9_value_binding
  ];
}
class SheetLockWorldSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$41, create_fragment$42, safe_not_equal, {});
  }
}
function create_fragment$41(ctx) {
  let div;
  let checkboxsetting;
  let updating_value;
  let current;
  function checkboxsetting_value_binding(value) {
    ctx[2](value);
  }
  let checkboxsetting_props = {
    name: SettingsProvider.settings.useTidySpellSchoolIcons.options.name,
    hint: SettingsProvider.settings.useTidySpellSchoolIcons.options.hint,
    id: "useTidySpellSchoolIcons"
  };
  if (
    /*$context*/
    ctx[0].settings.useTidySpellSchoolIcons !== void 0
  ) {
    checkboxsetting_props.value = /*$context*/
    ctx[0].settings.useTidySpellSchoolIcons;
  }
  checkboxsetting = new CheckboxSetting({ props: checkboxsetting_props });
  binding_callbacks.push(() => bind(checkboxsetting, "value", checkboxsetting_value_binding));
  return {
    c() {
      div = element("div");
      create_component(checkboxsetting.$$.fragment);
      attr(div, "class", "settings-form");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkboxsetting, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkboxsetting_changes = {};
      if (!updating_value && dirty & /*$context*/
      1) {
        updating_value = true;
        checkboxsetting_changes.value = /*$context*/
        ctx2[0].settings.useTidySpellSchoolIcons;
        add_flush_callback(() => updating_value = false);
      }
      checkboxsetting.$set(checkboxsetting_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkboxsetting.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxsetting.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(checkboxsetting);
    }
  };
}
function instance$40($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  function checkboxsetting_value_binding(value) {
    if ($$self.$$.not_equal($context.settings.useTidySpellSchoolIcons, value)) {
      $context.settings.useTidySpellSchoolIcons = value;
      context.set($context);
    }
  }
  return [$context, context, checkboxsetting_value_binding];
}
class IconsWorldSettingsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$40, create_fragment$41, safe_not_equal, {});
  }
}
function create_fragment$40(ctx) {
  let div3;
  let div1;
  let tabs_1;
  let updating_selectedTabId;
  let t0;
  let div0;
  let t1;
  let tabcontents;
  let t2;
  let div2;
  let button0;
  let i0;
  let t3;
  let t4_value = (
    /*localize*/
    ctx[6]("TIDY5E.SaveChanges") + ""
  );
  let t4;
  let t5;
  let button1;
  let i1;
  let t6;
  let t7_value = (
    /*localize*/
    ctx[6]("TIDY5E.ApplyChanges") + ""
  );
  let t7;
  let current;
  let mounted;
  let dispose;
  function tabs_1_selectedTabId_binding(value) {
    ctx[7](value);
  }
  let tabs_1_props = {
    tabs: (
      /*tabs*/
      ctx[3]
    ),
    orientation: "vertical"
  };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_1_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "selectedTabId", tabs_1_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*tabs*/
        ctx[3]
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      ),
      cssClass: "tidy-sheet-body"
    }
  });
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      create_component(tabs_1.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = space();
      create_component(tabcontents.$$.fragment);
      t2 = space();
      div2 = element("div");
      button0 = element("button");
      i0 = element("i");
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      button1 = element("button");
      i1 = element("i");
      t6 = space();
      t7 = text(t7_value);
      attr(div0, "role", "presentation");
      attr(div0, "class", "remaining-vertical-space svelte-1ya24fr");
      attr(div1, "role", "presentation");
      attr(div1, "class", "vertical-tab-container flex-column no-gap svelte-1ya24fr");
      attr(i0, "class", "fas fa-save");
      attr(button0, "type", "button");
      attr(button0, "class", "save-changes-btn");
      button0.disabled = /*applyingChanges*/
      ctx[1];
      attr(i1, "class", "fas fa-check");
      attr(button1, "type", "button");
      attr(button1, "class", "apply-changes-btn");
      button1.disabled = /*applyingChanges*/
      ctx[1];
      attr(div2, "class", "button-bar svelte-1ya24fr");
      attr(div3, "class", "settings-form svelte-1ya24fr");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      mount_component(tabs_1, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div3, t1);
      mount_component(tabcontents, div3, null);
      append(div3, t2);
      append(div3, div2);
      append(div2, button0);
      append(button0, i0);
      append(button0, t3);
      append(button0, t4);
      append(div2, t5);
      append(div2, button1);
      append(button1, i1);
      append(button1, t6);
      append(button1, t7);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*save*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*apply*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const tabs_1_changes = {};
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_1_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabcontents_changes = {};
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
      if (!current || dirty & /*applyingChanges*/
      2) {
        button0.disabled = /*applyingChanges*/
        ctx2[1];
      }
      if (!current || dirty & /*applyingChanges*/
      2) {
        button1.disabled = /*applyingChanges*/
        ctx2[1];
      }
    },
    i(local) {
      if (current) return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(tabs_1);
      destroy_component(tabcontents);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3$($$self, $$props, $$invalidate) {
  let $context;
  let selectedTabId;
  let functions = getContext(CONSTANTS.SVELTE_CONTEXT.FUNCTIONS);
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(8, $context = value));
  let tabs = [
    {
      id: CONSTANTS.TAB_WORLD_SETTINGS_MISC,
      title: "TIDY5E.WorldSettings.TabMisc.tabLabel",
      content: {
        component: MiscWorldSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_WORLD_SETTINGS_CHARACTER,
      title: "TIDY5E.WorldSettings.TabCharacter.tabLabel",
      content: {
        component: CharacterWorldSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_WORLD_SETTINGS_NPC,
      title: "TIDY5E.WorldSettings.TabNpc.tabLabel",
      content: {
        component: NpcWorldSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_WORLD_SETTINGS_VEHICLE,
      title: "TIDY5E.WorldSettings.TabVehicle.tabLabel",
      content: {
        component: VehicleWorldSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_WORLD_SETTINGS_ITEM,
      title: "TIDY5E.WorldSettings.TabItem.tabLabel",
      content: {
        component: ItemWorldSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_WORLD_SETTINGS_EXHAUSTION,
      title: "TIDY5E.WorldSettings.TabExhaustion.tabLabel",
      content: {
        component: ExhaustionWorldSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_WORLD_SETTINGS_SHEETLOCK,
      title: "TIDY5E.WorldSettings.TabSheetLock.tabLabel",
      content: {
        component: SheetLockWorldSettingsTab,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_WORLD_SETTINGS_ICONS,
      title: "TIDY5E.WorldSettings.TabIcons.tabLabel",
      content: {
        component: IconsWorldSettingsTab,
        type: "svelte"
      }
    }
  ];
  selectedTabId ??= tabs[0].id;
  let applyingChanges = false;
  async function save() {
    $$invalidate(1, applyingChanges = true);
    try {
      await functions.save($context);
    } finally {
      $$invalidate(1, applyingChanges = false);
    }
  }
  async function apply() {
    $$invalidate(1, applyingChanges = true);
    try {
      await functions.apply($context);
    } finally {
      $$invalidate(1, applyingChanges = false);
    }
  }
  const localize = FoundryAdapter.localize;
  function tabs_1_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [
    selectedTabId,
    applyingChanges,
    context,
    tabs,
    save,
    apply,
    localize,
    tabs_1_selectedTabId_binding
  ];
}
class WorldSettings extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3$, create_fragment$40, safe_not_equal, {});
  }
}
function clickOutside(node) {
  function handleClick(e2) {
    if (e2.target instanceof Node && !node.contains(e2.target)) {
      node.dispatchEvent(new CustomEvent("outsideclick"));
    }
  }
  setTimeout(() => {
    window.addEventListener("click", handleClick);
  });
  return {
    destroy() {
      window.removeEventListener("click", handleClick);
    }
  };
}
function getPositionStyles(openerEl, menuEl, position, anchor, gap) {
  let styleObj = position === "bottom" ? getBottomPositionStyles(openerEl, menuEl) : position === "left" ? getLeftPositionStyles(openerEl, menuEl) : position === "top" ? getTopPositionStyles(openerEl, menuEl) : position === "right" ? getRightPositionStyles(openerEl, menuEl) : null;
  if (!styleObj) {
    return "";
  }
  if (anchor !== "center") {
    styleObj = anchorMenu(styleObj, anchor, openerEl, menuEl);
  }
  let styleString = Object.entries({ ...styleObj }).map((x2) => `${x2[0]}: ${x2[1]}px`).join("; ");
  const gapTransform = getGapTransform(position, gap);
  if (gapTransform) {
    styleString += `; transform: ${gapTransform}`;
  }
  return styleString;
}
function getBottomPositionStyles(openerEl, menuEl) {
  const openerCenterX = Math.ceil(
    openerEl.offsetLeft + Math.max(openerEl.offsetWidth, 1) / 2
  );
  return {
    left: Math.ceil(openerCenterX - menuEl.offsetWidth / 2),
    top: Math.ceil(openerEl.offsetTop + openerEl.offsetHeight)
  };
}
function getLeftPositionStyles(openerEl, menuEl) {
  const openerCenterY = Math.ceil(
    openerEl.offsetTop + Math.max(openerEl.offsetHeight, 1) / 2
  );
  return {
    left: Math.ceil(openerEl.offsetLeft - menuEl.offsetWidth),
    top: Math.ceil(openerCenterY - menuEl.offsetHeight / 2)
  };
}
function getRightPositionStyles(openerEl, menuEl) {
  const openerCenterY = Math.ceil(
    openerEl.offsetTop + Math.max(openerEl.offsetHeight, 1) / 2
  );
  return {
    left: Math.ceil(openerEl.offsetLeft + openerEl.offsetWidth),
    top: Math.ceil(openerCenterY - menuEl.offsetHeight / 2)
  };
}
function getTopPositionStyles(openerEl, menuEl) {
  const openerCenterX = Math.ceil(
    openerEl.offsetLeft + Math.max(openerEl.offsetWidth, 1) / 2
  );
  return {
    left: Math.ceil(openerCenterX - menuEl.offsetWidth / 2),
    top: Math.ceil(openerEl.offsetTop - menuEl.offsetHeight)
  };
}
function anchorMenu(styleObj, anchor, openerEl, menuEl) {
  switch (anchor) {
    case "top":
      styleObj.top = openerEl.offsetTop;
      break;
    case "right":
      const anchoredMenuLeftPixels = openerEl.offsetLeft + openerEl.offsetWidth - menuEl.offsetWidth;
      styleObj.left = anchoredMenuLeftPixels;
      break;
    case "bottom":
      const anchoredMenuTopPixels = openerEl.offsetTop + openerEl.offsetHeight - menuEl.offsetHeight;
      styleObj.top = anchoredMenuTopPixels;
      break;
    case "left":
      styleObj.left = openerEl.offsetLeft;
      break;
  }
  return styleObj;
}
function getGapTransform(position, gap) {
  const translation = position === "top" ? `translateY(-${gap})` : position === "right" ? `translateX(${gap})` : position === "bottom" ? `translateY(${gap})` : position === "left" ? `translateX(-${gap})` : null;
  if (translation && gap) {
    return translation;
  }
  return null;
}
function create_if_block_1$15(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(
        i2,
        "class",
        /*actualIconClass*/
        ctx[12]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*actualIconClass*/
      4096) {
        attr(
          i2,
          "class",
          /*actualIconClass*/
          ctx2[12]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block$1P(ctx) {
  let previous_tag = (
    /*menuElement*/
    ctx[9]
  );
  let svelte_element_anchor;
  let current;
  let svelte_element = (
    /*menuElement*/
    ctx[9] && create_dynamic_element$2(ctx)
  );
  return {
    c() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*menuElement*/
        ctx2[9]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element$2(ctx2);
          previous_tag = /*menuElement*/
          ctx2[9];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*menuElement*/
          ctx2[9]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element$2(ctx2);
          previous_tag = /*menuElement*/
          ctx2[9];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*menuElement*/
        ctx2[9];
      }
    },
    i(local) {
      if (current) return;
      transition_in(svelte_element, local);
      current = true;
    },
    o(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
}
function create_dynamic_element$2(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = "button-menu-list " + /*listClass*/
      (ctx[4] ?? "")
    },
    { style: (
      /*menuStyles*/
      ctx[11]
    ) }
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  return {
    c() {
      svelte_element = element(
        /*menuElement*/
        ctx[9]
      );
      if (default_slot) default_slot.c();
      set_dynamic_element_data(
        /*menuElement*/
        ctx[9]
      )(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(clickOutside.call(null, svelte_element)),
          listen(
            svelte_element,
            "outsideclick",
            /*outsideclick_handler*/
            ctx[23]
          ),
          action_destroyer(
            /*positionMenu*/
            ctx[15].call(null, svelte_element)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*menuElement*/
        ctx2[9]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*listClass*/
        16 && svelte_element_class_value !== (svelte_element_class_value = "button-menu-list " + /*listClass*/
        (ctx2[4] ?? ""))) && { class: svelte_element_class_value },
        (!current || dirty & /*menuStyles*/
        2048) && { style: (
          /*menuStyles*/
          ctx2[11]
        ) }
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$3$(ctx) {
  let div;
  let button;
  let t0;
  let t1;
  let button_class_value;
  let button_tabindex_value;
  let t2;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*iconClass*/
    ctx[2] && create_if_block_1$15(ctx)
  );
  let if_block1 = (
    /*open*/
    ctx[0] && create_if_block$1P(ctx)
  );
  return {
    c() {
      div = element("div");
      button = element("button");
      if (if_block0) if_block0.c();
      t0 = space();
      t1 = text(
        /*buttonText*/
        ctx[1]
      );
      t2 = space();
      if (if_block1) if_block1.c();
      attr(button, "type", "button");
      attr(
        button,
        "aria-label",
        /*ariaLabel*/
        ctx[7]
      );
      attr(
        button,
        "title",
        /*title*/
        ctx[8]
      );
      attr(button, "class", button_class_value = "button-menu-opener " + /*buttonClass*/
      (ctx[5] ?? ""));
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[13].useAccessibleKeyboardSupport ? 0 : -1);
      set_style(
        button,
        "padding",
        /*openerPadding*/
        ctx[6]
      );
      attr(div, "class", div_class_value = "button-menu-wrapper " + /*wrapperClass*/
      (ctx[3] ?? ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (if_block0) if_block0.m(button, null);
      append(button, t0);
      append(button, t1);
      ctx[22](button);
      append(div, t2);
      if (if_block1) if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[21]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*iconClass*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$15(ctx2);
          if_block0.c();
          if_block0.m(button, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*buttonText*/
      2) set_data(
        t1,
        /*buttonText*/
        ctx2[1]
      );
      if (!current || dirty & /*ariaLabel*/
      128) {
        attr(
          button,
          "aria-label",
          /*ariaLabel*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*title*/
      256) {
        attr(
          button,
          "title",
          /*title*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*buttonClass*/
      32 && button_class_value !== (button_class_value = "button-menu-opener " + /*buttonClass*/
      (ctx2[5] ?? ""))) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*$settingStore*/
      8192 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[13].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*openerPadding*/
      64) {
        set_style(
          button,
          "padding",
          /*openerPadding*/
          ctx2[6]
        );
      }
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1P(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*wrapperClass*/
      8 && div_class_value !== (div_class_value = "button-menu-wrapper " + /*wrapperClass*/
      (ctx2[3] ?? ""))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      ctx[22](null);
      if (if_block1) if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$3_($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(13, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { open = false } = $$props;
  let { buttonText = "" } = $$props;
  let { iconClass = null } = $$props;
  let { wrapperClass = null } = $$props;
  let { listClass = null } = $$props;
  let { buttonClass = null } = $$props;
  let { openerPadding = null } = $$props;
  let { ariaLabel = null } = $$props;
  let { title = null } = $$props;
  let { gap = "0.25rem" } = $$props;
  let { position = "bottom" } = $$props;
  let { anchor = "center" } = $$props;
  let { menuElement = "ul" } = $$props;
  let openerEl;
  let menuStyles = "";
  setContext(CONSTANTS.SVELTE_CONTEXT.BUTTON_MENU_CONTEXT, { close });
  function close() {
    $$invalidate(0, open = false);
  }
  function positionMenu(menuEl) {
    $$invalidate(11, menuStyles = getPositionStyles(openerEl, menuEl, position, anchor, gap));
  }
  let actualIconClass;
  const click_handler = () => $$invalidate(0, open = !open);
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      openerEl = $$value;
      $$invalidate(10, openerEl);
    });
  }
  const outsideclick_handler = () => close();
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2) $$invalidate(0, open = $$props2.open);
    if ("buttonText" in $$props2) $$invalidate(1, buttonText = $$props2.buttonText);
    if ("iconClass" in $$props2) $$invalidate(2, iconClass = $$props2.iconClass);
    if ("wrapperClass" in $$props2) $$invalidate(3, wrapperClass = $$props2.wrapperClass);
    if ("listClass" in $$props2) $$invalidate(4, listClass = $$props2.listClass);
    if ("buttonClass" in $$props2) $$invalidate(5, buttonClass = $$props2.buttonClass);
    if ("openerPadding" in $$props2) $$invalidate(6, openerPadding = $$props2.openerPadding);
    if ("ariaLabel" in $$props2) $$invalidate(7, ariaLabel = $$props2.ariaLabel);
    if ("title" in $$props2) $$invalidate(8, title = $$props2.title);
    if ("gap" in $$props2) $$invalidate(16, gap = $$props2.gap);
    if ("position" in $$props2) $$invalidate(17, position = $$props2.position);
    if ("anchor" in $$props2) $$invalidate(18, anchor = $$props2.anchor);
    if ("menuElement" in $$props2) $$invalidate(9, menuElement = $$props2.menuElement);
    if ("$$scope" in $$props2) $$invalidate(19, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*iconClass, open*/
    5) {
      {
        if (iconClass !== null) {
          if (typeof iconClass === "string") {
            $$invalidate(12, actualIconClass = iconClass);
          } else {
            let potentialClass = open ? iconClass.opened : iconClass.closed;
            potentialClass ??= iconClass.opened ?? iconClass.closed;
            $$invalidate(12, actualIconClass = potentialClass);
          }
        }
      }
    }
  };
  return [
    open,
    buttonText,
    iconClass,
    wrapperClass,
    listClass,
    buttonClass,
    openerPadding,
    ariaLabel,
    title,
    menuElement,
    openerEl,
    menuStyles,
    actualIconClass,
    $settingStore,
    close,
    positionMenu,
    gap,
    position,
    anchor,
    $$scope,
    slots,
    click_handler,
    button_binding,
    outsideclick_handler
  ];
}
class ButtonMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3_, create_fragment$3$, safe_not_equal, {
      open: 0,
      buttonText: 1,
      iconClass: 2,
      wrapperClass: 3,
      listClass: 4,
      buttonClass: 5,
      openerPadding: 6,
      ariaLabel: 7,
      title: 8,
      gap: 16,
      position: 17,
      anchor: 18,
      menuElement: 9
    });
  }
}
function create_fragment$3_(ctx) {
  let li;
  let li_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      li = element("li");
      if (default_slot) default_slot.c();
      attr(li, "class", li_class_value = "button-menu-item " + /*cssClass*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cssClass*/
      1 && li_class_value !== (li_class_value = "button-menu-item " + /*cssClass*/
      ctx2[0])) {
        attr(li, "class", li_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$3Z($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { cssClass = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [cssClass, $$scope, slots];
}
class ButtonMenuItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Z, create_fragment$3_, safe_not_equal, { cssClass: 0 });
  }
}
function create_if_block$1O(ctx) {
  let span;
  let if_block = (
    /*iconClass*/
    ctx[0] && create_if_block_1$14(ctx)
  );
  return {
    c() {
      span = element("span");
      if (if_block) if_block.c();
      attr(span, "class", "icon-container");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block) if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (
        /*iconClass*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$14(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block) if_block.d();
    }
  };
}
function create_if_block_1$14(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(
        i2,
        "class",
        /*iconClass*/
        ctx[0]
      );
      attr(i2, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconClass*/
      1) {
        attr(
          i2,
          "class",
          /*iconClass*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot$1u(ctx) {
  let button;
  let t2;
  let span;
  let button_class_value;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*useIconColumn*/
    ctx[1] && create_if_block$1O(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  return {
    c() {
      button = element("button");
      if (if_block) if_block.c();
      t2 = space();
      span = element("span");
      if (default_slot) default_slot.c();
      attr(span, "class", "command-text");
      attr(button, "type", "button");
      attr(button, "class", button_class_value = "button-menu-command " + /*size*/
      ctx[3]);
      attr(
        button,
        "title",
        /*title*/
        ctx[2]
      );
      button.disabled = /*disabled*/
      ctx[4];
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block) if_block.m(button, null);
      append(button, t2);
      append(button, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleClick*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*useIconColumn*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1O(ctx2);
          if_block.c();
          if_block.m(button, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*size*/
      8 && button_class_value !== (button_class_value = "button-menu-command " + /*size*/
      ctx2[3])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*title*/
      4) {
        attr(
          button,
          "title",
          /*title*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled*/
      16) {
        button.disabled = /*disabled*/
        ctx2[4];
      }
      if (!current || dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3Z(ctx) {
  let buttonmenuitem;
  let current;
  buttonmenuitem = new ButtonMenuItem({
    props: {
      cssClass: "button-menu-command-li",
      $$slots: { default: [create_default_slot$1u] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(buttonmenuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenuitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const buttonmenuitem_changes = {};
      if (dirty & /*$$scope, size, title, disabled, $settingStore, iconClass, useIconColumn*/
      319) {
        buttonmenuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenuitem.$set(buttonmenuitem_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenuitem, detaching);
    }
  };
}
function instance$3Y($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { iconClass = "" } = $$props;
  let { useIconColumn = true } = $$props;
  let { title = null } = $$props;
  let { size = "standard" } = $$props;
  let { disabled = false } = $$props;
  const buttonMenuContext = getContext(CONSTANTS.SVELTE_CONTEXT.BUTTON_MENU_CONTEXT);
  const dispatch2 = createEventDispatcher();
  function handleClick(event) {
    buttonMenuContext.close();
    dispatch2("click", { event });
  }
  $$self.$$set = ($$props2) => {
    if ("iconClass" in $$props2) $$invalidate(0, iconClass = $$props2.iconClass);
    if ("useIconColumn" in $$props2) $$invalidate(1, useIconColumn = $$props2.useIconColumn);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("size" in $$props2) $$invalidate(3, size = $$props2.size);
    if ("disabled" in $$props2) $$invalidate(4, disabled = $$props2.disabled);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    iconClass,
    useIconColumn,
    title,
    size,
    disabled,
    $settingStore,
    handleClick,
    slots,
    $$scope
  ];
}
class ButtonMenuCommand extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Y, create_fragment$3Z, safe_not_equal, {
      iconClass: 0,
      useIconColumn: 1,
      title: 2,
      size: 3,
      disabled: 4
    });
  }
}
function get_each_context$15(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_default_slot_1$Q(ctx) {
  let t0_value = (
    /*option*/
    ctx[8].text + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      1 && t0_value !== (t0_value = /*option*/
      ctx2[8].text + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block$15(ctx) {
  let buttonmenucommand;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[6](
        /*option*/
        ctx[8]
      )
    );
  }
  buttonmenucommand = new ButtonMenuCommand({
    props: {
      useIconColumn: false,
      size: "compact",
      $$slots: { default: [create_default_slot_1$Q] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand.$on("click", click_handler);
  return {
    c() {
      create_component(buttonmenucommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenucommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const buttonmenucommand_changes = {};
      if (dirty & /*$$scope, options*/
      2049) {
        buttonmenucommand_changes.$$scope = { dirty, ctx };
      }
      buttonmenucommand.$set(buttonmenucommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenucommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenucommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenucommand, detaching);
    }
  };
}
function create_default_slot$1t(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$15(get_each_context$15(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*optionClicked, options*/
      17) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$15(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$15(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$3Y(ctx) {
  let buttonmenu;
  let current;
  buttonmenu = new ButtonMenu({
    props: {
      position: "bottom",
      ariaLabel: (
        /*title*/
        ctx[2]
      ),
      title: (
        /*title*/
        ctx[2]
      ),
      buttonText: (
        /*selected*/
        ctx[1].text
      ),
      buttonClass: "inline-transparent-button primary " + /*buttonClass*/
      ctx[3],
      $$slots: { default: [create_default_slot$1t] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(buttonmenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const buttonmenu_changes = {};
      if (dirty & /*title*/
      4) buttonmenu_changes.ariaLabel = /*title*/
      ctx2[2];
      if (dirty & /*title*/
      4) buttonmenu_changes.title = /*title*/
      ctx2[2];
      if (dirty & /*selected*/
      2) buttonmenu_changes.buttonText = /*selected*/
      ctx2[1].text;
      if (dirty & /*buttonClass*/
      8) buttonmenu_changes.buttonClass = "inline-transparent-button primary " + /*buttonClass*/
      ctx2[3];
      if (dirty & /*$$scope, options*/
      2049) {
        buttonmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenu.$set(buttonmenu_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenu, detaching);
    }
  };
}
function instance$3X($$self, $$props, $$invalidate) {
  let { options } = $$props;
  let { selected } = $$props;
  let { isOpen = false } = $$props;
  let { title = null } = $$props;
  let { buttonClass = "" } = $$props;
  const dispatch2 = createEventDispatcher();
  function optionClicked(selection) {
    dispatch2("optionClicked", { ...selection });
    $$invalidate(5, isOpen = false);
  }
  const click_handler = (option) => optionClicked(option);
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2) $$invalidate(0, options = $$props2.options);
    if ("selected" in $$props2) $$invalidate(1, selected = $$props2.selected);
    if ("isOpen" in $$props2) $$invalidate(5, isOpen = $$props2.isOpen);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("buttonClass" in $$props2) $$invalidate(3, buttonClass = $$props2.buttonClass);
  };
  return [options, selected, title, buttonClass, optionClicked, isOpen, click_handler];
}
class InlineTextDropdownList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3X, create_fragment$3Y, safe_not_equal, {
      options: 0,
      selected: 1,
      isOpen: 5,
      title: 2,
      buttonClass: 3
    });
  }
}
const nilValues = [null, void 0];
function isNil(value, ...or) {
  return nilValues.concat(or ?? []).includes(value);
}
function camelToLowerDashCase(str) {
  if (str != str.toLowerCase()) {
    str = str.replace(/[A-Z]/g, (m2) => "-" + m2.toLowerCase());
  }
  return str;
}
function buildDataset(obj) {
  if (!obj) {
    return {};
  }
  return Object.entries(obj).reduce(
    (acc, [key, value]) => {
      acc[`data-${camelToLowerDashCase(key)}`] = value;
      return acc;
    },
    {}
  );
}
class ActiveEffectsHelper {
  static isActiveEffectAppliedToField(document2, field) {
    try {
      return document2?.overrides && !isNil(field) && foundry.utils.getProperty(document2.overrides, field);
    } catch (e2) {
      error(
        "An error occurred while checking if a field has an active effect applied",
        false,
        e2
      );
      debug("Active effect error troubleshooting info", { document: document2, field });
      return false;
    }
  }
}
function formatAsModifier(value) {
  if (value === null || value === void 0) {
    return toSignedNumberString(0);
  }
  const parsed = typeof value === "string" ? +value : value;
  if (isNaN(parsed)) {
    return toSignedNumberString(0);
  }
  return toSignedNumberString(parsed);
}
function toSignedNumberString(value) {
  return value.toLocaleString(FoundryAdapter.getCurrentLang(), { signDisplay: "always" });
}
function coalesce(...values) {
  for (let value of values) {
    if (!isNil(value?.trim(), "")) {
      return value;
    }
  }
  return "";
}
function get_each_context$14(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  const constants_0 = (
    /*skillRef*/
    child_ctx[19].skill && /*showAllSkills*/
    (child_ctx[4] || /*skillRef*/
    child_ctx[19].skill.value > 0)
  );
  child_ctx[20] = constants_0;
  return child_ctx;
}
function get_if_ctx$i(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = ActiveEffectsHelper.isActiveEffectAppliedToField(
    /*$context*/
    child_ctx[1].actor,
    `system.skills.${/*skillRef*/
    child_ctx[19].key}.value`
  );
  child_ctx[23] = constants_0;
  return child_ctx;
}
function create_if_block_2$S(ctx) {
  let li;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block2;
  let t2;
  let span0;
  let t3_value = formatAsModifier(
    /*skillRef*/
    ctx[19].skill.total
  ) + "";
  let t3;
  let t4;
  let span1;
  let t5;
  let t6_value = (
    /*skillRef*/
    ctx[19].skill.passive + ""
  );
  let t6;
  let t7;
  let span1_title_value;
  let t8;
  let li_data_key_value;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].editable && /*$context*/
      ctx2[1].unlocked
    ) return create_if_block_5$q;
    return create_else_block_3$3;
  }
  function select_block_ctx(ctx2, type) {
    if (type === create_if_block_5$q) return get_if_ctx$i(ctx2);
    return ctx2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(select_block_ctx(ctx, current_block_type));
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].editable
    ) return create_if_block_4$u;
    return create_else_block_2$5;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block1 = current_block_type_1(ctx);
  const if_block_creators = [create_if_block_3$F, create_else_block_1$h];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].unlocked && /*$context*/
      ctx2[1].editable
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      li = element("li");
      if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if_block2.c();
      t2 = space();
      span0 = element("span");
      t3 = text(t3_value);
      t4 = space();
      span1 = element("span");
      t5 = text("(");
      t6 = text(t6_value);
      t7 = text(")");
      t8 = space();
      attr(span0, "class", "skill-mod svelte-tmgyvr");
      attr(span1, "class", "skill-passive svelte-tmgyvr");
      attr(span1, "title", span1_title_value = /*skillRef*/
      ctx[19].skill.label + " (" + /*localize*/
      ctx[7]("DND5E.Passive") + ")");
      attr(li, "class", "proficiency-row skill svelte-tmgyvr");
      attr(li, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SKILL_CONTAINER);
      attr(li, "data-key", li_data_key_value = /*skillRef*/
      ctx[19].key);
      toggle_class(
        li,
        "proficient",
        /*skillRef*/
        ctx[19].skill.value
      );
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if_block0.m(li, null);
      append(li, t0);
      if_block1.m(li, null);
      append(li, t1);
      if_blocks[current_block_type_index].m(li, null);
      append(li, t2);
      append(li, span0);
      append(span0, t3);
      append(li, t4);
      append(li, span1);
      append(span1, t5);
      append(span1, t6);
      append(span1, t7);
      append(li, t8);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(select_block_ctx(ctx2, current_block_type), dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(select_block_ctx(ctx2, current_block_type));
        if (if_block0) {
          if_block0.c();
          if_block0.m(li, t0);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(li, t1);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(li, t2);
      }
      if ((!current || dirty & /*skillRefs*/
      4) && t3_value !== (t3_value = formatAsModifier(
        /*skillRef*/
        ctx2[19].skill.total
      ) + "")) set_data(t3, t3_value);
      if ((!current || dirty & /*skillRefs*/
      4) && t6_value !== (t6_value = /*skillRef*/
      ctx2[19].skill.passive + "")) set_data(t6, t6_value);
      if (!current || dirty & /*skillRefs*/
      4 && span1_title_value !== (span1_title_value = /*skillRef*/
      ctx2[19].skill.label + " (" + /*localize*/
      ctx2[7]("DND5E.Passive") + ")")) {
        attr(span1, "title", span1_title_value);
      }
      if (!current || dirty & /*skillRefs*/
      4 && li_data_key_value !== (li_data_key_value = /*skillRef*/
      ctx2[19].key)) {
        attr(li, "data-key", li_data_key_value);
      }
      if (!current || dirty & /*skillRefs*/
      4) {
        toggle_class(
          li,
          "proficient",
          /*skillRef*/
          ctx2[19].skill.value
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if_block0.d();
      if_block1.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block_3$3(ctx) {
  let span;
  let raw_value = (
    /*skillRef*/
    ctx[19].skill.icon + ""
  );
  let span_title_value;
  return {
    c() {
      span = element("span");
      attr(span, "class", "skill-proficiency svelte-tmgyvr");
      attr(span, "title", span_title_value = /*skillRef*/
      ctx[19].skill.hover);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & /*skillRefs*/
      4 && raw_value !== (raw_value = /*skillRef*/
      ctx2[19].skill.icon + "")) span.innerHTML = raw_value;
      if (dirty & /*skillRefs*/
      4 && span_title_value !== (span_title_value = /*skillRef*/
      ctx2[19].skill.hover)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_5$q(ctx) {
  let button0;
  let i2;
  let button0_tabindex_value;
  let t2;
  let button1;
  let raw_value = (
    /*skillRef*/
    ctx[19].skill.icon + ""
  );
  let button1_title_value;
  let button1_tabindex_value;
  let button1_disabled_value;
  let button1_data_tooltip_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[13](
        /*skillRef*/
        ctx[19]
      )
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[14](
        /*skillRef*/
        ctx[19]
      )
    );
  }
  function contextmenu_handler() {
    return (
      /*contextmenu_handler*/
      ctx[15](
        /*skillRef*/
        ctx[19]
      )
    );
  }
  return {
    c() {
      button0 = element("button");
      i2 = element("i");
      t2 = space();
      button1 = element("button");
      attr(i2, "class", "fas fa-cog svelte-tmgyvr");
      attr(button0, "type", "button");
      attr(button0, "class", "configure-proficiency inline-icon-button svelte-tmgyvr");
      attr(
        button0,
        "title",
        /*localize*/
        ctx[7]("DND5E.SkillConfigure")
      );
      attr(button0, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SKILL_CONFIGURATION_CONTROL);
      attr(button0, "tabindex", button0_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button1, "type", "button");
      attr(button1, "class", "skill-proficiency-toggle inline-icon-button svelte-tmgyvr");
      attr(button1, "title", button1_title_value = /*skillRef*/
      ctx[19].skill.hover);
      attr(button1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SKILL_PROFICIENCY_TOGGLE);
      attr(button1, "tabindex", button1_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      button1.disabled = button1_disabled_value = /*activeEffectApplied*/
      ctx[23];
      attr(button1, "data-tooltip", button1_data_tooltip_value = /*activeEffectApplied*/
      ctx[23] ? (
        /*localize*/
        ctx[7]("DND5E.ActiveEffectOverrideWarning")
      ) : null);
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, i2);
      insert(target, t2, anchor);
      insert(target, button1, anchor);
      button1.innerHTML = raw_value;
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler),
          listen(button1, "click", click_handler_1),
          listen(button1, "contextmenu", contextmenu_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$settingStore*/
      32 && button0_tabindex_value !== (button0_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button0, "tabindex", button0_tabindex_value);
      }
      if (dirty & /*skillRefs*/
      4 && raw_value !== (raw_value = /*skillRef*/
      ctx[19].skill.icon + "")) button1.innerHTML = raw_value;
      if (dirty & /*skillRefs*/
      4 && button1_title_value !== (button1_title_value = /*skillRef*/
      ctx[19].skill.hover)) {
        attr(button1, "title", button1_title_value);
      }
      if (dirty & /*$settingStore*/
      32 && button1_tabindex_value !== (button1_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button1, "tabindex", button1_tabindex_value);
      }
      if (dirty & /*$context, skillRefs*/
      6 && button1_disabled_value !== (button1_disabled_value = /*activeEffectApplied*/
      ctx[23])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$context, skillRefs*/
      6 && button1_data_tooltip_value !== (button1_data_tooltip_value = /*activeEffectApplied*/
      ctx[23] ? (
        /*localize*/
        ctx[7]("DND5E.ActiveEffectOverrideWarning")
      ) : null)) {
        attr(button1, "data-tooltip", button1_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t2);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_2$5(ctx) {
  let span;
  let t_value = (
    /*skillRef*/
    ctx[19].skill.label + ""
  );
  let t2;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "tidy5e-skill-name svelte-tmgyvr");
      attr(span, "title", span_title_value = /*skillRef*/
      ctx[19].skill.label);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*skillRefs*/
      4 && t_value !== (t_value = /*skillRef*/
      ctx2[19].skill.label + "")) set_data(t2, t_value);
      if (dirty & /*skillRefs*/
      4 && span_title_value !== (span_title_value = /*skillRef*/
      ctx2[19].skill.label)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_4$u(ctx) {
  let button;
  let t_value = (
    /*skillRef*/
    ctx[19].skill.label + ""
  );
  let t2;
  let button_tabindex_value;
  let button_title_value;
  let mounted;
  let dispose;
  function click_handler_2(...args) {
    return (
      /*click_handler_2*/
      ctx[16](
        /*skillRef*/
        ctx[19],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "tidy5e-skill-name transparent-button rollable svelte-tmgyvr");
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SKILL_ROLLER);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "title", button_title_value = /*skillRef*/
      ctx[19].skill.label);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*skillRefs*/
      4 && t_value !== (t_value = /*skillRef*/
      ctx[19].skill.label + "")) set_data(t2, t_value);
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*skillRefs*/
      4 && button_title_value !== (button_title_value = /*skillRef*/
      ctx[19].skill.label)) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1$h(ctx) {
  let span;
  let t_value = (
    /*skillRef*/
    ctx[19].skill.abbreviation + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "skill-ability");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*skillRefs*/
      4 && t_value !== (t_value = /*skillRef*/
      ctx2[19].skill.abbreviation + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3$F(ctx) {
  let inlinetextdropdownlist;
  let current;
  function optionClicked_handler(...args) {
    return (
      /*optionClicked_handler*/
      ctx[17](
        /*skillRef*/
        ctx[19],
        ...args
      )
    );
  }
  inlinetextdropdownlist = new InlineTextDropdownList({
    props: {
      options: (
        /*abilities*/
        ctx[3]
      ),
      selected: {
        text: (
          /*skillRef*/
          ctx[19].skill.abbreviation
        ),
        value: (
          /*skillRef*/
          ctx[19].skill.abbreviation
        )
      },
      buttonClass: "skill-ability",
      title: (
        /*$context*/
        ctx[1].abilities?.[
          /*skillRef*/
          ctx[19].ability
        ]?.label
      )
    }
  });
  inlinetextdropdownlist.$on("optionClicked", optionClicked_handler);
  return {
    c() {
      create_component(inlinetextdropdownlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinetextdropdownlist, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inlinetextdropdownlist_changes = {};
      if (dirty & /*abilities*/
      8) inlinetextdropdownlist_changes.options = /*abilities*/
      ctx[3];
      if (dirty & /*skillRefs*/
      4) inlinetextdropdownlist_changes.selected = {
        text: (
          /*skillRef*/
          ctx[19].skill.abbreviation
        ),
        value: (
          /*skillRef*/
          ctx[19].skill.abbreviation
        )
      };
      if (dirty & /*$context, skillRefs*/
      6) inlinetextdropdownlist_changes.title = /*$context*/
      ctx[1].abilities?.[
        /*skillRef*/
        ctx[19].ability
      ]?.label;
      inlinetextdropdownlist.$set(inlinetextdropdownlist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinetextdropdownlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetextdropdownlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetextdropdownlist, detaching);
    }
  };
}
function create_each_block$14(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*showSkill*/
    ctx[20] && create_if_block_2$S(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*showSkill*/
        ctx[20]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*skillRefs, showAllSkills*/
          20) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$S(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block$1N(ctx) {
  let div;
  let button;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function select_block_type_3(ctx2, dirty) {
    if (
      /*showAllSkills*/
      ctx2[4]
    ) return create_if_block_1$13;
    return create_else_block$$;
  }
  let current_block_type = select_block_type_3(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      if_block.c();
      attr(button, "type", "button");
      attr(button, "class", "toggle-proficient inline-transparent-button svelte-tmgyvr");
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SKILLS_SHOW_PROFICIENT_TOGGLE);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      set_style(div, "text-align", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleShowAllSkills*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$$(ctx) {
  let t_value = (
    /*localize*/
    ctx[7]("TIDY5E.ShowNotProficientSkills") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$13(ctx) {
  let t_value = (
    /*localize*/
    ctx[7]("TIDY5E.HideNotProficientSkills") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$3X(ctx) {
  let div;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let current;
  let each_value = ensure_array_like(
    /*skillRefs*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*skillRef*/
    ctx2[19].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$14(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$14(key, child_ctx));
  }
  let if_block = (
    /*toggleable*/
    ctx[0] && create_if_block$1N(ctx)
  );
  return {
    c() {
      div = element("div");
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      attr(ul, "class", "skills-list svelte-tmgyvr");
      attr(ul, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SKILLS_LIST);
      attr(div, "class", "skills-list-container svelte-tmgyvr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      append(div, t2);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*skillRefs, localize, abilities, $context, onSkillAbilityChange, $settingStore, showAllSkills*/
      702) {
        each_value = ensure_array_like(
          /*skillRefs*/
          ctx2[2]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$14, null, get_each_context$14);
        check_outros();
      }
      if (
        /*toggleable*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1N(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block) if_block.d();
    }
  };
}
function instance$3W($$self, $$props, $$invalidate) {
  let showAllSkills;
  let abilities;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { toggleable = false } = $$props;
  let { actor } = $$props;
  let { expanded = true } = $$props;
  let { toggleField = null } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let skillRefs;
  const localize = FoundryAdapter.localize;
  function getSkill(key) {
    if (key in $context.actor.system.skills) {
      return $context.skills[key];
    }
    return null;
  }
  function toggleShowAllSkills() {
    if (toggleField === null) {
      return;
    }
    actor.update({ [toggleField]: !expanded });
  }
  function onSkillAbilityChange(ev, skillRef) {
    $context.actor.update({
      system: {
        skills: {
          [skillRef.key]: { ability: ev.detail.value }
        }
      }
    });
  }
  const click_handler = (skillRef) => FoundryAdapter.renderProficiencyConfig($context.actor, "skills", skillRef.key);
  const click_handler_1 = (skillRef) => FoundryAdapter.cycleProficiency($context.actor, skillRef.key, skillRef.skill?.value, "skills");
  const contextmenu_handler = (skillRef) => FoundryAdapter.cycleProficiency($context.actor, skillRef.key, skillRef.skill?.value, "skills", true);
  const click_handler_2 = (skillRef, event) => $context.actor.rollSkill(skillRef.key, { event });
  const optionClicked_handler = (skillRef, ev) => onSkillAbilityChange(ev, skillRef);
  $$self.$$set = ($$props2) => {
    if ("toggleable" in $$props2) $$invalidate(0, toggleable = $$props2.toggleable);
    if ("actor" in $$props2) $$invalidate(10, actor = $$props2.actor);
    if ("expanded" in $$props2) $$invalidate(11, expanded = $$props2.expanded);
    if ("toggleField" in $$props2) $$invalidate(12, toggleField = $$props2.toggleField);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*toggleable, expanded*/
    2049) {
      $$invalidate(4, showAllSkills = !toggleable || expanded);
    }
    if ($$self.$$.dirty & /*$context*/
    2) {
      {
        $$invalidate(2, skillRefs = Array.from(Object.entries($context.config.skills)).reduce(
          (prev, [key, configSkill]) => {
            const skill = getSkill(key);
            if (!skill) {
              warn('Unable to find skill. Ensure custom skills are added at "init" time.', false, { key, configSkill });
              return prev;
            }
            prev.push({
              key,
              label: configSkill.label,
              ability: skill.ability,
              skill
            });
            return prev;
          },
          []
        ));
      }
    }
    if ($$self.$$.dirty & /*$context*/
    2) {
      $$invalidate(3, abilities = FoundryAdapter.getAbilitiesAsDropdownOptions($context.abilities));
    }
  };
  return [
    toggleable,
    $context,
    skillRefs,
    abilities,
    showAllSkills,
    $settingStore,
    context,
    localize,
    toggleShowAllSkills,
    onSkillAbilityChange,
    actor,
    expanded,
    toggleField,
    click_handler,
    click_handler_1,
    contextmenu_handler,
    click_handler_2,
    optionClicked_handler
  ];
}
class SkillsList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3W, create_fragment$3X, safe_not_equal, {
      toggleable: 0,
      actor: 10,
      expanded: 11,
      toggleField: 12
    });
  }
}
const get_custom_icon_slot_changes = (dirty) => ({});
const get_custom_icon_slot_context = (ctx) => ({});
function create_if_block$1M(ctx) {
  let div1;
  let span;
  let t0;
  let t1;
  let div0;
  let t2;
  let t3;
  let div1_class_value;
  let current;
  let if_block0 = (
    /*iconCssClass*/
    ctx[2] !== void 0 && create_if_block_3$E(ctx)
  );
  const custom_icon_slot_template = (
    /*#slots*/
    ctx[10]["custom-icon"]
  );
  const custom_icon_slot = create_slot(
    custom_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_custom_icon_slot_context
  );
  let if_block1 = (
    /*$settingStore*/
    ctx[5].showTraitLabels && create_if_block_2$R(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let if_block2 = (
    /*$context*/
    ctx[6].unlocked && create_if_block_1$12(ctx)
  );
  return {
    c() {
      div1 = element("div");
      span = element("span");
      if (if_block0) if_block0.c();
      t0 = space();
      if (custom_icon_slot) custom_icon_slot.c();
      t1 = space();
      div0 = element("div");
      if (if_block1) if_block1.c();
      t2 = space();
      if (default_slot) default_slot.c();
      t3 = space();
      if (if_block2) if_block2.c();
      attr(span, "class", "trait-icon");
      attr(
        span,
        "aria-label",
        /*title*/
        ctx[0]
      );
      attr(
        span,
        "title",
        /*title*/
        ctx[0]
      );
      attr(div0, "class", "trait-label-and-list");
      attr(div0, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ACTOR_TRAIT_DETAILS);
      attr(div1, "class", div1_class_value = "trait-form-group " + /*traitCssClass*/
      (ctx[3] ?? ""));
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ACTOR_TRAIT);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      if (if_block0) if_block0.m(span, null);
      append(span, t0);
      if (custom_icon_slot) {
        custom_icon_slot.m(span, null);
      }
      append(div1, t1);
      append(div1, div0);
      if (if_block1) if_block1.m(div0, null);
      append(div0, t2);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append(div1, t3);
      if (if_block2) if_block2.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*iconCssClass*/
        ctx2[2] !== void 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$E(ctx2);
          if_block0.c();
          if_block0.m(span, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (custom_icon_slot) {
        if (custom_icon_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            custom_icon_slot,
            custom_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              custom_icon_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_custom_icon_slot_changes
            ),
            get_custom_icon_slot_context
          );
        }
      }
      if (!current || dirty & /*title*/
      1) {
        attr(
          span,
          "aria-label",
          /*title*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*title*/
      1) {
        attr(
          span,
          "title",
          /*title*/
          ctx2[0]
        );
      }
      if (
        /*$settingStore*/
        ctx2[5].showTraitLabels
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$R(ctx2);
          if_block1.c();
          if_block1.m(div0, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$context*/
        ctx2[6].unlocked
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$12(ctx2);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*traitCssClass*/
      8 && div1_class_value !== (div1_class_value = "trait-form-group " + /*traitCssClass*/
      (ctx2[3] ?? ""))) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(custom_icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(custom_icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0) if_block0.d();
      if (custom_icon_slot) custom_icon_slot.d(detaching);
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
      if (if_block2) if_block2.d();
    }
  };
}
function create_if_block_3$E(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(
        i2,
        "class",
        /*iconCssClass*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconCssClass*/
      4) {
        attr(
          i2,
          "class",
          /*iconCssClass*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_2$R(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(
        /*title*/
        ctx[0]
      );
      attr(span, "class", "trait-label");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      1) set_data(
        t2,
        /*title*/
        ctx2[0]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$12(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-pencil-alt");
      attr(button, "type", "button");
      attr(button, "class", "trait-editor inline-icon-button flex-row align-items-flex-start justify-content-center");
      attr(
        button,
        "title",
        /*configureButtonTitle*/
        ctx[1]
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*click_handler*/
          ctx[11]
        )));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*configureButtonTitle*/
      2) {
        attr(
          button,
          "title",
          /*configureButtonTitle*/
          ctx2[1]
        );
      }
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3W(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*show*/
    ctx[4] && create_if_block$1M(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*show*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*show*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1M(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance$3V($$self, $$props, $$invalidate) {
  let $settingStore;
  let $context;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(6, $context = value));
  let { title } = $$props;
  let { configureButtonTitle } = $$props;
  let { iconCssClass = void 0 } = $$props;
  let { traitCssClass = "" } = $$props;
  let { show } = $$props;
  const dispatcher = createEventDispatcher();
  const click_handler = (event) => dispatcher("onConfigureClicked", event);
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("configureButtonTitle" in $$props2) $$invalidate(1, configureButtonTitle = $$props2.configureButtonTitle);
    if ("iconCssClass" in $$props2) $$invalidate(2, iconCssClass = $$props2.iconCssClass);
    if ("traitCssClass" in $$props2) $$invalidate(3, traitCssClass = $$props2.traitCssClass);
    if ("show" in $$props2) $$invalidate(4, show = $$props2.show);
    if ("$$scope" in $$props2) $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    title,
    configureButtonTitle,
    iconCssClass,
    traitCssClass,
    show,
    $settingStore,
    $context,
    context,
    dispatcher,
    $$scope,
    slots,
    click_handler
  ];
}
class TraitSection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3V, create_fragment$3W, safe_not_equal, {
      title: 0,
      configureButtonTitle: 1,
      iconCssClass: 2,
      traitCssClass: 3,
      show: 4
    });
  }
}
function get_each_context$13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2][0];
  child_ctx[10] = list[i2][1];
  return child_ctx;
}
function get_if_ctx$h(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = ActiveEffectsHelper.isActiveEffectAppliedToField(
    /*$context*/
    child_ctx[1].actor,
    `system.tools.${/*key*/
    child_ctx[9]}.value`
  );
  child_ctx[13] = constants_0;
  return child_ctx;
}
function create_else_block_1$g(ctx) {
  let span;
  let raw_value = (
    /*tool*/
    ctx[10].icon + ""
  );
  let span_title_value;
  return {
    c() {
      span = element("span");
      attr(span, "title", span_title_value = /*tool*/
      ctx[10].hover);
      attr(span, "class", "tool-proficiency-readonly");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & /*tools*/
      1 && raw_value !== (raw_value = /*tool*/
      ctx2[10].icon + "")) span.innerHTML = raw_value;
      if (dirty & /*tools*/
      1 && span_title_value !== (span_title_value = /*tool*/
      ctx2[10].hover)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2$Q(ctx) {
  let button;
  let raw_value = (
    /*tool*/
    ctx[10].icon + ""
  );
  let button_title_value;
  let button_tabindex_value;
  let button_disabled_value;
  let button_data_tooltip_value;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[5](
        /*key*/
        ctx[9],
        /*tool*/
        ctx[10],
        ...args
      )
    );
  }
  function contextmenu_handler(...args) {
    return (
      /*contextmenu_handler*/
      ctx[6](
        /*key*/
        ctx[9],
        /*tool*/
        ctx[10],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      attr(button, "type", "button");
      attr(button, "class", "tool-proficiency-toggle inline-transparent-button");
      attr(button, "title", button_title_value = /*tool*/
      ctx[10].hover);
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.TOOL_PROFICIENCY_TOGGLE);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
      button.disabled = button_disabled_value = /*activeEffectApplied*/
      ctx[13];
      attr(button, "data-tooltip", button_data_tooltip_value = /*activeEffectApplied*/
      ctx[13] ? (
        /*localize*/
        ctx[4]("DND5E.ActiveEffectOverrideWarning")
      ) : null);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = [
          listen(button, "click", stop_propagation(prevent_default(click_handler))),
          listen(button, "contextmenu", stop_propagation(prevent_default(contextmenu_handler)))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tools*/
      1 && raw_value !== (raw_value = /*tool*/
      ctx[10].icon + "")) button.innerHTML = raw_value;
      if (dirty & /*tools*/
      1 && button_title_value !== (button_title_value = /*tool*/
      ctx[10].hover)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*$context, tools*/
      3 && button_disabled_value !== (button_disabled_value = /*activeEffectApplied*/
      ctx[13])) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$context, tools*/
      3 && button_data_tooltip_value !== (button_data_tooltip_value = /*activeEffectApplied*/
      ctx[13] ? (
        /*localize*/
        ctx[4]("DND5E.ActiveEffectOverrideWarning")
      ) : null)) {
        attr(button, "data-tooltip", button_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$_(ctx) {
  let span;
  let t_value = (
    /*tool*/
    ctx[10].label + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "tool-check-roller");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*tools*/
      1 && t_value !== (t_value = /*tool*/
      ctx2[10].label + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$11(ctx) {
  let button;
  let t_value = (
    /*tool*/
    ctx[10].label + ""
  );
  let t2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[7](
        /*key*/
        ctx[9],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "tool-check-roller inline-transparent-button rollable");
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.TOOL_ROLLER);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tools*/
      1 && t_value !== (t_value = /*tool*/
      ctx[10].label + "")) set_data(t2, t_value);
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1L(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[8](
        /*key*/
        ctx[9]
      )
    );
  }
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "tool-proficiency-editor inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[4]("DND5E.ToolConfigure")
      );
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.TOOL_CONFIGURATION_CONTROL);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(click_handler_2)));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$13(ctx) {
  let li;
  let t0;
  let t1;
  let t2;
  let li_data_key_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].editable && !/*$context*/
      ctx2[1].lockSensitiveFields
    ) return create_if_block_2$Q;
    return create_else_block_1$g;
  }
  function select_block_ctx(ctx2, type) {
    if (type === create_if_block_2$Q) return get_if_ctx$h(ctx2);
    return ctx2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(select_block_ctx(ctx, current_block_type));
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].editable
    ) return create_if_block_1$11;
    return create_else_block$_;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block1 = current_block_type_1(ctx);
  let if_block2 = (
    /*$context*/
    ctx[1].unlocked && create_if_block$1L(ctx)
  );
  return {
    c() {
      li = element("li");
      if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      attr(li, "class", "tool");
      attr(li, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.TOOL_CONTAINER);
      attr(li, "data-key", li_data_key_value = /*key*/
      ctx[9]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if_block0.m(li, null);
      append(li, t0);
      if_block1.m(li, null);
      append(li, t1);
      if (if_block2) if_block2.m(li, null);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(select_block_ctx(ctx2, current_block_type), dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(select_block_ctx(ctx2, current_block_type));
        if (if_block0) {
          if_block0.c();
          if_block0.m(li, t0);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(li, t1);
        }
      }
      if (
        /*$context*/
        ctx2[1].unlocked
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$1L(ctx2);
          if_block2.c();
          if_block2.m(li, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & /*tools*/
      1 && li_data_key_value !== (li_data_key_value = /*key*/
      ctx2[9])) {
        attr(li, "data-key", li_data_key_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if_block0.d();
      if_block1.d();
      if (if_block2) if_block2.d();
    }
  };
}
function create_fragment$3V(ctx) {
  let ul;
  let each_value = ensure_array_like(
    /*tools*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$13(get_each_context$13(ctx, each_value, i2));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "trait-list tools");
      attr(ul, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.TOOLS_LIST);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tools, localize, $settingStore, $context*/
      23) {
        each_value = ensure_array_like(
          /*tools*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$13(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$13(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ul, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3U($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let { tools = [] } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = (key, tool, event) => FoundryAdapter.cycleProficiency($context.actor, key, tool.value, "tools");
  const contextmenu_handler = (key, tool, event) => FoundryAdapter.cycleProficiency($context.actor, key, tool.value, "tools", true);
  const click_handler_1 = (key, event) => $context.actor.rollToolCheck(key, { event });
  const click_handler_2 = (key) => FoundryAdapter.renderProficiencyConfig($context.actor, "tools", key);
  $$self.$$set = ($$props2) => {
    if ("tools" in $$props2) $$invalidate(0, tools = $$props2.tools);
  };
  return [
    tools,
    $context,
    $settingStore,
    context,
    localize,
    click_handler,
    contextmenu_handler,
    click_handler_1,
    click_handler_2
  ];
}
class TraitSectionTools extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3U, create_fragment$3V, safe_not_equal, { tools: 0 });
  }
}
function get_each_context$12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2][0];
  child_ctx[2] = list[i2][1];
  return child_ctx;
}
function create_each_block$12(ctx) {
  let li;
  let t_value = (
    /*value*/
    ctx[2] + ""
  );
  let t2;
  let li_class_value;
  return {
    c() {
      li = element("li");
      t2 = text(t_value);
      attr(li, "class", li_class_value = "trait-tag " + /*key*/
      ctx[1]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*tags*/
      1 && t_value !== (t_value = /*value*/
      ctx2[2] + "")) set_data(t2, t_value);
      if (dirty & /*tags*/
      1 && li_class_value !== (li_class_value = "trait-tag " + /*key*/
      ctx2[1])) {
        attr(li, "class", li_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment$3U(ctx) {
  let ul;
  let each_value = ensure_array_like(
    /*tags*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$12(get_each_context$12(ctx, each_value, i2));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "trait-list traits");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tags*/
      1) {
        each_value = ensure_array_like(
          /*tags*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$12(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$12(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ul, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3T($$self, $$props, $$invalidate) {
  let { tags = [] } = $$props;
  $$self.$$set = ($$props2) => {
    if ("tags" in $$props2) $$invalidate(0, tags = $$props2.tags);
  };
  return [tags];
}
class TraitSectionTags extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3T, create_fragment$3U, safe_not_equal, { tags: 0 });
  }
}
function get_each_context$11(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function get_each_context_1$p(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[1].config.itemProperties[
      /*icon*/
      child_ctx[7]
    ]?.label ?? ""
  );
  child_ctx[8] = constants_0;
  return child_ctx;
}
function create_each_block_1$p(ctx) {
  let i2;
  let i_class_value;
  let i_title_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = "damage-modification-icon " + /*icon*/
      ctx[7]);
      attr(i2, "title", i_title_value = /*localize*/
      ctx[3]("DND5E.DamagePhysicalBypassesShort", { type: (
        /*propertyLabel*/
        ctx[8]
      ) }));
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*modifications*/
      1 && i_class_value !== (i_class_value = "damage-modification-icon " + /*icon*/
      ctx2[7])) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & /*$context, modifications*/
      3 && i_title_value !== (i_title_value = /*localize*/
      ctx2[3]("DND5E.DamagePhysicalBypassesShort", { type: (
        /*propertyLabel*/
        ctx2[8]
      ) }))) {
        attr(i2, "title", i_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_each_block$11(ctx) {
  let li;
  let t0;
  let t1_value = (
    /*modification*/
    ctx[4].label + ""
  );
  let t1;
  let t2;
  let li_class_value;
  let each_value_1 = ensure_array_like(
    /*modification*/
    ctx[4].icons ?? []
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$p(get_each_context_1$p(ctx, each_value_1, i2));
  }
  return {
    c() {
      li = element("li");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(li, "class", li_class_value = "damage-modification " + /*modification*/
      ctx[4].consequence + " flex-row extra-small-gap");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(li, null);
        }
      }
      append(li, t0);
      append(li, t1);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*modifications, localize, $context*/
      11) {
        each_value_1 = ensure_array_like(
          /*modification*/
          ctx2[4].icons ?? []
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$p(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$p(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(li, t0);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*modifications*/
      1 && t1_value !== (t1_value = /*modification*/
      ctx2[4].label + "")) set_data(t1, t1_value);
      if (dirty & /*modifications*/
      1 && li_class_value !== (li_class_value = "damage-modification " + /*modification*/
      ctx2[4].consequence + " flex-row extra-small-gap")) {
        attr(li, "class", li_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$3T(ctx) {
  let ul;
  let each_value = ensure_array_like(
    /*modifications*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$11(get_each_context$11(ctx, each_value, i2));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "damage-modifications");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*modifications, localize, $context*/
      11) {
        each_value = ensure_array_like(
          /*modifications*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$11(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$11(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ul, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3S($$self, $$props, $$invalidate) {
  let $context;
  let { modifications } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("modifications" in $$props2) $$invalidate(0, modifications = $$props2.modifications);
  };
  return [modifications, $context, context, localize];
}
class TraitSectionModifications extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3S, create_fragment$3T, safe_not_equal, { modifications: 0 });
  }
}
class TidyFlags {
  static getFlagPropertyPath(key) {
    return `flags.${CONSTANTS.MODULE_ID}.${key}`;
  }
  /**
   * Determines whether an item whose default Action List behavior has been overridden
   * to be included (`true`) or excluded (`false`).
   * `undefined` means there is no override and standard Action List logic should be used.
   * */
  static actionFilterOverride = {
    key: "action-filter-override",
    prop: TidyFlags.getFlagPropertyPath("action-filter-override"),
    /** Gets the item's Action Filter Override setting. */
    get(item) {
      return TidyFlags.tryGetFlag(
        item,
        TidyFlags.actionFilterOverride.key
      ) ?? void 0;
    },
    /** Sets the item's Action Filter Override setting. */
    set(item, value) {
      return TidyFlags.setFlag(item, TidyFlags.actionFilterOverride.key, value);
    },
    /**
     * Clears the item's Action Filter Override setting,
     * meaning the item should use the standard Action List logic
     * for inclusion or exclusion. */
    unset(item) {
      return TidyFlags.unsetFlag(item, TidyFlags.actionFilterOverride.key);
    }
  };
  /**
   * Indicates a custom section name for a given item,
   * which determines the item's section placement
   * in the Actions tab.
   */
  static actionSection = {
    key: "actionSection",
    prop: TidyFlags.getFlagPropertyPath("actionSection"),
    /** Gets the item's Action Section setting. */
    get(item) {
      return TidyFlags.tryGetFlag(item, TidyFlags.actionSection.key) ?? void 0;
    },
    /** Sets the item's Action Section setting. */
    set(item, value) {
      return TidyFlags.setFlag(item, TidyFlags.actionSection.key, value);
    },
    /**
     * Clears the item's Action Section setting,
     * meaning the item should use its default action section
     * in the Actions tab.
     */
    unset(item) {
      return TidyFlags.unsetFlag(item, TidyFlags.actionSection.key);
    }
  };
  /**
   * The age of an actor.
   * For this module, it is only an informational biographical field.
   */
  static age = {
    key: "age",
    prop: TidyFlags.getFlagPropertyPath("age"),
    /** Gets the actor's age. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.age.key) ?? void 0;
    },
    /** Sets the actor's age. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.age.key, value);
    },
    /** Clears the actor's age. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.age.key);
    }
  };
  /**
   * Determines whether an actor's sheet should be editable per the sheet lock feature (default `true`).
   * @param actor the actor
   * @returns whether the sheet should be editable per the sheet lock feature
   */
  static allowEdit = {
    key: "allow-edit",
    prop: TidyFlags.getFlagPropertyPath("allow-edit"),
    /** Denotes whether the sheet is in edit mode. */
    get(document2) {
      return TidyFlags.tryGetFlag(document2, "allow-edit") ?? true;
    },
    /** Sets whether the sheet is in edit mode. */
    set(document2, value) {
      return TidyFlags.setFlag(document2, TidyFlags.allowEdit.key, value);
    },
    /** Removes the actor's edit mode setting. */
    unset(document2) {
      return TidyFlags.unsetFlag(document2, TidyFlags.allowEdit.key);
    }
  };
  /**
   * The appearance of an actor.
   * For this module, it is only an informational biographical field.
   */
  static appearance = {
    key: "appearance",
    prop: TidyFlags.getFlagPropertyPath("appearance"),
    /** Gets the actor's appearance. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.appearance.key) ?? void 0;
    },
    /** Sets the actor's appearance. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.appearance.key, value);
    },
    /** Clears the actor's appearance. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.appearance.key);
    }
  };
  /**
   * A field used to filter spells based on an indicated class,
   * showing only spells whose `system.sourceClass` property matches
   * this `classFilter` selection.
   */
  static classFilter = {
    key: "classFilter",
    prop: TidyFlags.getFlagPropertyPath("classFilter"),
    /** Gets the actor's class filter. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.classFilter.key) ?? void 0;
    },
    /** Sets the actor's class filter. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.classFilter.key, value);
    },
    /** Clears the actor's class filter. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.classFilter.key);
    }
  };
  /**
   * The level exhaustion for a given actor.
   * This flag applies to actors which don't yet possess
   * standard exhaustion schema from the dnd5e system.
   */
  static exhaustion = {
    key: "exhaustion",
    prop: TidyFlags.getFlagPropertyPath("exhaustion"),
    /** Gets the actor's exhaustion level. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.exhaustion.key) ?? void 0;
    },
    /** Sets the actor's exhaustion level. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.exhaustion.key, value);
    },
    /** Clears the actor's exhaustion level. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.exhaustion.key);
    }
  };
  /**
   * The eyes of an actor.
   * For this module, it is only an informational biographical field.
   */
  static eyes = {
    key: "eyes",
    prop: TidyFlags.getFlagPropertyPath("eyes"),
    /** Gets the actor's eyes. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.eyes.key) ?? void 0;
    },
    /** Sets the actor's eyes. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.eyes.key, value);
    },
    /** Clears the actor's eyes. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.eyes.key);
    }
  };
  /**
   * The faith of an actor.
   * For this module, it is only an informational biographical field.
   */
  static faith = {
    key: "faith",
    prop: TidyFlags.getFlagPropertyPath("faith"),
    /** Gets the actor's faith. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.faith.key) ?? void 0;
    },
    /** Sets the actor's faith. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.faith.key, value);
    },
    /** Clears the actor's faith. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.faith.key);
    }
  };
  /**
   * The gender of an actor.
   * For this module, it is only an informational biographical field.
   */
  static gender = {
    key: "gender",
    prop: TidyFlags.getFlagPropertyPath("gender"),
    /** Gets the actor's gender. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.gender.key) ?? void 0;
    },
    /** Sets the actor's gender. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.gender.key, value);
    },
    /** Clears the actor's gender. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.gender.key);
    }
  };
  /**
   * The hair of an actor.
   * For this module, it is only an informational biographical field.
   */
  static hair = {
    key: "hair",
    prop: TidyFlags.getFlagPropertyPath("hair"),
    /** Gets the actor's hair. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.hair.key) ?? void 0;
    },
    /** Sets the actor's hair. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.hair.key, value);
    },
    /** Clears the actor's hair. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.hair.key);
    }
  };
  /**
   * The height of an actor.
   * For this module, it is only an informational biographical field.
   */
  static height = {
    key: "height",
    prop: TidyFlags.getFlagPropertyPath("height"),
    /** Gets the actor's height. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.height.key) ?? void 0;
    },
    /** Sets the actor's height. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.height.key, value);
    },
    /** Clears the actor's height. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.height.key);
    }
  };
  /**
   * Denotes whether to show a grid for a given inventory screen.
   */
  static inventoryGrid = {
    key: "inventory-grid",
    prop: TidyFlags.getFlagPropertyPath("inventory-grid"),
    /** Gets whether to show a grid for a given inventory screen. */
    get(document2) {
      return TidyFlags.tryGetFlag(document2, TidyFlags.inventoryGrid.key) === true;
    },
    /** Sets whether to show a grid for a given inventory screen. */
    set(document2) {
      return TidyFlags.setFlag(document2, TidyFlags.inventoryGrid.key, true);
    },
    /** Clears whether to show a grid for a given inventory screen. */
    unset(document2) {
      return TidyFlags.unsetFlag(document2, TidyFlags.inventoryGrid.key);
    }
  };
  /**
   * A formula that determines the maximum number of
   * prepared spells an actor can have.
   */
  static maxPreparedSpells = {
    key: "maxPreparedSpells",
    prop: TidyFlags.getFlagPropertyPath("maxPreparedSpells"),
    /** Gets the actor's maximum number of prepared spells. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.maxPreparedSpells.key) ?? void 0;
    },
    /** Sets the actor's maximum number of prepared spells. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.maxPreparedSpells.key, value);
    },
    /** Clears the actor's maximum number of prepared spells. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.maxPreparedSpells.key);
    }
  };
  /**
   * Denotes whether a vehicle is moving.
   */
  static motion = {
    key: "motion",
    prop: TidyFlags.getFlagPropertyPath("motion"),
    /** Gets whether a vehicle is moving. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.motion.key) ?? void 0;
    },
    /** Sets whether a vehicle is moving. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.motion.key, value);
    },
    /** Clears whether a vehicle is moving. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.motion.key);
    }
  };
  /**
   * Journal notes for an actor.
   * This flag is for actors which don't yet have the standard notes schema.
   */
  static notes = {
    key: "notes",
    prop: TidyFlags.getFlagPropertyPath("notes"),
    /** Gets the actor's journal notes. */
    get(actor) {
      return TidyFlags.tryGetFlag(
        actor,
        TidyFlags.notes.key
      ) ?? void 0;
    },
    /** Sets the actor's journal notes. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.notes.key, value);
    },
    /** Clears the actor's journal notes. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.notes.key);
    },
    /** The individual members of this flag. For flags that are not primitive values. */
    members: {
      /** The notes HTML. */
      value: {
        key: "notes.value",
        prop: TidyFlags.getFlagPropertyPath("notes.value"),
        /** Gets the actor's notes HTML. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes.members.value.key
          ) ?? void 0;
        },
        /** Sets the actor's notes HTML. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes.members.value.key,
            value
          );
        },
        /** Clears the actor's notes HTML. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes.members.value.key);
        }
      }
    }
  };
  /**
   * Named journal notes for an actor.
   * These notes represent extra notes that are available
   * to actors for compartmentalizing notes.
   */
  static notes1 = {
    key: "notes1",
    prop: TidyFlags.getFlagPropertyPath("notes1"),
    /** Gets the actor's first named journal notes. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.notes1.key) ?? void 0;
    },
    /** Sets the actor's first named journal notes. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.notes1.key, value);
    },
    /** Clears the actor's first named journal notes. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.notes1.key);
    },
    /** The individual members of this flag. For flags that are not primitive values. */
    members: {
      /** The notes name. */
      name: {
        key: "notes1.name",
        prop: TidyFlags.getFlagPropertyPath("notes1.name"),
        /** Gets the actor's first named journal notes name. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes1.members.name.key
          ) ?? void 0;
        },
        /** Sets the actor's first named journal notes name. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes1.members.name.key,
            value
          );
        },
        /** Clears the actor's first named journal notes name. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes1.members.name.key);
        }
      },
      /** The notes HTML. */
      value: {
        key: "notes1.value",
        prop: TidyFlags.getFlagPropertyPath("notes1.value"),
        /** Gets the actor's first named journal notes HTML. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes1.members.value.key
          ) ?? void 0;
        },
        /** Sets the actor's first named journal notes HTML. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes1.members.value.key,
            value
          );
        },
        /** Clears the actor's first named journal notes HTML. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes1.members.value.key);
        }
      }
    }
  };
  /**
   * Named journal notes for an actor.
   * These notes represent extra notes that are available
   * to actors for compartmentalizing notes.
   */
  static notes2 = {
    key: "notes2",
    prop: TidyFlags.getFlagPropertyPath("notes2"),
    /** Gets the actor's second named journal notes. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.notes2.key) ?? void 0;
    },
    /** Sets the actor's second named journal notes. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.notes2.key, value);
    },
    /** Clears the actor's second named journal notes. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.notes2.key);
    },
    /** The individual members of this flag. For flags that are not primitive values. */
    members: {
      /** The notes name. */
      name: {
        key: "notes2.name",
        prop: TidyFlags.getFlagPropertyPath("notes2.name"),
        /** Gets the actor's second named journal notes name. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes2.members.name.key
          ) ?? void 0;
        },
        /** Sets the actor's second named journal notes name. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes2.members.name.key,
            value
          );
        },
        /** Clears the actor's second named journal notes name. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes2.members.name.key);
        }
      },
      /** The notes HTML. */
      value: {
        key: "notes2.value",
        prop: TidyFlags.getFlagPropertyPath("notes2.value"),
        /** Gets the actor's second named journal notes HTML. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes2.members.value.key
          ) ?? void 0;
        },
        /** Sets the actor's second named journal notes HTML. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes2.members.value.key,
            value
          );
        },
        /** Clears the actor's second named journal notes HTML. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes2.members.value.key);
        }
      }
    }
  };
  /**
   * Named journal notes for an actor.
   * These notes represent extra notes that are available
   * to actors for compartmentalizing notes.
   */
  static notes3 = {
    key: "notes3",
    prop: TidyFlags.getFlagPropertyPath("notes3"),
    /** Gets the actor's third named journal notes. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.notes3.key) ?? void 0;
    },
    /** Sets the actor's third named journal notes. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.notes3.key, value);
    },
    /** Clears the actor's third named journal notes. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.notes3.key);
    },
    members: {
      name: {
        key: "notes3.name",
        prop: TidyFlags.getFlagPropertyPath("notes3.name"),
        /** Gets the actor's third named journal notes name. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes3.members.name.key
          ) ?? void 0;
        },
        /** Sets the actor's third named journal notes name. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes3.members.name.key,
            value
          );
        },
        /** Clears the actor's third named journal notes name. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes3.members.name.key);
        }
      },
      value: {
        key: "notes3.value",
        prop: TidyFlags.getFlagPropertyPath("notes3.value"),
        /** Gets the actor's third named journal notes HTML. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes3.members.value.key
          ) ?? void 0;
        },
        /** Sets the actor's third named journal notes HTML. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes3.members.value.key,
            value
          );
        },
        /** Clears the actor's third named journal notes HTML. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes3.members.value.key);
        }
      }
    }
  };
  /**
   * Named journal notes for an actor.
   * These notes represent extra notes that are available
   * to actors for compartmentalizing notes.
   */
  static notes4 = {
    key: "notes4",
    prop: TidyFlags.getFlagPropertyPath("notes4"),
    /** Gets the actor's fourth named journal notes. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.notes4.key) ?? void 0;
    },
    /** Sets the actor's fourth named journal notes. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.notes4.key, value);
    },
    /** Clears the actor's fourth named journal notes. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.notes4.key);
    },
    /** The individual members of this flag. For flags that are not primitive values. */
    members: {
      /** The notes name. */
      name: {
        key: "notes4.name",
        prop: TidyFlags.getFlagPropertyPath("notes4.name"),
        /** Gets the actor's fourth named journal notes name. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes4.members.name.key
          ) ?? void 0;
        },
        /** Sets the actor's fourth named journal notes name. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes4.members.name.key,
            value
          );
        },
        /** Clears the actor's fourth named journal notes name. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes4.members.name.key);
        }
      },
      /** The notes HTML. */
      value: {
        key: "notes4.value",
        prop: TidyFlags.getFlagPropertyPath("notes4.value"),
        /** Gets the actor's fourth named journal notes HTML. */
        get(actor) {
          return TidyFlags.tryGetFlag(
            actor,
            TidyFlags.notes4.members.value.key
          ) ?? void 0;
        },
        /** Sets the actor's fourth named journal notes HTML. */
        set(actor, value) {
          return TidyFlags.setFlag(
            actor,
            TidyFlags.notes4.members.value.key,
            value
          );
        },
        /** Clears the actor's fourth named journal notes HTML. */
        unset(actor) {
          return TidyFlags.unsetFlag(actor, TidyFlags.notes4.members.value.key);
        }
      }
    }
  };
  /**
   * The name of the player who owns the actor.
   * This is informational and not used for game logic.
   */
  static playerName = {
    key: "playerName",
    prop: TidyFlags.getFlagPropertyPath("playerName"),
    /** Gets the name of the player who owns the actor. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.playerName.key) ?? void 0;
    },
    /** Sets the name of the player who owns the actor. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.playerName.key, value);
    },
    /** Clears the name of the player who owns the actor. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.playerName.key);
    }
  };
  /**
   * Indicates a custom section name for a given item
   * which determines the item's section placement
   * in the item's default tab, as well as any other locations
   * that aren't the Actions tab.
   */
  static section = {
    key: "section",
    prop: TidyFlags.getFlagPropertyPath("section"),
    /** Gets the custom section name for an item. */
    get(item) {
      return TidyFlags.tryGetFlag(item, TidyFlags.section.key) ?? void 0;
    },
    /** Sets the custom section name for an item. */
    set(item, value) {
      return TidyFlags.setFlag(item, TidyFlags.section.key, value);
    },
    /**
     * Clears the item's custom section setting,
     * meaning the item should use its default section
     * in the item's default tab, as well as any other locations
     * that aren't the Actions tab.
     */
    unset(item) {
      return TidyFlags.unsetFlag(item, TidyFlags.section.key);
    }
  };
  /** Determines the order of item table sections for a given document sheet. */
  static sectionConfig = {
    key: "sheet-section-config",
    prop: TidyFlags.getFlagPropertyPath("sheet-section-config"),
    /** Gets the document sheet's section configuration. `undefined` means to use the default settings. */
    get(document2) {
      const sectionConfigs = TidyFlags.tryGetFlag(
        document2,
        TidyFlags.sectionConfig.key
      );
      if (!sectionConfigs) {
        return void 0;
      }
      for (let section of Object.values(sectionConfigs)) {
        for (let [key, value] of Object.entries(section)) {
          if (Object.getOwnPropertyNames(value).length > 1) {
            continue;
          }
          let newKey = key;
          let newValue = value;
          while (true) {
            const propNames = Object.getOwnPropertyNames(newValue);
            let currentPropAtDepth = propNames[0];
            if (isNil(currentPropAtDepth) || propNames.length > 1) {
              break;
            }
            newKey += "." + currentPropAtDepth;
            newValue = newValue[currentPropAtDepth];
          }
          delete section[key];
          section[newKey] = newValue;
        }
      }
      return sectionConfigs;
    },
    /** Sets the document sheet's configuration. */
    set(document2, value) {
      return TidyFlags.setFlag(document2, TidyFlags.sectionConfig.key, value);
    },
    /**
     * Clears the document sheet's section config,
     * meaning the target actor should use default settings.
     * */
    unset(document2) {
      return TidyFlags.unsetFlag(document2, TidyFlags.sectionConfig.key);
    }
  };
  /**
   * The tabs that are currently selected for a given actor.
   * This is used to determine which tabs are visible
   * in the actor's sheet.
   * When this field is empty, the actor uses the default tabs.
   */
  static selectedTabs = {
    key: "selected-tabs",
    prop: TidyFlags.getFlagPropertyPath("selected-tabs"),
    /** Gets the selected tabs for an actor. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.selectedTabs.key) ?? void 0;
    },
    /** Sets the selected tabs for an actor. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.selectedTabs.key, value);
    },
    /** Clears the selected tabs for an actor. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.selectedTabs.key);
    }
  };
  /**
   * Indicates whether the container panel should be shown for a given actor.
   * This is used to determine whether the container panel is visible
   * in the actor's inventory tab.
   */
  static showContainerPanel = {
    key: "showContainerPanel",
    prop: TidyFlags.getFlagPropertyPath("showContainerPanel"),
    /** Gets whether the container panel should be shown for an actor. */
    get(actor) {
      return TidyFlags.tryGetFlag(
        actor,
        TidyFlags.showContainerPanel.key
      ) ?? void 0;
    },
    /** Sets whether the container panel should be shown for an actor. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.showContainerPanel.key, value);
    },
    /** Clears whether the container panel should be shown for an actor. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.showContainerPanel.key);
    }
  };
  /**
   * Indicates whether the legendary toolbar should be shown for a given NPC.
   */
  static showLegendaryToolbar = {
    key: "showLegendaryToolbar",
    prop: TidyFlags.getFlagPropertyPath("showLegendaryToolbar"),
    /** Gets whether the legendary toolbar should be shown for an NPC. */
    get(actor) {
      return TidyFlags.tryGetFlag(
        actor,
        TidyFlags.showLegendaryToolbar.key
      ) ?? void 0;
    },
    /** Sets whether the legendary toolbar should be shown for an NPC. */
    set(actor, value) {
      return TidyFlags.setFlag(
        actor,
        TidyFlags.showLegendaryToolbar.key,
        value
      );
    },
    /** Clears whether the legendary toolbar should be shown for an NPC. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.showLegendaryToolbar.key);
    }
  };
  /**
   * Indicates whether the additional personality info should be shown
   * for a given NPC on the biography tab.
   */
  static showNpcPersonalityInfo = {
    key: "showNpcPersonalityInfo",
    prop: TidyFlags.getFlagPropertyPath("showNpcPersonalityInfo"),
    /** Gets whether the additional personality info should be shown for an NPC. */
    get(actor) {
      return TidyFlags.tryGetFlag(
        actor,
        TidyFlags.showNpcPersonalityInfo.key
      ) ?? void 0;
    },
    /** Sets whether the additional personality info should be shown for an NPC. */
    set(actor, value) {
      return TidyFlags.setFlag(
        actor,
        TidyFlags.showNpcPersonalityInfo.key,
        value
      );
    },
    /** Clears whether the additional personality info should be shown for an NPC. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.showNpcPersonalityInfo.key);
    }
  };
  /**
   * Indicates whether the skills section should be expanded for a given actor.
   * If this is set to `true`, all skills are shown.
   * If this is set to `false`, unproficient skills are hidden and the rest are shown.
   */
  static skillsExpanded = {
    key: "skillsExpanded",
    prop: TidyFlags.getFlagPropertyPath("skillsExpanded"),
    /** Gets whether the skills section should be expanded for an actor. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.skillsExpanded.key) ?? void 0;
    },
    /** Sets whether the skills section should be expanded for an actor. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.skillsExpanded.key, value);
    },
    /** Clears whether the skills section should be expanded for an actor. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.skillsExpanded.key);
    }
  };
  /**
   * The skin of an actor.
   * This is informational and not used for game logic.
   */
  static skin = {
    key: "skin",
    prop: TidyFlags.getFlagPropertyPath("skin"),
    /** Gets the skin of an actor. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.skin.key) ?? void 0;
    },
    /** Sets the skin of an actor. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.skin.key, value);
    },
    /** Clears the skin of an actor. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.skin.key);
    }
  };
  /**
   * Denotes whether to show a grid for a given spellbook screen.
   */
  static spellbookGrid = {
    key: "spellbook-grid",
    prop: TidyFlags.getFlagPropertyPath("spellbook-grid"),
    /** Gets whether to show a grid for a given spellbook screen. */
    get(document2) {
      return TidyFlags.tryGetFlag(document2, TidyFlags.spellbookGrid.key) === true;
    },
    /** Sets whether to show a grid for a given spellbook screen. */
    set(document2) {
      return TidyFlags.setFlag(document2, TidyFlags.spellbookGrid.key, true);
    },
    /** Clears whether to show a grid for a given spellbook screen. */
    unset(document2) {
      return TidyFlags.unsetFlag(document2, TidyFlags.spellbookGrid.key);
    }
  };
  /**
   * The trait of an actor.
   * This is informational and not used for game logic.
   */
  static trait = {
    key: "trait",
    prop: TidyFlags.getFlagPropertyPath("trait"),
    /** Gets the trait of an actor. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.trait.key) ?? void 0;
    },
    /** Sets the trait of an actor. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.trait.key, value);
    },
    /** Clears the trait of an actor. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.trait.key);
    }
  };
  /**
   * The weight of an actor.
   * For this module, it is only an informational biographical field.
   */
  static weight = {
    key: "weight",
    prop: TidyFlags.getFlagPropertyPath("weight"),
    /** Gets the weight of an actor. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.weight.key) ?? void 0;
    },
    /** Sets the weight of an actor. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.weight.key, value);
    },
    /** Clears the weight of an actor. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.weight.key);
    }
  };
  /**
   * Indicates whether the traits section should be expanded for a given actor.
   * If this is set to `true`, all traits are shown.
   * If this is set to `false`, empty traits sections are hidden and the rest are shown.
   * This does not apply to custom traits which are added through the Tidy API.
   */
  static traitsExpanded = {
    key: "traitsExpanded",
    prop: TidyFlags.getFlagPropertyPath("traitsExpanded"),
    /** Gets whether the traits section should be expanded for an actor. */
    get(actor) {
      return TidyFlags.tryGetFlag(actor, TidyFlags.traitsExpanded.key) ?? void 0;
    },
    /** Sets whether the traits section should be expanded for an actor. */
    set(actor, value) {
      return TidyFlags.setFlag(actor, TidyFlags.traitsExpanded.key, value);
    },
    /** Clears whether the traits section should be expanded for an actor. */
    unset(actor) {
      return TidyFlags.unsetFlag(actor, TidyFlags.traitsExpanded.key);
    }
  };
  /**
   * Attempts to get a flag from a document.
   * @param flagged A document which supports flags.
   * @param flagName The name of the flag to get.
   * @returns The flag's value, or `undefined` if the flag is not set.
   * 
   * @remarks
   * This function is generic, but it is not performing parsing of the flag's value.
   * It is simply doing an optimistic cast to the target type.
   */
  static tryGetFlag(flagged, flagName) {
    return flagged.getFlag(CONSTANTS.MODULE_ID, flagName);
  }
  /**
   * Sets a flag on a document.
   * @param flagged A document to set the flag on.
   * @param flagName The name of the flag to set.
   * @param value The value to set the flag to.
   * @returns A promise that resolves when the flag is set.
   */
  static setFlag(flagged, flagName, value) {
    return flagged.setFlag(CONSTANTS.MODULE_ID, flagName, value);
  }
  /**
   * Clears a flag from a document.
   * @param flagged A document to clear the flag from.
   * @param flagName The name of the flag to clear.
   * @returns A promise that resolves when the flag is cleared.
   */
  static unsetFlag(flagged, flagName) {
    return flagged.unsetFlag(CONSTANTS.MODULE_ID, flagName);
  }
}
function get_each_context$10(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  return child_ctx;
}
function get_if_ctx$g(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = Object.entries(
    /*$context*/
    child_ctx[3].tools
  );
  child_ctx[25] = constants_0;
  return child_ctx;
}
function get_if_ctx_1(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getTags(
    /*$context*/
    child_ctx[3].traits.traits.armorProf.selected
  );
  child_ctx[26] = constants_0;
  return child_ctx;
}
function get_if_ctx_2(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getTags(
    /*$context*/
    child_ctx[3].traits.traits.weaponProf.selected
  );
  child_ctx[27] = constants_0;
  return child_ctx;
}
function get_if_ctx_3(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getTags(
    /*$context*/
    child_ctx[3].traits.traits.ci.selected
  );
  child_ctx[28] = constants_0;
  return child_ctx;
}
function get_if_ctx_4(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getTags(
    /*$context*/
    child_ctx[3].traits.traits.dv.selected
  );
  child_ctx[29] = constants_0;
  return child_ctx;
}
function get_if_ctx_5(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getTags(
    /*$context*/
    child_ctx[3].traits.traits.dr.selected
  );
  child_ctx[30] = constants_0;
  return child_ctx;
}
function get_if_ctx_6(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getTags(
    /*$context*/
    child_ctx[3].traits.traits.di.selected
  );
  child_ctx[31] = constants_0;
  return child_ctx;
}
function get_if_ctx_7(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getTags(
    /*$context*/
    child_ctx[3].traits?.traits?.languages?.selected
  );
  child_ctx[32] = constants_0;
  return child_ctx;
}
function get_if_ctx_8(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = getTags(
    /*$context*/
    child_ctx[3].senses
  );
  child_ctx[33] = constants_0;
  return child_ctx;
}
function create_if_block_14$6(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      title: (
        /*localize*/
        ctx[8]("DND5E.Senses")
      ),
      iconCssClass: "fas fa-eye",
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.SensesConfig")
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*senses*/
        ctx[33].length
      ),
      $$slots: { default: [create_default_slot_9$i] },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler*/
    ctx[9]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*senses*/
      ctx2[33].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_9$i(ctx) {
  let traitsectiontags;
  let current;
  traitsectiontags = new TraitSectionTags({ props: { tags: (
    /*senses*/
    ctx[33]
  ) } });
  return {
    c() {
      create_component(traitsectiontags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontags_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontags_changes.tags = /*senses*/
      ctx2[33];
      traitsectiontags.$set(traitsectiontags_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontags, detaching);
    }
  };
}
function create_if_block_13$6(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      traitCssClass: (
        /*$context*/
        ctx[3].traits?.traits?.languages?.cssClass ?? ""
      ),
      title: (
        /*localize*/
        ctx[8]("DND5E.Languages")
      ),
      iconCssClass: "fas fa-comment",
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5e.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.Languages")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*languages*/
        ctx[32].length
      ),
      $$slots: { default: [create_default_slot_8$k] },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_1*/
    ctx[10]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.traitCssClass = /*$context*/
      ctx2[3].traits?.traits?.languages?.cssClass ?? "";
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*languages*/
      ctx2[32].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_8$k(ctx) {
  let traitsectiontags;
  let current;
  traitsectiontags = new TraitSectionTags({ props: { tags: (
    /*languages*/
    ctx[32]
  ) } });
  return {
    c() {
      create_component(traitsectiontags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontags_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontags_changes.tags = /*languages*/
      ctx2[32];
      traitsectiontags.$set(traitsectiontags_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontags, detaching);
    }
  };
}
function create_if_block_12$7(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      traitCssClass: (
        /*$context*/
        ctx[3].traits.traits?.di?.cssClass ?? ""
      ),
      title: (
        /*localize*/
        ctx[8]("DND5E.DamImm")
      ),
      iconCssClass: "fas fa-heart",
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.DamImm")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*damageImmunities*/
        ctx[31].length
      ),
      $$slots: { default: [create_default_slot_7$n] },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_2*/
    ctx[11]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.traitCssClass = /*$context*/
      ctx2[3].traits.traits?.di?.cssClass ?? "";
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*damageImmunities*/
      ctx2[31].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_7$n(ctx) {
  let traitsectiontags;
  let current;
  traitsectiontags = new TraitSectionTags({
    props: { tags: (
      /*damageImmunities*/
      ctx[31]
    ) }
  });
  return {
    c() {
      create_component(traitsectiontags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontags_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontags_changes.tags = /*damageImmunities*/
      ctx2[31];
      traitsectiontags.$set(traitsectiontags_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontags, detaching);
    }
  };
}
function create_if_block_11$8(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      traitCssClass: (
        /*$context*/
        ctx[3].traits.traits?.dr?.cssClass ?? ""
      ),
      title: (
        /*localize*/
        ctx[8]("DND5E.DamRes")
      ),
      iconCssClass: "far fa-heart",
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.DamRes")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*damageResistances*/
        ctx[30].length
      ),
      $$slots: { default: [create_default_slot_6$o] },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_3*/
    ctx[12]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.traitCssClass = /*$context*/
      ctx2[3].traits.traits?.dr?.cssClass ?? "";
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*damageResistances*/
      ctx2[30].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_6$o(ctx) {
  let traitsectiontags;
  let current;
  traitsectiontags = new TraitSectionTags({
    props: { tags: (
      /*damageResistances*/
      ctx[30]
    ) }
  });
  return {
    c() {
      create_component(traitsectiontags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontags_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontags_changes.tags = /*damageResistances*/
      ctx2[30];
      traitsectiontags.$set(traitsectiontags_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontags, detaching);
    }
  };
}
function create_if_block_10$9(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      traitCssClass: (
        /*$context*/
        ctx[3].traits.traits?.dv?.cssClass ?? ""
      ),
      title: (
        /*localize*/
        ctx[8]("DND5E.DamVuln")
      ),
      iconCssClass: "fas fa-heart-broken",
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.DamVuln")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*vulnerabilities*/
        ctx[29].length
      ),
      $$slots: { default: [create_default_slot_5$t] },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_4*/
    ctx[13]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.traitCssClass = /*$context*/
      ctx2[3].traits.traits?.dv?.cssClass ?? "";
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*vulnerabilities*/
      ctx2[29].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_5$t(ctx) {
  let traitsectiontags;
  let current;
  traitsectiontags = new TraitSectionTags({
    props: { tags: (
      /*vulnerabilities*/
      ctx[29]
    ) }
  });
  return {
    c() {
      create_component(traitsectiontags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontags_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontags_changes.tags = /*vulnerabilities*/
      ctx2[29];
      traitsectiontags.$set(traitsectiontags_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontags, detaching);
    }
  };
}
function create_if_block_9$b(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      title: (
        /*localize*/
        ctx[8]("DND5E.DamageModification.Label")
      ),
      iconCssClass: "fas fa-heart-circle-plus",
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.DamageModification.Label")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*$context*/
        ctx[3].traits.traits.dm.length
      ),
      $$slots: { default: [create_default_slot_4$y] },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_5*/
    ctx[14]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*$context*/
      ctx2[3].traits.traits.dm.length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_4$y(ctx) {
  let traitsectionmodifications;
  let current;
  traitsectionmodifications = new TraitSectionModifications({
    props: {
      modifications: (
        /*$context*/
        ctx[3].traits.traits?.dm
      )
    }
  });
  return {
    c() {
      create_component(traitsectionmodifications.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectionmodifications, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectionmodifications_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectionmodifications_changes.modifications = /*$context*/
      ctx2[3].traits.traits?.dm;
      traitsectionmodifications.$set(traitsectionmodifications_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectionmodifications.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectionmodifications.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectionmodifications, detaching);
    }
  };
}
function create_if_block_8$c(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      traitCssClass: (
        /*$context*/
        ctx[3].traits.traits?.ci?.cssClass ?? ""
      ),
      title: (
        /*localize*/
        ctx[8]("DND5E.ConImm")
      ),
      iconCssClass: "fas fa-shield-virus",
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.ConImm")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*conditionImmunities*/
        ctx[28].length
      ),
      $$slots: { default: [create_default_slot_3$D] },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_6*/
    ctx[15]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.traitCssClass = /*$context*/
      ctx2[3].traits.traits?.ci?.cssClass ?? "";
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*conditionImmunities*/
      ctx2[28].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_3$D(ctx) {
  let traitsectiontags;
  let current;
  traitsectiontags = new TraitSectionTags({
    props: { tags: (
      /*conditionImmunities*/
      ctx[28]
    ) }
  });
  return {
    c() {
      create_component(traitsectiontags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontags_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontags_changes.tags = /*conditionImmunities*/
      ctx2[28];
      traitsectiontags.$set(traitsectiontags_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontags, detaching);
    }
  };
}
function create_if_block_7$g(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      traitCssClass: (
        /*$context*/
        ctx[3].traits.traits?.weaponProf?.cssClass ?? ""
      ),
      title: (
        /*localize*/
        ctx[8]("DND5E.TraitWeaponProf")
      ),
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.TraitWeaponProf")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*weaponProfs*/
        ctx[27].length
      ),
      $$slots: {
        "custom-icon": [create_custom_icon_slot_1],
        default: [create_default_slot_2$E]
      },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_7*/
    ctx[16]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.traitCssClass = /*$context*/
      ctx2[3].traits.traits?.weaponProf?.cssClass ?? "";
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*weaponProfs*/
      ctx2[27].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_2$E(ctx) {
  let traitsectiontags;
  let current;
  traitsectiontags = new TraitSectionTags({ props: { tags: (
    /*weaponProfs*/
    ctx[27]
  ) } });
  return {
    c() {
      create_component(traitsectiontags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontags_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontags_changes.tags = /*weaponProfs*/
      ctx2[27];
      traitsectiontags.$set(traitsectiontags_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontags, detaching);
    }
  };
}
function create_custom_icon_slot_1(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M443.7,2.6c-2.2-2.5-5.8-3.3-8.8-1.8C417.9,9,358.8,36.1,304.4,43.5c-4.1,0.6-8-0.3-11.3-2.1c-1.5-0.8-2.4-2.5-2.4-4.2v0\n        c0-10.7-8.7-19.4-19.5-19.4h-30.5c-10.7,0-19.5,8.7-19.5,19.4v0c0,1.7-0.9,3.4-2.4,4.2c-3.3,1.8-7.2,2.7-11.3,2.1\n        C153.2,36.1,94.2,9,77.1,0.7c-3-1.5-6.6-0.7-8.8,1.8C56.3,16.4,21,64.9,21,154.9c0,83.4,30.3,143.6,44.3,166.9\n        c2.9,4.9,10,4.7,12.8-0.2c10.5-19,34-59.1,62-91.7c0.4-0.5,0.9-1,1.3-1.5c28.3-30.7,79.9-9.8,79.9,32v232.2\n        c0,10.7,8.7,19.4,19.5,19.4h30.5c10.7,0,19.5-8.7,19.5-19.4V260.4c0-41.8,51.5-62.7,79.9-32c0.4,0.5,0.9,1,1.3,1.5\n        c28,32.6,51.5,72.7,62,91.7c2.8,5,9.9,5.1,12.8,0.2c14-23.3,44.3-83.4,44.3-166.9C491,64.9,455.7,16.4,443.7,2.6z");
      attr(path, "class", "svelte-f6iv97");
      attr(svg, "slot", "custom-icon");
      attr(svg, "x", "0px");
      attr(svg, "y", "0px");
      attr(svg, "viewBox", "0 0 512 512");
      attr(svg, "xml:space", "preserve");
      attr(svg, "class", "svelte-f6iv97");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_6$i(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      traitCssClass: (
        /*$context*/
        ctx[3].traits.traits?.armorProf?.cssClass ?? ""
      ),
      title: (
        /*localize*/
        ctx[8]("DND5E.TraitArmorProf")
      ),
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.TraitArmorProf")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*armorProfs*/
        ctx[26].length
      ),
      $$slots: {
        "custom-icon": [create_custom_icon_slot],
        default: [create_default_slot_1$P]
      },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_8*/
    ctx[17]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.traitCssClass = /*$context*/
      ctx2[3].traits.traits?.armorProf?.cssClass ?? "";
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*armorProfs*/
      ctx2[26].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_default_slot_1$P(ctx) {
  let traitsectiontags;
  let current;
  traitsectiontags = new TraitSectionTags({ props: { tags: (
    /*armorProfs*/
    ctx[26]
  ) } });
  return {
    c() {
      create_component(traitsectiontags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontags_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontags_changes.tags = /*armorProfs*/
      ctx2[26];
      traitsectiontags.$set(traitsectiontags_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontags, detaching);
    }
  };
}
function create_custom_icon_slot(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M471.7,198.8c0-56.6-37.8-107.3-81.7-147.1c-76-68.9-191.9-68.9-268,0c-43.9,39.8-81.7,90.5-81.7,147.1\n      c0,93-3.2,163.9-12.5,203c-3.9,16.2,4,33,18.3,39.6l113.6,66.3c27.9,13.6,60.3-6.7,60.3-37.7V258.3c0-5.2-3.3-9.8-8.3-11.5\n      l-91.3-30.4c-4.9-1.6-8.3-6.3-8.3-11.5v-15.1c0-6.7,5.4-12.1,12.1-12.1h263.4c6.7,0,12.1,5.4,12.1,12.1v15.1c0,5.2-3.3,9.8-8.3,11.5\n      l-91.3,30.4c-4.9,1.6-8.3,6.3-8.3,11.5V470c0,31,32.5,51.3,60.3,37.7l113.6-66.3c14.3-6.6,22.2-23.4,18.3-39.6\n      C474.9,362.7,471.7,291.8,471.7,198.8L471.7,198.8z");
      attr(path, "class", "svelte-f6iv97");
      attr(svg, "slot", "custom-icon");
      attr(svg, "x", "0px");
      attr(svg, "y", "0px");
      attr(svg, "viewBox", "0 0 512 512");
      attr(svg, "xml:space", "preserve");
      attr(svg, "class", "svelte-f6iv97");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_4$t(ctx) {
  let traitsection;
  let current;
  traitsection = new TraitSection({
    props: {
      traitCssClass: (
        /*$context*/
        ctx[3].traits.tools?.toolProf?.cssClass ?? ""
      ),
      title: (
        /*localize*/
        ctx[8]("DND5E.TraitToolProf")
      ),
      iconCssClass: "fas fa-hammer",
      configureButtonTitle: (
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.TraitToolProf")
          )
        })
      ),
      show: (
        /*traitsExpanded*/
        ctx[4] || !!/*tools*/
        ctx[25].length
      ),
      $$slots: { default: [create_default_slot$1s] },
      $$scope: { ctx }
    }
  });
  traitsection.$on(
    "onConfigureClicked",
    /*onConfigureClicked_handler_9*/
    ctx[18]
  );
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.traitCssClass = /*$context*/
      ctx2[3].traits.tools?.toolProf?.cssClass ?? "";
      if (dirty[0] & /*traitsExpanded, $context*/
      24) traitsection_changes.show = /*traitsExpanded*/
      ctx2[4] || !!/*tools*/
      ctx2[25].length;
      if (dirty[0] & /*$context*/
      8 | dirty[1] & /*$$scope*/
      8) {
        traitsection_changes.$$scope = { dirty, ctx: ctx2 };
      }
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_if_block_5$p(ctx) {
  let traitsectiontools;
  let current;
  traitsectiontools = new TraitSectionTools({ props: { tools: (
    /*tools*/
    ctx[25]
  ) } });
  return {
    c() {
      create_component(traitsectiontools.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsectiontools, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traitsectiontools_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsectiontools_changes.tools = /*tools*/
      ctx2[25];
      traitsectiontools.$set(traitsectiontools_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsectiontools.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsectiontools.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsectiontools, detaching);
    }
  };
}
function create_default_slot$1s(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*tools*/
    ctx[25].length && create_if_block_5$p(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*tools*/
        ctx2[25].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$p(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_3$D(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[3].customActorTraits
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$10(get_each_context$10(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$context, traitsExpanded*/
      24) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[3].customActorTraits
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$10(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$10(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$10(ctx) {
  let traitsection;
  let current;
  function onConfigureClicked_handler_10(...args) {
    return (
      /*onConfigureClicked_handler_10*/
      ctx[19](
        /*trait*/
        ctx[22],
        ...args
      )
    );
  }
  traitsection = new TraitSection({
    props: {
      title: (
        /*trait*/
        ctx[22].title
      ),
      iconCssClass: (
        /*trait*/
        ctx[22].iconClass
      ),
      configureButtonTitle: (
        /*trait*/
        ctx[22].openConfigurationTooltip ?? ""
      ),
      show: (
        /*trait*/
        ctx[22].alwaysShow || /*traitsExpanded*/
        ctx[4]
      )
    }
  });
  traitsection.$on("onConfigureClicked", onConfigureClicked_handler_10);
  return {
    c() {
      create_component(traitsection.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traitsection, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const traitsection_changes = {};
      if (dirty[0] & /*$context*/
      8) traitsection_changes.title = /*trait*/
      ctx[22].title;
      if (dirty[0] & /*$context*/
      8) traitsection_changes.iconCssClass = /*trait*/
      ctx[22].iconClass;
      if (dirty[0] & /*$context*/
      8) traitsection_changes.configureButtonTitle = /*trait*/
      ctx[22].openConfigurationTooltip ?? "";
      if (dirty[0] & /*$context, traitsExpanded*/
      24) traitsection_changes.show = /*trait*/
      ctx[22].alwaysShow || /*traitsExpanded*/
      ctx[4];
      traitsection.$set(traitsection_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traitsection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traitsection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traitsection, detaching);
    }
  };
}
function create_if_block_1$10(ctx) {
  let button;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*traitsExpanded*/
      ctx2[4]
    ) return create_if_block_2$P;
    return create_else_block$Z;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "type", "button");
      attr(button, "class", "toggle-traits inline-transparent-button svelte-f6iv97");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*click_handler*/
          ctx[20]
        )));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$Z(ctx) {
  let t_value = (
    /*localize*/
    ctx[8]("TIDY5E.ShowEmptyTraits") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_2$P(ctx) {
  let t_value = (
    /*localize*/
    ctx[8]("TIDY5E.HideEmptyTraits") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$1K(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-star svelte-f6iv97");
      attr(button, "type", "button");
      attr(button, "class", "configure-special-traits inline-icon-button svelte-f6iv97");
      attr(
        button,
        "title",
        /*localize*/
        ctx[8]("DND5E.TraitConfig", {
          trait: (
            /*localize*/
            ctx[8]("DND5E.SpecialTraits")
          )
        })
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*click_handler_1*/
          ctx[21]
        )));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3S(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let current;
  let if_block0 = (
    /*useSenses*/
    ctx[1] && /*$context*/
    ctx[3].senses && create_if_block_14$6(get_if_ctx_8(ctx))
  );
  let if_block1 = (
    /*$context*/
    ctx[3].traits?.traits?.languages && create_if_block_13$6(get_if_ctx_7(ctx))
  );
  let if_block2 = (
    /*$context*/
    ctx[3].traits.traits?.di && create_if_block_12$7(get_if_ctx_6(ctx))
  );
  let if_block3 = (
    /*$context*/
    ctx[3].traits.traits?.dr && create_if_block_11$8(get_if_ctx_5(ctx))
  );
  let if_block4 = (
    /*$context*/
    ctx[3].traits.traits?.dv && create_if_block_10$9(get_if_ctx_4(ctx))
  );
  let if_block5 = (
    /*$context*/
    ctx[3].traits.traits?.dm && create_if_block_9$b(ctx)
  );
  let if_block6 = (
    /*$context*/
    ctx[3].traits.traits?.ci && create_if_block_8$c(get_if_ctx_3(ctx))
  );
  let if_block7 = (
    /*$context*/
    ctx[3].traits.traits?.weaponProf && create_if_block_7$g(get_if_ctx_2(ctx))
  );
  let if_block8 = (
    /*$context*/
    ctx[3].traits.traits?.armorProf && create_if_block_6$i(get_if_ctx_1(ctx))
  );
  let if_block9 = (
    /*$context*/
    ctx[3].traits.tools && create_if_block_4$t(get_if_ctx$g(ctx))
  );
  let if_block10 = (
    /*$context*/
    ctx[3].customActorTraits?.length && create_if_block_3$D(ctx)
  );
  let if_block11 = (
    /*toggleable*/
    ctx[0] && create_if_block_1$10(ctx)
  );
  let if_block12 = (
    /*enableSpecialTraitsConfiguration*/
    ctx[2] && !/*$context*/
    ctx[3].lockSensitiveFields && create_if_block$1K(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      if (if_block3) if_block3.c();
      t3 = space();
      if (if_block4) if_block4.c();
      t4 = space();
      if (if_block5) if_block5.c();
      t5 = space();
      if (if_block6) if_block6.c();
      t6 = space();
      if (if_block7) if_block7.c();
      t7 = space();
      if (if_block8) if_block8.c();
      t8 = space();
      if (if_block9) if_block9.c();
      t9 = space();
      if (if_block10) if_block10.c();
      t10 = space();
      if (if_block11) if_block11.c();
      t11 = space();
      if (if_block12) if_block12.c();
      attr(div, "class", "traits svelte-f6iv97");
      toggle_class(div, "expanded", TidyFlags.traitsExpanded.get(
        /*$context*/
        ctx[3].actor
      ));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if (if_block1) if_block1.m(div, null);
      append(div, t1);
      if (if_block2) if_block2.m(div, null);
      append(div, t2);
      if (if_block3) if_block3.m(div, null);
      append(div, t3);
      if (if_block4) if_block4.m(div, null);
      append(div, t4);
      if (if_block5) if_block5.m(div, null);
      append(div, t5);
      if (if_block6) if_block6.m(div, null);
      append(div, t6);
      if (if_block7) if_block7.m(div, null);
      append(div, t7);
      if (if_block8) if_block8.m(div, null);
      append(div, t8);
      if (if_block9) if_block9.m(div, null);
      append(div, t9);
      if (if_block10) if_block10.m(div, null);
      append(div, t10);
      if (if_block11) if_block11.m(div, null);
      append(div, t11);
      if (if_block12) if_block12.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*useSenses*/
        ctx2[1] && /*$context*/
        ctx2[3].senses
      ) {
        if (if_block0) {
          if_block0.p(get_if_ctx_8(ctx2), dirty);
          if (dirty[0] & /*useSenses, $context*/
          10) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14$6(get_if_ctx_8(ctx2));
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits?.traits?.languages
      ) {
        if (if_block1) {
          if_block1.p(get_if_ctx_7(ctx2), dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_13$6(get_if_ctx_7(ctx2));
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits.traits?.di
      ) {
        if (if_block2) {
          if_block2.p(get_if_ctx_6(ctx2), dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_12$7(get_if_ctx_6(ctx2));
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits.traits?.dr
      ) {
        if (if_block3) {
          if_block3.p(get_if_ctx_5(ctx2), dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_11$8(get_if_ctx_5(ctx2));
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits.traits?.dv
      ) {
        if (if_block4) {
          if_block4.p(get_if_ctx_4(ctx2), dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_10$9(get_if_ctx_4(ctx2));
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits.traits?.dm
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_9$b(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div, t5);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits.traits?.ci
      ) {
        if (if_block6) {
          if_block6.p(get_if_ctx_3(ctx2), dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_8$c(get_if_ctx_3(ctx2));
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div, t6);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits.traits?.weaponProf
      ) {
        if (if_block7) {
          if_block7.p(get_if_ctx_2(ctx2), dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_7$g(get_if_ctx_2(ctx2));
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div, t7);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits.traits?.armorProf
      ) {
        if (if_block8) {
          if_block8.p(get_if_ctx_1(ctx2), dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block8, 1);
          }
        } else {
          if_block8 = create_if_block_6$i(get_if_ctx_1(ctx2));
          if_block8.c();
          transition_in(if_block8, 1);
          if_block8.m(div, t8);
        }
      } else if (if_block8) {
        group_outros();
        transition_out(if_block8, 1, 1, () => {
          if_block8 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].traits.tools
      ) {
        if (if_block9) {
          if_block9.p(get_if_ctx$g(ctx2), dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block9, 1);
          }
        } else {
          if_block9 = create_if_block_4$t(get_if_ctx$g(ctx2));
          if_block9.c();
          transition_in(if_block9, 1);
          if_block9.m(div, t9);
        }
      } else if (if_block9) {
        group_outros();
        transition_out(if_block9, 1, 1, () => {
          if_block9 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].customActorTraits?.length
      ) {
        if (if_block10) {
          if_block10.p(ctx2, dirty);
          if (dirty[0] & /*$context*/
          8) {
            transition_in(if_block10, 1);
          }
        } else {
          if_block10 = create_if_block_3$D(ctx2);
          if_block10.c();
          transition_in(if_block10, 1);
          if_block10.m(div, t10);
        }
      } else if (if_block10) {
        group_outros();
        transition_out(if_block10, 1, 1, () => {
          if_block10 = null;
        });
        check_outros();
      }
      if (
        /*toggleable*/
        ctx2[0]
      ) {
        if (if_block11) {
          if_block11.p(ctx2, dirty);
        } else {
          if_block11 = create_if_block_1$10(ctx2);
          if_block11.c();
          if_block11.m(div, t11);
        }
      } else if (if_block11) {
        if_block11.d(1);
        if_block11 = null;
      }
      if (
        /*enableSpecialTraitsConfiguration*/
        ctx2[2] && !/*$context*/
        ctx2[3].lockSensitiveFields
      ) {
        if (if_block12) {
          if_block12.p(ctx2, dirty);
        } else {
          if_block12 = create_if_block$1K(ctx2);
          if_block12.c();
          if_block12.m(div, null);
        }
      } else if (if_block12) {
        if_block12.d(1);
        if_block12 = null;
      }
      if (!current || dirty[0] & /*$context*/
      8) {
        toggle_class(div, "expanded", TidyFlags.traitsExpanded.get(
          /*$context*/
          ctx2[3].actor
        ));
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(if_block7);
      transition_in(if_block8);
      transition_in(if_block9);
      transition_in(if_block10);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(if_block7);
      transition_out(if_block8);
      transition_out(if_block9);
      transition_out(if_block10);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      if (if_block5) if_block5.d();
      if (if_block6) if_block6.d();
      if (if_block7) if_block7.d();
      if (if_block8) if_block8.d();
      if (if_block9) if_block9.d();
      if (if_block10) if_block10.d();
      if (if_block11) if_block11.d();
      if (if_block12) if_block12.d();
    }
  };
}
function getTags(obj) {
  return Object.entries(obj);
}
function instance$3R($$self, $$props, $$invalidate) {
  let traitsExpanded;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  let { toggleable } = $$props;
  let { useSenses = true } = $$props;
  let { enableSpecialTraitsConfiguration = true } = $$props;
  function toggleTraitsExpanded() {
    if (traitsExpanded) {
      TidyFlags.traitsExpanded.unset($context.actor);
    } else {
      TidyFlags.traitsExpanded.set($context.actor, true);
    }
  }
  const localize = FoundryAdapter.localize;
  const onConfigureClicked_handler = () => FoundryAdapter.renderActorSensesConfig($context.actor);
  const onConfigureClicked_handler_1 = () => FoundryAdapter.renderTraitsSelector($context.actor, "languages");
  const onConfigureClicked_handler_2 = () => FoundryAdapter.renderTraitsSelector($context.actor, "di");
  const onConfigureClicked_handler_3 = () => FoundryAdapter.renderTraitsSelector($context.actor, "dr");
  const onConfigureClicked_handler_4 = () => FoundryAdapter.renderTraitsSelector($context.actor, "dv");
  const onConfigureClicked_handler_5 = () => FoundryAdapter.openDamageModificationConfig($context.actor);
  const onConfigureClicked_handler_6 = () => FoundryAdapter.renderTraitsSelector($context.actor, "ci");
  const onConfigureClicked_handler_7 = () => FoundryAdapter.renderTraitsSelector($context.actor, "weapon");
  const onConfigureClicked_handler_8 = () => FoundryAdapter.renderTraitsSelector($context.actor, "armor");
  const onConfigureClicked_handler_9 = () => FoundryAdapter.renderToolSelector($context.actor);
  const onConfigureClicked_handler_10 = (trait, ev) => {
    try {
      trait.openConfiguration?.({
        app: $context.actor.sheet,
        data: $context,
        element: $context.actor.sheet.element.get(0),
        event: ev.detail
      });
    } catch (e2) {
      error("An error occurred while handling trait configuration click event", false, e2);
    }
  };
  const click_handler = () => toggleTraitsExpanded();
  const click_handler_1 = () => FoundryAdapter.renderActorSheetFlags($context.actor);
  $$self.$$set = ($$props2) => {
    if ("toggleable" in $$props2) $$invalidate(0, toggleable = $$props2.toggleable);
    if ("useSenses" in $$props2) $$invalidate(1, useSenses = $$props2.useSenses);
    if ("enableSpecialTraitsConfiguration" in $$props2) $$invalidate(2, enableSpecialTraitsConfiguration = $$props2.enableSpecialTraitsConfiguration);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*toggleable, $context*/
    9) {
      $$invalidate(4, traitsExpanded = !toggleable || TidyFlags.traitsExpanded.get($context.actor) === true);
    }
  };
  return [
    toggleable,
    useSenses,
    enableSpecialTraitsConfiguration,
    $context,
    traitsExpanded,
    $settingStore,
    context,
    toggleTraitsExpanded,
    localize,
    onConfigureClicked_handler,
    onConfigureClicked_handler_1,
    onConfigureClicked_handler_2,
    onConfigureClicked_handler_3,
    onConfigureClicked_handler_4,
    onConfigureClicked_handler_5,
    onConfigureClicked_handler_6,
    onConfigureClicked_handler_7,
    onConfigureClicked_handler_8,
    onConfigureClicked_handler_9,
    onConfigureClicked_handler_10,
    click_handler,
    click_handler_1
  ];
}
class Traits extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3R,
      create_fragment$3S,
      safe_not_equal,
      {
        toggleable: 0,
        useSenses: 1,
        enableSpecialTraitsConfiguration: 2
      },
      null,
      [-1, -1]
    );
  }
}
function create_fragment$3R(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      attr(div0, "role", "presentation");
      attr(div0, "class", "expandable-child-animation-wrapper");
      attr(div1, "class", div1_class_value = "expandable " + /*$$restProps*/
      (ctx[3].class ?? "") + " svelte-cgte90");
      attr(div1, "role", "presentation");
      toggle_class(
        div1,
        "expanded",
        /*expanded*/
        ctx[0]
      );
      toggle_class(
        div1,
        "overflow-y-hidden",
        /*overflowYHidden*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[6](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$$restProps*/
      8 && div1_class_value !== (div1_class_value = "expandable " + /*$$restProps*/
      (ctx2[3].class ?? "") + " svelte-cgte90")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*$$restProps, expanded*/
      9) {
        toggle_class(
          div1,
          "expanded",
          /*expanded*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$$restProps, overflowYHidden*/
      10) {
        toggle_class(
          div1,
          "overflow-y-hidden",
          /*overflowYHidden*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[6](null);
    }
  };
}
function instance$3Q($$self, $$props, $$invalidate) {
  const omit_props_names = ["expanded"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { expanded = true } = $$props;
  let overflowYHidden = !expanded;
  let expandableContainer;
  onMount(() => {
    expandableContainer.addEventListener("transitionstart", () => {
      $$invalidate(1, overflowYHidden = true);
    });
    expandableContainer.addEventListener("transitionend", () => {
      $$invalidate(1, overflowYHidden = !expanded);
    });
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      expandableContainer = $$value;
      $$invalidate(2, expandableContainer);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expanded" in $$new_props) $$invalidate(0, expanded = $$new_props.expanded);
    if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  return [
    expanded,
    overflowYHidden,
    expandableContainer,
    $$restProps,
    $$scope,
    slots,
    div1_binding
  ];
}
class ExpandableContainer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Q, create_fragment$3R, safe_not_equal, { expanded: 0 });
  }
}
class ExpandCollapseService {
  static contextKey = "expandCollapseService";
  _onItemTableToggle;
  _location;
  _state;
  state;
  constructor(initialState = {
    expanded: true,
    toggleable: true
  }) {
    this._state = writable({ ...initialState });
    this.state = this._state;
    this._onItemTableToggle = getContext(
      CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TABLE_TOGGLE
    );
    this._location = getContext(CONSTANTS.SVELTE_CONTEXT.LOCATION);
  }
  toggle() {
    this._state.update((current) => {
      const newState = !current.expanded;
      this._tryCacheExpandedState(newState);
      return {
        ...current,
        expanded: newState
      };
    });
  }
  _tryCacheExpandedState(newState) {
    if (!!this._location) {
      this._onItemTableToggle?.(this._location, newState);
    }
  }
  set(expanded) {
    this._state.update((current) => {
      return {
        ...current,
        expanded
      };
    });
    this._tryCacheExpandedState(expanded);
  }
  static initService(toggleable) {
    const itemTableToggles = getContext(
      CONSTANTS.SVELTE_CONTEXT.ITEM_TABLE_TOGGLES
    );
    const location = getContext(CONSTANTS.SVELTE_CONTEXT.LOCATION) ?? "";
    const service = new ExpandCollapseService({
      expanded: itemTableToggles?.get(location) ?? true,
      toggleable
    });
    setContext(ExpandCollapseService.contextKey, service);
    return service;
  }
  static getService() {
    return getContext(ExpandCollapseService.contextKey);
  }
}
const get_body_slot_changes$1 = (dirty) => ({});
const get_body_slot_context$1 = (ctx) => ({});
const get_header_slot_changes$2 = (dirty) => ({});
const get_header_slot_context$2 = (ctx) => ({});
function create_default_slot$1r(ctx) {
  let div;
  let current;
  const body_slot_template = (
    /*#slots*/
    ctx[8].body
  );
  const body_slot = create_slot(
    body_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_body_slot_context$1
  );
  return {
    c() {
      div = element("div");
      if (body_slot) body_slot.c();
      attr(div, "class", "item-table-body");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (body_slot) {
        body_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (body_slot) {
        if (body_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            body_slot,
            body_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              body_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_body_slot_changes$1
            ),
            get_body_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(body_slot, local);
      current = true;
    },
    o(local) {
      transition_out(body_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (body_slot) body_slot.d(detaching);
    }
  };
}
function create_fragment$3Q(ctx) {
  let section;
  let t2;
  let expandablecontainer;
  let section_class_value;
  let section_data_tidy_sheet_part_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[8].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_header_slot_context$2
  );
  expandablecontainer = new ExpandableContainer({
    props: {
      expanded: (
        /*$expandedState*/
        ctx[2].expanded
      ),
      $$slots: { default: [create_default_slot$1r] },
      $$scope: { ctx }
    }
  });
  let section_levels = [
    {
      class: section_class_value = "item-table " + /*cssClass*/
      (ctx[3] ?? "")
    },
    {
      "data-tidy-sheet-part": section_data_tidy_sheet_part_value = CONSTANTS.SHEET_PARTS.ITEM_TABLE
    },
    { "data-tidy-section-key": (
      /*key*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[4]
  ];
  let section_data = {};
  for (let i2 = 0; i2 < section_levels.length; i2 += 1) {
    section_data = assign(section_data, section_levels[i2]);
  }
  return {
    c() {
      section = element("section");
      if (header_slot) header_slot.c();
      t2 = space();
      create_component(expandablecontainer.$$.fragment);
      set_attributes(section, section_data);
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (header_slot) {
        header_slot.m(section, null);
      }
      append(section, t2);
      mount_component(expandablecontainer, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_header_slot_changes$2
            ),
            get_header_slot_context$2
          );
        }
      }
      const expandablecontainer_changes = {};
      if (dirty & /*$expandedState*/
      4) expandablecontainer_changes.expanded = /*$expandedState*/
      ctx2[2].expanded;
      if (dirty & /*$$scope*/
      512) {
        expandablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandablecontainer.$set(expandablecontainer_changes);
      set_attributes(section, section_data = get_spread_update(section_levels, [
        { class: section_class_value },
        {
          "data-tidy-sheet-part": section_data_tidy_sheet_part_value
        },
        (!current || dirty & /*key*/
        1) && { "data-tidy-section-key": (
          /*key*/
          ctx2[0]
        ) },
        /*attributes*/
        ctx2[4]
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      transition_in(expandablecontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(expandablecontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (header_slot) header_slot.d(detaching);
      destroy_component(expandablecontainer);
    }
  };
}
function instance$3P($$self, $$props, $$invalidate) {
  let expandedState;
  const omit_props_names = ["key", "toggleable"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $messageBus;
  let $expandedState, $$unsubscribe_expandedState = noop$1, $$subscribe_expandedState = () => ($$unsubscribe_expandedState(), $$unsubscribe_expandedState = subscribe(expandedState, ($$value) => $$invalidate(2, $expandedState = $$value)), expandedState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_expandedState());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { key } = $$props;
  let { toggleable = true } = $$props;
  let { class: cssClass, ...attributes } = $$restProps;
  const messageBus = getContext(CONSTANTS.SVELTE_CONTEXT.MESSAGE_BUS);
  component_subscribe($$self, messageBus, (value) => $$invalidate(7, $messageBus = value));
  const tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  declareLocation("item-table", key);
  const expandCollapseService = ExpandCollapseService.initService(toggleable);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("key" in $$new_props) $$invalidate(0, key = $$new_props.key);
    if ("toggleable" in $$new_props) $$invalidate(6, toggleable = $$new_props.toggleable);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$messageBus*/
    128) {
      {
        if ($messageBus?.tabId === tabId && $messageBus?.message === CONSTANTS.MESSAGE_BUS_EXPAND_ALL) {
          expandCollapseService.set(true);
        }
        if ($messageBus?.tabId === tabId && $messageBus?.message === CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL) {
          expandCollapseService.set(false);
        }
      }
    }
  };
  $$subscribe_expandedState($$invalidate(1, expandedState = expandCollapseService.state));
  return [
    key,
    expandedState,
    $expandedState,
    cssClass,
    attributes,
    messageBus,
    toggleable,
    $messageBus,
    slots,
    $$scope
  ];
}
class ItemTable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3P, create_fragment$3Q, safe_not_equal, { key: 0, toggleable: 6 });
  }
}
const inputTagNames = /* @__PURE__ */ new Set([
  "INPUT",
  "BUTTON",
  "SELECT",
  "COLOR",
  "DATE",
  "DATETIME-LOCAL",
  "EMAIL",
  "FILE",
  "HIDDEN",
  "A"
]);
const inputTabNamesSelector = Array.from(inputTagNames).map((i2) => i2.toLowerCase()).join(", ");
function isUserInteractable(el) {
  return (
    // Is it one of the known interactables?
    inputTagNames.has(el.tagName) || // Is it contained within an interactable?
    el.closest(inputTabNamesSelector)
  );
}
function create_if_block$1J(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "expand-indicator fas fa-angle-right svelte-1x4fy16");
      attr(i2, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.EXPANSION_TOGGLE);
      toggle_class(
        i2,
        "expanded",
        /*$expandState*/
        ctx[1].expanded
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$expandState*/
      2) {
        toggle_class(
          i2,
          "expanded",
          /*$expandState*/
          ctx2[1].expanded
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_fragment$3P(ctx) {
  let header;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$expandState*/
    ctx[1].toggleable && create_if_block$1J(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      header = element("header");
      if (if_block) if_block.c();
      t2 = space();
      if (default_slot) default_slot.c();
      attr(header, "class", "item-table-header-row svelte-1x4fy16");
      attr(header, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_TABLE_HEADER_ROW);
      toggle_class(
        header,
        "toggleable",
        /*$expandState*/
        ctx[1].toggleable
      );
    },
    m(target, anchor) {
      insert(target, header, anchor);
      if (if_block) if_block.m(header, null);
      append(header, t2);
      if (default_slot) {
        default_slot.m(header, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          header,
          "click",
          /*handleHeaderRowClick*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$expandState*/
        ctx2[1].toggleable
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1J(ctx2);
          if_block.c();
          if_block.m(header, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$expandState*/
      2) {
        toggle_class(
          header,
          "toggleable",
          /*$expandState*/
          ctx2[1].toggleable
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$3O($$self, $$props, $$invalidate) {
  let expandState;
  let $expandState, $$unsubscribe_expandState = noop$1, $$subscribe_expandState = () => ($$unsubscribe_expandState(), $$unsubscribe_expandState = subscribe(expandState, ($$value) => $$invalidate(1, $expandState = $$value)), expandState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_expandState());
  let { $$slots: slots = {}, $$scope } = $$props;
  const expandCollapseService = ExpandCollapseService.getService();
  function handleHeaderRowClick(ev) {
    if (!$expandState.toggleable) {
      return;
    }
    if (ev.target instanceof HTMLElement && isUserInteractable(ev.target) && ev.target.getAttribute(CONSTANTS.SHEET_PART_ATTRIBUTE) !== CONSTANTS.SHEET_PARTS.EXPANSION_TOGGLE) {
      return;
    }
    ev.stopPropagation();
    expandCollapseService.toggle();
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$subscribe_expandState($$invalidate(0, expandState = expandCollapseService.state));
  return [expandState, $expandState, handleHeaderRowClick, $$scope, slots];
}
class ItemTableHeaderRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3O, create_fragment$3P, safe_not_equal, {});
  }
}
class ItemSummaryRuntime {
  static _itemSummaryCommands = [];
  static registerItemSummaryCommands(commands) {
    ItemSummaryRuntime._itemSummaryCommands.push(...commands);
  }
  static getItemSummaryCommands(item) {
    return [...ItemSummaryRuntime._itemSummaryCommands].filter(
      (c2) => item && (c2.enabled?.({ item }) ?? true)
    );
  }
}
function create_if_block$1I(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = null_to_empty(
        /*command*/
        ctx[0].iconClass
      ) + " svelte-5inzn8");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*command*/
      1 && i_class_value !== (i_class_value = null_to_empty(
        /*command*/
        ctx2[0].iconClass
      ) + " svelte-5inzn8")) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_fragment$3O(ctx) {
  let button;
  let t0;
  let t1_value = FoundryAdapter.localize(
    /*command*/
    ctx[0].label ?? ""
  ) + "";
  let t1;
  let button_title_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  let if_block = (
    /*command*/
    ctx[0].iconClass && create_if_block$1I(ctx)
  );
  return {
    c() {
      button = element("button");
      if (if_block) if_block.c();
      t0 = space();
      t1 = text(t1_value);
      attr(button, "type", "button");
      attr(button, "class", "item-summary-command svelte-5inzn8");
      attr(button, "title", button_title_value = /*command*/
      ctx[0].tooltip ?? null);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block) if_block.m(button, null);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*command*/
        ctx2[0].iconClass
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1I(ctx2);
          if_block.c();
          if_block.m(button, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*command*/
      1 && t1_value !== (t1_value = FoundryAdapter.localize(
        /*command*/
        ctx2[0].label ?? ""
      ) + "")) set_data(t1, t1_value);
      if (dirty & /*command*/
      1 && button_title_value !== (button_title_value = /*command*/
      ctx2[0].tooltip ?? null)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$3N($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let { command } = $$props;
  let { item } = $$props;
  const click_handler = () => command.execute?.({ item });
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2) $$invalidate(0, command = $$props2.command);
    if ("item" in $$props2) $$invalidate(1, item = $$props2.item);
  };
  return [command, item, $settingStore, click_handler];
}
class ItemSummaryCommandButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3N, create_fragment$3O, safe_not_equal, { command: 0, item: 1 });
  }
}
function get_each_context$$(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  return child_ctx;
}
function create_each_block$$(ctx) {
  let itemsummarycommandbutton;
  let current;
  itemsummarycommandbutton = new ItemSummaryCommandButton({
    props: {
      item: (
        /*item*/
        ctx[0]
      ),
      command: (
        /*command*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(itemsummarycommandbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemsummarycommandbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemsummarycommandbutton_changes = {};
      if (dirty & /*item*/
      1) itemsummarycommandbutton_changes.item = /*item*/
      ctx2[0];
      if (dirty & /*itemSummaryCommands*/
      2) itemsummarycommandbutton_changes.command = /*command*/
      ctx2[2];
      itemsummarycommandbutton.$set(itemsummarycommandbutton_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemsummarycommandbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemsummarycommandbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemsummarycommandbutton, detaching);
    }
  };
}
function create_fragment$3N(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*itemSummaryCommands*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$$(get_each_context$$(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*item, itemSummaryCommands*/
      3) {
        each_value = ensure_array_like(
          /*itemSummaryCommands*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$$(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$$(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3M($$self, $$props, $$invalidate) {
  let itemSummaryCommands;
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(1, itemSummaryCommands = ItemSummaryRuntime.getItemSummaryCommands(item));
    }
  };
  return [item, itemSummaryCommands];
}
class ItemSummaryCommandButtonList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3M, create_fragment$3N, safe_not_equal, { item: 0 });
  }
}
function create_fragment$3M(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "aria-hidden", "true");
      attr(div, "role", "presentation");
      attr(div, "class", div_class_value = "horizontal-line-separator " + /*borderColor*/
      ctx[0] + " " + /*cssClass*/
      ctx[1] + " svelte-p11z6r");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*borderColor, cssClass*/
      3 && div_class_value !== (div_class_value = "horizontal-line-separator " + /*borderColor*/
      ctx2[0] + " " + /*cssClass*/
      ctx2[1] + " svelte-p11z6r")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$3L($$self, $$props, $$invalidate) {
  let { borderColor = "faint" } = $$props;
  let { cssClass = null } = $$props;
  $$self.$$set = ($$props2) => {
    if ("borderColor" in $$props2) $$invalidate(0, borderColor = $$props2.borderColor);
    if ("cssClass" in $$props2) $$invalidate(1, cssClass = $$props2.cssClass);
  };
  return [borderColor, cssClass];
}
class HorizontalLineSeparator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3L, create_fragment$3M, safe_not_equal, { borderColor: 0, cssClass: 1 });
  }
}
function get_each_context$_(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_else_block$Y(ctx) {
  let html_tag;
  let raw_value = (
    /*chatData*/
    ctx[0].description.value + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*chatData*/
      1 && raw_value !== (raw_value = /*chatData*/
      ctx2[0].description.value + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block_2$O(ctx) {
  let html_tag;
  let raw_value = (
    /*chatData*/
    ctx[0].unidentified.description + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*chatData*/
      1 && raw_value !== (raw_value = /*chatData*/
      ctx2[0].unidentified.description + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block_1$$(ctx) {
  let horizontallineseparator;
  let t2;
  let div;
  let itemsummarycommandbuttonlist;
  let current;
  horizontallineseparator = new HorizontalLineSeparator({});
  itemsummarycommandbuttonlist = new ItemSummaryCommandButtonList({ props: { item: (
    /*item*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(horizontallineseparator.$$.fragment);
      t2 = space();
      div = element("div");
      create_component(itemsummarycommandbuttonlist.$$.fragment);
      attr(div, "class", "inline-wrapped-elements svelte-zx40yd");
    },
    m(target, anchor) {
      mount_component(horizontallineseparator, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      mount_component(itemsummarycommandbuttonlist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const itemsummarycommandbuttonlist_changes = {};
      if (dirty & /*item*/
      2) itemsummarycommandbuttonlist_changes.item = /*item*/
      ctx2[1];
      itemsummarycommandbuttonlist.$set(itemsummarycommandbuttonlist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      transition_in(itemsummarycommandbuttonlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      transition_out(itemsummarycommandbuttonlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(horizontallineseparator, detaching);
      destroy_component(itemsummarycommandbuttonlist);
    }
  };
}
function create_if_block$1H(ctx) {
  let horizontallineseparator;
  let t2;
  let div;
  let current;
  horizontallineseparator = new HorizontalLineSeparator({});
  let each_value = ensure_array_like(
    /*chatData*/
    ctx[0].properties
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$_(get_each_context$_(ctx, each_value, i2));
  }
  return {
    c() {
      create_component(horizontallineseparator.$$.fragment);
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "inline-wrapped-elements svelte-zx40yd");
      div.inert = /*concealDetails*/
      ctx[3];
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_PROPERTY_LIST);
    },
    m(target, anchor) {
      mount_component(horizontallineseparator, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*chatData*/
      1) {
        each_value = ensure_array_like(
          /*chatData*/
          ctx2[0].properties
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$_(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$_(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*concealDetails*/
      8) {
        div.inert = /*concealDetails*/
        ctx2[3];
      }
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(horizontallineseparator, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$_(ctx) {
  let span;
  let t_value = (
    /*prop*/
    ctx[5] + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "tag");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*chatData*/
      1 && t_value !== (t_value = /*prop*/
      ctx2[5] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$3L(ctx) {
  let div;
  let t0;
  let t1;
  let div_transition;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*concealDetails*/
      ctx2[3]
    ) return create_if_block_2$O;
    return create_else_block$Y;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*itemSummaryCommands*/
    ctx[4].length && create_if_block_1$$(ctx)
  );
  let if_block2 = (
    /*chatData*/
    ctx[0].properties && create_if_block$1H(ctx)
  );
  return {
    c() {
      div = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      attr(div, "class", "item-summary svelte-zx40yd");
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_SUMMARY);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block0.m(div, null);
      append(div, t0);
      if (if_block1) if_block1.m(div, null);
      append(div, t1);
      if (if_block2) if_block2.m(div, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
        if_block0.p(ctx, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div, t0);
        }
      }
      if (
        /*itemSummaryCommands*/
        ctx[4].length
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*itemSummaryCommands*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$$(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*chatData*/
        ctx[0].properties
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & /*chatData*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1H(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block1);
      transition_in(if_block2);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div_transition) div_transition = create_bidirectional_transition(
            div,
            slide,
            {
              duration: (
                /*useTransition*/
                ctx[2] ? 200 : 0
              ),
              easing: quadInOut
            },
            true
          );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      if (local) {
        if (!div_transition) div_transition = create_bidirectional_transition(
          div,
          slide,
          {
            duration: (
              /*useTransition*/
              ctx[2] ? 200 : 0
            ),
            easing: quadInOut
          },
          false
        );
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (detaching && div_transition) div_transition.end();
    }
  };
}
function instance$3K($$self, $$props, $$invalidate) {
  let itemSummaryCommands;
  let concealDetails;
  let { chatData } = $$props;
  let { item } = $$props;
  let { useTransition } = $$props;
  $$self.$$set = ($$props2) => {
    if ("chatData" in $$props2) $$invalidate(0, chatData = $$props2.chatData);
    if ("item" in $$props2) $$invalidate(1, item = $$props2.item);
    if ("useTransition" in $$props2) $$invalidate(2, useTransition = $$props2.useTransition);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    2) {
      $$invalidate(4, itemSummaryCommands = ItemSummaryRuntime.getItemSummaryCommands(item));
    }
    if ($$self.$$.dirty & /*item*/
    2) {
      $$invalidate(3, concealDetails = FoundryAdapter.concealDetails(item));
    }
  };
  return [chatData, item, useTransition, concealDetails, itemSummaryCommands];
}
class ItemSummary extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3K, create_fragment$3L, safe_not_equal, { chatData: 0, item: 1, useTransition: 2 });
  }
}
class TidyHooks {
  /**
   * The active effect context menu has established its options and is about to show.
   * @param {ActiveEffect5e} effect The active effect document instance.
   * @param {ContextMenuEntry[]} menuItems The menu items for this active effect.
   * @returns {boolean} `true` to allow the menu to show, `false` to prevent the default menu from showing.
   *
   * @example
   * ```js
   * Hooks.on('dnd5e.getActiveEffectContextOptions', (effect, menuItems) => {
   *   return true;
   * });
   * ```
   */
  static dnd5eGetActiveEffectContextOptions(effect, menuItems) {
    return Hooks.call("dnd5e.getActiveEffectContextOptions", effect, menuItems);
  }
  /**
   * The context menu for the advancements list has been constructed.
   * @param {jQuery} html The HTML element to which the context options are attached.
   * @param {ContextMenuEntry[]} contextOptions The context menu entries.
   * @returns {boolean} `true` to allow the menu to show, `false` to prevent the default menu from showing.
   *
   * @example
   * ```js
   * Hooks.on('dnd5e.getItemAdvancementContext', (html, contextOptions) => {
   *   return true;
   * });
   * ```
   */
  static dnd5eGetItemAdvancementContext(html, contextOptions) {
    return Hooks.call("dnd5e.getItemAdvancementContext", html, contextOptions);
  }
  /**
   * The item context menu has established its options and is about to show.
   * @param {Item5e} item The item document instance.
   * @param {ContextMenuEntry[]} menuItems The menu items for this item.
   * @returns {boolean} `true` to allow the menu to show, `false` to prevent the default menu from showing.
   *
   * @example
   * ```js
   * Hooks.on('dnd5e.getItemContextOptions', (item, menuItems) => {
   *   return true;
   * });
   * ```
   */
  static dnd5eGetItemContextOptions(item, menuItems) {
    return Hooks.call("dnd5e.getItemContextOptions", item, menuItems);
  }
  /**
   * A hit die roll is about to occur.
   * @param {Actor5e} actor The affected actor.
   * @param {RollConfig} rollConfig The configuration for the roll.
   * @param {string} denomination The roll denomination.
   * @returns {boolean} `true` to allow the roll, `false` to prevent it.
   *
   * @example
   * ```js
   * Hooks.on('dnd5e.preRollHitDie', (actor, rollConfig, denomination) => {
   *   return true;
   * });
   * ```
   */
  static dnd5ePreRollHitDie(actor, rollConfig, denomination) {
    return Hooks.call("dnd5e.preRollHitDie", actor, rollConfig, denomination);
  }
  /**
   * A short rest is about to start.
   * @param {Actor5e} actor The actor that is being rested.
   * @param {RestConfiguration} config Configuration options for the rest.
   * @returns {boolean} Explicitly return `false` to prevent the rest from being started.
   *
   * @example
   * ```js
   * Hooks.on('dnd5e.preShortRest', (actor, config) => {
   *   return true;
   * });
   * ```
   */
  static dnd5ePreShortRest(actor, config) {
    return Hooks.call("dnd5e.preShortRest", actor, config);
  }
  /**
   * A hook event that fires after a hit die has been rolled for an Actor, but before updates have been performed.
   * @param {Actor5e} actor Actor for which the hit die has been rolled.
   * @param {Roll} roll The resulting roll.
   * @param {object} updates
   * @param {object} updates.actor Updates that will be applied to the actor.
   * @param {object} updates.class Updates that will be applied to the class.
   * @returns {boolean} `true` to allow the roll, `false` to prevent it.
   *
   * @example
   * ```js
   * Hooks.on('dnd5e.rollHitDie', (actor, roll, updates) => {
   *   return true;
   * });
   * ```
   */
  static dnd5eRollHitDie(actor, roll, updates) {
    return Hooks.call("dnd5e.rollHitDie", actor, roll, updates);
  }
  /**
   * The context menu is about to show for a given item on a sheet.
   * @param {Item5e} item The item document instance.
   * @param {object} options The mouse event which triggered the context menu.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.actorItemUseContextMenu', (item, options) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsActorItemUseContextMenu(item, options) {
    Hooks.callAll("tidy5e-sheet.actorItemUseContextMenu", item, options);
  }
  /**
   * An item is about to be used by an actor.
   * @param {Item5e} item The affected item document instance.
   * @param {any} config Any configuration for the item use.
   * @param {any} options Any options for the item use.
   * @returns {boolean} `true` to allow the item use, `false` to prevent it.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.actorPreUseItem', (item, config, options) => {
   *   return true;
   * });
   * ```
   */
  static tidy5eSheetsActorPreUseItem(item, config, options) {
    return Hooks.call("tidy5e-sheet.actorPreUseItem", item, config, options);
  }
  /**
   * A user has hovered off an item, typically from an item table row.
   * @param {Event} event The triggering mouse event.
   * @param {any} item The item which is no longer hovered.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.itemHoverOff', (event, item) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsItemHoverOff(event, item) {
    Hooks.callAll("tidy5e-sheet.itemHoverOff", event, item);
  }
  /**
   * A user has hovered over an item, typically on an item table row.
   * @param {Event} event The triggering mouse event.
   * @param {any} item The hovered-over item.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.itemHoverOn', (event, item) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsItemHoverOn(event, item) {
    Hooks.callAll("tidy5e-sheet.itemHoverOn", event, item);
  }
  /**
   * Sheet item/effect sections are about to be configured. Use this hook to inject additional items, sections, etc., or to adjust context data.
   * @param {any} app The sheet application instance.
   * @param {HTMLElement} element The sheet HTML element.
   * @param {CharacterSheetContext | NpcSheetContext | ContainerSheetContext} data The data context from `getData()`.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.preConfigureSections', (app, element, data) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsPreConfigureSections(app, element2, data) {
    Hooks.callAll("tidy5e-sheet.preConfigureSections", app, element2, data);
  }
  /**
   * An active effect is about to be created for an owning document.
   * This was initiated specifically through Tidy 5e Sheets,
   * whether directly by the user, or indirectly through some user interaction.
   * @param {any} owner The owning document instance which will receive the created effect.
   * @param {object} createData The data used to create it.
   * @param {string} userId The user who initiated the creation.
   * @returns {boolean} `true` to allow the effect creation, `false` to prevent it.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.preCreateActiveEffect', (owner, createData, userId) => {
   *   return true;
   * });
   * ```
   */
  static tidy5eSheetsPreCreateActiveEffect(owner, createData, userId) {
    return Hooks.call(
      "tidy5e-sheet.preCreateActiveEffect",
      owner,
      createData,
      userId
    );
  }
  /**
   * An item is about to be created for an owning document.
   * This was initiated specifically through Tidy 5e Sheets,
   * whether directly by the user, or indirectly through some user interaction.
   * @param {any} owner The owning document instance which will receive the created item.
   * @param {object} createData The data used to create it.
   * @param {string} userId The user who initiated the creation.
   * @returns {boolean} `true` to allow the item creation, `false` to prevent it.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.preCreateItem', (owner, createData, userId) => {
   *   return true;
   * });
   * ```
   */
  static tidy5eSheetsPreCreateItem(owner, createData, userId) {
    return Hooks.call("tidy5e-sheet.preCreateItem", owner, createData, userId);
  }
  /**
   * The portrait picker is about to open.
   * @param {ActorSheetContext} context The actor sheet data from `getData()`.
   * @param {MouseEvent & { currentTarget: EventTarget & HTMLElement }} event The triggering event.
   * @returns {boolean} `true` to allow the picker to open, `false` to prevent it.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.preOpenActorPortraitFilePicker', (context, event) => {
   *   return true;
   * });
   * ```
   */
  static tidy5eSheetsPreOpenActorPortraitFilePicker(context, event) {
    return Hooks.call(
      "tidy5e-sheet.preOpenActorPortraitFilePicker",
      context,
      event
    );
  }
  /**
   * The floating context menu's positioning is being determined.
   * @param {ContextMenuPositionInfo} positionInfo Context menu positioning info, used for determining where to put the context menu.
   * @returns {boolean} `true` to allow the menu to show, `false` to prevent the default menu from showing.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.prepareFloatingContextMenuPosition', (positionInfo) => {
   *   return true;
   * });
   * ```
   */
  static tidy5eSheetsPrepareFloatingContextMenuPosition(positionInfo) {
    return Hooks.call(
      "tidy5e-sheet.prepareFloatingContextMenuPosition",
      positionInfo
    );
  }
  /**
   * Resources have been prepared. Use this hook to adjust them and/or add new resources.
   * @param {TidyResource[]} tidyResources The resources that have been prepared for the sheet.
   * @param {Actor5e} actor The affected actor.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.prepareResources', (tidyResources, actor) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsPrepareResources(tidyResources, actor) {
    Hooks.callAll("tidy5e-sheet.prepareResources", tidyResources, actor);
  }
  /**
   * A tab is about to be selected.
   * @param {any} app The sheet application instance.
   * @param {HTMLElement} element The sheet's HTML element.
   * @param {object} data The current tab ID before selecting the new tab, and the new tab ID to be selected.
   * @returns {boolean} `false` to cancel tabbing.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.preSelectTab', (app, element, data) => {
   *   return true;
   * });
   * ```
   */
  static tidy5eSheetsPreSelectTab(app, element2, data) {
    return Hooks.call("tidy5e-sheet.preSelectTab", app, element2, data);
  }
  /**
   * Tidy 5e Sheets is ready to be used and customized.
   * @param {Tidy5eSheetsApi} api The Tidy 5e Sheets API, used for customizing and registering content with Tidy 5e Sheets.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.ready', (api) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsReady(api) {
    Hooks.callAll("tidy5e-sheet.ready", api);
  }
  /**
   * The actor sheet has rendered all content and registered custom content. Is called on partial and full renders.
   * @param {any} app The sheet application instance.
   * @param {HTMLElement} element The sheet's HTML element.
   * @param {CharacterSheetContext | NpcSheetContext | VehicleSheetContext} data The data context from `getData()`.
   * @param {boolean} forced `true` when performing a full re-render; `false` when performing a partial re-render.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.renderActorSheet', (app, element, data, forced) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsRenderActorSheet(app, element2, data, forced) {
    Hooks.callAll("tidy5e-sheet.renderActorSheet", app, element2, data, forced);
  }
  /**
   * The item sheet has rendered all content and registered custom content. Is called on partial and full renders.
   * @param {any} app The target item sheet application class instance.
   * @param {HTMLElement} element The item sheet's HTML element.
   * @param {ContainerSheetContext | ItemSheetContext} data The data context from `getData()`.
   * @param {boolean} forced `true` when performing a full re-render; `false` when performing a partial re-render.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.renderItemSheet', (app, element, data, forced) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsRenderItemSheet(app, element2, data, forced) {
    Hooks.callAll("tidy5e-sheet.renderItemSheet", app, element2, data, forced);
  }
  /**
   * A tab has been selected on the sheet.
   * @param {any} app The sheet application instance.
   * @param {HTMLElement} element The sheet's HTML element.
   * @param {string} newTabId The selected tab ID.
   *
   * @example
   * ```js
   * Hooks.on('tidy5e-sheet.selectTab', (app, element, newTabId) => {
   *   // Your code here
   * });
   * ```
   */
  static tidy5eSheetsSelectTab(app, element2, newTabId) {
    Hooks.callAll("tidy5e-sheet.selectTab", app, element2, newTabId);
  }
}
const get_default_slot_changes$4 = (dirty) => ({});
const get_default_slot_context$4 = (ctx) => ({ toggleSummary: (
  /*toggleSummary*/
  ctx[11]
) });
function create_if_block$1G(ctx) {
  let itemsummary;
  let current;
  itemsummary = new ItemSummary({
    props: {
      chatData: (
        /*chatData*/
        ctx[7]
      ),
      useTransition: (
        /*useTransition*/
        ctx[8]
      ),
      item: (
        /*item*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(itemsummary.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemsummary, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemsummary_changes = {};
      if (dirty & /*chatData*/
      128) itemsummary_changes.chatData = /*chatData*/
      ctx2[7];
      if (dirty & /*useTransition*/
      256) itemsummary_changes.useTransition = /*useTransition*/
      ctx2[8];
      if (dirty & /*item*/
      1) itemsummary_changes.item = /*item*/
      ctx2[0];
      itemsummary.$set(itemsummary_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemsummary.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemsummary.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemsummary, detaching);
    }
  };
}
function create_fragment$3K(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t2;
  let div1_data_context_menu_value;
  let div1_data_context_menu_document_uuid_value;
  let div1_data_effect_id_value;
  let div1_data_parent_id_value;
  let div1_draggable_value;
  let div1_data_item_id_value;
  let div1_data_tidy_item_type_value;
  let div1_data_favorite_id_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context$4
  );
  let if_block = (
    /*showSummary*/
    ctx[6] && /*chatData*/
    ctx[7] && create_if_block$1G(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      t2 = space();
      if (if_block) if_block.c();
      attr(div0, "class", div0_class_value = "item-table-row " + /*cssClass*/
      (ctx[4] ?? "") + " svelte-1vvzmd0");
      attr(div1, "class", "item-table-row-container svelte-1vvzmd0");
      attr(
        div1,
        "aria-hidden",
        /*hidden*/
        ctx[5]
      );
      attr(div1, "data-context-menu", div1_data_context_menu_value = /*contextMenu*/
      ctx[3]?.type);
      attr(div1, "data-context-menu-document-uuid", div1_data_context_menu_document_uuid_value = /*contextMenu*/
      ctx[3]?.uuid);
      attr(div1, "data-effect-id", div1_data_effect_id_value = /*effect*/
      ctx[1]?.id);
      attr(div1, "data-parent-id", div1_data_parent_id_value = /*effect*/
      ctx[1]?.parentId ?? /*effect*/
      ctx[1]?.parent?.id);
      attr(div1, "draggable", div1_draggable_value = !!/*draggable*/
      ctx[9]);
      attr(div1, "data-item-id", div1_data_item_id_value = /*item*/
      ctx[0]?.id);
      attr(div1, "data-tidy-table-row", "");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_TABLE_ROW);
      attr(div1, "data-tidy-item-type", div1_data_tidy_item_type_value = /*item*/
      ctx[0]?.type ?? "unknown");
      attr(div1, "data-favorite-id", div1_data_favorite_id_value = /*favoriteId*/
      ctx[2] ?? null);
      toggle_class(
        div1,
        "hidden",
        /*hidden*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append(div1, t2);
      if (if_block) if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "mousedown",
            /*mousedown_handler*/
            ctx[19]
          ),
          listen(
            div1,
            "mouseenter",
            /*onMouseEnter*/
            ctx[12]
          ),
          listen(
            div1,
            "mouseleave",
            /*onMouseLeave*/
            ctx[13]
          ),
          listen(
            div1,
            "dragstart",
            /*handleDragStart*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes$4
            ),
            get_default_slot_context$4
          );
        }
      }
      if (!current || dirty & /*cssClass*/
      16 && div0_class_value !== (div0_class_value = "item-table-row " + /*cssClass*/
      (ctx2[4] ?? "") + " svelte-1vvzmd0")) {
        attr(div0, "class", div0_class_value);
      }
      if (
        /*showSummary*/
        ctx2[6] && /*chatData*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*showSummary, chatData*/
          192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1G(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*hidden*/
      32) {
        attr(
          div1,
          "aria-hidden",
          /*hidden*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*contextMenu*/
      8 && div1_data_context_menu_value !== (div1_data_context_menu_value = /*contextMenu*/
      ctx2[3]?.type)) {
        attr(div1, "data-context-menu", div1_data_context_menu_value);
      }
      if (!current || dirty & /*contextMenu*/
      8 && div1_data_context_menu_document_uuid_value !== (div1_data_context_menu_document_uuid_value = /*contextMenu*/
      ctx2[3]?.uuid)) {
        attr(div1, "data-context-menu-document-uuid", div1_data_context_menu_document_uuid_value);
      }
      if (!current || dirty & /*effect*/
      2 && div1_data_effect_id_value !== (div1_data_effect_id_value = /*effect*/
      ctx2[1]?.id)) {
        attr(div1, "data-effect-id", div1_data_effect_id_value);
      }
      if (!current || dirty & /*effect*/
      2 && div1_data_parent_id_value !== (div1_data_parent_id_value = /*effect*/
      ctx2[1]?.parentId ?? /*effect*/
      ctx2[1]?.parent?.id)) {
        attr(div1, "data-parent-id", div1_data_parent_id_value);
      }
      if (!current || dirty & /*draggable*/
      512 && div1_draggable_value !== (div1_draggable_value = !!/*draggable*/
      ctx2[9])) {
        attr(div1, "draggable", div1_draggable_value);
      }
      if (!current || dirty & /*item*/
      1 && div1_data_item_id_value !== (div1_data_item_id_value = /*item*/
      ctx2[0]?.id)) {
        attr(div1, "data-item-id", div1_data_item_id_value);
      }
      if (!current || dirty & /*item*/
      1 && div1_data_tidy_item_type_value !== (div1_data_tidy_item_type_value = /*item*/
      ctx2[0]?.type ?? "unknown")) {
        attr(div1, "data-tidy-item-type", div1_data_tidy_item_type_value);
      }
      if (!current || dirty & /*favoriteId*/
      4 && div1_data_favorite_id_value !== (div1_data_favorite_id_value = /*favoriteId*/
      ctx2[2] ?? null)) {
        attr(div1, "data-favorite-id", div1_data_favorite_id_value);
      }
      if (!current || dirty & /*hidden*/
      32) {
        toggle_class(
          div1,
          "hidden",
          /*hidden*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3J($$self, $$props, $$invalidate) {
  let draggable;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(20, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { item = null } = $$props;
  let { effect = null } = $$props;
  let { favoriteId = null } = $$props;
  let { contextMenu = null } = $$props;
  let { cssClass = "" } = $$props;
  let { itemCardContentTemplate = null } = $$props;
  let { hidden = false } = $$props;
  let { getDragData = null } = $$props;
  const expandedItemData = getContext(CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEM_DATA);
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  const expandedItems = getContext(CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEMS);
  const onItemToggled = getContext(CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TOGGLED);
  const dispatcher = createEventDispatcher();
  const location = getContext(CONSTANTS.SVELTE_CONTEXT.LOCATION);
  let card = getContext(CONSTANTS.SVELTE_CONTEXT.CARD);
  let showSummary = false;
  let chatData;
  let useTransition = false;
  async function toggleSummary(actor) {
    if (!item) {
      warn("Unable to show summary. No item was provided.");
      $$invalidate(6, showSummary = false);
      return;
    }
    $$invalidate(7, chatData ??= await item.getChatData({ secrets: actor.isOwner }));
    $$invalidate(6, showSummary = !showSummary);
    onItemToggled?.(item.id, showSummary, location);
  }
  async function onMouseEnter(event) {
    TidyHooks.tidy5eSheetsItemHoverOn(event, item);
    if (!item?.getChatData || !$settingStore.itemCardsForAllItems) {
      return;
    }
    card?.update((card2) => {
      card2.item = item;
      card2.itemCardContentTemplate = itemCardContentTemplate;
      return card2;
    });
  }
  async function onMouseLeave(event) {
    TidyHooks.tidy5eSheetsItemHoverOff(event, item);
    card?.update((card2) => {
      card2.item = null;
      card2.itemCardContentTemplate = null;
      return card2;
    });
  }
  function handleDragStart2(event) {
    if (!draggable) {
      return;
    }
    onMouseLeave(event);
    card?.update((card2) => {
      return card2;
    });
    const dragData = getDragData?.() ?? draggable.toDragData?.();
    if (dragData) {
      event.dataTransfer?.setData("text/plain", JSON.stringify(dragData));
    }
  }
  function restoreItemSummaryIfExpanded() {
    if (!item) {
      $$invalidate(8, useTransition = true);
      return;
    }
    $$invalidate(8, useTransition = false);
    const isExpandedAtThisLocation = expandedItems?.get(item.id)?.has(location);
    if (isExpandedAtThisLocation) {
      $$invalidate(7, chatData = expandedItemData.get(item.id));
      $$invalidate(6, showSummary = true);
    }
    setTimeout(() => {
      $$invalidate(8, useTransition = true);
    });
  }
  onMount(() => {
    let first = true;
    const subscription = context?.subscribe(async (c2) => {
      if (first) {
        first = false;
        restoreItemSummaryIfExpanded();
        return;
      }
      if (item && showSummary) {
        item.getChatData({ secrets: item.actor.isOwner }).then((data) => {
          $$invalidate(7, chatData = data);
        });
      } else if (item && !showSummary && chatData) {
        $$invalidate(7, chatData = void 0);
      }
    });
    return subscription;
  });
  const mousedown_handler = (event) => dispatcher("mousedown", event);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("effect" in $$props2) $$invalidate(1, effect = $$props2.effect);
    if ("favoriteId" in $$props2) $$invalidate(2, favoriteId = $$props2.favoriteId);
    if ("contextMenu" in $$props2) $$invalidate(3, contextMenu = $$props2.contextMenu);
    if ("cssClass" in $$props2) $$invalidate(4, cssClass = $$props2.cssClass);
    if ("itemCardContentTemplate" in $$props2) $$invalidate(15, itemCardContentTemplate = $$props2.itemCardContentTemplate);
    if ("hidden" in $$props2) $$invalidate(5, hidden = $$props2.hidden);
    if ("getDragData" in $$props2) $$invalidate(16, getDragData = $$props2.getDragData);
    if ("$$scope" in $$props2) $$invalidate(17, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item, effect*/
    3) {
      $$invalidate(9, draggable = item ?? effect);
    }
  };
  return [
    item,
    effect,
    favoriteId,
    contextMenu,
    cssClass,
    hidden,
    showSummary,
    chatData,
    useTransition,
    draggable,
    dispatcher,
    toggleSummary,
    onMouseEnter,
    onMouseLeave,
    handleDragStart2,
    itemCardContentTemplate,
    getDragData,
    $$scope,
    slots,
    mousedown_handler
  ];
}
class ItemTableRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3J, create_fragment$3K, safe_not_equal, {
      item: 0,
      effect: 1,
      favoriteId: 2,
      contextMenu: 3,
      cssClass: 4,
      itemCardContentTemplate: 15,
      hidden: 5,
      getDragData: 16
    });
  }
}
function create_fragment$3J(ctx) {
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[2]("DND5E.Add") + ""
  );
  let t1;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-plus-circle");
      attr(button, "type", "button");
      attr(button, "class", "item-list-footer-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[2]("DND5E.FeatureAdd")
      );
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_CREATE_COMMAND);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*create*/
            ctx[0]
          )) ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3I($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let { dataset } = $$props;
  let { actor } = $$props;
  let { create = defaultCreateFunction } = $$props;
  const localize = FoundryAdapter.localize;
  function defaultCreateFunction() {
    return FoundryAdapter.createItem(dataset, actor);
  }
  $$self.$$set = ($$props2) => {
    if ("dataset" in $$props2) $$invalidate(3, dataset = $$props2.dataset);
    if ("actor" in $$props2) $$invalidate(4, actor = $$props2.actor);
    if ("create" in $$props2) $$invalidate(0, create = $$props2.create);
  };
  return [create, $settingStore, localize, dataset, actor];
}
class ItemCreateButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3I, create_fragment$3J, safe_not_equal, { dataset: 3, actor: 4, create: 0 });
  }
}
class ActorItemRuntime {
  static _actorItemSectionCommands = [];
  static registerActorItemSectionCommands(commands) {
    ActorItemRuntime._actorItemSectionCommands.push(...commands);
  }
  static getActorItemSectionCommands({
    section,
    actor
  }) {
    return [...ActorItemRuntime._actorItemSectionCommands].filter((c2) => {
      try {
        return section && (c2.enabled?.({ section, actor }) ?? true);
      } catch (e2) {
        error(
          "Failed to check if actor item section command is enabled",
          false,
          { error: e2, actor, section }
        );
        return false;
      }
    });
  }
}
function get_each_context$Z(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function get_if_ctx$f(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*section*/
    child_ctx[0].custom
  );
  child_ctx[14] = constants_0;
  return child_ctx;
}
function create_if_block_1$_(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$N, create_else_block$X];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*custom*/
      ctx2[14]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$X(ctx) {
  let itemcreatebutton;
  let current;
  itemcreatebutton = new ItemCreateButton({
    props: {
      dataset: (
        /*section*/
        ctx[0].dataset
      ),
      actor: (
        /*actor*/
        ctx[1]
      ),
      create: (
        /*create*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(itemcreatebutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcreatebutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemcreatebutton_changes = {};
      if (dirty & /*section*/
      1) itemcreatebutton_changes.dataset = /*section*/
      ctx2[0].dataset;
      if (dirty & /*actor*/
      2) itemcreatebutton_changes.actor = /*actor*/
      ctx2[1];
      if (dirty & /*create*/
      8) itemcreatebutton_changes.create = /*create*/
      ctx2[3];
      itemcreatebutton.$set(itemcreatebutton_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcreatebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcreatebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcreatebutton, detaching);
    }
  };
}
function create_if_block_2$N(ctx) {
  let itemcreatebutton;
  let current;
  function func2() {
    return (
      /*func*/
      ctx[9](
        /*custom*/
        ctx[14]
      )
    );
  }
  itemcreatebutton = new ItemCreateButton({
    props: {
      dataset: (
        /*section*/
        ctx[0].dataset
      ),
      actor: (
        /*actor*/
        ctx[1]
      ),
      create: func2
    }
  });
  return {
    c() {
      create_component(itemcreatebutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcreatebutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemcreatebutton_changes = {};
      if (dirty & /*section*/
      1) itemcreatebutton_changes.dataset = /*section*/
      ctx[0].dataset;
      if (dirty & /*actor*/
      2) itemcreatebutton_changes.actor = /*actor*/
      ctx[1];
      if (dirty & /*section*/
      1) itemcreatebutton_changes.create = func2;
      itemcreatebutton.$set(itemcreatebutton_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcreatebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcreatebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcreatebutton, detaching);
    }
  };
}
function create_if_block$1F(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", null_to_empty(
        /*command*/
        ctx[11].iconClass
      ) + " svelte-1ya4qwh");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_each_block$Z(ctx) {
  let button;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[7](
      /*command*/
      ctx[11].label ?? ""
    ) + ""
  );
  let t1;
  let t2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  let if_block = (
    /*command*/
    (ctx[11].iconClass ?? "") !== "" && create_if_block$1F(ctx)
  );
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[10](
        /*command*/
        ctx[11],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      if (if_block) if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(button, "type", "button");
      attr(button, "class", "item-list-footer-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[7](
          /*command*/
          ctx[11].tooltip ?? ""
        )
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block) if_block.m(button, null);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*command*/
        (ctx[11].iconClass ?? "") !== ""
      ) if_block.p(ctx, dirty);
      if (dirty & /*$settingStore*/
      16 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3I(ctx) {
  let footer;
  let t2;
  let current;
  let if_block = (
    /*canCreate*/
    ctx[2] && create_if_block_1$_(get_if_ctx$f(ctx))
  );
  let each_value = ensure_array_like(
    /*customCommands*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Z(get_each_context$Z(ctx, each_value, i2));
  }
  return {
    c() {
      footer = element("footer");
      if (if_block) if_block.c();
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(footer, "class", "item-table-footer-row svelte-1ya4qwh");
    },
    m(target, anchor) {
      insert(target, footer, anchor);
      if (if_block) if_block.m(footer, null);
      append(footer, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(footer, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*canCreate*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(get_if_ctx$f(ctx2), dirty);
          if (dirty & /*canCreate*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$_(get_if_ctx$f(ctx2));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(footer, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*localize, customCommands, $settingStore, section, actor*/
      179) {
        each_value = ensure_array_like(
          /*customCommands*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$Z(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$Z(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(footer, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(footer);
      }
      if (if_block) if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3H($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(4, $settingStore = $$value));
  let { section } = $$props;
  let { actor } = $$props;
  let { canCreate = true } = $$props;
  let { create = void 0 } = $$props;
  let { isItem } = $$props;
  let customCommands = isItem ? ActorItemRuntime.getActorItemSectionCommands({ actor, section }) : [];
  function createForCustom(custom) {
    if (!custom.creationItemTypes.length) {
      return;
    }
    if (custom.creationItemTypes.length === 1) {
      FoundryAdapter.createItem(
        {
          type: custom.creationItemTypes[0],
          ...section.dataset
        },
        actor
      );
    } else {
      const createData = { ...section.dataset };
      if (!TidyHooks.tidy5eSheetsPreCreateItem(actor, createData, game.user.id)) {
        return;
      }
      Item.implementation.createDialog(createData, {
        parent: actor,
        pack: actor.pack,
        types: custom.creationItemTypes
      });
    }
  }
  const localize = FoundryAdapter.localize;
  const func2 = (custom) => createForCustom(custom);
  const click_handler = (command, ev) => command.execute?.({ section, event: ev, actor });
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
    if ("actor" in $$props2) $$invalidate(1, actor = $$props2.actor);
    if ("canCreate" in $$props2) $$invalidate(2, canCreate = $$props2.canCreate);
    if ("create" in $$props2) $$invalidate(3, create = $$props2.create);
    if ("isItem" in $$props2) $$invalidate(8, isItem = $$props2.isItem);
  };
  return [
    section,
    actor,
    canCreate,
    create,
    $settingStore,
    customCommands,
    createForCustom,
    localize,
    isItem,
    func2,
    click_handler
  ];
}
class ItemTableFooter extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3H, create_fragment$3I, safe_not_equal, {
      section: 0,
      actor: 1,
      canCreate: 2,
      create: 3,
      isItem: 8
    });
  }
}
function create_fragment$3H(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr(div, "class", div_class_value = "item-table-column " + /*cssClass*/
      ctx[3] + " svelte-14w3uu6");
      attr(
        div,
        "title",
        /*title*/
        ctx[2]
      );
      toggle_class(
        div,
        "primary",
        /*primary*/
        ctx[0]
      );
      set_style(
        div,
        "flex-basis",
        /*baseWidth*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cssClass*/
      8 && div_class_value !== (div_class_value = "item-table-column " + /*cssClass*/
      ctx2[3] + " svelte-14w3uu6")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*title*/
      4) {
        attr(
          div,
          "title",
          /*title*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*cssClass, primary*/
      9) {
        toggle_class(
          div,
          "primary",
          /*primary*/
          ctx2[0]
        );
      }
      if (dirty & /*baseWidth*/
      2) {
        set_style(
          div,
          "flex-basis",
          /*baseWidth*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$3G($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { primary = false } = $$props;
  let { baseWidth = null } = $$props;
  let { title = null } = $$props;
  let { cssClass = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("primary" in $$props2) $$invalidate(0, primary = $$props2.primary);
    if ("baseWidth" in $$props2) $$invalidate(1, baseWidth = $$props2.baseWidth);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("cssClass" in $$props2) $$invalidate(3, cssClass = $$props2.cssClass);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [primary, baseWidth, title, cssClass, $$scope, slots];
}
class ItemTableColumn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3G, create_fragment$3H, safe_not_equal, {
      primary: 0,
      baseWidth: 1,
      title: 2,
      cssClass: 3
    });
  }
}
function create_fragment$3G(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    {
      class: div_class_value = "item-table-cell " + /*cssClass*/
      ctx[2]
    },
    { title: (
      /*title*/
      ctx[3]
    ) },
    /*$$props*/
    ctx[6].attributes
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign(div_data, div_levels[i2]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
      toggle_class(
        div,
        "primary",
        /*primary*/
        ctx[1]
      );
      set_style(
        div,
        "flex-basis",
        /*baseWidth*/
        ctx[0]
      );
      toggle_class(div, "svelte-1uglpqz", true);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mouseenter",
            /*mouseEnter*/
            ctx[4]
          ),
          listen(
            div,
            "mouseleave",
            /*mouseLeave*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*cssClass*/
        4 && div_class_value !== (div_class_value = "item-table-cell " + /*cssClass*/
        ctx2[2])) && { class: div_class_value },
        (!current || dirty & /*title*/
        8) && { title: (
          /*title*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        64 && /*$$props*/
        ctx2[6].attributes
      ]));
      toggle_class(
        div,
        "primary",
        /*primary*/
        ctx2[1]
      );
      set_style(
        div,
        "flex-basis",
        /*baseWidth*/
        ctx2[0]
      );
      toggle_class(div, "svelte-1uglpqz", true);
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3F($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { baseWidth = void 0 } = $$props;
  let { primary = false } = $$props;
  let { cssClass = "" } = $$props;
  let { title = void 0 } = $$props;
  const isHovering = writable(false);
  setContext(CONSTANTS.CONTEXT_GRID_CELL_HOVER, isHovering);
  function mouseEnter(ev) {
    isHovering.set(true);
  }
  function mouseLeave(ev) {
    isHovering.set(false);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("baseWidth" in $$new_props) $$invalidate(0, baseWidth = $$new_props.baseWidth);
    if ("primary" in $$new_props) $$invalidate(1, primary = $$new_props.primary);
    if ("cssClass" in $$new_props) $$invalidate(2, cssClass = $$new_props.cssClass);
    if ("title" in $$new_props) $$invalidate(3, title = $$new_props.title);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    baseWidth,
    primary,
    cssClass,
    title,
    mouseEnter,
    mouseLeave,
    $$props,
    $$scope,
    slots
  ];
}
class ItemTableCell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3F, create_fragment$3G, safe_not_equal, {
      baseWidth: 0,
      primary: 1,
      cssClass: 2,
      title: 3
    });
  }
}
const get_after_roll_button_slot_changes = (dirty) => ({});
const get_after_roll_button_slot_context = (ctx) => ({});
function create_if_block$1E(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fa fa-dice-d20 svelte-wrz0h9");
      toggle_class(i2, "invisible", !/*showDiceIconOnHover*/
      ctx[3]);
      attr(button, "type", "button");
      attr(button, "class", "item-use-button icon-button svelte-wrz0h9");
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_USE_COMMAND);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[6].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[10]
          ),
          listen(
            button,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[11]
          ),
          listen(
            button,
            "focusin",
            /*focusin_handler*/
            ctx[12]
          ),
          listen(
            button,
            "focusout",
            /*focusout_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*showDiceIconOnHover*/
      8) {
        toggle_class(i2, "invisible", !/*showDiceIconOnHover*/
        ctx2[3]);
      }
      if (dirty & /*$settingStore*/
      64 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[6].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$3F(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let current;
  let if_block = !/*disabled*/
  ctx[2] && create_if_block$1E(ctx);
  const after_roll_button_slot_template = (
    /*#slots*/
    ctx[9]["after-roll-button"]
  );
  const after_roll_button_slot = create_slot(
    after_roll_button_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_after_roll_button_slot_context
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<i class="fas fa-question svelte-wrz0h9"></i>`;
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      if (after_roll_button_slot) after_roll_button_slot.c();
      attr(div0, "role", "presentation");
      attr(div0, "aria-hidden", "true");
      attr(div0, "class", "unidentified-glyph no-transition svelte-wrz0h9");
      toggle_class(
        div0,
        "conceal",
        /*item*/
        ctx[0].system.identified === false
      );
      toggle_class(
        div0,
        "hidden",
        /*$showRoll*/
        ctx[5]
      );
      attr(div1, "class", "item-image svelte-wrz0h9");
      set_style(div1, "background-image", "url('" + /*imgUrlOverride*/
      (ctx[1] ?? /*item*/
      ctx[0].img) + "')");
      toggle_class(
        div1,
        "item-use-button-has-focus",
        /*buttonIsFocused*/
        ctx[4]
      );
      toggle_class(div1, "show-roll", !/*disabled*/
      ctx[2] && /*$showRoll*/
      ctx[5]);
      toggle_class(
        div1,
        "conceal",
        /*item*/
        ctx[0].system.identified === false
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t0);
      if (if_block) if_block.m(div1, null);
      append(div1, t1);
      if (after_roll_button_slot) {
        after_roll_button_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*item*/
      1) {
        toggle_class(
          div0,
          "conceal",
          /*item*/
          ctx2[0].system.identified === false
        );
      }
      if (!current || dirty & /*$showRoll*/
      32) {
        toggle_class(
          div0,
          "hidden",
          /*$showRoll*/
          ctx2[5]
        );
      }
      if (!/*disabled*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1E(ctx2);
          if_block.c();
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (after_roll_button_slot) {
        if (after_roll_button_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            after_roll_button_slot,
            after_roll_button_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              after_roll_button_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_after_roll_button_slot_changes
            ),
            get_after_roll_button_slot_context
          );
        }
      }
      if (!current || dirty & /*imgUrlOverride, item*/
      3) {
        set_style(div1, "background-image", "url('" + /*imgUrlOverride*/
        (ctx2[1] ?? /*item*/
        ctx2[0].img) + "')");
      }
      if (!current || dirty & /*buttonIsFocused*/
      16) {
        toggle_class(
          div1,
          "item-use-button-has-focus",
          /*buttonIsFocused*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*disabled, $showRoll*/
      36) {
        toggle_class(div1, "show-roll", !/*disabled*/
        ctx2[2] && /*$showRoll*/
        ctx2[5]);
      }
      if (!current || dirty & /*item*/
      1) {
        toggle_class(
          div1,
          "conceal",
          /*item*/
          ctx2[0].system.identified === false
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(after_roll_button_slot, local);
      current = true;
    },
    o(local) {
      transition_out(after_roll_button_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block) if_block.d();
      if (after_roll_button_slot) after_roll_button_slot.d(detaching);
    }
  };
}
function instance$3E($$self, $$props, $$invalidate) {
  let $showRoll;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(6, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { item } = $$props;
  let { imgUrlOverride = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { showDiceIconOnHover = true } = $$props;
  const showRoll = getContext(CONSTANTS.CONTEXT_GRID_CELL_HOVER);
  component_subscribe($$self, showRoll, (value) => $$invalidate(5, $showRoll = value));
  let buttonIsFocused = false;
  const click_handler = (event) => FoundryAdapter.actorTryUseItem(item, {}, { event });
  const contextmenu_handler = (event) => FoundryAdapter.onActorItemButtonContextMenu(item, { event });
  const focusin_handler = () => $$invalidate(4, buttonIsFocused = true);
  const focusout_handler = () => $$invalidate(4, buttonIsFocused = false);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("imgUrlOverride" in $$props2) $$invalidate(1, imgUrlOverride = $$props2.imgUrlOverride);
    if ("disabled" in $$props2) $$invalidate(2, disabled = $$props2.disabled);
    if ("showDiceIconOnHover" in $$props2) $$invalidate(3, showDiceIconOnHover = $$props2.showDiceIconOnHover);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    item,
    imgUrlOverride,
    disabled,
    showDiceIconOnHover,
    buttonIsFocused,
    $showRoll,
    $settingStore,
    showRoll,
    $$scope,
    slots,
    click_handler,
    contextmenu_handler,
    focusin_handler,
    focusout_handler
  ];
}
class ItemUseButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3E, create_fragment$3F, safe_not_equal, {
      item: 0,
      imgUrlOverride: 1,
      disabled: 2,
      showDiceIconOnHover: 3
    });
  }
}
function create_fragment$3E(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text("");
      attr(span, "class", "ae-marker svelte-1atytd6");
      attr(
        span,
        "title",
        /*localize*/
        ctx[0]("TIDY5E.ActiveEffectsMarkerTitle")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function instance$3D($$self) {
  const localize = FoundryAdapter.localize;
  return [localize];
}
class ActiveEffectsMarker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3D, create_fragment$3E, safe_not_equal, {});
  }
}
function create_if_block$1D(ctx) {
  let activeeffectsmarker;
  let current;
  activeeffectsmarker = new ActiveEffectsMarker({});
  return {
    c() {
      create_component(activeeffectsmarker.$$.fragment);
    },
    m(target, anchor) {
      mount_component(activeeffectsmarker, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(activeeffectsmarker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(activeeffectsmarker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(activeeffectsmarker, detaching);
    }
  };
}
function create_fragment$3D(ctx) {
  let span;
  let span_tabindex_value;
  let span_class_value;
  let t2;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let if_block = (
    /*useActiveEffectsMarker*/
    ctx[3] && /*$settingStore*/
    ctx[5].showActiveEffectsMarker && /*hasActiveEffects*/
    ctx[4] && create_if_block$1D()
  );
  return {
    c() {
      span = element("span");
      if (default_slot) default_slot.c();
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(span, "role", "button");
      attr(span, "tabindex", span_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(span, "class", span_class_value = "item-name truncate " + /*cssClass*/
      ctx[0] + " svelte-tphlr0");
      toggle_class(
        span,
        "has-children",
        /*hasChildren*/
        ctx[1]
      );
      toggle_class(
        span,
        "italic",
        /*item*/
        ctx[2].system.identified === false
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span,
            "click",
            /*click_handler*/
            ctx[9]
          ),
          listen(
            span,
            "keypress",
            /*keypress_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$settingStore*/
      32 && span_tabindex_value !== (span_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(span, "tabindex", span_tabindex_value);
      }
      if (!current || dirty & /*cssClass*/
      1 && span_class_value !== (span_class_value = "item-name truncate " + /*cssClass*/
      ctx2[0] + " svelte-tphlr0")) {
        attr(span, "class", span_class_value);
      }
      if (!current || dirty & /*cssClass, hasChildren*/
      3) {
        toggle_class(
          span,
          "has-children",
          /*hasChildren*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*cssClass, item*/
      5) {
        toggle_class(
          span,
          "italic",
          /*item*/
          ctx2[2].system.identified === false
        );
      }
      if (
        /*useActiveEffectsMarker*/
        ctx2[3] && /*$settingStore*/
        ctx2[5].showActiveEffectsMarker && /*hasActiveEffects*/
        ctx2[4]
      ) {
        if (if_block) {
          if (dirty & /*useActiveEffectsMarker, $settingStore, hasActiveEffects*/
          56) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1D();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t2);
        detach(if_block_anchor);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3C($$self, $$props, $$invalidate) {
  let hasActiveEffects;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { cssClass = "" } = $$props;
  let { hasChildren = true } = $$props;
  let { item } = $$props;
  let { useActiveEffectsMarker = true } = $$props;
  const dispatcher = createEventDispatcher();
  const click_handler = (ev) => dispatcher("toggle", ev);
  const keypress_handler = (ev) => ev.key === "Enter" && dispatcher("toggle", ev);
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
    if ("hasChildren" in $$props2) $$invalidate(1, hasChildren = $$props2.hasChildren);
    if ("item" in $$props2) $$invalidate(2, item = $$props2.item);
    if ("useActiveEffectsMarker" in $$props2) $$invalidate(3, useActiveEffectsMarker = $$props2.useActiveEffectsMarker);
    if ("$$scope" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    4) {
      $$invalidate(4, hasActiveEffects = !!item.effects?.size);
    }
  };
  return [
    cssClass,
    hasChildren,
    item,
    useActiveEffectsMarker,
    hasActiveEffects,
    $settingStore,
    dispatcher,
    $$scope,
    slots,
    click_handler,
    keypress_handler
  ];
}
class ItemName extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3C, create_fragment$3D, safe_not_equal, {
      cssClass: 0,
      hasChildren: 1,
      item: 2,
      useActiveEffectsMarker: 3
    });
  }
}
function clamp$1(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
function getPercentage(value, max) {
  max ??= 0;
  value ??= 0;
  if (max <= 0) {
    return 0;
  }
  const percentage = Math.ceil(value / max * 100);
  return clamp$1(percentage, 0, 100);
}
function toNumber(str) {
  if (str.includes("/")) {
    const pieces = str.split("/");
    return parseInt(pieces[0]) / parseInt(pieces[1]);
  }
  return +str;
}
function create_fragment$3C(ctx) {
  let div;
  let input0;
  let input0_value_value;
  let input0_disabled_value;
  let t2;
  let input1;
  let input1_value_value;
  let input1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t2 = text("\n  /\n  ");
      input1 = element("input");
      attr(input0, "class", "uses-value svelte-dfnk2f");
      attr(input0, "type", "text");
      input0.value = input0_value_value = /*item*/
      ctx[0].system.uses.value;
      input0.disabled = input0_disabled_value = !/*item*/
      ctx[0].isOwner;
      attr(input0, "data-tidy-field", "system.uses.value");
      attr(input1, "class", "uses-max svelte-dfnk2f");
      attr(input1, "type", "text");
      input1.value = input1_value_value = /*item*/
      ctx[0].system.uses.max;
      input1.disabled = input1_disabled_value = !/*item*/
      ctx[0].isOwner;
      attr(input1, "data-tidy-field", "system.uses.max");
      attr(div, "class", "item-uses svelte-dfnk2f");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      append(div, t2);
      append(div, input1);
      if (!mounted) {
        dispose = [
          listen(input0, "change", stop_propagation(prevent_default(
            /*change_handler*/
            ctx[2]
          ))),
          listen(input0, "focus", focus_handler$1),
          listen(input1, "change", stop_propagation(prevent_default(
            /*change_handler_1*/
            ctx[3]
          ))),
          listen(input1, "focus", focus_handler_1)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*item*/
      1 && input0_value_value !== (input0_value_value = /*item*/
      ctx2[0].system.uses.value) && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (dirty & /*item*/
      1 && input0_disabled_value !== (input0_disabled_value = !/*item*/
      ctx2[0].isOwner)) {
        input0.disabled = input0_disabled_value;
      }
      if (dirty & /*item*/
      1 && input1_value_value !== (input1_value_value = /*item*/
      ctx2[0].system.uses.max) && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if (dirty & /*item*/
      1 && input1_disabled_value !== (input1_disabled_value = !/*item*/
      ctx2[0].isOwner)) {
        input1.disabled = input1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function onUsesMaxChanged(event, item2) {
  let uses = parseInt(event.currentTarget.value ?? item2.system.uses.max ?? 0);
  if (isNaN(uses)) {
    uses = 0;
  }
  return item2.update({ "system.uses.max": uses });
}
const focus_handler$1 = (ev) => ev.currentTarget.select();
const focus_handler_1 = (ev) => ev.currentTarget.select();
function instance$3B($$self, $$props, $$invalidate) {
  let { item } = $$props;
  function onUsesChanged(event, item2) {
    const uses = clamp$1(0, parseInt(event.currentTarget.value), item2.system.uses.max);
    event.currentTarget.value = uses.toString();
    return item2.update({ "system.uses.value": uses });
  }
  const change_handler = (event) => onUsesChanged(event, item);
  const change_handler_1 = (event) => onUsesMaxChanged(event, item);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  return [item, onUsesChanged, change_handler, change_handler_1];
}
class ItemUses extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3B, create_fragment$3C, safe_not_equal, { item: 0 });
  }
}
function create_fragment$3B(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text("Add");
      attr(button, "type", "button");
      attr(button, "class", "item-add-uses item-list-button svelte-1sdrp90");
      button.disabled = button_disabled_value = !/*item*/
      ctx[0].isOwner;
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*item*/
      1 && button_disabled_value !== (button_disabled_value = !/*item*/
      ctx2[0].isOwner)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3A($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let { item } = $$props;
  function onAddUses() {
    let data = {};
    data["system.uses.value"] = 1;
    data["system.uses.max"] = "1";
    data["system.uses.per"] = CONSTANTS.LIMITED_USES_PER_CHARGES;
    if (item.system.activation?.type === null) {
      data["system.activation.type"] = CONSTANTS.ACTIVATION_COST_ACTION;
    }
    item.update(data);
  }
  const click_handler = () => onAddUses();
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  return [item, $settingStore, onAddUses, click_handler];
}
class ItemAddUses extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3A, create_fragment$3B, safe_not_equal, { item: 0 });
  }
}
function create_key_block$6(ctx) {
  let dnd5e_icon;
  let dnd5e_icon_src_value;
  let dnd5e_icon_levels = [
    {
      src: dnd5e_icon_src_value = /*src*/
      ctx[0]
    },
    /*$$props*/
    ctx[1]
  ];
  let dnd5e_icon_data = {};
  for (let i2 = 0; i2 < dnd5e_icon_levels.length; i2 += 1) {
    dnd5e_icon_data = assign(dnd5e_icon_data, dnd5e_icon_levels[i2]);
  }
  return {
    c() {
      dnd5e_icon = element("dnd5e-icon");
      set_attributes(dnd5e_icon, dnd5e_icon_data);
    },
    m(target, anchor) {
      insert(target, dnd5e_icon, anchor);
    },
    p(ctx2, dirty) {
      set_attributes(dnd5e_icon, dnd5e_icon_data = get_spread_update(dnd5e_icon_levels, [
        dirty & /*src*/
        1 && !src_url_equal(dnd5e_icon.src, dnd5e_icon_src_value = /*src*/
        ctx2[0]) && { src: dnd5e_icon_src_value },
        dirty & /*$$props*/
        2 && /*$$props*/
        ctx2[1]
      ]));
    },
    d(detaching) {
      if (detaching) {
        detach(dnd5e_icon);
      }
    }
  };
}
function create_fragment$3A(ctx) {
  let previous_key = (
    /*src*/
    ctx[0]
  );
  let key_block_anchor;
  let key_block = create_key_block$6(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*src*/
      1 && safe_not_equal(previous_key, previous_key = /*src*/
      ctx2[0])) {
        key_block.d(1);
        key_block = create_key_block$6(ctx2);
        key_block.c();
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
function instance$3z($$self, $$props, $$invalidate) {
  let { src } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
  };
  $$props = exclude_internal_props($$props);
  return [src, $$props];
}
class Dnd5eIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3z, create_fragment$3A, safe_not_equal, { src: 0 });
  }
}
function create_if_block_1$Z(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = null_to_empty(
        /*iconCssClass*/
        ctx[0]
      ) + " svelte-7v6r9g");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconCssClass*/
      1 && i_class_value !== (i_class_value = null_to_empty(
        /*iconCssClass*/
        ctx2[0]
      ) + " svelte-7v6r9g")) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block$1C(ctx) {
  let dnd5eicon;
  let current;
  dnd5eicon = new Dnd5eIcon({ props: { src: (
    /*iconSrc*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(dnd5eicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eicon_changes = {};
      if (dirty & /*iconSrc*/
      2) dnd5eicon_changes.src = /*iconSrc*/
      ctx2[1];
      dnd5eicon.$set(dnd5eicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(dnd5eicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eicon, detaching);
    }
  };
}
function create_fragment$3z(ctx) {
  let button;
  let t2;
  let button_title_value;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*iconCssClass*/
    ctx[0] && create_if_block_1$Z(ctx)
  );
  let if_block1 = (
    /*iconSrc*/
    ctx[1] && create_if_block$1C(ctx)
  );
  return {
    c() {
      button = element("button");
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      attr(button, "type", "button");
      attr(button, "class", "item-list-button svelte-7v6r9g");
      attr(button, "title", button_title_value = /*title*/
      ctx[2] !== void 0 ? (
        /*localize*/
        ctx[6](
          /*title*/
          ctx[2]
        )
      ) : "");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      toggle_class(button, "inactive", !/*active*/
      ctx[3]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block0) if_block0.m(button, null);
      append(button, t2);
      if (if_block1) if_block1.m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*onclick*/
            ctx[4]
          )) ctx[4].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*iconCssClass*/
        ctx[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_1$Z(ctx);
          if_block0.c();
          if_block0.m(button, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*iconSrc*/
        ctx[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*iconSrc*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1C(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*title*/
      4 && button_title_value !== (button_title_value = /*title*/
      ctx[2] !== void 0 ? (
        /*localize*/
        ctx[6](
          /*title*/
          ctx[2]
        )
      ) : "")) {
        attr(button, "title", button_title_value);
      }
      if (!current || dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*active*/
      8) {
        toggle_class(button, "inactive", !/*active*/
        ctx[3]);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$3y($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { iconCssClass = void 0 } = $$props;
  let { iconSrc = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { active: active2 = true } = $$props;
  let { onclick = void 0 } = $$props;
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("iconCssClass" in $$props2) $$invalidate(0, iconCssClass = $$props2.iconCssClass);
    if ("iconSrc" in $$props2) $$invalidate(1, iconSrc = $$props2.iconSrc);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("active" in $$props2) $$invalidate(3, active2 = $$props2.active);
    if ("onclick" in $$props2) $$invalidate(4, onclick = $$props2.onclick);
  };
  return [iconCssClass, iconSrc, title, active2, onclick, $settingStore, localize];
}
class ItemControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3y, create_fragment$3z, safe_not_equal, {
      iconCssClass: 0,
      iconSrc: 1,
      title: 2,
      active: 3,
      onclick: 4
    });
  }
}
function create_fragment$3y(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      iconCssClass: "fas fa-trash fa-fw",
      onclick: (
        /*func*/
        ctx[4]
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.ItemDelete")
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*onDelete, deleteFn*/
      3) itemcontrol_changes.onclick = /*func*/
      ctx2[4];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$3x($$self, $$props, $$invalidate) {
  let { item } = $$props;
  let { onDelete = () => true } = $$props;
  let { deleteFn = () => FoundryAdapter.onActorItemDelete(item.actor, item) } = $$props;
  const localize = FoundryAdapter.localize;
  const func2 = () => onDelete() && deleteFn();
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(3, item = $$props2.item);
    if ("onDelete" in $$props2) $$invalidate(0, onDelete = $$props2.onDelete);
    if ("deleteFn" in $$props2) $$invalidate(1, deleteFn = $$props2.deleteFn);
  };
  return [onDelete, deleteFn, localize, item, func2];
}
class ItemDeleteControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3x, create_fragment$3y, safe_not_equal, { item: 3, onDelete: 0, deleteFn: 1 });
  }
}
function create_fragment$3x(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      iconCssClass: "fas fa-edit fa-fw",
      title: (
        /*localize*/
        ctx[1]("DND5E.ItemEdit")
      ),
      onclick: (
        /*func*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*item*/
      1) itemcontrol_changes.onclick = /*func*/
      ctx2[2];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$3w($$self, $$props, $$invalidate) {
  let { item } = $$props;
  const localize = FoundryAdapter.localize;
  const func2 = () => item.sheet.render(true);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  return [item, localize, func2];
}
class ItemEditControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3w, create_fragment$3x, safe_not_equal, { item: 0 });
  }
}
function create_fragment$3w(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      title: (
        /*ctx*/
        ctx[0]?.toggleTitle
      ),
      iconCssClass: "fas fa-user-alt",
      active: (
        /*item*/
        ctx[1].system.equipped
      ),
      onclick: (
        /*toggleEquipped*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*ctx*/
      1) itemcontrol_changes.title = /*ctx*/
      ctx2[0]?.toggleTitle;
      if (dirty & /*item*/
      2) itemcontrol_changes.active = /*item*/
      ctx2[1].system.equipped;
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$3v($$self, $$props, $$invalidate) {
  let { ctx } = $$props;
  let { item } = $$props;
  function toggleEquipped() {
    const value = FoundryAdapter.getProperty(item, "system.equipped");
    item.update({ "system.equipped": !value });
  }
  $$self.$$set = ($$props2) => {
    if ("ctx" in $$props2) $$invalidate(0, ctx = $$props2.ctx);
    if ("item" in $$props2) $$invalidate(1, item = $$props2.item);
  };
  return [ctx, item, toggleEquipped];
}
class EquipControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3v, create_fragment$3w, safe_not_equal, { ctx: 0, item: 1 });
  }
}
function create_fragment$3v(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      title: (
        /*ctx*/
        ctx[0]?.attunement?.title
      ),
      iconCssClass: "fas fa-sun " + /*ctx*/
      ctx[0]?.attunement?.cls,
      active: (
        /*isAttuned*/
        ctx[1]
      ),
      onclick: (
        /*toggleAttuned*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*ctx*/
      1) itemcontrol_changes.title = /*ctx*/
      ctx2[0]?.attunement?.title;
      if (dirty & /*ctx*/
      1) itemcontrol_changes.iconCssClass = "fas fa-sun " + /*ctx*/
      ctx2[0]?.attunement?.cls;
      if (dirty & /*isAttuned*/
      2) itemcontrol_changes.active = /*isAttuned*/
      ctx2[1];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$3u($$self, $$props, $$invalidate) {
  let isAttuned;
  let { item } = $$props;
  let { ctx } = $$props;
  function toggleAttuned() {
    const actor = item.actor;
    if (!actor) {
      return;
    }
    const currentAttunementCount = actor.system.attributes.attunement.value;
    if (item.system.attuned) {
      item.update({ "system.attuned": false });
    } else {
      if (currentAttunementCount >= actor.system.attributes.attunement.max) {
        ui.notifications.warn(`${FoundryAdapter.localize("TIDY5E.AttunementWarning", { number: currentAttunementCount })}`);
      } else {
        item.update({ "system.attuned": true });
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(3, item = $$props2.item);
    if ("ctx" in $$props2) $$invalidate(0, ctx = $$props2.ctx);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    8) {
      $$invalidate(1, isAttuned = item.system.attuned);
    }
  };
  return [ctx, isAttuned, toggleAttuned, item];
}
class AttuneControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3u, create_fragment$3v, safe_not_equal, { item: 3, ctx: 0 });
  }
}
function create_fragment$3u(ctx) {
  let div;
  let i2;
  return {
    c() {
      div = element("div");
      i2 = element("i");
      attr(i2, "class", "fas fa-bookmark icon-fav fa-fw");
      attr(div, "class", "is-favorite svelte-hgw8rv");
      attr(
        div,
        "title",
        /*localize*/
        ctx[0]("TIDY5E.Favorite")
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, i2);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$3t($$self) {
  const localize = FoundryAdapter.localize;
  return [localize];
}
class InlineFavoriteIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3t, create_fragment$3u, safe_not_equal, {});
  }
}
function create_fragment$3t(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      iconCssClass: "fas fa-bookmark",
      active: (
        /*active*/
        ctx[1]
      ),
      title: (
        /*title*/
        ctx[2]
      ),
      onclick: (
        /*func*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*active*/
      2) itemcontrol_changes.active = /*active*/
      ctx2[1];
      if (dirty & /*title*/
      4) itemcontrol_changes.title = /*title*/
      ctx2[2];
      if (dirty & /*item*/
      1) itemcontrol_changes.onclick = /*func*/
      ctx2[3];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$3s($$self, $$props, $$invalidate) {
  let active2;
  let title;
  let { item } = $$props;
  const func2 = () => FoundryAdapter.toggleFavoriteItem(item);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(1, active2 = FoundryAdapter.isItemFavorited(item));
    }
    if ($$self.$$.dirty & /*active*/
    2) {
      $$invalidate(2, title = FoundryAdapter.localize(active2 ? "TIDY5E.RemoveFavorite" : "TIDY5E.AddFavorite"));
    }
  };
  return [item, active2, title, func2];
}
class ItemFavoriteControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3s, create_fragment$3t, safe_not_equal, { item: 0 });
  }
}
function get_each_context$Y(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block$Y(ctx) {
  let option;
  let t_value = (
    /*ammo*/
    ctx[8].text + ""
  );
  let t2;
  let option_value_value;
  let option_selected_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*ammo*/
      ctx[8].value;
      set_input_value(option, option.__value);
      option.selected = option_selected_value = /*item*/
      ctx[0].system.consume?.target === /*ammo*/
      ctx[8].value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*ammos*/
      4 && t_value !== (t_value = /*ammo*/
      ctx2[8].text + "")) set_data(t2, t_value);
      if (dirty & /*ammos*/
      4 && option_value_value !== (option_value_value = /*ammo*/
      ctx2[8].value)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
      if (dirty & /*item, ammos*/
      5 && option_selected_value !== (option_selected_value = /*item*/
      ctx2[0].system.consume?.target === /*ammo*/
      ctx2[8].value)) {
        option.selected = option_selected_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment$3s(ctx) {
  let select;
  let select_disabled_value;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*ammos*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Y(get_each_context$Y(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      select.disabled = select_disabled_value = !/*$context*/
      ctx[1].editable;
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen(select, "click", stop_propagation(
            /*click_handler*/
            ctx[6]
          )),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*ammos, item*/
      5) {
        each_value = ensure_array_like(
          /*ammos*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$Y(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$Y(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$context*/
      2 && select_disabled_value !== (select_disabled_value = !/*$context*/
      ctx2[1].editable)) {
        select.disabled = select_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3r($$self, $$props, $$invalidate) {
  let actor;
  let $settingStore;
  let $context;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { item } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let ammos;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  const change_handler = (event) => FoundryAdapter.onAmmoChange(item, event.currentTarget.value);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    2) {
      $$invalidate(4, actor = $context.actor ?? $context.item.actor);
    }
    if ($$self.$$.dirty & /*actor, $settingStore*/
    48) {
      $$invalidate(2, ammos = [
        { text: "", value: null, ammo: null },
        ...(actor?.items ?? []).filter((item2) => item2.system.type?.value === "ammo" && (!$settingStore.showEquippedAmmoOnly || item2.system.equipped)).map((item2) => ({
          text: `${item2.name} (${item2.system.quantity})`,
          value: item2.id,
          ammo: item2
        }))
      ]);
    }
  };
  return [
    item,
    $context,
    ammos,
    context,
    actor,
    $settingStore,
    click_handler,
    change_handler
  ];
}
class AmmoSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3r, create_fragment$3s, safe_not_equal, { item: 0 });
  }
}
class ActionListRuntime {
  static _activationTypeMappings = {};
  static addActivationTypeMappings(mappings2) {
    ActionListRuntime._activationTypeMappings = foundry.utils.mergeObject(
      ActionListRuntime._activationTypeMappings,
      mappings2
    );
  }
  static getActivationTypeMappings() {
    return { ...ActionListRuntime._activationTypeMappings };
  }
}
function scaleCantripDamageFormula(spell, formula) {
  try {
    const scaledFormula = spell._scaleCantripDamage(
      [formula],
      spell.system.scaling.formula,
      spell.actor.type === "character" ? spell.actor.system.details.level ?? 0 : spell.system.preparation.mode === "innate" ? Math.ceil(spell.actor.system.details.cr ?? 0) : spell.actor.system.details.spellLevel ?? 0,
      spell.getRollData()
    );
    return scaledFormula;
  } catch (e2) {
    error(
      "An error occurred while scaling cantrip damage. Returning original formula.",
      false,
      e2
    );
    return formula;
  }
}
function simplifyFormula(formula, removeFlavor = false) {
  try {
    if (removeFlavor) {
      formula = formula?.replace(RollTerm.FLAVOR_REGEXP, "")?.replace(RollTerm.FLAVOR_REGEXP_STRING, "")?.trim();
    }
    if (formula?.trim() === "") {
      return "";
    }
    const roll = Roll.create(formula);
    const simplifiedTerms = roll.terms.map(
      (t2) => t2.isIntermediate ? new NumericTerm({
        number: FoundryAdapter.isFoundryV12OrHigher() ? t2.evaluateSync().total : t2.evaluate({ async: false }).total,
        options: t2.options
      }) : t2
    );
    let simplifiedFormula = Roll.fromTerms(simplifiedTerms).formula;
    return simplifiedFormula;
  } catch (e2) {
    error("Unable to simplify formula due to an error.", false, e2);
    return formula;
  }
}
function getMaxPreparedSpellsSampleFormulas() {
  return [
    {
      label: "TIDY5E.Class.Artificer",
      value: "@abilities.int.mod + floor(@classes.artificer.levels / 2)"
    },
    {
      label: "TIDY5E.Class.Bard",
      value: "max(@classes.bard.levels + 3 - floor(@classes.bard.levels/20), (min(floor(@classes.bard.levels/10),1) * (14 + min(floor(@classes.bard.levels/11),1) + min(floor(@classes.bard.levels/13),1) + (min(floor(@classes.bard.levels/14),1) * 2) + min(floor(@classes.bard.levels/15),1) + min(floor(@classes.bard.levels/17),1) + (min(floor(@classes.bard.levels/18),1) * 2))))"
    },
    {
      label: "TIDY5E.Class.Cleric",
      value: "@abilities.wis.mod + @classes.cleric.levels"
    },
    {
      label: "TIDY5E.Class.Druid",
      value: "@abilities.wis.mod + @classes.druid.levels"
    },
    {
      label: "TIDY5E.Class.Paladin",
      value: "@abilities.cha.mod + floor(@classes.paladin.levels / 2)"
    },
    { label: "TIDY5E.Class.Ranger", value: "ceil(@classes.ranger.levels/2)+1" },
    {
      label: "TIDY5E.Class.Sorcerer",
      value: "min(@classes.sorcerer.levels + 1, 12 + min(floor(@classes.sorcerer.levels/13),1) + min(floor(@classes.sorcerer.levels/15),1) + min(floor(@classes.sorcerer.levels/17),1))"
    },
    {
      label: "TIDY5E.Class.Wizard",
      value: "@abilities.int.mod + @classes.wizard.levels"
    }
  ];
}
function calculateSpellAttackAndDc(actor) {
  try {
    const rollData = actor.getRollData();
    const prof = actor.system.attributes.prof ?? 0;
    const spellAbility = actor.system.attributes.spellcasting;
    const abilityMod = (spellAbility != "" ? actor.system.abilities[spellAbility].mod : 0) ?? 0;
    const spellAttackMod = prof + abilityMod;
    const rawRsak = Roll.replaceFormulaData(
      actor.system.bonuses.rsak.attack,
      rollData,
      { missing: 0, warn: false }
    );
    const rsakBonusTotal = calculateDeterministicBonus(rawRsak);
    let rsakTotal = (spellAttackMod + rsakBonusTotal).toString();
    if (!rsakTotal.startsWith("-")) {
      rsakTotal = "+" + rsakTotal;
    }
    let rawMsak = Roll.replaceFormulaData(
      actor.system.bonuses.msak.attack,
      rollData,
      { missing: 0, warn: false }
    );
    let msakBonusTotal = calculateDeterministicBonus(rawMsak);
    let msakTotal = (spellAttackMod + msakBonusTotal).toString();
    if (!msakTotal.startsWith("-")) {
      msakTotal = "+" + msakTotal;
    }
    const abilityName = CONFIG.DND5E.abilities[spellAbility]?.label ?? FoundryAdapter.localize("DND5E.None");
    return {
      dc: actor.system.attributes.spelldc,
      dcTooltip: getDcTooltip(actor),
      meleeMod: msakTotal,
      meleeTooltip: buildAttackModTooltip(
        abilityName,
        abilityMod,
        prof,
        msakBonusTotal
      ),
      meleeHasBonus: msakBonusTotal !== 0,
      rangedMod: rsakTotal,
      rangedTooltip: buildAttackModTooltip(
        abilityName,
        abilityMod,
        prof,
        rsakBonusTotal
      ),
      rangedHasBonus: rsakBonusTotal !== 0
    };
  } catch (e2) {
    error("An error occurred while calculating spell attack bonus", false, e2);
    debug("Spell attack bonus error troubleshooting details", {
      bonuses: actor.system.bonuses,
      actor
    });
    return {
      dc: actor.system.attributes.spelldc,
      dcTooltip: "",
      meleeMod: "",
      meleeTooltip: "",
      meleeHasBonus: false,
      rangedMod: "",
      rangedTooltip: "",
      rangedHasBonus: false
    };
  }
}
function buildAttackModTooltip(abilityName, abilityMod, proficiency, bonusTotal) {
  let tooltip = "";
  if (abilityMod !== 0) {
    tooltip += abilityMod < 0 ? " - " : " + ";
    tooltip += `${Math.abs(abilityMod)} (${abilityName})`;
  }
  if (proficiency !== 0) {
    tooltip += proficiency < 0 ? " - " : " + ";
    tooltip += `${Math.abs(proficiency)} (${FoundryAdapter.localize(
      "DND5E.ProficiencyBonus"
    )})`;
  }
  if (bonusTotal !== 0) {
    tooltip += bonusTotal < 0 ? " - " : " + ";
    tooltip += `${Math.abs(bonusTotal)} (${FoundryAdapter.localize(
      "DND5E.Bonus"
    )})`;
  }
  return tooltip.trim();
}
function calculateDeterministicBonus(rawBonus) {
  if (!Roll.validate(rawBonus)) {
    return 0;
  }
  const deterministicRawBonus = new Roll(rawBonus).terms.filter(
    (t2) => t2.isDeterministic
  );
  if (deterministicRawBonus.length == 0) {
    return 0;
  }
  let bonusRoll = Roll.fromTerms([new NumericTerm(0)]);
  try {
    bonusRoll = Roll.fromTerms(deterministicRawBonus);
    let bonusTotal = 0;
    if (Roll.validate(bonusRoll.formula)) {
      bonusTotal = FoundryAdapter.isFoundryV12OrHigher() ? bonusRoll.evaluateSync().total : bonusRoll.evaluate({ async: false }).total;
    }
    return bonusTotal;
  } catch (e2) {
    warn(e2.toString());
    return 0;
  }
}
function getDcTooltip(actor) {
  const base = 8;
  const spellAbility = actor.system.attributes.spellcasting;
  const abilityMod = (spellAbility != "" ? actor.system.abilities[spellAbility].mod : 0) ?? 0;
  const abilityName = CONFIG.DND5E.abilities[spellAbility]?.label ?? FoundryAdapter.localize("DND5E.None");
  const prof = actor.system.attributes.prof ?? 0;
  let tooltip = base.toString();
  if (abilityMod !== 0) {
    tooltip += abilityMod < 0 ? " - " : " + ";
    tooltip += `${Math.abs(abilityMod)} (${abilityName})`;
  }
  if (prof !== 0) {
    tooltip += prof < 0 ? " - " : " + ";
    tooltip += `${Math.abs(prof)} (${FoundryAdapter.localize(
      "DND5E.ProficiencyBonus"
    )})`;
  }
  const rawBonus = actor.system.bonuses.spell.dc?.toString()?.trim();
  if (!isNil(rawBonus, "") && Roll.validate(rawBonus)) {
    const bonusRoll = new Roll(rawBonus);
    FoundryAdapter.isFoundryV12OrHigher() ? bonusRoll.evaluateSync() : bonusRoll.evaluate({ async: false });
    const bonusTotal = bonusRoll.total;
    if (bonusTotal !== 0) {
      tooltip += bonusTotal < 0 ? " - " : " + ";
      tooltip += `${Math.abs(bonusTotal)} (${FoundryAdapter.localize(
        "DND5E.Bonus"
      )})`;
    }
  }
  return tooltip;
}
function rollRawSpellAttack(ev, actor, attackType) {
  let titleKey = attackType === "rsak" ? "TIDY5E.ActorRangedSpellAttackTitle" : attackType === "msak" ? "TIDY5E.ActorMeleeSpellAttackTitle" : "TIDY5E.ActorSpellAttackTitle";
  let title = FoundryAdapter.localize(titleKey, {
    actorName: actor.name
  });
  let flavorKey = attackType === "rsak" ? "TIDY5E.ActorRangedSpellAttackFlavorText" : attackType === "msak" ? "TIDY5E.ActorMeleeSpellAttackFlavorText" : "TIDY5E.ActorSpellAttackFlavorText";
  let flavor = FoundryAdapter.localize(flavorKey);
  const effectiveAttackType = attackType ?? "rsak";
  const rollData = {};
  const parts = [];
  const spellcastingAbility = actor.system.attributes.spellcasting;
  const spellcastingMod = actor.system.abilities[spellcastingAbility]?.mod;
  if (spellcastingAbility !== "none" && spellcastingMod) {
    parts.push("@mod");
    rollData.mod = spellcastingMod;
  }
  parts.push("@prof");
  rollData.prof = actor.system.attributes.prof;
  const actorBonusAttack = actor.system.bonuses?.[effectiveAttackType]?.attack;
  if (actorBonusAttack) {
    parts.push(actorBonusAttack);
  }
  const rollConfig = foundry.utils.mergeObject(
    {
      actor,
      data: rollData,
      critical: actor.flags["dnd5e"]?.spellCriticalThreshold,
      title,
      flavor,
      elvenAccuracy: actor.flags["dnd5e"]?.elvenAccuracy ?? false,
      halflingLucky: actor.flags["dnd5e"]?.halflingLucky ?? false,
      dialogOptions: {
        width: 400,
        top: ev ? ev.clientY - 80 : null,
        left: ev ? ev.clientX + 40 : null
      },
      messageData: {
        "flags.dnd5e.roll": {
          type: "attack"
        },
        speaker: ChatMessage.getSpeaker({ actor })
      },
      event: ev
    },
    {}
  );
  rollConfig.parts = parts;
  dnd5e.dice.d20Roll(rollConfig);
}
class ItemUtils {
  static canUse(item) {
    return ItemUtils.hasActivationType(item) && (ItemUtils.hasUnlimitedUses(item) || ItemUtils.hasSufficientLimitedUses(item)) && (!ItemUtils.hasConsumptionRequirements(item) || ItemUtils.hasSufficientConsumptionAmount(item)) && (!ItemUtils.hasRecharge(item) || ItemUtils.isCharged(item)) && ItemUtils.atLeastOneExists(item);
  }
  static atLeastOneExists(item) {
    return (item.system.quantity ?? 1) >= 1;
  }
  static hasActivationType(item) {
    return !isNil(item.system.activation?.type, "");
  }
  static hasUnlimitedUses(item) {
    return isNil(item.system.uses?.per, "");
  }
  static hasSufficientLimitedUses(item) {
    return ItemUtils.hasConfiguredUses(item) && item.system.uses?.value > 0;
  }
  static hasConfiguredUses(item) {
    return item.system.uses?.per !== null;
  }
  static hasConsumptionRequirements(item) {
    return !isNil(item.system.consume?.type, "");
  }
  static hasSufficientConsumptionAmount(item) {
    const consumeTarget = item.parent?.items?.get(item.system.consume.target);
    return (
      // If there's no consume target, then we'll be permissive and allow the system to deal with whether it's usable
      // Note: this is intentionally ignoring non-item / non-item-use consumption scenarios like consuming attributes
      isNil(item.system.consume?.target, "") || (consumeTarget?.system.quantity ?? consumeTarget?.system.uses?.value ?? 0) >= item.system.consume?.amount
    );
  }
  static hasRecharge(item) {
    return (item.system.recharge?.value ?? 0) > 0;
  }
  static isCharged(item) {
    return item.system.recharge?.charged === true;
  }
  static getMaxUses(item) {
    return item.system.uses?.max;
  }
  static sortItems(items, sortMode) {
    if (sortMode === "a") {
      items.sort((a2, b2) => a2.name.localeCompare(b2.name));
    } else if (sortMode === "m") {
      items.sort((a2, b2) => (a2.sort || 0) - (b2.sort || 0));
    }
  }
}
class SpellUtils {
  /** Is a cantrip. */
  static isCantrip(item) {
    return item.type === CONSTANTS.ITEM_TYPE_SPELL && item.system.level === 0;
  }
  /** The cantrip is castable. If cantrip preparation is turned on, then require the cantrip to be prepared to be castable. */
  static isCastableCantrip(item) {
    return SpellUtils.isCantrip(item) && (SpellUtils.isCantripPrepared(item) || SpellUtils.isAlwaysPrepared(item) || SpellUtils.isUnlimitedAtWill(item) || SpellUtils.isUnlimitedInnate(item) || ItemUtils.hasSufficientLimitedUses(item));
  }
  /** While the Cantrip Formulas rule is enabled, this cantrip must have prepared status. If the rule is not enabled, a cantrip is always prepared.  */
  static isCantripPrepared(item) {
    const prepareCantrips = SettingsProvider.settings.allowCantripsToBePrepared.get();
    return !prepareCantrips || prepareCantrips && SpellUtils.isPrepared(item);
  }
  /** Spell is castable in this moment. */
  static isCastableSpell(item) {
    return SpellUtils.isSpell(item) && (SpellUtils.isPrepared(item) || SpellUtils.isAlwaysPrepared(item) || SpellUtils.isUnlimitedAtWill(item) || SpellUtils.isUnlimitedInnate(item) || ItemUtils.hasSufficientLimitedUses(item) || SpellUtils.isPactMagic(item));
  }
  /** A spell item with a non-cantrip level. */
  static isSpell(item) {
    return item.type === CONSTANTS.ITEM_TYPE_SPELL && item.system.level > 0;
  }
  /** Spell is always prepared. */
  static isAlwaysPrepared(item) {
    return item.system.preparation?.mode === CONSTANTS.SPELL_PREPARATION_MODE_ALWAYS;
  }
  /** Is an At-Will spell with no limit on uses. */
  static isUnlimitedAtWill(item) {
    return SpellUtils.isAtWill(item) && !ItemUtils.hasConfiguredUses(item);
  }
  /** Is an At-Will spell. */
  static isAtWill(item) {
    return item.system.preparation?.mode === CONSTANTS.SPELL_PREPARATION_MODE_ATWILL;
  }
  /** Is an Innate spell with no limit on uses. */
  static isUnlimitedInnate(item) {
    return SpellUtils.isInnate(item) && !ItemUtils.hasConfiguredUses(item);
  }
  /** Is an Innate spell. */
  static isInnate(item) {
    return item.system.preparation?.mode === CONSTANTS.SPELL_PREPARATION_MODE_INNATE;
  }
  /** Is pact magic. */
  static isPactMagic(item) {
    return item.system.preparation?.mode === CONSTANTS.SPELL_PREPARATION_MODE_PACT;
  }
  /** Is a spell that requires preparation and is prepared. */
  static isPrepared(item) {
    return item.system.preparation?.mode === "prepared" && item.system.preparation?.prepared;
  }
  /** Is a spell that requires preparation but is unprepared. */
  static isUnprepared(item) {
    return item.system.preparation?.mode === "prepared" && !item.system.preparation?.prepared;
  }
}
class SheetPreferencesService {
  static async setDocumentTypeTabPreference(documentType, tabId, property, value) {
    await game.user.setFlag(
      CONSTANTS.MODULE_ID,
      `sheetPreferences.${documentType}.tabs.${tabId}.${property}`,
      value
    );
  }
  static async setDocumentTypePreference(documentType, property, value) {
    await game.user.setFlag(
      CONSTANTS.MODULE_ID,
      `sheetPreferences.${documentType}.${property}`,
      value
    );
  }
  static get() {
    return foundry.utils.getProperty(
      game.user,
      `flags.${CONSTANTS.MODULE_ID}.sheetPreferences`
    ) ?? {};
  }
  static getByType(documentType) {
    return foundry.utils.getProperty(
      game.user,
      `flags.${CONSTANTS.MODULE_ID}.sheetPreferences.${documentType}`
    ) ?? {};
  }
}
class SheetSections {
  static generateCustomSpellbookSections(spells, options) {
    const customSpellbook = {};
    spells.forEach(
      (s2) => SheetSections.applySpellToSection(customSpellbook, s2, options)
    );
    return Object.values(customSpellbook);
  }
  static applySpellToSection(spellbook, spell, options) {
    const customSectionName = TidyFlags.section.get(spell);
    if (!customSectionName) {
      return;
    }
    const section = spellbook[customSectionName] ??= {
      dataset: {
        [TidyFlags.section.prop]: customSectionName
      },
      spells: [],
      label: customSectionName,
      canCreate: true,
      canPrepare: true,
      usesSlots: false,
      key: customSectionName,
      custom: {
        section: customSectionName,
        creationItemTypes: [CONSTANTS.ITEM_TYPE_SPELL]
      },
      show: true,
      ...options
    };
    section.spells.push(spell);
  }
  static sortKeyedSections(sections, sectionConfigs) {
    const sortMap = new Map(
      Object.values(sectionConfigs ?? {}).map((e2) => [e2.key, e2.order])
    );
    const defaultSortMap = new Map(
      SheetSections.getDefaultSortOrder(sections).map((e2, i2) => [e2, i2])
    );
    const maxLength = sections.length;
    sections.sort(
      (a2, b2) => (sortMap.get(a2.key) ?? defaultSortMap.get(a2.key) ?? maxLength) - (sortMap.get(b2.key) ?? defaultSortMap.get(b2.key) ?? maxLength)
    );
    return sections;
  }
  static getDefaultSortOrder(sections) {
    const { defaultSections, customSections } = sections.reduce(
      (prev, curr) => {
        curr.custom ? prev.customSections.push(curr.key) : prev.defaultSections.push(curr.key);
        return prev;
      },
      { defaultSections: [], customSections: [] }
    );
    customSections.sort((a2, b2) => a2.localeCompare(b2));
    return [...defaultSections, ...customSections];
  }
  static prepareTidySpellbook(context, spells, options = {}, app) {
    const customSectionSpells = spells.filter((s2) => TidyFlags.section.get(s2));
    spells = spells.filter((s2) => !TidyFlags.section.get(s2));
    const spellbook = app._prepareSpellbook(context, spells).map(
      (s2) => ({
        ...s2,
        key: s2.key ?? s2.prop,
        show: true
      })
    );
    const spellbookMap = spellbook.reduce(
      (prev, curr) => {
        const key = curr.prop ?? "";
        curr.key = key;
        curr.dataset["system"] = {
          level: curr.dataset.level,
          preparationMode: curr.dataset.preparationMode
        };
        delete curr.dataset.level;
        delete curr.dataset.preparationMode;
        prev[key] = curr;
        return prev;
      },
      {}
    );
    customSectionSpells.forEach((spell) => {
      SheetSections.applySpellToSection(spellbookMap, spell, options);
    });
    return Object.values(spellbookMap);
  }
  static prepareClassItems(context, classes, subclasses, actor) {
    const maxLevelDelta = CONFIG.DND5E.maxLevel - actor.system.details.level;
    return classes.reduce((arr, cls) => {
      arr.push(cls);
      const ctx = context.itemContext[cls.id] ??= {};
      ctx.availableLevels = Array.fromRange(CONFIG.DND5E.maxLevel + 1).slice(1).map((level) => {
        const delta = level - cls.system.levels;
        return { level, delta, disabled: delta > maxLevelDelta };
      });
      const identifier = cls.system.identifier || cls.name.slugify({ strict: true });
      const subclass = subclasses.findSplice(
        (s2) => s2.system.classIdentifier === identifier
      );
      if (subclass) {
        arr.push(subclass);
        const subclassCtx = context.itemContext[subclass.id] ??= {};
        subclassCtx.parent = cls;
      }
      return arr;
    }, []);
  }
  static collocateSubItems(context, items) {
    const itemContext = context.itemContext;
    const { parents, parentIdToChildren } = items.reduce(
      (prev, item) => {
        const parentItem = itemContext[item.id]?.parent;
        const isChild = !!parentItem;
        if (isChild) {
          const children2 = prev.parentIdToChildren.get(parentItem.id) ?? [];
          children2.push(item);
          prev.parentIdToChildren.set(parentItem.id, children2);
        } else {
          prev.parents.push(item);
        }
        return prev;
      },
      { parents: [], parentIdToChildren: /* @__PURE__ */ new Map() }
    );
    if (parents.length === items.length) {
      return items;
    }
    return parents.reduce((result, item) => {
      result.push(item);
      const children2 = parentIdToChildren.get(item.id);
      if (children2) {
        result.push(...children2);
      }
      return result;
    }, []);
  }
  static accountForExternalSections(props, data) {
    props.forEach((prop) => {
      const sectionCollection = data[prop];
      sectionCollection?.forEach((section) => {
        if (!isNil(section.key)) {
          return;
        }
        section.key = SheetSections.getSectionKey(section);
        section.canCreate = false;
        section.show = true;
      });
    });
  }
  static getSectionKey(section) {
    if (isNil(section.key)) {
      return `${section.label}-external`;
    }
    return section.key;
  }
  static configureInventory(sections, tabId, sheetPreferences, sectionConfig) {
    try {
      sections = SheetSections.sortKeyedSections(sections, sectionConfig);
      const sortMode = sheetPreferences.tabs?.[tabId]?.sort ?? "m";
      sections.forEach((section) => {
        ItemUtils.sortItems(section.items, sortMode);
        section.show = sectionConfig?.[section.key]?.show !== false;
      });
    } catch (e2) {
      error("An error occurred while configuring inventory", false, e2);
    }
    return sections;
  }
  static configureSpellbook(document2, tabId, sections) {
    try {
      const sectionConfigs = TidyFlags.sectionConfig.get(document2);
      sections = SheetSections.sortKeyedSections(
        sections,
        sectionConfigs?.[tabId]
      );
      const characterPreferences = SheetPreferencesService.getByType(
        document2.type
      );
      const sortMode = characterPreferences.tabs?.[tabId]?.sort ?? "m";
      sections.forEach((section) => {
        ItemUtils.sortItems(section.spells, sortMode);
        section.show = sectionConfigs?.[CONSTANTS.TAB_CHARACTER_SPELLBOOK]?.[section.key]?.show !== false;
      });
    } catch (e2) {
      error("An error occurred while configuring spells", false, e2);
    }
    return sections;
  }
  static configureFavorites(favoriteSections, actor, tabId, sheetPreferences, sectionConfig) {
    try {
      favoriteSections = SheetSections.sortKeyedSections(
        favoriteSections,
        sectionConfig
      );
      const sortMode = sheetPreferences.tabs?.[tabId]?.sort ?? "m";
      const favoritesIdMap = actor.system.favorites.reduce(
        (map, f2) => {
          map.set(f2.id, f2);
          return map;
        },
        /* @__PURE__ */ new Map()
      );
      favoriteSections.forEach((section) => {
        if ("effects" in section) {
          let effectContexts = section.effects;
          if (sortMode === "m") {
            const getSort = (effects) => favoritesIdMap.get(effects.getRelativeUUID(actor))?.sort ?? Number.MAX_SAFE_INTEGER;
            effectContexts.sort(
              (a2, b2) => getSort(a2.effect) - getSort(b2.effect)
            );
          } else {
            effectContexts.sort(
              (a2, b2) => a2.effect.name.localeCompare(b2.effect.name)
            );
          }
        } else {
          let items = "spells" in section ? section.spells : section.items;
          if (sortMode === "m") {
            const getSort = (item) => favoritesIdMap.get(item.getRelativeUUID(actor))?.sort ?? Number.MAX_SAFE_INTEGER;
            items.sort((a2, b2) => getSort(a2) - getSort(b2));
          } else {
            ItemUtils.sortItems(items, sortMode);
          }
          if ("spells" in section) {
            section.spells = items;
          } else {
            section.items = items;
          }
        }
        section.show = sectionConfig?.[section.key]?.show !== false;
      });
    } catch (e2) {
      error("An error occurred while configuring favorites", false, e2);
    }
    return favoriteSections;
  }
  static configureFeatures(features, context, tabId, sheetPreferences, sectionConfig) {
    try {
      features = SheetSections.sortKeyedSections(features, sectionConfig);
      const sortMode = sheetPreferences.tabs?.[tabId]?.sort ?? "m";
      features.forEach((section) => {
        ItemUtils.sortItems(section.items, sortMode);
        section.items = SheetSections.collocateSubItems(context, section.items);
        section.show = sectionConfig?.[section.key]?.show !== false;
      });
    } catch (e2) {
      error("An error occurred while configuring features", false, e2);
    }
    return features;
  }
  static configureActions(sections, tabId, sheetPreferences, sectionConfigs) {
    try {
      sections = SheetSections.sortKeyedSections(sections, sectionConfigs);
      const sortMode = sheetPreferences.tabs?.[tabId]?.sort ?? "m";
      sections.forEach((section) => {
        sortActions(section, sortMode);
        section.show = sectionConfigs?.[section.key]?.show !== false;
      });
    } catch (e2) {
      error("An error occurred while configuring actions", false, e2);
    }
    return sections;
  }
}
class Inventory {
  static getDefaultInventoryTypes() {
    return Object.entries(CONFIG.Item.dataModels).filter(([, model]) => model.metadata?.inventoryItem).sort(
      ([, lhs], [, rhs]) => lhs.metadata.inventoryOrder - rhs.metadata.inventoryOrder
    ).map((entry) => entry[0]);
  }
  static getDefaultInventorySections(options = {}) {
    const inventoryTypes = Inventory.getDefaultInventoryTypes();
    const inventory = {};
    for (const type of inventoryTypes) {
      inventory[type] = {
        canCreate: true,
        dataset: { type },
        items: [],
        key: type,
        label: `${CONFIG.Item.typeLabels[type]}Pl`,
        show: true,
        custom: void 0,
        isExternal: false,
        ...options
      };
    }
    return inventory;
  }
  static applyInventoryItemToSection(inventory, item, defaultInventoryTypes, customSectionOptions) {
    const customSectionName = TidyFlags.section.get(item);
    if (!customSectionName) {
      inventory[item.type].items.push(item);
      return;
    }
    const customSection = inventory[customSectionName] ??= {
      dataset: { [TidyFlags.section.prop]: customSectionName },
      items: [],
      label: customSectionName,
      canCreate: true,
      key: customSectionName,
      custom: {
        section: customSectionName,
        creationItemTypes: [...defaultInventoryTypes]
      },
      show: true,
      ...customSectionOptions
    };
    customSection.items.push(item);
  }
  static async getContainerPanelItems(items) {
    let containerPanelItems = [];
    try {
      let containers = items.filter((i2) => i2.type === CONSTANTS.ITEM_TYPE_CONTAINER).toSorted((a2, b2) => a2.sort - b2.sort);
      for (let container of containers) {
        const capacity = await container.system.computeCapacity();
        containerPanelItems.push({
          container,
          ...capacity
        });
      }
    } catch (e2) {
      error(
        "An error occurred while preparing containers for the container panel",
        false,
        e2
      );
    }
    return containerPanelItems;
  }
  static getInventory(items, options = {
    canCreate: false
  }) {
    const inventory = Inventory.getDefaultInventorySections();
    const inventoryTypes = Inventory.getDefaultInventoryTypes();
    for (let item of items) {
      Inventory.applyInventoryItemToSection(
        inventory,
        item,
        inventoryTypes,
        options
      );
    }
    return Object.values(inventory);
  }
}
class Container {
  static async getContainerContents(item) {
    const containerItems = (await item.system.contents).values();
    return {
      capacity: await item.system.computeCapacity(),
      currency: item.system.currency,
      contents: Inventory.getInventory(containerItems),
      itemContext: await Container.getContainerItemContext(item)
    };
  }
  static async getContainerItemContext(container) {
    const itemContext = {};
    const favorites = container.actor?.system.favorites;
    const containerValues = (await container.system.contents).values();
    for (const item of containerValues) {
      const ctx = itemContext[item.id] ??= {};
      ctx.totalWeight = (await item.system.totalWeight).toNearest(0.1);
      ctx.isStack = item.system.quantity > 1;
      ctx.attunement = FoundryAdapter.getAttunementContext(item);
      if (favorites) {
        const relativeUuid = item.getRelativeUUID(container.actor);
        ctx.favoriteId = item.actor.system.favorites?.find(
          (f2) => f2.id === relativeUuid
        )?.id;
      }
      if (item.type === CONSTANTS.ITEM_TYPE_CONTAINER) {
        ctx.containerContents = await Container.getContainerContents(item);
      }
    }
    return itemContext;
  }
}
const itemTypeSortValues = {
  weapon: 1,
  equipment: 2,
  feat: 3,
  spell: 4,
  consumable: 5,
  tool: 6,
  class: 8,
  loot: 9
};
const activationTypeSortValues = {
  action: 1,
  bonus: 2,
  reaction: 3,
  legendary: 4,
  mythic: 5,
  lair: 6,
  crew: 7,
  special: 8
};
async function getActorActionSections(actor) {
  try {
    let eligibleItems = [];
    for (let item of actor.items) {
      if (!isItemInActionList(item)) {
        continue;
      }
      eligibleItems.push(await mapActionItem(item));
    }
    return buildActionSections(actor, eligibleItems);
  } catch (e2) {
    error("An error occurred while getting actions", false, e2);
    return [];
  }
}
function sortActions(section, sortMode) {
  section.actions.sort(({ item: a2 }, { item: b2 }) => {
    if (sortMode === "a") {
      return a2.name.localeCompare(b2.name);
    }
    if (a2.type !== b2.type) {
      return itemTypeSortValues[a2.type] - itemTypeSortValues[b2.type];
    }
    if (a2.type === "spell" && b2.type === "spell") {
      return a2.system.level - b2.system.level;
    }
    return (a2.sort || 0) - (b2.sort || 0);
  });
}
function buildActionSections(actor, actionItems) {
  const customMappings = ActionListRuntime.getActivationTypeMappings();
  let actionSections = {};
  Object.keys(activationTypeSortValues).forEach((activationType) => {
    actionSections[activationType] = {
      actions: [],
      dataset: {},
      label: FoundryAdapter.getActivationTypeLabel(activationType),
      key: activationType,
      show: true
    };
  });
  for (let actionItem of actionItems) {
    const customSectionName = TidyFlags.actionSection.get(actionItem.item);
    if (customSectionName) {
      const customSection = actionSections[customSectionName] ??= {
        actions: [],
        dataset: {},
        key: customSectionName,
        label: FoundryAdapter.localize(customSectionName),
        show: true,
        custom: {
          creationItemTypes: [],
          section: customSectionName
        }
      };
      customSection.actions.push(actionItem);
    } else {
      const activationType = getActivationType(
        actionItem.item.system.activation?.type,
        customMappings
      );
      const section = actionSections[activationType] ??= {
        actions: [],
        dataset: {},
        key: activationType,
        label: FoundryAdapter.getActivationTypeLabel(activationType),
        show: true
      };
      section.actions.push(actionItem);
    }
  }
  return Object.values(actionSections);
}
function isItemInActionList(item) {
  const override = TidyFlags.actionFilterOverride.get(item);
  if (override !== void 0 && override !== null) {
    return override;
  }
  switch (item.type) {
    case CONSTANTS.ITEM_TYPE_WEAPON: {
      return item.system.equipped;
    }
    case CONSTANTS.ITEM_TYPE_EQUIPMENT: {
      return item.system.equipped && isActiveItem(item.system.activation?.type);
    }
    case CONSTANTS.ITEM_TYPE_CONSUMABLE: {
      return SettingsProvider.settings.actionListIncludeConsumables.get() && isActiveItem(item.system.activation?.type);
    }
    case CONSTANTS.ITEM_TYPE_SPELL: {
      const limitToCantrips = SettingsProvider.settings.actionListLimitActionsToCantrips.get();
      if (!SpellUtils.isCantrip(item) && (limitToCantrips || SpellUtils.isUnprepared(item))) {
        return false;
      }
      const isReaction = item.system.activation?.type === CONSTANTS.ACTIVATION_COST_REACTION;
      const isBonusAction = item.system.activation?.type === CONSTANTS.ACTIVATION_COST_BONUS;
      const isDamageDealer = item.system.damage?.parts?.length > 0;
      let shouldInclude = isReaction || isBonusAction || isDamageDealer;
      if (SettingsProvider.settings.actionListIncludeMinuteLongSpellsAsActions.get()) {
        const isOneMinuter = item.system?.duration?.units === "minute" && item.system?.duration?.value === 1;
        const isOneRounder = item.system?.duration?.units === "round" && item.system?.duration?.value === 1;
        shouldInclude = shouldInclude || isOneMinuter || isOneRounder;
      }
      if (SettingsProvider.settings.actionListIncludeSpellsWithActiveEffects.get()) {
        const hasEffects = !!item.effects.size;
        shouldInclude = shouldInclude || hasEffects;
      }
      return shouldInclude;
    }
    case CONSTANTS.ITEM_TYPE_FEAT: {
      return !!item.system.activation?.type;
    }
    default: {
      return false;
    }
  }
}
async function mapActionItem(item) {
  try {
    let calculatedDerivedDamage = Array.isArray(item.labels.derivedDamage) ? [...item.labels.derivedDamage].map(
      ({ formula, label, damageType }, i2) => {
        const rawDamagePartFormula = item.system.damage?.parts[i2]?.[0];
        if (rawDamagePartFormula?.trim() === "") {
          formula = "";
        }
        formula = simplifyFormula(formula, true);
        const damageHealingTypeLabel = FoundryAdapter.lookupDamageType(damageType) ?? FoundryAdapter.lookupHealingType(damageType) ?? "";
        if (item.type === "spell" && item.system.scaling?.mode === "cantrip" && SettingsProvider.settings.actionListScaleCantripDamage.get()) {
          formula = scaleCantripDamageFormula(item, formula);
          label = `${formula} ${damageHealingTypeLabel}`;
        }
        return {
          label,
          formula,
          damageType,
          damageHealingTypeLabel
        };
      }
    ) : [];
    let containerContents = void 0;
    if (item.type === CONSTANTS.ITEM_TYPE_CONTAINER) {
      containerContents = await Container.getContainerContents(item);
    }
    return {
      item,
      typeLabel: FoundryAdapter.localize(`ITEM.Type${item.type.titleCase()}`),
      calculatedDerivedDamage,
      containerContents,
      ...getRangeTitles(item)
    };
  } catch (e2) {
    error(
      "An error occurred while processing an item for the action list",
      false,
      e2
    );
    debug("Action list mapping error troubleshooting info", { item });
    return {
      item,
      typeLabel: FoundryAdapter.localize(`ITEM.Type${item.type.titleCase()}`),
      calculatedDerivedDamage: [],
      rangeTitle: "",
      rangeSubtitle: ""
    };
  }
}
function getRangeTitles(item) {
  const rangeSubtitle = item.system.target?.type !== "self" && item.labels?.target ? item.labels.target : null;
  const rangeTitle = item.system.target?.type === "self" ? item.labels.target : hasRange(item) ? item.labels.range : rangeSubtitle !== null ? "" : null;
  return {
    rangeTitle,
    rangeSubtitle
  };
}
function hasRange(item) {
  return !isNil(item.system.range?.units);
}
function getActivationType(activationType, customMappings) {
  const customMapping = customMappings[activationType];
  if (customMapping) {
    return customMapping;
  }
  if (activationType in activationTypeSortValues) {
    return activationType;
  }
  return "other";
}
function isActiveItem(activationType) {
  if (!activationType) {
    return false;
  }
  if (["minute", "hour", "day", "none"].includes(activationType)) {
    return false;
  }
  return true;
}
class Actions {
  static get damageAndHealingTypesIconSrcMap() {
    const damageTypes = Object.entries(CONFIG.DND5E.damageTypes).reduce((obj, [key, damageType]) => {
      obj[key] = damageType.icon;
      return obj;
    }, {});
    const healingTypes = Object.entries(CONFIG.DND5E.healingTypes).reduce((obj, [key, damageType]) => {
      obj[key] = damageType.icon;
      return obj;
    }, {});
    return {
      ...damageTypes,
      ...healingTypes
    };
  }
}
function actorUsesActionFeature(actor) {
  const selectedTabIds = TidyFlags.selectedTabs.get(actor);
  if (selectedTabIds) {
    return selectedTabIds.includes(CONSTANTS.TAB_ACTOR_ACTIONS);
  }
  const defaultTabIds = actor.type === CONSTANTS.SHEET_TYPE_CHARACTER ? SettingsProvider.settings.defaultCharacterSheetTabs.get() : actor.type === CONSTANTS.SHEET_TYPE_NPC ? SettingsProvider.settings.defaultNpcSheetTabs.get() : actor.type === CONSTANTS.SHEET_TYPE_VEHICLE ? SettingsProvider.settings.defaultVehicleSheetTabs.get() : [];
  return defaultTabIds.includes(CONSTANTS.TAB_ACTOR_ACTIONS);
}
function create_fragment$3r(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      iconCssClass: "fas fa-fist-raised",
      active: (
        /*active*/
        ctx[2]
      ),
      title: (
        /*title*/
        ctx[1]
      ),
      onclick: (
        /*func*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*active*/
      4) itemcontrol_changes.active = /*active*/
      ctx2[2];
      if (dirty & /*title*/
      2) itemcontrol_changes.title = /*title*/
      ctx2[1];
      if (dirty & /*item*/
      1) itemcontrol_changes.onclick = /*func*/
      ctx2[3];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$3q($$self, $$props, $$invalidate) {
  let active2;
  let { item } = $$props;
  let title;
  const localize = FoundryAdapter.localize;
  const func2 = (ev) => ev.shiftKey ? TidyFlags.actionFilterOverride.unset(item) : TidyFlags.actionFilterOverride.set(item, !isItemInActionList(item));
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(2, active2 = isItemInActionList(item));
    }
    if ($$self.$$.dirty & /*item*/
    1) {
      {
        const flagValue = TidyFlags.actionFilterOverride.get(item);
        const titleKey = flagValue === true ? "TIDY5E.Actions.OverriddenSetOverrideFalse" : flagValue === false ? "TIDY5E.Actions.OverriddenSetOverrideTrue" : isItemInActionList(item) ? "TIDY5E.Actions.SetOverrideFalse" : "TIDY5E.Actions.SetOverrideTrue";
        $$invalidate(1, title = localize(titleKey));
      }
    }
  };
  return [item, title, active2, func2];
}
class ActionFilterOverrideControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3q, create_fragment$3r, safe_not_equal, { item: 0 });
  }
}
function processInputChangeDelta(value, entity, field) {
  if (["+", "-"].includes(value[0])) {
    const delta = parseFloat(value);
    return Number(FoundryAdapter.getProperty(entity, field)) + delta;
  } else if (value[0] === "=") {
    return Number(value.slice(1));
  }
  return Number(value);
}
function create_fragment$3q(ctx) {
  let input;
  let input_data_tooltip_value;
  let input_disabled_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "text" },
    { id: (
      /*id*/
      ctx[3]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[0]
    ) },
    {
      "data-tooltip": input_data_tooltip_value = /*activeEffectApplied*/
      ctx[13] ? (
        /*overrideTooltip*/
        ctx[12]
      ) : (
        /*tooltip*/
        ctx[2]
      )
    },
    /*actualDataset*/
    ctx[15],
    { class: (
      /*cssClass*/
      ctx[4]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[5]
    ) },
    {
      "aria-describedby": (
        /*ariaDescribedBy*/
        ctx[6]
      )
    },
    { title: (
      /*title*/
      ctx[8]
    ) },
    {
      disabled: input_disabled_value = /*disabled*/
      ctx[9] || /*activeEffectApplied*/
      ctx[13]
    },
    /*$$props*/
    ctx[18].attributes,
    { "data-tidy-field": (
      /*field*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus) input.focus();
      ctx[30](input);
      set_input_value(
        input,
        /*draftValue*/
        ctx[14]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[31]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[32]
          ),
          listen(
            input,
            "click",
            /*click_handler*/
            ctx[28]
          ),
          listen(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[29]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[33]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        dirty[0] & /*id*/
        8 && { id: (
          /*id*/
          ctx2[3]
        ) },
        dirty[0] & /*placeholder*/
        1 && { placeholder: (
          /*placeholder*/
          ctx2[0]
        ) },
        dirty[0] & /*activeEffectApplied, overrideTooltip, tooltip*/
        12292 && input_data_tooltip_value !== (input_data_tooltip_value = /*activeEffectApplied*/
        ctx2[13] ? (
          /*overrideTooltip*/
          ctx2[12]
        ) : (
          /*tooltip*/
          ctx2[2]
        )) && { "data-tooltip": input_data_tooltip_value },
        dirty[0] & /*actualDataset*/
        32768 && /*actualDataset*/
        ctx2[15],
        dirty[0] & /*cssClass*/
        16 && { class: (
          /*cssClass*/
          ctx2[4]
        ) },
        dirty[0] & /*maxlength*/
        32 && { maxlength: (
          /*maxlength*/
          ctx2[5]
        ) },
        dirty[0] & /*ariaDescribedBy*/
        64 && {
          "aria-describedby": (
            /*ariaDescribedBy*/
            ctx2[6]
          )
        },
        dirty[0] & /*title*/
        256 && { title: (
          /*title*/
          ctx2[8]
        ) },
        dirty[0] & /*disabled, activeEffectApplied*/
        8704 && input_disabled_value !== (input_disabled_value = /*disabled*/
        ctx2[9] || /*activeEffectApplied*/
        ctx2[13]) && { disabled: input_disabled_value },
        dirty[0] & /*$$props*/
        262144 && /*$$props*/
        ctx2[18].attributes,
        dirty[0] & /*field*/
        2 && { "data-tidy-field": (
          /*field*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*draftValue*/
      16384 && input.value !== /*draftValue*/
      ctx2[14]) {
        set_input_value(
          input,
          /*draftValue*/
          ctx2[14]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[30](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3p($$self, $$props, $$invalidate) {
  let draftValue;
  let actualDataset;
  let activeEffectApplied;
  let isEnchanted;
  let overrideTooltip;
  let $context;
  let { value = null } = $$props;
  let { placeholder = null } = $$props;
  let { field } = $$props;
  let { document: document2 } = $$props;
  let { tooltip = null } = $$props;
  let { id = null } = $$props;
  let { dataset = null } = $$props;
  let { cssClass = null } = $$props;
  let { maxlength = null } = $$props;
  let { ariaDescribedBy = null } = $$props;
  let { selectOnFocus = false } = $$props;
  let { saveEmptyAsNull = false } = $$props;
  let { title = null } = $$props;
  let { allowDeltaChanges = false } = $$props;
  let { disabled = false } = $$props;
  let { onSaveChange = () => true } = $$props;
  let { additionalDataToSave = {} } = $$props;
  let { stopChangePropagation = false } = $$props;
  let theInput;
  async function saveChange(event) {
    stopChangePropagation && event.stopPropagation();
    const targetValue = event.currentTarget.value;
    let valueToSave = saveEmptyAsNull && targetValue === "" ? null : !isNaN(parseInt(targetValue)) && allowDeltaChanges ? processInputChangeDelta(targetValue, document2, field) : targetValue;
    await document2.update({
      ...additionalDataToSave,
      [field]: valueToSave
    });
    $$invalidate(14, draftValue = value?.toString() ?? "");
    setTimeout(() => {
      if (selectOnFocus && theInput === window.document.activeElement) {
        theInput.select();
      }
    });
  }
  const context = getContext("context");
  component_subscribe($$self, context, (value2) => $$invalidate(27, $context = value2));
  const localize = FoundryAdapter.localize;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      theInput = $$value;
      $$invalidate(11, theInput);
    });
  }
  function input_input_handler() {
    draftValue = this.value;
    $$invalidate(14, draftValue), $$invalidate(19, value);
  }
  const change_handler = (ev) => onSaveChange(ev) && saveChange(ev);
  const focus_handler2 = (ev) => selectOnFocus && ev.currentTarget.select();
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props) $$invalidate(19, value = $$new_props.value);
    if ("placeholder" in $$new_props) $$invalidate(0, placeholder = $$new_props.placeholder);
    if ("field" in $$new_props) $$invalidate(1, field = $$new_props.field);
    if ("document" in $$new_props) $$invalidate(20, document2 = $$new_props.document);
    if ("tooltip" in $$new_props) $$invalidate(2, tooltip = $$new_props.tooltip);
    if ("id" in $$new_props) $$invalidate(3, id = $$new_props.id);
    if ("dataset" in $$new_props) $$invalidate(21, dataset = $$new_props.dataset);
    if ("cssClass" in $$new_props) $$invalidate(4, cssClass = $$new_props.cssClass);
    if ("maxlength" in $$new_props) $$invalidate(5, maxlength = $$new_props.maxlength);
    if ("ariaDescribedBy" in $$new_props) $$invalidate(6, ariaDescribedBy = $$new_props.ariaDescribedBy);
    if ("selectOnFocus" in $$new_props) $$invalidate(7, selectOnFocus = $$new_props.selectOnFocus);
    if ("saveEmptyAsNull" in $$new_props) $$invalidate(22, saveEmptyAsNull = $$new_props.saveEmptyAsNull);
    if ("title" in $$new_props) $$invalidate(8, title = $$new_props.title);
    if ("allowDeltaChanges" in $$new_props) $$invalidate(23, allowDeltaChanges = $$new_props.allowDeltaChanges);
    if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
    if ("onSaveChange" in $$new_props) $$invalidate(10, onSaveChange = $$new_props.onSaveChange);
    if ("additionalDataToSave" in $$new_props) $$invalidate(24, additionalDataToSave = $$new_props.additionalDataToSave);
    if ("stopChangePropagation" in $$new_props) $$invalidate(25, stopChangePropagation = $$new_props.stopChangePropagation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    524288) {
      $$invalidate(14, draftValue = value?.toString() ?? "");
    }
    if ($$self.$$.dirty[0] & /*dataset*/
    2097152) {
      $$invalidate(15, actualDataset = buildDataset(dataset));
    }
    if ($$self.$$.dirty[0] & /*document, field*/
    1048578) {
      $$invalidate(13, activeEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(document2, field));
    }
    if ($$self.$$.dirty[0] & /*$context, field*/
    134217730) {
      $$invalidate(26, isEnchanted = $context.itemOverrides instanceof Set && $context.itemOverrides.has(field));
    }
    if ($$self.$$.dirty[0] & /*isEnchanted*/
    67108864) {
      $$invalidate(12, overrideTooltip = isEnchanted ? localize("DND5E.Enchantment.Warning.Override") : localize("DND5E.ActiveEffectOverrideWarning"));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    placeholder,
    field,
    tooltip,
    id,
    cssClass,
    maxlength,
    ariaDescribedBy,
    selectOnFocus,
    title,
    disabled,
    onSaveChange,
    theInput,
    overrideTooltip,
    activeEffectApplied,
    draftValue,
    actualDataset,
    saveChange,
    context,
    $$props,
    value,
    document2,
    dataset,
    saveEmptyAsNull,
    allowDeltaChanges,
    additionalDataToSave,
    stopChangePropagation,
    isEnchanted,
    $context,
    click_handler,
    keypress_handler,
    input_binding,
    input_input_handler,
    change_handler,
    focus_handler2
  ];
}
let TextInput$1 = class TextInput extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3p,
      create_fragment$3q,
      safe_not_equal,
      {
        value: 19,
        placeholder: 0,
        field: 1,
        document: 20,
        tooltip: 2,
        id: 3,
        dataset: 21,
        cssClass: 4,
        maxlength: 5,
        ariaDescribedBy: 6,
        selectOnFocus: 7,
        saveEmptyAsNull: 22,
        title: 8,
        allowDeltaChanges: 23,
        disabled: 9,
        onSaveChange: 10,
        additionalDataToSave: 24,
        stopChangePropagation: 25
      },
      null,
      [-1, -1]
    );
  }
};
function get_each_context$X(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  return child_ctx;
}
function create_else_block$W(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "";
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$1B(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*control*/
    ctx[2].props?.(
      /*params*/
      ctx[1]
    )
  ];
  var switch_value = (
    /*control*/
    ctx[2].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*controls, params*/
    3) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*control*/
        ctx2[2].props?.(
          /*params*/
          ctx2[1]
        )
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*controls*/
      1 && switch_value !== (switch_value = /*control*/
      ctx2[2].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*controls, params*/
        3 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*control*/
          ctx2[2].props?.(
            /*params*/
            ctx2[1]
          )
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block$X(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1B, create_else_block$W];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*controls, params*/
    3) show_if = null;
    if (show_if == null) show_if = !!/*control*/
    (ctx2[2].visible === void 0 || /*control*/
    ctx2[2].visible(
      /*params*/
      ctx2[1]
    ));
    if (show_if) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment$3p(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*controls*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$X(get_each_context$X(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "tidy5e-classic-controls svelte-m2fs4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*controls, params, undefined*/
      3) {
        each_value = ensure_array_like(
          /*controls*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$X(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$X(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$3o($$self, $$props, $$invalidate) {
  let { controls } = $$props;
  let { params } = $$props;
  $$self.$$set = ($$props2) => {
    if ("controls" in $$props2) $$invalidate(0, controls = $$props2.controls);
    if ("params" in $$props2) $$invalidate(1, params = $$props2.params);
  };
  return [controls, params];
}
class ClassicControls extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3o, create_fragment$3p, safe_not_equal, { controls: 0, params: 1 });
  }
}
function create_else_block$V(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = "fa-solid fa-box fa-fw " + /*iconClass*/
      ctx[2]);
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconClass*/
      4 && i_class_value !== (i_class_value = "fa-solid fa-box fa-fw " + /*iconClass*/
      ctx2[2])) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block$1A(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = "fa-solid fa-box-open fa-fw " + /*iconClass*/
      ctx[2]);
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconClass*/
      4 && i_class_value !== (i_class_value = "fa-solid fa-box-open fa-fw " + /*iconClass*/
      ctx2[2])) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_fragment$3o(ctx) {
  let button;
  let show_if;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (dirty & /*$inlineContainerToggleServiceStore, item*/
    34) show_if = null;
    if (show_if == null) show_if = !!/*$inlineContainerToggleServiceStore*/
    ctx2[5].get(
      /*tabId*/
      ctx2[6]
    )?.has(
      /*item*/
      ctx2[1].id
    );
    if (show_if) return create_if_block$1A;
    return create_else_block$V;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "type", "button");
      attr(button, "class", "inline-container-toggle inline-transparent-button");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.INLINE_CONTAINER_TOGGLE);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty & /*$settingStore*/
      16 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[4].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$3n($$self, $$props, $$invalidate) {
  let inlineContainerToggleServiceStore;
  let $settingStore;
  let $inlineContainerToggleServiceStore, $$unsubscribe_inlineContainerToggleServiceStore = noop$1, $$subscribe_inlineContainerToggleServiceStore = () => ($$unsubscribe_inlineContainerToggleServiceStore(), $$unsubscribe_inlineContainerToggleServiceStore = subscribe(inlineContainerToggleServiceStore, ($$value) => $$invalidate(5, $inlineContainerToggleServiceStore = $$value)), inlineContainerToggleServiceStore);
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(4, $settingStore = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_inlineContainerToggleServiceStore());
  let { inlineContainerToggleService } = $$props;
  let { item } = $$props;
  let { iconClass = "" } = $$props;
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  const click_handler = () => inlineContainerToggleService.toggle(tabId, item.id);
  $$self.$$set = ($$props2) => {
    if ("inlineContainerToggleService" in $$props2) $$invalidate(0, inlineContainerToggleService = $$props2.inlineContainerToggleService);
    if ("item" in $$props2) $$invalidate(1, item = $$props2.item);
    if ("iconClass" in $$props2) $$invalidate(2, iconClass = $$props2.iconClass);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*inlineContainerToggleService*/
    1) {
      $$subscribe_inlineContainerToggleServiceStore($$invalidate(3, inlineContainerToggleServiceStore = inlineContainerToggleService.store));
    }
  };
  return [
    inlineContainerToggleService,
    item,
    iconClass,
    inlineContainerToggleServiceStore,
    $settingStore,
    $inlineContainerToggleServiceStore,
    tabId,
    click_handler
  ];
}
class InlineContainerToggle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3n, create_fragment$3o, safe_not_equal, {
      inlineContainerToggleService: 0,
      item: 1,
      iconClass: 2
    });
  }
}
class InlineContainerToggleService {
  /** Container IDs which represent all containers that are currently expanded. */
  store = writable(
    /* @__PURE__ */ new Map()
  );
  /** Toggle a container to be expanded or collapsed, based on its current state. */
  toggle(tabId, containerId) {
    this.store.update((tabs) => {
      if (!tabs.has(tabId)) {
        tabs.set(tabId, /* @__PURE__ */ new Set());
      }
      const tab = tabs.get(tabId);
      if (tab.has(containerId)) {
        tab.delete(containerId);
      } else {
        tab.add(containerId);
      }
      return tabs;
    });
  }
}
function create_if_block$1z(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(
        /*capacityLabel*/
        ctx[3]
      );
      attr(span, "class", "capacity-label svelte-1owr90p");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*capacityLabel*/
      8) set_data(
        t2,
        /*capacityLabel*/
        ctx2[3]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$3n(ctx) {
  let div;
  let div_aria_valuenow_value;
  let div_aria_valuemax_value;
  let if_block = (
    /*showLabel*/
    ctx[1] && create_if_block$1z(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      attr(div, "class", "tidy-capacity svelte-1owr90p");
      attr(div, "role", "meter");
      attr(
        div,
        "aria-label",
        /*localize*/
        ctx[4]("DND5E.ItemContainerCapacity")
      );
      attr(
        div,
        "title",
        /*capacityLabel*/
        ctx[3]
      );
      attr(
        div,
        "aria-valuetext",
        /*capacityLabel*/
        ctx[3]
      );
      attr(div, "aria-valuemin", "0");
      attr(div, "aria-valuenow", div_aria_valuenow_value = /*capacity*/
      ctx[0].value);
      attr(div, "aria-valuemax", div_aria_valuemax_value = /*capacity*/
      ctx[0].max);
      set_style(
        div,
        "--percentage",
        /*percentage*/
        ctx[2] + "%"
      );
      toggle_class(
        div,
        "empty",
        /*percentage*/
        ctx[2] === 0
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*showLabel*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1z(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*capacityLabel*/
      8) {
        attr(
          div,
          "title",
          /*capacityLabel*/
          ctx2[3]
        );
      }
      if (dirty & /*capacityLabel*/
      8) {
        attr(
          div,
          "aria-valuetext",
          /*capacityLabel*/
          ctx2[3]
        );
      }
      if (dirty & /*capacity*/
      1 && div_aria_valuenow_value !== (div_aria_valuenow_value = /*capacity*/
      ctx2[0].value)) {
        attr(div, "aria-valuenow", div_aria_valuenow_value);
      }
      if (dirty & /*capacity*/
      1 && div_aria_valuemax_value !== (div_aria_valuemax_value = /*capacity*/
      ctx2[0].max)) {
        attr(div, "aria-valuemax", div_aria_valuemax_value);
      }
      if (dirty & /*percentage*/
      4) {
        set_style(
          div,
          "--percentage",
          /*percentage*/
          ctx2[2] + "%"
        );
      }
      if (dirty & /*percentage*/
      4) {
        toggle_class(
          div,
          "empty",
          /*percentage*/
          ctx2[2] === 0
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
    }
  };
}
function instance$3m($$self, $$props, $$invalidate) {
  let readableValue;
  let capacityLabel;
  let percentage;
  let { container } = $$props;
  let { capacity } = $$props;
  let { showLabel = true } = $$props;
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("container" in $$props2) $$invalidate(5, container = $$props2.container);
    if ("capacity" in $$props2) $$invalidate(0, capacity = $$props2.capacity);
    if ("showLabel" in $$props2) $$invalidate(1, showLabel = $$props2.showLabel);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*container, capacity*/
    33) {
      $$invalidate(6, readableValue = container.system.capacity.type === CONSTANTS.ITEM_CAPACITY_TYPE_WEIGHT ? (capacity.value ?? 0).toFixed(2) : Math.ceil(capacity.value ?? 0));
    }
    if ($$self.$$.dirty & /*readableValue, capacity*/
    65) {
      $$invalidate(3, capacityLabel = `${readableValue}/${capacity.max} ${capacity.units}`);
    }
    if ($$self.$$.dirty & /*capacity*/
    1) {
      $$invalidate(2, percentage = Math.round(capacity.pct));
    }
  };
  return [
    capacity,
    showLabel,
    percentage,
    capacityLabel,
    localize,
    container,
    readableValue
  ];
}
class CapacityBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3m, create_fragment$3n, safe_not_equal, { container: 5, capacity: 0, showLabel: 1 });
  }
}
const get_body_slot_changes = (dirty) => ({});
const get_body_slot_context = (ctx) => ({});
const get_header_slot_changes$1 = (dirty) => ({});
const get_header_slot_context$1 = (ctx) => ({});
function create_default_slot$1q(ctx) {
  let div;
  let current;
  const body_slot_template = (
    /*#slots*/
    ctx[8].body
  );
  const body_slot = create_slot(
    body_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_body_slot_context
  );
  return {
    c() {
      div = element("div");
      if (body_slot) body_slot.c();
      attr(div, "class", "item-table-body");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (body_slot) {
        body_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (body_slot) {
        if (body_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            body_slot,
            body_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              body_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_body_slot_changes
            ),
            get_body_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(body_slot, local);
      current = true;
    },
    o(local) {
      transition_out(body_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (body_slot) body_slot.d(detaching);
    }
  };
}
function create_fragment$3m(ctx) {
  let section;
  let t2;
  let expandablecontainer;
  let section_class_value;
  let section_data_tidy_sheet_part_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[8].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_header_slot_context$1
  );
  expandablecontainer = new ExpandableContainer({
    props: {
      expanded: (
        /*$expandedState*/
        ctx[2].expanded
      ),
      $$slots: { default: [create_default_slot$1q] },
      $$scope: { ctx }
    }
  });
  let section_levels = [
    {
      class: section_class_value = "tidy-table " + /*cssClass*/
      (ctx[3] ?? "")
    },
    {
      "data-tidy-sheet-part": section_data_tidy_sheet_part_value = CONSTANTS.SHEET_PARTS.ITEM_TABLE
    },
    { "data-tidy-section-key": (
      /*key*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[4]
  ];
  let section_data = {};
  for (let i2 = 0; i2 < section_levels.length; i2 += 1) {
    section_data = assign(section_data, section_levels[i2]);
  }
  return {
    c() {
      section = element("section");
      if (header_slot) header_slot.c();
      t2 = space();
      create_component(expandablecontainer.$$.fragment);
      set_attributes(section, section_data);
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (header_slot) {
        header_slot.m(section, null);
      }
      append(section, t2);
      mount_component(expandablecontainer, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_header_slot_changes$1
            ),
            get_header_slot_context$1
          );
        }
      }
      const expandablecontainer_changes = {};
      if (dirty & /*$expandedState*/
      4) expandablecontainer_changes.expanded = /*$expandedState*/
      ctx2[2].expanded;
      if (dirty & /*$$scope*/
      512) {
        expandablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandablecontainer.$set(expandablecontainer_changes);
      set_attributes(section, section_data = get_spread_update(section_levels, [
        { class: section_class_value },
        {
          "data-tidy-sheet-part": section_data_tidy_sheet_part_value
        },
        (!current || dirty & /*key*/
        1) && { "data-tidy-section-key": (
          /*key*/
          ctx2[0]
        ) },
        /*attributes*/
        ctx2[4]
      ]));
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      transition_in(expandablecontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(expandablecontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (header_slot) header_slot.d(detaching);
      destroy_component(expandablecontainer);
    }
  };
}
function instance$3l($$self, $$props, $$invalidate) {
  let expandedState;
  const omit_props_names = ["key", "toggleable"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $messageBus;
  let $expandedState, $$unsubscribe_expandedState = noop$1, $$subscribe_expandedState = () => ($$unsubscribe_expandedState(), $$unsubscribe_expandedState = subscribe(expandedState, ($$value) => $$invalidate(2, $expandedState = $$value)), expandedState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_expandedState());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { key } = $$props;
  let { toggleable = true } = $$props;
  let { class: cssClass, ...attributes } = $$restProps;
  const messageBus = getContext(CONSTANTS.SVELTE_CONTEXT.MESSAGE_BUS);
  component_subscribe($$self, messageBus, (value) => $$invalidate(7, $messageBus = value));
  const tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  declareLocation("item-table", key);
  const expandCollapseService = ExpandCollapseService.initService(toggleable);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("key" in $$new_props) $$invalidate(0, key = $$new_props.key);
    if ("toggleable" in $$new_props) $$invalidate(6, toggleable = $$new_props.toggleable);
    if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$messageBus*/
    128) {
      {
        if ($messageBus?.tabId === tabId && $messageBus?.message === CONSTANTS.MESSAGE_BUS_EXPAND_ALL) {
          expandCollapseService.set(true);
        }
        if ($messageBus?.tabId === tabId && $messageBus?.message === CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL) {
          expandCollapseService.set(false);
        }
      }
    }
  };
  $$subscribe_expandedState($$invalidate(1, expandedState = expandCollapseService.state));
  return [
    key,
    expandedState,
    $expandedState,
    cssClass,
    attributes,
    messageBus,
    toggleable,
    $messageBus,
    slots,
    $$scope
  ];
}
class TidyTable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3l, create_fragment$3m, safe_not_equal, { key: 0, toggleable: 6 });
  }
}
function create_fragment$3l(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "expand-indicator fas fa-angle-right");
      attr(i2, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.EXPANSION_TOGGLE);
      toggle_class(
        i2,
        "expanded",
        /*expanded*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*expanded*/
      1) {
        toggle_class(
          i2,
          "expanded",
          /*expanded*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function instance$3k($$self, $$props, $$invalidate) {
  let { expanded = true } = $$props;
  $$self.$$set = ($$props2) => {
    if ("expanded" in $$props2) $$invalidate(0, expanded = $$props2.expanded);
  };
  return [expanded];
}
class TidyTableToggleIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3k, create_fragment$3l, safe_not_equal, { expanded: 0 });
  }
}
function create_if_block$1y(ctx) {
  let tidytabletoggleicon;
  let current;
  tidytabletoggleicon = new TidyTableToggleIcon({
    props: {
      expanded: (
        /*$expandState*/
        ctx[4].expanded
      )
    }
  });
  return {
    c() {
      create_component(tidytabletoggleicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytabletoggleicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytabletoggleicon_changes = {};
      if (dirty & /*$expandState*/
      16) tidytabletoggleicon_changes.expanded = /*$expandState*/
      ctx2[4].expanded;
      tidytabletoggleicon.$set(tidytabletoggleicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytabletoggleicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytabletoggleicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytabletoggleicon, detaching);
    }
  };
}
function create_fragment$3k(ctx) {
  let div;
  let t2;
  let div_class_value;
  let current;
  let if_block = (
    /*primary*/
    ctx[0] && /*$expandState*/
    ctx[4].toggleable && create_if_block$1y(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (default_slot) default_slot.c();
      attr(div, "class", div_class_value = "tidy-table-header-cell " + /*$$restProps*/
      (ctx[5].class ?? ""));
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.TABLE_HEADER_CELL);
      attr(
        div,
        "title",
        /*title*/
        ctx[2]
      );
      toggle_class(
        div,
        "primary",
        /*primary*/
        ctx[0]
      );
      set_style(
        div,
        "flex-basis",
        /*baseWidth*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*primary*/
        ctx2[0] && /*$expandState*/
        ctx2[4].toggleable
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*primary, $expandState*/
          17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$$restProps*/
      32 && div_class_value !== (div_class_value = "tidy-table-header-cell " + /*$$restProps*/
      (ctx2[5].class ?? ""))) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*title*/
      4) {
        attr(
          div,
          "title",
          /*title*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$$restProps, primary*/
      33) {
        toggle_class(
          div,
          "primary",
          /*primary*/
          ctx2[0]
        );
      }
      if (dirty & /*baseWidth*/
      2) {
        set_style(
          div,
          "flex-basis",
          /*baseWidth*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$3j($$self, $$props, $$invalidate) {
  let expandState;
  const omit_props_names = ["primary", "baseWidth", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $expandState, $$unsubscribe_expandState = noop$1, $$subscribe_expandState = () => ($$unsubscribe_expandState(), $$unsubscribe_expandState = subscribe(expandState, ($$value) => $$invalidate(4, $expandState = $$value)), expandState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_expandState());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { primary = false } = $$props;
  let { baseWidth = null } = $$props;
  let { title = null } = $$props;
  const expandCollapseService = ExpandCollapseService.getService();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("primary" in $$new_props) $$invalidate(0, primary = $$new_props.primary);
    if ("baseWidth" in $$new_props) $$invalidate(1, baseWidth = $$new_props.baseWidth);
    if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$subscribe_expandState($$invalidate(3, expandState = expandCollapseService.state));
  return [
    primary,
    baseWidth,
    title,
    expandState,
    $expandState,
    $$restProps,
    $$scope,
    slots
  ];
}
class TidyTableHeaderCell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3j, create_fragment$3k, safe_not_equal, { primary: 0, baseWidth: 1, title: 2 });
  }
}
function create_fragment$3j(ctx) {
  let header;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      header = element("header");
      if (default_slot) default_slot.c();
      attr(header, "class", "tidy-table-header-row");
      attr(header, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.TABLE_HEADER_ROW);
      toggle_class(
        header,
        "toggleable",
        /*$expandState*/
        ctx[1].toggleable
      );
    },
    m(target, anchor) {
      insert(target, header, anchor);
      if (default_slot) {
        default_slot.m(header, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          header,
          "click",
          /*handleHeaderRowClick*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$expandState*/
      2) {
        toggle_class(
          header,
          "toggleable",
          /*$expandState*/
          ctx2[1].toggleable
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$3i($$self, $$props, $$invalidate) {
  let expandState;
  let $expandState, $$unsubscribe_expandState = noop$1, $$subscribe_expandState = () => ($$unsubscribe_expandState(), $$unsubscribe_expandState = subscribe(expandState, ($$value) => $$invalidate(1, $expandState = $$value)), expandState);
  $$self.$$.on_destroy.push(() => $$unsubscribe_expandState());
  let { $$slots: slots = {}, $$scope } = $$props;
  const expandCollapseService = ExpandCollapseService.getService();
  function handleHeaderRowClick(ev) {
    if (!$expandState.toggleable) {
      return;
    }
    if (ev.target instanceof HTMLElement && isUserInteractable(ev.target) && ev.target.getAttribute(CONSTANTS.SHEET_PART_ATTRIBUTE) !== CONSTANTS.SHEET_PARTS.EXPANSION_TOGGLE) {
      return;
    }
    ev.stopPropagation();
    expandCollapseService.toggle();
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$subscribe_expandState($$invalidate(0, expandState = expandCollapseService.state));
  return [expandState, $expandState, handleHeaderRowClick, $$scope, slots];
}
class TidyTableHeaderRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3i, create_fragment$3j, safe_not_equal, {});
  }
}
const get_after_row_slot_changes = (dirty) => ({});
const get_after_row_slot_context = (ctx) => ({});
function create_fragment$3i(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_data_tidy_sheet_part_value;
  let t2;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div0_levels = [
    {
      class: div0_class_value = "tidy-table-row " + /*rowClass*/
      (ctx[2] ?? "")
    },
    { "data-tidy-table-row": "" },
    {
      "data-tidy-sheet-part": div0_data_tidy_sheet_part_value = CONSTANTS.SHEET_PARTS.TABLE_ROW
    },
    /*rowAttributes*/
    ctx[4]
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div0_levels.length; i2 += 1) {
    div_data = assign(div_data, div0_levels[i2]);
  }
  const after_row_slot_template = (
    /*#slots*/
    ctx[6]["after-row"]
  );
  const after_row_slot = create_slot(
    after_row_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_after_row_slot_context
  );
  let div1_levels = [
    {
      class: div1_class_value = "tidy-table-row-container " + /*rowContainerClass*/
      (ctx[1] ?? "")
    },
    { "aria-hidden": (
      /*hidden*/
      ctx[0]
    ) },
    /*rowContainerAttributes*/
    ctx[3]
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      t2 = space();
      if (after_row_slot) after_row_slot.c();
      set_attributes(div0, div_data);
      set_attributes(div1, div_data_1);
      toggle_class(
        div1,
        "hidden",
        /*hidden*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append(div1, t2);
      if (after_row_slot) {
        after_row_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div0,
            "mousedown",
            /*mousedown_handler*/
            ctx[7]
          ),
          listen(
            div0,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[8]
          ),
          listen(
            div0,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[9]
          ),
          listen(
            div0,
            "dragstart",
            /*dragstart_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div0, div_data = get_spread_update(div0_levels, [
        (!current || dirty & /*rowClass*/
        4 && div0_class_value !== (div0_class_value = "tidy-table-row " + /*rowClass*/
        (ctx2[2] ?? ""))) && { class: div0_class_value },
        { "data-tidy-table-row": "" },
        {
          "data-tidy-sheet-part": div0_data_tidy_sheet_part_value
        },
        dirty & /*rowAttributes*/
        16 && /*rowAttributes*/
        ctx2[4]
      ]));
      if (after_row_slot) {
        if (after_row_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            after_row_slot,
            after_row_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              after_row_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_after_row_slot_changes
            ),
            get_after_row_slot_context
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty & /*rowContainerClass*/
        2 && div1_class_value !== (div1_class_value = "tidy-table-row-container " + /*rowContainerClass*/
        (ctx2[1] ?? ""))) && { class: div1_class_value },
        (!current || dirty & /*hidden*/
        1) && { "aria-hidden": (
          /*hidden*/
          ctx2[0]
        ) },
        dirty & /*rowContainerAttributes*/
        8 && /*rowContainerAttributes*/
        ctx2[3]
      ]));
      toggle_class(
        div1,
        "hidden",
        /*hidden*/
        ctx2[0]
      );
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(after_row_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(after_row_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot) default_slot.d(detaching);
      if (after_row_slot) after_row_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3h($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { hidden = false } = $$props;
  let { rowContainerClass = "" } = $$props;
  let { rowClass = "" } = $$props;
  let { rowContainerAttributes = {} } = $$props;
  let { rowAttributes = {} } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("hidden" in $$props2) $$invalidate(0, hidden = $$props2.hidden);
    if ("rowContainerClass" in $$props2) $$invalidate(1, rowContainerClass = $$props2.rowContainerClass);
    if ("rowClass" in $$props2) $$invalidate(2, rowClass = $$props2.rowClass);
    if ("rowContainerAttributes" in $$props2) $$invalidate(3, rowContainerAttributes = $$props2.rowContainerAttributes);
    if ("rowAttributes" in $$props2) $$invalidate(4, rowAttributes = $$props2.rowAttributes);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [
    hidden,
    rowContainerClass,
    rowClass,
    rowContainerAttributes,
    rowAttributes,
    $$scope,
    slots,
    mousedown_handler,
    mouseenter_handler,
    mouseleave_handler,
    dragstart_handler
  ];
}
class TidyTableRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3h, create_fragment$3i, safe_not_equal, {
      hidden: 0,
      rowContainerClass: 1,
      rowClass: 2,
      rowContainerAttributes: 3,
      rowAttributes: 4
    });
  }
}
const get_default_slot_changes$3 = (dirty) => ({});
const get_default_slot_context$3 = (ctx) => ({ toggleSummary: (
  /*toggleSummary*/
  ctx[9]
) });
function create_default_slot_1$O(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context$3
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes$3
            ),
            get_default_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_default_slot$1p(ctx) {
  let itemsummary;
  let current;
  itemsummary = new ItemSummary({
    props: {
      chatData: (
        /*chatData*/
        ctx[5] ?? /*emptyChatData*/
        ctx[8]
      ),
      useTransition: (
        /*useTransition*/
        ctx[6]
      ),
      item: (
        /*item*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(itemsummary.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemsummary, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemsummary_changes = {};
      if (dirty & /*chatData*/
      32) itemsummary_changes.chatData = /*chatData*/
      ctx2[5] ?? /*emptyChatData*/
      ctx2[8];
      if (dirty & /*useTransition*/
      64) itemsummary_changes.useTransition = /*useTransition*/
      ctx2[6];
      if (dirty & /*item*/
      1) itemsummary_changes.item = /*item*/
      ctx2[0];
      itemsummary.$set(itemsummary_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemsummary.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemsummary.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemsummary, detaching);
    }
  };
}
function create_after_row_slot(ctx) {
  let expandablecontainer;
  let current;
  expandablecontainer = new ExpandableContainer({
    props: {
      expanded: (
        /*showSummary*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot$1p] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expandablecontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expandablecontainer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const expandablecontainer_changes = {};
      if (dirty & /*showSummary*/
      16) expandablecontainer_changes.expanded = /*showSummary*/
      ctx2[4];
      if (dirty & /*$$scope, chatData, useTransition, item*/
      65633) {
        expandablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandablecontainer.$set(expandablecontainer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(expandablecontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expandablecontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expandablecontainer, detaching);
    }
  };
}
function create_fragment$3h(ctx) {
  let div;
  let tidytablerow;
  let current;
  tidytablerow = new TidyTableRow({
    props: {
      hidden: (
        /*hidden*/
        ctx[3]
      ),
      rowContainerAttributes: {
        ["data-context-menu"]: (
          /*contextMenu*/
          ctx[1]?.type
        ),
        ["data-context-menu-document-uuid"]: (
          /*contextMenu*/
          ctx[1]?.uuid
        ),
        ["data-item-id"]: (
          /*item*/
          ctx[0]?.id
        ),
        ["data-tidy-table-row"]: "",
        ["data-tidy-sheet-part"]: CONSTANTS.SHEET_PARTS.ITEM_TABLE_ROW,
        ["data-tidy-item-type"]: (
          /*item*/
          ctx[0]?.type ?? "unknown"
        )
      },
      rowAttributes: { draggable: !!/*draggable*/
      ctx[7] },
      rowClass: (
        /*rowClass*/
        ctx[2]
      ),
      $$slots: {
        "after-row": [create_after_row_slot],
        default: [create_default_slot_1$O]
      },
      $$scope: { ctx }
    }
  });
  tidytablerow.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[15]
  );
  tidytablerow.$on(
    "mouseenter",
    /*onMouseEnter*/
    ctx[10]
  );
  tidytablerow.$on(
    "mouseleave",
    /*onMouseLeave*/
    ctx[11]
  );
  tidytablerow.$on(
    "dragstart",
    /*handleDragStart*/
    ctx[12]
  );
  return {
    c() {
      div = element("div");
      create_component(tidytablerow.$$.fragment);
      set_style(div, "display", "contents");
      attr(div, "class", "item-table-row svelte-11clow7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tidytablerow, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tidytablerow_changes = {};
      if (dirty & /*hidden*/
      8) tidytablerow_changes.hidden = /*hidden*/
      ctx2[3];
      if (dirty & /*contextMenu, item*/
      3) tidytablerow_changes.rowContainerAttributes = {
        ["data-context-menu"]: (
          /*contextMenu*/
          ctx2[1]?.type
        ),
        ["data-context-menu-document-uuid"]: (
          /*contextMenu*/
          ctx2[1]?.uuid
        ),
        ["data-item-id"]: (
          /*item*/
          ctx2[0]?.id
        ),
        ["data-tidy-table-row"]: "",
        ["data-tidy-sheet-part"]: CONSTANTS.SHEET_PARTS.ITEM_TABLE_ROW,
        ["data-tidy-item-type"]: (
          /*item*/
          ctx2[0]?.type ?? "unknown"
        )
      };
      if (dirty & /*draggable*/
      128) tidytablerow_changes.rowAttributes = { draggable: !!/*draggable*/
      ctx2[7] };
      if (dirty & /*rowClass*/
      4) tidytablerow_changes.rowClass = /*rowClass*/
      ctx2[2];
      if (dirty & /*$$scope, showSummary, chatData, useTransition, item*/
      65649) {
        tidytablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablerow.$set(tidytablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tidytablerow);
    }
  };
}
function instance$3g($$self, $$props, $$invalidate) {
  let draggable;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(17, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { item = null } = $$props;
  let { contextMenu = null } = $$props;
  let { rowClass = "" } = $$props;
  let { itemCardContentTemplate = null } = $$props;
  let { hidden = false } = $$props;
  const emptyChatData = {
    description: { value: "" },
    properties: [],
    unidentified: { description: "" }
  };
  const expandedItemData = getContext(CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEM_DATA);
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  const expandedItems = getContext(CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEMS);
  const onItemToggled = getContext(CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TOGGLED);
  const location = getContext(CONSTANTS.SVELTE_CONTEXT.LOCATION);
  let card = getContext(CONSTANTS.SVELTE_CONTEXT.CARD);
  let showSummary = false;
  let chatData;
  let useTransition = false;
  async function toggleSummary() {
    if (!item) {
      warn("Unable to show summary. No item was provided.");
      $$invalidate(4, showSummary = false);
      return;
    }
    $$invalidate(5, chatData ??= await item.getChatData({ secrets: item.isOwner }));
    $$invalidate(4, showSummary = !showSummary);
    onItemToggled?.(item.id, showSummary, location);
  }
  async function onMouseEnter(event) {
    TidyHooks.tidy5eSheetsItemHoverOn(event, item);
    if (!item?.getChatData || !$settingStore.itemCardsForAllItems) {
      return;
    }
    card?.update((card2) => {
      card2.item = item;
      card2.itemCardContentTemplate = itemCardContentTemplate;
      return card2;
    });
  }
  async function onMouseLeave(event) {
    TidyHooks.tidy5eSheetsItemHoverOff(event, item);
    card?.update((card2) => {
      card2.item = null;
      card2.itemCardContentTemplate = null;
      return card2;
    });
  }
  function handleDragStart2(event) {
    if (!draggable) {
      return;
    }
    onMouseLeave(event);
    card?.update((card2) => {
      return card2;
    });
    const dragData = draggable.toDragData();
    event.dataTransfer?.setData("text/plain", JSON.stringify(dragData));
  }
  function restoreItemSummaryIfExpanded() {
    if (!item) {
      $$invalidate(6, useTransition = true);
      return;
    }
    $$invalidate(6, useTransition = false);
    const isExpandedAtThisLocation = expandedItems?.get(item.id)?.has(location);
    if (isExpandedAtThisLocation) {
      $$invalidate(5, chatData = expandedItemData.get(item.id));
      $$invalidate(4, showSummary = true);
    }
    setTimeout(() => {
      $$invalidate(6, useTransition = true);
    });
  }
  onMount(() => {
    let first = true;
    const subscription = context?.subscribe(async (c2) => {
      if (first) {
        first = false;
        restoreItemSummaryIfExpanded();
        return;
      }
      if (item && showSummary) {
        item.getChatData({ secrets: item.actor.isOwner }).then((data) => {
          $$invalidate(5, chatData = data);
        });
      } else if (item && !showSummary && chatData) {
        $$invalidate(5, chatData = void 0);
      }
    });
    return subscription;
  });
  const mousedown_handler = (event) => item && FoundryAdapter.editOnMiddleClick(event, item);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("contextMenu" in $$props2) $$invalidate(1, contextMenu = $$props2.contextMenu);
    if ("rowClass" in $$props2) $$invalidate(2, rowClass = $$props2.rowClass);
    if ("itemCardContentTemplate" in $$props2) $$invalidate(13, itemCardContentTemplate = $$props2.itemCardContentTemplate);
    if ("hidden" in $$props2) $$invalidate(3, hidden = $$props2.hidden);
    if ("$$scope" in $$props2) $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(7, draggable = item);
    }
  };
  return [
    item,
    contextMenu,
    rowClass,
    hidden,
    showSummary,
    chatData,
    useTransition,
    draggable,
    emptyChatData,
    toggleSummary,
    onMouseEnter,
    onMouseLeave,
    handleDragStart2,
    itemCardContentTemplate,
    slots,
    mousedown_handler,
    $$scope
  ];
}
class ItemTableRowV2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3g, create_fragment$3h, safe_not_equal, {
      item: 0,
      contextMenu: 1,
      rowClass: 2,
      itemCardContentTemplate: 13,
      hidden: 3
    });
  }
}
const get_default_slot_changes$2 = (dirty) => ({});
const get_default_slot_context$2 = (ctx) => ({ isHovering: (
  /*isHovering*/
  ctx[2]
) });
function create_fragment$3g(ctx) {
  let div;
  let div_class_value;
  let div_data_tidy_sheet_part_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context$2
  );
  let div_levels = [
    {
      class: div_class_value = "tidy-table-cell " + /*$$restProps*/
      (ctx[5].class ?? "")
    },
    { title: (
      /*title*/
      ctx[1]
    ) },
    {
      "data-tidy-sheet-part": div_data_tidy_sheet_part_value = CONSTANTS.SHEET_PARTS.TABLE_CELL
    },
    /*$$restProps*/
    ctx[5].attributes
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign(div_data, div_levels[i2]);
  }
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      set_attributes(div, div_data);
      toggle_class(
        div,
        "primary",
        /*primary*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mouseenter",
            /*mouseEnter*/
            ctx[3]
          ),
          listen(
            div,
            "mouseleave",
            /*mouseLeave*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes$2
            ),
            get_default_slot_context$2
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*$$restProps*/
        32 && div_class_value !== (div_class_value = "tidy-table-cell " + /*$$restProps*/
        (ctx2[5].class ?? ""))) && { class: div_class_value },
        (!current || dirty & /*title*/
        2) && { title: (
          /*title*/
          ctx2[1]
        ) },
        {
          "data-tidy-sheet-part": div_data_tidy_sheet_part_value
        },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5].attributes
      ]));
      toggle_class(
        div,
        "primary",
        /*primary*/
        ctx2[0]
      );
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3f($$self, $$props, $$invalidate) {
  const omit_props_names = ["primary", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { primary = false } = $$props;
  let { title = void 0 } = $$props;
  const isHovering = writable(false);
  function mouseEnter(ev) {
    isHovering.set(true);
  }
  function mouseLeave(ev) {
    isHovering.set(false);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("primary" in $$new_props) $$invalidate(0, primary = $$new_props.primary);
    if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  return [
    primary,
    title,
    isHovering,
    mouseEnter,
    mouseLeave,
    $$restProps,
    $$scope,
    slots
  ];
}
class TidyTableCell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3f, create_fragment$3g, safe_not_equal, { primary: 0, title: 1 });
  }
}
function get_each_context$W(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function get_each_context_1$o(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  const constants_0 = (
    /*itemContext*/
    child_ctx[1][
      /*item*/
      child_ctx[21].id
    ]
  );
  child_ctx[22] = constants_0;
  const constants_1 = (
    /*ctx*/
    child_ctx[22]?.totalWeight ?? /*item*/
    child_ctx[21].system.weight.value
  );
  child_ctx[23] = constants_1;
  return child_ctx;
}
function get_each_context_2$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  return child_ctx;
}
function get_if_ctx$e(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = FoundryAdapter.getAttunementContext(
    /*item*/
    child_ctx[21]
  );
  child_ctx[30] = constants_0;
  return child_ctx;
}
function create_if_block$1x(ctx) {
  let section_1;
  let tidytable;
  let t2;
  let current;
  tidytable = new TidyTable({
    props: {
      key: (
        /*section*/
        ctx[18].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[18].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$k],
        header: [create_header_slot$l]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section_1 = element("section");
      create_component(tidytable.$$.fragment);
      t2 = space();
      attr(section_1, "class", "container-contents-list-section");
      set_style(
        section_1,
        "--grid-template-columns",
        /*gridTemplateColumns*/
        ctx[6]
      );
    },
    m(target, anchor) {
      insert(target, section_1, anchor);
      mount_component(tidytable, section_1, null);
      append(section_1, t2);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytable_changes = {};
      if (dirty[0] & /*configuredContents*/
      128) tidytable_changes.key = /*section*/
      ctx2[18].key;
      if (dirty[0] & /*configuredContents*/
      128) tidytable_changes["data-custom-section"] = /*section*/
      ctx2[18].custom ? true : null;
      if (dirty[0] & /*configuredContents, itemContext, editable, inlineContainerToggleService, lockItemQuantity, sheetDocument, $itemIdsToShow, useClassicControls*/
      447 | dirty[1] & /*$$scope*/
      1) {
        tidytable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytable.$set(tidytable_changes);
      if (!current || dirty[0] & /*gridTemplateColumns*/
      64) {
        set_style(
          section_1,
          "--grid-template-columns",
          /*gridTemplateColumns*/
          ctx2[6]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(tidytable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section_1);
      }
      destroy_component(tidytable);
    }
  };
}
function create_default_slot_9$h(ctx) {
  let t0_value = (
    /*localize*/
    ctx[12](
      /*section*/
      ctx[18].label
    ) + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*section*/
    ctx[18].items.length + ""
  );
  let t2;
  let t3;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" (");
      t2 = text(t2_value);
      t3 = text(")");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*configuredContents*/
      128 && t0_value !== (t0_value = /*localize*/
      ctx2[12](
        /*section*/
        ctx2[18].label
      ) + "")) set_data(t0, t0_value);
      if (dirty[0] & /*configuredContents*/
      128 && t2_value !== (t2_value = /*section*/
      ctx2[18].items.length + "")) set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
    }
  };
}
function create_default_slot_8$j(ctx) {
  let t_value = (
    /*localize*/
    ctx[12]("DND5E.Weight") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7$m(ctx) {
  let t_value = (
    /*localize*/
    ctx[12]("DND5E.QuantityAbbr") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_7$f(ctx) {
  let tidytableheadercell;
  let current;
  tidytableheadercell = new TidyTableHeaderCell({});
  return {
    c() {
      create_component(tidytableheadercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheadercell, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheadercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheadercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytableheadercell, detaching);
    }
  };
}
function create_default_slot_6$n(ctx) {
  let tidytableheadercell0;
  let t0;
  let tidytableheadercell1;
  let t1;
  let tidytableheadercell2;
  let t2;
  let if_block_anchor;
  let current;
  tidytableheadercell0 = new TidyTableHeaderCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_9$h] },
      $$scope: { ctx }
    }
  });
  tidytableheadercell1 = new TidyTableHeaderCell({
    props: {
      $$slots: { default: [create_default_slot_8$j] },
      $$scope: { ctx }
    }
  });
  tidytableheadercell2 = new TidyTableHeaderCell({
    props: {
      $$slots: { default: [create_default_slot_7$m] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*editable*/
    ctx[0] && /*useClassicControls*/
    ctx[5] && create_if_block_7$f()
  );
  return {
    c() {
      create_component(tidytableheadercell0.$$.fragment);
      t0 = space();
      create_component(tidytableheadercell1.$$.fragment);
      t1 = space();
      create_component(tidytableheadercell2.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(tidytableheadercell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(tidytableheadercell1, target, anchor);
      insert(target, t1, anchor);
      mount_component(tidytableheadercell2, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheadercell0_changes = {};
      if (dirty[0] & /*configuredContents*/
      128 | dirty[1] & /*$$scope*/
      1) {
        tidytableheadercell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell0.$set(tidytableheadercell0_changes);
      const tidytableheadercell1_changes = {};
      if (dirty[1] & /*$$scope*/
      1) {
        tidytableheadercell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell1.$set(tidytableheadercell1_changes);
      const tidytableheadercell2_changes = {};
      if (dirty[1] & /*$$scope*/
      1) {
        tidytableheadercell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell2.$set(tidytableheadercell2_changes);
      if (
        /*editable*/
        ctx2[0] && /*useClassicControls*/
        ctx2[5]
      ) {
        if (if_block) {
          if (dirty[0] & /*editable, useClassicControls*/
          33) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7$f();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheadercell0.$$.fragment, local);
      transition_in(tidytableheadercell1.$$.fragment, local);
      transition_in(tidytableheadercell2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(tidytableheadercell0.$$.fragment, local);
      transition_out(tidytableheadercell1.$$.fragment, local);
      transition_out(tidytableheadercell2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(tidytableheadercell0, detaching);
      destroy_component(tidytableheadercell1, detaching);
      destroy_component(tidytableheadercell2, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_header_slot$l(ctx) {
  let tidytableheaderrow;
  let current;
  tidytableheaderrow = new TidyTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_6$n] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheaderrow_changes = {};
      if (dirty[0] & /*editable, useClassicControls, configuredContents*/
      161 | dirty[1] & /*$$scope*/
      1) {
        tidytableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheaderrow.$set(tidytableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytableheaderrow, detaching);
    }
  };
}
function create_if_block_6$h(ctx) {
  let inlinecontainertoggle;
  let current;
  inlinecontainertoggle = new InlineContainerToggle({
    props: {
      item: (
        /*item*/
        ctx[21]
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainertoggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainertoggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainertoggle_changes = {};
      if (dirty[0] & /*configuredContents*/
      128) inlinecontainertoggle_changes.item = /*item*/
      ctx2[21];
      if (dirty[0] & /*inlineContainerToggleService*/
      4) inlinecontainertoggle_changes.inlineContainerToggleService = /*inlineContainerToggleService*/
      ctx2[2];
      inlinecontainertoggle.$set(inlinecontainertoggle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainertoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainertoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainertoggle, detaching);
    }
  };
}
function create_default_slot_5$s(ctx) {
  let span;
  let t_value = (
    /*item*/
    ctx[21].name + ""
  );
  let t2;
  let span_data_tidy_item_name_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "truncate");
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*item*/
      ctx[21].name);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*configuredContents*/
      128 && t_value !== (t_value = /*item*/
      ctx2[21].name + "")) set_data(t2, t_value);
      if (dirty[0] & /*configuredContents*/
      128 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*item*/
      ctx2[21].name)) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_4$s(ctx) {
  let if_block_anchor;
  let if_block = (
    /*attunementContext*/
    ctx[30] && create_if_block_5$o(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*attunementContext*/
        ctx2[30]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5$o(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_5$o(ctx) {
  let i2;
  let i_class_value;
  let i_title_value;
  return {
    c() {
      i2 = element("i");
      set_style(i2, "margin-left", "auto");
      set_style(i2, "align-self", "center");
      attr(i2, "class", i_class_value = "item-state-icon fas " + /*attunementContext*/
      ctx[30].icon + " " + /*attunementContext*/
      ctx[30].cls + " fa-fw");
      attr(i2, "title", i_title_value = /*localize*/
      ctx[12](
        /*attunementContext*/
        ctx[30].title
      ));
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*configuredContents*/
      128 && i_class_value !== (i_class_value = "item-state-icon fas " + /*attunementContext*/
      ctx2[30].icon + " " + /*attunementContext*/
      ctx2[30].cls + " fa-fw")) {
        attr(i2, "class", i_class_value);
      }
      if (dirty[0] & /*configuredContents*/
      128 && i_title_value !== (i_title_value = /*localize*/
      ctx2[12](
        /*attunementContext*/
        ctx2[30].title
      ))) {
        attr(i2, "title", i_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_3$C(ctx) {
  let inlinefavoriteicon;
  let current;
  inlinefavoriteicon = new InlineFavoriteIcon({});
  return {
    c() {
      create_component(inlinefavoriteicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinefavoriteicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(inlinefavoriteicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinefavoriteicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinefavoriteicon, detaching);
    }
  };
}
function create_default_slot_4$x(ctx) {
  let itemusebutton;
  let t0;
  let t1;
  let itemname;
  let t2;
  let show_if = !FoundryAdapter.concealDetails(
    /*item*/
    ctx[21]
  );
  let t3;
  let if_block2_anchor;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !FoundryAdapter.canUseItem(
        /*item*/
        ctx[21]
      ),
      item: (
        /*item*/
        ctx[21]
      )
    }
  });
  let if_block0 = "containerContents" in /*ctx*/
  ctx[22] && !!/*ctx*/
  ctx[22].containerContents && create_if_block_6$h(ctx);
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[16](
        /*toggleSummary*/
        ctx[26]
      )
    );
  }
  itemname = new ItemName({
    props: {
      cssClass: "align-self-stretch flex-row align-items-center",
      item: (
        /*item*/
        ctx[21]
      ),
      $$slots: { default: [create_default_slot_5$s] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  let if_block1 = show_if && create_if_block_4$s(get_if_ctx$e(ctx));
  let if_block2 = !!/*ctx*/
  ctx[22].favoriteId && create_if_block_3$C();
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      create_component(itemname.$$.fragment);
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemname, target, anchor);
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty[0] & /*configuredContents*/
      128) itemusebutton_changes.disabled = !FoundryAdapter.canUseItem(
        /*item*/
        ctx[21]
      );
      if (dirty[0] & /*configuredContents*/
      128) itemusebutton_changes.item = /*item*/
      ctx[21];
      itemusebutton.$set(itemusebutton_changes);
      if ("containerContents" in /*ctx*/
      ctx[22] && !!/*ctx*/
      ctx[22].containerContents) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*itemContext, configuredContents*/
          130) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$h(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemname_changes = {};
      if (dirty[0] & /*configuredContents*/
      128) itemname_changes.item = /*item*/
      ctx[21];
      if (dirty[0] & /*configuredContents*/
      128 | dirty[1] & /*$$scope*/
      1) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
      if (dirty[0] & /*configuredContents*/
      128) show_if = !FoundryAdapter.concealDetails(
        /*item*/
        ctx[21]
      );
      if (show_if) {
        if (if_block1) {
          if_block1.p(get_if_ctx$e(ctx), dirty);
        } else {
          if_block1 = create_if_block_4$s(get_if_ctx$e(ctx));
          if_block1.c();
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!!/*ctx*/
      ctx[22].favoriteId) {
        if (if_block2) {
          if (dirty[0] & /*itemContext, configuredContents*/
          130) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$C();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemname.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemname.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block2_anchor);
      }
      destroy_component(itemusebutton, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemname, detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_default_slot_3$C(ctx) {
  let span;
  let t_value = (
    /*weight*/
    ctx[23] + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "truncate");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*itemContext, configuredContents*/
      130 && t_value !== (t_value = /*weight*/
      ctx2[23] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_2$D(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[21]
      ),
      field: "system.quantity",
      value: (
        /*item*/
        ctx[21].system.quantity
      ),
      selectOnFocus: true,
      disabled: !/*editable*/
      ctx[0] || /*lockItemQuantity*/
      ctx[3],
      placeholder: "0",
      allowDeltaChanges: true
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty[0] & /*configuredContents*/
      128) textinput_changes.document = /*item*/
      ctx2[21];
      if (dirty[0] & /*configuredContents*/
      128) textinput_changes.value = /*item*/
      ctx2[21].system.quantity;
      if (dirty[0] & /*editable, lockItemQuantity*/
      9) textinput_changes.disabled = !/*editable*/
      ctx2[0] || /*lockItemQuantity*/
      ctx2[3];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_2$M(ctx) {
  let tidytablecell;
  let current;
  tidytablecell = new TidyTableCell({
    props: {
      $$slots: { default: [create_default_slot_1$N] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytablecell_changes = {};
      if (dirty[0] & /*configuredContents*/
      128 | dirty[1] & /*$$scope*/
      1) {
        tidytablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell.$set(tidytablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytablecell, detaching);
    }
  };
}
function create_each_block_2$9(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*control*/
    ctx[27].getProps(
      /*item*/
      ctx[21]
    )
  ];
  var switch_value = (
    /*control*/
    ctx[27].component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty[0] & /*classicControls, configuredContents*/
    1152) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*control*/
        ctx2[27].getProps(
          /*item*/
          ctx2[21]
        )
      )]));
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = /*control*/
      ctx2[27].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*classicControls, configuredContents*/
        1152 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*control*/
          ctx2[27].getProps(
            /*item*/
            ctx2[21]
          )
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_1$N(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*classicControls*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$9(get_each_context_2$9(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*classicControls, configuredContents*/
      1152) {
        each_value_2 = ensure_array_like(
          /*classicControls*/
          ctx2[10]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$9(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot$1o(ctx) {
  let tidytablecell0;
  let t0;
  let tidytablecell1;
  let t1;
  let tidytablecell2;
  let t2;
  let if_block_anchor;
  let current;
  tidytablecell0 = new TidyTableCell({
    props: {
      class: "flex-row extra-small-gap",
      $$slots: { default: [create_default_slot_4$x] },
      $$scope: { ctx }
    }
  });
  tidytablecell1 = new TidyTableCell({
    props: {
      title: (
        /*localize*/
        ctx[12]("TIDY5E.Inventory.Weight.Text", {
          weight: (
            /*weight*/
            ctx[23]
          ),
          weightUnit: (
            /*weightUnit*/
            ctx[11]
          )
        })
      ),
      $$slots: { default: [create_default_slot_3$C] },
      $$scope: { ctx }
    }
  });
  tidytablecell2 = new TidyTableCell({
    props: {
      $$slots: { default: [create_default_slot_2$D] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*editable*/
    ctx[0] && /*useClassicControls*/
    ctx[5] && create_if_block_2$M(ctx)
  );
  return {
    c() {
      create_component(tidytablecell0.$$.fragment);
      t0 = space();
      create_component(tidytablecell1.$$.fragment);
      t1 = space();
      create_component(tidytablecell2.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(tidytablecell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(tidytablecell1, target, anchor);
      insert(target, t1, anchor);
      mount_component(tidytablecell2, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytablecell0_changes = {};
      if (dirty[0] & /*itemContext, configuredContents, toggleSummary, inlineContainerToggleService*/
      67108998 | dirty[1] & /*$$scope*/
      1) {
        tidytablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell0.$set(tidytablecell0_changes);
      const tidytablecell1_changes = {};
      if (dirty[0] & /*itemContext, configuredContents*/
      130) tidytablecell1_changes.title = /*localize*/
      ctx2[12]("TIDY5E.Inventory.Weight.Text", {
        weight: (
          /*weight*/
          ctx2[23]
        ),
        weightUnit: (
          /*weightUnit*/
          ctx2[11]
        )
      });
      if (dirty[0] & /*itemContext, configuredContents*/
      130 | dirty[1] & /*$$scope*/
      1) {
        tidytablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell1.$set(tidytablecell1_changes);
      const tidytablecell2_changes = {};
      if (dirty[0] & /*configuredContents, editable, lockItemQuantity*/
      137 | dirty[1] & /*$$scope*/
      1) {
        tidytablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell2.$set(tidytablecell2_changes);
      if (
        /*editable*/
        ctx2[0] && /*useClassicControls*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*editable, useClassicControls*/
          33) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$M(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(tidytablecell0.$$.fragment, local);
      transition_in(tidytablecell1.$$.fragment, local);
      transition_in(tidytablecell2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(tidytablecell0.$$.fragment, local);
      transition_out(tidytablecell1.$$.fragment, local);
      transition_out(tidytablecell2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(tidytablecell0, detaching);
      destroy_component(tidytablecell1, detaching);
      destroy_component(tidytablecell2, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_1$Y(ctx) {
  let inlinecontainerview;
  let current;
  inlinecontainerview = new InlineContainerView({
    props: {
      container: (
        /*item*/
        ctx[21]
      ),
      containerContents: (
        /*ctx*/
        ctx[22].containerContents
      ),
      editable: (
        /*editable*/
        ctx[0]
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[2]
      ),
      lockItemQuantity: (
        /*lockItemQuantity*/
        ctx[3]
      ),
      sheetDocument: (
        /*sheetDocument*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainerview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainerview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainerview_changes = {};
      if (dirty[0] & /*configuredContents*/
      128) inlinecontainerview_changes.container = /*item*/
      ctx2[21];
      if (dirty[0] & /*itemContext, configuredContents*/
      130) inlinecontainerview_changes.containerContents = /*ctx*/
      ctx2[22].containerContents;
      if (dirty[0] & /*editable*/
      1) inlinecontainerview_changes.editable = /*editable*/
      ctx2[0];
      if (dirty[0] & /*inlineContainerToggleService*/
      4) inlinecontainerview_changes.inlineContainerToggleService = /*inlineContainerToggleService*/
      ctx2[2];
      if (dirty[0] & /*lockItemQuantity*/
      8) inlinecontainerview_changes.lockItemQuantity = /*lockItemQuantity*/
      ctx2[3];
      if (dirty[0] & /*sheetDocument*/
      16) inlinecontainerview_changes.sheetDocument = /*sheetDocument*/
      ctx2[4];
      inlinecontainerview.$set(inlinecontainerview_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainerview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainerview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainerview, detaching);
    }
  };
}
function create_each_block_1$o(key_1, ctx) {
  let first;
  let itemtablerowv2;
  let t2;
  let if_block_anchor;
  let current;
  itemtablerowv2 = new ItemTableRowV2({
    props: {
      item: (
        /*item*/
        ctx[21]
      ),
      hidden: !!/*$itemIdsToShow*/
      ctx[8] && !/*$itemIdsToShow*/
      ctx[8].has(
        /*item*/
        ctx[21].id
      ),
      rowClass: FoundryAdapter.getInventoryRowClasses(
        /*item*/
        ctx[21],
        /*itemContext*/
        ctx[1][
          /*item*/
          ctx[21].id
        ]?.attunement
      ),
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[21].uuid
        )
      },
      $$slots: {
        default: [
          create_default_slot$1o,
          ({ toggleSummary }) => ({ 26: toggleSummary }),
          ({ toggleSummary }) => [toggleSummary ? 67108864 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = "containerContents" in /*ctx*/
  ctx[22] && !!/*ctx*/
  ctx[22].containerContents && create_if_block_1$Y(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerowv2.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerowv2, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerowv2_changes = {};
      if (dirty[0] & /*configuredContents*/
      128) itemtablerowv2_changes.item = /*item*/
      ctx[21];
      if (dirty[0] & /*$itemIdsToShow, configuredContents*/
      384) itemtablerowv2_changes.hidden = !!/*$itemIdsToShow*/
      ctx[8] && !/*$itemIdsToShow*/
      ctx[8].has(
        /*item*/
        ctx[21].id
      );
      if (dirty[0] & /*configuredContents, itemContext*/
      130) itemtablerowv2_changes.rowClass = FoundryAdapter.getInventoryRowClasses(
        /*item*/
        ctx[21],
        /*itemContext*/
        ctx[1][
          /*item*/
          ctx[21].id
        ]?.attunement
      );
      if (dirty[0] & /*configuredContents*/
      128) itemtablerowv2_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[21].uuid
        )
      };
      if (dirty[0] & /*configuredContents, editable, useClassicControls, lockItemQuantity, itemContext, toggleSummary, inlineContainerToggleService*/
      67109039 | dirty[1] & /*$$scope*/
      1) {
        itemtablerowv2_changes.$$scope = { dirty, ctx };
      }
      itemtablerowv2.$set(itemtablerowv2_changes);
      if ("containerContents" in /*ctx*/
      ctx[22] && !!/*ctx*/
      ctx[22].containerContents) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*itemContext, configuredContents*/
          130) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$Y(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerowv2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablerowv2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablerowv2, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_body_slot$k(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[18].items
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[21].id
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$o(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$o(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*configuredContents, itemContext, editable, inlineContainerToggleService, lockItemQuantity, sheetDocument, $itemIdsToShow, classicControls, useClassicControls, localize, weightUnit, toggleSummary*/
      67116479) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[18].items
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$o, each_1_anchor, get_each_context_1$o);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$W(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[18].show && create_if_block$1x(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*section*/
        ctx[18].show
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*configuredContents*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1x(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$3f(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*configuredContents*/
    ctx[7]
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[18].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$W(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$W(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*gridTemplateColumns, configuredContents, itemContext, editable, inlineContainerToggleService, lockItemQuantity, sheetDocument, $itemIdsToShow, classicControls, useClassicControls, localize, weightUnit, toggleSummary*/
      67116543) {
        each_value = ensure_array_like(
          /*configuredContents*/
          ctx2[7]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$W, each_1_anchor, get_each_context$W);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
const classicControlWidthRems = 1.5;
function instance$3e($$self, $$props, $$invalidate) {
  let configuredContents;
  let useClassicControls;
  let classicControlsWidth;
  let gridTemplateColumns;
  let $itemIdsToShow;
  let { contents } = $$props;
  let { container } = $$props;
  let { editable } = $$props;
  let { itemContext } = $$props;
  let { inlineContainerToggleService } = $$props;
  let { lockItemQuantity } = $$props;
  let { sheetDocument } = $$props;
  const tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  let itemIdsToShow = getContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(8, $itemIdsToShow = value));
  const classicControls = [
    {
      component: ItemEditControl,
      getProps: (item) => ({ item })
    },
    {
      component: ItemDeleteControl,
      getProps: (item) => ({
        item,
        deleteFn: () => item.deleteDialog()
      })
    }
  ];
  const weightUnit = FoundryAdapter.getWeightUnit();
  const localize = FoundryAdapter.localize;
  const toggle_handler = (toggleSummary) => toggleSummary();
  $$self.$$set = ($$props2) => {
    if ("contents" in $$props2) $$invalidate(13, contents = $$props2.contents);
    if ("container" in $$props2) $$invalidate(14, container = $$props2.container);
    if ("editable" in $$props2) $$invalidate(0, editable = $$props2.editable);
    if ("itemContext" in $$props2) $$invalidate(1, itemContext = $$props2.itemContext);
    if ("inlineContainerToggleService" in $$props2) $$invalidate(2, inlineContainerToggleService = $$props2.inlineContainerToggleService);
    if ("lockItemQuantity" in $$props2) $$invalidate(3, lockItemQuantity = $$props2.lockItemQuantity);
    if ("sheetDocument" in $$props2) $$invalidate(4, sheetDocument = $$props2.sheetDocument);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*contents, sheetDocument, container*/
    24592) {
      $$invalidate(7, configuredContents = SheetSections.configureInventory(contents.filter((i2) => i2.items.length), tabId, SheetPreferencesService.getByType(sheetDocument.type), TidyFlags.sectionConfig.get(container)?.[CONSTANTS.TAB_CONTAINER_CONTENTS]));
    }
    if ($$self.$$.dirty[0] & /*container*/
    16384) {
      $$invalidate(5, useClassicControls = FoundryAdapter.useClassicControls(container));
    }
    if ($$self.$$.dirty[0] & /*useClassicControls*/
    32) {
      $$invalidate(15, classicControlsWidth = useClassicControls ? `/* Controls */ ${classicControlWidthRems * classicControls.length}rem` : "");
    }
    if ($$self.$$.dirty[0] & /*classicControlsWidth*/
    32768) {
      $$invalidate(6, gridTemplateColumns = `/* Name */ 1fr /* Weight */ 3rem /* Quantity */ 3rem ${classicControlsWidth}`);
    }
  };
  return [
    editable,
    itemContext,
    inlineContainerToggleService,
    lockItemQuantity,
    sheetDocument,
    useClassicControls,
    gridTemplateColumns,
    configuredContents,
    $itemIdsToShow,
    itemIdsToShow,
    classicControls,
    weightUnit,
    localize,
    contents,
    container,
    classicControlsWidth,
    toggle_handler
  ];
}
class ContainerContentsSections extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3e,
      create_fragment$3f,
      safe_not_equal,
      {
        contents: 13,
        container: 14,
        editable: 0,
        itemContext: 1,
        inlineContainerToggleService: 2,
        lockItemQuantity: 3,
        sheetDocument: 4
      },
      null,
      [-1, -1]
    );
  }
}
function create_if_block$1w(ctx) {
  let div;
  let span;
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${FoundryAdapter.localize("TIDY5E.EmptyContainer")}`;
      attr(span, "class", "empty-container-text");
      attr(div, "class", "empty-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_default_slot$1n(ctx) {
  let div;
  let capacitybar;
  let t0;
  let containercontentssections;
  let t1;
  let show_if = !/*containerContents*/
  ctx[1].contents.some(func$1);
  let div_data_tidy_container_id_value;
  let current;
  let mounted;
  let dispose;
  capacitybar = new CapacityBar({
    props: {
      container: (
        /*container*/
        ctx[0]
      ),
      capacity: (
        /*containerContents*/
        ctx[1].capacity
      )
    }
  });
  containercontentssections = new ContainerContentsSections({
    props: {
      contents: (
        /*containerContents*/
        ctx[1].contents
      ),
      container: (
        /*container*/
        ctx[0]
      ),
      editable: (
        /*editable*/
        ctx[2]
      ),
      itemContext: (
        /*containerContents*/
        ctx[1].itemContext
      ),
      lockItemQuantity: (
        /*lockItemQuantity*/
        ctx[4]
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[3]
      ),
      sheetDocument: (
        /*sheetDocument*/
        ctx[5]
      )
    }
  });
  let if_block = show_if && create_if_block$1w();
  return {
    c() {
      div = element("div");
      create_component(capacitybar.$$.fragment);
      t0 = space();
      create_component(containercontentssections.$$.fragment);
      t1 = space();
      if (if_block) if_block.c();
      attr(div, "class", "flex-column extra-small-gap flex-1 inline-container-view");
      attr(div, "data-tidy-container-id", div_data_tidy_container_id_value = /*container*/
      ctx[0].id);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(capacitybar, div, null);
      append(div, t0);
      mount_component(containercontentssections, div, null);
      append(div, t1);
      if (if_block) if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "drop",
          /*onDrop*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const capacitybar_changes = {};
      if (dirty & /*container*/
      1) capacitybar_changes.container = /*container*/
      ctx2[0];
      if (dirty & /*containerContents*/
      2) capacitybar_changes.capacity = /*containerContents*/
      ctx2[1].capacity;
      capacitybar.$set(capacitybar_changes);
      const containercontentssections_changes = {};
      if (dirty & /*containerContents*/
      2) containercontentssections_changes.contents = /*containerContents*/
      ctx2[1].contents;
      if (dirty & /*container*/
      1) containercontentssections_changes.container = /*container*/
      ctx2[0];
      if (dirty & /*editable*/
      4) containercontentssections_changes.editable = /*editable*/
      ctx2[2];
      if (dirty & /*containerContents*/
      2) containercontentssections_changes.itemContext = /*containerContents*/
      ctx2[1].itemContext;
      if (dirty & /*lockItemQuantity*/
      16) containercontentssections_changes.lockItemQuantity = /*lockItemQuantity*/
      ctx2[4];
      if (dirty & /*inlineContainerToggleService*/
      8) containercontentssections_changes.inlineContainerToggleService = /*inlineContainerToggleService*/
      ctx2[3];
      if (dirty & /*sheetDocument*/
      32) containercontentssections_changes.sheetDocument = /*sheetDocument*/
      ctx2[5];
      containercontentssections.$set(containercontentssections_changes);
      if (dirty & /*containerContents*/
      2) show_if = !/*containerContents*/
      ctx2[1].contents.some(func$1);
      if (show_if) {
        if (if_block) ;
        else {
          if_block = create_if_block$1w();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*container*/
      1 && div_data_tidy_container_id_value !== (div_data_tidy_container_id_value = /*container*/
      ctx2[0].id)) {
        attr(div, "data-tidy-container-id", div_data_tidy_container_id_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(capacitybar.$$.fragment, local);
      transition_in(containercontentssections.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(capacitybar.$$.fragment, local);
      transition_out(containercontentssections.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(capacitybar);
      destroy_component(containercontentssections);
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3e(ctx) {
  let expandablecontainer;
  let current;
  expandablecontainer = new ExpandableContainer({
    props: {
      expanded: (
        /*$inlineContainerToggleServiceStore*/
        ctx[7].get(
          /*tabId*/
          ctx[10]
        )?.has(
          /*container*/
          ctx[0].id
        ) === true
      ),
      class: !!/*$itemIdsToShow*/
      ctx[8] && !/*$itemIdsToShow*/
      ctx[8].has(
        /*container*/
        ctx[0].id
      ) ? "hidden" : "",
      $$slots: { default: [create_default_slot$1n] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expandablecontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expandablecontainer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expandablecontainer_changes = {};
      if (dirty & /*$inlineContainerToggleServiceStore, container*/
      129) expandablecontainer_changes.expanded = /*$inlineContainerToggleServiceStore*/
      ctx2[7].get(
        /*tabId*/
        ctx2[10]
      )?.has(
        /*container*/
        ctx2[0].id
      ) === true;
      if (dirty & /*$itemIdsToShow, container*/
      257) expandablecontainer_changes.class = !!/*$itemIdsToShow*/
      ctx2[8] && !/*$itemIdsToShow*/
      ctx2[8].has(
        /*container*/
        ctx2[0].id
      ) ? "hidden" : "";
      if (dirty & /*$$scope, container, containerContents, editable, lockItemQuantity, inlineContainerToggleService, sheetDocument*/
      4159) {
        expandablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandablecontainer.$set(expandablecontainer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(expandablecontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expandablecontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expandablecontainer, detaching);
    }
  };
}
const func$1 = (c2) => c2.items.length > 0;
function instance$3d($$self, $$props, $$invalidate) {
  let inlineContainerToggleServiceStore;
  let $inlineContainerToggleServiceStore, $$unsubscribe_inlineContainerToggleServiceStore = noop$1, $$subscribe_inlineContainerToggleServiceStore = () => ($$unsubscribe_inlineContainerToggleServiceStore(), $$unsubscribe_inlineContainerToggleServiceStore = subscribe(inlineContainerToggleServiceStore, ($$value) => $$invalidate(7, $inlineContainerToggleServiceStore = $$value)), inlineContainerToggleServiceStore);
  let $itemIdsToShow;
  $$self.$$.on_destroy.push(() => $$unsubscribe_inlineContainerToggleServiceStore());
  let { container } = $$props;
  let { containerContents } = $$props;
  let { editable } = $$props;
  let { inlineContainerToggleService } = $$props;
  let { lockItemQuantity } = $$props;
  let { sheetDocument } = $$props;
  let itemIdsToShow = getContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(8, $itemIdsToShow = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  async function onDrop(event) {
    container.sheet._onDrop(event);
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  $$self.$$set = ($$props2) => {
    if ("container" in $$props2) $$invalidate(0, container = $$props2.container);
    if ("containerContents" in $$props2) $$invalidate(1, containerContents = $$props2.containerContents);
    if ("editable" in $$props2) $$invalidate(2, editable = $$props2.editable);
    if ("inlineContainerToggleService" in $$props2) $$invalidate(3, inlineContainerToggleService = $$props2.inlineContainerToggleService);
    if ("lockItemQuantity" in $$props2) $$invalidate(4, lockItemQuantity = $$props2.lockItemQuantity);
    if ("sheetDocument" in $$props2) $$invalidate(5, sheetDocument = $$props2.sheetDocument);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*inlineContainerToggleService*/
    8) {
      $$subscribe_inlineContainerToggleServiceStore($$invalidate(6, inlineContainerToggleServiceStore = inlineContainerToggleService.store));
    }
  };
  return [
    container,
    containerContents,
    editable,
    inlineContainerToggleService,
    lockItemQuantity,
    sheetDocument,
    inlineContainerToggleServiceStore,
    $inlineContainerToggleServiceStore,
    $itemIdsToShow,
    itemIdsToShow,
    tabId,
    onDrop
  ];
}
class InlineContainerView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3d, create_fragment$3e, safe_not_equal, {
      container: 0,
      containerContents: 1,
      editable: 2,
      inlineContainerToggleService: 3,
      lockItemQuantity: 4,
      sheetDocument: 5
    });
  }
}
function get_each_context$V(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[7].itemContext[
      /*item*/
      child_ctx[20].id
    ]
  );
  child_ctx[21] = constants_0;
  const constants_1 = (
    /*item*/
    child_ctx[20].system.identified === false ? coalesce(
      /*item*/
      child_ctx[20].system.unidentified.name,
      /*localize*/
      child_ctx[14]("DND5E.Unidentified.Title")
    ) : (
      /*item*/
      child_ctx[20].name
    )
  );
  child_ctx[22] = constants_1;
  return child_ctx;
}
function get_if_ctx$d(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*ctx*/
    child_ctx[21]?.totalWeight ?? /*item*/
    child_ctx[20].system.weight.value
  );
  child_ctx[26] = constants_0;
  return child_ctx;
}
function create_default_slot_14$7(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*primaryColumnName*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*primaryColumnName*/
      1) set_data(
        t2,
        /*primaryColumnName*/
        ctx2[0]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_12$6(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      title: (
        /*localize*/
        ctx[14]("DND5E.Weight") + " (" + /*weightUnit*/
        ctx[15] + ")"
      ),
      baseWidth: "4rem",
      $$slots: { default: [create_default_slot_13$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope*/
      134217728) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_13$9(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-weight-hanging");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot_12$a(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-bolt");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot_11$b(ctx) {
  let t_value = (
    /*localize*/
    ctx[14]("DND5E.Usage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_10$f(ctx) {
  let t_value = (
    /*localize*/
    ctx[14]("DND5E.QuantityAbbr") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_11$7(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      256) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[8];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_9$g(ctx) {
  let itemtablecolumn0;
  let t0;
  let t1;
  let itemtablecolumn1;
  let t2;
  let itemtablecolumn2;
  let t3;
  let itemtablecolumn3;
  let t4;
  let if_block1_anchor;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_14$7] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*includeWeightColumn*/
    ctx[5] && create_if_block_12$6(ctx)
  );
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      title: (
        /*localize*/
        ctx[14]("DND5E.Charges")
      ),
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_12$a] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn2 = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_11$b] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn3 = new ItemTableColumn({
    props: {
      baseWidth: "3rem",
      $$slots: { default: [create_default_slot_10$f] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$context*/
    ctx[7].editable && /*$context*/
    ctx[7].useClassicControls && !/*lockControls*/
    ctx[3] && create_if_block_11$7(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t2 = space();
      create_component(itemtablecolumn2.$$.fragment);
      t3 = space();
      create_component(itemtablecolumn3.$$.fragment);
      t4 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      insert(target, t3, anchor);
      mount_component(itemtablecolumn3, target, anchor);
      insert(target, t4, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope, primaryColumnName*/
      134217729) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      if (
        /*includeWeightColumn*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*includeWeightColumn*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12$6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemtablecolumn1_changes = {};
      if (dirty & /*$$scope*/
      134217728) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
      const itemtablecolumn2_changes = {};
      if (dirty & /*$$scope*/
      134217728) {
        itemtablecolumn2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn2.$set(itemtablecolumn2_changes);
      const itemtablecolumn3_changes = {};
      if (dirty & /*$$scope*/
      134217728) {
        itemtablecolumn3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn3.$set(itemtablecolumn3_changes);
      if (
        /*$context*/
        ctx2[7].editable && /*$context*/
        ctx2[7].useClassicControls && !/*lockControls*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context, lockControls*/
          136) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_11$7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(itemtablecolumn2.$$.fragment, local);
      transition_in(itemtablecolumn3.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(itemtablecolumn2.$$.fragment, local);
      transition_out(itemtablecolumn3.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block1_anchor);
      }
      destroy_component(itemtablecolumn0, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemtablecolumn1, detaching);
      destroy_component(itemtablecolumn2, detaching);
      destroy_component(itemtablecolumn3, detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_header_slot$k(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_9$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, classicControlsColumnWidth, $context, lockControls, includeWeightColumn, primaryColumnName*/
      134218153) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_if_block_10$8(ctx) {
  let inlinecontainertoggle;
  let current;
  inlinecontainertoggle = new InlineContainerToggle({
    props: {
      item: (
        /*item*/
        ctx[20]
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[11]
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainertoggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainertoggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainertoggle_changes = {};
      if (dirty & /*items*/
      2) inlinecontainertoggle_changes.item = /*item*/
      ctx2[20];
      inlinecontainertoggle.$set(inlinecontainertoggle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainertoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainertoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainertoggle, detaching);
    }
  };
}
function create_if_block_9$a(ctx) {
  let span;
  let ammoselector;
  let current;
  ammoselector = new AmmoSelector({ props: { item: (
    /*item*/
    ctx[20]
  ) } });
  return {
    c() {
      span = element("span");
      create_component(ammoselector.$$.fragment);
      attr(span, "class", "ammo");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(ammoselector, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ammoselector_changes = {};
      if (dirty & /*items*/
      2) ammoselector_changes.item = /*item*/
      ctx2[20];
      ammoselector.$set(ammoselector_changes);
    },
    i(local) {
      if (current) return;
      transition_in(ammoselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ammoselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(ammoselector);
    }
  };
}
function create_default_slot_8$i(ctx) {
  let span;
  let t0_value = (
    /*itemName*/
    ctx[22] + ""
  );
  let t0;
  let span_data_tidy_item_name_value;
  let t1;
  let show_if = (
    /*item*/
    ctx[20].system?.properties?.has("amm")
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_9$a(ctx);
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "truncate");
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*itemName*/
      ctx[22]);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*items*/
      2) && t0_value !== (t0_value = /*itemName*/
      ctx2[22] + "")) set_data(t0, t0_value);
      if (!current || dirty & /*items*/
      2 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*itemName*/
      ctx2[22])) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
      if (dirty & /*items*/
      2) show_if = /*item*/
      ctx2[20].system?.properties?.has("amm");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*items*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_9$a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot_7$l(ctx) {
  let itemusebutton;
  let t0;
  let t1;
  let itemname;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[7].editable,
      item: (
        /*item*/
        ctx[20]
      )
    }
  });
  let if_block = "containerContents" in /*ctx*/
  ctx[21] && !!/*ctx*/
  ctx[21].containerContents && create_if_block_10$8(ctx);
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[18](
        /*toggleSummary*/
        ctx[25]
      )
    );
  }
  itemname = new ItemName({
    props: {
      cssClass: "extra-small-gap",
      item: (
        /*item*/
        ctx[20]
      ),
      $$slots: { default: [create_default_slot_8$i] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      create_component(itemname.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemname, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty & /*$context*/
      128) itemusebutton_changes.disabled = !/*$context*/
      ctx[7].editable;
      if (dirty & /*items*/
      2) itemusebutton_changes.item = /*item*/
      ctx[20];
      itemusebutton.$set(itemusebutton_changes);
      if ("containerContents" in /*ctx*/
      ctx[21] && !!/*ctx*/
      ctx[21].containerContents) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$context, items*/
          130) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_10$8(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const itemname_changes = {};
      if (dirty & /*items*/
      2) itemname_changes.item = /*item*/
      ctx[20];
      if (dirty & /*$$scope, items*/
      134217730) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(if_block);
      transition_in(itemname.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(if_block);
      transition_out(itemname.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(itemusebutton, detaching);
      if (if_block) if_block.d(detaching);
      destroy_component(itemname, detaching);
    }
  };
}
function create_if_block_6$g(ctx) {
  let itemtablecell;
  let t2;
  let if_block_anchor;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      cssClass: "no-border",
      $$slots: { default: [create_default_slot_6$m] },
      $$scope: { ctx }
    }
  });
  let if_block = "favoriteId" in /*ctx*/
  ctx[21] && !!/*ctx*/
  ctx[21].favoriteId && /*allowFavoriteIconNextToName*/
  ctx[4] && create_if_block_7$e();
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, $context, items*/
      134217858) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
      if ("favoriteId" in /*ctx*/
      ctx2[21] && !!/*ctx*/
      ctx2[21].favoriteId && /*allowFavoriteIconNextToName*/
      ctx2[4]) {
        if (if_block) {
          if (dirty & /*$context, items, allowFavoriteIconNextToName*/
          146) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7$e();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecell, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_8$b(ctx) {
  let div;
  let i2;
  let i_class_value;
  let i_title_value;
  return {
    c() {
      div = element("div");
      i2 = element("i");
      attr(i2, "class", i_class_value = "item-state-icon fas " + /*ctx*/
      ctx[21].attunement.icon + " " + /*ctx*/
      ctx[21].attunement.cls + " svelte-16qwexh");
      attr(i2, "title", i_title_value = /*localize*/
      ctx[14](
        /*ctx*/
        ctx[21].attunement.title
      ));
      attr(div, "class", "item-detail attunement svelte-16qwexh");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, i2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, items*/
      130 && i_class_value !== (i_class_value = "item-state-icon fas " + /*ctx*/
      ctx2[21].attunement.icon + " " + /*ctx*/
      ctx2[21].attunement.cls + " svelte-16qwexh")) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & /*$context, items*/
      130 && i_title_value !== (i_title_value = /*localize*/
      ctx2[14](
        /*ctx*/
        ctx2[21].attunement.title
      ))) {
        attr(i2, "title", i_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_default_slot_6$m(ctx) {
  let show_if = (
    /*ctx*/
    ctx[21]?.attunement && !FoundryAdapter.concealDetails(
      /*item*/
      ctx[20]
    )
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block_8$b(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, items*/
      130) show_if = /*ctx*/
      ctx2[21]?.attunement && !FoundryAdapter.concealDetails(
        /*item*/
        ctx2[20]
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_8$b(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_7$e(ctx) {
  let inlinefavoriteicon;
  let current;
  inlinefavoriteicon = new InlineFavoriteIcon({});
  return {
    c() {
      create_component(inlinefavoriteicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinefavoriteicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(inlinefavoriteicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinefavoriteicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinefavoriteicon, detaching);
    }
  };
}
function create_if_block_5$n(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "4rem",
      title: (
        /*localize*/
        ctx[14]("TIDY5E.Inventory.Weight.Tooltip", {
          weight: (
            /*weight*/
            ctx[26]
          ),
          weightUnit: (
            /*weightUnit*/
            ctx[15]
          )
        })
      ),
      $$slots: { default: [create_default_slot_5$r] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$context, items*/
      130) itemtablecell_changes.title = /*localize*/
      ctx2[14]("TIDY5E.Inventory.Weight.Tooltip", {
        weight: (
          /*weight*/
          ctx2[26]
        ),
        weightUnit: (
          /*weightUnit*/
          ctx2[15]
        )
      });
      if (dirty & /*$$scope, $context, items*/
      134217858) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_5$r(ctx) {
  let span;
  let t_value = (
    /*localize*/
    ctx[14]("TIDY5E.Inventory.Weight.Text", {
      weight: (
        /*weight*/
        ctx[26]
      ),
      weightUnit: (
        /*weightUnit*/
        ctx[15]
      )
    }) + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "truncate");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, items*/
      130 && t_value !== (t_value = /*localize*/
      ctx2[14]("TIDY5E.Inventory.Weight.Text", {
        weight: (
          /*weight*/
          ctx2[26]
        ),
        weightUnit: (
          /*weightUnit*/
          ctx2[15]
        )
      }) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block$U(ctx) {
  let itemadduses;
  let current;
  itemadduses = new ItemAddUses({ props: { item: (
    /*item*/
    ctx[20]
  ) } });
  return {
    c() {
      create_component(itemadduses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemadduses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemadduses_changes = {};
      if (dirty & /*items*/
      2) itemadduses_changes.item = /*item*/
      ctx2[20];
      itemadduses.$set(itemadduses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemadduses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemadduses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemadduses, detaching);
    }
  };
}
function create_if_block_4$r(ctx) {
  let itemuses;
  let current;
  itemuses = new ItemUses({ props: { item: (
    /*item*/
    ctx[20]
  ) } });
  return {
    c() {
      create_component(itemuses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemuses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemuses_changes = {};
      if (dirty & /*items*/
      2) itemuses_changes.item = /*item*/
      ctx2[20];
      itemuses.$set(itemuses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemuses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemuses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemuses, detaching);
    }
  };
}
function create_default_slot_4$w(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$r, create_else_block$U];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*ctx*/
      ctx2[21]?.hasUses
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_3$B(ctx) {
  let t_value = (
    /*item*/
    (ctx[20].labels?.activation ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      2 && t_value !== (t_value = /*item*/
      (ctx2[20].labels?.activation ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$B(ctx) {
  let if_block_anchor;
  let if_block = (
    /*item*/
    ctx[20].system.activation?.type && create_if_block_3$B(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[20].system.activation?.type
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$B(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot_2$C(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[20]
      ),
      field: "system.quantity",
      value: (
        /*item*/
        ctx[20].system.quantity
      ),
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[7].editable || /*$context*/
      ctx[7].lockItemQuantity,
      placeholder: "0",
      allowDeltaChanges: true,
      cssClass: "text-align-center"
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*items*/
      2) textinput_changes.document = /*item*/
      ctx2[20];
      if (dirty & /*items*/
      2) textinput_changes.value = /*item*/
      ctx2[20].system.quantity;
      if (dirty & /*$context*/
      128) textinput_changes.disabled = !/*$context*/
      ctx2[7].editable || /*$context*/
      ctx2[7].lockItemQuantity;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_2$L(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot_1$M] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      256) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[8];
      if (dirty & /*$$scope, controls, items, $context*/
      134217922) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_1$M(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[6]
      ),
      params: {
        item: (
          /*item*/
          ctx[20]
        ),
        ctx: (
          /*ctx*/
          ctx[21]
        )
      }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      64) classiccontrols_changes.controls = /*controls*/
      ctx2[6];
      if (dirty & /*items, $context*/
      130) classiccontrols_changes.params = {
        item: (
          /*item*/
          ctx2[20]
        ),
        ctx: (
          /*ctx*/
          ctx2[21]
        )
      };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot$1m(ctx) {
  let itemtablecell0;
  let t0;
  let t1;
  let t2;
  let itemtablecell1;
  let t3;
  let itemtablecell2;
  let t4;
  let itemtablecell3;
  let t5;
  let if_block2_anchor;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_7$l] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$settingStore*/
    ctx[10].showIconsNextToTheItemName && create_if_block_6$g(ctx)
  );
  let if_block1 = (
    /*includeWeightColumn*/
    ctx[5] && create_if_block_5$n(get_if_ctx$d(ctx))
  );
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "3.125rem",
      title: (
        /*localize*/
        ctx[14]("DND5E.Uses")
      ),
      $$slots: { default: [create_default_slot_4$w] },
      $$scope: { ctx }
    }
  });
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      title: (
        /*localize*/
        ctx[14]("DND5E.Usage")
      ),
      $$slots: { default: [create_default_slot_3$B] },
      $$scope: { ctx }
    }
  });
  itemtablecell3 = new ItemTableCell({
    props: {
      baseWidth: "3rem",
      $$slots: { default: [create_default_slot_2$C] },
      $$scope: { ctx }
    }
  });
  let if_block2 = (
    /*$context*/
    ctx[7].editable && /*$context*/
    ctx[7].useClassicControls && !/*lockControls*/
    ctx[3] && create_if_block_2$L(ctx)
  );
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      create_component(itemtablecell1.$$.fragment);
      t3 = space();
      create_component(itemtablecell2.$$.fragment);
      t4 = space();
      create_component(itemtablecell3.$$.fragment);
      t5 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t3, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t4, anchor);
      mount_component(itemtablecell3, target, anchor);
      insert(target, t5, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*$$scope, items, toggleSummary, $context*/
      167772290) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      if (
        /*$settingStore*/
        ctx2[10].showIconsNextToTheItemName
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$settingStore*/
          1024) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$g(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*includeWeightColumn*/
        ctx2[5]
      ) {
        if (if_block1) {
          if_block1.p(get_if_ctx$d(ctx2), dirty);
          if (dirty & /*includeWeightColumn*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5$n(get_if_ctx$d(ctx2));
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const itemtablecell1_changes = {};
      if (dirty & /*$$scope, items, $context*/
      134217858) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      const itemtablecell2_changes = {};
      if (dirty & /*$$scope, items*/
      134217730) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
      const itemtablecell3_changes = {};
      if (dirty & /*$$scope, items, $context*/
      134217858) {
        itemtablecell3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell3.$set(itemtablecell3_changes);
      if (
        /*$context*/
        ctx2[7].editable && /*$context*/
        ctx2[7].useClassicControls && !/*lockControls*/
        ctx2[3]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context, lockControls*/
          136) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$L(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(itemtablecell2.$$.fragment, local);
      transition_in(itemtablecell3.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(itemtablecell2.$$.fragment, local);
      transition_out(itemtablecell3.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(if_block2_anchor);
      }
      destroy_component(itemtablecell0, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(itemtablecell1, detaching);
      destroy_component(itemtablecell2, detaching);
      destroy_component(itemtablecell3, detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_1$X(ctx) {
  let inlinecontainerview;
  let current;
  inlinecontainerview = new InlineContainerView({
    props: {
      container: (
        /*item*/
        ctx[20]
      ),
      containerContents: (
        /*ctx*/
        ctx[21].containerContents
      ),
      editable: (
        /*$context*/
        ctx[7].editable
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[11]
      ),
      lockItemQuantity: (
        /*$context*/
        ctx[7].lockItemQuantity
      ),
      sheetDocument: (
        /*$context*/
        ctx[7].actor
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainerview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainerview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainerview_changes = {};
      if (dirty & /*items*/
      2) inlinecontainerview_changes.container = /*item*/
      ctx2[20];
      if (dirty & /*$context, items*/
      130) inlinecontainerview_changes.containerContents = /*ctx*/
      ctx2[21].containerContents;
      if (dirty & /*$context*/
      128) inlinecontainerview_changes.editable = /*$context*/
      ctx2[7].editable;
      if (dirty & /*$context*/
      128) inlinecontainerview_changes.lockItemQuantity = /*$context*/
      ctx2[7].lockItemQuantity;
      if (dirty & /*$context*/
      128) inlinecontainerview_changes.sheetDocument = /*$context*/
      ctx2[7].actor;
      inlinecontainerview.$set(inlinecontainerview_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainerview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainerview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainerview, detaching);
    }
  };
}
function create_each_block$V(key_1, ctx) {
  let first;
  let itemtablerow;
  let t2;
  let if_block_anchor;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[19](
        /*item*/
        ctx[20],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      item: (
        /*item*/
        ctx[20]
      ),
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[20].uuid
        )
      },
      cssClass: (
        /*getInventoryRowClasses*/
        ctx[16](
          /*item*/
          ctx[20]
        )
      ),
      hidden: !!/*$itemIdsToShow*/
      ctx[9] && !/*$itemIdsToShow*/
      ctx[9].has(
        /*item*/
        ctx[20].id
      ),
      favoriteId: "favoriteId" in /*ctx*/
      ctx[21] ? (
        /*ctx*/
        ctx[21].favoriteId
      ) : null,
      $$slots: {
        default: [
          create_default_slot$1m,
          ({ toggleSummary }) => ({ 25: toggleSummary }),
          ({ toggleSummary }) => toggleSummary ? 33554432 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  let if_block = "containerContents" in /*ctx*/
  ctx[21] && !!/*ctx*/
  ctx[21].containerContents && create_if_block_1$X(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*items*/
      2) itemtablerow_changes.item = /*item*/
      ctx[20];
      if (dirty & /*items*/
      2) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[20].uuid
        )
      };
      if (dirty & /*items*/
      2) itemtablerow_changes.cssClass = /*getInventoryRowClasses*/
      ctx[16](
        /*item*/
        ctx[20]
      );
      if (dirty & /*$itemIdsToShow, items*/
      514) itemtablerow_changes.hidden = !!/*$itemIdsToShow*/
      ctx[9] && !/*$itemIdsToShow*/
      ctx[9].has(
        /*item*/
        ctx[20].id
      );
      if (dirty & /*$context, items*/
      130) itemtablerow_changes.favoriteId = "favoriteId" in /*ctx*/
      ctx[21] ? (
        /*ctx*/
        ctx[21].favoriteId
      ) : null;
      if (dirty & /*$$scope, classicControlsColumnWidth, controls, items, $context, lockControls, includeWeightColumn, allowFavoriteIconNextToName, $settingStore, toggleSummary*/
      167773690) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
      if ("containerContents" in /*ctx*/
      ctx[21] && !!/*ctx*/
      ctx[21].containerContents) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$context, items*/
          130) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$X(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablerow, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block$1v(ctx) {
  let itemtablefooter;
  let current;
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[7].actor
      ),
      section: (
        /*section*/
        ctx[2]
      ),
      isItem: true
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablefooter_changes = {};
      if (dirty & /*$context*/
      128) itemtablefooter_changes.actor = /*$context*/
      ctx2[7].actor;
      if (dirty & /*section*/
      4) itemtablefooter_changes.section = /*section*/
      ctx2[2];
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$j(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let if_block_anchor;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[20].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$V(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$V(key, child_ctx));
  }
  let if_block = (
    /*$context*/
    ctx[7].unlocked && /*section*/
    ctx[2].canCreate && create_if_block$1v(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*items, $context, inlineContainerToggleService, getInventoryRowClasses, $itemIdsToShow, classicControlsColumnWidth, controls, lockControls, localize, weightUnit, includeWeightColumn, allowFavoriteIconNextToName, $settingStore, toggleSummary*/
      33673210) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t2.parentNode, outro_and_destroy_block, create_each_block$V, t2, get_each_context$V);
        check_outros();
      }
      if (
        /*$context*/
        ctx2[7].unlocked && /*section*/
        ctx2[2].canCreate
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context, section*/
          132) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1v(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$3d(ctx) {
  let section_1;
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[2].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[2].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$j],
        header: [create_header_slot$k]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section_1 = element("section");
      create_component(itemtable.$$.fragment);
      attr(section_1, "class", "inventory-list-section svelte-16qwexh");
    },
    m(target, anchor) {
      insert(target, section_1, anchor);
      mount_component(itemtable, section_1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*section*/
      4) itemtable_changes.key = /*section*/
      ctx2[2].key;
      if (dirty & /*section*/
      4) itemtable_changes["data-custom-section"] = /*section*/
      ctx2[2].custom ? true : null;
      if (dirty & /*$$scope, $context, section, items, $itemIdsToShow, classicControlsColumnWidth, controls, lockControls, includeWeightColumn, allowFavoriteIconNextToName, $settingStore, primaryColumnName*/
      134219775) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section_1);
      }
      destroy_component(itemtable);
    }
  };
}
let classicControlsIconWidth$7 = 1.25;
function instance$3c($$self, $$props, $$invalidate) {
  let classicControlsColumnWidth;
  let $context;
  let $itemIdsToShow;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(10, $settingStore = $$value));
  let { primaryColumnName } = $$props;
  let { items } = $$props;
  let { section } = $$props;
  let { extraInventoryRowClasses = "" } = $$props;
  let { lockControls = false } = $$props;
  let { allowFavoriteIconNextToName = true } = $$props;
  let { includeWeightColumn = true } = $$props;
  let inlineContainerToggleService = getContext(CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE);
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(7, $context = value));
  let itemIdsToShow = getContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(9, $itemIdsToShow = value));
  const localize = FoundryAdapter.localize;
  const weightUnit = FoundryAdapter.getWeightUnit();
  let controls = [];
  function getInventoryRowClasses(item) {
    const extras = [];
    if (extraInventoryRowClasses) {
      extras.push(extraInventoryRowClasses);
    }
    return FoundryAdapter.getInventoryRowClasses(item, $context.itemContext[item.id], extras);
  }
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (item, event) => FoundryAdapter.editOnMiddleClick(event.detail, item);
  $$self.$$set = ($$props2) => {
    if ("primaryColumnName" in $$props2) $$invalidate(0, primaryColumnName = $$props2.primaryColumnName);
    if ("items" in $$props2) $$invalidate(1, items = $$props2.items);
    if ("section" in $$props2) $$invalidate(2, section = $$props2.section);
    if ("extraInventoryRowClasses" in $$props2) $$invalidate(17, extraInventoryRowClasses = $$props2.extraInventoryRowClasses);
    if ("lockControls" in $$props2) $$invalidate(3, lockControls = $$props2.lockControls);
    if ("allowFavoriteIconNextToName" in $$props2) $$invalidate(4, allowFavoriteIconNextToName = $$props2.allowFavoriteIconNextToName);
    if ("includeWeightColumn" in $$props2) $$invalidate(5, includeWeightColumn = $$props2.includeWeightColumn);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*controls, $context*/
    192) {
      {
        $$invalidate(6, controls = []);
        controls.push(
          {
            component: AttuneControl,
            props: ({ item, ctx }) => ({ item, ctx }),
            visible: ({ item, ctx }) => ctx?.attunement && !FoundryAdapter.concealDetails(item)
          },
          {
            component: EquipControl,
            props: ({ item, ctx }) => ({ item, ctx }),
            visible: ({ ctx }) => ctx?.canToggle === true
          }
        );
        if ("favorites" in $context.actor.system) {
          controls.push({
            component: ItemFavoriteControl,
            props: ({ item }) => ({ item })
          });
        }
        controls.push({
          component: ItemEditControl,
          props: ({ item }) => ({ item })
        });
        if ($context.unlocked) {
          controls.push({
            component: ItemDeleteControl,
            props: ({ item }) => ({ item })
          });
        }
        if ($context.useActionsFeature) {
          controls.push({
            component: ActionFilterOverrideControl,
            props: ({ item }) => ({ item })
          });
        }
      }
    }
    if ($$self.$$.dirty & /*controls*/
    64) {
      $$invalidate(8, classicControlsColumnWidth = `${classicControlsIconWidth$7 * controls.length}rem`);
    }
  };
  return [
    primaryColumnName,
    items,
    section,
    lockControls,
    allowFavoriteIconNextToName,
    includeWeightColumn,
    controls,
    $context,
    classicControlsColumnWidth,
    $itemIdsToShow,
    $settingStore,
    inlineContainerToggleService,
    context,
    itemIdsToShow,
    localize,
    weightUnit,
    getInventoryRowClasses,
    extraInventoryRowClasses,
    toggle_handler,
    mousedown_handler
  ];
}
class InventoryList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3c, create_fragment$3d, safe_not_equal, {
      primaryColumnName: 0,
      items: 1,
      section: 2,
      extraInventoryRowClasses: 17,
      lockControls: 3,
      allowFavoriteIconNextToName: 4,
      includeWeightColumn: 5
    });
  }
}
function create_if_block$1u(ctx) {
  let t2;
  return {
    c() {
      t2 = text("+");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$3c(ctx) {
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*item*/
    ctx[0].system.recharge?.value + ""
  );
  let t1;
  let button_disabled_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  let if_block = (
    /*item*/
    ctx[0].system.recharge?.value !== 6 && create_if_block$1u()
  );
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      if (if_block) if_block.c();
      attr(i2, "class", "fas fa-dice-six");
      attr(button, "type", "button");
      attr(button, "class", "item-list-button");
      attr(
        button,
        "title",
        /*rechargeLabel*/
        ctx[1]
      );
      button.disabled = button_disabled_value = !/*$context*/
      ctx[2].owner;
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[3].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      if (if_block) if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*item*/
      1 && t1_value !== (t1_value = /*item*/
      ctx2[0].system.recharge?.value + "")) set_data(t1, t1_value);
      if (
        /*item*/
        ctx2[0].system.recharge?.value !== 6
      ) {
        if (if_block) ;
        else {
          if_block = create_if_block$1u();
          if_block.c();
          if_block.m(button, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*rechargeLabel*/
      2) {
        attr(
          button,
          "title",
          /*rechargeLabel*/
          ctx2[1]
        );
      }
      if (dirty & /*$context*/
      4 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx2[2].owner)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$settingStore*/
      8 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[3].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$3b($$self, $$props, $$invalidate) {
  let rechargeLabel;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(3, $settingStore = $$value));
  let { item } = $$props;
  const localize = FoundryAdapter.localize;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  const click_handler = (ev) => ev.shiftKey ? item.update({ "system.recharge.charged": true }) : item.rollRecharge();
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(1, rechargeLabel = item.system.recharge?.charged === false ? localize("TIDY5E.RollRecharge.Hint", {
        rechargeLabel: item.labels?.recharge ?? ""
      }) : item.labels?.recharge ?? "");
    }
  };
  return [item, rechargeLabel, $context, $settingStore, context, click_handler];
}
class RechargeControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3b, create_fragment$3c, safe_not_equal, { item: 0 });
  }
}
function get_each_context$U(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[2].itemContext[
      /*item*/
      child_ctx[9].id
    ]
  );
  child_ctx[10] = constants_0;
  return child_ctx;
}
function create_default_slot_8$h(ctx) {
  let t_value = (
    /*localize*/
    ctx[6](
      /*section*/
      ctx[1].label ?? "DND5E.Features"
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[6](
        /*section*/
        ctx2[1].label ?? "DND5E.Features"
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7$k(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Uses") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_6$l(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Usage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_5$q(ctx) {
  let itemtablecolumn0;
  let t0;
  let itemtablecolumn1;
  let t1;
  let itemtablecolumn2;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_8$h] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_7$k] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn2 = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_6$l] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t1 = space();
      create_component(itemtablecolumn2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope, section*/
      16386) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
      const itemtablecolumn2_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        itemtablecolumn2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn2.$set(itemtablecolumn2_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(itemtablecolumn2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(itemtablecolumn2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
      destroy_component(itemtablecolumn2, detaching);
    }
  };
}
function create_header_slot$j(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_5$q] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, section*/
      16386) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_default_slot_4$v(ctx) {
  let span;
  let t_value = (
    /*item*/
    ctx[9].name + ""
  );
  let t2;
  let span_data_tidy_item_name_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*item*/
      ctx[9].name);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      1 && t_value !== (t_value = /*item*/
      ctx2[9].name + "")) set_data(t2, t_value);
      if (dirty & /*items*/
      1 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*item*/
      ctx2[9].name)) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_3$A(ctx) {
  let itemusebutton;
  let t2;
  let itemname;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[2].editable,
      item: (
        /*item*/
        ctx[9]
      )
    }
  });
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[7](
        /*toggleSummary*/
        ctx[13]
      )
    );
  }
  itemname = new ItemName({
    props: {
      hasChildren: false,
      item: (
        /*item*/
        ctx[9]
      ),
      $$slots: { default: [create_default_slot_4$v] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t2 = space();
      create_component(itemname.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemname, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty & /*$context*/
      4) itemusebutton_changes.disabled = !/*$context*/
      ctx[2].editable;
      if (dirty & /*items*/
      1) itemusebutton_changes.item = /*item*/
      ctx[9];
      itemusebutton.$set(itemusebutton_changes);
      const itemname_changes = {};
      if (dirty & /*items*/
      1) itemname_changes.item = /*item*/
      ctx[9];
      if (dirty & /*$$scope, items*/
      16385) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(itemname.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(itemname.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemusebutton, detaching);
      destroy_component(itemname, detaching);
    }
  };
}
function create_else_block$T(ctx) {
  let itemadduses;
  let current;
  itemadduses = new ItemAddUses({ props: { item: (
    /*item*/
    ctx[9]
  ) } });
  return {
    c() {
      create_component(itemadduses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemadduses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemadduses_changes = {};
      if (dirty & /*items*/
      1) itemadduses_changes.item = /*item*/
      ctx2[9];
      itemadduses.$set(itemadduses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemadduses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemadduses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemadduses, detaching);
    }
  };
}
function create_if_block_3$A(ctx) {
  let itemuses;
  let current;
  itemuses = new ItemUses({ props: { item: (
    /*item*/
    ctx[9]
  ) } });
  return {
    c() {
      create_component(itemuses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemuses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemuses_changes = {};
      if (dirty & /*items*/
      1) itemuses_changes.item = /*item*/
      ctx2[9];
      itemuses.$set(itemuses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemuses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemuses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemuses, detaching);
    }
  };
}
function create_if_block_2$K(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-bolt");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[6]("DND5E.Charged")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_1$W(ctx) {
  let rechargecontrol;
  let current;
  rechargecontrol = new RechargeControl({ props: { item: (
    /*item*/
    ctx[9]
  ) } });
  return {
    c() {
      create_component(rechargecontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rechargecontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rechargecontrol_changes = {};
      if (dirty & /*items*/
      1) rechargecontrol_changes.item = /*item*/
      ctx2[9];
      rechargecontrol.$set(rechargecontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rechargecontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rechargecontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rechargecontrol, detaching);
    }
  };
}
function create_default_slot_2$B(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$W, create_if_block_2$K, create_if_block_3$A, create_else_block$T];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*item*/
      ctx2[9].isOnCooldown
    ) return 0;
    if (
      /*item*/
      ctx2[9].system.recharge?.value
    ) return 1;
    if (
      /*ctx*/
      ctx2[10]?.hasUses
    ) return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block$1t(ctx) {
  let t_value = (
    /*item*/
    (ctx[9].labels?.activation ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*items*/
      1 && t_value !== (t_value = /*item*/
      (ctx2[9].labels?.activation ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$L(ctx) {
  let if_block_anchor;
  let if_block = (
    /*item*/
    ctx[9].system.activation?.type && create_if_block$1t(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[9].system.activation?.type
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1t(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$1l(ctx) {
  let itemtablecell0;
  let t0;
  let itemtablecell1;
  let t1;
  let itemtablecell2;
  let t2;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_3$A] },
      $$scope: { ctx }
    }
  });
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_2$B] },
      $$scope: { ctx }
    }
  });
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_1$L] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      create_component(itemtablecell1.$$.fragment);
      t1 = space();
      create_component(itemtablecell2.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*$$scope, items, toggleSummary, $context*/
      24581) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      const itemtablecell1_changes = {};
      if (dirty & /*$$scope, items, $context*/
      16389) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      const itemtablecell2_changes = {};
      if (dirty & /*$$scope, items*/
      16385) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(itemtablecell2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(itemtablecell2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(itemtablecell0, detaching);
      destroy_component(itemtablecell1, detaching);
      destroy_component(itemtablecell2, detaching);
    }
  };
}
function create_each_block$U(key_1, ctx) {
  let first;
  let itemtablerow;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[8](
        /*item*/
        ctx[9],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      item: (
        /*item*/
        ctx[9]
      ),
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[9].uuid
        )
      },
      hidden: !!/*$itemIdsToShow*/
      ctx[3] && !/*$itemIdsToShow*/
      ctx[3].has(
        /*item*/
        ctx[9].id
      ),
      favoriteId: (
        /*ctx*/
        ctx[10].favoriteId
      ),
      $$slots: {
        default: [
          create_default_slot$1l,
          ({ toggleSummary }) => ({ 13: toggleSummary }),
          ({ toggleSummary }) => toggleSummary ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*items*/
      1) itemtablerow_changes.item = /*item*/
      ctx[9];
      if (dirty & /*items*/
      1) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[9].uuid
        )
      };
      if (dirty & /*$itemIdsToShow, items*/
      9) itemtablerow_changes.hidden = !!/*$itemIdsToShow*/
      ctx[3] && !/*$itemIdsToShow*/
      ctx[3].has(
        /*item*/
        ctx[9].id
      );
      if (dirty & /*$context, items*/
      5) itemtablerow_changes.favoriteId = /*ctx*/
      ctx[10].favoriteId;
      if (dirty & /*$$scope, items, $context, toggleSummary*/
      24581) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_body_slot$i(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[9].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$U(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$U(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*items, $itemIdsToShow, $context, localize, toggleSummary*/
      8269) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$U, each_1_anchor, get_each_context$U);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_fragment$3b(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[1].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[1].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$i],
        header: [create_header_slot$j]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*section*/
      2) itemtable_changes.key = /*section*/
      ctx2[1].key;
      if (dirty & /*section*/
      2) itemtable_changes["data-custom-section"] = /*section*/
      ctx2[1].custom ? true : null;
      if (dirty & /*$$scope, items, $itemIdsToShow, $context, section*/
      16399) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function instance$3a($$self, $$props, $$invalidate) {
  let $context;
  let $itemIdsToShow;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let { items = [] } = $$props;
  let { section } = $$props;
  let itemIdsToShow = getContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(3, $itemIdsToShow = value));
  const localize = FoundryAdapter.localize;
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (item, event) => FoundryAdapter.editOnMiddleClick(event.detail, item);
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2) $$invalidate(0, items = $$props2.items);
    if ("section" in $$props2) $$invalidate(1, section = $$props2.section);
  };
  return [
    items,
    section,
    $context,
    $itemIdsToShow,
    context,
    itemIdsToShow,
    localize,
    toggle_handler,
    mousedown_handler
  ];
}
class FavoriteFeaturesList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3a, create_fragment$3b, safe_not_equal, { items: 0, section: 1 });
  }
}
function get_each_context$T(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  return child_ctx;
}
function create_each_block$T(ctx) {
  let span;
  let t_value = (
    /*component*/
    ctx[2].abbr + ""
  );
  let t2;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "spell-component svelte-vhpebl");
      attr(span, "title", span_title_value = /*spellAbbreviationMap*/
      ctx[1].get(
        /*component*/
        ctx[2].abbr
      ));
      toggle_class(
        span,
        "spell-tag",
        /*component*/
        ctx[2].tag
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*spell*/
      1 && t_value !== (t_value = /*component*/
      ctx2[2].abbr + "")) set_data(t2, t_value);
      if (dirty & /*spell*/
      1 && span_title_value !== (span_title_value = /*spellAbbreviationMap*/
      ctx2[1].get(
        /*component*/
        ctx2[2].abbr
      ))) {
        attr(span, "title", span_title_value);
      }
      if (dirty & /*spell*/
      1) {
        toggle_class(
          span,
          "spell-tag",
          /*component*/
          ctx2[2].tag
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$3a(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*spell*/
    ctx[0].labels.components.all
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$T(get_each_context$T(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*spellAbbreviationMap, spell*/
      3) {
        each_value = ensure_array_like(
          /*spell*/
          ctx2[0].labels.components.all
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$T(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$T(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$39($$self, $$props, $$invalidate) {
  let { spell } = $$props;
  const spellAbbreviationMap = FoundryAdapter.getSpellAbbreviationMap();
  $$self.$$set = ($$props2) => {
    if ("spell" in $$props2) $$invalidate(0, spell = $$props2.spell);
  };
  return [spell, spellAbbreviationMap];
}
class SpellComponents extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$39, create_fragment$3a, safe_not_equal, { spell: 0 });
  }
}
function create_fragment$39(ctx) {
  let button;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "type", "button");
      attr(button, "class", "pip svelte-837hq8");
      button.disabled = /*disabled*/
      ctx[2];
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[6].useAccessibleKeyboardSupport ? 0 : -1);
      toggle_class(
        button,
        "empty",
        /*isEmpty*/
        ctx[0]
      );
      toggle_class(
        button,
        "change",
        /*willChange*/
        ctx[1]
      );
      toggle_class(
        button,
        "animate-expended",
        /*animateExpended*/
        ctx[4]
      );
      toggle_class(
        button,
        "animate-restored",
        /*animateRestored*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      ctx[12](button);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[7]
          ),
          listen(
            button,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[8]
          ),
          listen(
            button,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[9]
          ),
          listen(
            button,
            "focusin",
            /*focusin_handler*/
            ctx[10]
          ),
          listen(
            button,
            "focusout",
            /*focusout_handler*/
            ctx[11]
          ),
          listen(
            button,
            "transitionend",
            /*transitionend_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*disabled*/
      4) {
        button.disabled = /*disabled*/
        ctx2[2];
      }
      if (dirty & /*$settingStore*/
      64 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[6].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*isEmpty*/
      1) {
        toggle_class(
          button,
          "empty",
          /*isEmpty*/
          ctx2[0]
        );
      }
      if (dirty & /*willChange*/
      2) {
        toggle_class(
          button,
          "change",
          /*willChange*/
          ctx2[1]
        );
      }
      if (dirty & /*animateExpended*/
      16) {
        toggle_class(
          button,
          "animate-expended",
          /*animateExpended*/
          ctx2[4]
        );
      }
      if (dirty & /*animateRestored*/
      32) {
        toggle_class(
          button,
          "animate-restored",
          /*animateRestored*/
          ctx2[5]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$38($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(6, $settingStore = $$value));
  let { isEmpty } = $$props;
  let { willChange } = $$props;
  let { disabled } = $$props;
  let pipEl;
  let animateExpended = false;
  let animateRestored = false;
  let animatePips = false;
  onMount(() => {
    animatePips = true;
  });
  function handlePipAnimation(isEmpty2) {
    if (
      // Don't animate when the pip is still initializing
      !animatePips || // Don't animate when the pip is not visible, as it will cause the pip to animate every time it becomes visible, until toggle manually
      // Note: offsetParent === null when the pip is hidden because of an ancestor being hidden (e.g., the tab isn't selected)
      !pipEl.offsetParent
    ) {
      return;
    }
    $$invalidate(4, animateExpended = isEmpty2);
    $$invalidate(5, animateRestored = !isEmpty2);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusin_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pipEl = $$value;
      $$invalidate(3, pipEl);
    });
  }
  const transitionend_handler = () => {
    $$invalidate(4, animateExpended = false);
    $$invalidate(5, animateRestored = false);
  };
  $$self.$$set = ($$props2) => {
    if ("isEmpty" in $$props2) $$invalidate(0, isEmpty = $$props2.isEmpty);
    if ("willChange" in $$props2) $$invalidate(1, willChange = $$props2.willChange);
    if ("disabled" in $$props2) $$invalidate(2, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isEmpty*/
    1) {
      {
        handlePipAnimation(isEmpty);
      }
    }
  };
  return [
    isEmpty,
    willChange,
    disabled,
    pipEl,
    animateExpended,
    animateRestored,
    $settingStore,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    focusin_handler,
    focusout_handler,
    button_binding,
    transitionend_handler
  ];
}
class SpellPip extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$38, create_fragment$39, safe_not_equal, { isEmpty: 0, willChange: 1, disabled: 2 });
  }
}
function get_each_context$S(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function create_if_block$1s(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*pips*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$S(get_each_context$S(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "spell-slot-markers svelte-17cz2vr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*pips, onSpellMarkerClick, section, onMouseEnterDot, onMouseLeaveDot*/
      59) {
        each_value = ensure_array_like(
          /*pips*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$S(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$S(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$S(ctx) {
  let spellpip;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[6](
        /*pip*/
        ctx[16]
      )
    );
  }
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[7](
        /*pip*/
        ctx[16]
      )
    );
  }
  function mouseleave_handler() {
    return (
      /*mouseleave_handler*/
      ctx[8](
        /*pip*/
        ctx[16]
      )
    );
  }
  function focusin_handler() {
    return (
      /*focusin_handler*/
      ctx[9](
        /*pip*/
        ctx[16]
      )
    );
  }
  function focusout_handler() {
    return (
      /*focusout_handler*/
      ctx[10](
        /*pip*/
        ctx[16]
      )
    );
  }
  spellpip = new SpellPip({
    props: {
      disabled: (
        /*pip*/
        ctx[16].disabled
      ),
      isEmpty: (
        /*pip*/
        ctx[16].isEmpty
      ),
      willChange: (
        /*pip*/
        ctx[16].willChange
      )
    }
  });
  spellpip.$on("click", click_handler);
  spellpip.$on("mouseenter", mouseenter_handler);
  spellpip.$on("mouseleave", mouseleave_handler);
  spellpip.$on("focusin", focusin_handler);
  spellpip.$on("focusout", focusout_handler);
  return {
    c() {
      create_component(spellpip.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellpip, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const spellpip_changes = {};
      if (dirty & /*pips*/
      2) spellpip_changes.disabled = /*pip*/
      ctx[16].disabled;
      if (dirty & /*pips*/
      2) spellpip_changes.isEmpty = /*pip*/
      ctx[16].isEmpty;
      if (dirty & /*pips*/
      2) spellpip_changes.willChange = /*pip*/
      ctx[16].willChange;
      spellpip.$set(spellpip_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellpip.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellpip.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellpip, detaching);
    }
  };
}
function create_fragment$38(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    (ctx[0].slots ?? 0) > 0 && create_if_block$1s(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*section*/
        (ctx2[0].slots ?? 0) > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*section*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1s(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance$37($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(12, $context = value));
  let { section } = $$props;
  let targetedDotIndex = null;
  function onSpellMarkerClick(section2, markerIndex) {
    let isEmpty2 = markerIndex >= (section2.uses ?? 0);
    let value = isEmpty2 ? markerIndex + 1 : markerIndex;
    $context.actor.update({
      [`system.spells.${section2.prop}.value`]: value
    });
  }
  function isEmpty(index) {
    return index >= (section.uses ?? 0);
  }
  function willChange(index) {
    if (targetedDotIndex === null) {
      return false;
    }
    return isEmpty(index) && index <= targetedDotIndex || !isEmpty(index) && index >= targetedDotIndex;
  }
  function onMouseEnterDot(index) {
    targetedDotIndex = index;
    $$invalidate(1, pips = generatePips());
  }
  function onMouseLeaveDot(index) {
    targetedDotIndex = null;
    $$invalidate(1, pips = generatePips());
  }
  function generatePips() {
    return Array.from({ length: section.slots ?? 0 }, (x2, i2) => ({
      index: i2,
      isEmpty: isEmpty(i2),
      willChange: willChange(i2),
      disabled: !$context.editable
    }));
  }
  let pips;
  const click_handler = (pip) => onSpellMarkerClick(section, pip.index);
  const mouseenter_handler = (pip) => onMouseEnterDot(pip.index);
  const mouseleave_handler = (pip) => onMouseLeaveDot(pip.index);
  const focusin_handler = (pip) => onMouseEnterDot(pip.index);
  const focusout_handler = (pip) => onMouseLeaveDot(pip.index);
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*section*/
    1) {
      $$invalidate(1, pips = generatePips());
    }
  };
  return [
    section,
    pips,
    context,
    onSpellMarkerClick,
    onMouseEnterDot,
    onMouseLeaveDot,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    focusin_handler,
    focusout_handler
  ];
}
class SpellPips extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$37, create_fragment$38, safe_not_equal, { section: 0 });
  }
}
function create_fragment$37(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-pencil");
      attr(button, "type", "button");
      attr(button, "class", "spell-slot-config inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[3]("DND5E.SpellSlotsConfig")
      );
      attr(
        button,
        "aria-label",
        /*localize*/
        ctx[3]("DND5E.SpellSlotsConfig")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$36($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = () => FoundryAdapter.openSpellSlotsConfig($context.actor);
  return [$context, $settingStore, context, localize, click_handler];
}
class SpellSlotConfigButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$36, create_fragment$37, safe_not_equal, {});
  }
}
function create_fragment$36(ctx) {
  let div;
  let textinput;
  let t0;
  let span0;
  let t2;
  let span1;
  let t3_value = (
    /*section*/
    ctx[0].slots + ""
  );
  let t3;
  let span1_data_level_value;
  let span1_data_slots_value;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[1].actor
      ),
      field: "system.spells." + /*section*/
      ctx[0].prop + ".value",
      cssClass: "spell-slot-uses",
      value: (
        /*section*/
        ctx[0].uses
      ),
      placeholder: "0",
      selectOnFocus: true,
      allowDeltaChanges: true,
      disabled: !/*$context*/
      ctx[1].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      span0 = element("span");
      span0.textContent = "/";
      t2 = space();
      span1 = element("span");
      t3 = text(t3_value);
      attr(span0, "class", "sep");
      attr(span1, "class", "spell-max svelte-1y8yhny");
      attr(span1, "data-level", span1_data_level_value = /*section*/
      ctx[0].prop);
      attr(span1, "data-slots", span1_data_slots_value = /*section*/
      ctx[0].slots);
      attr(div, "class", "spell-slots-detail svelte-1y8yhny");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      append(div, t0);
      append(div, span0);
      append(div, t2);
      append(div, span1);
      append(span1, t3);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].actor;
      if (dirty & /*section*/
      1) textinput_changes.field = "system.spells." + /*section*/
      ctx2[0].prop + ".value";
      if (dirty & /*section*/
      1) textinput_changes.value = /*section*/
      ctx2[0].uses;
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      textinput.$set(textinput_changes);
      if ((!current || dirty & /*section*/
      1) && t3_value !== (t3_value = /*section*/
      ctx2[0].slots + "")) set_data(t3, t3_value);
      if (!current || dirty & /*section*/
      1 && span1_data_level_value !== (span1_data_level_value = /*section*/
      ctx2[0].prop)) {
        attr(span1, "data-level", span1_data_level_value);
      }
      if (!current || dirty & /*section*/
      1 && span1_data_slots_value !== (span1_data_slots_value = /*section*/
      ctx2[0].slots)) {
        attr(span1, "data-slots", span1_data_slots_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput);
    }
  };
}
function instance$35($$self, $$props, $$invalidate) {
  let $context;
  let { section } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
  };
  return [section, $context, context];
}
class SpellSlotUses extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$35, create_fragment$36, safe_not_equal, { section: 0 });
  }
}
function create_if_block_2$J(ctx) {
  let spellpips;
  let current;
  spellpips = new SpellPips({ props: { section: (
    /*section*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(spellpips.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellpips, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellpips_changes = {};
      if (dirty & /*section*/
      1) spellpips_changes.section = /*section*/
      ctx2[0];
      spellpips.$set(spellpips_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellpips.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellpips.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellpips, detaching);
    }
  };
}
function create_if_block_1$V(ctx) {
  let spellslotuses;
  let current;
  spellslotuses = new SpellSlotUses({ props: { section: (
    /*section*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(spellslotuses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellslotuses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellslotuses_changes = {};
      if (dirty & /*section*/
      1) spellslotuses_changes.section = /*section*/
      ctx2[0];
      spellslotuses.$set(spellslotuses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellslotuses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellslotuses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellslotuses, detaching);
    }
  };
}
function create_if_block$1r(ctx) {
  let spellslotconfigbutton;
  let current;
  spellslotconfigbutton = new SpellSlotConfigButton({});
  return {
    c() {
      create_component(spellslotconfigbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellslotconfigbutton, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(spellslotconfigbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellslotconfigbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellslotconfigbutton, detaching);
    }
  };
}
function create_fragment$35(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*$context*/
    ctx[1].spellSlotTrackerMode === CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS && create_if_block_2$J(ctx)
  );
  let if_block1 = (
    /*$context*/
    ctx[1].spellSlotTrackerMode === CONSTANTS.SPELL_SLOT_TRACKER_MODE_VALUE_MAX && create_if_block_1$V(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[1].unlocked && create_if_block$1r()
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      attr(div, "class", "flex-row extra-small-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if (if_block1) if_block1.m(div, null);
      append(div, t1);
      if (if_block2) if_block2.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$context*/
        ctx2[1].spellSlotTrackerMode === CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$J(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[1].spellSlotTrackerMode === CONSTANTS.SPELL_SLOT_TRACKER_MODE_VALUE_MAX
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$V(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[1].unlocked
      ) {
        if (if_block2) {
          if (dirty & /*$context*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1r();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
    }
  };
}
function instance$34($$self, $$props, $$invalidate) {
  let $context;
  let { section } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
  };
  return [section, $context, context];
}
class SpellSlotManagement extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$34, create_fragment$35, safe_not_equal, { section: 0 });
  }
}
function create_if_block$1q(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "concentration-overlay fas fa-arrow-rotate-left fa-spin fa-spin-reverse svelte-1pg3q3k");
      attr(
        i2,
        "aria-label",
        /*localize*/
        ctx[1]("DND5E.Concentration")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_fragment$34(ctx) {
  let if_block_anchor;
  let if_block = (
    /*ctx*/
    ctx[0].concentration && create_if_block$1q(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*ctx*/
        ctx2[0].concentration
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1q(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance$33($$self, $$props, $$invalidate) {
  let { ctx } = $$props;
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("ctx" in $$props2) $$invalidate(0, ctx = $$props2.ctx);
  };
  return [ctx, localize];
}
class ConcentrationOverlayIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$33, create_fragment$34, safe_not_equal, { ctx: 0 });
  }
}
function get_each_context$R(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[2].itemContext[
      /*spell*/
      child_ctx[9].id
    ]
  );
  child_ctx[10] = constants_0;
  const constants_1 = FoundryAdapter.getSpellImageUrl(
    /*$context*/
    child_ctx[2],
    /*spell*/
    child_ctx[9]
  );
  child_ctx[11] = constants_1;
  return child_ctx;
}
function create_else_block$S(ctx) {
  let span;
  let t_value = (
    /*localize*/
    ctx[6](
      /*section*/
      ctx[0].label
    ) + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "spell-primary-column-label svelte-xf2hju");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*localize*/
      ctx2[6](
        /*section*/
        ctx2[0].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2$I(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("TIDY5E.FavoriteSpellLevelLabel", { number: (
      /*section*/
      ctx[0].dataset.level
    ) }) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*localize*/
      ctx2[6]("TIDY5E.FavoriteSpellLevelLabel", { number: (
        /*section*/
        ctx2[0].dataset.level
      ) }) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$U(ctx) {
  let spellslotmanagement;
  let current;
  spellslotmanagement = new SpellSlotManagement({ props: { section: (
    /*section*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(spellslotmanagement.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellslotmanagement, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellslotmanagement_changes = {};
      if (dirty & /*section*/
      1) spellslotmanagement_changes.section = /*section*/
      ctx2[0];
      spellslotmanagement.$set(spellslotmanagement_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellslotmanagement.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellslotmanagement.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellslotmanagement, detaching);
    }
  };
}
function create_default_slot_9$f(ctx) {
  let t2;
  let if_block1_anchor;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*section*/
      ctx2[0].dataset["preparation.mode"] === CONSTANTS.SPELL_PREPARATION_MODE_PREPARED && /*section*/
      ctx2[0].dataset.level > 0
    ) return create_if_block_2$I;
    return create_else_block$S;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*section*/
    ctx[0].usesSlots && create_if_block_1$U(ctx)
  );
  return {
    c() {
      if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      }
      if (
        /*section*/
        ctx2[0].usesSlots
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*section*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$U(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block1_anchor);
      }
      if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_default_slot_8$g(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-mortar-pestle");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot_7$j(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Usage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_6$k(ctx) {
  let itemtablecolumn0;
  let t0;
  let itemtablecolumn1;
  let t1;
  let itemtablecolumn2;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_9$f] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: "4.375rem",
      title: (
        /*localize*/
        ctx[6]("DND5E.SpellComponents")
      ),
      $$slots: { default: [create_default_slot_8$g] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn2 = new ItemTableColumn({
    props: {
      title: (
        /*localize*/
        ctx[6]("DND5E.SpellUsage")
      ),
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_7$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t1 = space();
      create_component(itemtablecolumn2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope, section*/
      32769) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
      const itemtablecolumn2_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        itemtablecolumn2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn2.$set(itemtablecolumn2_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(itemtablecolumn2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(itemtablecolumn2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
      destroy_component(itemtablecolumn2, detaching);
    }
  };
}
function create_header_slot$i(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_6$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, section*/
      32769) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_after_roll_button_slot$1(ctx) {
  let concentrationoverlayicon;
  let current;
  concentrationoverlayicon = new ConcentrationOverlayIcon({ props: { ctx: (
    /*ctx*/
    ctx[10]
  ) } });
  return {
    c() {
      create_component(concentrationoverlayicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(concentrationoverlayicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const concentrationoverlayicon_changes = {};
      if (dirty & /*$context, spells*/
      6) concentrationoverlayicon_changes.ctx = /*ctx*/
      ctx2[10];
      concentrationoverlayicon.$set(concentrationoverlayicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(concentrationoverlayicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(concentrationoverlayicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(concentrationoverlayicon, detaching);
    }
  };
}
function create_default_slot_5$p(ctx) {
  let span;
  let t_value = (
    /*spell*/
    ctx[9].name + ""
  );
  let t2;
  let span_data_tidy_item_name_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "truncate");
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*spell*/
      ctx[9].name);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*spells*/
      2 && t_value !== (t_value = /*spell*/
      ctx2[9].name + "")) set_data(t2, t_value);
      if (dirty & /*spells*/
      2 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*spell*/
      ctx2[9].name)) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_4$u(ctx) {
  let itemusebutton;
  let t2;
  let itemname;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[2].editable,
      item: (
        /*spell*/
        ctx[9]
      ),
      imgUrlOverride: (
        /*spellImgUrl*/
        ctx[11]
      ),
      $$slots: {
        "after-roll-button": [create_after_roll_button_slot$1]
      },
      $$scope: { ctx }
    }
  });
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[7](
        /*toggleSummary*/
        ctx[14]
      )
    );
  }
  itemname = new ItemName({
    props: {
      item: (
        /*spell*/
        ctx[9]
      ),
      $$slots: { default: [create_default_slot_5$p] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t2 = space();
      create_component(itemname.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemname, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty & /*$context*/
      4) itemusebutton_changes.disabled = !/*$context*/
      ctx[2].editable;
      if (dirty & /*spells*/
      2) itemusebutton_changes.item = /*spell*/
      ctx[9];
      if (dirty & /*$context, spells*/
      6) itemusebutton_changes.imgUrlOverride = /*spellImgUrl*/
      ctx[11];
      if (dirty & /*$$scope, $context, spells*/
      32774) {
        itemusebutton_changes.$$scope = { dirty, ctx };
      }
      itemusebutton.$set(itemusebutton_changes);
      const itemname_changes = {};
      if (dirty & /*spells*/
      2) itemname_changes.item = /*spell*/
      ctx[9];
      if (dirty & /*$$scope, spells*/
      32770) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(itemname.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(itemname.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemusebutton, detaching);
      destroy_component(itemname, detaching);
    }
  };
}
function create_if_block$1p(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_3$z] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, spells*/
      32770) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_3$z(ctx) {
  let itemuses;
  let current;
  itemuses = new ItemUses({ props: { item: (
    /*spell*/
    ctx[9]
  ) } });
  return {
    c() {
      create_component(itemuses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemuses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemuses_changes = {};
      if (dirty & /*spells*/
      2) itemuses_changes.item = /*spell*/
      ctx2[9];
      itemuses.$set(itemuses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemuses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemuses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemuses, detaching);
    }
  };
}
function create_default_slot_2$A(ctx) {
  let spellcomponents;
  let current;
  spellcomponents = new SpellComponents({ props: { spell: (
    /*spell*/
    ctx[9]
  ) } });
  return {
    c() {
      create_component(spellcomponents.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellcomponents, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellcomponents_changes = {};
      if (dirty & /*spells*/
      2) spellcomponents_changes.spell = /*spell*/
      ctx2[9];
      spellcomponents.$set(spellcomponents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellcomponents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellcomponents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellcomponents, detaching);
    }
  };
}
function create_default_slot_1$K(ctx) {
  let t_value = (
    /*spell*/
    ctx[9].labels.activation + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*spells*/
      2 && t_value !== (t_value = /*spell*/
      ctx2[9].labels.activation + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$1k(ctx) {
  let itemtablecell0;
  let t0;
  let t1;
  let itemtablecell1;
  let t2;
  let itemtablecell2;
  let t3;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_4$u] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*spell*/
    ctx[9].system.uses.per && create_if_block$1p(ctx)
  );
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "4.375rem",
      cssClass: "no-gap",
      $$slots: { default: [create_default_slot_2$A] },
      $$scope: { ctx }
    }
  });
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      title: (
        /*localize*/
        ctx[6]("DND5E.SpellUsage")
      ),
      $$slots: { default: [create_default_slot_1$K] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      create_component(itemtablecell1.$$.fragment);
      t2 = space();
      create_component(itemtablecell2.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*$$scope, spells, toggleSummary, $context*/
      49158) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      if (
        /*spell*/
        ctx2[9].system.uses.per
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*spells*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1p(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const itemtablecell1_changes = {};
      if (dirty & /*$$scope, spells*/
      32770) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      const itemtablecell2_changes = {};
      if (dirty & /*$$scope, spells*/
      32770) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(if_block);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(itemtablecell2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(if_block);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(itemtablecell2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
      }
      destroy_component(itemtablecell0, detaching);
      if (if_block) if_block.d(detaching);
      destroy_component(itemtablecell1, detaching);
      destroy_component(itemtablecell2, detaching);
    }
  };
}
function create_each_block$R(ctx) {
  let itemtablerow;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[8](
        /*spell*/
        ctx[9],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      item: (
        /*spell*/
        ctx[9]
      ),
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*spell*/
          ctx[9].uuid
        )
      },
      cssClass: FoundryAdapter.getSpellRowClasses(
        /*spell*/
        ctx[9]
      ),
      hidden: !!/*$itemIdsToShow*/
      ctx[3] && !/*$itemIdsToShow*/
      ctx[3].has(
        /*spell*/
        ctx[9].id
      ),
      favoriteId: (
        /*ctx*/
        ctx[10].favoriteId
      ),
      $$slots: {
        default: [
          create_default_slot$1k,
          ({ toggleSummary }) => ({ 14: toggleSummary }),
          ({ toggleSummary }) => toggleSummary ? 16384 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    c() {
      create_component(itemtablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*spells*/
      2) itemtablerow_changes.item = /*spell*/
      ctx[9];
      if (dirty & /*spells*/
      2) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*spell*/
          ctx[9].uuid
        )
      };
      if (dirty & /*spells*/
      2) itemtablerow_changes.cssClass = FoundryAdapter.getSpellRowClasses(
        /*spell*/
        ctx[9]
      );
      if (dirty & /*$itemIdsToShow, spells*/
      10) itemtablerow_changes.hidden = !!/*$itemIdsToShow*/
      ctx[3] && !/*$itemIdsToShow*/
      ctx[3].has(
        /*spell*/
        ctx[9].id
      );
      if (dirty & /*$context, spells*/
      6) itemtablerow_changes.favoriteId = /*ctx*/
      ctx[10].favoriteId;
      if (dirty & /*$$scope, spells, toggleSummary, $context*/
      49158) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_body_slot$h(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*spells*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$R(get_each_context$R(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*spells, $itemIdsToShow, $context, localize, toggleSummary*/
      16462) {
        each_value = ensure_array_like(
          /*spells*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$R(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$R(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$33(ctx) {
  let section_1;
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[0].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[0].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$h],
        header: [create_header_slot$i]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section_1 = element("section");
      create_component(itemtable.$$.fragment);
      attr(section_1, "class", "spellbook-list-section");
    },
    m(target, anchor) {
      insert(target, section_1, anchor);
      mount_component(itemtable, section_1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*section*/
      1) itemtable_changes.key = /*section*/
      ctx2[0].key;
      if (dirty & /*section*/
      1) itemtable_changes["data-custom-section"] = /*section*/
      ctx2[0].custom ? true : null;
      if (dirty & /*$$scope, spells, $itemIdsToShow, $context, section*/
      32783) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section_1);
      }
      destroy_component(itemtable);
    }
  };
}
function instance$32($$self, $$props, $$invalidate) {
  let $context;
  let $itemIdsToShow;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let { section } = $$props;
  let { spells } = $$props;
  let itemIdsToShow = getContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(3, $itemIdsToShow = value));
  const localize = FoundryAdapter.localize;
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (spell, event) => FoundryAdapter.editOnMiddleClick(event.detail, spell);
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
    if ("spells" in $$props2) $$invalidate(1, spells = $$props2.spells);
  };
  return [
    section,
    spells,
    $context,
    $itemIdsToShow,
    context,
    itemIdsToShow,
    localize,
    toggle_handler,
    mousedown_handler
  ];
}
class FavoriteSpellsList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$32, create_fragment$33, safe_not_equal, { section: 0, spells: 1 });
  }
}
function create_fragment$32(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "item-image svelte-9tozoy");
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[0])) attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*src*/
      1 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[0])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      2) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[1]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function instance$31($$self, $$props, $$invalidate) {
  let { src } = $$props;
  let { alt = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("src" in $$props2) $$invalidate(0, src = $$props2.src);
    if ("alt" in $$props2) $$invalidate(1, alt = $$props2.alt);
  };
  return [src, alt];
}
class ItemImage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$31, create_fragment$32, safe_not_equal, { src: 0, alt: 1 });
  }
}
function create_fragment$31(ctx) {
  let label;
  let t2;
  let button;
  let button_tabindex_value;
  let label_class_value;
  let label_title_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      label = element("label");
      if (default_slot) default_slot.c();
      t2 = space();
      button = element("button");
      attr(button, "type", "button");
      attr(button, "role", "switch");
      attr(
        button,
        "aria-checked",
        /*value*/
        ctx[0]
      );
      attr(
        button,
        "aria-labelledby",
        /*switchLabelId*/
        ctx[3]
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
      button.disabled = /*disabled*/
      ctx[1];
      attr(label, "class", label_class_value = "tidy-switch " + /*$$props*/
      (ctx[5].class ?? ""));
      attr(
        label,
        "id",
        /*switchLabelId*/
        ctx[3]
      );
      attr(label, "title", label_title_value = /*$$props*/
      ctx[5].title ?? null);
      toggle_class(
        label,
        "disabled",
        /*disabled*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      append(label, t2);
      append(label, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*value*/
      1) {
        attr(
          button,
          "aria-checked",
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx2[1];
      }
      if (!current || dirty & /*$$props*/
      32 && label_class_value !== (label_class_value = "tidy-switch " + /*$$props*/
      (ctx2[5].class ?? ""))) {
        attr(label, "class", label_class_value);
      }
      if (!current || dirty & /*$$props*/
      32 && label_title_value !== (label_title_value = /*$$props*/
      ctx2[5].title ?? null)) {
        attr(label, "title", label_title_value);
      }
      if (!current || dirty & /*$$props, disabled*/
      34) {
        toggle_class(
          label,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$30($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { value = false } = $$props;
  let { disabled = false } = $$props;
  const switchLabelId = `switch-${Math.random()}-label`;
  const dispatcher = createEventDispatcher();
  function handleClick(_) {
    const originalValue = value;
    $$invalidate(0, value = !value);
    dispatcher("change", { originalValue });
  }
  const click_handler = (ev) => handleClick();
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    disabled,
    $settingStore,
    switchLabelId,
    handleClick,
    $$props,
    $$scope,
    slots,
    click_handler
  ];
}
class TidySwitch extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$30, create_fragment$31, safe_not_equal, { value: 0, disabled: 1 });
  }
}
function get_each_context$Q(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_default_slot_7$i(ctx) {
  let t_value = (
    /*localize*/
    ctx[2](
      /*section*/
      ctx[0].label ?? "DND5E.Effect"
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*localize*/
      ctx2[2](
        /*section*/
        ctx2[0].label ?? "DND5E.Effect"
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_4$t(ctx) {
  let itemtablecolumn0;
  let t0;
  let itemtablecolumn1;
  let t1;
  let itemtablecolumn2;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_7$i] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: { baseWidth: subtitleColumnWidth }
  });
  itemtablecolumn2 = new ItemTableColumn({
    props: { baseWidth: controlsColumnWidth }
  });
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t1 = space();
      create_component(itemtablecolumn2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope, section*/
      513) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(itemtablecolumn2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(itemtablecolumn2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
      destroy_component(itemtablecolumn2, detaching);
    }
  };
}
function create_header_slot$h(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_4$t] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, section*/
      513) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_default_slot_3$y(ctx) {
  let itemimage;
  let t0;
  let span;
  let t1_value = (
    /*effectContext*/
    ctx[6].effect.name + ""
  );
  let t1;
  let span_data_tidy_effect_name_value;
  let current;
  itemimage = new ItemImage({
    props: { src: (
      /*effectContext*/
      ctx[6].img
    ) }
  });
  return {
    c() {
      create_component(itemimage.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(span, "class", "align-self-center truncate");
      attr(span, "data-tidy-effect-name", span_data_tidy_effect_name_value = /*effectContext*/
      ctx[6].effect.name);
    },
    m(target, anchor) {
      mount_component(itemimage, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const itemimage_changes = {};
      if (dirty & /*section*/
      1) itemimage_changes.src = /*effectContext*/
      ctx2[6].img;
      itemimage.$set(itemimage_changes);
      if ((!current || dirty & /*section*/
      1) && t1_value !== (t1_value = /*effectContext*/
      ctx2[6].effect.name + "")) set_data(t1, t1_value);
      if (!current || dirty & /*section*/
      1 && span_data_tidy_effect_name_value !== (span_data_tidy_effect_name_value = /*effectContext*/
      ctx2[6].effect.name)) {
        attr(span, "data-tidy-effect-name", span_data_tidy_effect_name_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemimage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemimage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      destroy_component(itemimage, detaching);
    }
  };
}
function create_default_slot_2$z(ctx) {
  let t_value = (
    /*effectContext*/
    (ctx[6].subtitle ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*effectContext*/
      (ctx2[6].subtitle ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$J(ctx) {
  let tidyswitch;
  let current;
  function change_handler() {
    return (
      /*change_handler*/
      ctx[3](
        /*effectContext*/
        ctx[6]
      )
    );
  }
  tidyswitch = new TidySwitch({
    props: {
      disabled: (
        /*effectContext*/
        ctx[6].suppressed
      ),
      value: (
        /*effectContext*/
        ctx[6].toggle.value
      )
    }
  });
  tidyswitch.$on("change", change_handler);
  return {
    c() {
      create_component(tidyswitch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidyswitch, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tidyswitch_changes = {};
      if (dirty & /*section*/
      1) tidyswitch_changes.disabled = /*effectContext*/
      ctx[6].suppressed;
      if (dirty & /*section*/
      1) tidyswitch_changes.value = /*effectContext*/
      ctx[6].toggle.value;
      tidyswitch.$set(tidyswitch_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidyswitch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidyswitch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidyswitch, detaching);
    }
  };
}
function create_default_slot$1j(ctx) {
  let itemtablecell0;
  let t0;
  let itemtablecell1;
  let t1;
  let itemtablecell2;
  let t2;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      attributes: {
        "data-tidy-effect-name-container": true,
        "data-effect-id": (
          /*effectContext*/
          ctx[6].id
        )
      },
      $$slots: { default: [create_default_slot_3$y] },
      $$scope: { ctx }
    }
  });
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: subtitleColumnWidth,
      $$slots: { default: [create_default_slot_2$z] },
      $$scope: { ctx }
    }
  });
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: controlsColumnWidth,
      $$slots: { default: [create_default_slot_1$J] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      create_component(itemtablecell1.$$.fragment);
      t1 = space();
      create_component(itemtablecell2.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*section*/
      1) itemtablecell0_changes.attributes = {
        "data-tidy-effect-name-container": true,
        "data-effect-id": (
          /*effectContext*/
          ctx2[6].id
        )
      };
      if (dirty & /*$$scope, section*/
      513) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      const itemtablecell1_changes = {};
      if (dirty & /*$$scope, section*/
      513) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      const itemtablecell2_changes = {};
      if (dirty & /*$$scope, section*/
      513) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(itemtablecell2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(itemtablecell2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(itemtablecell0, detaching);
      destroy_component(itemtablecell1, detaching);
      destroy_component(itemtablecell2, detaching);
    }
  };
}
function create_each_block$Q(key_1, ctx) {
  let first;
  let itemtablerow;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[4](
        /*effectContext*/
        ctx[6],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      effect: (
        /*effectContext*/
        ctx[6].effect
      ),
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS,
        uuid: (
          /*effectContext*/
          ctx[6].effect.uuid
        )
      },
      hidden: (
        /*visibleEffectIdSubset*/
        ctx[1] !== null && !/*visibleEffectIdSubset*/
        ctx[1].has(
          /*effectContext*/
          ctx[6].effect.id
        )
      ),
      favoriteId: (
        /*effectContext*/
        ctx[6].id
      ),
      cssClass: (
        /*effectContext*/
        ctx[6].suppressed ? "suppressed" : ""
      ),
      $$slots: { default: [create_default_slot$1j] },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*section*/
      1) itemtablerow_changes.effect = /*effectContext*/
      ctx[6].effect;
      if (dirty & /*section*/
      1) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS,
        uuid: (
          /*effectContext*/
          ctx[6].effect.uuid
        )
      };
      if (dirty & /*visibleEffectIdSubset, section*/
      3) itemtablerow_changes.hidden = /*visibleEffectIdSubset*/
      ctx[1] !== null && !/*visibleEffectIdSubset*/
      ctx[1].has(
        /*effectContext*/
        ctx[6].effect.id
      );
      if (dirty & /*section*/
      1) itemtablerow_changes.favoriteId = /*effectContext*/
      ctx[6].id;
      if (dirty & /*section*/
      1) itemtablerow_changes.cssClass = /*effectContext*/
      ctx[6].suppressed ? "suppressed" : "";
      if (dirty & /*$$scope, section*/
      513) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_body_slot$g(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*section*/
    ctx[0].effects
  );
  const get_key = (ctx2) => (
    /*effectContext*/
    ctx2[6].effectId
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$Q(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$Q(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*section, visibleEffectIdSubset, controlsColumnWidth, toggleEffect, subtitleColumnWidth*/
      3) {
        each_value = ensure_array_like(
          /*section*/
          ctx2[0].effects
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$Q, each_1_anchor, get_each_context$Q);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_fragment$30(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[0].key
      ),
      class: "favorite-effects",
      $$slots: {
        body: [create_body_slot$g],
        header: [create_header_slot$h]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*section*/
      1) itemtable_changes.key = /*section*/
      ctx2[0].key;
      if (dirty & /*$$scope, section, visibleEffectIdSubset*/
      515) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
const subtitleColumnWidth = "5rem";
const controlsColumnWidth = "3rem";
function toggleEffect(context2) {
  context2.effect.update({ disabled: !context2.effect.disabled });
}
function instance$2$($$self, $$props, $$invalidate) {
  getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  let { section } = $$props;
  let { visibleEffectIdSubset = null } = $$props;
  const localize = FoundryAdapter.localize;
  const change_handler = (effectContext) => toggleEffect(effectContext);
  const mousedown_handler = (effectContext, event) => FoundryAdapter.editOnMiddleClick(event.detail, effectContext.effect);
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
    if ("visibleEffectIdSubset" in $$props2) $$invalidate(1, visibleEffectIdSubset = $$props2.visibleEffectIdSubset);
  };
  return [section, visibleEffectIdSubset, localize, change_handler, mousedown_handler];
}
class FavoriteEffectsList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2$, create_fragment$30, safe_not_equal, { section: 0, visibleEffectIdSubset: 1 });
  }
}
const defaultItemFilters = {
  activationCostAction: {
    name: "activationCostAction",
    predicate: (item) => item.system.activation?.type === CONSTANTS.ACTIVATION_COST_ACTION,
    text: "DND5E.Action"
  },
  activationCostBonus: {
    name: "activationCostBonus",
    predicate: (item) => item.system.activation?.type === CONSTANTS.ACTIVATION_COST_BONUS,
    text: "DND5E.BonusAction"
  },
  activationCostReaction: {
    name: "activationCostReaction",
    predicate: (item) => item.system.activation?.type === CONSTANTS.ACTIVATION_COST_REACTION,
    text: "DND5E.Reaction"
  },
  activationCostLegendary: {
    name: "activationCostLegendary",
    predicate: (item) => item.system.activation?.type === CONSTANTS.ACTIVATION_COST_LEGENDARY,
    text: "DND5E.LegendaryActionLabel"
  },
  activationCostMythic: {
    name: "activationCostMythic",
    predicate: (item) => item.system.activation?.type === CONSTANTS.ACTIVATION_COST_MYTHIC,
    text: "DND5E.MythicActionLabel"
  },
  activationCostLair: {
    name: "activationCostLair",
    predicate: (item) => item.system.activation?.type === CONSTANTS.ACTIVATION_COST_LAIR,
    text: "DND5E.LairActionLabel"
  },
  activationCostCrew: {
    name: "activationCostCrew",
    predicate: (item) => item.system.activation?.type === CONSTANTS.ACTIVATION_COST_CREW,
    text: "DND5E.VehicleCrewAction"
  },
  activationCostSpecial: {
    name: "activationCostSpecial",
    predicate: (item) => item.system.activation?.type === CONSTANTS.ACTIVATION_COST_SPECIAL,
    text: "DND5E.Special"
  },
  activationCostOther: {
    name: "activationCostOther",
    predicate: (item) => ![
      CONSTANTS.ACTIVATION_COST_ACTION,
      CONSTANTS.ACTIVATION_COST_BONUS,
      CONSTANTS.ACTIVATION_COST_REACTION
    ].includes(item.system.activation?.type),
    text: "TIDY5E.ItemFilters.Filter.Other"
  },
  ritual: {
    name: "ritual",
    predicate: (item) => item.system.properties?.has("ritual") === true,
    text: "DND5E.Ritual"
  },
  concentration: {
    name: "concentration",
    predicate: (item) => item.system.properties?.has("concentration") === true,
    text: "DND5E.Concentration",
    abbreviation: "DND5E.AbbreviationConc"
  },
  verbal: {
    name: "verbal",
    predicate: (item) => item.system.properties?.has("vocal") === true,
    text: "DND5E.ComponentVerbal"
  },
  somatic: {
    name: "somatic",
    predicate: (item) => item.system.properties?.has("somatic") === true,
    text: "DND5E.ComponentSomatic"
  },
  material: {
    name: "material",
    predicate: (item) => item.system.properties?.has("material") === true,
    text: "DND5E.ComponentMaterial"
  },
  prepared: {
    name: "prepared",
    predicate: (item) => {
      const isPreparedCantrip = SpellUtils.isCantrip(item) && SpellUtils.isCantripPrepared(item);
      return isPreparedCantrip || SpellUtils.isAlwaysPrepared(item) || SpellUtils.isInnate(item) || SpellUtils.isPrepared(item);
    },
    text: "DND5E.Prepared"
  },
  canCastSpell: {
    name: "canCastSpell",
    predicate: (item) => {
      return item.type === CONSTANTS.ITEM_TYPE_SPELL && (SpellUtils.isCastableCantrip(item) || SpellUtils.isCastableSpell(item));
    },
    text: "TIDY5E.ItemFilters.CanCast"
  },
  canUse: {
    name: "canUse",
    predicate: (item) => ItemUtils.canUse(item),
    text: "TIDY5E.ItemFilters.CanUse"
  },
  equipped: {
    name: "equipped",
    predicate: (item) => item.system.equipped === true,
    text: "DND5E.Equipped"
  }
};
function getItemRarityFilters() {
  const itemRarity = CONFIG.DND5E.itemRarity;
  return Object.entries(itemRarity).map(
    ([key, text2]) => ({
      name: key,
      predicate: (item) => !FoundryAdapter.concealDetails(item) && item.system.rarity === key,
      text: text2
    })
  );
}
function getItemRarityFiltersAsObject() {
  return getItemRarityFilters().reduce(
    (prev, curr) => {
      prev[curr.name] = curr;
      return prev;
    },
    {}
  );
}
function getSpellSchoolFilters() {
  const spellSchools = CONFIG.DND5E.spellSchools;
  return Object.entries(spellSchools).map(
    ([key, schoolData]) => ({
      name: key,
      predicate: (item) => item.system.school === key,
      text: schoolData.label
    })
  );
}
function getSpellSchoolFiltersAsObject() {
  return getSpellSchoolFilters().reduce(
    (prev, curr) => {
      prev[curr.name] = curr;
      return prev;
    },
    {}
  );
}
function getAttunementFilters() {
  return [
    {
      name: "attunement-optional",
      predicate: (item) => !FoundryAdapter.concealDetails(item) && item.system.attunement === CONSTANTS.ATTUNEMENT_OPTIONAL,
      text: CONFIG.DND5E.attunementTypes[CONSTANTS.ATTUNEMENT_OPTIONAL]
    },
    {
      name: "attunement-required",
      predicate: (item) => !FoundryAdapter.concealDetails(item) && item.system.attunement === CONSTANTS.ATTUNEMENT_REQUIRED,
      text: CONFIG.DND5E.attunementTypes[CONSTANTS.ATTUNEMENT_REQUIRED]
    },
    {
      name: "attuned",
      predicate: (item) => !FoundryAdapter.concealDetails(item) && !!item.system.attunement && item.system.attuned,
      text: "DND5E.AttunementAttuned"
    }
  ];
}
function getAttunementFiltersAsObject() {
  return getAttunementFilters().reduce(
    (prev, curr) => {
      prev[curr.name] = curr;
      return prev;
    },
    {}
  );
}
function getStandardSpellSchoolFilterCategories() {
  return {
    "DND5E.SpellComponents": [
      defaultItemFilters.verbal,
      defaultItemFilters.somatic,
      defaultItemFilters.material,
      defaultItemFilters.concentration,
      defaultItemFilters.ritual
    ],
    "DND5E.SpellPreparationMode": [
      defaultItemFilters.prepared,
      defaultItemFilters.canCastSpell
    ],
    "DND5E.SpellSchool": () => getSpellSchoolFilters()
  };
}
function getActionListFilterCategories() {
  return {
    "DND5E.ItemActivationCost": [
      defaultItemFilters.activationCostAction,
      defaultItemFilters.activationCostBonus,
      defaultItemFilters.activationCostReaction,
      defaultItemFilters.activationCostLegendary,
      defaultItemFilters.activationCostMythic,
      defaultItemFilters.activationCostLair,
      defaultItemFilters.activationCostCrew,
      defaultItemFilters.activationCostSpecial
    ],
    ...getStandardSpellSchoolFilterCategories()
  };
}
class ItemFilterRuntime {
  static _registeredItemFilters = {};
  static init() {
    ItemFilterRuntime._registeredItemFilters = {
      ...defaultItemFilters,
      ...getAttunementFiltersAsObject(),
      ...getItemRarityFiltersAsObject(),
      ...getSpellSchoolFiltersAsObject()
    };
  }
  static defaultFilterPins = {
    [CONSTANTS.SHEET_TYPE_CHARACTER]: {
      [CONSTANTS.TAB_CHARACTER_ATTRIBUTES]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name,
        defaultItemFilters.canUse.name,
        defaultItemFilters.canCastSpell.name
      ]),
      [CONSTANTS.TAB_CHARACTER_INVENTORY]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name,
        defaultItemFilters.equipped.name
      ]),
      [CONSTANTS.TAB_CHARACTER_FEATURES]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name,
        defaultItemFilters.canUse.name
      ]),
      [CONSTANTS.TAB_CHARACTER_SPELLBOOK]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name,
        defaultItemFilters.concentration.name,
        defaultItemFilters.ritual.name,
        defaultItemFilters.canCastSpell.name
      ]),
      [CONSTANTS.TAB_ACTOR_ACTIONS]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name
      ])
    },
    [CONSTANTS.SHEET_TYPE_NPC]: {
      [CONSTANTS.TAB_NPC_ABILITIES]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name
      ]),
      [CONSTANTS.TAB_NPC_SPELLBOOK]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name,
        defaultItemFilters.concentration.name,
        defaultItemFilters.ritual.name,
        defaultItemFilters.canCastSpell.name
      ]),
      [CONSTANTS.TAB_ACTOR_ACTIONS]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name
      ]),
      [CONSTANTS.TAB_NPC_INVENTORY]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name,
        defaultItemFilters.equipped.name
      ])
    },
    [CONSTANTS.SHEET_TYPE_VEHICLE]: {
      [CONSTANTS.TAB_ACTOR_ACTIONS]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name
      ])
    },
    [CONSTANTS.SHEET_TYPE_CONTAINER]: {
      [CONSTANTS.TAB_CONTAINER_CONTENTS]: /* @__PURE__ */ new Set([
        defaultItemFilters.activationCostAction.name,
        defaultItemFilters.activationCostBonus.name,
        defaultItemFilters.activationCostReaction.name,
        defaultItemFilters.equipped.name
      ])
    }
  };
  static _documentTabFilters = {
    [CONSTANTS.SHEET_TYPE_CHARACTER]: {
      [CONSTANTS.TAB_CHARACTER_ATTRIBUTES]: {
        "DND5E.ItemActivationCost": [
          defaultItemFilters.activationCostAction,
          defaultItemFilters.activationCostBonus,
          defaultItemFilters.activationCostReaction,
          defaultItemFilters.activationCostOther
        ],
        "DND5E.SpellComponents": [
          defaultItemFilters.verbal,
          defaultItemFilters.somatic,
          defaultItemFilters.material,
          defaultItemFilters.concentration,
          defaultItemFilters.ritual
        ],
        "DND5E.SpellPreparationMode": [
          defaultItemFilters.prepared,
          defaultItemFilters.canCastSpell
        ],
        "TIDY5E.ItemFilters.Category.Miscellaneous": () => [
          defaultItemFilters.equipped,
          defaultItemFilters.canUse
        ]
      },
      [CONSTANTS.TAB_CHARACTER_INVENTORY]: {
        "DND5E.ItemActivationCost": [
          defaultItemFilters.activationCostAction,
          defaultItemFilters.activationCostBonus,
          defaultItemFilters.activationCostReaction
        ],
        "DND5E.Rarity": () => getItemRarityFilters(),
        "TIDY5E.ItemFilters.Category.Miscellaneous": () => [
          defaultItemFilters.equipped,
          ...getAttunementFilters()
        ]
      },
      [CONSTANTS.TAB_CHARACTER_SPELLBOOK]: {
        "DND5E.ItemActivationCost": [
          defaultItemFilters.activationCostAction,
          defaultItemFilters.activationCostBonus,
          defaultItemFilters.activationCostReaction,
          defaultItemFilters.activationCostOther
        ],
        ...getStandardSpellSchoolFilterCategories()
      },
      [CONSTANTS.TAB_CHARACTER_FEATURES]: {
        "DND5E.ItemActivationCost": [
          defaultItemFilters.activationCostAction,
          defaultItemFilters.activationCostBonus,
          defaultItemFilters.activationCostReaction
        ],
        "TIDY5E.ItemFilters.Category.Miscellaneous": () => [
          defaultItemFilters.canUse
        ]
      },
      [CONSTANTS.TAB_ACTOR_ACTIONS]: { ...getActionListFilterCategories() }
    },
    [CONSTANTS.SHEET_TYPE_NPC]: {
      [CONSTANTS.TAB_NPC_SPELLBOOK]: {
        "DND5E.ItemActivationCost": [
          defaultItemFilters.activationCostAction,
          defaultItemFilters.activationCostBonus,
          defaultItemFilters.activationCostReaction,
          defaultItemFilters.activationCostOther
        ],
        ...getStandardSpellSchoolFilterCategories()
      },
      [CONSTANTS.TAB_NPC_ABILITIES]: {
        // TODO: Upgrade the filter system so that it's easier to dynamically graft in additional filter sets rather than hardcoding them in
        "DND5E.ItemActivationCost": [
          defaultItemFilters.activationCostAction,
          defaultItemFilters.activationCostBonus,
          defaultItemFilters.activationCostReaction,
          defaultItemFilters.activationCostLegendary,
          defaultItemFilters.activationCostMythic,
          defaultItemFilters.activationCostLair,
          defaultItemFilters.activationCostOther
        ],
        ...getStandardSpellSchoolFilterCategories()
      },
      [CONSTANTS.TAB_NPC_INVENTORY]: {
        "DND5E.ItemActivationCost": [
          defaultItemFilters.activationCostAction,
          defaultItemFilters.activationCostBonus,
          defaultItemFilters.activationCostReaction
        ],
        "DND5E.Rarity": () => getItemRarityFilters(),
        "TIDY5E.ItemFilters.Category.Miscellaneous": () => [
          defaultItemFilters.equipped,
          ...getAttunementFilters()
        ]
      },
      [CONSTANTS.TAB_ACTOR_ACTIONS]: { ...getActionListFilterCategories() }
    },
    [CONSTANTS.SHEET_TYPE_VEHICLE]: {
      [CONSTANTS.TAB_ACTOR_ACTIONS]: { ...getActionListFilterCategories() }
    },
    [CONSTANTS.SHEET_TYPE_CONTAINER]: {
      [CONSTANTS.TAB_CONTAINER_CONTENTS]: {
        "DND5E.ItemActivationCost": [
          defaultItemFilters.activationCostAction,
          defaultItemFilters.activationCostBonus,
          defaultItemFilters.activationCostReaction
        ],
        "DND5E.Rarity": () => getItemRarityFilters(),
        "TIDY5E.ItemFilters.Category.Miscellaneous": () => [
          defaultItemFilters.equipped,
          ...getAttunementFilters()
        ]
      }
    }
  };
  static getFilter(filterName) {
    return ItemFilterRuntime._registeredItemFilters[filterName];
  }
  static getDocumentFilters(document2) {
    return ItemFilterRuntime._documentTabFilters[document2.type] ?? {};
  }
  static getPinnedFiltersForTab(filterPins, filterData, tabId) {
    let pinnedFilters = /* @__PURE__ */ new Map();
    try {
      let tabFilterPins = filterPins[tabId] ?? /* @__PURE__ */ new Set();
      for (let categoryFilters of Object.values(filterData[tabId] ?? {})) {
        for (let filter of categoryFilters) {
          if (tabFilterPins.has(filter.name)) {
            pinnedFilters.set(filter.name, filter);
          }
        }
      }
    } catch (e2) {
      error(
        `An error occurred while searching for pinned filters on the ${tabId} tab.`,
        false,
        e2
      );
      debug("Filter pins error troubleshooting info", {
        filterData,
        filterPins,
        tabId
      });
    }
    return Array.from(pinnedFilters.values());
  }
}
class ItemFilterService {
  // Maybe svelte runes will make this easier?
  _filterData;
  _filterDataStore;
  _document;
  get filterData$() {
    return this._filterDataStore;
  }
  // TODO: Have sheets send in what they have in session storage upon construction
  constructor(filterData = {}, document2) {
    this._filterData = filterData;
    this._filterDataStore = writable(this._filterData);
    this._document = document2;
  }
  // TODO: Better yet, have composed store ready to use, and have it update whenever the filters update
  compose(filterGroup) {
    const group = this._getGroup(filterGroup) ?? {};
    const composition = Object.entries(group).map(([filterName, value]) => {
      return {
        filter: ItemFilterRuntime.getFilter(filterName),
        value
      };
    }).filter((f2) => typeof f2.filter?.predicate === "function").reduce(
      (prev, curr) => {
        return (item) => prev(item) && curr.filter?.predicate?.(item) == curr.value;
      },
      (item) => true
    );
    return (item) => {
      try {
        return composition(item);
      } catch (e2) {
        error("An error occurred while filtering an item", false, e2);
        debug("Item filtering error troubleshooting info", {
          item,
          filters: group
        });
      }
      return true;
    };
  }
  onFilter(filterGroup, filterName, value) {
    try {
      let group = this._getGroup(filterGroup);
      if (value === null) {
        delete group[filterName];
        return;
      }
      group[filterName] = value;
    } finally {
      this._notifyOfChange();
    }
  }
  onFilterClearAll(filterGroup) {
    if (!isNil(filterGroup, "")) {
      delete this._filterData[filterGroup];
    } else {
      this._filterData = {};
    }
    this._notifyOfChange();
  }
  _getGroup(filterGroup) {
    let group = this._filterData[filterGroup];
    if (!group) {
      this._filterData[filterGroup] = group = {};
    }
    return group;
  }
  _notifyOfChange() {
    this._filterDataStore.set(this._filterData);
  }
  getDocumentItemFilterData() {
    const documentFilters = ItemFilterRuntime.getDocumentFilters(
      this._document
    );
    const documentItemFilterData = {};
    for (let [tab, categories] of Object.entries(documentFilters)) {
      documentItemFilterData[tab] ??= {};
      for (let [category, filters] of Object.entries(categories)) {
        documentItemFilterData[tab][category] ??= [];
        const effectiveFilters = Array.isArray(filters) ? filters : filters();
        for (let filter of effectiveFilters) {
          try {
            documentItemFilterData[tab][category].push({
              ...filter,
              value: this._filterData[tab]?.[filter.name] ?? null
            });
          } catch (e2) {
            error(
              "An error occurred while setting up document item filter data",
              false,
              e2
            );
            debug("Document item filter data error troubleshooting info", {
              tab,
              category,
              filter,
              effectiveFilters
            });
          }
        }
      }
    }
    return documentItemFilterData;
  }
}
class ItemVisibility {
  static countVisibleItems(items, itemIdsToShow) {
    if (!itemIdsToShow) {
      return items.length;
    }
    return items.reduce(
      (prev, curr) => prev + (itemIdsToShow.has(curr.id) ? 1 : 0),
      0
    );
  }
  static getItemsToShowAtDepth(args) {
    const itemFilterService = getContext(
      "itemFilterService"
    );
    const filter = itemFilterService?.compose(args.tabId) ?? (() => true);
    const items = args.sections.flatMap(
      (x2) => "items" in x2 ? x2.items : "spells" in x2 ? x2.spells : x2.actions.map((y2) => y2.item)
    );
    const results = new Set(
      ItemVisibility.recursivelyFindEligibleItems({
        criteria: args.criteria,
        filter,
        itemContext: args.itemContext,
        items
      })
    );
    debug("Item IDs to show", { results, ...args });
    return results;
  }
  static recursivelyFindEligibleItems(args) {
    let results = [];
    for (let item of args.items) {
      const containerContents = args.itemContext[item.id]?.containerContents;
      let containedItemsToInclude = [];
      if (containerContents) {
        containedItemsToInclude = ItemVisibility.recursivelyFindEligibleItems({
          criteria: args.criteria,
          filter: args.filter,
          itemContext: containerContents.itemContext,
          items: containerContents.contents.flatMap((s2) => s2.items)
        });
        results = results.concat(containedItemsToInclude);
      }
      const includeItem = FoundryAdapter.searchItem(item, args.criteria) && args.filter(item) || !!containedItemsToInclude.length;
      if (includeItem) {
        results.push(item.id);
      }
    }
    return results;
  }
}
function get_each_context$P(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function get_if_ctx$c(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = FoundryAdapter.searchEffects(
    /*searchCriteria*/
    child_ctx[0],
    /*section*/
    child_ctx[8].effects.map((e2) => e2.effect)
  );
  child_ctx[11] = constants_0;
  return child_ctx;
}
function create_if_block$1o(ctx) {
  let t0;
  let t1;
  let t2;
  let if_block3_anchor;
  let current;
  let if_block0 = (
    /*section*/
    ctx[8].type === CONSTANTS.TAB_CHARACTER_INVENTORY && create_if_block_4$q(ctx)
  );
  let if_block1 = (
    /*section*/
    (ctx[8].type === CONSTANTS.TAB_CHARACTER_FEATURES || /*section*/
    ctx[8].type === CONSTANTS.CHARACTER_FAVORITE_SECTION_GENERIC) && create_if_block_3$z(ctx)
  );
  let if_block2 = (
    /*section*/
    ctx[8].type === CONSTANTS.TAB_CHARACTER_SPELLBOOK && create_if_block_2$H(ctx)
  );
  let if_block3 = (
    /*section*/
    ctx[8].type === CONSTANTS.TAB_CHARACTER_EFFECTS && create_if_block_1$T(get_if_ctx$c(ctx))
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      if (if_block3) if_block3.c();
      if_block3_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*section*/
        ctx2[8].type === CONSTANTS.TAB_CHARACTER_INVENTORY
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*favorites*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$q(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[8].type === CONSTANTS.TAB_CHARACTER_FEATURES || /*section*/
        ctx2[8].type === CONSTANTS.CHARACTER_FAVORITE_SECTION_GENERIC
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*favorites*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$z(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[8].type === CONSTANTS.TAB_CHARACTER_SPELLBOOK
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*favorites*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$H(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[8].type === CONSTANTS.TAB_CHARACTER_EFFECTS
      ) {
        if (if_block3) {
          if_block3.p(get_if_ctx$c(ctx2), dirty);
          if (dirty & /*favorites*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$T(get_if_ctx$c(ctx2));
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block3_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
    }
  };
}
function create_if_block_4$q(ctx) {
  let inventorylist;
  let current;
  inventorylist = new InventoryList({
    props: {
      section: (
        /*section*/
        ctx[8]
      ),
      items: (
        /*section*/
        ctx[8].items
      ),
      primaryColumnName: (
        /*localize*/
        ctx[4](
          /*section*/
          ctx[8].label
        )
      ),
      lockControls: true,
      allowFavoriteIconNextToName: false,
      includeWeightColumn: false
    }
  });
  return {
    c() {
      create_component(inventorylist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inventorylist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inventorylist_changes = {};
      if (dirty & /*favorites*/
      2) inventorylist_changes.section = /*section*/
      ctx2[8];
      if (dirty & /*favorites*/
      2) inventorylist_changes.items = /*section*/
      ctx2[8].items;
      if (dirty & /*favorites*/
      2) inventorylist_changes.primaryColumnName = /*localize*/
      ctx2[4](
        /*section*/
        ctx2[8].label
      );
      inventorylist.$set(inventorylist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inventorylist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inventorylist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inventorylist, detaching);
    }
  };
}
function create_if_block_3$z(ctx) {
  let favoritefeatureslist;
  let current;
  favoritefeatureslist = new FavoriteFeaturesList({
    props: {
      section: (
        /*section*/
        ctx[8]
      ),
      items: (
        /*section*/
        ctx[8].items
      )
    }
  });
  return {
    c() {
      create_component(favoritefeatureslist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(favoritefeatureslist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const favoritefeatureslist_changes = {};
      if (dirty & /*favorites*/
      2) favoritefeatureslist_changes.section = /*section*/
      ctx2[8];
      if (dirty & /*favorites*/
      2) favoritefeatureslist_changes.items = /*section*/
      ctx2[8].items;
      favoritefeatureslist.$set(favoritefeatureslist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(favoritefeatureslist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(favoritefeatureslist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(favoritefeatureslist, detaching);
    }
  };
}
function create_if_block_2$H(ctx) {
  let favoritespellslist;
  let current;
  favoritespellslist = new FavoriteSpellsList({
    props: {
      section: (
        /*section*/
        ctx[8]
      ),
      spells: (
        /*section*/
        ctx[8].spells
      )
    }
  });
  return {
    c() {
      create_component(favoritespellslist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(favoritespellslist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const favoritespellslist_changes = {};
      if (dirty & /*favorites*/
      2) favoritespellslist_changes.section = /*section*/
      ctx2[8];
      if (dirty & /*favorites*/
      2) favoritespellslist_changes.spells = /*section*/
      ctx2[8].spells;
      favoritespellslist.$set(favoritespellslist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(favoritespellslist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(favoritespellslist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(favoritespellslist, detaching);
    }
  };
}
function create_if_block_1$T(ctx) {
  let favoriteeffectslist;
  let current;
  favoriteeffectslist = new FavoriteEffectsList({
    props: {
      section: (
        /*section*/
        ctx[8]
      ),
      visibleEffectIdSubset: (
        /*visibleEffectIdSubset*/
        ctx[11]
      )
    }
  });
  return {
    c() {
      create_component(favoriteeffectslist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(favoriteeffectslist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const favoriteeffectslist_changes = {};
      if (dirty & /*favorites*/
      2) favoriteeffectslist_changes.section = /*section*/
      ctx2[8];
      if (dirty & /*searchCriteria, favorites*/
      3) favoriteeffectslist_changes.visibleEffectIdSubset = /*visibleEffectIdSubset*/
      ctx2[11];
      favoriteeffectslist.$set(favoriteeffectslist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(favoriteeffectslist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(favoriteeffectslist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(favoriteeffectslist, detaching);
    }
  };
}
function create_each_block$P(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[8].show && create_if_block$1o(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*section*/
        ctx2[8].show
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*favorites*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1o(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$2$(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*favorites*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$P(get_each_context$P(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "flex-column small-gap");
      attr(div, "data-tidy-favorites", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*favorites, searchCriteria, localize*/
      19) {
        each_value = ensure_array_like(
          /*favorites*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$P(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$P(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2_($$self, $$props, $$invalidate) {
  let favorites;
  let $context;
  let $itemIdsToShow;
  let { searchCriteria = "" } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(5, $context = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  const itemIdsToShow = writable(void 0);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(6, $itemIdsToShow = value));
  setContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW, itemIdsToShow);
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("searchCriteria" in $$props2) $$invalidate(0, searchCriteria = $$props2.searchCriteria);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    32) {
      $$invalidate(1, favorites = SheetSections.configureFavorites($context.favorites, $context.actor, tabId, SheetPreferencesService.getByType($context.actor.type), TidyFlags.sectionConfig.get($context.actor)?.[tabId]));
    }
    if ($$self.$$.dirty & /*favorites, searchCriteria, $context*/
    35) {
      {
        const sections = favorites.filter((x2) => x2.type !== CONSTANTS.TAB_CHARACTER_EFFECTS);
        set_store_value(
          itemIdsToShow,
          $itemIdsToShow = ItemVisibility.getItemsToShowAtDepth({
            criteria: searchCriteria,
            itemContext: $context.itemContext,
            sections,
            tabId
          }),
          $itemIdsToShow
        );
      }
    }
  };
  return [searchCriteria, favorites, context, itemIdsToShow, localize, $context];
}
class Favorites extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2_, create_fragment$2$, safe_not_equal, { searchCriteria: 0 });
  }
}
function create_if_block$1n(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button resource-options svelte-1bmdrvx");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1);
      toggle_class(
        button,
        "active",
        /*configActive*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      16 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[4].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*configActive*/
      2) {
        toggle_class(
          button,
          "active",
          /*configActive*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2_(ctx) {
  let li;
  let h40;
  let textinput0;
  let t0;
  let div0;
  let textinput1;
  let t1;
  let span;
  let t3;
  let textinput2;
  let t4;
  let header;
  let div1;
  let h41;
  let t6;
  let input0;
  let input0_id_value;
  let input0_checked_value;
  let input0_disabled_value;
  let input0_data_tidy_field_value;
  let t7;
  let label0;
  let t8_value = (
    /*localize*/
    ctx[6]("DND5E.RestS") + ""
  );
  let t8;
  let label0_for_value;
  let t9;
  let input1;
  let input1_id_value;
  let input1_checked_value;
  let input1_disabled_value;
  let input1_data_tidy_field_value;
  let t10;
  let label1;
  let t11_value = (
    /*localize*/
    ctx[6]("DND5E.RestL") + ""
  );
  let t11;
  let label1_for_value;
  let t12;
  let li_class_value;
  let current;
  let mounted;
  let dispose;
  textinput0 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[3].actor
      ),
      field: (
        /*resource*/
        ctx[0].labelName
      ),
      value: (
        /*resource*/
        ctx[0].label
      ),
      placeholder: (
        /*resource*/
        ctx[0].placeholder
      ),
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockSensitiveFields
    }
  });
  textinput1 = new TextInput$1({
    props: {
      cssClass: "resource-value",
      document: (
        /*$context*/
        ctx[3].actor
      ),
      field: (
        /*resource*/
        ctx[0].valueName
      ),
      value: (
        /*resource*/
        ctx[0].value ?? null
      ),
      placeholder: "0",
      allowDeltaChanges: true,
      maxlength: 3,
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[3].editable
    }
  });
  textinput2 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[3].actor
      ),
      field: (
        /*resource*/
        ctx[0].maxName
      ),
      cssClass: "resource-max",
      value: (
        /*resource*/
        ctx[0].max ?? null
      ),
      placeholder: "0",
      allowDeltaChanges: true,
      maxlength: 3,
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockSensitiveFields
    }
  });
  let if_block = (
    /*$context*/
    ctx[3].editable && !/*$context*/
    ctx[3].lockSensitiveFields && create_if_block$1n(ctx)
  );
  return {
    c() {
      li = element("li");
      h40 = element("h4");
      create_component(textinput0.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(textinput1.$$.fragment);
      t1 = space();
      span = element("span");
      span.textContent = "/";
      t3 = space();
      create_component(textinput2.$$.fragment);
      t4 = space();
      header = element("header");
      div1 = element("div");
      h41 = element("h4");
      h41.textContent = `${/*localize*/
      ctx[6]("TIDY5E.RestoreOnRest")}`;
      t6 = space();
      input0 = element("input");
      t7 = space();
      label0 = element("label");
      t8 = text(t8_value);
      t9 = space();
      input1 = element("input");
      t10 = space();
      label1 = element("label");
      t11 = text(t11_value);
      t12 = space();
      if (if_block) if_block.c();
      attr(h40, "class", "resource-name svelte-1bmdrvx");
      toggle_class(
        h40,
        "hidden",
        /*viewingConfig*/
        ctx[2] || /*configActive*/
        ctx[1]
      );
      attr(span, "class", "sep svelte-1bmdrvx");
      attr(div0, "class", "resource-value multiple svelte-1bmdrvx");
      toggle_class(
        div0,
        "hidden",
        /*viewingConfig*/
        ctx[2] || /*configActive*/
        ctx[1]
      );
      attr(h41, "class", "svelte-1bmdrvx");
      attr(input0, "id", input0_id_value = /*$context*/
      ctx[3].appId + "-" + /*resource*/
      ctx[0].name + "-sr");
      attr(input0, "type", "checkbox");
      input0.checked = input0_checked_value = /*resource*/
      ctx[0].sr;
      input0.disabled = input0_disabled_value = !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockSensitiveFields;
      attr(input0, "data-tidy-field", input0_data_tidy_field_value = /*resource*/
      ctx[0].srName);
      attr(input0, "class", "svelte-1bmdrvx");
      attr(label0, "for", label0_for_value = /*$context*/
      ctx[3].appId + "-" + /*resource*/
      ctx[0].name + "-sr");
      attr(label0, "class", "checkbox svelte-1bmdrvx");
      attr(
        label0,
        "title",
        /*localize*/
        ctx[6]("TIDY5E.ShortRest")
      );
      attr(input1, "id", input1_id_value = /*$context*/
      ctx[3].appId + "-" + /*resource*/
      ctx[0].name + "-lr");
      attr(input1, "type", "checkbox");
      input1.checked = input1_checked_value = /*resource*/
      ctx[0].lr;
      input1.disabled = input1_disabled_value = !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockSensitiveFields;
      attr(input1, "data-tidy-field", input1_data_tidy_field_value = /*resource*/
      ctx[0].lrName);
      attr(input1, "class", "svelte-1bmdrvx");
      attr(label1, "for", label1_for_value = /*$context*/
      ctx[3].appId + "-" + /*resource*/
      ctx[0].name + "-lr");
      attr(label1, "class", "checkbox svelte-1bmdrvx");
      attr(
        label1,
        "title",
        /*localize*/
        ctx[6]("TIDY5E.LongRest")
      );
      attr(div1, "class", "resource-rest svelte-1bmdrvx");
      attr(header, "class", "resource-header svelte-1bmdrvx");
      toggle_class(
        header,
        "active",
        /*configActive*/
        ctx[1]
      );
      attr(li, "class", li_class_value = "resource " + /*resource*/
      (ctx[0].cssClasses?.join(" ") ?? "") + " svelte-1bmdrvx");
      attr(li, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.RESOURCE);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, h40);
      mount_component(textinput0, h40, null);
      append(li, t0);
      append(li, div0);
      mount_component(textinput1, div0, null);
      append(div0, t1);
      append(div0, span);
      append(div0, t3);
      mount_component(textinput2, div0, null);
      append(li, t4);
      append(li, header);
      append(header, div1);
      append(div1, h41);
      append(div1, t6);
      append(div1, input0);
      append(div1, t7);
      append(div1, label0);
      append(label0, t8);
      append(div1, t9);
      append(div1, input1);
      append(div1, t10);
      append(div1, label1);
      append(label1, t11);
      append(header, t12);
      if (if_block) if_block.m(header, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "change", stop_propagation(prevent_default(
            /*change_handler*/
            ctx[7]
          ))),
          listen(input1, "change", stop_propagation(prevent_default(
            /*change_handler_1*/
            ctx[8]
          ))),
          listen(
            header,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[10]
          ),
          listen(
            header,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const textinput0_changes = {};
      if (dirty & /*$context*/
      8) textinput0_changes.document = /*$context*/
      ctx2[3].actor;
      if (dirty & /*resource*/
      1) textinput0_changes.field = /*resource*/
      ctx2[0].labelName;
      if (dirty & /*resource*/
      1) textinput0_changes.value = /*resource*/
      ctx2[0].label;
      if (dirty & /*resource*/
      1) textinput0_changes.placeholder = /*resource*/
      ctx2[0].placeholder;
      if (dirty & /*$context*/
      8) textinput0_changes.disabled = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockSensitiveFields;
      textinput0.$set(textinput0_changes);
      if (!current || dirty & /*viewingConfig, configActive*/
      6) {
        toggle_class(
          h40,
          "hidden",
          /*viewingConfig*/
          ctx2[2] || /*configActive*/
          ctx2[1]
        );
      }
      const textinput1_changes = {};
      if (dirty & /*$context*/
      8) textinput1_changes.document = /*$context*/
      ctx2[3].actor;
      if (dirty & /*resource*/
      1) textinput1_changes.field = /*resource*/
      ctx2[0].valueName;
      if (dirty & /*resource*/
      1) textinput1_changes.value = /*resource*/
      ctx2[0].value ?? null;
      if (dirty & /*$context*/
      8) textinput1_changes.disabled = !/*$context*/
      ctx2[3].editable;
      textinput1.$set(textinput1_changes);
      const textinput2_changes = {};
      if (dirty & /*$context*/
      8) textinput2_changes.document = /*$context*/
      ctx2[3].actor;
      if (dirty & /*resource*/
      1) textinput2_changes.field = /*resource*/
      ctx2[0].maxName;
      if (dirty & /*resource*/
      1) textinput2_changes.value = /*resource*/
      ctx2[0].max ?? null;
      if (dirty & /*$context*/
      8) textinput2_changes.disabled = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockSensitiveFields;
      textinput2.$set(textinput2_changes);
      if (!current || dirty & /*viewingConfig, configActive*/
      6) {
        toggle_class(
          div0,
          "hidden",
          /*viewingConfig*/
          ctx2[2] || /*configActive*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$context, resource*/
      9 && input0_id_value !== (input0_id_value = /*$context*/
      ctx2[3].appId + "-" + /*resource*/
      ctx2[0].name + "-sr")) {
        attr(input0, "id", input0_id_value);
      }
      if (!current || dirty & /*resource*/
      1 && input0_checked_value !== (input0_checked_value = /*resource*/
      ctx2[0].sr)) {
        input0.checked = input0_checked_value;
      }
      if (!current || dirty & /*$context*/
      8 && input0_disabled_value !== (input0_disabled_value = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockSensitiveFields)) {
        input0.disabled = input0_disabled_value;
      }
      if (!current || dirty & /*resource*/
      1 && input0_data_tidy_field_value !== (input0_data_tidy_field_value = /*resource*/
      ctx2[0].srName)) {
        attr(input0, "data-tidy-field", input0_data_tidy_field_value);
      }
      if (!current || dirty & /*$context, resource*/
      9 && label0_for_value !== (label0_for_value = /*$context*/
      ctx2[3].appId + "-" + /*resource*/
      ctx2[0].name + "-sr")) {
        attr(label0, "for", label0_for_value);
      }
      if (!current || dirty & /*$context, resource*/
      9 && input1_id_value !== (input1_id_value = /*$context*/
      ctx2[3].appId + "-" + /*resource*/
      ctx2[0].name + "-lr")) {
        attr(input1, "id", input1_id_value);
      }
      if (!current || dirty & /*resource*/
      1 && input1_checked_value !== (input1_checked_value = /*resource*/
      ctx2[0].lr)) {
        input1.checked = input1_checked_value;
      }
      if (!current || dirty & /*$context*/
      8 && input1_disabled_value !== (input1_disabled_value = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockSensitiveFields)) {
        input1.disabled = input1_disabled_value;
      }
      if (!current || dirty & /*resource*/
      1 && input1_data_tidy_field_value !== (input1_data_tidy_field_value = /*resource*/
      ctx2[0].lrName)) {
        attr(input1, "data-tidy-field", input1_data_tidy_field_value);
      }
      if (!current || dirty & /*$context, resource*/
      9 && label1_for_value !== (label1_for_value = /*$context*/
      ctx2[3].appId + "-" + /*resource*/
      ctx2[0].name + "-lr")) {
        attr(label1, "for", label1_for_value);
      }
      if (
        /*$context*/
        ctx2[3].editable && !/*$context*/
        ctx2[3].lockSensitiveFields
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1n(ctx2);
          if_block.c();
          if_block.m(header, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*configActive*/
      2) {
        toggle_class(
          header,
          "active",
          /*configActive*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*resource*/
      1 && li_class_value !== (li_class_value = "resource " + /*resource*/
      (ctx2[0].cssClasses?.join(" ") ?? "") + " svelte-1bmdrvx")) {
        attr(li, "class", li_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(textinput0.$$.fragment, local);
      transition_in(textinput1.$$.fragment, local);
      transition_in(textinput2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput0.$$.fragment, local);
      transition_out(textinput1.$$.fragment, local);
      transition_out(textinput2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(textinput0);
      destroy_component(textinput1);
      destroy_component(textinput2);
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2Z($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(4, $settingStore = $$value));
  let { resource } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  const localize = FoundryAdapter.localize;
  let configActive = false;
  let viewingConfig = false;
  const change_handler = (event) => $context.actor.update({
    [resource.srName]: event.currentTarget.checked
  });
  const change_handler_1 = (event) => $context.actor.update({
    [resource.lrName]: event.currentTarget.checked
  });
  const click_handler = () => {
    $$invalidate(1, configActive = !configActive);
  };
  const mouseenter_handler = () => $$invalidate(2, viewingConfig = true);
  const mouseleave_handler = () => $$invalidate(2, viewingConfig = false);
  $$self.$$set = ($$props2) => {
    if ("resource" in $$props2) $$invalidate(0, resource = $$props2.resource);
  };
  return [
    resource,
    configActive,
    viewingConfig,
    $context,
    $settingStore,
    context,
    localize,
    change_handler,
    change_handler_1,
    click_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
class Resource extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Z, create_fragment$2_, safe_not_equal, { resource: 0 });
  }
}
function get_each_context$O(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  return child_ctx;
}
function create_each_block$O(ctx) {
  let resource_1;
  let current;
  resource_1 = new Resource({ props: { resource: (
    /*resource*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(resource_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(resource_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const resource_1_changes = {};
      if (dirty & /*$context*/
      1) resource_1_changes.resource = /*resource*/
      ctx2[2];
      resource_1.$set(resource_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(resource_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resource_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(resource_1, detaching);
    }
  };
}
function create_fragment$2Z(ctx) {
  let ul;
  let current;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[0].tidyResources
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$O(get_each_context$O(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "resources svelte-1swh5wo");
      attr(ul, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.RESOURCES_CONTAINER);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      1) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[0].tidyResources
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$O(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$O(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(ul, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2Y($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  return [$context, context];
}
class Resources extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Y, create_fragment$2Z, safe_not_equal, {});
  }
}
function create_fragment$2Y(ctx) {
  let section;
  let section_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      section = element("section");
      if (default_slot) default_slot.c();
      attr(section, "class", section_class_value = "utility-toolbar " + /*$$props*/
      (ctx[0].class ?? "") + " svelte-k742dh");
      attr(section, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.UTILITY_TOOLBAR);
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (default_slot) {
        default_slot.m(section, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$$props*/
      1 && section_class_value !== (section_class_value = "utility-toolbar " + /*$$props*/
      (ctx2[0].class ?? "") + " svelte-k742dh")) {
        attr(section, "class", section_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$2X($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [$$props, $$scope, slots];
}
class UtilityToolbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2X, create_fragment$2Y, safe_not_equal, {});
  }
}
function create_if_block_1$S(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(
        i2,
        "class",
        /*iconClass*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconClass*/
      2) {
        attr(
          i2,
          "class",
          /*iconClass*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block$1m(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*text*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      4) set_data(
        t2,
        /*text*/
        ctx2[2]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$2X(ctx) {
  let button;
  let show_if_1 = !isNil(
    /*iconClass*/
    ctx[1],
    ""
  );
  let t2;
  let show_if = !isNil(
    /*text*/
    ctx[2],
    ""
  );
  let button_tabindex_value;
  let mounted;
  let dispose;
  let if_block0 = show_if_1 && create_if_block_1$S(ctx);
  let if_block1 = show_if && create_if_block$1m(ctx);
  return {
    c() {
      button = element("button");
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button");
      attr(
        button,
        "title",
        /*title*/
        ctx[0]
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.UTILITY_TOOLBAR_COMMAND);
      toggle_class(button, "hidden", !/*visible*/
      ctx[3]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block0) if_block0.m(button, null);
      append(button, t2);
      if (if_block1) if_block1.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*iconClass*/
      2) show_if_1 = !isNil(
        /*iconClass*/
        ctx2[1],
        ""
      );
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$S(ctx2);
          if_block0.c();
          if_block0.m(button, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*text*/
      4) show_if = !isNil(
        /*text*/
        ctx2[2],
        ""
      );
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1m(ctx2);
          if_block1.c();
          if_block1.m(button, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*title*/
      1) {
        attr(
          button,
          "title",
          /*title*/
          ctx2[0]
        );
      }
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*visible*/
      8) {
        toggle_class(button, "hidden", !/*visible*/
        ctx2[3]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$2W($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { title = void 0 } = $$props;
  let { iconClass = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { visible = true } = $$props;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(4, $context = value));
  const dispatcher = createEventDispatcher();
  const click_handler = (ev) => dispatcher("execute", { event: ev, context: $context });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("iconClass" in $$props2) $$invalidate(1, iconClass = $$props2.iconClass);
    if ("text" in $$props2) $$invalidate(2, text2 = $$props2.text);
    if ("visible" in $$props2) $$invalidate(3, visible = $$props2.visible);
  };
  return [
    title,
    iconClass,
    text2,
    visible,
    $context,
    $settingStore,
    context,
    dispatcher,
    click_handler
  ];
}
class UtilityToolbarCommand extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2W, create_fragment$2X, safe_not_equal, {
      title: 0,
      iconClass: 1,
      text: 2,
      visible: 3
    });
  }
}
function create_if_block$1l(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-times");
      attr(button, "class", "inline-icon-button search-close-button svelte-dwke6o");
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SEARCH_CLEAR);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2W(ctx) {
  let div;
  let input;
  let t2;
  let show_if = (
    /*value*/
    ctx[0]?.trim() !== ""
  );
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block$1l(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t2 = space();
      if (if_block) if_block.c();
      attr(input, "class", "search svelte-dwke6o");
      attr(input, "type", "text");
      attr(
        input,
        "title",
        /*localize*/
        ctx[4]("TIDY5E.SearchHint")
      );
      attr(
        input,
        "placeholder",
        /*localize*/
        ctx[4]("TIDY5E.Search")
      );
      attr(input, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SEARCH_INPUT);
      attr(div, "class", "search-container svelte-dwke6o");
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SEARCH_CONTAINER);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append(div, t2);
      if (if_block) if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[5]
          ),
          listen(input, "blur", stop_propagation(prevent_default(
            /*blur_handler*/
            ctx[6]
          )))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (dirty & /*value*/
      1) show_if = /*value*/
      ctx2[0]?.trim() !== "";
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1l(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2V($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let { value } = $$props;
  async function rememberSearch() {
    onSearch?.(location, value);
  }
  async function clearSearch() {
    $$invalidate(0, value = "");
    rememberSearch();
  }
  const searchFilters = getContext(CONSTANTS.SVELTE_CONTEXT.SEARCH_FILTERS);
  const onSearch = getContext(CONSTANTS.SVELTE_CONTEXT.ON_SEARCH);
  const location = getContext(CONSTANTS.SVELTE_CONTEXT.LOCATION);
  const localize = FoundryAdapter.localize;
  onMount(() => {
    $$invalidate(0, value = searchFilters?.get(location) ?? "");
  });
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const blur_handler = () => rememberSearch();
  const click_handler = () => clearSearch();
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
  };
  return [
    value,
    $settingStore,
    rememberSearch,
    clearSearch,
    localize,
    input_input_handler,
    blur_handler,
    click_handler
  ];
}
class Search extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2V, create_fragment$2W, safe_not_equal, { value: 0 });
  }
}
const filterCycle = [null, true, false];
function cycleNullTrueFalseForward(currentValue) {
  const currentValueIndex = filterCycle.indexOf(currentValue);
  return filterCycle[(currentValueIndex + 1) % filterCycle.length];
}
function cycleNullTrueFalseBackward(currentValue) {
  const currentValueIndex = filterCycle.indexOf(currentValue);
  return filterCycle.at(currentValueIndex - 1) ?? null;
}
function create_fragment$2V(ctx) {
  let button;
  let button_tabindex_value;
  let button_title_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot) default_slot.c();
      attr(button, "type", "button");
      attr(button, "class", "pinned-filter-toggle truncate");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "title", button_title_value = /*localize*/
      ctx[4](
        /*filter*/
        ctx[0].text
      ));
      toggle_class(
        button,
        "include",
        /*filter*/
        ctx[0].value === true
      );
      toggle_class(
        button,
        "exclude",
        /*filter*/
        ctx[0].value === false
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*filter*/
      1 && button_title_value !== (button_title_value = /*localize*/
      ctx2[4](
        /*filter*/
        ctx2[0].text
      ))) {
        attr(button, "title", button_title_value);
      }
      if (!current || dirty & /*filter*/
      1) {
        toggle_class(
          button,
          "include",
          /*filter*/
          ctx2[0].value === true
        );
      }
      if (!current || dirty & /*filter*/
      1) {
        toggle_class(
          button,
          "exclude",
          /*filter*/
          ctx2[0].value === false
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2U($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { filter } = $$props;
  let { filterGroupName } = $$props;
  const onFilter = getContext("onFilter");
  function cycleFilterForward(name, currentValue) {
    onFilter(filterGroupName, name, cycleNullTrueFalseForward(currentValue));
  }
  function cycleFilterBackward(name, currentValue) {
    onFilter(filterGroupName, name, cycleNullTrueFalseBackward(currentValue));
  }
  const localize = FoundryAdapter.localize;
  const click_handler = () => cycleFilterForward(filter.name, filter.value);
  const contextmenu_handler = () => cycleFilterBackward(filter.name, filter.value);
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2) $$invalidate(0, filter = $$props2.filter);
    if ("filterGroupName" in $$props2) $$invalidate(5, filterGroupName = $$props2.filterGroupName);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    filter,
    $settingStore,
    cycleFilterForward,
    cycleFilterBackward,
    localize,
    filterGroupName,
    $$scope,
    slots,
    click_handler,
    contextmenu_handler
  ];
}
class PinnedFilterToggle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2U, create_fragment$2V, safe_not_equal, { filter: 0, filterGroupName: 5 });
  }
}
function get_each_context$N(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_if_block$1k(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*filters*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*filter*/
    ctx2[3].name
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$N(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$N(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "role", "presentation");
      attr(div, "class", "pinned-filter-toggles");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*filterGroupName, filters, localize*/
      7) {
        each_value = ensure_array_like(
          /*filters*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$N, null, get_each_context$N);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_default_slot$1i(ctx) {
  let t0_value = (
    /*localize*/
    ctx[2](
      /*filter*/
      ctx[3].abbreviation ?? /*filter*/
      ctx[3].text
    ) + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*filters*/
      1 && t0_value !== (t0_value = /*localize*/
      ctx2[2](
        /*filter*/
        ctx2[3].abbreviation ?? /*filter*/
        ctx2[3].text
      ) + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block$N(key_1, ctx) {
  let first;
  let pinnedfiltertoggle;
  let current;
  pinnedfiltertoggle = new PinnedFilterToggle({
    props: {
      filterGroupName: (
        /*filterGroupName*/
        ctx[1]
      ),
      filter: (
        /*filter*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot$1i] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(pinnedfiltertoggle.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(pinnedfiltertoggle, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const pinnedfiltertoggle_changes = {};
      if (dirty & /*filterGroupName*/
      2) pinnedfiltertoggle_changes.filterGroupName = /*filterGroupName*/
      ctx[1];
      if (dirty & /*filters*/
      1) pinnedfiltertoggle_changes.filter = /*filter*/
      ctx[3];
      if (dirty & /*$$scope, filters*/
      65) {
        pinnedfiltertoggle_changes.$$scope = { dirty, ctx };
      }
      pinnedfiltertoggle.$set(pinnedfiltertoggle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(pinnedfiltertoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pinnedfiltertoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(pinnedfiltertoggle, detaching);
    }
  };
}
function create_fragment$2U(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*filters*/
    ctx[0].length && create_if_block$1k(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*filters*/
        ctx2[0].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*filters*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1k(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance$2T($$self, $$props, $$invalidate) {
  let { filters } = $$props;
  let { filterGroupName } = $$props;
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("filters" in $$props2) $$invalidate(0, filters = $$props2.filters);
    if ("filterGroupName" in $$props2) $$invalidate(1, filterGroupName = $$props2.filterGroupName);
  };
  return [filters, filterGroupName, localize];
}
class PinnedFilterToggles extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2T, create_fragment$2U, safe_not_equal, { filters: 0, filterGroupName: 1 });
  }
}
function create_fragment$2T(ctx) {
  let button;
  let button_tabindex_value;
  let button_title_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot) default_slot.c();
      attr(button, "type", "button");
      attr(button, "class", "filter-toggle-button pill-button truncate");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "title", button_title_value = /*localize*/
      ctx[4](
        /*filter*/
        ctx[0].text
      ));
      toggle_class(
        button,
        "include",
        /*filter*/
        ctx[0].value === true
      );
      toggle_class(
        button,
        "exclude",
        /*filter*/
        ctx[0].value === false
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*filter*/
      1 && button_title_value !== (button_title_value = /*localize*/
      ctx2[4](
        /*filter*/
        ctx2[0].text
      ))) {
        attr(button, "title", button_title_value);
      }
      if (!current || dirty & /*filter*/
      1) {
        toggle_class(
          button,
          "include",
          /*filter*/
          ctx2[0].value === true
        );
      }
      if (!current || dirty & /*filter*/
      1) {
        toggle_class(
          button,
          "exclude",
          /*filter*/
          ctx2[0].value === false
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2S($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { filter } = $$props;
  let { filterGroupName } = $$props;
  const onFilter = getContext("onFilter");
  function cycleFilterForward(name, currentValue) {
    onFilter(filterGroupName, name, cycleNullTrueFalseForward(currentValue));
  }
  function cycleFilterBackward(name, currentValue) {
    onFilter(filterGroupName, name, cycleNullTrueFalseBackward(currentValue));
  }
  const localize = FoundryAdapter.localize;
  const click_handler = () => cycleFilterForward(filter.name, filter.value);
  const contextmenu_handler = () => cycleFilterBackward(filter.name, filter.value);
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2) $$invalidate(0, filter = $$props2.filter);
    if ("filterGroupName" in $$props2) $$invalidate(5, filterGroupName = $$props2.filterGroupName);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    filter,
    $settingStore,
    cycleFilterForward,
    cycleFilterBackward,
    localize,
    filterGroupName,
    $$scope,
    slots,
    click_handler,
    contextmenu_handler
  ];
}
class FilterToggleButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2S, create_fragment$2T, safe_not_equal, { filter: 0, filterGroupName: 5 });
  }
}
function create_fragment$2S(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      attr(li, "class", "button-menu-divider");
      attr(li, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
class ButtonMenuDivider extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$2S, safe_not_equal, {});
  }
}
function get_each_context$M(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2][0];
  child_ctx[11] = list[i2][1];
  return child_ctx;
}
function get_each_context_1$n(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_default_slot_1$I(ctx) {
  let t_value = (
    /*localize*/
    ctx[4](
      /*filter*/
      ctx[14].text
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*categories*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[4](
        /*filter*/
        ctx2[14].text
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_1$n(key_1, ctx) {
  let first;
  let filtertogglebutton;
  let current;
  filtertogglebutton = new FilterToggleButton({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[0]
      ),
      filter: (
        /*filter*/
        ctx[14]
      ),
      $$slots: { default: [create_default_slot_1$I] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(filtertogglebutton.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(filtertogglebutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const filtertogglebutton_changes = {};
      if (dirty & /*tabId*/
      1) filtertogglebutton_changes.filterGroupName = /*tabId*/
      ctx[0];
      if (dirty & /*categories*/
      2) filtertogglebutton_changes.filter = /*filter*/
      ctx[14];
      if (dirty & /*$$scope, categories*/
      131074) {
        filtertogglebutton_changes.$$scope = { dirty, ctx };
      }
      filtertogglebutton.$set(filtertogglebutton_changes);
    },
    i(local) {
      if (current) return;
      transition_in(filtertogglebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filtertogglebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(filtertogglebutton, detaching);
    }
  };
}
function create_each_block$M(key_1, ctx) {
  let section;
  let h4;
  let t0_value = (
    /*localize*/
    ctx[4](
      /*category*/
      ctx[10]
    ) + ""
  );
  let t0;
  let t1;
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_1 = ensure_array_like(
    /*filters*/
    ctx[11]
  );
  const get_key = (ctx2) => (
    /*filter*/
    ctx2[14].text
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$n(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$n(key, child_ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      section = element("section");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h4, "class", "filter-group-header");
      attr(div, "class", "filters");
      attr(section, "class", "filter-group");
      this.first = section;
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h4);
      append(h4, t0);
      append(section, t1);
      append(section, div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*categories*/
      2) && t0_value !== (t0_value = /*localize*/
      ctx[4](
        /*category*/
        ctx[10]
      ) + "")) set_data(t0, t0_value);
      if (dirty & /*tabId, Object, categories, localize*/
      19) {
        each_value_1 = ensure_array_like(
          /*filters*/
          ctx[11]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1$n, null, get_each_context_1$n);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_default_slot$1h(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let buttonmenudivider;
  let t1;
  let section;
  let button;
  let i2;
  let t2;
  let t3_value = (
    /*localize*/
    ctx[4]("TIDY5E.ItemFilters.ClearAll") + ""
  );
  let t3;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.entries(
    /*categories*/
    ctx[1]
  ));
  const get_key = (ctx2) => (
    /*category*/
    ctx2[10]
  );
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    let child_ctx = get_each_context$M(ctx, each_value, i3);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i3] = create_each_block$M(key, child_ctx));
  }
  buttonmenudivider = new ButtonMenuDivider({});
  return {
    c() {
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t0 = space();
      create_component(buttonmenudivider.$$.fragment);
      t1 = space();
      section = element("section");
      button = element("button");
      i2 = element("i");
      t2 = space();
      t3 = text(t3_value);
      attr(i2, "class", "fas fa-filter-slash");
      attr(button, "type", "button");
      attr(button, "class", "clear-all-button pill-button flex-row extra-small-gap align-items-center");
      attr(section, "class", "filter-footer flex-row justify-content-center");
    },
    m(target, anchor) {
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      mount_component(buttonmenudivider, target, anchor);
      insert(target, t1, anchor);
      insert(target, section, anchor);
      append(section, button);
      append(button, i2);
      append(button, t2);
      append(button, t3);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, categories, tabId, localize*/
      19) {
        each_value = ensure_array_like(Object.entries(
          /*categories*/
          ctx2[1]
        ));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t0.parentNode, outro_and_destroy_block, create_each_block$M, t0, get_each_context$M);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        transition_in(each_blocks[i3]);
      }
      transition_in(buttonmenudivider.$$.fragment, local);
      current = true;
    },
    o(local) {
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        transition_out(each_blocks[i3]);
      }
      transition_out(buttonmenudivider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(section);
      }
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].d(detaching);
      }
      destroy_component(buttonmenudivider, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2R(ctx) {
  let div;
  let buttonmenu;
  let updating_open;
  let current;
  function buttonmenu_open_binding(value) {
    ctx[9](value);
  }
  let buttonmenu_props = {
    iconClass: "fas fa-filter",
    buttonClass: "inline-icon-button filter-menu-button " + /*hasActiveFilters*/
    (ctx[3] ? "has-active-filters" : "") + " " + /*menuOpen*/
    (ctx[2] ? "menu-is-open" : ""),
    position: "bottom",
    anchor: "right",
    title: (
      /*localize*/
      ctx[4]("TIDY5E.ItemFilters.MenuTooltip.Filters")
    ),
    menuElement: "div",
    $$slots: { default: [create_default_slot$1h] },
    $$scope: { ctx }
  };
  if (
    /*menuOpen*/
    ctx[2] !== void 0
  ) {
    buttonmenu_props.open = /*menuOpen*/
    ctx[2];
  }
  buttonmenu = new ButtonMenu({ props: buttonmenu_props });
  binding_callbacks.push(() => bind(buttonmenu, "open", buttonmenu_open_binding));
  return {
    c() {
      div = element("div");
      create_component(buttonmenu.$$.fragment);
      attr(div, "role", "presentation");
      attr(div, "class", "filter-menu");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(buttonmenu, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const buttonmenu_changes = {};
      if (dirty & /*hasActiveFilters, menuOpen*/
      12) buttonmenu_changes.buttonClass = "inline-icon-button filter-menu-button " + /*hasActiveFilters*/
      (ctx2[3] ? "has-active-filters" : "") + " " + /*menuOpen*/
      (ctx2[2] ? "menu-is-open" : "");
      if (dirty & /*$$scope, tabId, menuOpen, categories*/
      131079) {
        buttonmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & /*menuOpen*/
      4) {
        updating_open = true;
        buttonmenu_changes.open = /*menuOpen*/
        ctx2[2];
        add_flush_callback(() => updating_open = false);
      }
      buttonmenu.$set(buttonmenu_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(buttonmenu);
    }
  };
}
function instance$2R($$self, $$props, $$invalidate) {
  let categories;
  let hasActiveFilters;
  let menuOpen;
  let $context;
  let { tabId } = $$props;
  const localize = FoundryAdapter.localize;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(7, $context = value));
  const onFilterClearAll = getContext("onFilterClearAll");
  const click_handler = (ev) => {
    onFilterClearAll(tabId);
    $$invalidate(2, menuOpen = false);
  };
  function buttonmenu_open_binding(value) {
    menuOpen = value;
    $$invalidate(2, menuOpen);
  }
  $$self.$$set = ($$props2) => {
    if ("tabId" in $$props2) $$invalidate(0, tabId = $$props2.tabId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, tabId*/
    129) {
      $$invalidate(1, categories = $context.filterData[tabId] ?? {});
    }
    if ($$self.$$.dirty & /*categories*/
    2) {
      $$invalidate(3, hasActiveFilters = Object.entries(categories).some(([_, filters]) => filters.some((f2) => f2.value !== null)));
    }
  };
  $$invalidate(2, menuOpen = false);
  return [
    tabId,
    categories,
    menuOpen,
    hasActiveFilters,
    localize,
    context,
    onFilterClearAll,
    $context,
    click_handler,
    buttonmenu_open_binding
  ];
}
class FilterMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2R, create_fragment$2R, safe_not_equal, { tabId: 0 });
  }
}
function get_each_context$L(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function create_each_block$L(key_1, ctx) {
  let first;
  let utilitytoolbarcommand;
  let current;
  function execute_handler(...args) {
    return (
      /*execute_handler*/
      ctx[8](
        /*command*/
        ctx[9],
        ...args
      )
    );
  }
  utilitytoolbarcommand = new UtilityToolbarCommand({
    props: {
      title: (
        /*command*/
        ctx[9].title
      ),
      iconClass: (
        /*command*/
        ctx[9].iconClass
      ),
      text: (
        /*command*/
        ctx[9].text
      ),
      visible: (
        /*command*/
        ctx[9].visible ?? true
      )
    }
  });
  utilitytoolbarcommand.$on("execute", execute_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(utilitytoolbarcommand.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(utilitytoolbarcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const utilitytoolbarcommand_changes = {};
      if (dirty & /*utilityBarCommands*/
      4) utilitytoolbarcommand_changes.title = /*command*/
      ctx[9].title;
      if (dirty & /*utilityBarCommands*/
      4) utilitytoolbarcommand_changes.iconClass = /*command*/
      ctx[9].iconClass;
      if (dirty & /*utilityBarCommands*/
      4) utilitytoolbarcommand_changes.text = /*command*/
      ctx[9].text;
      if (dirty & /*utilityBarCommands*/
      4) utilitytoolbarcommand_changes.visible = /*command*/
      ctx[9].visible ?? true;
      utilitytoolbarcommand.$set(utilitytoolbarcommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbarcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbarcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(utilitytoolbarcommand, detaching);
    }
  };
}
function create_default_slot$1g(ctx) {
  let search;
  let updating_value;
  let t0;
  let pinnedfiltertoggles;
  let t1;
  let filtermenu;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  function search_value_binding(value) {
    ctx[7](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[1] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[1];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  pinnedfiltertoggles = new PinnedFilterToggles({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[6]
      ),
      filters: ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx[0].filterPins,
        /*$context*/
        ctx[0].filterData,
        /*tabId*/
        ctx[6]
      )
    }
  });
  filtermenu = new FilterMenu({ props: { tabId: (
    /*tabId*/
    ctx[6]
  ) } });
  let each_value = ensure_array_like(
    /*utilityBarCommands*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[9].title
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$L(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$L(key, child_ctx));
  }
  return {
    c() {
      create_component(search.$$.fragment);
      t0 = space();
      create_component(pinnedfiltertoggles.$$.fragment);
      t1 = space();
      create_component(filtermenu.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      insert(target, t0, anchor);
      mount_component(pinnedfiltertoggles, target, anchor);
      insert(target, t1, anchor);
      mount_component(filtermenu, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_changes = {};
      if (!updating_value && dirty & /*searchCriteria*/
      2) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      const pinnedfiltertoggles_changes = {};
      if (dirty & /*$context*/
      1) pinnedfiltertoggles_changes.filters = ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx2[0].filterPins,
        /*$context*/
        ctx2[0].filterData,
        /*tabId*/
        ctx2[6]
      );
      pinnedfiltertoggles.$set(pinnedfiltertoggles_changes);
      if (dirty & /*utilityBarCommands*/
      4) {
        each_value = ensure_array_like(
          /*utilityBarCommands*/
          ctx2[2]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$L, each_1_anchor, get_each_context$L);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(pinnedfiltertoggles.$$.fragment, local);
      transition_in(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(pinnedfiltertoggles.$$.fragment, local);
      transition_out(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(search, detaching);
      destroy_component(pinnedfiltertoggles, detaching);
      destroy_component(filtermenu, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block_2$G(ctx) {
  let traits;
  let current;
  traits = new Traits({
    props: {
      toggleable: (
        /*$settingStore*/
        ctx[4].toggleEmptyCharacterTraits
      )
    }
  });
  return {
    c() {
      create_component(traits.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traits, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traits_changes = {};
      if (dirty & /*$settingStore*/
      16) traits_changes.toggleable = /*$settingStore*/
      ctx2[4].toggleEmptyCharacterTraits;
      traits.$set(traits_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traits.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traits.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traits, detaching);
    }
  };
}
function create_if_block_1$R(ctx) {
  let resources;
  let current;
  resources = new Resources({});
  return {
    c() {
      create_component(resources.$$.fragment);
    },
    m(target, anchor) {
      mount_component(resources, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(resources.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resources.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(resources, detaching);
    }
  };
}
function create_if_block$1j(ctx) {
  let traits;
  let current;
  traits = new Traits({
    props: {
      toggleable: (
        /*$settingStore*/
        ctx[4].toggleEmptyCharacterTraits
      )
    }
  });
  return {
    c() {
      create_component(traits.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traits, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traits_changes = {};
      if (dirty & /*$settingStore*/
      16) traits_changes.toggleable = /*$settingStore*/
      ctx2[4].toggleEmptyCharacterTraits;
      traits.$set(traits_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traits.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traits.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traits, detaching);
    }
  };
}
function create_fragment$2Q(ctx) {
  let utilitytoolbar;
  let t0;
  let div1;
  let div0;
  let section0;
  let skillslist;
  let t1;
  let t2;
  let section1;
  let t3;
  let t4;
  let favorites;
  let current;
  utilitytoolbar = new UtilityToolbar({
    props: {
      $$slots: { default: [create_default_slot$1g] },
      $$scope: { ctx }
    }
  });
  skillslist = new SkillsList({
    props: {
      actor: (
        /*$context*/
        ctx[0].actor
      ),
      toggleable: (
        /*$settingStore*/
        ctx[4].toggleEmptyCharacterSkills
      ),
      expanded: !!TidyFlags.skillsExpanded.get(
        /*$context*/
        ctx[0].actor
      ),
      toggleField: TidyFlags.skillsExpanded.prop
    }
  });
  let if_block0 = !/*$settingStore*/
  ctx[4].moveTraitsBelowCharacterResources && create_if_block_2$G(ctx);
  let if_block1 = (
    /*showResources*/
    ctx[3] && create_if_block_1$R()
  );
  let if_block2 = (
    /*$settingStore*/
    ctx[4].moveTraitsBelowCharacterResources && create_if_block$1j(ctx)
  );
  favorites = new Favorites({
    props: {
      searchCriteria: (
        /*searchCriteria*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(utilitytoolbar.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      section0 = element("section");
      create_component(skillslist.$$.fragment);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      section1 = element("section");
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      create_component(favorites.$$.fragment);
      attr(section0, "class", "side-panel svelte-1nht630");
      attr(section1, "class", "main-panel svelte-1nht630");
      attr(div0, "class", "attributes-tab-contents svelte-1nht630");
      attr(div1, "class", "scroll-container");
    },
    m(target, anchor) {
      mount_component(utilitytoolbar, target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, section0);
      mount_component(skillslist, section0, null);
      append(section0, t1);
      if (if_block0) if_block0.m(section0, null);
      append(div0, t2);
      append(div0, section1);
      if (if_block1) if_block1.m(section1, null);
      append(section1, t3);
      if (if_block2) if_block2.m(section1, null);
      append(section1, t4);
      mount_component(favorites, section1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const utilitytoolbar_changes = {};
      if (dirty & /*$$scope, utilityBarCommands, $context, searchCriteria*/
      4103) {
        utilitytoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      utilitytoolbar.$set(utilitytoolbar_changes);
      const skillslist_changes = {};
      if (dirty & /*$context*/
      1) skillslist_changes.actor = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$settingStore*/
      16) skillslist_changes.toggleable = /*$settingStore*/
      ctx2[4].toggleEmptyCharacterSkills;
      if (dirty & /*$context*/
      1) skillslist_changes.expanded = !!TidyFlags.skillsExpanded.get(
        /*$context*/
        ctx2[0].actor
      );
      skillslist.$set(skillslist_changes);
      if (!/*$settingStore*/
      ctx2[4].moveTraitsBelowCharacterResources) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$settingStore*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$G(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(section0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showResources*/
        ctx2[3]
      ) {
        if (if_block1) {
          if (dirty & /*showResources*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$R();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section1, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$settingStore*/
        ctx2[4].moveTraitsBelowCharacterResources
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$settingStore*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1j(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(section1, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const favorites_changes = {};
      if (dirty & /*searchCriteria*/
      2) favorites_changes.searchCriteria = /*searchCriteria*/
      ctx2[1];
      favorites.$set(favorites_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbar.$$.fragment, local);
      transition_in(skillslist.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(favorites.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbar.$$.fragment, local);
      transition_out(skillslist.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(favorites.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div1);
      }
      destroy_component(utilitytoolbar, detaching);
      destroy_component(skillslist);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      destroy_component(favorites);
    }
  };
}
function instance$2Q($$self, $$props, $$invalidate) {
  let showResources;
  let utilityBarCommands;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(4, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  let searchCriteria = "";
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(1, searchCriteria);
  }
  const execute_handler = (command, ev) => command.execute?.(ev.detail);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(3, showResources = $context.unlocked || $context.resources.some((x2) => !isNil(x2.value) || !isNil(x2.value, "") || !isNil(x2.max)));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, utilityBarCommands = $context.utilities[tabId]?.utilityToolbarCommands ?? []);
    }
  };
  return [
    $context,
    searchCriteria,
    utilityBarCommands,
    showResources,
    $settingStore,
    context,
    tabId,
    search_value_binding,
    execute_handler
  ];
}
class CharacterAttributesTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Q, create_fragment$2Q, safe_not_equal, {});
  }
}
function create_fragment$2P(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-bookmark icon-fav no-pointer-events svelte-1dblvwn");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[0]("TIDY5E.Favorite")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function instance$2P($$self) {
  const localize = FoundryAdapter.localize;
  return [localize];
}
class GridPaneFavoriteIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2P, create_fragment$2P, safe_not_equal, {});
  }
}
function get_each_context$K(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  return child_ctx;
}
function get_each_context_1$m(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[2].itemContext[
      /*item*/
      child_ctx[25].id
    ]
  );
  child_ctx[26] = constants_0;
  const constants_1 = !!/*$itemIdsToShow*/
  child_ctx[4] && !/*$itemIdsToShow*/
  child_ctx[4].has(
    /*item*/
    child_ctx[25].id
  );
  child_ctx[27] = constants_1;
  return child_ctx;
}
function create_default_slot_1$H(ctx) {
  let span;
  let t0_value = (
    /*localize*/
    ctx[8](
      /*section*/
      ctx[0].label
    ) + ""
  );
  let t0;
  let t1;
  let t2_value = ItemVisibility.countVisibleItems(
    /*items*/
    ctx[1],
    /*$itemIdsToShow*/
    ctx[4]
  ) + "";
  let t2;
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" (");
      t2 = text(t2_value);
      t3 = text(")");
      attr(span, "class", "inventory-primary-column-label svelte-7m90sc");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t0_value !== (t0_value = /*localize*/
      ctx2[8](
        /*section*/
        ctx2[0].label
      ) + "")) set_data(t0, t0_value);
      if (dirty & /*items, $itemIdsToShow*/
      18 && t2_value !== (t2_value = ItemVisibility.countVisibleItems(
        /*items*/
        ctx2[1],
        /*$itemIdsToShow*/
        ctx2[4]
      ) + "")) set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot$1f(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_1$H] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope, items, $itemIdsToShow, section*/
      1073741843) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_header_slot$g(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot$1f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, items, $itemIdsToShow, section*/
      1073741843) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_if_block_5$m(ctx) {
  let i2;
  let i_class_value;
  let i_title_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = "fas fa-sun icon-attuned " + /*ctx*/
      (ctx[26].attunement?.cls ?? "") + " no-pointer-events svelte-7m90sc");
      attr(i2, "title", i_title_value = /*localize*/
      ctx[8](
        /*ctx*/
        ctx[26].attunement?.title ?? ""
      ));
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, items*/
      6 && i_class_value !== (i_class_value = "fas fa-sun icon-attuned " + /*ctx*/
      (ctx2[26].attunement?.cls ?? "") + " no-pointer-events svelte-7m90sc")) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & /*$context, items*/
      6 && i_title_value !== (i_title_value = /*localize*/
      ctx2[8](
        /*ctx*/
        ctx2[26].attunement?.title ?? ""
      ))) {
        attr(i2, "title", i_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_4$p(ctx) {
  let gridpanefavoriteicon;
  let current;
  gridpanefavoriteicon = new GridPaneFavoriteIcon({});
  return {
    c() {
      create_component(gridpanefavoriteicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridpanefavoriteicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(gridpanefavoriteicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridpanefavoriteicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridpanefavoriteicon, detaching);
    }
  };
}
function create_if_block_3$y(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-edit fa-fw svelte-7m90sc");
      attr(button, "type", "button");
      attr(button, "class", "item-control item-edit");
      set_style(button, "display", "none");
      attr(button, "data-action", "itemEdit");
      attr(
        button,
        "title",
        /*localize*/
        ctx[8]("DND5E.ItemEdit")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
    }
  };
}
function create_if_block_2$F(ctx) {
  let i2;
  let t2;
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[25]
      ),
      field: "system.uses.value",
      value: (
        /*item*/
        ctx[25].system.uses?.value
      ),
      placeholder: "0",
      maxlength: 2,
      allowDeltaChanges: true,
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[2].editable
    }
  });
  textinput.$on("click", preventUseItemEvent);
  return {
    c() {
      i2 = element("i");
      t2 = space();
      create_component(textinput.$$.fragment);
      attr(i2, "class", "fas fa-bolt svelte-7m90sc");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t2, anchor);
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*items*/
      2) textinput_changes.document = /*item*/
      ctx2[25];
      if (dirty & /*items*/
      2) textinput_changes.value = /*item*/
      ctx2[25].system.uses?.value;
      if (dirty & /*$context*/
      4) textinput_changes.disabled = !/*$context*/
      ctx2[2].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
        detach(t2);
      }
      destroy_component(textinput, detaching);
    }
  };
}
function create_each_block_1$m(key_1, ctx) {
  let button;
  let div2;
  let div0;
  let i0;
  let t0;
  let div1;
  let t1;
  let show_if = (
    /*ctx*/
    ctx[26].attunement && !FoundryAdapter.concealDetails(
      /*item*/
      ctx[25]
    )
  );
  let t2;
  let t3;
  let t4;
  let div4;
  let div3;
  let div3_title_value;
  let t5;
  let span;
  let textinput;
  let button_class_value;
  let button_aria_hidden_value;
  let button_data_context_menu_document_uuid_value;
  let button_disabled_value;
  let button_data_item_id_value;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = show_if && create_if_block_5$m(ctx);
  let if_block1 = "favoriteId" in /*ctx*/
  ctx[26] && !!/*ctx*/
  ctx[26].favoriteId && create_if_block_4$p();
  let if_block2 = (
    /*$context*/
    ctx[2].editable && create_if_block_3$y(ctx)
  );
  let if_block3 = (
    /*ctx*/
    ctx[26]?.hasUses && create_if_block_2$F(ctx)
  );
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[25]
      ),
      field: "system.quantity",
      cssClass: "item-count",
      value: (
        /*item*/
        ctx[25].system.quantity
      ),
      maxlength: 2,
      disabled: !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockItemQuantity,
      allowDeltaChanges: true,
      selectOnFocus: true
    }
  });
  textinput.$on("click", preventUseItemEvent);
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[13](
        /*item*/
        ctx[25],
        ...args
      )
    );
  }
  function contextmenu_handler(...args) {
    return (
      /*contextmenu_handler*/
      ctx[14](
        /*item*/
        ctx[25],
        ...args
      )
    );
  }
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[15](
        /*item*/
        ctx[25],
        ...args
      )
    );
  }
  function mouseenter_handler(...args) {
    return (
      /*mouseenter_handler*/
      ctx[16](
        /*item*/
        ctx[25],
        ...args
      )
    );
  }
  function mouseleave_handler(...args) {
    return (
      /*mouseleave_handler*/
      ctx[17](
        /*item*/
        ctx[25],
        ...args
      )
    );
  }
  function dragstart_handler(...args) {
    return (
      /*dragstart_handler*/
      ctx[18](
        /*item*/
        ctx[25],
        ...args
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      div2 = element("div");
      div0 = element("div");
      i0 = element("i");
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<i class="fas fa-question svelte-7m90sc"></i>`;
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      div4 = element("div");
      div3 = element("div");
      if (if_block3) if_block3.c();
      t5 = space();
      span = element("span");
      create_component(textinput.$$.fragment);
      attr(i0, "class", "fa fa-dice-d20 svelte-7m90sc");
      attr(div0, "class", "item-image svelte-7m90sc");
      set_style(div0, "background-image", "url('" + /*item*/
      ctx[25].img + "')");
      toggle_class(
        div0,
        "conceal",
        /*item*/
        ctx[25].system.identified === false
      );
      attr(div1, "role", "presentation");
      attr(div1, "aria-hidden", "true");
      attr(div1, "class", "unidentified-glyph no-transition svelte-7m90sc");
      toggle_class(
        div1,
        "conceal",
        /*item*/
        ctx[25].system.identified === false
      );
      attr(div2, "class", "item-name svelte-7m90sc");
      attr(div3, "class", "item-detail item-uses svelte-7m90sc");
      attr(div3, "title", div3_title_value = /*localize*/
      ctx[8]("DND5E.Uses") + ": " + /*item*/
      ctx[25].system.uses?.value + "/" + /*item*/
      ctx[25].system.uses?.max + " ");
      attr(span, "class", "item-quantity svelte-7m90sc");
      attr(
        span,
        "title",
        /*localize*/
        ctx[8]("DND5E.Quantity")
      );
      toggle_class(
        span,
        "isStack",
        /*item*/
        ctx[25].isStack
      );
      attr(div4, "class", "item-stats svelte-7m90sc");
      attr(button, "type", "button");
      attr(button, "class", button_class_value = "item " + /*getInventoryRowClasses*/
      ctx[9](
        /*item*/
        ctx[25]
      ) + " transparent-button svelte-7m90sc");
      attr(button, "aria-hidden", button_aria_hidden_value = /*hidden*/
      ctx[27]);
      attr(button, "data-context-menu", CONSTANTS.CONTEXT_MENU_TYPE_ITEMS);
      attr(button, "data-context-menu-document-uuid", button_data_context_menu_document_uuid_value = /*item*/
      ctx[25].uuid);
      attr(button, "draggable", true);
      button.disabled = button_disabled_value = !/*$context*/
      ctx[2].editable;
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_USE_COMMAND);
      attr(button, "data-item-id", button_data_item_id_value = /*item*/
      ctx[25].id);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-tidy-grid-item", "");
      toggle_class(
        button,
        "hidden",
        /*hidden*/
        ctx[27]
      );
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div2);
      append(div2, div0);
      append(div0, i0);
      append(div2, t0);
      append(div2, div1);
      append(button, t1);
      if (if_block0) if_block0.m(button, null);
      append(button, t2);
      if (if_block1) if_block1.m(button, null);
      append(button, t3);
      if (if_block2) if_block2.m(button, null);
      append(button, t4);
      append(button, div4);
      append(div4, div3);
      if (if_block3) if_block3.m(div3, null);
      append(div4, t5);
      append(div4, span);
      mount_component(textinput, span, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", click_handler),
          listen(button, "contextmenu", contextmenu_handler),
          listen(button, "mousedown", mousedown_handler),
          listen(button, "mouseenter", mouseenter_handler),
          listen(button, "mouseleave", mouseleave_handler),
          listen(button, "dragstart", dragstart_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*items*/
      2) {
        set_style(div0, "background-image", "url('" + /*item*/
        ctx[25].img + "')");
      }
      if (!current || dirty & /*items*/
      2) {
        toggle_class(
          div0,
          "conceal",
          /*item*/
          ctx[25].system.identified === false
        );
      }
      if (!current || dirty & /*items*/
      2) {
        toggle_class(
          div1,
          "conceal",
          /*item*/
          ctx[25].system.identified === false
        );
      }
      if (dirty & /*$context, items*/
      6) show_if = /*ctx*/
      ctx[26].attunement && !FoundryAdapter.concealDetails(
        /*item*/
        ctx[25]
      );
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_5$m(ctx);
          if_block0.c();
          if_block0.m(button, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ("favoriteId" in /*ctx*/
      ctx[26] && !!/*ctx*/
      ctx[26].favoriteId) {
        if (if_block1) {
          if (dirty & /*$context, items*/
          6) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$p();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx[2].editable
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_3$y(ctx);
          if_block2.c();
          if_block2.m(button, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*ctx*/
        ctx[26]?.hasUses
      ) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
          if (dirty & /*$context, items*/
          6) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2$F(ctx);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div3, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*items*/
      2 && div3_title_value !== (div3_title_value = /*localize*/
      ctx[8]("DND5E.Uses") + ": " + /*item*/
      ctx[25].system.uses?.value + "/" + /*item*/
      ctx[25].system.uses?.max + " ")) {
        attr(div3, "title", div3_title_value);
      }
      const textinput_changes = {};
      if (dirty & /*items*/
      2) textinput_changes.document = /*item*/
      ctx[25];
      if (dirty & /*items*/
      2) textinput_changes.value = /*item*/
      ctx[25].system.quantity;
      if (dirty & /*$context*/
      4) textinput_changes.disabled = !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockItemQuantity;
      textinput.$set(textinput_changes);
      if (!current || dirty & /*items*/
      2) {
        toggle_class(
          span,
          "isStack",
          /*item*/
          ctx[25].isStack
        );
      }
      if (!current || dirty & /*items*/
      2 && button_class_value !== (button_class_value = "item " + /*getInventoryRowClasses*/
      ctx[9](
        /*item*/
        ctx[25]
      ) + " transparent-button svelte-7m90sc")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*$itemIdsToShow, items*/
      18 && button_aria_hidden_value !== (button_aria_hidden_value = /*hidden*/
      ctx[27])) {
        attr(button, "aria-hidden", button_aria_hidden_value);
      }
      if (!current || dirty & /*items*/
      2 && button_data_context_menu_document_uuid_value !== (button_data_context_menu_document_uuid_value = /*item*/
      ctx[25].uuid)) {
        attr(button, "data-context-menu-document-uuid", button_data_context_menu_document_uuid_value);
      }
      if (!current || dirty & /*$context*/
      4 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx[2].editable)) {
        button.disabled = button_disabled_value;
      }
      if (!current || dirty & /*items*/
      2 && button_data_item_id_value !== (button_data_item_id_value = /*item*/
      ctx[25].id)) {
        attr(button, "data-item-id", button_data_item_id_value);
      }
      if (!current || dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*items, $itemIdsToShow, items*/
      18) {
        toggle_class(
          button,
          "hidden",
          /*hidden*/
          ctx[27]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block1);
      transition_in(if_block3);
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      transition_out(if_block3);
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      destroy_component(textinput);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$1i(ctx) {
  let div;
  let button;
  let i2;
  let button_tabindex_value;
  let t2;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*customCommands*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$K(get_each_context$K(ctx, each_value, i3));
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      t2 = space();
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      attr(i2, "class", "fas fa-plus-circle svelte-7m90sc");
      attr(button, "type", "button");
      attr(button, "class", "footer-command icon-button svelte-7m90sc");
      attr(
        button,
        "title",
        /*localize*/
        ctx[8]("DND5E.ItemCreate")
      );
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_CREATE_COMMAND);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div, "class", "items-footer svelte-7m90sc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      append(div, t2);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(div, null);
        }
      }
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*click_handler_1*/
          ctx[19]
        )));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*$settingStore, localize, customCommands, section, $context*/
      301) {
        each_value = ensure_array_like(
          /*customCommands*/
          ctx2[3]
        );
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$K(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block$K(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(div, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$Q(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = null_to_empty(
        /*command*/
        ctx[22].iconClass
      ) + " svelte-7m90sc");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*customCommands*/
      8 && i_class_value !== (i_class_value = null_to_empty(
        /*command*/
        ctx2[22].iconClass
      ) + " svelte-7m90sc")) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_each_block$K(ctx) {
  let button;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[8](
      /*command*/
      ctx[22].label ?? ""
    ) + ""
  );
  let t1;
  let t2;
  let button_tabindex_value;
  let button_title_value;
  let mounted;
  let dispose;
  let if_block = (
    /*command*/
    (ctx[22].iconClass ?? "") !== "" && create_if_block_1$Q(ctx)
  );
  function click_handler_2(...args) {
    return (
      /*click_handler_2*/
      ctx[20](
        /*command*/
        ctx[22],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      if (if_block) if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(button, "type", "button");
      attr(button, "class", "footer-command icon-button svelte-7m90sc");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "title", button_title_value = /*localize*/
      ctx[8](
        /*command*/
        ctx[22].tooltip ?? ""
      ));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block) if_block.m(button, null);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*command*/
        (ctx[22].iconClass ?? "") !== ""
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$Q(ctx);
          if_block.c();
          if_block.m(button, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*customCommands*/
      8 && t1_value !== (t1_value = /*localize*/
      ctx[8](
        /*command*/
        ctx[22].label ?? ""
      ) + "")) set_data(t1, t1_value);
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*customCommands*/
      8 && button_title_value !== (button_title_value = /*localize*/
      ctx[8](
        /*command*/
        ctx[22].tooltip ?? ""
      ))) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_body_slot$f(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let current;
  let each_value_1 = ensure_array_like(
    /*items*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[25].id
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$m(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$m(key, child_ctx));
  }
  let if_block = (
    /*$context*/
    ctx[2].unlocked && create_if_block$1i(ctx)
  );
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      attr(div, "class", "items svelte-7m90sc");
      attr(div, "slot", "body");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t2);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*getInventoryRowClasses, items, $itemIdsToShow, $context, $settingStore, onMouseEnter, onMouseLeave, handleDragStart, localize, preventUseItemEvent*/
      7990) {
        each_value_1 = ensure_array_like(
          /*items*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1$m, t2, get_each_context_1$m);
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].unlocked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1i(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block) if_block.d();
    }
  };
}
function create_fragment$2O(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[0].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[0].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$f],
        header: [create_header_slot$g]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*section*/
      1) itemtable_changes.key = /*section*/
      ctx2[0].key;
      if (dirty & /*section*/
      1) itemtable_changes["data-custom-section"] = /*section*/
      ctx2[0].custom ? true : null;
      if (dirty & /*$$scope, customCommands, $settingStore, section, $context, items, $itemIdsToShow*/
      1073741887) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function preventUseItemEvent(ev) {
  ev.stopPropagation();
}
function instance$2O($$self, $$props, $$invalidate) {
  let customCommands;
  let $context;
  let $itemIdsToShow;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { section } = $$props;
  let { items } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let card = getContext(CONSTANTS.SVELTE_CONTEXT.CARD);
  let itemIdsToShow = getContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(4, $itemIdsToShow = value));
  const localize = FoundryAdapter.localize;
  function getInventoryRowClasses(item) {
    const extras = [];
    return FoundryAdapter.getInventoryRowClasses(item, $context.itemContext[item.id], extras);
  }
  async function onMouseEnter(event, item) {
    TidyHooks.tidy5eSheetsItemHoverOn(event, item);
    card.update((card2) => {
      card2.item = item;
      return card2;
    });
  }
  async function onMouseLeave(event, item) {
    TidyHooks.tidy5eSheetsItemHoverOff(event, item);
    card.update((card2) => {
      card2.item = null;
      return card2;
    });
  }
  function handleDragStart2(event, item) {
    if (!item) {
      return;
    }
    onMouseLeave(event, item);
    card.update((card2) => {
      return card2;
    });
    const dragData = item.toDragData();
    event.dataTransfer?.setData("text/plain", JSON.stringify(dragData));
  }
  declareLocation("inventory-grid");
  const click_handler = (item, event) => $context.editable && FoundryAdapter.actorTryUseItem(item, {}, { event });
  const contextmenu_handler = (item, event) => FoundryAdapter.onActorItemButtonContextMenu(item, { event });
  const mousedown_handler = (item, event) => FoundryAdapter.editOnMiddleClick(event, item);
  const mouseenter_handler = (item, ev) => onMouseEnter(ev, item);
  const mouseleave_handler = (item, ev) => onMouseLeave(ev, item);
  const dragstart_handler = (item, ev) => handleDragStart2(ev, item);
  const click_handler_1 = () => FoundryAdapter.createItem(
    {
      ...section.dataset,
      action: "itemCreate",
      tooltip: "DND5E.ItemCreate"
    },
    $context.actor
  );
  const click_handler_2 = (command, ev) => command.execute?.({
    section,
    event: ev,
    actor: $context.actor
  });
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
    if ("items" in $$props2) $$invalidate(1, items = $$props2.items);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, section*/
    5) {
      $$invalidate(3, customCommands = ActorItemRuntime.getActorItemSectionCommands({ actor: $context.actor, section }));
    }
  };
  return [
    section,
    items,
    $context,
    customCommands,
    $itemIdsToShow,
    $settingStore,
    context,
    itemIdsToShow,
    localize,
    getInventoryRowClasses,
    onMouseEnter,
    onMouseLeave,
    handleDragStart2,
    click_handler,
    contextmenu_handler,
    mousedown_handler,
    mouseenter_handler,
    mouseleave_handler,
    dragstart_handler,
    click_handler_1,
    click_handler_2
  ];
}
class InventoryGrid extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2O, create_fragment$2O, safe_not_equal, { section: 0, items: 1 });
  }
}
function get_each_context$J(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block$J(ctx) {
  let li;
  let textinput;
  let t0;
  let label;
  let t1_value = abbreviateCurrency(
    /*currency*/
    ctx[8].key
  ) + "";
  let t1;
  let label_for_value;
  let label_class_value;
  let label_data_denom_value;
  let li_class_value;
  let li_title_value;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*document*/
        ctx[0]
      ),
      field: "system.currency." + /*currency*/
      ctx[8].key,
      id: (
        /*$context*/
        ctx[2].appId + "-system.currency." + /*currency*/
        ctx[8].key
      ),
      value: (
        /*currency*/
        ctx[8].value
      ),
      allowDeltaChanges: true,
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockMoneyChanges
    }
  });
  return {
    c() {
      li = element("li");
      create_component(textinput.$$.fragment);
      t0 = space();
      label = element("label");
      t1 = text(t1_value);
      attr(label, "for", label_for_value = /*$context*/
      ctx[2].appId + "-system.currency." + /*currency*/
      ctx[8].key);
      attr(label, "class", label_class_value = "denomination " + /*currency*/
      ctx[8].key + " svelte-19ozue8");
      attr(label, "data-denom", label_data_denom_value = /*currency*/
      ctx[8].key);
      attr(li, "class", li_class_value = "currency-item " + /*currency*/
      ctx[8].key + " svelte-19ozue8");
      attr(li, "title", li_title_value = /*$context*/
      ctx[2].config.currencies[
        /*currency*/
        ctx[8].key
      ]?.label);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(textinput, li, null);
      append(li, t0);
      append(li, label);
      append(label, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*document*/
      1) textinput_changes.document = /*document*/
      ctx2[0];
      if (dirty & /*currencies*/
      2) textinput_changes.field = "system.currency." + /*currency*/
      ctx2[8].key;
      if (dirty & /*$context, currencies*/
      6) textinput_changes.id = /*$context*/
      ctx2[2].appId + "-system.currency." + /*currency*/
      ctx2[8].key;
      if (dirty & /*currencies*/
      2) textinput_changes.value = /*currency*/
      ctx2[8].value;
      if (dirty & /*$context*/
      4) textinput_changes.disabled = !/*$context*/
      ctx2[2].editable || /*$context*/
      ctx2[2].lockMoneyChanges;
      textinput.$set(textinput_changes);
      if ((!current || dirty & /*currencies*/
      2) && t1_value !== (t1_value = abbreviateCurrency(
        /*currency*/
        ctx2[8].key
      ) + "")) set_data(t1, t1_value);
      if (!current || dirty & /*$context, currencies*/
      6 && label_for_value !== (label_for_value = /*$context*/
      ctx2[2].appId + "-system.currency." + /*currency*/
      ctx2[8].key)) {
        attr(label, "for", label_for_value);
      }
      if (!current || dirty & /*currencies*/
      2 && label_class_value !== (label_class_value = "denomination " + /*currency*/
      ctx2[8].key + " svelte-19ozue8")) {
        attr(label, "class", label_class_value);
      }
      if (!current || dirty & /*currencies*/
      2 && label_data_denom_value !== (label_data_denom_value = /*currency*/
      ctx2[8].key)) {
        attr(label, "data-denom", label_data_denom_value);
      }
      if (!current || dirty & /*currencies*/
      2 && li_class_value !== (li_class_value = "currency-item " + /*currency*/
      ctx2[8].key + " svelte-19ozue8")) {
        attr(li, "class", li_class_value);
      }
      if (!current || dirty & /*$context, currencies*/
      6 && li_title_value !== (li_title_value = /*$context*/
      ctx2[2].config.currencies[
        /*currency*/
        ctx2[8].key
      ]?.label)) {
        attr(li, "title", li_title_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(textinput);
    }
  };
}
function create_fragment$2N(ctx) {
  let div;
  let ol;
  let t2;
  let li;
  let button;
  let i2;
  let button_disabled_value;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*currencies*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$J(get_each_context$J(ctx, each_value, i3));
  }
  const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
    each_blocks[i3] = null;
  });
  return {
    c() {
      div = element("div");
      ol = element("ol");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t2 = space();
      li = element("li");
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-coins");
      attr(button, "type", "button");
      attr(button, "class", "currency-convert svelte-19ozue8");
      attr(
        button,
        "title",
        /*localize*/
        ctx[6]("DND5E.CurrencyManager.Title")
      );
      button.disabled = button_disabled_value = !/*$context*/
      ctx[2].editable;
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[3].useAccessibleKeyboardSupport ? 0 : -1);
      attr(li, "class", "currency-item convert svelte-19ozue8");
      attr(ol, "class", "currency svelte-19ozue8");
      attr(div, "class", "inventory-currency svelte-19ozue8");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ol);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(ol, null);
        }
      }
      append(ol, t2);
      append(ol, li);
      append(li, button);
      append(button, i2);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*click_handler*/
          ctx[7]
        )));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*currencies, $context, abbreviateCurrency, document*/
      7) {
        each_value = ensure_array_like(
          /*currencies*/
          ctx2[1]
        );
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$J(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
            transition_in(each_blocks[i3], 1);
          } else {
            each_blocks[i3] = create_each_block$J(child_ctx);
            each_blocks[i3].c();
            transition_in(each_blocks[i3], 1);
            each_blocks[i3].m(ol, t2);
          }
        }
        group_outros();
        for (i3 = each_value.length; i3 < each_blocks.length; i3 += 1) {
          out(i3);
        }
        check_outros();
      }
      if (!current || dirty & /*$context*/
      4 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx2[2].editable)) {
        button.disabled = button_disabled_value;
      }
      if (!current || dirty & /*$settingStore*/
      8 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[3].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i(local) {
      if (current) return;
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        transition_in(each_blocks[i3]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        transition_out(each_blocks[i3]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function abbreviateCurrency(currencyKey) {
  return CONFIG.DND5E.currencies[currencyKey]?.abbreviation ?? currencyKey;
}
function instance$2N($$self, $$props, $$invalidate) {
  let currencies;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(3, $settingStore = $$value));
  let { document: document2 } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  function confirmConvertCurrency() {
    new dnd5e.applications.CurrencyManager(document2).render(true);
  }
  const localize = FoundryAdapter.localize;
  const click_handler = () => confirmConvertCurrency();
  $$self.$$set = ($$props2) => {
    if ("document" in $$props2) $$invalidate(0, document2 = $$props2.document);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*document*/
    1) {
      $$invalidate(1, currencies = Object.entries(document2.system.currency).map((e2) => ({ key: e2[0], value: e2[1] })));
    }
  };
  return [
    document2,
    currencies,
    $context,
    $settingStore,
    context,
    confirmConvertCurrency,
    localize,
    click_handler
  ];
}
class Currency extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2N, create_fragment$2N, safe_not_equal, { document: 0 });
  }
}
function create_fragment$2M(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr(div, "class", div_class_value = "notice " + /*cssClass*/
      ctx[0] + " svelte-p0r7e5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cssClass*/
      1 && div_class_value !== (div_class_value = "notice " + /*cssClass*/
      ctx2[0] + " svelte-p0r7e5")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$2M($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { cssClass = null } = $$props;
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [cssClass, $$scope, slots];
}
class Notice extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2M, create_fragment$2M, safe_not_equal, { cssClass: 0 });
  }
}
function create_fragment$2L(ctx) {
  let input;
  let input_data_tooltip_value;
  let input_disabled_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "number" },
    { id: (
      /*id*/
      ctx[6]
    ) },
    { step: (
      /*step*/
      ctx[0]
    ) },
    { min: (
      /*min*/
      ctx[4]
    ) },
    { max: (
      /*max*/
      ctx[5]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[1]
    ) },
    {
      "data-tooltip": input_data_tooltip_value = /*activeEffectApplied*/
      ctx[16] ? (
        /*overrideTooltip*/
        ctx[15]
      ) : (
        /*tooltip*/
        ctx[3]
      )
    },
    {
      disabled: input_disabled_value = /*disabled*/
      ctx[7] || /*activeEffectApplied*/
      ctx[16]
    },
    { readOnly: (
      /*readonly*/
      ctx[8]
    ) },
    { class: (
      /*cssClass*/
      ctx[9]
    ) },
    { maxlength: (
      /*maxlength*/
      ctx[10]
    ) },
    /*datasetAttributes*/
    ctx[18],
    { title: (
      /*title*/
      ctx[12]
    ) },
    { "data-tidy-field": (
      /*field*/
      ctx[2]
    ) }
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus) input.focus();
      ctx[26](input);
      set_input_value(
        input,
        /*draftValue*/
        ctx[17]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[27]
          ),
          listen(
            input,
            "change",
            /*saveChange*/
            ctx[19]
          ),
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[28]
          ),
          listen(
            input,
            "click",
            /*click_handler*/
            ctx[29]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "number" },
        dirty & /*id*/
        64 && { id: (
          /*id*/
          ctx2[6]
        ) },
        dirty & /*step*/
        1 && { step: (
          /*step*/
          ctx2[0]
        ) },
        dirty & /*min*/
        16 && { min: (
          /*min*/
          ctx2[4]
        ) },
        dirty & /*max*/
        32 && { max: (
          /*max*/
          ctx2[5]
        ) },
        dirty & /*placeholder*/
        2 && { placeholder: (
          /*placeholder*/
          ctx2[1]
        ) },
        dirty & /*activeEffectApplied, overrideTooltip, tooltip*/
        98312 && input_data_tooltip_value !== (input_data_tooltip_value = /*activeEffectApplied*/
        ctx2[16] ? (
          /*overrideTooltip*/
          ctx2[15]
        ) : (
          /*tooltip*/
          ctx2[3]
        )) && { "data-tooltip": input_data_tooltip_value },
        dirty & /*disabled, activeEffectApplied*/
        65664 && input_disabled_value !== (input_disabled_value = /*disabled*/
        ctx2[7] || /*activeEffectApplied*/
        ctx2[16]) && { disabled: input_disabled_value },
        dirty & /*readonly*/
        256 && { readOnly: (
          /*readonly*/
          ctx2[8]
        ) },
        dirty & /*cssClass*/
        512 && { class: (
          /*cssClass*/
          ctx2[9]
        ) },
        dirty & /*maxlength*/
        1024 && { maxlength: (
          /*maxlength*/
          ctx2[10]
        ) },
        dirty & /*datasetAttributes*/
        262144 && /*datasetAttributes*/
        ctx2[18],
        dirty & /*title*/
        4096 && { title: (
          /*title*/
          ctx2[12]
        ) },
        dirty & /*field*/
        4 && { "data-tidy-field": (
          /*field*/
          ctx2[2]
        ) }
      ]));
      if (dirty & /*draftValue*/
      131072 && to_number(input.value) !== /*draftValue*/
      ctx2[17]) {
        set_input_value(
          input,
          /*draftValue*/
          ctx2[17]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2L($$self, $$props, $$invalidate) {
  let draftValue;
  let datasetAttributes;
  let activeEffectApplied;
  let isEnchanted;
  let overrideTooltip;
  let $context;
  let { value = null } = $$props;
  let { step = "any" } = $$props;
  let { placeholder = null } = $$props;
  let { field } = $$props;
  let { document: document2 } = $$props;
  let { tooltip = null } = $$props;
  let { min = null } = $$props;
  let { max = null } = $$props;
  let { id = null } = $$props;
  let { disabled = null } = $$props;
  let { dataset = null } = $$props;
  let { readonly = null } = $$props;
  let { cssClass = null } = $$props;
  let { maxlength = null } = $$props;
  let { selectOnFocus = false } = $$props;
  let { title = null } = $$props;
  let { stopClickPropagation = false } = $$props;
  let theInput;
  async function saveChange(event) {
    const proposedValueToSave = parseFloat(event.currentTarget.value);
    const parsedValueToSave = !isNaN(proposedValueToSave) ? proposedValueToSave : null;
    await document2.update({ [field]: parsedValueToSave });
    $$invalidate(17, draftValue = value);
    if (selectOnFocus && theInput === window.document.activeElement) {
      theInput.select();
    }
  }
  const context = getContext("context");
  component_subscribe($$self, context, (value2) => $$invalidate(25, $context = value2));
  const localize = FoundryAdapter.localize;
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      theInput = $$value;
      $$invalidate(14, theInput);
    });
  }
  function input_input_handler() {
    draftValue = to_number(this.value);
    $$invalidate(17, draftValue), $$invalidate(21, value);
  }
  const focus_handler2 = (ev) => selectOnFocus && ev.currentTarget.select();
  const click_handler = (ev) => stopClickPropagation && ev.stopPropagation();
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(21, value = $$props2.value);
    if ("step" in $$props2) $$invalidate(0, step = $$props2.step);
    if ("placeholder" in $$props2) $$invalidate(1, placeholder = $$props2.placeholder);
    if ("field" in $$props2) $$invalidate(2, field = $$props2.field);
    if ("document" in $$props2) $$invalidate(22, document2 = $$props2.document);
    if ("tooltip" in $$props2) $$invalidate(3, tooltip = $$props2.tooltip);
    if ("min" in $$props2) $$invalidate(4, min = $$props2.min);
    if ("max" in $$props2) $$invalidate(5, max = $$props2.max);
    if ("id" in $$props2) $$invalidate(6, id = $$props2.id);
    if ("disabled" in $$props2) $$invalidate(7, disabled = $$props2.disabled);
    if ("dataset" in $$props2) $$invalidate(23, dataset = $$props2.dataset);
    if ("readonly" in $$props2) $$invalidate(8, readonly = $$props2.readonly);
    if ("cssClass" in $$props2) $$invalidate(9, cssClass = $$props2.cssClass);
    if ("maxlength" in $$props2) $$invalidate(10, maxlength = $$props2.maxlength);
    if ("selectOnFocus" in $$props2) $$invalidate(11, selectOnFocus = $$props2.selectOnFocus);
    if ("title" in $$props2) $$invalidate(12, title = $$props2.title);
    if ("stopClickPropagation" in $$props2) $$invalidate(13, stopClickPropagation = $$props2.stopClickPropagation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    2097152) {
      $$invalidate(17, draftValue = value);
    }
    if ($$self.$$.dirty & /*dataset*/
    8388608) {
      $$invalidate(18, datasetAttributes = buildDataset(dataset));
    }
    if ($$self.$$.dirty & /*document, field*/
    4194308) {
      $$invalidate(16, activeEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(document2, field));
    }
    if ($$self.$$.dirty & /*$context, field*/
    33554436) {
      $$invalidate(24, isEnchanted = $context.itemOverrides instanceof Set && $context.itemOverrides.has(field));
    }
    if ($$self.$$.dirty & /*isEnchanted*/
    16777216) {
      $$invalidate(15, overrideTooltip = isEnchanted ? localize("DND5E.Enchantment.Warning.Override") : localize("DND5E.ActiveEffectOverrideWarning"));
    }
  };
  return [
    step,
    placeholder,
    field,
    tooltip,
    min,
    max,
    id,
    disabled,
    readonly,
    cssClass,
    maxlength,
    selectOnFocus,
    title,
    stopClickPropagation,
    theInput,
    overrideTooltip,
    activeEffectApplied,
    draftValue,
    datasetAttributes,
    saveChange,
    context,
    value,
    document2,
    dataset,
    isEnchanted,
    $context,
    input_binding,
    input_input_handler,
    focus_handler2,
    click_handler
  ];
}
class NumberInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2L, create_fragment$2L, safe_not_equal, {
      value: 21,
      step: 0,
      placeholder: 1,
      field: 2,
      document: 22,
      tooltip: 3,
      min: 4,
      max: 5,
      id: 6,
      disabled: 7,
      dataset: 23,
      readonly: 8,
      cssClass: 9,
      maxlength: 10,
      selectOnFocus: 11,
      title: 12,
      stopClickPropagation: 13
    });
  }
}
function create_fragment$2K(ctx) {
  let div;
  let span0;
  let t0;
  let span1;
  let t1_value = (
    /*$context*/
    ctx[0].encumbrance.value + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*$context*/
    ctx[0].encumbrance.max + ""
  );
  let t3;
  let t4;
  let i0;
  let t5;
  let i1;
  let t6;
  let i2;
  let t7;
  let i3;
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = text(" / ");
      t3 = text(t3_value);
      t4 = space();
      i0 = element("i");
      t5 = space();
      i1 = element("i");
      t6 = space();
      i2 = element("i");
      t7 = space();
      i3 = element("i");
      attr(span0, "class", "encumbrance-bar svelte-1xtp6nu");
      set_style(
        span0,
        "width",
        /*$context*/
        ctx[0].encumbrance.pct + "%"
      );
      attr(span1, "class", "encumbrance-label svelte-1xtp6nu");
      attr(i0, "class", "encumbrance-breakpoint encumbrance-33 arrow-up svelte-1xtp6nu");
      attr(i1, "class", "encumbrance-breakpoint encumbrance-33 arrow-down svelte-1xtp6nu");
      attr(i2, "class", "encumbrance-breakpoint encumbrance-66 arrow-up svelte-1xtp6nu");
      attr(i3, "class", "encumbrance-breakpoint encumbrance-66 arrow-down svelte-1xtp6nu");
      attr(div, "class", "encumbrance svelte-1xtp6nu");
      attr(
        div,
        "title",
        /*localize*/
        ctx[2]("TIDY5E.Encumbrance")
      );
      toggle_class(
        div,
        "encumbered",
        /*$context*/
        ctx[0].encumbrance.encumbered
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(div, t0);
      append(div, span1);
      append(span1, t1);
      append(span1, t2);
      append(span1, t3);
      append(div, t4);
      append(div, i0);
      append(div, t5);
      append(div, i1);
      append(div, t6);
      append(div, i2);
      append(div, t7);
      append(div, i3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      1) {
        set_style(
          span0,
          "width",
          /*$context*/
          ctx2[0].encumbrance.pct + "%"
        );
      }
      if (dirty & /*$context*/
      1 && t1_value !== (t1_value = /*$context*/
      ctx2[0].encumbrance.value + "")) set_data(t1, t1_value);
      if (dirty & /*$context*/
      1 && t3_value !== (t3_value = /*$context*/
      ctx2[0].encumbrance.max + "")) set_data(t3, t3_value);
      if (dirty & /*$context*/
      1) {
        toggle_class(
          div,
          "encumbered",
          /*$context*/
          ctx2[0].encumbrance.encumbered
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$2K($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class EncumbranceBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2K, create_fragment$2K, safe_not_equal, {});
  }
}
function create_fragment$2J(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      footer = element("footer");
      if (default_slot) default_slot.c();
      attr(footer, "class", footer_class_value = "tab-footer " + /*cssClass*/
      ctx[0] + " " + /*mode*/
      ctx[1] + " svelte-f8ueuq");
    },
    m(target, anchor) {
      insert(target, footer, anchor);
      if (default_slot) {
        default_slot.m(footer, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cssClass, mode*/
      3 && footer_class_value !== (footer_class_value = "tab-footer " + /*cssClass*/
      ctx2[0] + " " + /*mode*/
      ctx2[1] + " svelte-f8ueuq")) {
        attr(footer, "class", footer_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(footer);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$2J($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { cssClass = null } = $$props;
  let { mode } = $$props;
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
    if ("mode" in $$props2) $$invalidate(1, mode = $$props2.mode);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [cssClass, mode, $$scope, slots];
}
class TabFooter extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2J, create_fragment$2J, safe_not_equal, { cssClass: 0, mode: 1 });
  }
}
function get_each_context$I(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2].container;
  child_ctx[13] = object_without_properties(list[i2], ["container"]);
  return child_ctx;
}
function create_each_block$I(key_1, ctx) {
  let li;
  let button;
  let div1;
  let div0;
  let button_data_context_menu_document_uuid_value;
  let button_disabled_value;
  let t0;
  let capacitybar;
  let div;
  let t1;
  let li_data_item_id_value;
  let li_title_value;
  let li_aria_hidden_value;
  let current;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[6](
        /*container*/
        ctx[12]
      )
    );
  }
  capacitybar = new CapacityBar({
    props: {
      showLabel: false,
      container: (
        /*container*/
        ctx[12]
      ),
      capacity: (
        /*capacity*/
        ctx[13]
      )
    }
  });
  function dragstart_handler(...args) {
    return (
      /*dragstart_handler*/
      ctx[7](
        /*container*/
        ctx[12],
        ...args
      )
    );
  }
  function mouseenter_handler(...args) {
    return (
      /*mouseenter_handler*/
      ctx[8](
        /*container*/
        ctx[12],
        ...args
      )
    );
  }
  function mouseleave_handler(...args) {
    return (
      /*mouseleave_handler*/
      ctx[9](
        /*container*/
        ctx[12],
        ...args
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      button = element("button");
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<i class="fas fa-question"></i>`;
      t0 = space();
      div = element("div");
      create_component(capacitybar.$$.fragment);
      t1 = space();
      attr(div0, "role", "presentation");
      attr(div0, "aria-hidden", "true");
      attr(div0, "class", "unidentified-glyph svelte-1eors33");
      toggle_class(
        div0,
        "conceal",
        /*container*/
        ctx[12].system.identified === false
      );
      attr(div1, "class", "container-image svelte-1eors33");
      set_style(div1, "background-image", "url('" + /*container*/
      ctx[12].img + "')");
      toggle_class(
        div1,
        "conceal",
        /*container*/
        ctx[12].system.identified === false
      );
      attr(button, "type", "button");
      attr(button, "class", "transparent-button");
      attr(button, "data-context-menu", CONSTANTS.CONTEXT_MENU_TYPE_ITEMS);
      attr(button, "data-context-menu-document-uuid", button_data_context_menu_document_uuid_value = /*container*/
      ctx[12].uuid);
      button.disabled = button_disabled_value = !FoundryAdapter.userIsGm() && !/*container*/
      ctx[12].isOwner;
      set_style(div, "display", "contents");
      set_style(div, "--capacity-bar-height", "0.5rem");
      set_style(div, "--capacity-bar-container-border-radius", "0 0 0.1875rem 0.1875rem");
      set_style(li, "position", "relative");
      attr(li, "draggable", "true");
      attr(li, "data-item-id", li_data_item_id_value = /*container*/
      ctx[12].id);
      attr(li, "class", "container svelte-1eors33");
      attr(li, "title", li_title_value = /*container*/
      ctx[12].system.identified === false ? coalesce(
        /*container*/
        ctx[12].system.unidentified.name,
        FoundryAdapter.localize("DND5E.Unidentified.Title")
      ) : (
        /*container*/
        ctx[12].name
      ));
      attr(li, "aria-hidden", li_aria_hidden_value = !/*visibleContainersIdsSubset*/
      ctx[1].has(
        /*container*/
        ctx[12].id
      ));
      toggle_class(li, "hidden", !/*visibleContainersIdsSubset*/
      ctx[1].has(
        /*container*/
        ctx[12].id
      ));
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, button);
      append(button, div1);
      append(div1, div0);
      append(li, t0);
      append(li, div);
      mount_component(capacitybar, div, null);
      append(li, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", click_handler),
          listen(li, "dragstart", dragstart_handler),
          listen(li, "mouseenter", mouseenter_handler),
          listen(li, "mouseleave", mouseleave_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*containerPanelItems*/
      1) {
        toggle_class(
          div0,
          "conceal",
          /*container*/
          ctx[12].system.identified === false
        );
      }
      if (!current || dirty & /*containerPanelItems*/
      1) {
        set_style(div1, "background-image", "url('" + /*container*/
        ctx[12].img + "')");
      }
      if (!current || dirty & /*containerPanelItems*/
      1) {
        toggle_class(
          div1,
          "conceal",
          /*container*/
          ctx[12].system.identified === false
        );
      }
      if (!current || dirty & /*containerPanelItems*/
      1 && button_data_context_menu_document_uuid_value !== (button_data_context_menu_document_uuid_value = /*container*/
      ctx[12].uuid)) {
        attr(button, "data-context-menu-document-uuid", button_data_context_menu_document_uuid_value);
      }
      if (!current || dirty & /*containerPanelItems*/
      1 && button_disabled_value !== (button_disabled_value = !FoundryAdapter.userIsGm() && !/*container*/
      ctx[12].isOwner)) {
        button.disabled = button_disabled_value;
      }
      const capacitybar_changes = {};
      if (dirty & /*containerPanelItems*/
      1) capacitybar_changes.container = /*container*/
      ctx[12];
      if (dirty & /*containerPanelItems*/
      1) capacitybar_changes.capacity = /*capacity*/
      ctx[13];
      capacitybar.$set(capacitybar_changes);
      if (!current || dirty & /*containerPanelItems*/
      1 && li_data_item_id_value !== (li_data_item_id_value = /*container*/
      ctx[12].id)) {
        attr(li, "data-item-id", li_data_item_id_value);
      }
      if (!current || dirty & /*containerPanelItems*/
      1 && li_title_value !== (li_title_value = /*container*/
      ctx[12].system.identified === false ? coalesce(
        /*container*/
        ctx[12].system.unidentified.name,
        FoundryAdapter.localize("DND5E.Unidentified.Title")
      ) : (
        /*container*/
        ctx[12].name
      ))) {
        attr(li, "title", li_title_value);
      }
      if (!current || dirty & /*visibleContainersIdsSubset, containerPanelItems*/
      3 && li_aria_hidden_value !== (li_aria_hidden_value = !/*visibleContainersIdsSubset*/
      ctx[1].has(
        /*container*/
        ctx[12].id
      ))) {
        attr(li, "aria-hidden", li_aria_hidden_value);
      }
      if (!current || dirty & /*visibleContainersIdsSubset, containerPanelItems*/
      3) {
        toggle_class(li, "hidden", !/*visibleContainersIdsSubset*/
        ctx[1].has(
          /*container*/
          ctx[12].id
        ));
      }
    },
    i(local) {
      if (current) return;
      transition_in(capacitybar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(capacitybar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(capacitybar);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2I(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*containerPanelItems*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*container*/
    ctx2[12].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$I(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$I(key, child_ctx));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "containers svelte-1eors33");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*containerPanelItems, visibleContainersIdsSubset, handleDragStart, onMouseEnter, onMouseLeave*/
      31) {
        each_value = ensure_array_like(
          /*containerPanelItems*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$I, null, get_each_context$I);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function instance$2I($$self, $$props, $$invalidate) {
  let visibleContainersIdsSubset;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(10, $settingStore = $$value));
  let { containerPanelItems = [] } = $$props;
  let { searchCriteria = "" } = $$props;
  let card = getContext(CONSTANTS.SVELTE_CONTEXT.CARD);
  async function onMouseEnter(event, item) {
    TidyHooks.tidy5eSheetsItemHoverOn(event, item);
    if (!item?.getChatData || !$settingStore.itemCardsForAllItems) {
      return;
    }
    card?.update((card2) => {
      card2.item = item;
      return card2;
    });
  }
  async function onMouseLeave(event, item) {
    TidyHooks.tidy5eSheetsItemHoverOff(event, item);
    card?.update((card2) => {
      card2.item = null;
      card2.itemCardContentTemplate = null;
      return card2;
    });
  }
  function handleDragStart2(event, item) {
    onMouseLeave(event, item);
    card?.update((card2) => {
      return card2;
    });
    const dragData = item.toDragData();
    event.dataTransfer?.setData("text/plain", JSON.stringify(dragData));
  }
  const click_handler = (container) => container.sheet.render(true);
  const dragstart_handler = (container, ev) => handleDragStart2(ev, container);
  const mouseenter_handler = (container, ev) => onMouseEnter(ev, container);
  const mouseleave_handler = (container, ev) => onMouseLeave(ev, container);
  $$self.$$set = ($$props2) => {
    if ("containerPanelItems" in $$props2) $$invalidate(0, containerPanelItems = $$props2.containerPanelItems);
    if ("searchCriteria" in $$props2) $$invalidate(5, searchCriteria = $$props2.searchCriteria);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*searchCriteria, containerPanelItems*/
    33) {
      $$invalidate(1, visibleContainersIdsSubset = FoundryAdapter.searchItems(searchCriteria, containerPanelItems.map((c2) => c2.container)));
    }
  };
  return [
    containerPanelItems,
    visibleContainersIdsSubset,
    onMouseEnter,
    onMouseLeave,
    handleDragStart2,
    searchCriteria,
    click_handler,
    dragstart_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
class ContainerPanel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2I, create_fragment$2I, safe_not_equal, {
      containerPanelItems: 0,
      searchCriteria: 5
    });
  }
}
function get_each_context$H(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  const constants_0 = ItemVisibility.countVisibleItems(
    /*section*/
    child_ctx[15].items,
    /*$itemIdsToShow*/
    child_ctx[7]
  );
  child_ctx[16] = constants_0;
  return child_ctx;
}
function get_else_ctx$1(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*$context*/
    child_ctx[3].showContainerPanel && !!/*$context*/
    child_ctx[3].containerPanelItems.length
  );
  child_ctx[14] = constants_0;
  return child_ctx;
}
function get_each_context_1$l(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function create_each_block_1$l(key_1, ctx) {
  let first;
  let utilitytoolbarcommand;
  let current;
  function execute_handler(...args) {
    return (
      /*execute_handler*/
      ctx[13](
        /*command*/
        ctx[19],
        ...args
      )
    );
  }
  utilitytoolbarcommand = new UtilityToolbarCommand({
    props: {
      title: (
        /*command*/
        ctx[19].title
      ),
      iconClass: (
        /*command*/
        ctx[19].iconClass
      ),
      text: (
        /*command*/
        ctx[19].text
      ),
      visible: (
        /*command*/
        ctx[19].visible ?? true
      )
    }
  });
  utilitytoolbarcommand.$on("execute", execute_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(utilitytoolbarcommand.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(utilitytoolbarcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const utilitytoolbarcommand_changes = {};
      if (dirty & /*utilityBarCommands*/
      32) utilitytoolbarcommand_changes.title = /*command*/
      ctx[19].title;
      if (dirty & /*utilityBarCommands*/
      32) utilitytoolbarcommand_changes.iconClass = /*command*/
      ctx[19].iconClass;
      if (dirty & /*utilityBarCommands*/
      32) utilitytoolbarcommand_changes.text = /*command*/
      ctx[19].text;
      if (dirty & /*utilityBarCommands*/
      32) utilitytoolbarcommand_changes.visible = /*command*/
      ctx[19].visible ?? true;
      utilitytoolbarcommand.$set(utilitytoolbarcommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbarcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbarcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(utilitytoolbarcommand, detaching);
    }
  };
}
function create_default_slot_3$x(ctx) {
  let search;
  let updating_value;
  let t0;
  let pinnedfiltertoggles;
  let t1;
  let filtermenu;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  function search_value_binding(value) {
    ctx[12](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[1] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[1];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  pinnedfiltertoggles = new PinnedFilterToggles({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[0]
      ),
      filters: ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx[3].filterPins,
        /*$context*/
        ctx[3].filterData,
        /*tabId*/
        ctx[0]
      )
    }
  });
  filtermenu = new FilterMenu({ props: { tabId: (
    /*tabId*/
    ctx[0]
  ) } });
  let each_value_1 = ensure_array_like(
    /*utilityBarCommands*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[19].title
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$l(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$l(key, child_ctx));
  }
  return {
    c() {
      create_component(search.$$.fragment);
      t0 = space();
      create_component(pinnedfiltertoggles.$$.fragment);
      t1 = space();
      create_component(filtermenu.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      insert(target, t0, anchor);
      mount_component(pinnedfiltertoggles, target, anchor);
      insert(target, t1, anchor);
      mount_component(filtermenu, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_changes = {};
      if (!updating_value && dirty & /*searchCriteria*/
      2) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      const pinnedfiltertoggles_changes = {};
      if (dirty & /*tabId*/
      1) pinnedfiltertoggles_changes.filterGroupName = /*tabId*/
      ctx2[0];
      if (dirty & /*$context, tabId*/
      9) pinnedfiltertoggles_changes.filters = ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx2[3].filterPins,
        /*$context*/
        ctx2[3].filterData,
        /*tabId*/
        ctx2[0]
      );
      pinnedfiltertoggles.$set(pinnedfiltertoggles_changes);
      const filtermenu_changes = {};
      if (dirty & /*tabId*/
      1) filtermenu_changes.tabId = /*tabId*/
      ctx2[0];
      filtermenu.$set(filtermenu_changes);
      if (dirty & /*utilityBarCommands*/
      32) {
        each_value_1 = ensure_array_like(
          /*utilityBarCommands*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$l, each_1_anchor, get_each_context_1$l);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(pinnedfiltertoggles.$$.fragment, local);
      transition_in(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(pinnedfiltertoggles.$$.fragment, local);
      transition_out(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(search, detaching);
      destroy_component(pinnedfiltertoggles, detaching);
      destroy_component(filtermenu, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_else_block_1$f(ctx) {
  let expandablecontainer;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  expandablecontainer = new ExpandableContainer({
    props: {
      expanded: (
        /*containerPanelExpanded*/
        ctx[14]
      ),
      class: "container-panel-wrapper " + /*containerPanelExpanded*/
      (ctx[14] ? "container-panel-expanded" : ""),
      $$slots: { default: [create_default_slot_2$y] },
      $$scope: { ctx }
    }
  });
  let each_value = ensure_array_like(
    /*inventory*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[15].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$H(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$H(key, child_ctx));
  }
  return {
    c() {
      create_component(expandablecontainer.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(expandablecontainer, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const expandablecontainer_changes = {};
      if (dirty & /*$context*/
      8) expandablecontainer_changes.expanded = /*containerPanelExpanded*/
      ctx2[14];
      if (dirty & /*$context*/
      8) expandablecontainer_changes.class = "container-panel-wrapper " + /*containerPanelExpanded*/
      (ctx2[14] ? "container-panel-expanded" : "");
      if (dirty & /*$$scope, $context, searchCriteria*/
      4194314) {
        expandablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandablecontainer.$set(expandablecontainer_changes);
      if (dirty & /*localize, inventory, $itemIdsToShow, layoutMode, searchCriteria, $context*/
      2206) {
        each_value = ensure_array_like(
          /*inventory*/
          ctx2[2]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$H, each_1_anchor, get_each_context$H);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(expandablecontainer.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(expandablecontainer.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(expandablecontainer, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block_2$E(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot_1$G] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      4194304) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_default_slot_2$y(ctx) {
  let containerpanel;
  let current;
  containerpanel = new ContainerPanel({
    props: {
      containerPanelItems: (
        /*$context*/
        ctx[3].containerPanelItems
      ),
      searchCriteria: (
        /*searchCriteria*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(containerpanel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(containerpanel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const containerpanel_changes = {};
      if (dirty & /*$context*/
      8) containerpanel_changes.containerPanelItems = /*$context*/
      ctx2[3].containerPanelItems;
      if (dirty & /*searchCriteria*/
      2) containerpanel_changes.searchCriteria = /*searchCriteria*/
      ctx2[1];
      containerpanel.$set(containerpanel_changes);
    },
    i(local) {
      if (current) return;
      transition_in(containerpanel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(containerpanel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(containerpanel, detaching);
    }
  };
}
function create_if_block_3$x(ctx) {
  let show_if = (
    /*searchCriteria*/
    ctx[1].trim() === "" && /*$context*/
    ctx[3].unlocked || /*visibleItemCount*/
    ctx[16] > 0
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_4$o(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*searchCriteria, $context, inventory, $itemIdsToShow*/
      142) show_if = /*searchCriteria*/
      ctx2[1].trim() === "" && /*$context*/
      ctx2[3].unlocked || /*visibleItemCount*/
      ctx2[16] > 0;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*searchCriteria, $context, inventory, $itemIdsToShow*/
          142) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4$o(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_4$o(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5$l, create_else_block_2$4];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*layoutMode*/
      ctx2[4] === "list"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_2$4(ctx) {
  let inventorygrid;
  let current;
  inventorygrid = new InventoryGrid({
    props: {
      items: (
        /*section*/
        ctx[15].items
      ),
      section: (
        /*section*/
        ctx[15]
      )
    }
  });
  return {
    c() {
      create_component(inventorygrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inventorygrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inventorygrid_changes = {};
      if (dirty & /*inventory*/
      4) inventorygrid_changes.items = /*section*/
      ctx2[15].items;
      if (dirty & /*inventory*/
      4) inventorygrid_changes.section = /*section*/
      ctx2[15];
      inventorygrid.$set(inventorygrid_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inventorygrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inventorygrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inventorygrid, detaching);
    }
  };
}
function create_if_block_5$l(ctx) {
  let inventorylist;
  let current;
  inventorylist = new InventoryList({
    props: {
      primaryColumnName: (
        /*localize*/
        ctx[11](
          /*section*/
          ctx[15].label
        ) + " (" + /*visibleItemCount*/
        ctx[16] + ")"
      ),
      section: (
        /*section*/
        ctx[15]
      ),
      items: (
        /*section*/
        ctx[15].items
      )
    }
  });
  return {
    c() {
      create_component(inventorylist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inventorylist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inventorylist_changes = {};
      if (dirty & /*inventory, $itemIdsToShow*/
      132) inventorylist_changes.primaryColumnName = /*localize*/
      ctx2[11](
        /*section*/
        ctx2[15].label
      ) + " (" + /*visibleItemCount*/
      ctx2[16] + ")";
      if (dirty & /*inventory*/
      4) inventorylist_changes.section = /*section*/
      ctx2[15];
      if (dirty & /*inventory*/
      4) inventorylist_changes.items = /*section*/
      ctx2[15].items;
      inventorylist.$set(inventorylist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inventorylist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inventorylist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inventorylist, detaching);
    }
  };
}
function create_each_block$H(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[15].show && create_if_block_3$x(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*section*/
        ctx[15].show
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*inventory*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$x(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot_1$G(ctx) {
  let t_value = (
    /*localize*/
    ctx[11]("TIDY5E.EmptySection") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_else_block$R(ctx) {
  let span;
  let t_value = (
    /*$context*/
    ctx[3].system.attributes.attunement.max + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "attuned-items-max svelte-o3won8");
      attr(
        span,
        "title",
        /*localize*/
        ctx[11]("TIDY5E.AttunementMax")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t_value !== (t_value = /*$context*/
      ctx2[3].system.attributes.attunement.max + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$P(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      selectOnFocus: true,
      document: (
        /*$context*/
        ctx[3].actor
      ),
      field: "system.attributes.attunement.max",
      cssClass: "attuned-items-max",
      value: (
        /*$context*/
        ctx[3].system.attributes.attunement.max
      ),
      placeholder: "0",
      title: (
        /*localize*/
        ctx[11]("TIDY5E.AttunementMax")
      ),
      disabled: !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockSensitiveFields
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*$context*/
      8) numberinput_changes.document = /*$context*/
      ctx2[3].actor;
      if (dirty & /*$context*/
      8) numberinput_changes.value = /*$context*/
      ctx2[3].system.attributes.attunement.max;
      if (dirty & /*$context*/
      8) numberinput_changes.disabled = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockSensitiveFields;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block$1h(ctx) {
  let encumbrancebar;
  let current;
  encumbrancebar = new EncumbranceBar({});
  return {
    c() {
      create_component(encumbrancebar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(encumbrancebar, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(encumbrancebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(encumbrancebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(encumbrancebar, detaching);
    }
  };
}
function create_default_slot$1e(ctx) {
  let div1;
  let div0;
  let i2;
  let t0;
  let span;
  let t1_value = (
    /*$context*/
    ctx[3].system.attributes.attunement.value + ""
  );
  let t1;
  let t2;
  let show_if;
  let current_block_type_index;
  let if_block0;
  let t3;
  let currency;
  let t4;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1$P, create_else_block$R];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty & /*$context*/
    8) show_if = null;
    if (show_if == null) show_if = !!/*$context*/
    (ctx2[3].editable && FoundryAdapter.userIsGm());
    if (show_if) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  currency = new Currency({
    props: { document: (
      /*$context*/
      ctx[3].actor
    ) }
  });
  let if_block1 = (
    /*$settingStore*/
    ctx[8].useCharacterEncumbranceBar && create_if_block$1h()
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      i2 = element("i");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = text("\n      /\n      ");
      if_block0.c();
      t3 = space();
      create_component(currency.$$.fragment);
      t4 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
      attr(i2, "class", "attunement-icon fas fa-sun svelte-o3won8");
      attr(span, "class", "attuned-items-current svelte-o3won8");
      attr(
        span,
        "title",
        /*localize*/
        ctx[11]("TIDY5E.AttunementItems")
      );
      attr(div0, "class", "attuned-items-counter svelte-o3won8");
      attr(
        div0,
        "title",
        /*localize*/
        ctx[11]("DND5E.Attunement")
      );
      toggle_class(
        div0,
        "overattuned",
        /*$context*/
        ctx[3].actor.system.attributes.attunement.value > /*$context*/
        ctx[3].actor.system.attributes.attunement.max
      );
      attr(div1, "class", "attunement-and-currency svelte-o3won8");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, i2);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div0, t2);
      if_blocks[current_block_type_index].m(div0, null);
      append(div1, t3);
      mount_component(currency, div1, null);
      insert(target, t4, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$context*/
      8) && t1_value !== (t1_value = /*$context*/
      ctx2[3].system.attributes.attunement.value + "")) set_data(t1, t1_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      if (!current || dirty & /*$context*/
      8) {
        toggle_class(
          div0,
          "overattuned",
          /*$context*/
          ctx2[3].actor.system.attributes.attunement.value > /*$context*/
          ctx2[3].actor.system.attributes.attunement.max
        );
      }
      const currency_changes = {};
      if (dirty & /*$context*/
      8) currency_changes.document = /*$context*/
      ctx2[3].actor;
      currency.$set(currency_changes);
      if (
        /*$settingStore*/
        ctx2[8].useCharacterEncumbranceBar
      ) {
        if (if_block1) {
          if (dirty & /*$settingStore*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1h();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(currency.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(currency.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t4);
        detach(if_block1_anchor);
      }
      if_blocks[current_block_type_index].d();
      destroy_component(currency);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_fragment$2H(ctx) {
  let utilitytoolbar;
  let t0;
  let div;
  let current_block_type_index;
  let if_block;
  let t1;
  let tabfooter;
  let current;
  utilitytoolbar = new UtilityToolbar({
    props: {
      $$slots: { default: [create_default_slot_3$x] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_2$E, create_else_block_1$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noItems*/
      ctx2[6] && !/*$context*/
      ctx2[3].unlocked
    ) return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 1) return get_else_ctx$1(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  tabfooter = new TabFooter({
    props: {
      mode: "vertical",
      $$slots: { default: [create_default_slot$1e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(utilitytoolbar.$$.fragment);
      t0 = space();
      div = element("div");
      if_block.c();
      t1 = space();
      create_component(tabfooter.$$.fragment);
      attr(div, "class", "tidy-inventory-container scroll-container flex-column small-gap svelte-o3won8");
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEMS_CONTAINER);
    },
    m(target, anchor) {
      mount_component(utilitytoolbar, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      insert(target, t1, anchor);
      mount_component(tabfooter, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const utilitytoolbar_changes = {};
      if (dirty & /*$$scope, utilityBarCommands, tabId, $context, searchCriteria*/
      4194347) {
        utilitytoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      utilitytoolbar.$set(utilitytoolbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(select_block_ctx(ctx2, current_block_type_index), dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block.c();
        } else {
          if_block.p(select_block_ctx(ctx2, current_block_type_index), dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      const tabfooter_changes = {};
      if (dirty & /*$$scope, $settingStore, $context*/
      4194568) {
        tabfooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabfooter.$set(tabfooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbar.$$.fragment, local);
      transition_in(if_block);
      transition_in(tabfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbar.$$.fragment, local);
      transition_out(if_block);
      transition_out(tabfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t1);
      }
      destroy_component(utilitytoolbar, detaching);
      if_blocks[current_block_type_index].d();
      destroy_component(tabfooter, detaching);
    }
  };
}
function instance$2H($$self, $$props, $$invalidate) {
  let inventory;
  let noItems;
  let utilityBarCommands;
  let $context;
  let $itemIdsToShow;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(8, $settingStore = $$value));
  let { tabId } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  let searchCriteria = "";
  const itemIdsToShow = writable(void 0);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(7, $itemIdsToShow = value));
  setContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW, itemIdsToShow);
  const localize = FoundryAdapter.localize;
  let layoutMode;
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(1, searchCriteria);
  }
  const execute_handler = (command, ev) => command.execute?.(ev.detail);
  $$self.$$set = ($$props2) => {
    if ("tabId" in $$props2) $$invalidate(0, tabId = $$props2.tabId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, tabId*/
    9) {
      $$invalidate(2, inventory = SheetSections.configureInventory($context.inventory, tabId, SheetPreferencesService.getByType($context.actor.type), TidyFlags.sectionConfig.get($context.actor)?.[tabId]));
    }
    if ($$self.$$.dirty & /*searchCriteria, $context, inventory, tabId*/
    15) {
      {
        set_store_value(
          itemIdsToShow,
          $itemIdsToShow = ItemVisibility.getItemsToShowAtDepth({
            criteria: searchCriteria,
            itemContext: $context.itemContext,
            sections: inventory,
            tabId
          }),
          $itemIdsToShow
        );
      }
    }
    if ($$self.$$.dirty & /*$context*/
    8) {
      $$invalidate(4, layoutMode = TidyFlags.inventoryGrid.get($context.actor) ? "grid" : "list");
    }
    if ($$self.$$.dirty & /*inventory*/
    4) {
      $$invalidate(6, noItems = inventory.some((section) => section.items.length > 0) === false);
    }
    if ($$self.$$.dirty & /*$context, tabId*/
    9) {
      $$invalidate(5, utilityBarCommands = $context.utilities[tabId]?.utilityToolbarCommands ?? []);
    }
  };
  return [
    tabId,
    searchCriteria,
    inventory,
    $context,
    layoutMode,
    utilityBarCommands,
    noItems,
    $itemIdsToShow,
    $settingStore,
    context,
    itemIdsToShow,
    localize,
    search_value_binding,
    execute_handler
  ];
}
class ActorInventoryTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2H, create_fragment$2H, safe_not_equal, { tabId: 0 });
  }
}
function create_fragment$2G(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      title: (
        /*ctx*/
        ctx[0]?.toggleTitle
      ),
      iconCssClass: "fas fa-book",
      active: (
        /*spell*/
        ctx[1].system.preparation.prepared
      ),
      onclick: (
        /*toggleSpellPreparation*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*ctx*/
      1) itemcontrol_changes.title = /*ctx*/
      ctx2[0]?.toggleTitle;
      if (dirty & /*spell*/
      2) itemcontrol_changes.active = /*spell*/
      ctx2[1].system.preparation.prepared;
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$2G($$self, $$props, $$invalidate) {
  let { ctx } = $$props;
  let { spell } = $$props;
  function toggleSpellPreparation() {
    const value = FoundryAdapter.getProperty(spell, "system.preparation.prepared");
    spell.update({ "system.preparation.prepared": !value });
  }
  $$self.$$set = ($$props2) => {
    if ("ctx" in $$props2) $$invalidate(0, ctx = $$props2.ctx);
    if ("spell" in $$props2) $$invalidate(1, spell = $$props2.spell);
  };
  return [ctx, spell, toggleSpellPreparation];
}
class SpellPrepareControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2G, create_fragment$2G, safe_not_equal, { ctx: 0, spell: 1 });
  }
}
class SpellSchool {
  static _iconsMap = {
    abj: "ra ra-shield",
    con: "ra ra-tentacle",
    div: "ra ra-crystal-ball",
    enc: "ra ra-aware",
    evo: "ra ra-burning-meteor",
    ill: "ra ra-bleeding-eye",
    nec: "ra ra-skull",
    trs: "ra ra-cycle"
  };
  static fallbackIcon = "fas fa-hat-wizard";
  static getIcon(schoolKey) {
    if (SettingsProvider.settings.useTidySpellSchoolIcons.get()) {
      return SpellSchool._iconsMap[schoolKey] ?? SpellSchool.fallbackIcon;
    }
    const dnd5eConfigIcon = CONFIG.DND5E.spellSchools[schoolKey]?.icon;
    if (dnd5eConfigIcon) {
      return {
        iconSrc: dnd5eConfigIcon
      };
    }
    return SpellSchool.fallbackIcon;
  }
  static setIcon(schoolKey, iconClass) {
    SpellSchool._iconsMap[schoolKey] = iconClass;
  }
}
function get_each_context$G(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[10].itemContext[
      /*spell*/
      child_ctx[19].id
    ]
  );
  child_ctx[20] = constants_0;
  const constants_1 = FoundryAdapter.getSpellImageUrl(
    /*$context*/
    child_ctx[10],
    /*spell*/
    child_ctx[19]
  );
  child_ctx[21] = constants_1;
  return child_ctx;
}
function get_if_ctx$b(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = SpellSchool.getIcon(
    /*spell*/
    child_ctx[19].system.school
  );
  child_ctx[25] = constants_0;
  return child_ctx;
}
function create_if_block_11$6(ctx) {
  let spellslotmanagement;
  let current;
  spellslotmanagement = new SpellSlotManagement({ props: { section: (
    /*section*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(spellslotmanagement.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellslotmanagement, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellslotmanagement_changes = {};
      if (dirty & /*section*/
      1) spellslotmanagement_changes.section = /*section*/
      ctx2[0];
      spellslotmanagement.$set(spellslotmanagement_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellslotmanagement.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellslotmanagement.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellslotmanagement, detaching);
    }
  };
}
function create_default_slot_16$2(ctx) {
  let span;
  let t0_value = (
    /*localize*/
    ctx[16](
      /*section*/
      ctx[0].label
    ) + ""
  );
  let t0;
  let t1;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[0].usesSlots && create_if_block_11$6(ctx)
  );
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "spell-primary-column-label svelte-1xjjmy5");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*section*/
      1) && t0_value !== (t0_value = /*localize*/
      ctx2[16](
        /*section*/
        ctx2[0].label
      ) + "")) set_data(t0, t0_value);
      if (
        /*section*/
        ctx2[0].usesSlots
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*section*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_11$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot_15$3(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-mortar-pestle");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_10$7(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: spellSchoolBaseWidth,
      title: (
        /*localize*/
        ctx[16]("DND5E.SpellSchool")
      ),
      $$slots: { default: [create_default_slot_14$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_14$6(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-hat-wizard");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot_13$8(ctx) {
  let t_value = (
    /*localize*/
    ctx[16]("DND5E.Target") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_9$9(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: "4.375rem",
      title: (
        /*localize*/
        ctx[16]("DND5E.Range")
      ),
      $$slots: { default: [create_default_slot_12$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_12$9(ctx) {
  let t_value = (
    /*localize*/
    ctx[16]("DND5E.Range") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_11$a(ctx) {
  let t_value = (
    /*localize*/
    ctx[16]("DND5E.Usage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_8$a(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[11]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      2048) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[11];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_10$e(ctx) {
  let itemtablecolumn0;
  let t0;
  let itemtablecolumn1;
  let t1;
  let t2;
  let itemtablecolumn2;
  let t3;
  let t4;
  let itemtablecolumn3;
  let t5;
  let if_block2_anchor;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_16$2] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: (
        /*spellComponentsBaseWidth*/
        ctx[6]
      ),
      title: (
        /*localize*/
        ctx[16]("DND5E.SpellComponents")
      ),
      $$slots: { default: [create_default_slot_15$3] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*includeSchool*/
    ctx[4] && create_if_block_10$7(ctx)
  );
  itemtablecolumn2 = new ItemTableColumn({
    props: {
      baseWidth: (
        /*targetBaseWidth*/
        ctx[7]
      ),
      title: (
        /*localize*/
        ctx[16]("DND5E.SpellTarget")
      ),
      $$slots: { default: [create_default_slot_13$8] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*includeRange*/
    ctx[5] && create_if_block_9$9(ctx)
  );
  itemtablecolumn3 = new ItemTableColumn({
    props: {
      title: (
        /*localize*/
        ctx[16]("DND5E.SpellUsage")
      ),
      baseWidth: (
        /*usageBaseWidth*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot_11$a] },
      $$scope: { ctx }
    }
  });
  let if_block2 = (
    /*$context*/
    ctx[10].editable && /*$context*/
    ctx[10].useClassicControls && create_if_block_8$a(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      create_component(itemtablecolumn2.$$.fragment);
      t3 = space();
      if (if_block1) if_block1.c();
      t4 = space();
      create_component(itemtablecolumn3.$$.fragment);
      t5 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t1, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      insert(target, t3, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t4, anchor);
      mount_component(itemtablecolumn3, target, anchor);
      insert(target, t5, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope, section*/
      67108865) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty & /*spellComponentsBaseWidth*/
      64) itemtablecolumn1_changes.baseWidth = /*spellComponentsBaseWidth*/
      ctx2[6];
      if (dirty & /*$$scope*/
      67108864) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
      if (
        /*includeSchool*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*includeSchool*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemtablecolumn2_changes = {};
      if (dirty & /*targetBaseWidth*/
      128) itemtablecolumn2_changes.baseWidth = /*targetBaseWidth*/
      ctx2[7];
      if (dirty & /*$$scope*/
      67108864) {
        itemtablecolumn2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn2.$set(itemtablecolumn2_changes);
      if (
        /*includeRange*/
        ctx2[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*includeRange*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_9$9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t4.parentNode, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const itemtablecolumn3_changes = {};
      if (dirty & /*usageBaseWidth*/
      256) itemtablecolumn3_changes.baseWidth = /*usageBaseWidth*/
      ctx2[8];
      if (dirty & /*$$scope*/
      67108864) {
        itemtablecolumn3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn3.$set(itemtablecolumn3_changes);
      if (
        /*$context*/
        ctx2[10].editable && /*$context*/
        ctx2[10].useClassicControls
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          1024) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_8$a(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemtablecolumn2.$$.fragment, local);
      transition_in(if_block1);
      transition_in(itemtablecolumn3.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemtablecolumn2.$$.fragment, local);
      transition_out(if_block1);
      transition_out(itemtablecolumn3.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(if_block2_anchor);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemtablecolumn2, detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(itemtablecolumn3, detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_header_slot$f(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_10$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, classicControlsColumnWidth, $context, usageBaseWidth, includeRange, targetBaseWidth, includeSchool, spellComponentsBaseWidth, section*/
      67112433) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_after_roll_button_slot(ctx) {
  let concentrationoverlayicon;
  let current;
  concentrationoverlayicon = new ConcentrationOverlayIcon({ props: { ctx: (
    /*ctx*/
    ctx[20]
  ) } });
  return {
    c() {
      create_component(concentrationoverlayicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(concentrationoverlayicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const concentrationoverlayicon_changes = {};
      if (dirty & /*$context, spells*/
      1026) concentrationoverlayicon_changes.ctx = /*ctx*/
      ctx2[20];
      concentrationoverlayicon.$set(concentrationoverlayicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(concentrationoverlayicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(concentrationoverlayicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(concentrationoverlayicon, detaching);
    }
  };
}
function create_default_slot_9$e(ctx) {
  let span;
  let t_value = (
    /*spell*/
    ctx[19].name + ""
  );
  let t2;
  let span_data_tidy_item_name_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "truncate");
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*spell*/
      ctx[19].name);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*spells*/
      2 && t_value !== (t_value = /*spell*/
      ctx2[19].name + "")) set_data(t2, t_value);
      if (dirty & /*spells*/
      2 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*spell*/
      ctx2[19].name)) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_8$f(ctx) {
  let itemusebutton;
  let t2;
  let itemname;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[10].editable,
      item: (
        /*spell*/
        ctx[19]
      ),
      imgUrlOverride: (
        /*spellImgUrl*/
        ctx[21]
      ),
      showDiceIconOnHover: !/*ctx*/
      ctx[20].concentration,
      $$slots: {
        "after-roll-button": [create_after_roll_button_slot]
      },
      $$scope: { ctx }
    }
  });
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[17](
        /*toggleSummary*/
        ctx[24]
      )
    );
  }
  itemname = new ItemName({
    props: {
      item: (
        /*spell*/
        ctx[19]
      ),
      $$slots: { default: [create_default_slot_9$e] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t2 = space();
      create_component(itemname.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemname, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty & /*$context*/
      1024) itemusebutton_changes.disabled = !/*$context*/
      ctx[10].editable;
      if (dirty & /*spells*/
      2) itemusebutton_changes.item = /*spell*/
      ctx[19];
      if (dirty & /*$context, spells*/
      1026) itemusebutton_changes.imgUrlOverride = /*spellImgUrl*/
      ctx[21];
      if (dirty & /*$context, spells*/
      1026) itemusebutton_changes.showDiceIconOnHover = !/*ctx*/
      ctx[20].concentration;
      if (dirty & /*$$scope, $context, spells*/
      67109890) {
        itemusebutton_changes.$$scope = { dirty, ctx };
      }
      itemusebutton.$set(itemusebutton_changes);
      const itemname_changes = {};
      if (dirty & /*spells*/
      2) itemname_changes.item = /*spell*/
      ctx[19];
      if (dirty & /*$$scope, spells*/
      67108866) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(itemname.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(itemname.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemusebutton, detaching);
      destroy_component(itemname, detaching);
    }
  };
}
function create_if_block_7$d(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_7$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, spells*/
      67108866) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_7$h(ctx) {
  let itemuses;
  let current;
  itemuses = new ItemUses({ props: { item: (
    /*spell*/
    ctx[19]
  ) } });
  return {
    c() {
      create_component(itemuses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemuses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemuses_changes = {};
      if (dirty & /*spells*/
      2) itemuses_changes.item = /*spell*/
      ctx2[19];
      itemuses.$set(itemuses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemuses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemuses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemuses, detaching);
    }
  };
}
function create_if_block_6$f(ctx) {
  let inlinefavoriteicon;
  let current;
  inlinefavoriteicon = new InlineFavoriteIcon({});
  return {
    c() {
      create_component(inlinefavoriteicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinefavoriteicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(inlinefavoriteicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinefavoriteicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinefavoriteicon, detaching);
    }
  };
}
function create_default_slot_6$j(ctx) {
  let spellcomponents;
  let current;
  spellcomponents = new SpellComponents({ props: { spell: (
    /*spell*/
    ctx[19]
  ) } });
  return {
    c() {
      create_component(spellcomponents.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellcomponents, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellcomponents_changes = {};
      if (dirty & /*spells*/
      2) spellcomponents_changes.spell = /*spell*/
      ctx2[19];
      spellcomponents.$set(spellcomponents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellcomponents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellcomponents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellcomponents, detaching);
    }
  };
}
function create_if_block_4$n(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: spellSchoolBaseWidth,
      title: (
        /*spell*/
        ctx[19].labels.school ?? ""
      ),
      $$slots: { default: [create_default_slot_5$o] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*spells*/
      2) itemtablecell_changes.title = /*spell*/
      ctx2[19].labels.school ?? "";
      if (dirty & /*$$scope, spells*/
      67108866) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_else_block_1$e(ctx) {
  let dnd5eicon;
  let div;
  let current;
  dnd5eicon = new Dnd5eIcon({ props: { src: (
    /*icon*/
    ctx[25].iconSrc
  ) } });
  return {
    c() {
      div = element("div");
      create_component(dnd5eicon.$$.fragment);
      set_style(div, "display", "contents");
      set_style(div, "--icon-fill", "var(--t5e-spell-school-icon-fill)");
      set_style(div, "--icon-width", "var(--t5e-spell-school-icon-width)");
      set_style(div, "--icon-height", "var(--t5e-spell-school-icon-height)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(dnd5eicon, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eicon_changes = {};
      if (dirty & /*spells*/
      2) dnd5eicon_changes.src = /*icon*/
      ctx2[25].iconSrc;
      dnd5eicon.$set(dnd5eicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(dnd5eicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching && dnd5eicon) detach(div);
      destroy_component(dnd5eicon, detaching);
    }
  };
}
function create_if_block_5$k(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = "spell-school-icon " + /*icon*/
      ctx[25] + " svelte-1xjjmy5");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*spells*/
      2 && i_class_value !== (i_class_value = "spell-school-icon " + /*icon*/
      ctx2[25] + " svelte-1xjjmy5")) {
        attr(i2, "class", i_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot_5$o(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5$k, create_else_block_1$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*icon*/
    ctx2[25] === "string") return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$Q(ctx) {
  let t_value = (
    /*localize*/
    ctx[16]("DND5E.None") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_3$w(ctx) {
  let t_value = (
    /*spell*/
    ctx[19].labels.target + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*spells*/
      2 && t_value !== (t_value = /*spell*/
      ctx2[19].labels.target + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_4$s(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*spell*/
      ctx2[19].labels.target
    ) return create_if_block_3$w;
    return create_else_block$Q;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block_2$D(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "4.375rem",
      title: (
        /*localize*/
        ctx[16]("DND5E.Range") + ": " + /*spell*/
        ctx[19].labels.range
      ),
      $$slots: { default: [create_default_slot_3$w] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*spells*/
      2) itemtablecell_changes.title = /*localize*/
      ctx2[16]("DND5E.Range") + ": " + /*spell*/
      ctx2[19].labels.range;
      if (dirty & /*$$scope, spells*/
      67108866) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_3$w(ctx) {
  let t_value = (
    /*spell*/
    ctx[19].labels.range + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*spells*/
      2 && t_value !== (t_value = /*spell*/
      ctx2[19].labels.range + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$x(ctx) {
  let t_value = (
    /*spell*/
    ctx[19].labels.activation + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*spells*/
      2 && t_value !== (t_value = /*spell*/
      ctx2[19].labels.activation + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$O(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_1$F] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      2048) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[11];
      if (dirty & /*$$scope, controls, spells, $context*/
      67110402) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_1$F(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[9]
      ),
      params: {
        item: (
          /*spell*/
          ctx[19]
        ),
        ctx: (
          /*ctx*/
          ctx[20]
        )
      }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      512) classiccontrols_changes.controls = /*controls*/
      ctx2[9];
      if (dirty & /*spells, $context*/
      1026) classiccontrols_changes.params = {
        item: (
          /*spell*/
          ctx2[19]
        ),
        ctx: (
          /*ctx*/
          ctx2[20]
        )
      };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot$1d(ctx) {
  let itemtablecell0;
  let t0;
  let t1;
  let t2;
  let itemtablecell1;
  let t3;
  let t4;
  let itemtablecell2;
  let t5;
  let t6;
  let itemtablecell3;
  let t7;
  let if_block4_anchor;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_8$f] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*spell*/
    ctx[19].hasLimitedUses && create_if_block_7$d(ctx)
  );
  let if_block1 = (
    /*allowFavorites*/
    ctx[2] && /*$settingStore*/
    ctx[13].showIconsNextToTheItemName && "favoriteId" in /*ctx*/
    ctx[20] && !!/*ctx*/
    ctx[20].favoriteId && create_if_block_6$f()
  );
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: (
        /*spellComponentsBaseWidth*/
        ctx[6]
      ),
      cssClass: "no-gap",
      $$slots: { default: [create_default_slot_6$j] },
      $$scope: { ctx }
    }
  });
  let if_block2 = (
    /*includeSchool*/
    ctx[4] && create_if_block_4$n(get_if_ctx$b(ctx))
  );
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: (
        /*targetBaseWidth*/
        ctx[7]
      ),
      title: (
        /*localize*/
        ctx[16]("DND5E.Target") + ": " + /*spell*/
        ctx[19].labels.target
      ),
      $$slots: { default: [create_default_slot_4$s] },
      $$scope: { ctx }
    }
  });
  let if_block3 = (
    /*includeRange*/
    ctx[5] && create_if_block_2$D(ctx)
  );
  itemtablecell3 = new ItemTableCell({
    props: {
      baseWidth: (
        /*usageBaseWidth*/
        ctx[8]
      ),
      title: (
        /*localize*/
        ctx[16]("DND5E.SpellUsage")
      ),
      $$slots: { default: [create_default_slot_2$x] },
      $$scope: { ctx }
    }
  });
  let if_block4 = (
    /*$context*/
    ctx[10].editable && /*$context*/
    ctx[10].useClassicControls && create_if_block_1$O(ctx)
  );
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      create_component(itemtablecell1.$$.fragment);
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      create_component(itemtablecell2.$$.fragment);
      t5 = space();
      if (if_block3) if_block3.c();
      t6 = space();
      create_component(itemtablecell3.$$.fragment);
      t7 = space();
      if (if_block4) if_block4.c();
      if_block4_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t4, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t5, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t6, anchor);
      mount_component(itemtablecell3, target, anchor);
      insert(target, t7, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, if_block4_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*$$scope, spells, toggleSummary, $context*/
      83887106) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      if (
        /*spell*/
        ctx2[19].hasLimitedUses
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*spells*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7$d(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*allowFavorites*/
        ctx2[2] && /*$settingStore*/
        ctx2[13].showIconsNextToTheItemName && "favoriteId" in /*ctx*/
        ctx2[20] && !!/*ctx*/
        ctx2[20].favoriteId
      ) {
        if (if_block1) {
          if (dirty & /*allowFavorites, $settingStore, $context, spells*/
          9222) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6$f();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const itemtablecell1_changes = {};
      if (dirty & /*spellComponentsBaseWidth*/
      64) itemtablecell1_changes.baseWidth = /*spellComponentsBaseWidth*/
      ctx2[6];
      if (dirty & /*$$scope, spells*/
      67108866) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      if (
        /*includeSchool*/
        ctx2[4]
      ) {
        if (if_block2) {
          if_block2.p(get_if_ctx$b(ctx2), dirty);
          if (dirty & /*includeSchool*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$n(get_if_ctx$b(ctx2));
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const itemtablecell2_changes = {};
      if (dirty & /*targetBaseWidth*/
      128) itemtablecell2_changes.baseWidth = /*targetBaseWidth*/
      ctx2[7];
      if (dirty & /*spells*/
      2) itemtablecell2_changes.title = /*localize*/
      ctx2[16]("DND5E.Target") + ": " + /*spell*/
      ctx2[19].labels.target;
      if (dirty & /*$$scope, spells*/
      67108866) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
      if (
        /*includeRange*/
        ctx2[5]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*includeRange*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2$D(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t6.parentNode, t6);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      const itemtablecell3_changes = {};
      if (dirty & /*usageBaseWidth*/
      256) itemtablecell3_changes.baseWidth = /*usageBaseWidth*/
      ctx2[8];
      if (dirty & /*$$scope, spells*/
      67108866) {
        itemtablecell3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell3.$set(itemtablecell3_changes);
      if (
        /*$context*/
        ctx2[10].editable && /*$context*/
        ctx2[10].useClassicControls
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$context*/
          1024) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1$O(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(if_block2);
      transition_in(itemtablecell2.$$.fragment, local);
      transition_in(if_block3);
      transition_in(itemtablecell3.$$.fragment, local);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(if_block2);
      transition_out(itemtablecell2.$$.fragment, local);
      transition_out(if_block3);
      transition_out(itemtablecell3.$$.fragment, local);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(if_block4_anchor);
      }
      destroy_component(itemtablecell0, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(itemtablecell1, detaching);
      if (if_block2) if_block2.d(detaching);
      destroy_component(itemtablecell2, detaching);
      if (if_block3) if_block3.d(detaching);
      destroy_component(itemtablecell3, detaching);
      if (if_block4) if_block4.d(detaching);
    }
  };
}
function create_each_block$G(key_1, ctx) {
  let first;
  let itemtablerow;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[18](
        /*spell*/
        ctx[19],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      item: (
        /*spell*/
        ctx[19]
      ),
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*spell*/
          ctx[19].uuid
        )
      },
      cssClass: FoundryAdapter.getSpellRowClasses(
        /*spell*/
        ctx[19]
      ),
      hidden: !!/*$itemIdsToShow*/
      ctx[12] && !/*$itemIdsToShow*/
      ctx[12].has(
        /*spell*/
        ctx[19].id
      ),
      $$slots: {
        default: [
          create_default_slot$1d,
          ({ toggleSummary }) => ({ 24: toggleSummary }),
          ({ toggleSummary }) => toggleSummary ? 16777216 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*spells*/
      2) itemtablerow_changes.item = /*spell*/
      ctx[19];
      if (dirty & /*spells*/
      2) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*spell*/
          ctx[19].uuid
        )
      };
      if (dirty & /*spells*/
      2) itemtablerow_changes.cssClass = FoundryAdapter.getSpellRowClasses(
        /*spell*/
        ctx[19]
      );
      if (dirty & /*$itemIdsToShow, spells*/
      4098) itemtablerow_changes.hidden = !!/*$itemIdsToShow*/
      ctx[12] && !/*$itemIdsToShow*/
      ctx[12].has(
        /*spell*/
        ctx[19].id
      );
      if (dirty & /*$$scope, classicControlsColumnWidth, controls, spells, $context, usageBaseWidth, includeRange, targetBaseWidth, includeSchool, spellComponentsBaseWidth, allowFavorites, $settingStore, toggleSummary*/
      83898358) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_if_block$1g(ctx) {
  let itemtablefooter;
  let current;
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[10].actor
      ),
      section: (
        /*section*/
        ctx[0]
      ),
      canCreate: (
        /*section*/
        ctx[0].canCreate
      ),
      isItem: true
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablefooter_changes = {};
      if (dirty & /*$context*/
      1024) itemtablefooter_changes.actor = /*$context*/
      ctx2[10].actor;
      if (dirty & /*section*/
      1) itemtablefooter_changes.section = /*section*/
      ctx2[0];
      if (dirty & /*section*/
      1) itemtablefooter_changes.canCreate = /*section*/
      ctx2[0].canCreate;
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$e(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let if_block_anchor;
  let current;
  let each_value = ensure_array_like(
    /*spells*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*spell*/
    ctx2[19].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$G(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$G(key, child_ctx));
  }
  let if_block = (
    /*$context*/
    ctx[10].unlocked && create_if_block$1g(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*spells, $itemIdsToShow, classicControlsColumnWidth, controls, $context, usageBaseWidth, localize, includeRange, targetBaseWidth, spellSchoolBaseWidth, includeSchool, spellComponentsBaseWidth, allowFavorites, $settingStore, toggleSummary*/
      16859126) {
        each_value = ensure_array_like(
          /*spells*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t2.parentNode, outro_and_destroy_block, create_each_block$G, t2, get_each_context$G);
        check_outros();
      }
      if (
        /*$context*/
        ctx2[10].unlocked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$2F(ctx) {
  let section_1;
  let itemtable;
  let section_1_class_value;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[0].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[0].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$e],
        header: [create_header_slot$f]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section_1 = element("section");
      create_component(itemtable.$$.fragment);
      attr(section_1, "class", section_1_class_value = "spellbook-list-section " + /*cssClass*/
      ctx[3] + " svelte-1xjjmy5");
    },
    m(target, anchor) {
      insert(target, section_1, anchor);
      mount_component(itemtable, section_1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*section*/
      1) itemtable_changes.key = /*section*/
      ctx2[0].key;
      if (dirty & /*section*/
      1) itemtable_changes["data-custom-section"] = /*section*/
      ctx2[0].custom ? true : null;
      if (dirty & /*$$scope, $context, section, spells, $itemIdsToShow, classicControlsColumnWidth, controls, usageBaseWidth, includeRange, targetBaseWidth, includeSchool, spellComponentsBaseWidth, allowFavorites, $settingStore*/
      67125239) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
      if (!current || dirty & /*cssClass*/
      8 && section_1_class_value !== (section_1_class_value = "spellbook-list-section " + /*cssClass*/
      ctx2[3] + " svelte-1xjjmy5")) {
        attr(section_1, "class", section_1_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section_1);
      }
      destroy_component(itemtable);
    }
  };
}
var spellSchoolBaseWidth = "2rem";
function instance$2F($$self, $$props, $$invalidate) {
  let classicControlsColumnWidth;
  let $context;
  let $itemIdsToShow;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(13, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(10, $context = value));
  let { section } = $$props;
  let { spells } = $$props;
  let { allowFavorites = true } = $$props;
  let { cssClass = null } = $$props;
  let { includeSchool = true } = $$props;
  let { includeRange = true } = $$props;
  let { spellComponentsBaseWidth = "3.75rem" } = $$props;
  let { targetBaseWidth = "7.5rem" } = $$props;
  let { usageBaseWidth = "7.5rem" } = $$props;
  let itemIdsToShow = getContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(12, $itemIdsToShow = value));
  let controls = [];
  const localize = FoundryAdapter.localize;
  declareLocation("spellbook-list-view");
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (spell, event) => FoundryAdapter.editOnMiddleClick(event.detail, spell);
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
    if ("spells" in $$props2) $$invalidate(1, spells = $$props2.spells);
    if ("allowFavorites" in $$props2) $$invalidate(2, allowFavorites = $$props2.allowFavorites);
    if ("cssClass" in $$props2) $$invalidate(3, cssClass = $$props2.cssClass);
    if ("includeSchool" in $$props2) $$invalidate(4, includeSchool = $$props2.includeSchool);
    if ("includeRange" in $$props2) $$invalidate(5, includeRange = $$props2.includeRange);
    if ("spellComponentsBaseWidth" in $$props2) $$invalidate(6, spellComponentsBaseWidth = $$props2.spellComponentsBaseWidth);
    if ("targetBaseWidth" in $$props2) $$invalidate(7, targetBaseWidth = $$props2.targetBaseWidth);
    if ("usageBaseWidth" in $$props2) $$invalidate(8, usageBaseWidth = $$props2.usageBaseWidth);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*allowFavorites, controls, $context*/
    1540) {
      {
        $$invalidate(9, controls = [
          {
            component: SpellPrepareControl,
            props: ({ item, ctx }) => ({ spell: item, ctx }),
            visible: ({ item }) => FoundryAdapter.canPrepareSpell(item)
          }
        ]);
        if (allowFavorites) {
          controls.push({
            component: ItemFavoriteControl,
            props: ({ item }) => ({ item })
          });
        }
        controls.push({
          component: ItemEditControl,
          props: ({ item }) => ({ item })
        });
        if ($context.unlocked) {
          controls.push({
            component: ItemDeleteControl,
            props: ({ item }) => ({ item })
          });
        }
        if ($context.useActionsFeature) {
          controls.push({
            component: ActionFilterOverrideControl,
            props: ({ item }) => ({ item })
          });
        }
      }
    }
    if ($$self.$$.dirty & /*controls*/
    512) {
      $$invalidate(11, classicControlsColumnWidth = `${controls.length * 1.25}rem`);
    }
  };
  return [
    section,
    spells,
    allowFavorites,
    cssClass,
    includeSchool,
    includeRange,
    spellComponentsBaseWidth,
    targetBaseWidth,
    usageBaseWidth,
    controls,
    $context,
    classicControlsColumnWidth,
    $itemIdsToShow,
    $settingStore,
    context,
    itemIdsToShow,
    localize,
    toggle_handler,
    mousedown_handler
  ];
}
class SpellbookList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2F, create_fragment$2F, safe_not_equal, {
      section: 0,
      spells: 1,
      allowFavorites: 2,
      cssClass: 3,
      includeSchool: 4,
      includeRange: 5,
      spellComponentsBaseWidth: 6,
      targetBaseWidth: 7,
      usageBaseWidth: 8
    });
  }
}
function create_fragment$2E(ctx) {
  let select;
  let select_data_tooltip_value;
  let select_disabled_value;
  let select_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  let select_levels = [
    { id: (
      /*id*/
      ctx[3]
    ) },
    {
      "data-tooltip": select_data_tooltip_value = /*activeEffectApplied*/
      ctx[7] ? (
        /*overrideTooltip*/
        ctx[6]
      ) : (
        /*tooltip*/
        ctx[0]
      )
    },
    { title: (
      /*title*/
      ctx[4]
    ) },
    /*datasetAttributes*/
    ctx[9],
    {
      disabled: select_disabled_value = /*disabled*/
      ctx[5] || /*activeEffectApplied*/
      ctx[7]
    },
    { "data-tidy-field": (
      /*field*/
      ctx[1]
    ) },
    {
      class: select_class_value = /*$$props*/
      ctx[12].class ?? ""
    }
  ];
  let select_data = {};
  for (let i2 = 0; i2 < select_levels.length; i2 += 1) {
    select_data = assign(select_data, select_levels[i2]);
  }
  return {
    c() {
      select = element("select");
      if (default_slot) default_slot.c();
      set_attributes(select, select_data);
      if (
        /*draftValue*/
        ctx[8] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[20].call(select)
      ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      "value" in select_data && (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus) select.focus();
      select_option(
        select,
        /*draftValue*/
        ctx[8],
        true
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[20]
          ),
          listen(select, "change", function() {
            if (is_function(
              /*document*/
              ctx[2] && /*saveChange*/
              ctx[10]
            )) /*document*/
            (ctx[2] && /*saveChange*/
            ctx[10]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        (!current || dirty & /*id*/
        8) && { id: (
          /*id*/
          ctx[3]
        ) },
        (!current || dirty & /*activeEffectApplied, overrideTooltip, tooltip*/
        193 && select_data_tooltip_value !== (select_data_tooltip_value = /*activeEffectApplied*/
        ctx[7] ? (
          /*overrideTooltip*/
          ctx[6]
        ) : (
          /*tooltip*/
          ctx[0]
        ))) && {
          "data-tooltip": select_data_tooltip_value
        },
        (!current || dirty & /*title*/
        16) && { title: (
          /*title*/
          ctx[4]
        ) },
        dirty & /*datasetAttributes*/
        512 && /*datasetAttributes*/
        ctx[9],
        (!current || dirty & /*disabled, activeEffectApplied*/
        160 && select_disabled_value !== (select_disabled_value = /*disabled*/
        ctx[5] || /*activeEffectApplied*/
        ctx[7])) && { disabled: select_disabled_value },
        (!current || dirty & /*field*/
        2) && { "data-tidy-field": (
          /*field*/
          ctx[1]
        ) },
        (!current || dirty & /*$$props*/
        4096 && select_class_value !== (select_class_value = /*$$props*/
        ctx[12].class ?? "")) && { class: select_class_value }
      ]));
      if (dirty & /*id, activeEffectApplied, overrideTooltip, tooltip, title, datasetAttributes, disabled, field, $$props*/
      4859 && "value" in select_data) (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (dirty & /*draftValue*/
      256) {
        select_option(
          select,
          /*draftValue*/
          ctx[8]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2E($$self, $$props, $$invalidate) {
  let draftValue;
  let datasetAttributes;
  let activeEffectApplied;
  let isEnchanted;
  let overrideTooltip;
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { value } = $$props;
  let { tooltip = null } = $$props;
  let { field } = $$props;
  let { document: document2 } = $$props;
  let { id = null } = $$props;
  let { dataset = null } = $$props;
  let { title = null } = $$props;
  let { disabled = false } = $$props;
  let { blankValue = null } = $$props;
  function saveChange(event) {
    const targetValue = event.currentTarget.value;
    document2.update({
      [field]: targetValue !== "" ? targetValue : blankValue
    });
    $$invalidate(8, draftValue = value?.toString() ?? "");
  }
  const context = getContext("context");
  component_subscribe($$self, context, (value2) => $$invalidate(17, $context = value2));
  const localize = FoundryAdapter.localize;
  function select_change_handler() {
    draftValue = select_value(this);
    $$invalidate(8, draftValue), $$invalidate(13, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props) $$invalidate(13, value = $$new_props.value);
    if ("tooltip" in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
    if ("field" in $$new_props) $$invalidate(1, field = $$new_props.field);
    if ("document" in $$new_props) $$invalidate(2, document2 = $$new_props.document);
    if ("id" in $$new_props) $$invalidate(3, id = $$new_props.id);
    if ("dataset" in $$new_props) $$invalidate(14, dataset = $$new_props.dataset);
    if ("title" in $$new_props) $$invalidate(4, title = $$new_props.title);
    if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    if ("blankValue" in $$new_props) $$invalidate(15, blankValue = $$new_props.blankValue);
    if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    8192) {
      $$invalidate(8, draftValue = value?.toString() ?? "");
    }
    if ($$self.$$.dirty & /*dataset*/
    16384) {
      $$invalidate(9, datasetAttributes = buildDataset(dataset));
    }
    if ($$self.$$.dirty & /*document, field*/
    6) {
      $$invalidate(7, activeEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(document2, field));
    }
    if ($$self.$$.dirty & /*$context, field*/
    131074) {
      $$invalidate(16, isEnchanted = $context.itemOverrides instanceof Set && $context.itemOverrides.has(field));
    }
    if ($$self.$$.dirty & /*isEnchanted*/
    65536) {
      $$invalidate(6, overrideTooltip = isEnchanted ? localize("DND5E.Enchantment.Warning.Override") : localize("DND5E.ActiveEffectOverrideWarning"));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    tooltip,
    field,
    document2,
    id,
    title,
    disabled,
    overrideTooltip,
    activeEffectApplied,
    draftValue,
    datasetAttributes,
    saveChange,
    context,
    $$props,
    value,
    dataset,
    blankValue,
    isEnchanted,
    $context,
    $$scope,
    slots,
    select_change_handler
  ];
}
class Select extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2E, create_fragment$2E, safe_not_equal, {
      value: 13,
      tooltip: 0,
      field: 1,
      document: 2,
      id: 3,
      dataset: 14,
      title: 4,
      disabled: 5,
      blankValue: 15
    });
  }
}
function get_each_context$F(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_each_block$F(ctx) {
  let button;
  let t_value = (
    /*localize*/
    ctx[3](
      /*formula*/
      ctx[6].label
    ) + ""
  );
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*formula*/
        ctx[6]
      )
    );
  }
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "highlight-on-hover svelte-1prypru");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$context*/
      1 && t_value !== (t_value = /*localize*/
      ctx[3](
        /*formula*/
        ctx[6].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2D(ctx) {
  let section;
  let div0;
  let label;
  let t0_value = (
    /*localize*/
    ctx[3]("DND5E.Formula") + ""
  );
  let t0;
  let t1;
  let input;
  let t2;
  let div1;
  let h3;
  let t4;
  let p0;
  let t5;
  let p1;
  let a2;
  let t7;
  let button;
  let i2;
  let t8;
  let t9_value = (
    /*localize*/
    ctx[3]("Save") + ""
  );
  let t9;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[0].formulas
  );
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$F(get_each_context$F(ctx, each_value, i3));
  }
  return {
    c() {
      section = element("section");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      t2 = space();
      div1 = element("div");
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[3]("TIDY5E.MaxPreparedSpellsConfig.ExamplesHeader")}`;
      t4 = space();
      p0 = element("p");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t5 = space();
      p1 = element("p");
      a2 = element("a");
      a2.textContent = `${/*localize*/
      ctx[3]("TIDY5E.MaxPreparedSpellsConfig.MoreFormulas")}`;
      t7 = space();
      button = element("button");
      i2 = element("i");
      t8 = space();
      t9 = text(t9_value);
      attr(label, "for", "max-prepared-spells-edit-" + /*appId*/
      ctx[1]);
      attr(input, "id", "max-prepared-spells-edit-" + /*appId*/
      ctx[1]);
      attr(input, "type", "text");
      attr(input, "placeholder", "0");
      attr(div0, "class", "form-field");
      attr(p0, "class", "flex-row flex-wrap sample-formulas svelte-1prypru");
      attr(a2, "target", "_blank");
      attr(a2, "href", "https://github.com/kgar/foundry-vtt-tidy-5e-sheets/wiki/Max-Prepared-Spells-Formulas");
      attr(div1, "role", "presentation");
      attr(i2, "class", "far fa-save");
      attr(button, "type", "submit");
      attr(section, "class", "flex-column");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div0);
      append(div0, label);
      append(label, t0);
      append(div0, t1);
      append(div0, input);
      set_input_value(
        input,
        /*$context*/
        ctx[0].maxPreparedSpells
      );
      append(section, t2);
      append(section, div1);
      append(div1, h3);
      append(div1, t4);
      append(div1, p0);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(p0, null);
        }
      }
      append(div1, t5);
      append(div1, p1);
      append(p1, a2);
      append(section, t7);
      append(section, button);
      append(button, i2);
      append(button, t8);
      append(button, t9);
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      1 && input.value !== /*$context*/
      ctx2[0].maxPreparedSpells) {
        set_input_value(
          input,
          /*$context*/
          ctx2[0].maxPreparedSpells
        );
      }
      if (dirty & /*$context, localize*/
      9) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[0].formulas
        );
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$F(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block$F(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(p0, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$2D($$self, $$props, $$invalidate) {
  let $context;
  const appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function input_input_handler() {
    $context.maxPreparedSpells = this.value;
    context.set($context);
  }
  const click_handler = (formula) => {
    set_store_value(context, $context.maxPreparedSpells = formula.value, $context);
  };
  return [$context, appId, context, localize, input_input_handler, click_handler];
}
class MaxPreparedSpellsConfig extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2D, create_fragment$2D, safe_not_equal, {});
  }
}
class MaxPreparedSpellsConfigFormApplication extends SvelteFormApplicationBase {
  context;
  actor;
  constructor(actor, ...args) {
    super(...args);
    this.actor = actor;
    this.context = writable({
      maxPreparedSpells: "",
      formulas: getMaxPreparedSpellsSampleFormulas(),
      actor
    });
  }
  createComponent(node) {
    this.context.set(this.getData());
    return new MaxPreparedSpellsConfig({
      target: node,
      context: /* @__PURE__ */ new Map([
        ["context", this.context],
        ["appId", this.appId]
      ])
    });
  }
  getData() {
    return {
      maxPreparedSpells: TidyFlags.maxPreparedSpells.get(this.actor) ?? "",
      formulas: getMaxPreparedSpellsSampleFormulas(),
      actor: this.actor
    };
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      width: 500,
      height: "auto",
      sheetConfig: false,
      resizable: false
    });
  }
  get title() {
    return FoundryAdapter.localize("TIDY5E.MaxPreparedSpellsConfig.Title", {
      actorName: this.actor.name
    });
  }
  async _updateObject() {
    const data = get_store_value(this.context);
    await this.actor.update({
      [TidyFlags.maxPreparedSpells.prop]: data?.maxPreparedSpells ?? ""
    });
  }
}
function get_each_context$E(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  return child_ctx;
}
function create_if_block_2$C(ctx) {
  let span0;
  let t1;
  let span1;
  let t4;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[3].spellCalculations.rangedMod !== /*$context*/
      ctx2[3].spellCalculations.meleeMod
    ) return create_if_block_3$v;
    return create_else_block$P;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      span0 = element("span");
      span0.textContent = "|";
      t1 = space();
      span1 = element("span");
      span1.textContent = `${FoundryAdapter.localize("TIDY5E.AttackMod")}:`;
      t4 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      insert(target, t1, anchor);
      insert(target, span1, anchor);
      insert(target, t4, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t1);
        detach(span1);
        detach(t4);
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block$P(ctx) {
  let button;
  let span;
  let t_value = (
    /*$context*/
    ctx[3].spellCalculations.rangedMod + ""
  );
  let t2;
  let span_data_tidy_mod_has_bonus_value;
  let button_tabindex_value;
  let button_data_tooltip_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "spell-attack-mod");
      attr(span, "data-tidy-mod-has-bonus", span_data_tidy_mod_has_bonus_value = /*$context*/
      ctx[3].spellCalculations.rangedHasBonus);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SPELL_ATTACK_MOD);
      attr(button, "type", "button");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-tooltip", button_data_tooltip_value = FoundryAdapter.localize("TIDY5E.SpellAttackMod") + ": " + /*$context*/
      ctx[3].spellCalculations.rangedTooltip);
      attr(button, "class", "inline-transparent-button spell-attack-mod-button rollable svelte-1h43w08");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(span, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t_value !== (t_value = /*$context*/
      ctx2[3].spellCalculations.rangedMod + "")) set_data(t2, t_value);
      if (dirty & /*$context*/
      8 && span_data_tidy_mod_has_bonus_value !== (span_data_tidy_mod_has_bonus_value = /*$context*/
      ctx2[3].spellCalculations.rangedHasBonus)) {
        attr(span, "data-tidy-mod-has-bonus", span_data_tidy_mod_has_bonus_value);
      }
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*$context*/
      8 && button_data_tooltip_value !== (button_data_tooltip_value = FoundryAdapter.localize("TIDY5E.SpellAttackMod") + ": " + /*$context*/
      ctx2[3].spellCalculations.rangedTooltip)) {
        attr(button, "data-tooltip", button_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$v(ctx) {
  let button0;
  let i0;
  let t0;
  let span0;
  let t1_value = (
    /*$context*/
    ctx[3].spellCalculations.rangedMod + ""
  );
  let t1;
  let span0_data_tidy_mod_has_bonus_value;
  let button0_tabindex_value;
  let button0_data_tooltip_value;
  let t2;
  let button1;
  let i1;
  let t3;
  let span1;
  let t4_value = (
    /*$context*/
    ctx[3].spellCalculations.meleeMod + ""
  );
  let t4;
  let span1_data_tidy_mod_has_bonus_value;
  let button1_tabindex_value;
  let button1_data_tooltip_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      i0 = element("i");
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      button1 = element("button");
      i1 = element("i");
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      attr(i0, "class", "fa-solid fa-wand-magic-sparkles svelte-1h43w08");
      attr(span0, "class", "spell-attack-mod");
      attr(span0, "data-tidy-mod-has-bonus", span0_data_tidy_mod_has_bonus_value = /*$context*/
      ctx[3].spellCalculations.rangedHasBonus);
      attr(span0, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.RANGED_SPELL_ATTACK_MOD);
      attr(button0, "type", "button");
      attr(button0, "tabindex", button0_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button0, "data-tooltip", button0_data_tooltip_value = FoundryAdapter.localize("TIDY5E.RangedSpellAttackMod") + ": " + /*$context*/
      ctx[3].spellCalculations.rangedTooltip);
      attr(button0, "class", "inline-transparent-button spell-attack-mod-button rollable svelte-1h43w08");
      attr(i1, "class", "fa-solid fa-hand-sparkles svelte-1h43w08");
      attr(span1, "class", "spell-attack-mod");
      attr(span1, "data-tidy-mod-has-bonus", span1_data_tidy_mod_has_bonus_value = /*$context*/
      ctx[3].spellCalculations.meleeHasBonus);
      attr(span1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.MELEE_SPELL_ATTACK_MOD);
      attr(button1, "type", "button");
      attr(button1, "tabindex", button1_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button1, "data-tooltip", button1_data_tooltip_value = FoundryAdapter.localize("TIDY5E.MeleeSpellAttackMod") + ": " + /*$context*/
      ctx[3].spellCalculations.meleeTooltip);
      attr(button1, "class", "inline-transparent-button spell-attack-mod-button rollable svelte-1h43w08");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, i0);
      append(button0, t0);
      append(button0, span0);
      append(span0, t1);
      insert(target, t2, anchor);
      insert(target, button1, anchor);
      append(button1, i1);
      append(button1, t3);
      append(button1, span1);
      append(span1, t4);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t1_value !== (t1_value = /*$context*/
      ctx2[3].spellCalculations.rangedMod + "")) set_data(t1, t1_value);
      if (dirty & /*$context*/
      8 && span0_data_tidy_mod_has_bonus_value !== (span0_data_tidy_mod_has_bonus_value = /*$context*/
      ctx2[3].spellCalculations.rangedHasBonus)) {
        attr(span0, "data-tidy-mod-has-bonus", span0_data_tidy_mod_has_bonus_value);
      }
      if (dirty & /*$settingStore*/
      32 && button0_tabindex_value !== (button0_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button0, "tabindex", button0_tabindex_value);
      }
      if (dirty & /*$context*/
      8 && button0_data_tooltip_value !== (button0_data_tooltip_value = FoundryAdapter.localize("TIDY5E.RangedSpellAttackMod") + ": " + /*$context*/
      ctx2[3].spellCalculations.rangedTooltip)) {
        attr(button0, "data-tooltip", button0_data_tooltip_value);
      }
      if (dirty & /*$context*/
      8 && t4_value !== (t4_value = /*$context*/
      ctx2[3].spellCalculations.meleeMod + "")) set_data(t4, t4_value);
      if (dirty & /*$context*/
      8 && span1_data_tidy_mod_has_bonus_value !== (span1_data_tidy_mod_has_bonus_value = /*$context*/
      ctx2[3].spellCalculations.meleeHasBonus)) {
        attr(span1, "data-tidy-mod-has-bonus", span1_data_tidy_mod_has_bonus_value);
      }
      if (dirty & /*$settingStore*/
      32 && button1_tabindex_value !== (button1_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button1, "tabindex", button1_tabindex_value);
      }
      if (dirty & /*$context*/
      8 && button1_data_tooltip_value !== (button1_data_tooltip_value = FoundryAdapter.localize("TIDY5E.MeleeSpellAttackMod") + ": " + /*$context*/
      ctx2[3].spellCalculations.meleeTooltip)) {
        attr(button1, "data-tooltip", button1_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t2);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$N(ctx) {
  let button;
  let p2;
  let t1;
  let span0;
  let t2_value = (
    /*$context*/
    (ctx[3].preparedSpells ?? 0) + ""
  );
  let t2;
  let t3;
  let span1;
  let t4_value = (
    /*$context*/
    (ctx[3].maxPreparedSpellsTotal ?? 0) + ""
  );
  let t4;
  let button_disabled_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[7]("TIDY5E.PreparedSpells")}`;
      t1 = space();
      span0 = element("span");
      t2 = text(t2_value);
      t3 = text("\n      /\n      ");
      span1 = element("span");
      t4 = text(t4_value);
      attr(p2, "class", "svelte-1h43w08");
      attr(span0, "class", "spells-prepared");
      attr(span1, "class", "spells-max-prepared");
      attr(button, "type", "button");
      attr(button, "class", "transparent-button secondary-footer-field highlight-on-hover svelte-1h43w08");
      attr(
        button,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.MaxPreparedSpellsConfig.ButtonTooltip")
      );
      button.disabled = button_disabled_value = !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockSensitiveFields;
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, p2);
      append(button, t1);
      append(button, span0);
      append(span0, t2);
      append(button, t3);
      append(button, span1);
      append(span1, t4);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_3*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t2_value !== (t2_value = /*$context*/
      (ctx2[3].preparedSpells ?? 0) + "")) set_data(t2, t2_value);
      if (dirty & /*$context*/
      8 && t4_value !== (t4_value = /*$context*/
      (ctx2[3].maxPreparedSpellsTotal ?? 0) + "")) set_data(t4, t4_value);
      if (dirty & /*$context*/
      8 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockSensitiveFields)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$E(ctx) {
  let option;
  let t_value = (
    /*ability*/
    ctx[12].text + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*ability*/
      ctx[12].value;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*abilities*/
      16 && t_value !== (t_value = /*ability*/
      ctx2[12].text + "")) set_data(t2, t_value);
      if (dirty & /*abilities*/
      16 && option_value_value !== (option_value_value = /*ability*/
      ctx2[12].value)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot_1$E(ctx) {
  let option;
  let t0_value = (
    /*localize*/
    ctx[7]("DND5E.None") + ""
  );
  let t0;
  let option_selected_value;
  let t1;
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*abilities*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$E(get_each_context$E(ctx, each_value, i2));
  }
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      option.__value = "";
      set_input_value(option, option.__value);
      option.selected = option_selected_value = !/*$context*/
      ctx[3].system.attributes.spellcasting;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && option_selected_value !== (option_selected_value = !/*$context*/
      ctx2[3].system.attributes.spellcasting)) {
        option.selected = option_selected_value;
      }
      if (dirty & /*abilities*/
      16) {
        each_value = ensure_array_like(
          /*abilities*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$E(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$E(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
        detach(t1);
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block$1f(ctx) {
  let div;
  let p2;
  let t1;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      cssClass: "spellcasting-level",
      document: (
        /*$context*/
        ctx[3].actor
      ),
      field: "system.details.spellLevel",
      value: (
        /*$context*/
        ctx[3].system.details.spellLevel
      ),
      placeholder: "0",
      min: "0",
      step: "1",
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockSensitiveFields
    }
  });
  return {
    c() {
      div = element("div");
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[7]("DND5E.SpellcasterLevel")}`;
      t1 = space();
      create_component(numberinput.$$.fragment);
      attr(p2, "class", "truncate svelte-1h43w08");
      attr(div, "class", "spellcasting-level-container secondary-footer-field svelte-1h43w08");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p2);
      append(div, t1);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*$context*/
      8) numberinput_changes.document = /*$context*/
      ctx2[3].actor;
      if (dirty & /*$context*/
      8) numberinput_changes.value = /*$context*/
      ctx2[3].system.details.spellLevel;
      if (dirty & /*$context*/
      8) numberinput_changes.disabled = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockSensitiveFields;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_default_slot$1c(ctx) {
  let h3;
  let div2;
  let div0;
  let t2;
  let div1;
  let t3_value = (
    /*$context*/
    ctx[3].spellCalculations.dc + ""
  );
  let t3;
  let div1_data_tooltip_value;
  let t4;
  let t5;
  let t6;
  let div3;
  let p2;
  let t8;
  let select;
  let t9;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*includeAttackMod*/
    ctx[1] && create_if_block_2$C(ctx)
  );
  let if_block1 = (
    /*includePreparedSpells*/
    ctx[2] && create_if_block_1$N(ctx)
  );
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[3].actor
      ),
      field: "system.attributes.spellcasting",
      value: (
        /*$context*/
        ctx[3].system.attributes.spellcasting
      ),
      disabled: !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockSensitiveFields,
      blankValue: "",
      $$slots: { default: [create_default_slot_1$E] },
      $$scope: { ctx }
    }
  });
  let if_block2 = (
    /*$context*/
    ctx[3].isNPC && create_if_block$1f(ctx)
  );
  return {
    c() {
      h3 = element("h3");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = `${FoundryAdapter.localize("DND5E.AbbreviationDC")}:`;
      t2 = space();
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      if (if_block0) if_block0.c();
      t5 = space();
      if (if_block1) if_block1.c();
      t6 = space();
      div3 = element("div");
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[7]("DND5E.SpellAbility")}`;
      t8 = space();
      create_component(select.$$.fragment);
      t9 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
      attr(div1, "class", "dc-container svelte-1h43w08");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.SPELL_DC);
      attr(div1, "data-tooltip", div1_data_tooltip_value = FoundryAdapter.localize("DND5E.SpellDC") + ": " + /*$context*/
      ctx[3].spellCalculations.dcTooltip);
      attr(div2, "class", "flex-row extra-small-gap");
      set_style(div2, "align-items", "baseline");
      attr(h3, "class", "spell-dc spell-mod flex-row extra-small-gap svelte-1h43w08");
      attr(p2, "class", "svelte-1h43w08");
      attr(div3, "class", "spellcasting-attribute secondary-footer-field svelte-1h43w08");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, div2);
      append(div2, div0);
      append(div2, t2);
      append(div2, div1);
      append(div1, t3);
      append(div2, t4);
      if (if_block0) if_block0.m(div2, null);
      insert(target, t5, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t6, anchor);
      insert(target, div3, anchor);
      append(div3, p2);
      append(div3, t8);
      mount_component(select, div3, null);
      insert(target, t9, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$context*/
      8) && t3_value !== (t3_value = /*$context*/
      ctx2[3].spellCalculations.dc + "")) set_data(t3, t3_value);
      if (!current || dirty & /*$context*/
      8 && div1_data_tooltip_value !== (div1_data_tooltip_value = FoundryAdapter.localize("DND5E.SpellDC") + ": " + /*$context*/
      ctx2[3].spellCalculations.dcTooltip)) {
        attr(div1, "data-tooltip", div1_data_tooltip_value);
      }
      if (
        /*includeAttackMod*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$C(ctx2);
          if_block0.c();
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*includePreparedSpells*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$N(ctx2);
          if_block1.c();
          if_block1.m(t6.parentNode, t6);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const select_changes = {};
      if (dirty & /*$context*/
      8) select_changes.document = /*$context*/
      ctx2[3].actor;
      if (dirty & /*$context*/
      8) select_changes.value = /*$context*/
      ctx2[3].system.attributes.spellcasting;
      if (dirty & /*$context*/
      8) select_changes.disabled = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockSensitiveFields;
      if (dirty & /*$$scope, abilities, $context*/
      32792) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
      if (
        /*$context*/
        ctx2[3].isNPC
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1f(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t5);
        detach(t6);
        detach(div3);
        detach(t9);
        detach(if_block2_anchor);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d(detaching);
      destroy_component(select);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_fragment$2C(ctx) {
  let tabfooter;
  let current;
  tabfooter = new TabFooter({
    props: {
      cssClass: (
        /*cssClass*/
        ctx[0] + " spellbook-footer"
      ),
      mode: "horizontal",
      $$slots: { default: [create_default_slot$1c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tabfooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tabfooter, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tabfooter_changes = {};
      if (dirty & /*cssClass*/
      1) tabfooter_changes.cssClass = /*cssClass*/
      ctx2[0] + " spellbook-footer";
      if (dirty & /*$$scope, $context, abilities, $settingStore, includePreparedSpells, includeAttackMod*/
      32830) {
        tabfooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabfooter.$set(tabfooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tabfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tabfooter, detaching);
    }
  };
}
function instance$2C($$self, $$props, $$invalidate) {
  let abilities;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  let { cssClass = null } = $$props;
  let { includeAttackMod = true } = $$props;
  let { includePreparedSpells = true } = $$props;
  const localize = FoundryAdapter.localize;
  const click_handler = (ev) => rollRawSpellAttack(ev, $context.actor, "rsak");
  const click_handler_1 = (ev) => rollRawSpellAttack(ev, $context.actor, "msak");
  const click_handler_2 = (ev) => rollRawSpellAttack(ev, $context.actor);
  const click_handler_3 = () => new MaxPreparedSpellsConfigFormApplication($context.actor).render(true);
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
    if ("includeAttackMod" in $$props2) $$invalidate(1, includeAttackMod = $$props2.includeAttackMod);
    if ("includePreparedSpells" in $$props2) $$invalidate(2, includePreparedSpells = $$props2.includePreparedSpells);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    8) {
      $$invalidate(4, abilities = FoundryAdapter.getAbilitiesAsDropdownOptions($context.abilities));
    }
  };
  return [
    cssClass,
    includeAttackMod,
    includePreparedSpells,
    $context,
    abilities,
    $settingStore,
    context,
    localize,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class SpellbookFooter extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2C, create_fragment$2C, safe_not_equal, {
      cssClass: 0,
      includeAttackMod: 1,
      includePreparedSpells: 2
    });
  }
}
function get_each_context$D(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  return child_ctx;
}
function get_each_context_1$k(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[3].itemContext[
      /*spell*/
      child_ctx[25].id
    ]
  );
  child_ctx[26] = constants_0;
  const constants_1 = FoundryAdapter.getSpellImageUrl(
    /*$context*/
    child_ctx[3],
    /*spell*/
    child_ctx[25]
  );
  child_ctx[27] = constants_1;
  const constants_2 = !!/*$itemIdsToShow*/
  child_ctx[5] && !/*$itemIdsToShow*/
  child_ctx[5].has(
    /*spell*/
    child_ctx[25].id
  );
  child_ctx[28] = constants_2;
  return child_ctx;
}
function create_if_block_5$j(ctx) {
  let spellslotmanagement;
  let current;
  spellslotmanagement = new SpellSlotManagement({ props: { section: (
    /*section*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(spellslotmanagement.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellslotmanagement, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellslotmanagement_changes = {};
      if (dirty[0] & /*section*/
      1) spellslotmanagement_changes.section = /*section*/
      ctx2[0];
      spellslotmanagement.$set(spellslotmanagement_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellslotmanagement.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellslotmanagement.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellslotmanagement, detaching);
    }
  };
}
function create_default_slot_1$D(ctx) {
  let span;
  let t0_value = (
    /*localize*/
    ctx[9](
      /*section*/
      ctx[0].label
    ) + ""
  );
  let t0;
  let t1;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[0].usesSlots && create_if_block_5$j(ctx)
  );
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "spell-primary-column-label svelte-179zdaq");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*section*/
      1) && t0_value !== (t0_value = /*localize*/
      ctx2[9](
        /*section*/
        ctx2[0].label
      ) + "")) set_data(t0, t0_value);
      if (
        /*section*/
        ctx2[0].usesSlots
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*section*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$j(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$1b(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_1$D] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty[0] & /*section*/
      1 | dirty[1] & /*$$scope*/
      1) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_header_slot$e(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot$1b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty[0] & /*section*/
      1 | dirty[1] & /*$$scope*/
      1) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_if_block_4$m(ctx) {
  let gridpanefavoriteicon;
  let current;
  gridpanefavoriteicon = new GridPaneFavoriteIcon({});
  return {
    c() {
      create_component(gridpanefavoriteicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridpanefavoriteicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(gridpanefavoriteicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridpanefavoriteicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridpanefavoriteicon, detaching);
    }
  };
}
function create_if_block_3$u(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-dice-d20 svelte-179zdaq");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_each_block_1$k(ctx) {
  let button;
  let t0;
  let div1;
  let div0;
  let t1;
  let concentrationoverlayicon;
  let div;
  let button_class_value;
  let button_aria_hidden_value;
  let button_data_context_menu_document_uuid_value;
  let button_disabled_value;
  let button_data_item_id_value;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = "favoriteId" in /*ctx*/
  ctx[26] && !!/*ctx*/
  ctx[26].favoriteId && create_if_block_4$m();
  let if_block1 = !/*ctx*/
  ctx[26].concentration && create_if_block_3$u();
  concentrationoverlayicon = new ConcentrationOverlayIcon({ props: { ctx: (
    /*ctx*/
    ctx[26]
  ) } });
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[13](
        /*spell*/
        ctx[25],
        ...args
      )
    );
  }
  function contextmenu_handler(...args) {
    return (
      /*contextmenu_handler*/
      ctx[14](
        /*spell*/
        ctx[25],
        ...args
      )
    );
  }
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[15](
        /*spell*/
        ctx[25],
        ...args
      )
    );
  }
  function mouseenter_handler(...args) {
    return (
      /*mouseenter_handler*/
      ctx[16](
        /*spell*/
        ctx[25],
        ...args
      )
    );
  }
  function mouseleave_handler(...args) {
    return (
      /*mouseleave_handler*/
      ctx[17](
        /*spell*/
        ctx[25],
        ...args
      )
    );
  }
  function dragstart_handler(...args) {
    return (
      /*dragstart_handler*/
      ctx[18](
        /*spell*/
        ctx[25],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      if (if_block0) if_block0.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block1) if_block1.c();
      t1 = space();
      div = element("div");
      create_component(concentrationoverlayicon.$$.fragment);
      set_style(div, "display", "contents");
      set_style(div, "--tidy-icon-font-size", "1.25rem");
      attr(div0, "class", "spell-image svelte-179zdaq");
      set_style(div0, "background-image", "url('" + /*spellImgUrl*/
      ctx[27] + "')");
      attr(div1, "class", "spell-name svelte-179zdaq");
      attr(button, "type", "button");
      attr(button, "class", button_class_value = "spell " + FoundryAdapter.getSpellRowClasses(
        /*spell*/
        ctx[25]
      ) + " transparent-button svelte-179zdaq");
      attr(button, "aria-hidden", button_aria_hidden_value = /*hidden*/
      ctx[28]);
      attr(button, "data-context-menu", CONSTANTS.CONTEXT_MENU_TYPE_ITEMS);
      attr(button, "data-context-menu-document-uuid", button_data_context_menu_document_uuid_value = /*spell*/
      ctx[25].uuid);
      attr(button, "draggable", true);
      button.disabled = button_disabled_value = !/*$context*/
      ctx[3].editable;
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_USE_COMMAND);
      attr(button, "data-item-id", button_data_item_id_value = /*spell*/
      ctx[25].id);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[6].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-tidy-grid-item", "");
      toggle_class(
        button,
        "hidden",
        /*hidden*/
        ctx[28]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block0) if_block0.m(button, null);
      append(button, t0);
      append(button, div1);
      append(div1, div0);
      if (if_block1) if_block1.m(div0, null);
      append(div0, t1);
      append(div0, div);
      mount_component(concentrationoverlayicon, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", click_handler),
          listen(button, "contextmenu", contextmenu_handler),
          listen(button, "mousedown", mousedown_handler),
          listen(button, "mouseenter", mouseenter_handler),
          listen(button, "mouseleave", mouseleave_handler),
          listen(button, "dragstart", dragstart_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ("favoriteId" in /*ctx*/
      ctx[26] && !!/*ctx*/
      ctx[26].favoriteId) {
        if (if_block0) {
          if (dirty[0] & /*$context, spells*/
          10) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$m();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(button, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*ctx*/
      ctx[26].concentration) {
        if (if_block1) ;
        else {
          if_block1 = create_if_block_3$u();
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const concentrationoverlayicon_changes = {};
      if (dirty[0] & /*$context, spells*/
      10) concentrationoverlayicon_changes.ctx = /*ctx*/
      ctx[26];
      concentrationoverlayicon.$set(concentrationoverlayicon_changes);
      if (!current || dirty[0] & /*$context, spells*/
      10) {
        set_style(div0, "background-image", "url('" + /*spellImgUrl*/
        ctx[27] + "')");
      }
      if (!current || dirty[0] & /*spells*/
      2 && button_class_value !== (button_class_value = "spell " + FoundryAdapter.getSpellRowClasses(
        /*spell*/
        ctx[25]
      ) + " transparent-button svelte-179zdaq")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty[0] & /*$itemIdsToShow, spells*/
      34 && button_aria_hidden_value !== (button_aria_hidden_value = /*hidden*/
      ctx[28])) {
        attr(button, "aria-hidden", button_aria_hidden_value);
      }
      if (!current || dirty[0] & /*spells*/
      2 && button_data_context_menu_document_uuid_value !== (button_data_context_menu_document_uuid_value = /*spell*/
      ctx[25].uuid)) {
        attr(button, "data-context-menu-document-uuid", button_data_context_menu_document_uuid_value);
      }
      if (!current || dirty[0] & /*$context*/
      8 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx[3].editable)) {
        button.disabled = button_disabled_value;
      }
      if (!current || dirty[0] & /*spells*/
      2 && button_data_item_id_value !== (button_data_item_id_value = /*spell*/
      ctx[25].id)) {
        attr(button, "data-item-id", button_data_item_id_value);
      }
      if (!current || dirty[0] & /*$settingStore*/
      64 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[6].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty[0] & /*spells, $itemIdsToShow, spells*/
      34) {
        toggle_class(
          button,
          "hidden",
          /*hidden*/
          ctx[28]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(concentrationoverlayicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(concentrationoverlayicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      destroy_component(concentrationoverlayicon);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$1e(ctx) {
  let div;
  let t2;
  let if_block = (
    /*section*/
    ctx[0].canCreate && create_if_block_2$B(ctx)
  );
  let each_value = ensure_array_like(
    /*customCommands*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$D(get_each_context$D(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "spells-footer svelte-179zdaq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (
        /*section*/
        ctx2[0].canCreate
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$B(ctx2);
          if_block.c();
          if_block.m(div, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*localize, customCommands, $settingStore, section, $context*/
      601) {
        each_value = ensure_array_like(
          /*customCommands*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$D(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$D(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_2$B(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-plus-circle svelte-179zdaq");
      attr(button, "type", "button");
      attr(button, "class", "footer-command icon-button svelte-179zdaq");
      attr(
        button,
        "title",
        /*localize*/
        ctx[9]("DND5E.SpellCreate")
      );
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_CREATE_COMMAND);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[6].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*click_handler_1*/
          ctx[19]
        )));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$settingStore*/
      64 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[6].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$M(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = null_to_empty(
        /*command*/
        ctx[22].iconClass
      ) + " svelte-179zdaq");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*customCommands*/
      16 && i_class_value !== (i_class_value = null_to_empty(
        /*command*/
        ctx2[22].iconClass
      ) + " svelte-179zdaq")) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_each_block$D(ctx) {
  let button;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[9](
      /*command*/
      ctx[22].label ?? ""
    ) + ""
  );
  let t1;
  let t2;
  let button_title_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  let if_block = (
    /*command*/
    (ctx[22].iconClass ?? "") !== "" && create_if_block_1$M(ctx)
  );
  function click_handler_2(...args) {
    return (
      /*click_handler_2*/
      ctx[20](
        /*command*/
        ctx[22],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      if (if_block) if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(button, "type", "button");
      attr(button, "class", "footer-command icon-button svelte-179zdaq");
      attr(button, "title", button_title_value = /*localize*/
      ctx[9](
        /*command*/
        ctx[22].tooltip ?? ""
      ));
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[6].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (if_block) if_block.m(button, null);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*command*/
        (ctx[22].iconClass ?? "") !== ""
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$M(ctx);
          if_block.c();
          if_block.m(button, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*customCommands*/
      16 && t1_value !== (t1_value = /*localize*/
      ctx[9](
        /*command*/
        ctx[22].label ?? ""
      ) + "")) set_data(t1, t1_value);
      if (dirty[0] & /*customCommands*/
      16 && button_title_value !== (button_title_value = /*localize*/
      ctx[9](
        /*command*/
        ctx[22].tooltip ?? ""
      ))) {
        attr(button, "title", button_title_value);
      }
      if (dirty[0] & /*$settingStore*/
      64 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[6].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_body_slot$d(ctx) {
  let div;
  let t2;
  let current;
  let each_value_1 = ensure_array_like(
    /*spells*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$k(get_each_context_1$k(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = (
    /*$context*/
    ctx[3].unlocked && create_if_block$1e(ctx)
  );
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      attr(div, "class", "spells svelte-179zdaq");
      attr(div, "slot", "body");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t2);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*spells, $itemIdsToShow, $context, $settingStore, onMouseEnter, onMouseLeave, handleDragStart*/
      7274) {
        each_value_1 = ensure_array_like(
          /*spells*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$k(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$k(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t2);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].unlocked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1e(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d();
    }
  };
}
function create_fragment$2B(ctx) {
  let section_1;
  let itemtable;
  let section_1_class_value;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[0].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[0].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$d],
        header: [create_header_slot$e]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section_1 = element("section");
      create_component(itemtable.$$.fragment);
      attr(section_1, "class", section_1_class_value = "spellbook-grid " + /*cssClass*/
      ctx[2] + " svelte-179zdaq");
    },
    m(target, anchor) {
      insert(target, section_1, anchor);
      mount_component(itemtable, section_1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtable_changes = {};
      if (dirty[0] & /*section*/
      1) itemtable_changes.key = /*section*/
      ctx2[0].key;
      if (dirty[0] & /*section*/
      1) itemtable_changes["data-custom-section"] = /*section*/
      ctx2[0].custom ? true : null;
      if (dirty[0] & /*customCommands, $settingStore, section, $context, spells, $itemIdsToShow*/
      123 | dirty[1] & /*$$scope*/
      1) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
      if (!current || dirty[0] & /*cssClass*/
      4 && section_1_class_value !== (section_1_class_value = "spellbook-grid " + /*cssClass*/
      ctx2[2] + " svelte-179zdaq")) {
        attr(section_1, "class", section_1_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section_1);
      }
      destroy_component(itemtable);
    }
  };
}
function instance$2B($$self, $$props, $$invalidate) {
  let customCommands;
  let $context;
  let $itemIdsToShow;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(6, $settingStore = $$value));
  let { section } = $$props;
  let { spells } = $$props;
  let { cssClass = null } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  let card = getContext(CONSTANTS.SVELTE_CONTEXT.CARD);
  let itemIdsToShow = getContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(5, $itemIdsToShow = value));
  const localize = FoundryAdapter.localize;
  async function onMouseEnter(event, item) {
    TidyHooks.tidy5eSheetsItemHoverOn(event, item);
    card.update((card2) => {
      card2.item = item;
      return card2;
    });
  }
  async function onMouseLeave(event, item) {
    TidyHooks.tidy5eSheetsItemHoverOff(event, item);
    card.update((card2) => {
      card2.item = null;
      return card2;
    });
  }
  function handleDragStart2(event, item) {
    if (!item) {
      return;
    }
    onMouseLeave(event, item);
    card.update((card2) => {
      return card2;
    });
    const dragData = item.toDragData();
    event.dataTransfer?.setData("text/plain", JSON.stringify(dragData));
  }
  declareLocation("spellbook-grid-view");
  const click_handler = (spell, event) => FoundryAdapter.actorTryUseItem(spell, {}, { event });
  const contextmenu_handler = (spell, event) => FoundryAdapter.onActorItemButtonContextMenu(spell, { event });
  const mousedown_handler = (spell, event) => FoundryAdapter.editOnMiddleClick(event, spell);
  const mouseenter_handler = (spell, ev) => onMouseEnter(ev, spell);
  const mouseleave_handler = (spell, ev) => onMouseLeave(ev, spell);
  const dragstart_handler = (spell, ev) => handleDragStart2(ev, spell);
  const click_handler_1 = () => FoundryAdapter.createItem(section.dataset, $context.actor);
  const click_handler_2 = (command, ev) => command.execute?.({
    section,
    event: ev,
    actor: $context.actor
  });
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
    if ("spells" in $$props2) $$invalidate(1, spells = $$props2.spells);
    if ("cssClass" in $$props2) $$invalidate(2, cssClass = $$props2.cssClass);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$context, section*/
    9) {
      $$invalidate(4, customCommands = ActorItemRuntime.getActorItemSectionCommands({ actor: $context.actor, section }));
    }
  };
  return [
    section,
    spells,
    cssClass,
    $context,
    customCommands,
    $itemIdsToShow,
    $settingStore,
    context,
    itemIdsToShow,
    localize,
    onMouseEnter,
    onMouseLeave,
    handleDragStart2,
    click_handler,
    contextmenu_handler,
    mousedown_handler,
    mouseenter_handler,
    mouseleave_handler,
    dragstart_handler,
    click_handler_1,
    click_handler_2
  ];
}
class SpellbookGrid extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2B, create_fragment$2B, safe_not_equal, { section: 0, spells: 1, cssClass: 2 }, null, [-1, -1]);
  }
}
function get_each_context$C(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_each_block$C(ctx) {
  let option_1;
  let t_value = (
    /*localize*/
    ctx[4](
      /*option*/
      ctx[6].text
    ) + ""
  );
  let t2;
  let option_1_value_value;
  let option_1_selected_value;
  return {
    c() {
      option_1 = element("option");
      t2 = text(t_value);
      option_1.__value = option_1_value_value = /*option*/
      ctx[6].value;
      set_input_value(option_1, option_1.__value);
      option_1.selected = option_1_selected_value = /*option*/
      ctx[6].value === /*selectedClassFilter*/
      ctx[2];
    },
    m(target, anchor) {
      insert(target, option_1, anchor);
      append(option_1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*allClasses*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[4](
        /*option*/
        ctx2[6].text
      ) + "")) set_data(t2, t_value);
      if (dirty & /*allClasses*/
      2 && option_1_value_value !== (option_1_value_value = /*option*/
      ctx2[6].value)) {
        option_1.__value = option_1_value_value;
        set_input_value(option_1, option_1.__value);
      }
      if (dirty & /*allClasses, selectedClassFilter*/
      6 && option_1_selected_value !== (option_1_selected_value = /*option*/
      ctx2[6].value === /*selectedClassFilter*/
      ctx2[2])) {
        option_1.selected = option_1_selected_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option_1);
      }
    }
  };
}
function create_fragment$2A(ctx) {
  let select;
  let select_disabled_value;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*allClasses*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$C(get_each_context$C(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(select, "class", "class-filter svelte-ssxj4u");
      select.disabled = select_disabled_value = !/*$context*/
      ctx[0].editable;
      attr(select, "data-tidy-field", TidyFlags.classFilter.prop);
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      if (!mounted) {
        dispose = listen(select, "change", stop_propagation(prevent_default(
          /*change_handler*/
          ctx[5]
        )));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*allClasses, selectedClassFilter, undefined, localize*/
      22) {
        each_value = ensure_array_like(
          /*allClasses*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$C(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$C(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$context*/
      1 && select_disabled_value !== (select_disabled_value = !/*$context*/
      ctx2[0].editable)) {
        select.disabled = select_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$2A($$self, $$props, $$invalidate) {
  let selectedClassFilter;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let allClasses = [];
  const localize = FoundryAdapter.localize;
  const change_handler = (event) => $context.actor.update({
    [TidyFlags.classFilter.prop]: event.currentTarget.value
  });
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      {
        $$invalidate(1, allClasses = [
          { text: "DND5E.Spellbook", value: "" },
          ...Object.entries($context.actor.spellcastingClasses).map(([key, value]) => ({ text: value.name, value: key }))
        ]);
      }
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, selectedClassFilter = TidyFlags.classFilter.get($context.actor) ?? "");
    }
  };
  return [$context, allClasses, selectedClassFilter, context, localize, change_handler];
}
class SpellbookClassFilter extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2A, create_fragment$2A, safe_not_equal, {});
  }
}
function create_default_slot$1a(ctx) {
  let t_value = (
    /*localize*/
    ctx[5]("DND5E.NoSpellLevels") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$1d(ctx) {
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[5]("DND5E.SpellCreate") + ""
  );
  let t1;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-plus-circle");
      attr(button, "type", "button");
      attr(button, "class", "create-spell-btn flex-row align-items-center extra-small-gap svelte-1i4uex");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[3].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      8 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[3].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2z(ctx) {
  let div;
  let notice;
  let t2;
  let div_class_value;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot$1a] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*editable*/
    ctx[0] && create_if_block$1d(ctx)
  );
  return {
    c() {
      div = element("div");
      create_component(notice.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      attr(div, "class", div_class_value = "no-spells-container " + /*cssClass*/
      ctx[1] + " svelte-1i4uex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(notice, div, null);
      append(div, t2);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      128) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*editable*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1d(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*cssClass*/
      2 && div_class_value !== (div_class_value = "no-spells-container " + /*cssClass*/
      ctx2[1] + " svelte-1i4uex")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(notice);
      if (if_block) if_block.d();
    }
  };
}
function instance$2z($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(3, $settingStore = $$value));
  let { editable } = $$props;
  let { cssClass = null } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = () => FoundryAdapter.createItem({ type: "spell", level: "" }, $context.actor);
  $$self.$$set = ($$props2) => {
    if ("editable" in $$props2) $$invalidate(0, editable = $$props2.editable);
    if ("cssClass" in $$props2) $$invalidate(1, cssClass = $$props2.cssClass);
  };
  return [editable, cssClass, $context, $settingStore, context, localize, click_handler];
}
class NoSpells extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2z, create_fragment$2z, safe_not_equal, { editable: 0, cssClass: 1 });
  }
}
function get_each_context_2$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function get_each_context$B(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  const constants_0 = (
    /*assignment*/
    (child_ctx[12].item.system.sourceClass?.trim() ?? "") === ""
  );
  child_ctx[13] = constants_0;
  const constants_1 = !/*visibleSelectablesIdSubset*/
  child_ctx[5].has(
    /*assignment*/
    child_ctx[12].item.id
  ) || /*showUnassignedOnly*/
  child_ctx[4] && !/*sourceClassIsUnassigned*/
  child_ctx[13];
  child_ctx[14] = constants_1;
  return child_ctx;
}
function get_each_context_1$j(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  const constants_0 = (
    /*assignment*/
    child_ctx[12].item.system.sourceClass === /*classColumn*/
    child_ctx[17].key
  );
  child_ctx[18] = constants_0;
  return child_ctx;
}
function create_default_slot_7$g(ctx) {
  let t_value = (
    /*localize*/
    ctx[7]("DND5E.spell") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_6$i(ctx) {
  let t_value = (
    /*classColumn*/
    ctx[17].item.name + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*classColumns*/
      2 && t_value !== (t_value = /*classColumn*/
      ctx2[17].item.name + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_2$8(ctx) {
  let tidytableheadercell;
  let current;
  tidytableheadercell = new TidyTableHeaderCell({
    props: {
      $$slots: { default: [create_default_slot_6$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheadercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheadercell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheadercell_changes = {};
      if (dirty & /*$$scope, classColumns*/
      8388610) {
        tidytableheadercell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell.$set(tidytableheadercell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheadercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheadercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytableheadercell, detaching);
    }
  };
}
function create_default_slot_5$n(ctx) {
  let span;
  let t1;
  let i2;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[7]("TIDY5E.SpellSourceClassAssignments.Identifier")}`;
      t1 = space();
      i2 = element("i");
      attr(i2, "class", "fas fa-question-circle");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.SpellSourceClassAssignments.IdentifierHint")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t1, anchor);
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(i2);
      }
    }
  };
}
function create_default_slot_4$r(ctx) {
  let tidytableheadercell0;
  let t0;
  let t1;
  let tidytableheadercell1;
  let current;
  tidytableheadercell0 = new TidyTableHeaderCell({
    props: {
      primary: true,
      class: "p-1 capitalize",
      $$slots: { default: [create_default_slot_7$g] },
      $$scope: { ctx }
    }
  });
  let each_value_2 = ensure_array_like(
    /*classColumns*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$8(get_each_context_2$8(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  tidytableheadercell1 = new TidyTableHeaderCell({
    props: {
      class: "flex-row small-gap",
      $$slots: { default: [create_default_slot_5$n] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheadercell0.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(tidytableheadercell1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheadercell0, target, anchor);
      insert(target, t0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t1, anchor);
      mount_component(tidytableheadercell1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheadercell0_changes = {};
      if (dirty & /*$$scope*/
      8388608) {
        tidytableheadercell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell0.$set(tidytableheadercell0_changes);
      if (dirty & /*classColumns*/
      2) {
        each_value_2 = ensure_array_like(
          /*classColumns*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$8(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$8(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const tidytableheadercell1_changes = {};
      if (dirty & /*$$scope*/
      8388608) {
        tidytableheadercell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell1.$set(tidytableheadercell1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheadercell0.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(tidytableheadercell1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheadercell0.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(tidytableheadercell1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(tidytableheadercell0, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(tidytableheadercell1, detaching);
    }
  };
}
function create_header_slot$d(ctx) {
  let tidytableheaderrow;
  let current;
  tidytableheaderrow = new TidyTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_4$r] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheaderrow_changes = {};
      if (dirty & /*$$scope, classColumns*/
      8388610) {
        tidytableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheaderrow.$set(tidytableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytableheaderrow, detaching);
    }
  };
}
function create_default_slot_3$v(ctx) {
  let button;
  let t_value = (
    /*assignment*/
    ctx[12].item.name + ""
  );
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[10](
        /*assignment*/
        ctx[12]
      )
    );
  }
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "inline-transparent-button highlight-on-hover");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$context*/
      4 && t_value !== (t_value = /*assignment*/
      ctx[12].item.name + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$w(ctx) {
  let tidyswitch;
  let current;
  function change_handler() {
    return (
      /*change_handler*/
      ctx[11](
        /*assignment*/
        ctx[12],
        /*selected*/
        ctx[18],
        /*classColumn*/
        ctx[17]
      )
    );
  }
  tidyswitch = new TidySwitch({ props: { value: (
    /*selected*/
    ctx[18]
  ) } });
  tidyswitch.$on("change", change_handler);
  return {
    c() {
      create_component(tidyswitch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidyswitch, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tidyswitch_changes = {};
      if (dirty & /*$context, classColumns*/
      6) tidyswitch_changes.value = /*selected*/
      ctx[18];
      tidyswitch.$set(tidyswitch_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidyswitch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidyswitch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidyswitch, detaching);
    }
  };
}
function create_each_block_1$j(ctx) {
  let tidytableheadercell;
  let current;
  tidytableheadercell = new TidyTableHeaderCell({
    props: {
      $$slots: { default: [create_default_slot_2$w] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheadercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheadercell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheadercell_changes = {};
      if (dirty & /*$$scope, $context, classColumns*/
      8388614) {
        tidytableheadercell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell.$set(tidytableheadercell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheadercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheadercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytableheadercell, detaching);
    }
  };
}
function create_default_slot_1$C(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*assignment*/
        ctx[12].item
      ),
      disabled: !/*assignment*/
      ctx[12].item.isOwner,
      field: "system.sourceClass",
      selectOnFocus: true,
      value: (
        /*assignment*/
        ctx[12].item.system.sourceClass
      )
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      4) textinput_changes.document = /*assignment*/
      ctx2[12].item;
      if (dirty & /*$context*/
      4) textinput_changes.disabled = !/*assignment*/
      ctx2[12].item.isOwner;
      if (dirty & /*$context*/
      4) textinput_changes.value = /*assignment*/
      ctx2[12].item.system.sourceClass;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot$19(ctx) {
  let tidytablecell0;
  let t0;
  let t1;
  let tidytablecell1;
  let t2;
  let current;
  tidytablecell0 = new TidyTableCell({
    props: {
      primary: true,
      class: "p-1 semibold",
      $$slots: { default: [create_default_slot_3$v] },
      $$scope: { ctx }
    }
  });
  let each_value_1 = ensure_array_like(
    /*classColumns*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$j(get_each_context_1$j(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  tidytablecell1 = new TidyTableCell({
    props: {
      $$slots: { default: [create_default_slot_1$C] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytablecell0.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(tidytablecell1.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(tidytablecell0, target, anchor);
      insert(target, t0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t1, anchor);
      mount_component(tidytablecell1, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytablecell0_changes = {};
      if (dirty & /*$$scope, $context*/
      8388612) {
        tidytablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell0.$set(tidytablecell0_changes);
      if (dirty & /*$context, classColumns, setItemSourceClass*/
      6) {
        each_value_1 = ensure_array_like(
          /*classColumns*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$j(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$j(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const tidytablecell1_changes = {};
      if (dirty & /*$$scope, $context*/
      8388612) {
        tidytablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell1.$set(tidytablecell1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytablecell0.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(tidytablecell1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytablecell0.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(tidytablecell1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(tidytablecell0, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(tidytablecell1, detaching);
    }
  };
}
function create_each_block$B(key_1, ctx) {
  let first;
  let tidytablerow;
  let current;
  tidytablerow = new TidyTableRow({
    props: {
      hidden: (
        /*hideRow*/
        ctx[14]
      ),
      $$slots: { default: [create_default_slot$19] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tidytablerow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tidytablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tidytablerow_changes = {};
      if (dirty & /*visibleSelectablesIdSubset, $context, showUnassignedOnly*/
      52) tidytablerow_changes.hidden = /*hideRow*/
      ctx[14];
      if (dirty & /*$$scope, $context, classColumns*/
      8388614) {
        tidytablerow_changes.$$scope = { dirty, ctx };
      }
      tidytablerow.$set(tidytablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(tidytablerow, detaching);
    }
  };
}
function create_body_slot$c(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[2].assignments
  );
  const get_key = (ctx2) => (
    /*assignment*/
    ctx2[12].item.id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$B(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$B(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*visibleSelectablesIdSubset, $context, showUnassignedOnly, classColumns, setItemSourceClass*/
      54) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[2].assignments
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$B, each_1_anchor, get_each_context$B);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_fragment$2y(ctx) {
  let section;
  let div0;
  let search;
  let updating_value;
  let t0;
  let label;
  let input;
  let t1;
  let t2_value = (
    /*localize*/
    ctx[7]("TIDY5E.SpellSourceClassAssignments.ShowUnassignedOnly.Text") + ""
  );
  let t2;
  let t3;
  let div1;
  let tidytable;
  let div;
  let current;
  let mounted;
  let dispose;
  function search_value_binding(value) {
    ctx[8](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[0] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[0];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  tidytable = new TidyTable({
    props: {
      key: "spell-source-class-assignments-matrix",
      toggleable: false,
      $$slots: {
        body: [create_body_slot$c],
        header: [create_header_slot$d]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section = element("section");
      div0 = element("div");
      create_component(search.$$.fragment);
      t0 = space();
      label = element("label");
      input = element("input");
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      div1 = element("div");
      div = element("div");
      create_component(tidytable.$$.fragment);
      attr(input, "type", "checkbox");
      attr(label, "class", "flex-row extra-small-gap align-items-center");
      attr(div0, "role", "presentation");
      attr(div0, "class", "flex-row small-gap");
      set_style(div, "display", "contents");
      set_style(
        div,
        "--grid-template-columns",
        /*gridTemplateColumns*/
        ctx[3]
      );
      attr(div1, "role", "presentation");
      attr(div1, "class", "scroll-container flex-1");
      attr(section, "class", "flex-column small-gap full-height");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div0);
      mount_component(search, div0, null);
      append(div0, t0);
      append(div0, label);
      append(label, input);
      input.checked = /*showUnassignedOnly*/
      ctx[4];
      append(label, t1);
      append(label, t2);
      append(section, t3);
      append(section, div1);
      append(div1, div);
      mount_component(tidytable, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const search_changes = {};
      if (!updating_value && dirty & /*searchCriteria*/
      1) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      if (dirty & /*showUnassignedOnly*/
      16) {
        input.checked = /*showUnassignedOnly*/
        ctx2[4];
      }
      if (dirty & /*gridTemplateColumns*/
      8) {
        set_style(
          div,
          "--grid-template-columns",
          /*gridTemplateColumns*/
          ctx2[3]
        );
      }
      const tidytable_changes = {};
      if (dirty & /*$$scope, $context, visibleSelectablesIdSubset, showUnassignedOnly, classColumns*/
      8388662) {
        tidytable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytable.$set(tidytable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(tidytable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(tidytable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(search);
      destroy_component(tidytable);
      mounted = false;
      dispose();
    }
  };
}
async function setItemSourceClass(item, sourceClass) {
  await item.update({ "system.sourceClass": sourceClass });
}
function instance$2y($$self, $$props, $$invalidate) {
  let visibleSelectablesIdSubset;
  let classColumns;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let searchCriteria = "";
  let gridTemplateColumns = "";
  const localize = FoundryAdapter.localize;
  var showUnassignedOnly = false;
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(0, searchCriteria);
  }
  function input_change_handler() {
    showUnassignedOnly = this.checked;
    $$invalidate(4, showUnassignedOnly);
  }
  const click_handler = async (assignment) => FoundryAdapter.renderSheetFromUuid(assignment.item.uuid);
  const change_handler = (assignment, selected, classColumn) => setItemSourceClass(assignment.item, selected ? "" : classColumn.key);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, searchCriteria*/
    5) {
      $$invalidate(5, visibleSelectablesIdSubset = new Set($context.assignments.filter((s2) => searchCriteria.trim() === "" || s2.item.name?.toLowerCase().includes(searchCriteria.toLowerCase())).map((d2) => d2.item.id)));
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(1, classColumns = Object.entries($context.actor.spellcastingClasses).map(([key, value]) => ({ key, item: value })));
    }
    if ($$self.$$.dirty & /*classColumns*/
    2) {
      {
        let standardClassColumnWidth = "10rem";
        let columns = "/* Spell Name */ minmax(200px, 1fr)";
        classColumns.forEach((column) => {
          columns += ` /* ${column.item.name} */ ${standardClassColumnWidth}`;
        });
        columns += " /* Identifier */ 200px";
        $$invalidate(3, gridTemplateColumns = columns);
      }
    }
  };
  return [
    searchCriteria,
    classColumns,
    $context,
    gridTemplateColumns,
    showUnassignedOnly,
    visibleSelectablesIdSubset,
    context,
    localize,
    search_value_binding,
    input_change_handler,
    click_handler,
    change_handler
  ];
}
class SpellSourceClassAssignments extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2y, create_fragment$2y, safe_not_equal, {});
  }
}
class StoreSubscriptionsService {
  _subscriptions = [];
  registerSubscriptions(...subscriptions) {
    this.unsubscribeAll();
    this._subscriptions = subscriptions;
  }
  unsubscribeAll() {
    this._subscriptions.forEach((s2) => s2());
    this._subscriptions = [];
  }
}
class SpellSourceClassAssignmentsFormApplication extends SvelteFormApplicationBase {
  context = writable();
  actor;
  subscriptionsService;
  updateHook;
  constructor(actor, ...args) {
    super(...args);
    this.actor = actor;
    this.subscriptionsService = new StoreSubscriptionsService();
  }
  createComponent(node) {
    this.context.set(this.getData());
    return new SpellSourceClassAssignments({
      target: node,
      context: /* @__PURE__ */ new Map([
        ["appId", this.appId],
        ["context", this.context]
      ])
    });
  }
  getData() {
    return {
      actor: this.actor,
      assignments: this.actor.items.filter((item) => item.type === CONSTANTS.ITEM_TYPE_SPELL).map((item) => ({
        item,
        sourceClass: "test"
      }))
    };
  }
  activateListeners(html) {
    Hooks.off("updateItem", this.updateHook);
    this.trackActorChanges();
    super.activateListeners(html);
  }
  trackActorChanges() {
    this.updateHook = Hooks.on("updateItem", (item) => {
      if (item.actor?.id !== this.actor.id) {
        return;
      }
      this.context.set(this.getData());
    });
  }
  get title() {
    return FoundryAdapter.localize("TIDY5E.Utilities.AssignSpellsToClasses");
  }
  close(options = {}) {
    Hooks.off("updateItem", this.updateHook);
    return super.close(options);
  }
}
function get_each_context$A(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function get_if_ctx$a(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*tryFilterByClass*/
    child_ctx[13](
      /*section*/
      child_ctx[18].spells
    )
  );
  child_ctx[21] = constants_0;
  const constants_1 = ItemVisibility.countVisibleItems(
    /*section*/
    child_ctx[18].spells,
    /*$itemIdsToShow*/
    child_ctx[8]
  );
  child_ctx[22] = constants_1;
  return child_ctx;
}
function get_each_context_1$i(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  return child_ctx;
}
function create_if_block_5$i(ctx) {
  let div;
  let spellbookclassfilter;
  let current;
  spellbookclassfilter = new SpellbookClassFilter({});
  return {
    c() {
      div = element("div");
      create_component(spellbookclassfilter.$$.fragment);
      attr(div, "class", "spellbook-class-filter svelte-j5isl1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spellbookclassfilter, div, null);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(spellbookclassfilter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellbookclassfilter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(spellbookclassfilter);
    }
  };
}
function create_default_slot_3$u(ctx) {
  let t_value = (
    /*localize*/
    ctx[12]("TIDY5E.Utilities.AssignSpellsToClasses") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$v(ctx) {
  let buttonmenucommand;
  let current;
  buttonmenucommand = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-list-check",
      disabled: !/*$context*/
      ctx[2].editable,
      $$slots: { default: [create_default_slot_3$u] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand.$on(
    "click",
    /*click_handler*/
    ctx[15]
  );
  return {
    c() {
      create_component(buttonmenucommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenucommand, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const buttonmenucommand_changes = {};
      if (dirty & /*$context*/
      4) buttonmenucommand_changes.disabled = !/*$context*/
      ctx2[2].editable;
      if (dirty & /*$$scope*/
      67108864) {
        buttonmenucommand_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand.$set(buttonmenucommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenucommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenucommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenucommand, detaching);
    }
  };
}
function create_each_block_1$i(key_1, ctx) {
  let first;
  let utilitytoolbarcommand;
  let current;
  function execute_handler(...args) {
    return (
      /*execute_handler*/
      ctx[16](
        /*command*/
        ctx[23],
        ...args
      )
    );
  }
  utilitytoolbarcommand = new UtilityToolbarCommand({
    props: {
      title: (
        /*command*/
        ctx[23].title
      ),
      iconClass: (
        /*command*/
        ctx[23].iconClass
      ),
      text: (
        /*command*/
        ctx[23].text
      ),
      visible: (
        /*command*/
        ctx[23].visible ?? true
      )
    }
  });
  utilitytoolbarcommand.$on("execute", execute_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(utilitytoolbarcommand.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(utilitytoolbarcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const utilitytoolbarcommand_changes = {};
      if (dirty & /*utilityBarCommands*/
      16) utilitytoolbarcommand_changes.title = /*command*/
      ctx[23].title;
      if (dirty & /*utilityBarCommands*/
      16) utilitytoolbarcommand_changes.iconClass = /*command*/
      ctx[23].iconClass;
      if (dirty & /*utilityBarCommands*/
      16) utilitytoolbarcommand_changes.text = /*command*/
      ctx[23].text;
      if (dirty & /*utilityBarCommands*/
      16) utilitytoolbarcommand_changes.visible = /*command*/
      ctx[23].visible ?? true;
      utilitytoolbarcommand.$set(utilitytoolbarcommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbarcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbarcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(utilitytoolbarcommand, detaching);
    }
  };
}
function create_default_slot_1$B(ctx) {
  let search;
  let updating_value;
  let t0;
  let t1;
  let pinnedfiltertoggles;
  let t2;
  let filtermenu;
  let t3;
  let buttonmenu;
  let t4;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  function search_value_binding(value) {
    ctx[14](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[0] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[0];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  let if_block = (
    /*$settingStore*/
    ctx[7].useMulticlassSpellbookFilter && create_if_block_5$i()
  );
  pinnedfiltertoggles = new PinnedFilterToggles({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[10]
      ),
      filters: ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx[2].filterPins,
        /*$context*/
        ctx[2].filterData,
        /*tabId*/
        ctx[10]
      )
    }
  });
  filtermenu = new FilterMenu({ props: { tabId: (
    /*tabId*/
    ctx[10]
  ) } });
  buttonmenu = new ButtonMenu({
    props: {
      iconClass: "ra ra-fairy-wand",
      buttonClass: "inline-icon-button",
      position: "bottom",
      anchor: "right",
      title: (
        /*localize*/
        ctx[12]("TIDY5E.Utilities.Tools")
      ),
      menuElement: "div",
      $$slots: { default: [create_default_slot_2$v] },
      $$scope: { ctx }
    }
  });
  let each_value_1 = ensure_array_like(
    /*utilityBarCommands*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[23].title
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$i(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$i(key, child_ctx));
  }
  return {
    c() {
      create_component(search.$$.fragment);
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      create_component(pinnedfiltertoggles.$$.fragment);
      t2 = space();
      create_component(filtermenu.$$.fragment);
      t3 = space();
      create_component(buttonmenu.$$.fragment);
      t4 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(pinnedfiltertoggles, target, anchor);
      insert(target, t2, anchor);
      mount_component(filtermenu, target, anchor);
      insert(target, t3, anchor);
      mount_component(buttonmenu, target, anchor);
      insert(target, t4, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_changes = {};
      if (!updating_value && dirty & /*searchCriteria*/
      1) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      if (
        /*$settingStore*/
        ctx2[7].useMulticlassSpellbookFilter
      ) {
        if (if_block) {
          if (dirty & /*$settingStore*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$i();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const pinnedfiltertoggles_changes = {};
      if (dirty & /*$context*/
      4) pinnedfiltertoggles_changes.filters = ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx2[2].filterPins,
        /*$context*/
        ctx2[2].filterData,
        /*tabId*/
        ctx2[10]
      );
      pinnedfiltertoggles.$set(pinnedfiltertoggles_changes);
      const buttonmenu_changes = {};
      if (dirty & /*$$scope, $context*/
      67108868) {
        buttonmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenu.$set(buttonmenu_changes);
      if (dirty & /*utilityBarCommands*/
      16) {
        each_value_1 = ensure_array_like(
          /*utilityBarCommands*/
          ctx2[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$i, each_1_anchor, get_each_context_1$i);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(if_block);
      transition_in(pinnedfiltertoggles.$$.fragment, local);
      transition_in(filtermenu.$$.fragment, local);
      transition_in(buttonmenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(if_block);
      transition_out(pinnedfiltertoggles.$$.fragment, local);
      transition_out(filtermenu.$$.fragment, local);
      transition_out(buttonmenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(each_1_anchor);
      }
      destroy_component(search, detaching);
      if (if_block) if_block.d(detaching);
      destroy_component(pinnedfiltertoggles, detaching);
      destroy_component(filtermenu, detaching);
      destroy_component(buttonmenu, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_else_block$O(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*spellbook*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[18].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$A(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$A(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*tryFilterByClass, spellbook, layoutMode, searchCriteria, $context, $itemIdsToShow*/
      8463) {
        each_value = ensure_array_like(
          /*spellbook*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$A, each_1_anchor, get_each_context$A);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block_1$L(ctx) {
  let nospells;
  let current;
  nospells = new NoSpells({
    props: { editable: (
      /*$context*/
      ctx[2].unlocked
    ) }
  });
  return {
    c() {
      create_component(nospells.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nospells, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const nospells_changes = {};
      if (dirty & /*$context*/
      4) nospells_changes.editable = /*$context*/
      ctx2[2].unlocked;
      nospells.$set(nospells_changes);
    },
    i(local) {
      if (current) return;
      transition_in(nospells.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nospells.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nospells, detaching);
    }
  };
}
function create_if_block_2$A(ctx) {
  let show_if = (
    /*searchCriteria*/
    ctx[0].trim() === "" && /*$context*/
    ctx[2].unlocked || /*visibleItemCount*/
    ctx[22] > 0 || !!/*section*/
    ctx[18].slots
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_3$t(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*searchCriteria, $context, spellbook, $itemIdsToShow*/
      263) show_if = /*searchCriteria*/
      ctx2[0].trim() === "" && /*$context*/
      ctx2[2].unlocked || /*visibleItemCount*/
      ctx2[22] > 0 || !!/*section*/
      ctx2[18].slots;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*searchCriteria, $context, spellbook, $itemIdsToShow*/
          263) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$t(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_3$t(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$l, create_else_block_1$d];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*layoutMode*/
      ctx2[3] === "list"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_1$d(ctx) {
  let spellbookgrid;
  let current;
  spellbookgrid = new SpellbookGrid({
    props: {
      spells: (
        /*classSpells*/
        ctx[21]
      ),
      section: (
        /*section*/
        ctx[18]
      )
    }
  });
  return {
    c() {
      create_component(spellbookgrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellbookgrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellbookgrid_changes = {};
      if (dirty & /*spellbook*/
      2) spellbookgrid_changes.spells = /*classSpells*/
      ctx2[21];
      if (dirty & /*spellbook*/
      2) spellbookgrid_changes.section = /*section*/
      ctx2[18];
      spellbookgrid.$set(spellbookgrid_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellbookgrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellbookgrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellbookgrid, detaching);
    }
  };
}
function create_if_block_4$l(ctx) {
  let spellbooklist;
  let current;
  spellbooklist = new SpellbookList({
    props: {
      spells: (
        /*classSpells*/
        ctx[21]
      ),
      section: (
        /*section*/
        ctx[18]
      )
    }
  });
  return {
    c() {
      create_component(spellbooklist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellbooklist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellbooklist_changes = {};
      if (dirty & /*spellbook*/
      2) spellbooklist_changes.spells = /*classSpells*/
      ctx2[21];
      if (dirty & /*spellbook*/
      2) spellbooklist_changes.section = /*section*/
      ctx2[18];
      spellbooklist.$set(spellbooklist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellbooklist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellbooklist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellbooklist, detaching);
    }
  };
}
function create_each_block$A(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[18].show && create_if_block_2$A(get_if_ctx$a(ctx))
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*section*/
        ctx[18].show
      ) {
        if (if_block) {
          if_block.p(get_if_ctx$a(ctx), dirty);
          if (dirty & /*spellbook*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$A(get_if_ctx$a(ctx));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block$1c(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot$18] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_default_slot$18(ctx) {
  let t_value = (
    /*localize*/
    ctx[12]("TIDY5E.EmptySection") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$2x(ctx) {
  let utilitytoolbar;
  let t0;
  let div;
  let current_block_type_index;
  let if_block0;
  let t1;
  let t2;
  let spellbookfooter;
  let current;
  utilitytoolbar = new UtilityToolbar({
    props: {
      $$slots: { default: [create_default_slot_1$B] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_1$L, create_else_block$O];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noSpellLevels*/
      ctx2[6]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*noSpells*/
    ctx[5] && !/*$context*/
    ctx[2].unlocked && create_if_block$1c(ctx)
  );
  spellbookfooter = new SpellbookFooter({});
  return {
    c() {
      create_component(utilitytoolbar.$$.fragment);
      t0 = space();
      div = element("div");
      if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      create_component(spellbookfooter.$$.fragment);
      attr(div, "class", "scroll-container flex-column small-gap");
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEMS_CONTAINER);
    },
    m(target, anchor) {
      mount_component(utilitytoolbar, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      if (if_block1) if_block1.m(div, null);
      insert(target, t2, anchor);
      mount_component(spellbookfooter, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const utilitytoolbar_changes = {};
      if (dirty & /*$$scope, utilityBarCommands, $context, $settingStore, searchCriteria*/
      67109013) {
        utilitytoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      utilitytoolbar.$set(utilitytoolbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t1);
      }
      if (
        /*noSpells*/
        ctx2[5] && !/*$context*/
        ctx2[2].unlocked
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*noSpells, $context*/
          36) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1c(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbar.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(spellbookfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbar.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(spellbookfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t2);
      }
      destroy_component(utilitytoolbar, detaching);
      if_blocks[current_block_type_index].d();
      if (if_block1) if_block1.d();
      destroy_component(spellbookfooter, detaching);
    }
  };
}
function instance$2x($$self, $$props, $$invalidate) {
  let spellbook;
  let selectedClassFilter;
  let noSpellLevels;
  let noSpells;
  let utilityBarCommands;
  let $context;
  let $settingStore;
  let $itemIdsToShow;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(7, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  const itemIdsToShow = writable(void 0);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(8, $itemIdsToShow = value));
  setContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW, itemIdsToShow);
  const localize = FoundryAdapter.localize;
  let searchCriteria = "";
  let layoutMode;
  function tryFilterByClass(spells) {
    if (!$settingStore.useMulticlassSpellbookFilter || selectedClassFilter === "") {
      return spells;
    }
    return spells.filter((spell) => spell.system.sourceClass?.trim() === selectedClassFilter?.trim());
  }
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(0, searchCriteria);
  }
  const click_handler = () => {
    new SpellSourceClassAssignmentsFormApplication($context.actor).render(true);
  };
  const execute_handler = (command, ev) => command.execute?.(ev.detail);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(1, spellbook = SheetSections.configureSpellbook($context.actor, tabId, $context.spellbook));
    }
    if ($$self.$$.dirty & /*searchCriteria, $context, spellbook*/
    7) {
      {
        set_store_value(
          itemIdsToShow,
          $itemIdsToShow = ItemVisibility.getItemsToShowAtDepth({
            criteria: searchCriteria,
            itemContext: $context.itemContext,
            sections: spellbook,
            tabId
          }),
          $itemIdsToShow
        );
      }
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(3, layoutMode = TidyFlags.spellbookGrid.get($context.actor) ? "grid" : "list");
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      selectedClassFilter = TidyFlags.classFilter.get($context.actor) ?? "";
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(6, noSpellLevels = !$context.spellbook.length);
    }
    if ($$self.$$.dirty & /*spellbook*/
    2) {
      $$invalidate(5, noSpells = spellbook.reduce((count, section) => count + section.spells.length, 0) === 0);
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(4, utilityBarCommands = $context.utilities[tabId]?.utilityToolbarCommands ?? []);
    }
  };
  return [
    searchCriteria,
    spellbook,
    $context,
    layoutMode,
    utilityBarCommands,
    noSpells,
    noSpellLevels,
    $settingStore,
    $itemIdsToShow,
    context,
    tabId,
    itemIdsToShow,
    localize,
    tryFilterByClass,
    search_value_binding,
    click_handler,
    execute_handler
  ];
}
class CharacterSpellbookTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2x, create_fragment$2x, safe_not_equal, {});
  }
}
function get_each_context$z(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_if_block$1b(ctx) {
  let t0;
  let t1_value = formatAsModifier(
    /*availableLevel*/
    ctx[5].delta
  ) + "";
  let t1;
  let t2;
  return {
    c() {
      t0 = text("(");
      t1 = text(t1_value);
      t2 = text(")");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*availableLevels*/
      1 && t1_value !== (t1_value = formatAsModifier(
        /*availableLevel*/
        ctx2[5].delta
      ) + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_each_block$z(ctx) {
  let option;
  let t0_value = (
    /*localize*/
    ctx[3]("DND5E.LevelNumber", { level: (
      /*availableLevel*/
      ctx[5].level
    ) }) + ""
  );
  let t0;
  let t1;
  let t2;
  let option_value_value;
  let option_disabled_value;
  let option_selected_value;
  let if_block = (
    /*availableLevel*/
    ctx[5].delta && create_if_block$1b(ctx)
  );
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      t2 = space();
      option.__value = option_value_value = /*availableLevel*/
      ctx[5].delta;
      set_input_value(option, option.__value);
      option.disabled = option_disabled_value = /*availableLevel*/
      ctx[5].disabled || void 0;
      option.selected = option_selected_value = /*availableLevel*/
      ctx[5].delta === 0;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
      if (if_block) if_block.m(option, null);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*availableLevels*/
      1 && t0_value !== (t0_value = /*localize*/
      ctx2[3]("DND5E.LevelNumber", { level: (
        /*availableLevel*/
        ctx2[5].level
      ) }) + "")) set_data(t0, t0_value);
      if (
        /*availableLevel*/
        ctx2[5].delta
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1b(ctx2);
          if_block.c();
          if_block.m(option, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*availableLevels*/
      1 && option_value_value !== (option_value_value = /*availableLevel*/
      ctx2[5].delta)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
      if (dirty & /*availableLevels*/
      1 && option_disabled_value !== (option_disabled_value = /*availableLevel*/
      ctx2[5].disabled || void 0)) {
        option.disabled = option_disabled_value;
      }
      if (dirty & /*availableLevels*/
      1 && option_selected_value !== (option_selected_value = /*availableLevel*/
      ctx2[5].delta === 0)) {
        option.selected = option_selected_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
      if (if_block) if_block.d();
    }
  };
}
function create_fragment$2w(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*availableLevels*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$z(get_each_context$z(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      select.disabled = /*disabled*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*change_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*availableLevels, undefined, localize*/
      9) {
        each_value = ensure_array_like(
          /*availableLevels*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$z(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$z(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*disabled*/
      2) {
        select.disabled = /*disabled*/
        ctx2[1];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$2w($$self, $$props, $$invalidate) {
  let { availableLevels = [] } = $$props;
  let { disabled = false } = $$props;
  let { item } = $$props;
  const localize = FoundryAdapter.localize;
  const change_handler = (event) => FoundryAdapter.onLevelChange(event, item, item.actor);
  $$self.$$set = ($$props2) => {
    if ("availableLevels" in $$props2) $$invalidate(0, availableLevels = $$props2.availableLevels);
    if ("disabled" in $$props2) $$invalidate(1, disabled = $$props2.disabled);
    if ("item" in $$props2) $$invalidate(2, item = $$props2.item);
  };
  return [availableLevels, disabled, item, localize, change_handler];
}
class LevelUpDropdown extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2w, create_fragment$2w, safe_not_equal, { availableLevels: 0, disabled: 1, item: 2 });
  }
}
function get_each_context$y(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function get_each_context_1$h(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[3].itemContext[
      /*item*/
      child_ctx[21].id
    ]
  );
  child_ctx[22] = constants_0;
  return child_ctx;
}
function get_if_ctx$9(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = ItemVisibility.countVisibleItems(
    /*section*/
    child_ctx[17].items,
    /*$itemIdsToShow*/
    child_ctx[7]
  );
  child_ctx[20] = constants_0;
  return child_ctx;
}
function get_each_context_2$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function create_each_block_2$7(key_1, ctx) {
  let first;
  let utilitytoolbarcommand;
  let current;
  function execute_handler(...args) {
    return (
      /*execute_handler*/
      ctx[14](
        /*command*/
        ctx[26],
        ...args
      )
    );
  }
  utilitytoolbarcommand = new UtilityToolbarCommand({
    props: {
      title: (
        /*command*/
        ctx[26].title
      ),
      iconClass: (
        /*command*/
        ctx[26].iconClass
      ),
      text: (
        /*command*/
        ctx[26].text
      ),
      visible: (
        /*command*/
        ctx[26].visible ?? true
      )
    }
  });
  utilitytoolbarcommand.$on("execute", execute_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(utilitytoolbarcommand.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(utilitytoolbarcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const utilitytoolbarcommand_changes = {};
      if (dirty & /*utilityBarCommands*/
      32) utilitytoolbarcommand_changes.title = /*command*/
      ctx[26].title;
      if (dirty & /*utilityBarCommands*/
      32) utilitytoolbarcommand_changes.iconClass = /*command*/
      ctx[26].iconClass;
      if (dirty & /*utilityBarCommands*/
      32) utilitytoolbarcommand_changes.text = /*command*/
      ctx[26].text;
      if (dirty & /*utilityBarCommands*/
      32) utilitytoolbarcommand_changes.visible = /*command*/
      ctx[26].visible ?? true;
      utilitytoolbarcommand.$set(utilitytoolbarcommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbarcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbarcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(utilitytoolbarcommand, detaching);
    }
  };
}
function create_default_slot_15$2(ctx) {
  let search;
  let updating_value;
  let t0;
  let pinnedfiltertoggles;
  let t1;
  let filtermenu;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  function search_value_binding(value) {
    ctx[13](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[0] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[0];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  pinnedfiltertoggles = new PinnedFilterToggles({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[10]
      ),
      filters: ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx[3].filterPins,
        /*$context*/
        ctx[3].filterData,
        /*tabId*/
        ctx[10]
      )
    }
  });
  filtermenu = new FilterMenu({ props: { tabId: (
    /*tabId*/
    ctx[10]
  ) } });
  let each_value_2 = ensure_array_like(
    /*utilityBarCommands*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[26].title
  );
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    let child_ctx = get_each_context_2$7(ctx, each_value_2, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_2$7(key, child_ctx));
  }
  return {
    c() {
      create_component(search.$$.fragment);
      t0 = space();
      create_component(pinnedfiltertoggles.$$.fragment);
      t1 = space();
      create_component(filtermenu.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      insert(target, t0, anchor);
      mount_component(pinnedfiltertoggles, target, anchor);
      insert(target, t1, anchor);
      mount_component(filtermenu, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_changes = {};
      if (!updating_value && dirty & /*searchCriteria*/
      1) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      const pinnedfiltertoggles_changes = {};
      if (dirty & /*$context*/
      8) pinnedfiltertoggles_changes.filters = ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx2[3].filterPins,
        /*$context*/
        ctx2[3].filterData,
        /*tabId*/
        ctx2[10]
      );
      pinnedfiltertoggles.$set(pinnedfiltertoggles_changes);
      if (dirty & /*utilityBarCommands*/
      32) {
        each_value_2 = ensure_array_like(
          /*utilityBarCommands*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2$7, each_1_anchor, get_each_context_2$7);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(pinnedfiltertoggles.$$.fragment, local);
      transition_in(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(pinnedfiltertoggles.$$.fragment, local);
      transition_out(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(search, detaching);
      destroy_component(pinnedfiltertoggles, detaching);
      destroy_component(filtermenu, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_else_block$N(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*features*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[17].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$y(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$y(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*features, $context, $itemIdsToShow, classicControlsColumnWidth, controls, localize, $settingStore, toggleSummary, searchCriteria*/
      33556895) {
        each_value = ensure_array_like(
          /*features*/
          ctx2[2]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$y, each_1_anchor, get_each_context$y);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block$1a(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot$17] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      536870912) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_if_block_1$K(ctx) {
  let show_if = (
    /*searchCriteria*/
    ctx[0].trim() === "" && /*$context*/
    ctx[3].unlocked || /*visibleItemCount*/
    ctx[20] > 0
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_2$z(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*searchCriteria, $context, features, $itemIdsToShow*/
      141) show_if = /*searchCriteria*/
      ctx2[0].trim() === "" && /*$context*/
      ctx2[3].unlocked || /*visibleItemCount*/
      ctx2[20] > 0;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*searchCriteria, $context, features, $itemIdsToShow*/
          141) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_2$z(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[17].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[17].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$b],
        header: [create_header_slot$c]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtable_changes = {};
      if (dirty & /*features*/
      4) itemtable_changes.key = /*section*/
      ctx2[17].key;
      if (dirty & /*features*/
      4) itemtable_changes["data-custom-section"] = /*section*/
      ctx2[17].custom ? true : null;
      if (dirty & /*$$scope, features, $context, $itemIdsToShow, classicControlsColumnWidth, controls, $settingStore*/
      536871326) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function create_default_slot_14$5(ctx) {
  let t_value = (
    /*localize*/
    ctx[11](
      /*section*/
      ctx[17].label
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*features*/
      4 && t_value !== (t_value = /*localize*/
      ctx2[11](
        /*section*/
        ctx2[17].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_22$1(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_13$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope*/
      536870912) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_13$7(ctx) {
  let t_value = (
    /*localize*/
    ctx[11]("DND5E.Uses") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_21$1(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_12$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope*/
      536870912) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_12$8(ctx) {
  let t_value = (
    /*localize*/
    ctx[11]("DND5E.Usage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_20$1(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_11$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope*/
      536870912) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_11$9(ctx) {
  let t_value = (
    /*localize*/
    ctx[11]("DND5E.Level") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_19$2(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_10$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope*/
      536870912) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_10$d(ctx) {
  let t_value = (
    /*localize*/
    ctx[11]("DND5E.Requirements") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_18$2(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      16) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[4];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_9$d(ctx) {
  let itemtablecolumn;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block4_anchor;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_14$5] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*section*/
    ctx[17].showUsesColumn && create_if_block_22$1(ctx)
  );
  let if_block1 = (
    /*section*/
    ctx[17].showUsagesColumn && create_if_block_21$1(ctx)
  );
  let if_block2 = (
    /*section*/
    ctx[17].showLevelColumn && create_if_block_20$1(ctx)
  );
  let if_block3 = (
    /*section*/
    ctx[17].showRequirementsColumn && create_if_block_19$2(ctx)
  );
  let if_block4 = (
    /*$context*/
    ctx[3].editable && /*$context*/
    ctx[3].useClassicControls && create_if_block_18$2(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      t4 = space();
      if (if_block4) if_block4.c();
      if_block4_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, if_block4_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope, features*/
      536870916) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
      if (
        /*section*/
        ctx2[17].showUsesColumn
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[17].showUsagesColumn
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_21$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[17].showLevelColumn
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_20$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[17].showRequirementsColumn
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_19$2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t4.parentNode, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].editable && /*$context*/
        ctx2[3].useClassicControls
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$context*/
          8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_18$2(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block4_anchor);
      }
      destroy_component(itemtablecolumn, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
    }
  };
}
function create_header_slot$c(ctx) {
  let itemtableheaderrow;
  let t2;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_9$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, classicControlsColumnWidth, $context, features*/
      536870940) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_if_block_17$2(ctx) {
  let t2;
  return {
    c() {
      t2 = text("");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_16$2(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa-solid fa-link-slash align-self-center");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_15$4(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[11]("DND5E.ClassOriginal")
      );
      attr(i2, "class", "fas fa-crown primary-accent-color");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot_8$e(ctx) {
  let t0;
  let t1;
  let span;
  let t2_value = (
    /*item*/
    ctx[21].name + ""
  );
  let t2;
  let span_data_tidy_item_name_value;
  let t3;
  let if_block2_anchor;
  let if_block0 = (
    /*ctx*/
    ctx[22].parent && create_if_block_17$2()
  );
  let if_block1 = !/*section*/
  ctx[17].isClass && /*item*/
  ctx[21].type === "subclass" && create_if_block_16$2();
  let if_block2 = (
    /*item*/
    ctx[21].isOriginalClass && create_if_block_15$4(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
      t3 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*item*/
      ctx[21].name);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, span, anchor);
      append(span, t2);
      insert(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*ctx*/
        ctx2[22].parent
      ) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_17$2();
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*section*/
      ctx2[17].isClass && /*item*/
      ctx2[21].type === "subclass") {
        if (if_block1) ;
        else {
          if_block1 = create_if_block_16$2();
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*features*/
      4 && t2_value !== (t2_value = /*item*/
      ctx2[21].name + "")) set_data(t2, t2_value);
      if (dirty & /*features*/
      4 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*item*/
      ctx2[21].name)) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
      if (
        /*item*/
        ctx2[21].isOriginalClass
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_15$4(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(span);
        detach(t3);
        detach(if_block2_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_default_slot_7$f(ctx) {
  let itemusebutton;
  let t2;
  let itemname;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[3].editable,
      item: (
        /*item*/
        ctx[21]
      )
    }
  });
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[15](
        /*toggleSummary*/
        ctx[25]
      )
    );
  }
  itemname = new ItemName({
    props: {
      hasChildren: false,
      item: (
        /*item*/
        ctx[21]
      ),
      $$slots: { default: [create_default_slot_8$e] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t2 = space();
      create_component(itemname.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemname, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty & /*$context*/
      8) itemusebutton_changes.disabled = !/*$context*/
      ctx[3].editable;
      if (dirty & /*features*/
      4) itemusebutton_changes.item = /*item*/
      ctx[21];
      itemusebutton.$set(itemusebutton_changes);
      const itemname_changes = {};
      if (dirty & /*features*/
      4) itemname_changes.item = /*item*/
      ctx[21];
      if (dirty & /*$$scope, features, $context*/
      536870924) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(itemname.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(itemname.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemusebutton, detaching);
      destroy_component(itemname, detaching);
    }
  };
}
function create_if_block_14$5(ctx) {
  let inlinefavoriteicon;
  let current;
  inlinefavoriteicon = new InlineFavoriteIcon({});
  return {
    c() {
      create_component(inlinefavoriteicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinefavoriteicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(inlinefavoriteicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinefavoriteicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinefavoriteicon, detaching);
    }
  };
}
function create_if_block_10$6(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_6$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, features, $context*/
      536870924) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_else_block_1$c(ctx) {
  let itemadduses;
  let current;
  itemadduses = new ItemAddUses({ props: { item: (
    /*item*/
    ctx[21]
  ) } });
  return {
    c() {
      create_component(itemadduses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemadduses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemadduses_changes = {};
      if (dirty & /*features*/
      4) itemadduses_changes.item = /*item*/
      ctx2[21];
      itemadduses.$set(itemadduses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemadduses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemadduses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemadduses, detaching);
    }
  };
}
function create_if_block_13$5(ctx) {
  let itemuses;
  let current;
  itemuses = new ItemUses({ props: { item: (
    /*item*/
    ctx[21]
  ) } });
  return {
    c() {
      create_component(itemuses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemuses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemuses_changes = {};
      if (dirty & /*features*/
      4) itemuses_changes.item = /*item*/
      ctx2[21];
      itemuses.$set(itemuses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemuses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemuses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemuses, detaching);
    }
  };
}
function create_if_block_12$5(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-bolt");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[11]("DND5E.Charged")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_11$5(ctx) {
  let rechargecontrol;
  let current;
  rechargecontrol = new RechargeControl({ props: { item: (
    /*item*/
    ctx[21]
  ) } });
  return {
    c() {
      create_component(rechargecontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rechargecontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rechargecontrol_changes = {};
      if (dirty & /*features*/
      4) rechargecontrol_changes.item = /*item*/
      ctx2[21];
      rechargecontrol.$set(rechargecontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rechargecontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rechargecontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rechargecontrol, detaching);
    }
  };
}
function create_default_slot_6$h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_11$5,
    create_if_block_12$5,
    create_if_block_13$5,
    create_else_block_1$c
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*item*/
      ctx2[21].isOnCooldown
    ) return 0;
    if (
      /*item*/
      ctx2[21].system.recharge?.value
    ) return 1;
    if (
      /*ctx*/
      ctx2[22]?.hasUses
    ) return 2;
    return 3;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_8$9(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_5$m] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, features*/
      536870916) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_if_block_9$8(ctx) {
  let t_value = (
    /*item*/
    (ctx[21].labels?.activation ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*features*/
      4 && t_value !== (t_value = /*item*/
      (ctx2[21].labels?.activation ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_5$m(ctx) {
  let if_block_anchor;
  let if_block = (
    /*item*/
    ctx[21].system.activation?.type && create_if_block_9$8(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[21].system.activation?.type
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_9$8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_6$e(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_4$q] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, $context, features*/
      536870924) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_if_block_7$c(ctx) {
  let levelupdropdown;
  let current;
  levelupdropdown = new LevelUpDropdown({
    props: {
      availableLevels: (
        /*ctx*/
        ctx[22]?.availableLevels
      ),
      item: (
        /*item*/
        ctx[21]
      ),
      disabled: !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockLevelSelector
    }
  });
  return {
    c() {
      create_component(levelupdropdown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(levelupdropdown, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const levelupdropdown_changes = {};
      if (dirty & /*$context, features*/
      12) levelupdropdown_changes.availableLevels = /*ctx*/
      ctx2[22]?.availableLevels;
      if (dirty & /*features*/
      4) levelupdropdown_changes.item = /*item*/
      ctx2[21];
      if (dirty & /*$context*/
      8) levelupdropdown_changes.disabled = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockLevelSelector;
      levelupdropdown.$set(levelupdropdown_changes);
    },
    i(local) {
      if (current) return;
      transition_in(levelupdropdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(levelupdropdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(levelupdropdown, detaching);
    }
  };
}
function create_default_slot_4$q(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*item*/
    ctx[21].type === "class" && create_if_block_7$c(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[21].type === "class"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_5$h(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_3$t] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, features*/
      536870916) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_3$t(ctx) {
  let span;
  let t_value = (
    /*item*/
    (ctx[21].system.requirements ?? "") + ""
  );
  let t2;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "truncate");
      attr(span, "title", span_title_value = /*item*/
      ctx[21].system.requirements ?? "");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*features*/
      4 && t_value !== (t_value = /*item*/
      (ctx2[21].system.requirements ?? "") + "")) set_data(t2, t_value);
      if (dirty & /*features*/
      4 && span_title_value !== (span_title_value = /*item*/
      ctx2[21].system.requirements ?? "")) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_4$k(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_2$u] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      16) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[4];
      if (dirty & /*$$scope, controls, features*/
      536870918) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_2$u(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[1]
      ),
      params: { item: (
        /*item*/
        ctx[21]
      ) }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      2) classiccontrols_changes.controls = /*controls*/
      ctx2[1];
      if (dirty & /*features*/
      4) classiccontrols_changes.params = { item: (
        /*item*/
        ctx2[21]
      ) };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot_1$A(ctx) {
  let itemtablecell;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let if_block5_anchor;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_7$f] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$settingStore*/
    ctx[8].showIconsNextToTheItemName && "favoriteId" in /*ctx*/
    ctx[22] && !!/*ctx*/
    ctx[22].favoriteId && create_if_block_14$5()
  );
  let if_block1 = (
    /*section*/
    ctx[17].showUsesColumn && create_if_block_10$6(ctx)
  );
  let if_block2 = (
    /*section*/
    ctx[17].showUsagesColumn && create_if_block_8$9(ctx)
  );
  let if_block3 = (
    /*section*/
    ctx[17].showLevelColumn && create_if_block_6$e(ctx)
  );
  let if_block4 = (
    /*section*/
    ctx[17].showRequirementsColumn && create_if_block_5$h(ctx)
  );
  let if_block5 = (
    /*$context*/
    ctx[3].editable && /*$context*/
    ctx[3].useClassicControls && create_if_block_4$k(ctx)
  );
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      t4 = space();
      if (if_block4) if_block4.c();
      t5 = space();
      if (if_block5) if_block5.c();
      if_block5_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block5) if_block5.m(target, anchor);
      insert(target, if_block5_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, features, toggleSummary, $context*/
      570425356) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
      if (
        /*$settingStore*/
        ctx2[8].showIconsNextToTheItemName && "favoriteId" in /*ctx*/
        ctx2[22] && !!/*ctx*/
        ctx2[22].favoriteId
      ) {
        if (if_block0) {
          if (dirty & /*$settingStore, $context, features*/
          268) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14$5();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[17].showUsesColumn
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_10$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[17].showUsagesColumn
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_8$9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[17].showLevelColumn
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_6$e(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t4.parentNode, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[17].showRequirementsColumn
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_5$h(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t5.parentNode, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].editable && /*$context*/
        ctx2[3].useClassicControls
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*$context*/
          8) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_4$k(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(if_block5_anchor);
      }
      destroy_component(itemtablecell, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      if (if_block5) if_block5.d(detaching);
    }
  };
}
function create_each_block_1$h(key_1, ctx) {
  let first;
  let itemtablerow;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[16](
        /*item*/
        ctx[21],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      item: (
        /*item*/
        ctx[21]
      ),
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[21].uuid
        )
      },
      hidden: !!/*$itemIdsToShow*/
      ctx[7] && !/*$itemIdsToShow*/
      ctx[7].has(
        /*item*/
        ctx[21].id
      ),
      $$slots: {
        default: [
          create_default_slot_1$A,
          ({ toggleSummary }) => ({ 25: toggleSummary }),
          ({ toggleSummary }) => toggleSummary ? 33554432 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*features*/
      4) itemtablerow_changes.item = /*item*/
      ctx[21];
      if (dirty & /*features*/
      4) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[21].uuid
        )
      };
      if (dirty & /*$itemIdsToShow, features*/
      132) itemtablerow_changes.hidden = !!/*$itemIdsToShow*/
      ctx[7] && !/*$itemIdsToShow*/
      ctx[7].has(
        /*item*/
        ctx[21].id
      );
      if (dirty & /*$$scope, classicControlsColumnWidth, controls, features, $context, $settingStore, toggleSummary*/
      570425630) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_if_block_3$s(ctx) {
  let itemtablefooter;
  let current;
  itemtablefooter = new ItemTableFooter({
    props: {
      section: (
        /*section*/
        ctx[17]
      ),
      actor: (
        /*$context*/
        ctx[3].actor
      ),
      isItem: true
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablefooter_changes = {};
      if (dirty & /*features*/
      4) itemtablefooter_changes.section = /*section*/
      ctx2[17];
      if (dirty & /*$context*/
      8) itemtablefooter_changes.actor = /*$context*/
      ctx2[3].actor;
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$b(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let t1;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[17].items
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[21].id
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$h(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$h(key, child_ctx));
  }
  let if_block = (
    /*$context*/
    ctx[3].unlocked && create_if_block_3$s(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*features, $itemIdsToShow, classicControlsColumnWidth, controls, $context, localize, $settingStore, toggleSummary*/
      33556894) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[17].items
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, t0.parentNode, outro_and_destroy_block, create_each_block_1$h, t0, get_each_context_1$h);
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].unlocked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$s(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_each_block$y(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[17].show && create_if_block_1$K(get_if_ctx$9(ctx))
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*section*/
        ctx[17].show
      ) {
        if (if_block) {
          if_block.p(get_if_ctx$9(ctx), dirty);
          if (dirty & /*features*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$K(get_if_ctx$9(ctx));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$17(ctx) {
  let t_value = (
    /*localize*/
    ctx[11]("TIDY5E.EmptySection") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$2v(ctx) {
  let utilitytoolbar;
  let t2;
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  utilitytoolbar = new UtilityToolbar({
    props: {
      $$slots: { default: [create_default_slot_15$2] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block$1a, create_else_block$N];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noFeatures*/
      ctx2[6] && !/*$context*/
      ctx2[3].unlocked
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(utilitytoolbar.$$.fragment);
      t2 = space();
      div = element("div");
      if_block.c();
      attr(div, "class", "scroll-container flex-column small-gap");
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEMS_CONTAINER);
    },
    m(target, anchor) {
      mount_component(utilitytoolbar, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const utilitytoolbar_changes = {};
      if (dirty & /*$$scope, utilityBarCommands, $context, searchCriteria*/
      536870953) {
        utilitytoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      utilitytoolbar.$set(utilitytoolbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(utilitytoolbar, detaching);
      if_blocks[current_block_type_index].d();
    }
  };
}
let classicControlsIconWidth$6 = 1.25;
function instance$2v($$self, $$props, $$invalidate) {
  let features;
  let noFeatures;
  let utilityBarCommands;
  let classicControlsColumnWidth;
  let $context;
  let $itemIdsToShow;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(8, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  const localize = FoundryAdapter.localize;
  const itemIdsToShow = writable(void 0);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(7, $itemIdsToShow = value));
  setContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW, itemIdsToShow);
  let searchCriteria = "";
  declareLocation("features");
  let controls = [];
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(0, searchCriteria);
  }
  const execute_handler = (command, ev) => command.execute?.(ev.detail);
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (item, event) => FoundryAdapter.editOnMiddleClick(event.detail, item);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    8) {
      $$invalidate(2, features = SheetSections.configureFeatures($context.features, $context, tabId, SheetPreferencesService.getByType($context.actor.type), TidyFlags.sectionConfig.get($context.actor)?.[tabId]));
    }
    if ($$self.$$.dirty & /*features*/
    4) {
      $$invalidate(6, noFeatures = features.some((section) => section.items.length > 0) === false);
    }
    if ($$self.$$.dirty & /*searchCriteria, $context, features*/
    13) {
      {
        set_store_value(
          itemIdsToShow,
          $itemIdsToShow = ItemVisibility.getItemsToShowAtDepth({
            criteria: searchCriteria,
            itemContext: $context.itemContext,
            sections: features,
            tabId
          }),
          $itemIdsToShow
        );
      }
    }
    if ($$self.$$.dirty & /*$context*/
    8) {
      $$invalidate(5, utilityBarCommands = $context.utilities[tabId]?.utilityToolbarCommands ?? []);
    }
    if ($$self.$$.dirty & /*$context, controls*/
    10) {
      {
        $$invalidate(1, controls = [
          {
            component: ItemFavoriteControl,
            props: ({ item }) => ({ item })
          },
          {
            component: ItemEditControl,
            props: ({ item }) => ({ item })
          }
        ]);
        if ($context.unlocked) {
          controls.push({
            component: ItemDeleteControl,
            props: ({ item }) => ({ item })
          });
        }
        if ($context.useActionsFeature) {
          controls.push({
            component: ActionFilterOverrideControl,
            props: ({ item }) => ({ item })
          });
        }
      }
    }
    if ($$self.$$.dirty & /*controls*/
    2) {
      $$invalidate(4, classicControlsColumnWidth = `${classicControlsIconWidth$6 * controls.length}rem`);
    }
  };
  return [
    searchCriteria,
    controls,
    features,
    $context,
    classicControlsColumnWidth,
    utilityBarCommands,
    noFeatures,
    $itemIdsToShow,
    $settingStore,
    context,
    tabId,
    localize,
    itemIdsToShow,
    search_value_binding,
    execute_handler,
    toggle_handler,
    mousedown_handler
  ];
}
class CharacterFeaturesTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2v, create_fragment$2v, safe_not_equal, {});
  }
}
function create_default_slot$16(ctx) {
  let dnd5eicon;
  let t0;
  let span;
  let t1_value = (
    /*condition*/
    ctx[0].name + ""
  );
  let t1;
  let current;
  dnd5eicon = new Dnd5eIcon({
    props: { src: (
      /*condition*/
      ctx[0].icon
    ) }
  });
  return {
    c() {
      create_component(dnd5eicon.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(span, "class", "flex-1 truncate");
    },
    m(target, anchor) {
      mount_component(dnd5eicon, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eicon_changes = {};
      if (dirty & /*condition*/
      1) dnd5eicon_changes.src = /*condition*/
      ctx2[0].icon;
      dnd5eicon.$set(dnd5eicon_changes);
      if ((!current || dirty & /*condition*/
      1) && t1_value !== (t1_value = /*condition*/
      ctx2[0].name + "")) set_data(t1, t1_value);
    },
    i(local) {
      if (current) return;
      transition_in(dnd5eicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      destroy_component(dnd5eicon, detaching);
    }
  };
}
function create_fragment$2u(ctx) {
  let tidyswitch;
  let updating_value;
  let current;
  function tidyswitch_value_binding(value) {
    ctx[5](value);
  }
  let tidyswitch_props = {
    class: "flex-row small-gap tidy-condition-toggle " + /*switchOn*/
    (ctx[1] ? "active" : "inactive"),
    title: (
      /*condition*/
      ctx[0].name
    ),
    disabled: !/*$context*/
    ctx[2].editable,
    "data-uuid": (
      /*condition*/
      ctx[0].reference
    ),
    "data-condition-id": (
      /*condition*/
      ctx[0].id
    ),
    "data-tidy-sheet-part": CONSTANTS.SHEET_PARTS.CONDITION_TOGGLE,
    $$slots: { default: [create_default_slot$16] },
    $$scope: { ctx }
  };
  if (
    /*switchOn*/
    ctx[1] !== void 0
  ) {
    tidyswitch_props.value = /*switchOn*/
    ctx[1];
  }
  tidyswitch = new TidySwitch({ props: tidyswitch_props });
  binding_callbacks.push(() => bind(tidyswitch, "value", tidyswitch_value_binding));
  tidyswitch.$on(
    "change",
    /*change_handler*/
    ctx[6]
  );
  return {
    c() {
      create_component(tidyswitch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidyswitch, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tidyswitch_changes = {};
      if (dirty & /*switchOn*/
      2) tidyswitch_changes.class = "flex-row small-gap tidy-condition-toggle " + /*switchOn*/
      (ctx2[1] ? "active" : "inactive");
      if (dirty & /*condition*/
      1) tidyswitch_changes.title = /*condition*/
      ctx2[0].name;
      if (dirty & /*$context*/
      4) tidyswitch_changes.disabled = !/*$context*/
      ctx2[2].editable;
      if (dirty & /*condition*/
      1) tidyswitch_changes["data-uuid"] = /*condition*/
      ctx2[0].reference;
      if (dirty & /*condition*/
      1) tidyswitch_changes["data-condition-id"] = /*condition*/
      ctx2[0].id;
      if (dirty & /*$$scope, condition*/
      129) {
        tidyswitch_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & /*switchOn*/
      2) {
        updating_value = true;
        tidyswitch_changes.value = /*switchOn*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      tidyswitch.$set(tidyswitch_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidyswitch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidyswitch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidyswitch, detaching);
    }
  };
}
function instance$2u($$self, $$props, $$invalidate) {
  let $context;
  const context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let { condition } = $$props;
  let switchOn = !condition.disabled;
  async function handleChange(originalValue) {
    try {
      await FoundryAdapter.toggleCondition($context.actor, condition);
    } catch (e2) {
      error("An error occurred while toggling a condition", false, e2);
      debug("Condition toggle error troubleshooting info", { condition, state: switchOn });
      $$invalidate(1, switchOn = originalValue);
    }
  }
  function tidyswitch_value_binding(value) {
    switchOn = value;
    $$invalidate(1, switchOn), $$invalidate(0, condition);
  }
  const change_handler = (ev) => handleChange(ev.detail.originalValue);
  $$self.$$set = ($$props2) => {
    if ("condition" in $$props2) $$invalidate(0, condition = $$props2.condition);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*condition*/
    1) {
      {
        $$invalidate(1, switchOn = !condition.disabled);
      }
    }
  };
  return [
    condition,
    switchOn,
    $context,
    context,
    handleChange,
    tidyswitch_value_binding,
    change_handler
  ];
}
class ConditionToggle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2u, create_fragment$2u, safe_not_equal, { condition: 0 });
  }
}
function get_each_context$x(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_default_slot_1$z(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("DND5E.Conditions") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$15(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_1$z] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope*/
      64) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_header_slot$b(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot$15] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope*/
      64) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_each_block$x(key_1, ctx) {
  let li;
  let conditiontoggle;
  let t2;
  let li_data_uuid_value;
  let li_data_condition_id_value;
  let current;
  conditiontoggle = new ConditionToggle({
    props: { condition: (
      /*condition*/
      ctx[3]
    ) }
  });
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      create_component(conditiontoggle.$$.fragment);
      t2 = space();
      attr(li, "class", "condition");
      attr(li, "data-uuid", li_data_uuid_value = /*condition*/
      ctx[3].reference);
      attr(li, "data-condition-id", li_data_condition_id_value = /*condition*/
      ctx[3].id);
      toggle_class(li, "active", !/*condition*/
      ctx[3].disabled);
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(conditiontoggle, li, null);
      append(li, t2);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const conditiontoggle_changes = {};
      if (dirty & /*$context*/
      1) conditiontoggle_changes.condition = /*condition*/
      ctx[3];
      conditiontoggle.$set(conditiontoggle_changes);
      if (!current || dirty & /*$context*/
      1 && li_data_uuid_value !== (li_data_uuid_value = /*condition*/
      ctx[3].reference)) {
        attr(li, "data-uuid", li_data_uuid_value);
      }
      if (!current || dirty & /*$context*/
      1 && li_data_condition_id_value !== (li_data_condition_id_value = /*condition*/
      ctx[3].id)) {
        attr(li, "data-condition-id", li_data_condition_id_value);
      }
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(li, "active", !/*condition*/
        ctx[3].disabled);
      }
    },
    i(local) {
      if (current) return;
      transition_in(conditiontoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(conditiontoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(conditiontoggle);
    }
  };
}
function create_body_slot$a(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[0].conditions
  );
  const get_key = (ctx2) => (
    /*condition*/
    ctx2[3].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$x(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$x(key, child_ctx));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "conditions-list svelte-1i7xe53");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[0].conditions
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$x, null, get_each_context$x);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_fragment$2t(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: "conditions",
      $$slots: {
        body: [create_body_slot$a],
        header: [create_header_slot$b]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*$$scope, $context*/
      65) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function instance$2t($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ActorConditions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2t, create_fragment$2t, safe_not_equal, {});
  }
}
function create_else_block_1$b(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "";
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$19(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$J, create_else_block$M];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*isConcentration*/
      ctx2[2]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$M(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      iconCssClass: `fas ${/*actualEffect*/
      ctx[0].disabled ? "fa-check" : "fa-times"}`,
      onclick: (
        /*func_1*/
        ctx[7]
      ),
      title: (
        /*actualEffect*/
        ctx[0].disabled ? (
          /*localize*/
          ctx[4]("DND5E.EffectEnable")
        ) : (
          /*localize*/
          ctx[4]("DND5E.EffectDisable")
        )
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemcontrol_changes = {};
      if (dirty & /*actualEffect*/
      1) itemcontrol_changes.iconCssClass = `fas ${/*actualEffect*/
      ctx2[0].disabled ? "fa-check" : "fa-times"}`;
      if (dirty & /*actualEffect*/
      1) itemcontrol_changes.onclick = /*func_1*/
      ctx2[7];
      if (dirty & /*actualEffect*/
      1) itemcontrol_changes.title = /*actualEffect*/
      ctx2[0].disabled ? (
        /*localize*/
        ctx2[4]("DND5E.EffectEnable")
      ) : (
        /*localize*/
        ctx2[4]("DND5E.EffectDisable")
      );
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function create_if_block_1$J(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      iconSrc: `systems/dnd5e/icons/svg/break-concentration.svg`,
      onclick: (
        /*func*/
        ctx[6]
      ),
      title: (
        /*localize*/
        ctx[4]("DND5E.ConcentrationBreak")
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemcontrol_changes = {};
      if (dirty & /*$context, actualEffect*/
      3) itemcontrol_changes.onclick = /*func*/
      ctx2[6];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function create_fragment$2s(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$19, create_else_block_1$b];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*actualEffect*/
      ctx2[0]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2s($$self, $$props, $$invalidate) {
  let actualEffect;
  let isConcentration;
  let $context;
  let { effect } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const localize = FoundryAdapter.localize;
  const func2 = () => $context.actor.endConcentration(actualEffect);
  const func_12 = () => actualEffect.update({ disabled: !actualEffect.disabled });
  $$self.$$set = ($$props2) => {
    if ("effect" in $$props2) $$invalidate(5, effect = $$props2.effect);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*effect, $context*/
    34) {
      $$invalidate(0, actualEffect = effect instanceof dnd5e.documents.ActiveEffect5e ? effect : !!effect ? FoundryAdapter.getEffect({
        document: $context.actor,
        effectId: effect.id,
        parentId: effect.parentId
      }) : void 0);
    }
    if ($$self.$$.dirty & /*actualEffect, $context*/
    3) {
      $$invalidate(2, isConcentration = FoundryAdapter.isConcentrationEffect(actualEffect, $context.actor.sheet));
    }
  };
  return [
    actualEffect,
    $context,
    isConcentration,
    context,
    localize,
    effect,
    func2,
    func_12
  ];
}
class ActorEffectToggleControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2s, create_fragment$2s, safe_not_equal, { effect: 5 });
  }
}
function create_fragment$2r(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      iconCssClass: "fas fa-bookmark",
      active: (
        /*active*/
        ctx[1]
      ),
      title: (
        /*title*/
        ctx[2]
      ),
      onclick: (
        /*func*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*active*/
      2) itemcontrol_changes.active = /*active*/
      ctx2[1];
      if (dirty & /*title*/
      4) itemcontrol_changes.title = /*title*/
      ctx2[2];
      if (dirty & /*effect*/
      1) itemcontrol_changes.onclick = /*func*/
      ctx2[4];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$2r($$self, $$props, $$invalidate) {
  let active2;
  let title;
  let { effect } = $$props;
  let { actor } = $$props;
  const func2 = () => {
    const actor2 = effect.source.actor ?? effect.source;
    const document2 = FoundryAdapter.getEffect({
      document: actor2,
      effectId: effect.id,
      parentId: effect.parentId
    });
    FoundryAdapter.toggleFavoriteEffect(document2);
  };
  $$self.$$set = ($$props2) => {
    if ("effect" in $$props2) $$invalidate(0, effect = $$props2.effect);
    if ("actor" in $$props2) $$invalidate(3, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*effect, actor*/
    9) {
      $$invalidate(1, active2 = FoundryAdapter.isActiveEffectContextFavorited(effect, actor));
    }
    if ($$self.$$.dirty & /*active*/
    2) {
      $$invalidate(2, title = FoundryAdapter.localize(active2 ? "TIDY5E.RemoveFavorite" : "TIDY5E.AddFavorite"));
    }
  };
  return [effect, active2, title, actor, func2];
}
class EffectFavoriteControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2r, create_fragment$2r, safe_not_equal, { effect: 0, actor: 3 });
  }
}
function get_each_context$w(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function get_each_context_1$g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_if_block_8$8(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot_10$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_default_slot_10$c(ctx) {
  let t_value = (
    /*localize*/
    ctx[7]("TIDY5E.GMOnlyEdit") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_else_block$L(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*effectSections*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$w(get_each_context$w(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections, $context, classicControlsColumnWidth, controls, $settingStore, localize*/
      175) {
        each_value = ensure_array_like(
          /*effectSections*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$w(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$w(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$I(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot$14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_if_block_2$y(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    (ctx[2].unlocked && /*$context*/
    ctx[2].allowEffectsManagement || /*section*/
    ctx[11].effects.length > 0) && create_if_block_3$r(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[2].unlocked && /*$context*/
        ctx2[2].allowEffectsManagement || /*section*/
        ctx2[11].effects.length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context, effectSections*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$r(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_3$r(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[11].label
      ),
      $$slots: {
        body: [create_body_slot$9],
        header: [create_header_slot$a]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtable_changes = {};
      if (dirty & /*effectSections*/
      2) itemtable_changes.key = /*section*/
      ctx2[11].label;
      if (dirty & /*$$scope, $context, effectSections, classicControlsColumnWidth, controls, $settingStore*/
      131119) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function create_default_slot_9$c(ctx) {
  let t_value = (
    /*localize*/
    ctx[7](
      /*section*/
      ctx[11].label
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[7](
        /*section*/
        ctx2[11].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_8$d(ctx) {
  let t_value = (
    /*localize*/
    ctx[7]("DND5E.Source") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7$e(ctx) {
  let t_value = (
    /*localize*/
    ctx[7]("DND5E.Duration") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_7$b(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      8) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[3];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_6$g(ctx) {
  let itemtablecolumn0;
  let t0;
  let itemtablecolumn1;
  let t1;
  let itemtablecolumn2;
  let t2;
  let if_block_anchor;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_9$c] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: "12.5rem",
      $$slots: { default: [create_default_slot_8$d] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn2 = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_7$e] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_7$b(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t1 = space();
      create_component(itemtablecolumn2.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope, effectSections*/
      131074) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
      const itemtablecolumn2_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        itemtablecolumn2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn2.$set(itemtablecolumn2_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7$b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(itemtablecolumn2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(itemtablecolumn2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
      destroy_component(itemtablecolumn2, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_header_slot$a(ctx) {
  let itemtableheaderrow;
  let t2;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_6$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, classicControlsColumnWidth, $context, effectSections*/
      131086) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_default_slot_5$l(ctx) {
  let itemimage;
  let t0;
  let span;
  let t1_value = (
    /*effectContext*/
    ctx[14].name + ""
  );
  let t1;
  let span_data_tidy_effect_name_value;
  let current;
  itemimage = new ItemImage({
    props: { src: (
      /*effectContext*/
      ctx[14].img
    ) }
  });
  return {
    c() {
      create_component(itemimage.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(span, "class", "align-self-center truncate");
      attr(span, "data-tidy-effect-name", span_data_tidy_effect_name_value = /*effectContext*/
      ctx[14].name);
    },
    m(target, anchor) {
      mount_component(itemimage, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const itemimage_changes = {};
      if (dirty & /*effectSections*/
      2) itemimage_changes.src = /*effectContext*/
      ctx2[14].img;
      itemimage.$set(itemimage_changes);
      if ((!current || dirty & /*effectSections*/
      2) && t1_value !== (t1_value = /*effectContext*/
      ctx2[14].name + "")) set_data(t1, t1_value);
      if (!current || dirty & /*effectSections*/
      2 && span_data_tidy_effect_name_value !== (span_data_tidy_effect_name_value = /*effectContext*/
      ctx2[14].name)) {
        attr(span, "data-tidy-effect-name", span_data_tidy_effect_name_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemimage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemimage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      destroy_component(itemimage, detaching);
    }
  };
}
function create_if_block_6$d(ctx) {
  let inlinefavoriteicon;
  let current;
  inlinefavoriteicon = new InlineFavoriteIcon({});
  return {
    c() {
      create_component(inlinefavoriteicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinefavoriteicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(inlinefavoriteicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinefavoriteicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinefavoriteicon, detaching);
    }
  };
}
function create_default_slot_4$p(ctx) {
  let t_value = (
    /*effectContext*/
    (ctx[14].source?.name ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*effectContext*/
      (ctx2[14].source?.name ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$s(ctx) {
  let t_value = (
    /*effectContext*/
    (ctx[14].duration?.label ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*effectContext*/
      (ctx2[14].duration?.label ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_5$g(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_2$t] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      8) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[3];
      if (dirty & /*$$scope, controls, effectSections*/
      131075) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_2$t(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[0]
      ),
      params: { effect: (
        /*effectContext*/
        ctx[14]
      ) }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      1) classiccontrols_changes.controls = /*controls*/
      ctx2[0];
      if (dirty & /*effectSections*/
      2) classiccontrols_changes.params = { effect: (
        /*effectContext*/
        ctx2[14]
      ) };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot_1$y(ctx) {
  let itemtablecell0;
  let t0;
  let show_if = FoundryAdapter.isActiveEffectContextFavorited(
    /*effectContext*/
    ctx[14],
    /*$context*/
    ctx[2].actor
  ) && /*$settingStore*/
  ctx[5].showIconsNextToTheItemName;
  let t1;
  let itemtablecell1;
  let t2;
  let itemtablecell2;
  let t3;
  let if_block1_anchor;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      attributes: {
        "data-tidy-effect-name-container": true,
        "data-effect-id": (
          /*effectContext*/
          ctx[14].id
        )
      },
      $$slots: { default: [create_default_slot_5$l] },
      $$scope: { ctx }
    }
  });
  let if_block0 = show_if && create_if_block_6$d();
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "12.5rem",
      $$slots: { default: [create_default_slot_4$p] },
      $$scope: { ctx }
    }
  });
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_3$s] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_5$g(ctx)
  );
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      create_component(itemtablecell1.$$.fragment);
      t2 = space();
      create_component(itemtablecell2.$$.fragment);
      t3 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t3, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*effectSections*/
      2) itemtablecell0_changes.attributes = {
        "data-tidy-effect-name-container": true,
        "data-effect-id": (
          /*effectContext*/
          ctx2[14].id
        )
      };
      if (dirty & /*$$scope, effectSections*/
      131074) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      if (dirty & /*effectSections, $context, $settingStore*/
      38) show_if = FoundryAdapter.isActiveEffectContextFavorited(
        /*effectContext*/
        ctx2[14],
        /*$context*/
        ctx2[2].actor
      ) && /*$settingStore*/
      ctx2[5].showIconsNextToTheItemName;
      if (show_if) {
        if (if_block0) {
          if (dirty & /*effectSections, $context, $settingStore*/
          38) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$d();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemtablecell1_changes = {};
      if (dirty & /*$$scope, effectSections*/
      131074) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      const itemtablecell2_changes = {};
      if (dirty & /*$$scope, effectSections*/
      131074) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5$g(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(itemtablecell2.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(itemtablecell2.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block1_anchor);
      }
      destroy_component(itemtablecell0, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemtablecell1, detaching);
      destroy_component(itemtablecell2, detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_each_block_1$g(ctx) {
  let itemtablerow;
  let current;
  function func2() {
    return (
      /*func*/
      ctx[8](
        /*effectContext*/
        ctx[14]
      )
    );
  }
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[9](
        /*effectContext*/
        ctx[14],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS,
        uuid: (
          /*effectContext*/
          ctx[14].uuid
        )
      },
      getDragData: func2,
      effect: (
        /*effectContext*/
        ctx[14]
      ),
      $$slots: { default: [create_default_slot_1$y] },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    c() {
      create_component(itemtablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*effectSections*/
      2) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS,
        uuid: (
          /*effectContext*/
          ctx[14].uuid
        )
      };
      if (dirty & /*$context, effectSections*/
      6) itemtablerow_changes.getDragData = func2;
      if (dirty & /*effectSections*/
      2) itemtablerow_changes.effect = /*effectContext*/
      ctx[14];
      if (dirty & /*$$scope, classicControlsColumnWidth, controls, effectSections, $context, $settingStore*/
      131119) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_if_block_4$j(ctx) {
  let itemtablefooter;
  let current;
  function func_12() {
    return (
      /*func_1*/
      ctx[10](
        /*section*/
        ctx[11]
      )
    );
  }
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[2].actor
      ),
      section: (
        /*section*/
        ctx[11]
      ),
      create: func_12,
      isItem: false
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablefooter_changes = {};
      if (dirty & /*$context*/
      4) itemtablefooter_changes.actor = /*$context*/
      ctx[2].actor;
      if (dirty & /*effectSections*/
      2) itemtablefooter_changes.section = /*section*/
      ctx[11];
      if (dirty & /*effectSections, $context*/
      6) itemtablefooter_changes.create = func_12;
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$9(ctx) {
  let t0;
  let t1;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[11].effects
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$g(get_each_context_1$g(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = (
    /*$context*/
    ctx[2].unlocked && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_4$j(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections, $context, classicControlsColumnWidth, controls, $settingStore*/
      47) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[11].effects
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$g(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$g(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].unlocked && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4$j(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_each_block$w(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*section*/
  ctx[11].hidden && create_if_block_2$y(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*section*/
      ctx2[11].hidden) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*effectSections*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$14(ctx) {
  let t_value = (
    /*localize*/
    ctx[7]("TIDY5E.EmptySection") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$18(ctx) {
  let actorconditions;
  let current;
  actorconditions = new ActorConditions({});
  return {
    c() {
      create_component(actorconditions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actorconditions, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(actorconditions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorconditions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actorconditions, detaching);
    }
  };
}
function create_fragment$2q(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let current;
  let if_block0 = !/*$context*/
  ctx[2].allowEffectsManagement && /*$context*/
  ctx[2].unlocked && create_if_block_8$8(ctx);
  const if_block_creators = [create_if_block_1$I, create_else_block$L];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noEffects*/
      ctx2[4] && !/*$context*/
      ctx2[2].unlocked && /*$context*/
      ctx2[2].allowEffectsManagement
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = (
    /*$context*/
    ctx[2].conditions && create_if_block$18()
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      attr(div, "class", "scroll-container flex-column small-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      if (if_block2) if_block2.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*$context*/
      ctx2[2].allowEffectsManagement && /*$context*/
      ctx2[2].unlocked) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8$8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      if (
        /*$context*/
        ctx2[2].conditions
      ) {
        if (if_block2) {
          if (dirty & /*$context*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$18();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if_blocks[current_block_type_index].d();
      if (if_block2) if_block2.d();
    }
  };
}
let classicControlsIconWidth$5 = 1.25;
function instance$2q($$self, $$props, $$invalidate) {
  let effectSections;
  let noEffects;
  let classicControlsColumnWidth;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  const localize = FoundryAdapter.localize;
  declareLocation("effects");
  let controls = [];
  const func2 = (effectContext) => FoundryAdapter.getEffect({
    document: $context.actor,
    effectId: effectContext.id,
    parentId: effectContext.parentId
  })?.toDragData();
  const mousedown_handler = (effectContext, event) => FoundryAdapter.editOnMiddleClick(event.detail, FoundryAdapter.getEffect({
    document: $context.actor,
    effectId: effectContext.id,
    parentId: effectContext.parentId
  }));
  const func_12 = (section) => FoundryAdapter.addEffect(section.type, $context.actor);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(1, effectSections = Object.values($context.effects));
    }
    if ($$self.$$.dirty & /*effectSections*/
    2) {
      $$invalidate(4, noEffects = effectSections.some((section) => section.effects.length > 0) === false);
    }
    if ($$self.$$.dirty & /*controls, $context*/
    5) {
      {
        $$invalidate(0, controls = []);
        controls.push(
          {
            component: ActorEffectToggleControl,
            props: ({ effect }) => ({ effect })
          },
          {
            component: EffectFavoriteControl,
            props: ({ effect }) => ({ effect, actor: $context.actor })
          },
          {
            component: ItemControl,
            props: ({ effect }) => ({
              onclick: () => FoundryAdapter.getEffect({
                document: $context.actor,
                effectId: effect.id,
                parentId: effect.parentId
              }).sheet.render(true),
              title: localize("DND5E.EffectEdit"),
              iconCssClass: "fas fa-edit"
            })
          }
        );
        if ($context.unlocked) {
          controls.push({
            component: ItemControl,
            props: ({ effect }) => ({
              onclick: () => FoundryAdapter.getEffect({
                document: $context.actor,
                effectId: effect.id,
                parentId: effect.parentId
              }).deleteDialog(),
              title: localize("DND5E.EffectDelete"),
              iconCssClass: "fas fa-trash"
            })
          });
        }
      }
    }
    if ($$self.$$.dirty & /*controls*/
    1) {
      $$invalidate(3, classicControlsColumnWidth = `${classicControlsIconWidth$5 * controls.length}rem`);
    }
  };
  return [
    controls,
    effectSections,
    $context,
    classicControlsColumnWidth,
    noEffects,
    $settingStore,
    context,
    localize,
    func2,
    mousedown_handler,
    func_12
  ];
}
class CharacterEffectsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2q, create_fragment$2q, safe_not_equal, {});
  }
}
function create_fragment$2p(ctx) {
  let html_tag;
  let raw_value = FoundryAdapter.createEditorHtml(
    /*content*/
    ctx[0],
    /*target*/
    ctx[1],
    /*editable*/
    ctx[2]
  ) + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*content, target, editable*/
      7 && raw_value !== (raw_value = FoundryAdapter.createEditorHtml(
        /*content*/
        ctx2[0],
        /*target*/
        ctx2[1],
        /*editable*/
        ctx2[2]
      ) + "")) html_tag.p(raw_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function instance$2p($$self, $$props, $$invalidate) {
  let { content } = $$props;
  let { target } = $$props;
  let { editable } = $$props;
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2) $$invalidate(0, content = $$props2.content);
    if ("target" in $$props2) $$invalidate(1, target = $$props2.target);
    if ("editable" in $$props2) $$invalidate(2, editable = $$props2.editable);
  };
  return [content, target, editable];
}
class SheetEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2p, create_fragment$2p, safe_not_equal, { content: 0, target: 1, editable: 2 });
  }
}
function create_else_block$K(ctx) {
  let previous_tag = (
    /*element*/
    ctx[1]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*element*/
    ctx[1] && create_dynamic_element_1(ctx)
  );
  return {
    c() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*element*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*element*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*element*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*element*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*element*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
}
function create_if_block$17(ctx) {
  let previous_tag = (
    /*element*/
    ctx[1]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*element*/
    ctx[1] && create_dynamic_element$1(ctx)
  );
  return {
    c() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*element*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element$1(ctx2);
          previous_tag = /*element*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*element*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element$1(ctx2);
          previous_tag = /*element*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*element*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
}
function create_dynamic_element_1(ctx) {
  let svelte_element;
  let t2;
  let svelte_element_data_tooltip_value;
  let svelte_element_levels = [
    { class: (
      /*cssClass*/
      ctx[4]
    ) },
    { title: (
      /*title*/
      ctx[8]
    ) },
    { "data-tidy-field": (
      /*field*/
      ctx[2]
    ) },
    {
      "data-tooltip": svelte_element_data_tooltip_value = /*activeEffectApplied*/
      ctx[11] ? (
        /*overrideTooltip*/
        ctx[10]
      ) : null
    }
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  return {
    c() {
      svelte_element = element(
        /*element*/
        ctx[1]
      );
      t2 = text(
        /*value*/
        ctx[0]
      );
      set_dynamic_element_data(
        /*element*/
        ctx[1]
      )(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      append(svelte_element, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      1) set_data(
        t2,
        /*value*/
        ctx2[0]
      );
      set_dynamic_element_data(
        /*element*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        dirty & /*cssClass*/
        16 && { class: (
          /*cssClass*/
          ctx2[4]
        ) },
        dirty & /*title*/
        256 && { title: (
          /*title*/
          ctx2[8]
        ) },
        dirty & /*field*/
        4 && { "data-tidy-field": (
          /*field*/
          ctx2[2]
        ) },
        dirty & /*activeEffectApplied, overrideTooltip*/
        3072 && svelte_element_data_tooltip_value !== (svelte_element_data_tooltip_value = /*activeEffectApplied*/
        ctx2[11] ? (
          /*overrideTooltip*/
          ctx2[10]
        ) : null) && {
          "data-tooltip": svelte_element_data_tooltip_value
        }
      ]));
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
    }
  };
}
function create_dynamic_element$1(ctx) {
  let svelte_element;
  let svelte_element_class_value;
  let mounted;
  let dispose;
  let svelte_element_levels = [
    { contenteditable: "true" },
    {
      class: svelte_element_class_value = null_to_empty(
        /*cssClass*/
        ctx[4]
      ) + " svelte-1u33atu"
    },
    { role: "textbox" },
    { tabindex: "0" },
    { spellcheck: (
      /*spellcheck*/
      ctx[5]
    ) },
    {
      "data-max-length": (
        /*dataMaxLength*/
        ctx[6]
      )
    },
    {
      "data-placeholder": (
        /*placeholder*/
        ctx[7]
      )
    },
    { title: (
      /*title*/
      ctx[8]
    ) },
    { "data-tidy-field": (
      /*field*/
      ctx[2]
    ) }
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  return {
    c() {
      svelte_element = element(
        /*element*/
        ctx[1]
      );
      set_dynamic_element_data(
        /*element*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      if (
        /*draftValue*/
        ctx[12] === void 0
      ) add_render_callback(() => (
        /*svelte_element_input_handler*/
        ctx[24].call(svelte_element)
      ));
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      ctx[23](svelte_element);
      if (
        /*draftValue*/
        ctx[12] !== void 0
      ) {
        svelte_element.innerHTML = /*draftValue*/
        ctx[12];
      }
      if (!mounted) {
        dispose = [
          listen(
            svelte_element,
            "input",
            /*svelte_element_input_handler*/
            ctx[24]
          ),
          listen(
            svelte_element,
            "blur",
            /*update*/
            ctx[13]
          ),
          listen(
            svelte_element,
            "keypress",
            /*submitWhenEnterKey*/
            ctx[14]
          ),
          listen(
            svelte_element,
            "paste",
            /*handlePaste*/
            ctx[15]
          ),
          listen(
            svelte_element,
            "focus",
            /*onFocus*/
            ctx[16]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_dynamic_element_data(
        /*element*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        { contenteditable: "true" },
        dirty & /*cssClass*/
        16 && svelte_element_class_value !== (svelte_element_class_value = null_to_empty(
          /*cssClass*/
          ctx2[4]
        ) + " svelte-1u33atu") && { class: svelte_element_class_value },
        { role: "textbox" },
        { tabindex: "0" },
        dirty & /*spellcheck*/
        32 && { spellcheck: (
          /*spellcheck*/
          ctx2[5]
        ) },
        dirty & /*dataMaxLength*/
        64 && {
          "data-max-length": (
            /*dataMaxLength*/
            ctx2[6]
          )
        },
        dirty & /*placeholder*/
        128 && {
          "data-placeholder": (
            /*placeholder*/
            ctx2[7]
          )
        },
        dirty & /*title*/
        256 && { title: (
          /*title*/
          ctx2[8]
        ) },
        dirty & /*field*/
        4 && { "data-tidy-field": (
          /*field*/
          ctx2[2]
        ) }
      ]));
      if (dirty & /*draftValue*/
      4096 && /*draftValue*/
      ctx2[12] !== svelte_element.innerHTML) {
        svelte_element.innerHTML = /*draftValue*/
        ctx2[12];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2o(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*editable*/
      ctx2[3] && !/*activeEffectApplied*/
      ctx2[11]
    ) return create_if_block$17;
    return create_else_block$K;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$2o($$self, $$props, $$invalidate) {
  let draftValue;
  let activeEffectApplied;
  let isEnchanted;
  let overrideTooltip;
  let $context;
  let { element: element2 } = $$props;
  let { document: document2 } = $$props;
  let { field } = $$props;
  let { value } = $$props;
  let { editable } = $$props;
  let { cssClass = "" } = $$props;
  let { spellcheck = false } = $$props;
  let { dataMaxLength = 40 } = $$props;
  let { placeholder = null } = $$props;
  let { saveAs = "string" } = $$props;
  let { title = null } = $$props;
  let { selectOnFocus = false } = $$props;
  async function update2() {
    if (draftValue.length > dataMaxLength) {
      $$invalidate(12, draftValue = draftValue.substring(0, dataMaxLength));
    }
    const valueToSave = saveAs === "number" ? toNumber(draftValue) : draftValue;
    const result = await document2.update({ [field]: valueToSave });
    if (!result) {
      $$invalidate(12, draftValue = value);
    }
  }
  function submitWhenEnterKey(e2) {
    if (e2.key == "Enter") {
      e2.preventDefault();
      update2();
    }
  }
  let _el;
  function handlePaste() {
    setTimeout(
      () => {
        $$invalidate(0, value = _el.textContent ?? "");
      },
      0
    );
  }
  function onFocus(ev) {
    if (selectOnFocus && window.getSelection) {
      const selection = window.getSelection();
      const range = window.document.createRange();
      range.selectNodeContents(ev.currentTarget);
      selection?.removeAllRanges();
      selection?.addRange(range);
    }
  }
  const context = getContext("context");
  component_subscribe($$self, context, (value2) => $$invalidate(22, $context = value2));
  const localize = FoundryAdapter.localize;
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      _el = $$value;
      $$invalidate(9, _el);
    });
  }
  function svelte_element_input_handler() {
    draftValue = this.innerHTML;
    $$invalidate(12, draftValue), $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2) $$invalidate(1, element2 = $$props2.element);
    if ("document" in $$props2) $$invalidate(18, document2 = $$props2.document);
    if ("field" in $$props2) $$invalidate(2, field = $$props2.field);
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("editable" in $$props2) $$invalidate(3, editable = $$props2.editable);
    if ("cssClass" in $$props2) $$invalidate(4, cssClass = $$props2.cssClass);
    if ("spellcheck" in $$props2) $$invalidate(5, spellcheck = $$props2.spellcheck);
    if ("dataMaxLength" in $$props2) $$invalidate(6, dataMaxLength = $$props2.dataMaxLength);
    if ("placeholder" in $$props2) $$invalidate(7, placeholder = $$props2.placeholder);
    if ("saveAs" in $$props2) $$invalidate(19, saveAs = $$props2.saveAs);
    if ("title" in $$props2) $$invalidate(8, title = $$props2.title);
    if ("selectOnFocus" in $$props2) $$invalidate(20, selectOnFocus = $$props2.selectOnFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $$invalidate(12, draftValue = value);
    }
    if ($$self.$$.dirty & /*document, field*/
    262148) {
      $$invalidate(11, activeEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(document2, field));
    }
    if ($$self.$$.dirty & /*$context, field*/
    4194308) {
      $$invalidate(21, isEnchanted = $context.itemOverrides instanceof Set && $context.itemOverrides.has(field));
    }
    if ($$self.$$.dirty & /*isEnchanted*/
    2097152) {
      $$invalidate(10, overrideTooltip = isEnchanted ? localize("DND5E.Enchantment.Warning.Override") : localize("DND5E.ActiveEffectOverrideWarning"));
    }
  };
  return [
    value,
    element2,
    field,
    editable,
    cssClass,
    spellcheck,
    dataMaxLength,
    placeholder,
    title,
    _el,
    overrideTooltip,
    activeEffectApplied,
    draftValue,
    update2,
    submitWhenEnterKey,
    handlePaste,
    onFocus,
    context,
    document2,
    saveAs,
    selectOnFocus,
    isEnchanted,
    $context,
    svelte_element_binding,
    svelte_element_input_handler
  ];
}
class ContentEditableFormField extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2o, create_fragment$2o, safe_not_equal, {
      element: 1,
      document: 18,
      field: 2,
      value: 0,
      editable: 3,
      cssClass: 4,
      spellcheck: 5,
      dataMaxLength: 6,
      placeholder: 7,
      saveAs: 19,
      title: 8,
      selectOnFocus: 20
    });
  }
}
function create_key_block_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_key_block$5(ctx) {
  let previous_key = (
    /*andOnValueChange*/
    ctx[0]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block_1(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*andOnValueChange*/
      1 && safe_not_equal(previous_key, previous_key = /*andOnValueChange*/
      ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block_1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current) return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
function create_fragment$2n(ctx) {
  let previous_key = (
    /*$stats*/
    ctx[1].lastSubmissionTime
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block$5(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$stats*/
      2 && safe_not_equal(previous_key, previous_key = /*$stats*/
      ctx2[1].lastSubmissionTime)) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$5(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current) return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
function instance$2n($$self, $$props, $$invalidate) {
  let $stats;
  let { $$slots: slots = {}, $$scope } = $$props;
  let stats = getContext(CONSTANTS.SVELTE_CONTEXT.STATS);
  component_subscribe($$self, stats, (value) => $$invalidate(1, $stats = value));
  let { andOnValueChange = null } = $$props;
  $$self.$$set = ($$props2) => {
    if ("andOnValueChange" in $$props2) $$invalidate(0, andOnValueChange = $$props2.andOnValueChange);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [andOnValueChange, $stats, stats, $$scope, slots];
}
class RerenderAfterFormSubmission extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2n, create_fragment$2n, safe_not_equal, { andOnValueChange: 0 });
  }
}
function get_each_context$v(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$v(key_1, ctx) {
  let li;
  let span;
  let t0_value = (
    /*localize*/
    ctx[3](
      /*bioField*/
      ctx[4].text
    ) + ""
  );
  let t0;
  let t1;
  let t2;
  let contenteditableformfield;
  let t3;
  let current;
  contenteditableformfield = new ContentEditableFormField({
    props: {
      selectOnFocus: true,
      element: "span",
      editable: (
        /*$context*/
        ctx[0].editable && !/*$context*/
        ctx[0].lockSensitiveFields
      ),
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: (
        /*bioField*/
        ctx[4].field
      ),
      value: (
        /*bioField*/
        ctx[4].value ?? ""
      ),
      cssClass: "detail-input"
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      span = element("span");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      create_component(contenteditableformfield.$$.fragment);
      t3 = space();
      attr(li, "class", "svelte-rd5ub1");
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span);
      append(span, t0);
      append(span, t1);
      append(li, t2);
      mount_component(contenteditableformfield, li, null);
      append(li, t3);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*bioFields*/
      2) && t0_value !== (t0_value = /*localize*/
      ctx[3](
        /*bioField*/
        ctx[4].text
      ) + "")) set_data(t0, t0_value);
      const contenteditableformfield_changes = {};
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.editable = /*$context*/
      ctx[0].editable && !/*$context*/
      ctx[0].lockSensitiveFields;
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.document = /*$context*/
      ctx[0].actor;
      if (dirty & /*bioFields*/
      2) contenteditableformfield_changes.field = /*bioField*/
      ctx[4].field;
      if (dirty & /*bioFields*/
      2) contenteditableformfield_changes.value = /*bioField*/
      ctx[4].value ?? "";
      contenteditableformfield.$set(contenteditableformfield_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contenteditableformfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contenteditableformfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(contenteditableformfield);
    }
  };
}
function create_default_slot_5$k(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].traitEnrichedHtml
      ),
      target: "system.details.trait",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[3]("DND5E.PersonalityTraits")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].traitEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$o(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].idealEnrichedHtml
      ),
      target: "system.details.ideal",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[3]("DND5E.Ideals")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].idealEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$r(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].bondEnrichedHtml
      ),
      target: "system.details.bond",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[3]("DND5E.Bonds")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].bondEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$s(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].flawEnrichedHtml
      ),
      target: "system.details.flaw",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[3]("DND5E.Flaws")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].flawEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$x(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].appearanceEnrichedHtml
      ),
      target: "system.details.appearance",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[3]("DND5E.Appearance")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
      attr(article, "class", "appearance-notes");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].appearanceEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$13(ctx) {
  let article;
  let div;
  let t3;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].biographyEnrichedHtml
      ),
      target: "system.details.biography.value",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[3]("DND5E.Background")}/${/*localize*/
      ctx[3]("DND5E.Biography")}`;
      t3 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles");
      attr(article, "class", "biography-notes");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t3);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].biographyEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2m(ctx) {
  let div5;
  let div4;
  let div0;
  let article;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div3;
  let div1;
  let rerenderafterformsubmission0;
  let t1;
  let rerenderafterformsubmission1;
  let t2;
  let rerenderafterformsubmission2;
  let t3;
  let rerenderafterformsubmission3;
  let t4;
  let div2;
  let rerenderafterformsubmission4;
  let t5;
  let rerenderafterformsubmission5;
  let current;
  let each_value = ensure_array_like(
    /*bioFields*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*bioField*/
    ctx2[4].field
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$v(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$v(key, child_ctx));
  }
  rerenderafterformsubmission0 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.trait
      ),
      $$slots: { default: [create_default_slot_5$k] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission1 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.ideal
      ),
      $$slots: { default: [create_default_slot_4$o] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission2 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.bond
      ),
      $$slots: { default: [create_default_slot_3$r] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission3 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.flaw
      ),
      $$slots: { default: [create_default_slot_2$s] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission4 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.appearance
      ),
      $$slots: { default: [create_default_slot_1$x] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission5 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.biography.value
      ),
      $$slots: { default: [create_default_slot$13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      article = element("article");
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      create_component(rerenderafterformsubmission0.$$.fragment);
      t1 = space();
      create_component(rerenderafterformsubmission1.$$.fragment);
      t2 = space();
      create_component(rerenderafterformsubmission2.$$.fragment);
      t3 = space();
      create_component(rerenderafterformsubmission3.$$.fragment);
      t4 = space();
      div2 = element("div");
      create_component(rerenderafterformsubmission4.$$.fragment);
      t5 = space();
      create_component(rerenderafterformsubmission5.$$.fragment);
      attr(ul, "class", "character-details svelte-rd5ub1");
      attr(div0, "class", "top-notes note-entries svelte-rd5ub1");
      toggle_class(
        div0,
        "limited",
        /*$context*/
        ctx[0].showLimitedSheet
      );
      attr(div1, "class", "left-notes note-entries svelte-rd5ub1");
      toggle_class(
        div1,
        "limited",
        /*$context*/
        ctx[0].showLimitedSheet
      );
      attr(div2, "class", "right-notes note-entries svelte-rd5ub1");
      toggle_class(
        div2,
        "limited",
        /*$context*/
        ctx[0].showLimitedSheet
      );
      attr(div3, "class", "main-notes svelte-rd5ub1");
      attr(div4, "class", "notes-container svelte-rd5ub1");
      attr(div5, "class", "scroll-container");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div0, article);
      append(article, ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      mount_component(rerenderafterformsubmission0, div1, null);
      append(div1, t1);
      mount_component(rerenderafterformsubmission1, div1, null);
      append(div1, t2);
      mount_component(rerenderafterformsubmission2, div1, null);
      append(div1, t3);
      mount_component(rerenderafterformsubmission3, div1, null);
      append(div3, t4);
      append(div3, div2);
      mount_component(rerenderafterformsubmission4, div2, null);
      append(div2, t5);
      mount_component(rerenderafterformsubmission5, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context, bioFields, localize*/
      11) {
        each_value = ensure_array_like(
          /*bioFields*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$v, null, get_each_context$v);
        check_outros();
      }
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div0,
          "limited",
          /*$context*/
          ctx2[0].showLimitedSheet
        );
      }
      const rerenderafterformsubmission0_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission0_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.trait;
      if (dirty & /*$$scope, $context*/
      129) {
        rerenderafterformsubmission0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission0.$set(rerenderafterformsubmission0_changes);
      const rerenderafterformsubmission1_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission1_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.ideal;
      if (dirty & /*$$scope, $context*/
      129) {
        rerenderafterformsubmission1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission1.$set(rerenderafterformsubmission1_changes);
      const rerenderafterformsubmission2_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission2_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.bond;
      if (dirty & /*$$scope, $context*/
      129) {
        rerenderafterformsubmission2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission2.$set(rerenderafterformsubmission2_changes);
      const rerenderafterformsubmission3_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission3_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.flaw;
      if (dirty & /*$$scope, $context*/
      129) {
        rerenderafterformsubmission3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission3.$set(rerenderafterformsubmission3_changes);
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div1,
          "limited",
          /*$context*/
          ctx2[0].showLimitedSheet
        );
      }
      const rerenderafterformsubmission4_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission4_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.appearance;
      if (dirty & /*$$scope, $context*/
      129) {
        rerenderafterformsubmission4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission4.$set(rerenderafterformsubmission4_changes);
      const rerenderafterformsubmission5_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission5_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.biography.value;
      if (dirty & /*$$scope, $context*/
      129) {
        rerenderafterformsubmission5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission5.$set(rerenderafterformsubmission5_changes);
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div2,
          "limited",
          /*$context*/
          ctx2[0].showLimitedSheet
        );
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(rerenderafterformsubmission0.$$.fragment, local);
      transition_in(rerenderafterformsubmission1.$$.fragment, local);
      transition_in(rerenderafterformsubmission2.$$.fragment, local);
      transition_in(rerenderafterformsubmission3.$$.fragment, local);
      transition_in(rerenderafterformsubmission4.$$.fragment, local);
      transition_in(rerenderafterformsubmission5.$$.fragment, local);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(rerenderafterformsubmission0.$$.fragment, local);
      transition_out(rerenderafterformsubmission1.$$.fragment, local);
      transition_out(rerenderafterformsubmission2.$$.fragment, local);
      transition_out(rerenderafterformsubmission3.$$.fragment, local);
      transition_out(rerenderafterformsubmission4.$$.fragment, local);
      transition_out(rerenderafterformsubmission5.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      destroy_component(rerenderafterformsubmission0);
      destroy_component(rerenderafterformsubmission1);
      destroy_component(rerenderafterformsubmission2);
      destroy_component(rerenderafterformsubmission3);
      destroy_component(rerenderafterformsubmission4);
      destroy_component(rerenderafterformsubmission5);
    }
  };
}
function instance$2m($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  let bioFields = [];
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, bioFields = [
        {
          field: "system.details.gender",
          value: $context.system.details.gender,
          text: "DND5E.Gender"
        },
        {
          field: "system.details.age",
          value: $context.system.details.age,
          text: "DND5E.Age"
        },
        {
          field: "system.details.height",
          value: $context.system.details.height,
          text: "DND5E.Height"
        },
        {
          field: "system.details.weight",
          value: $context.system.details.weight,
          text: "DND5E.Weight"
        },
        {
          field: "system.details.eyes",
          value: $context.system.details.eyes,
          text: "DND5E.Eyes"
        },
        {
          field: "system.details.skin",
          value: $context.system.details.skin,
          text: "DND5E.Skin"
        },
        {
          field: "system.details.hair",
          value: $context.system.details.hair,
          text: "DND5E.Hair"
        },
        {
          field: "system.details.faith",
          value: $context.system.details.faith,
          text: "DND5E.Faith"
        }
      ]);
    }
  };
  return [$context, bioFields, context, localize];
}
class CharacterBiographyTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2m, create_fragment$2m, safe_not_equal, {});
  }
}
function create_default_slot_4$n(ctx) {
  let article;
  let div;
  let textinput;
  let t2;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: TidyFlags.notes1.members.name.prop,
      value: TidyFlags.notes1.members.name.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      placeholder: (
        /*localize*/
        ctx[2]("TIDY5E.JournalPersonsOfInterest")
      ),
      selectOnFocus: true,
      stopChangePropagation: true,
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].notes1EnrichedHtml
      ),
      target: TidyFlags.notes1.members.value.prop,
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      create_component(textinput.$$.fragment);
      t2 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      mount_component(textinput, div, null);
      append(article, t2);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput_changes.value = TidyFlags.notes1.members.name.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].notes1EnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(textinput);
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$q(ctx) {
  let article;
  let div;
  let textinput;
  let t2;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: TidyFlags.notes2.members.name.prop,
      value: TidyFlags.notes2.members.name.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      placeholder: (
        /*localize*/
        ctx[2]("TIDY5E.JournalLocationsOfInterest")
      ),
      selectOnFocus: true,
      stopChangePropagation: true,
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].notes2EnrichedHtml
      ),
      target: TidyFlags.notes2.members.value.prop,
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      create_component(textinput.$$.fragment);
      t2 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      mount_component(textinput, div, null);
      append(article, t2);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput_changes.value = TidyFlags.notes2.members.name.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].notes2EnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(textinput);
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$r(ctx) {
  let article;
  let div;
  let textinput;
  let t2;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: TidyFlags.notes3.members.name.prop,
      value: TidyFlags.notes3.members.name.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      placeholder: (
        /*localize*/
        ctx[2]("TIDY5E.JournalQuests")
      ),
      selectOnFocus: true,
      stopChangePropagation: true,
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].notes3EnrichedHtml
      ),
      target: TidyFlags.notes3.members.value.prop,
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      create_component(textinput.$$.fragment);
      t2 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      mount_component(textinput, div, null);
      append(article, t2);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput_changes.value = TidyFlags.notes3.members.name.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].notes3EnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(textinput);
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$w(ctx) {
  let article;
  let div;
  let textinput;
  let t2;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: TidyFlags.notes4.members.name.prop,
      value: TidyFlags.notes4.members.name.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      placeholder: (
        /*localize*/
        ctx[2]("TIDY5E.JournalMisc")
      ),
      selectOnFocus: true,
      stopChangePropagation: true,
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].notes4EnrichedHtml
      ),
      target: TidyFlags.notes4.members.value.prop,
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      create_component(textinput.$$.fragment);
      t2 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      mount_component(textinput, div, null);
      append(article, t2);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput_changes.value = TidyFlags.notes4.members.name.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].notes4EnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(textinput);
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$12(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].notesEnrichedHtml
      ),
      target: TidyFlags.notes.members.value.prop,
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[2]("TIDY5E.JournalEntries")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles");
      attr(article, "class", "journal-notes");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].notesEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2l(ctx) {
  let div2;
  let div0;
  let rerenderafterformsubmission0;
  let t0;
  let rerenderafterformsubmission1;
  let t1;
  let rerenderafterformsubmission2;
  let t2;
  let rerenderafterformsubmission3;
  let t3;
  let div1;
  let rerenderafterformsubmission4;
  let current;
  rerenderafterformsubmission0 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: TidyFlags.notes1.members.value.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      $$slots: { default: [create_default_slot_4$n] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission1 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: TidyFlags.notes2.members.value.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      $$slots: { default: [create_default_slot_3$q] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission2 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: TidyFlags.notes3.members.value.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      $$slots: { default: [create_default_slot_2$r] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission3 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: TidyFlags.notes4.members.value.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      $$slots: { default: [create_default_slot_1$w] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission4 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: TidyFlags.notes.members.value.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      $$slots: { default: [create_default_slot$12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(rerenderafterformsubmission0.$$.fragment);
      t0 = space();
      create_component(rerenderafterformsubmission1.$$.fragment);
      t1 = space();
      create_component(rerenderafterformsubmission2.$$.fragment);
      t2 = space();
      create_component(rerenderafterformsubmission3.$$.fragment);
      t3 = space();
      div1 = element("div");
      create_component(rerenderafterformsubmission4.$$.fragment);
      attr(div0, "class", "left-notes note-entries svelte-17wqpkm");
      toggle_class(
        div0,
        "limited",
        /*$context*/
        ctx[0].showLimitedSheet
      );
      attr(div1, "class", "right-notes note-entries svelte-17wqpkm");
      toggle_class(
        div1,
        "limited",
        /*$context*/
        ctx[0].showLimitedSheet
      );
      attr(div2, "class", "scroll-container journal-container svelte-17wqpkm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(rerenderafterformsubmission0, div0, null);
      append(div0, t0);
      mount_component(rerenderafterformsubmission1, div0, null);
      append(div0, t1);
      mount_component(rerenderafterformsubmission2, div0, null);
      append(div0, t2);
      mount_component(rerenderafterformsubmission3, div0, null);
      append(div2, t3);
      append(div2, div1);
      mount_component(rerenderafterformsubmission4, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rerenderafterformsubmission0_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission0_changes.andOnValueChange = TidyFlags.notes1.members.value.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission0.$set(rerenderafterformsubmission0_changes);
      const rerenderafterformsubmission1_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission1_changes.andOnValueChange = TidyFlags.notes2.members.value.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission1.$set(rerenderafterformsubmission1_changes);
      const rerenderafterformsubmission2_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission2_changes.andOnValueChange = TidyFlags.notes3.members.value.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission2.$set(rerenderafterformsubmission2_changes);
      const rerenderafterformsubmission3_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission3_changes.andOnValueChange = TidyFlags.notes4.members.value.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission3.$set(rerenderafterformsubmission3_changes);
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div0,
          "limited",
          /*$context*/
          ctx2[0].showLimitedSheet
        );
      }
      const rerenderafterformsubmission4_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission4_changes.andOnValueChange = TidyFlags.notes.members.value.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission4.$set(rerenderafterformsubmission4_changes);
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div1,
          "limited",
          /*$context*/
          ctx2[0].showLimitedSheet
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(rerenderafterformsubmission0.$$.fragment, local);
      transition_in(rerenderafterformsubmission1.$$.fragment, local);
      transition_in(rerenderafterformsubmission2.$$.fragment, local);
      transition_in(rerenderafterformsubmission3.$$.fragment, local);
      transition_in(rerenderafterformsubmission4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rerenderafterformsubmission0.$$.fragment, local);
      transition_out(rerenderafterformsubmission1.$$.fragment, local);
      transition_out(rerenderafterformsubmission2.$$.fragment, local);
      transition_out(rerenderafterformsubmission3.$$.fragment, local);
      transition_out(rerenderafterformsubmission4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(rerenderafterformsubmission0);
      destroy_component(rerenderafterformsubmission1);
      destroy_component(rerenderafterformsubmission2);
      destroy_component(rerenderafterformsubmission3);
      destroy_component(rerenderafterformsubmission4);
    }
  };
}
function instance$2l($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ActorJournalTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2l, create_fragment$2l, safe_not_equal, {});
  }
}
function get_each_context$u(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  const constants_0 = ItemVisibility.countVisibleItems(
    /*section*/
    child_ctx[15].actions.map((a2) => a2.item),
    /*$itemIdsToShow*/
    child_ctx[4]
  );
  child_ctx[16] = constants_0;
  return child_ctx;
}
function get_each_context_1$f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function get_each_context_2$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  child_ctx[26] = i2;
  const constants_0 = (
    /*damageHealingTypeIconMap*/
    child_ctx[10][
      /*entry*/
      child_ctx[23].damageType
    ]
  );
  child_ctx[24] = constants_0;
  return child_ctx;
}
function get_if_ctx$8(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = FoundryAdapter.lookupAbility(
    /*actionItem*/
    child_ctx[19].item.system.save.ability
  )?.label ?? "";
  child_ctx[27] = constants_0;
  return child_ctx;
}
function get_context(ctx) {
  const constants_0 = (
    /*$context*/
    ctx[2].actor.spellcastingClasses?.[
      /*actionItem*/
      ctx[19].item.system.sourceClass
    ]?.name ?? ""
  );
  ctx[28] = constants_0;
}
function get_each_context_3$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i2];
  return child_ctx;
}
function create_each_block_3$2(key_1, ctx) {
  let first;
  let utilitytoolbarcommand;
  let current;
  function execute_handler(...args) {
    return (
      /*execute_handler*/
      ctx[12](
        /*command*/
        ctx[29],
        ...args
      )
    );
  }
  utilitytoolbarcommand = new UtilityToolbarCommand({
    props: {
      title: (
        /*command*/
        ctx[29].title
      ),
      iconClass: (
        /*command*/
        ctx[29].iconClass
      ),
      text: (
        /*command*/
        ctx[29].text
      ),
      visible: (
        /*command*/
        ctx[29].visible ?? true
      )
    }
  });
  utilitytoolbarcommand.$on("execute", execute_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(utilitytoolbarcommand.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(utilitytoolbarcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const utilitytoolbarcommand_changes = {};
      if (dirty[0] & /*utilityBarCommands*/
      8) utilitytoolbarcommand_changes.title = /*command*/
      ctx[29].title;
      if (dirty[0] & /*utilityBarCommands*/
      8) utilitytoolbarcommand_changes.iconClass = /*command*/
      ctx[29].iconClass;
      if (dirty[0] & /*utilityBarCommands*/
      8) utilitytoolbarcommand_changes.text = /*command*/
      ctx[29].text;
      if (dirty[0] & /*utilityBarCommands*/
      8) utilitytoolbarcommand_changes.visible = /*command*/
      ctx[29].visible ?? true;
      utilitytoolbarcommand.$set(utilitytoolbarcommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbarcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbarcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(utilitytoolbarcommand, detaching);
    }
  };
}
function create_default_slot_12$7(ctx) {
  let search;
  let updating_value;
  let t0;
  let pinnedfiltertoggles;
  let t1;
  let filtermenu;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  function search_value_binding(value) {
    ctx[11](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[0] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[0];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  pinnedfiltertoggles = new PinnedFilterToggles({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[6]
      ),
      filters: ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx[2].filterPins,
        /*$context*/
        ctx[2].filterData,
        /*tabId*/
        ctx[6]
      )
    }
  });
  filtermenu = new FilterMenu({ props: { tabId: (
    /*tabId*/
    ctx[6]
  ) } });
  let each_value_3 = ensure_array_like(
    /*utilityBarCommands*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[29].title
  );
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    let child_ctx = get_each_context_3$2(ctx, each_value_3, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_3$2(key, child_ctx));
  }
  return {
    c() {
      create_component(search.$$.fragment);
      t0 = space();
      create_component(pinnedfiltertoggles.$$.fragment);
      t1 = space();
      create_component(filtermenu.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      insert(target, t0, anchor);
      mount_component(pinnedfiltertoggles, target, anchor);
      insert(target, t1, anchor);
      mount_component(filtermenu, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_changes = {};
      if (!updating_value && dirty[0] & /*searchCriteria*/
      1) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      const pinnedfiltertoggles_changes = {};
      if (dirty[0] & /*$context*/
      4) pinnedfiltertoggles_changes.filters = ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx2[2].filterPins,
        /*$context*/
        ctx2[2].filterData,
        /*tabId*/
        ctx2[6]
      );
      pinnedfiltertoggles.$set(pinnedfiltertoggles_changes);
      if (dirty[0] & /*utilityBarCommands*/
      8) {
        each_value_3 = ensure_array_like(
          /*utilityBarCommands*/
          ctx2[3]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_3, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_3$2, each_1_anchor, get_each_context_3$2);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(pinnedfiltertoggles.$$.fragment, local);
      transition_in(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(pinnedfiltertoggles.$$.fragment, local);
      transition_out(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(search, detaching);
      destroy_component(pinnedfiltertoggles, detaching);
      destroy_component(filtermenu, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block$16(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[15].key
      ),
      $$slots: {
        body: [create_body_slot$8],
        header: [create_header_slot$9]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtable_changes = {};
      if (dirty[0] & /*actions*/
      2) itemtable_changes.key = /*section*/
      ctx2[15].key;
      if (dirty[0] & /*actions, $context, $itemIdsToShow*/
      22 | dirty[1] & /*$$scope*/
      2) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function create_default_slot_11$8(ctx) {
  let t_value = (
    /*section*/
    ctx[15].label + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t_value !== (t_value = /*section*/
      ctx2[15].label + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_10$b(ctx) {
  let t_value = (
    /*localize*/
    ctx[9]("DND5E.Range") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_9$b(ctx) {
  let t_value = (
    /*localize*/
    ctx[9]("TIDY5E.HitDC") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_8$c(ctx) {
  let t_value = (
    /*localize*/
    ctx[9]("DND5E.Damage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_19$1(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({ props: { baseWidth: "1.5rem" } });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_7$d(ctx) {
  let itemtablecolumn0;
  let t0;
  let itemtablecolumn1;
  let t1;
  let itemtablecolumn2;
  let t2;
  let itemtablecolumn3;
  let t3;
  let if_block_anchor;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_11$8] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: "6.25rem",
      $$slots: { default: [create_default_slot_10$b] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn2 = new ItemTableColumn({
    props: {
      baseWidth: "5rem",
      $$slots: { default: [create_default_slot_9$b] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn3 = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_8$c] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && create_if_block_19$1()
  );
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t1 = space();
      create_component(itemtablecolumn2.$$.fragment);
      t2 = space();
      create_component(itemtablecolumn3.$$.fragment);
      t3 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecolumn3, target, anchor);
      insert(target, t3, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty[0] & /*actions*/
      2 | dirty[1] & /*$$scope*/
      2) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty[1] & /*$$scope*/
      2) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
      const itemtablecolumn2_changes = {};
      if (dirty[1] & /*$$scope*/
      2) {
        itemtablecolumn2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn2.$set(itemtablecolumn2_changes);
      const itemtablecolumn3_changes = {};
      if (dirty[1] & /*$$scope*/
      2) {
        itemtablecolumn3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn3.$set(itemtablecolumn3_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls
      ) {
        if (if_block) {
          if (dirty[0] & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_19$1();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(itemtablecolumn2.$$.fragment, local);
      transition_in(itemtablecolumn3.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(itemtablecolumn2.$$.fragment, local);
      transition_out(itemtablecolumn3.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
      destroy_component(itemtablecolumn2, detaching);
      destroy_component(itemtablecolumn3, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_header_slot$9(ctx) {
  let itemtableheaderrow;
  let t2;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_7$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty[0] & /*$context, actions*/
      6 | dirty[1] & /*$$scope*/
      2) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_if_block_18$1(ctx) {
  let inlinecontainertoggle;
  let current;
  inlinecontainertoggle = new InlineContainerToggle({
    props: {
      iconClass: "fa-lg",
      item: (
        /*actionItem*/
        ctx[19].item
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[7]
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainertoggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainertoggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainertoggle_changes = {};
      if (dirty[0] & /*actions*/
      2) inlinecontainertoggle_changes.item = /*actionItem*/
      ctx2[19].item;
      inlinecontainertoggle.$set(inlinecontainertoggle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainertoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainertoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainertoggle, detaching);
    }
  };
}
function create_else_block_2$3(ctx) {
  let t0_value = (
    /*actionItem*/
    (ctx[19].item.labels?.school ?? "") + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*actionItem*/
    (ctx[19].item.labels?.level ?? "") + ""
  );
  let t2;
  let t3;
  let if_block_anchor;
  let if_block = (
    /*sourceClassText*/
    ctx[28] && create_if_block_17$1(ctx)
  );
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t0_value !== (t0_value = /*actionItem*/
      (ctx2[19].item.labels?.school ?? "") + "")) set_data(t0, t0_value);
      if (dirty[0] & /*actions*/
      2 && t2_value !== (t2_value = /*actionItem*/
      (ctx2[19].item.labels?.level ?? "") + "")) set_data(t2, t2_value);
      if (
        /*sourceClassText*/
        ctx2[28]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_17$1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_15$3(ctx) {
  let t0_value = (
    /*actionItem*/
    (ctx[19].item.labels?.level ?? "") + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*actionItem*/
    (ctx[19].item.labels?.school ?? "") + ""
  );
  let t2;
  let t3;
  let if_block_anchor;
  let if_block = (
    /*sourceClassText*/
    ctx[28] && create_if_block_16$1(ctx)
  );
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t0_value !== (t0_value = /*actionItem*/
      (ctx2[19].item.labels?.level ?? "") + "")) set_data(t0, t0_value);
      if (dirty[0] & /*actions*/
      2 && t2_value !== (t2_value = /*actionItem*/
      (ctx2[19].item.labels?.school ?? "") + "")) set_data(t2, t2_value);
      if (
        /*sourceClassText*/
        ctx2[28]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_16$1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_14$4(ctx) {
  let t_value = (
    /*actionItem*/
    ctx[19].typeLabel + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t_value !== (t_value = /*actionItem*/
      ctx2[19].typeLabel + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_17$1(ctx) {
  let t0;
  let t1_value = (
    /*localize*/
    ctx[9](
      /*sourceClassText*/
      ctx[28]
    ) + ""
  );
  let t1;
  return {
    c() {
      t0 = text(" ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$context, actions*/
      6 && t1_value !== (t1_value = /*localize*/
      ctx2[9](
        /*sourceClassText*/
        ctx2[28]
      ) + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_if_block_16$1(ctx) {
  let t0;
  let t1_value = (
    /*localize*/
    ctx[9](
      /*sourceClassText*/
      ctx[28]
    ) + ""
  );
  let t1;
  return {
    c() {
      t0 = text(" ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$context, actions*/
      6 && t1_value !== (t1_value = /*localize*/
      ctx2[9](
        /*sourceClassText*/
        ctx2[28]
      ) + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_default_slot_6$f(ctx) {
  get_context(ctx);
  let div1;
  let div0;
  let t0_value = (
    /*actionItem*/
    ctx[19].item.name + ""
  );
  let t0;
  let div0_data_tidy_item_name_value;
  let div0_title_value;
  let t1;
  let small;
  function select_block_type(ctx2, dirty) {
    if (
      /*actionItem*/
      ctx2[19].item.type !== CONSTANTS.ITEM_TYPE_SPELL
    ) return create_if_block_14$4;
    if (
      /*actionItem*/
      ctx2[19].item.system.level !== 0
    ) return create_if_block_15$3;
    return create_else_block_2$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      small = element("small");
      if_block.c();
      attr(div0, "data-tidy-item-name", div0_data_tidy_item_name_value = /*actionItem*/
      ctx[19].item.name);
      attr(div0, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
      attr(div0, "class", "truncate");
      attr(div0, "title", div0_title_value = /*actionItem*/
      ctx[19].item.name);
      attr(small, "class", "svelte-1nldtre");
      attr(div1, "class", "flex-1 min-width-0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      append(div1, small);
      if_block.m(small, null);
    },
    p(ctx2, dirty) {
      get_context(ctx2);
      if (dirty[0] & /*actions*/
      2 && t0_value !== (t0_value = /*actionItem*/
      ctx2[19].item.name + "")) set_data(t0, t0_value);
      if (dirty[0] & /*actions*/
      2 && div0_data_tidy_item_name_value !== (div0_data_tidy_item_name_value = /*actionItem*/
      ctx2[19].item.name)) {
        attr(div0, "data-tidy-item-name", div0_data_tidy_item_name_value);
      }
      if (dirty[0] & /*actions*/
      2 && div0_title_value !== (div0_title_value = /*actionItem*/
      ctx2[19].item.name)) {
        attr(div0, "title", div0_title_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(small, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_block.d();
    }
  };
}
function create_if_block_8$7(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t2;
  let current;
  const if_block_creators = [create_if_block_10$5, create_if_block_11$4, create_if_block_12$4];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*actionItem*/
      ctx2[19].item.system.recharge?.charged && /*actionItem*/
      ctx2[19].item.system.recharge?.value
    ) return 0;
    if (
      /*actionItem*/
      ctx2[19].item.system.recharge?.value
    ) return 1;
    if (
      /*actionItem*/
      ctx2[19].item.hasLimitedUses
    ) return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*actionItem*/
    ctx[19].item.system.activation.type === "legendary" && create_if_block_9$7(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      attr(div, "class", "item-uses svelte-1nldtre");
      attr(
        div,
        "title",
        /*localize*/
        ctx[9]("DND5E.Uses")
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(div, t2);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*actionItem*/
        ctx2[19].item.system.activation.type === "legendary"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_9$7(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1) if_block1.d();
    }
  };
}
function create_if_block_12$4(ctx) {
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*actionItem*/
      ctx2[19].item.system.uses?.value === /*actionItem*/
      ctx2[19].item.system.uses?.max && /*actionItem*/
      ctx2[19].item.system.uses?.autoDestroy
    ) return create_if_block_13$4;
    return create_else_block_1$a;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block_11$4(ctx) {
  let rechargecontrol;
  let current;
  rechargecontrol = new RechargeControl({
    props: { item: (
      /*actionItem*/
      ctx[19].item
    ) }
  });
  return {
    c() {
      create_component(rechargecontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rechargecontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rechargecontrol_changes = {};
      if (dirty[0] & /*actions*/
      2) rechargecontrol_changes.item = /*actionItem*/
      ctx2[19].item;
      rechargecontrol.$set(rechargecontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rechargecontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rechargecontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rechargecontrol, detaching);
    }
  };
}
function create_if_block_10$5(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-bolt");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[9]("DND5E.Charged")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_else_block_1$a(ctx) {
  let div;
  let t0_value = (
    /*actionItem*/
    (ctx[19].item.system.uses.value ?? 0) + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*actionItem*/
    (ctx[19].item.system.uses.max ?? 0) + ""
  );
  let t2;
  let t3;
  let small;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = text(" / ");
      t2 = text(t2_value);
      t3 = space();
      small = element("small");
      small.textContent = `${/*localize*/
      ctx[9]("DND5E.Uses")}`;
      attr(small, "class", "svelte-1nldtre");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      insert(target, t3, anchor);
      insert(target, small, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t0_value !== (t0_value = /*actionItem*/
      (ctx2[19].item.system.uses.value ?? 0) + "")) set_data(t0, t0_value);
      if (dirty[0] & /*actions*/
      2 && t2_value !== (t2_value = /*actionItem*/
      (ctx2[19].item.system.uses.max ?? 0) + "")) set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t3);
        detach(small);
      }
    }
  };
}
function create_if_block_13$4(ctx) {
  let div;
  let t0_value = (
    /*actionItem*/
    (ctx[19].item.system.quantity ?? 0) + ""
  );
  let t0;
  let div_title_value;
  let t1;
  let small;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      small = element("small");
      small.textContent = `${/*localize*/
      ctx[9]("DND5E.Quantity")}`;
      attr(div, "title", div_title_value = /*actionItem*/
      ctx[19].item.system.quantity);
      attr(small, "class", "svelte-1nldtre");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      insert(target, t1, anchor);
      insert(target, small, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t0_value !== (t0_value = /*actionItem*/
      (ctx2[19].item.system.quantity ?? 0) + "")) set_data(t0, t0_value);
      if (dirty[0] & /*actions*/
      2 && div_title_value !== (div_title_value = /*actionItem*/
      ctx2[19].item.system.quantity)) {
        attr(div, "title", div_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t1);
        detach(small);
      }
    }
  };
}
function create_if_block_9$7(ctx) {
  let t_value = (
    /*actionItem*/
    ctx[19].item.system.activation.cost + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t_value !== (t_value = /*actionItem*/
      ctx2[19].item.system.activation.cost + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_5$j(ctx) {
  let itemusebutton;
  let t0;
  let t1;
  let itemname;
  let t2;
  let if_block1_anchor;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[2].editable,
      item: (
        /*actionItem*/
        ctx[19].item
      )
    }
  });
  let if_block0 = "containerContents" in /*actionItem*/
  ctx[19] && !!/*actionItem*/
  ctx[19].containerContents && create_if_block_18$1(ctx);
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[13](
        /*toggleSummary*/
        ctx[22]
      )
    );
  }
  itemname = new ItemName({
    props: {
      item: (
        /*actionItem*/
        ctx[19].item
      ),
      useActiveEffectsMarker: false,
      $$slots: { default: [create_default_slot_6$f] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  let if_block1 = (
    /*actionItem*/
    (ctx[19].item.system.recharge?.value || /*actionItem*/
    ctx[19].item.hasLimitedUses || /*actionItem*/
    ctx[19].item.system.activation?.type === "legendary") && create_if_block_8$7(ctx)
  );
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      create_component(itemname.$$.fragment);
      t2 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemname, target, anchor);
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty[0] & /*$context*/
      4) itemusebutton_changes.disabled = !/*$context*/
      ctx[2].editable;
      if (dirty[0] & /*actions*/
      2) itemusebutton_changes.item = /*actionItem*/
      ctx[19].item;
      itemusebutton.$set(itemusebutton_changes);
      if ("containerContents" in /*actionItem*/
      ctx[19] && !!/*actionItem*/
      ctx[19].containerContents) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*actions*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_18$1(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemname_changes = {};
      if (dirty[0] & /*actions*/
      2) itemname_changes.item = /*actionItem*/
      ctx[19].item;
      if (dirty[0] & /*actions, $context*/
      6 | dirty[1] & /*$$scope*/
      2) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
      if (
        /*actionItem*/
        ctx[19].item.system.recharge?.value || /*actionItem*/
        ctx[19].item.hasLimitedUses || /*actionItem*/
        ctx[19].item.system.activation?.type === "legendary"
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty[0] & /*actions*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8$7(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemname.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemname.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block1_anchor);
      }
      destroy_component(itemusebutton, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemname, detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_if_block_7$a(ctx) {
  let div;
  let t_value = (
    /*actionItem*/
    (ctx[19].rangeTitle ?? "") + ""
  );
  let t2;
  let div_title_value;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "title", div_title_value = /*actionItem*/
      ctx[19].rangeTitle);
      attr(div, "class", "flex-column-truncate svelte-1nldtre");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t_value !== (t_value = /*actionItem*/
      (ctx2[19].rangeTitle ?? "") + "")) set_data(t2, t_value);
      if (dirty[0] & /*actions*/
      2 && div_title_value !== (div_title_value = /*actionItem*/
      ctx2[19].rangeTitle)) {
        attr(div, "title", div_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_6$c(ctx) {
  let small;
  let t_value = (
    /*actionItem*/
    (ctx[19].rangeSubtitle ?? "") + ""
  );
  let t2;
  let small_title_value;
  return {
    c() {
      small = element("small");
      t2 = text(t_value);
      attr(small, "title", small_title_value = /*actionItem*/
      ctx[19].rangeSubtitle);
      attr(small, "class", "flex-column-truncate svelte-1nldtre");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t_value !== (t_value = /*actionItem*/
      (ctx2[19].rangeSubtitle ?? "") + "")) set_data(t2, t_value);
      if (dirty[0] & /*actions*/
      2 && small_title_value !== (small_title_value = /*actionItem*/
      ctx2[19].rangeSubtitle)) {
        attr(small, "title", small_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(small);
      }
    }
  };
}
function create_default_slot_4$m(ctx) {
  let t2;
  let if_block1_anchor;
  let if_block0 = (
    /*actionItem*/
    ctx[19].rangeTitle !== null && create_if_block_7$a(ctx)
  );
  let if_block1 = (
    /*actionItem*/
    ctx[19].rangeSubtitle !== null && create_if_block_6$c(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*actionItem*/
        ctx2[19].rangeTitle !== null
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7$a(ctx2);
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*actionItem*/
        ctx2[19].rangeSubtitle !== null
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_6$c(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_if_block_4$i(ctx) {
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (
      /*actionItem*/
      ctx2[19].item.labels?.save !== "" && /*actionItem*/
      ctx2[19].item.labels?.save !== void 0
    ) return create_if_block_5$f;
    return create_else_block$J;
  }
  function select_block_ctx(ctx2, type) {
    if (type === create_if_block_5$f) return get_if_ctx$8(ctx2);
    return ctx2;
  }
  let current_block_type = select_block_type_3(ctx);
  let if_block = current_block_type(select_block_ctx(ctx, current_block_type));
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2)) && if_block) {
        if_block.p(select_block_ctx(ctx2, current_block_type), dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(select_block_ctx(ctx2, current_block_type));
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block$J(ctx) {
  let span;
  let t_value = (
    /*actionItem*/
    (ctx[19].item.labels?.toHit ?? "") + ""
  );
  let t2;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "title", span_title_value = /*actionItem*/
      ctx[19].item.labels?.toHit ?? "");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t_value !== (t_value = /*actionItem*/
      (ctx2[19].item.labels?.toHit ?? "") + "")) set_data(t2, t_value);
      if (dirty[0] & /*actions*/
      2 && span_title_value !== (span_title_value = /*actionItem*/
      ctx2[19].item.labels?.toHit ?? "")) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_5$f(ctx) {
  let span;
  let t0_value = (
    /*localize*/
    ctx[9]("DND5E.AbbreviationDC") + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*actionItem*/
    (ctx[19].item.system.save.dc ?? "") + ""
  );
  let t2;
  let span_title_value;
  let t3;
  let small;
  let t4_value = (
    /*saveAbilityLabel*/
    ctx[27] + ""
  );
  let t4;
  let small_title_value;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      small = element("small");
      t4 = text(t4_value);
      attr(span, "title", span_title_value = /*actionItem*/
      ctx[19].item.labels?.save ?? "");
      attr(span, "class", "flex-column-truncate svelte-1nldtre");
      attr(small, "title", small_title_value = /*saveAbilityLabel*/
      ctx[27]);
      attr(small, "class", "flex-column-truncate svelte-1nldtre");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      insert(target, t3, anchor);
      insert(target, small, anchor);
      append(small, t4);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      2 && t2_value !== (t2_value = /*actionItem*/
      (ctx2[19].item.system.save.dc ?? "") + "")) set_data(t2, t2_value);
      if (dirty[0] & /*actions*/
      2 && span_title_value !== (span_title_value = /*actionItem*/
      ctx2[19].item.labels?.save ?? "")) {
        attr(span, "title", span_title_value);
      }
      if (dirty[0] & /*actions*/
      2 && t4_value !== (t4_value = /*saveAbilityLabel*/
      ctx2[27] + "")) set_data(t4, t4_value);
      if (dirty[0] & /*actions*/
      2 && small_title_value !== (small_title_value = /*saveAbilityLabel*/
      ctx2[27])) {
        attr(small, "title", small_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t3);
        detach(small);
      }
    }
  };
}
function create_default_slot_3$p(ctx) {
  let if_block_anchor;
  let if_block = (
    /*actionItem*/
    (ctx[19].item.labels?.save || /*actionItem*/
    ctx[19].item.labels?.toHit) && create_if_block_4$i(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*actionItem*/
        ctx2[19].item.labels?.save || /*actionItem*/
        ctx2[19].item.labels?.toHit
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$i(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_3$q(ctx) {
  let dnd5eicon;
  let current;
  dnd5eicon = new Dnd5eIcon({ props: { src: (
    /*iconSrc*/
    ctx[24]
  ) } });
  return {
    c() {
      create_component(dnd5eicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eicon_changes = {};
      if (dirty[0] & /*actions*/
      2) dnd5eicon_changes.src = /*iconSrc*/
      ctx2[24];
      dnd5eicon.$set(dnd5eicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(dnd5eicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eicon, detaching);
    }
  };
}
function create_each_block_2$6(ctx) {
  let div;
  let span;
  let t0_value = (
    /*entry*/
    ctx[23].formula + ""
  );
  let t0;
  let t1;
  let t2;
  let div_title_value;
  let current;
  let if_block = (
    /*iconSrc*/
    ctx[24] && create_if_block_3$q(ctx)
  );
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      t2 = space();
      attr(div, "title", div_title_value = /*entry*/
      ctx[23].label ?? /*entry*/
      ctx[23].formula + /*entry*/
      ctx[23].damageHealingTypeLabel);
      attr(div, "class", "truncate flex-row align-items-flex-end extra-small-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(div, t1);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*actions*/
      2) && t0_value !== (t0_value = /*entry*/
      ctx2[23].formula + "")) set_data(t0, t0_value);
      if (
        /*iconSrc*/
        ctx2[24]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*actions*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*actions*/
      2 && div_title_value !== (div_title_value = /*entry*/
      ctx2[23].label ?? /*entry*/
      ctx2[23].formula + /*entry*/
      ctx2[23].damageHealingTypeLabel)) {
        attr(div, "title", div_title_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
    }
  };
}
function create_default_slot_2$q(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*actionItem*/
    ctx[19].calculatedDerivedDamage ?? []
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$6(get_each_context_2$6(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions, damageHealingTypeIconMap*/
      1026) {
        each_value_2 = ensure_array_like(
          /*actionItem*/
          ctx2[19].calculatedDerivedDamage ?? []
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$6(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$6(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_2$x(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "1.5rem",
      $$slots: { default: [create_default_slot_1$v] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty[0] & /*actions*/
      2 | dirty[1] & /*$$scope*/
      2) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_1$v(ctx) {
  let actionfilteroverridecontrol;
  let current;
  actionfilteroverridecontrol = new ActionFilterOverrideControl({
    props: { item: (
      /*actionItem*/
      ctx[19].item
    ) }
  });
  return {
    c() {
      create_component(actionfilteroverridecontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionfilteroverridecontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionfilteroverridecontrol_changes = {};
      if (dirty[0] & /*actions*/
      2) actionfilteroverridecontrol_changes.item = /*actionItem*/
      ctx2[19].item;
      actionfilteroverridecontrol.$set(actionfilteroverridecontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(actionfilteroverridecontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionfilteroverridecontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actionfilteroverridecontrol, detaching);
    }
  };
}
function create_default_slot$11(ctx) {
  let itemtablecell0;
  let t0;
  let itemtablecell1;
  let t1;
  let itemtablecell2;
  let t2;
  let itemtablecell3;
  let t3;
  let if_block_anchor;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_5$j] },
      $$scope: { ctx }
    }
  });
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "6.25rem",
      cssClass: "truncate flex-column no-gap",
      $$slots: { default: [create_default_slot_4$m] },
      $$scope: { ctx }
    }
  });
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: "5rem",
      cssClass: "flex-column no-gap",
      $$slots: { default: [create_default_slot_3$p] },
      $$scope: { ctx }
    }
  });
  itemtablecell3 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      cssClass: "flex-wrap flex-row small-gap extra-small-row-gap",
      $$slots: { default: [create_default_slot_2$q] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && create_if_block_2$x(ctx)
  );
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      create_component(itemtablecell1.$$.fragment);
      t1 = space();
      create_component(itemtablecell2.$$.fragment);
      t2 = space();
      create_component(itemtablecell3.$$.fragment);
      t3 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecell3, target, anchor);
      insert(target, t3, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty[0] & /*actions, toggleSummary, $context*/
      4194310 | dirty[1] & /*$$scope*/
      2) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      const itemtablecell1_changes = {};
      if (dirty[0] & /*actions*/
      2 | dirty[1] & /*$$scope*/
      2) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      const itemtablecell2_changes = {};
      if (dirty[0] & /*actions*/
      2 | dirty[1] & /*$$scope*/
      2) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
      const itemtablecell3_changes = {};
      if (dirty[0] & /*actions*/
      2 | dirty[1] & /*$$scope*/
      2) {
        itemtablecell3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell3.$set(itemtablecell3_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$x(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(itemtablecell2.$$.fragment, local);
      transition_in(itemtablecell3.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(itemtablecell2.$$.fragment, local);
      transition_out(itemtablecell3.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecell0, detaching);
      destroy_component(itemtablecell1, detaching);
      destroy_component(itemtablecell2, detaching);
      destroy_component(itemtablecell3, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_1$H(ctx) {
  let inlinecontainerview;
  let div;
  let current;
  inlinecontainerview = new InlineContainerView({
    props: {
      container: (
        /*actionItem*/
        ctx[19].item
      ),
      containerContents: (
        /*actionItem*/
        ctx[19].containerContents
      ),
      editable: (
        /*$context*/
        ctx[2].editable
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[7]
      ),
      lockItemQuantity: (
        /*$context*/
        ctx[2].lockItemQuantity
      ),
      sheetDocument: (
        /*$context*/
        ctx[2].actor
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontainerview.$$.fragment);
      set_style(div, "display", "contents");
      set_style(div, "--t5e-image-size-override", "1.5rem");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontainerview, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainerview_changes = {};
      if (dirty[0] & /*actions*/
      2) inlinecontainerview_changes.container = /*actionItem*/
      ctx2[19].item;
      if (dirty[0] & /*actions*/
      2) inlinecontainerview_changes.containerContents = /*actionItem*/
      ctx2[19].containerContents;
      if (dirty[0] & /*$context*/
      4) inlinecontainerview_changes.editable = /*$context*/
      ctx2[2].editable;
      if (dirty[0] & /*$context*/
      4) inlinecontainerview_changes.lockItemQuantity = /*$context*/
      ctx2[2].lockItemQuantity;
      if (dirty[0] & /*$context*/
      4) inlinecontainerview_changes.sheetDocument = /*$context*/
      ctx2[2].actor;
      inlinecontainerview.$set(inlinecontainerview_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainerview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainerview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching && inlinecontainerview) detach(div);
      destroy_component(inlinecontainerview, detaching);
    }
  };
}
function create_each_block_1$f(key_1, ctx) {
  let first;
  let itemtablerow;
  let t2;
  let if_block_anchor;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[14](
        /*actionItem*/
        ctx[19],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      item: (
        /*actionItem*/
        ctx[19].item
      ),
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*actionItem*/
          ctx[19].item.uuid
        )
      },
      hidden: !!/*$itemIdsToShow*/
      ctx[4] && !/*$itemIdsToShow*/
      ctx[4].has(
        /*actionItem*/
        ctx[19].item.id
      ),
      $$slots: {
        default: [
          create_default_slot$11,
          ({ toggleSummary }) => ({ 22: toggleSummary }),
          ({ toggleSummary }) => [toggleSummary ? 4194304 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  let if_block = "containerContents" in /*actionItem*/
  ctx[19] && !!/*actionItem*/
  ctx[19].containerContents && create_if_block_1$H(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty[0] & /*actions*/
      2) itemtablerow_changes.item = /*actionItem*/
      ctx[19].item;
      if (dirty[0] & /*actions*/
      2) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*actionItem*/
          ctx[19].item.uuid
        )
      };
      if (dirty[0] & /*$itemIdsToShow, actions*/
      18) itemtablerow_changes.hidden = !!/*$itemIdsToShow*/
      ctx[4] && !/*$itemIdsToShow*/
      ctx[4].has(
        /*actionItem*/
        ctx[19].item.id
      );
      if (dirty[0] & /*actions, $context, toggleSummary*/
      4194310 | dirty[1] & /*$$scope*/
      2) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
      if ("containerContents" in /*actionItem*/
      ctx[19] && !!/*actionItem*/
      ctx[19].containerContents) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*actions*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$H(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablerow, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_body_slot$8(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[15].actions
  );
  const get_key = (ctx2) => (
    /*actionItem*/
    ctx2[19].item.id
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$f(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$f(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions, $context, inlineContainerToggleService, $itemIdsToShow, damageHealingTypeIconMap, localize, toggleSummary*/
      4195990) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[15].actions
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, t2.parentNode, outro_and_destroy_block, create_each_block_1$f, t2, get_each_context_1$f);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$u(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*visibleItemCount*/
    ctx[16] > 0 && /*section*/
    ctx[15].show && create_if_block$16(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*visibleItemCount*/
        ctx[16] > 0 && /*section*/
        ctx[15].show
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*actions, $itemIdsToShow*/
          18) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$16(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$2k(ctx) {
  let utilitytoolbar;
  let t2;
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  utilitytoolbar = new UtilityToolbar({
    props: {
      class: "abilities-toolbar",
      $$slots: { default: [create_default_slot_12$7] },
      $$scope: { ctx }
    }
  });
  let each_value = ensure_array_like(
    /*actions*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[15].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$u(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$u(key, child_ctx));
  }
  return {
    c() {
      create_component(utilitytoolbar.$$.fragment);
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "actions-tab-container scroll-container flex-column small-gap svelte-1nldtre");
    },
    m(target, anchor) {
      mount_component(utilitytoolbar, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      const utilitytoolbar_changes = {};
      if (dirty[0] & /*utilityBarCommands, $context, searchCriteria*/
      13 | dirty[1] & /*$$scope*/
      2) {
        utilitytoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      utilitytoolbar.$set(utilitytoolbar_changes);
      if (dirty[0] & /*actions, $context, inlineContainerToggleService, $itemIdsToShow, damageHealingTypeIconMap, localize, toggleSummary*/
      4195990) {
        each_value = ensure_array_like(
          /*actions*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$u, null, get_each_context$u);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbar.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbar.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(utilitytoolbar, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function instance$2k($$self, $$props, $$invalidate) {
  let actions;
  let utilityBarCommands;
  let $context;
  let $itemIdsToShow;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  let inlineContainerToggleService = getContext(CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE);
  let searchCriteria = "";
  const itemIdsToShow = writable(void 0);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(4, $itemIdsToShow = value));
  setContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW, itemIdsToShow);
  const localize = FoundryAdapter.localize;
  declareLocation("actions");
  const damageHealingTypeIconMap = Actions.damageAndHealingTypesIconSrcMap;
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(0, searchCriteria);
  }
  const execute_handler = (command, ev) => command.execute?.(ev.detail);
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (actionItem, event) => FoundryAdapter.editOnMiddleClick(event.detail, actionItem.item);
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$context*/
    4) {
      $$invalidate(1, actions = SheetSections.configureActions($context.actions, tabId, SheetPreferencesService.getByType($context.actor.type), TidyFlags.sectionConfig.get($context.actor)?.[tabId]));
    }
    if ($$self.$$.dirty[0] & /*searchCriteria, $context, actions*/
    7) {
      {
        set_store_value(
          itemIdsToShow,
          $itemIdsToShow = ItemVisibility.getItemsToShowAtDepth({
            criteria: searchCriteria,
            itemContext: $context.itemContext,
            sections: actions,
            tabId
          }),
          $itemIdsToShow
        );
      }
    }
    if ($$self.$$.dirty[0] & /*$context*/
    4) {
      $$invalidate(3, utilityBarCommands = $context.utilities[tabId]?.utilityToolbarCommands ?? []);
    }
  };
  return [
    searchCriteria,
    actions,
    $context,
    utilityBarCommands,
    $itemIdsToShow,
    context,
    tabId,
    inlineContainerToggleService,
    itemIdsToShow,
    localize,
    damageHealingTypeIconMap,
    search_value_binding,
    execute_handler,
    toggle_handler,
    mousedown_handler
  ];
}
class ActorActionsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2k, create_fragment$2k, safe_not_equal, {}, null, [-1, -1]);
  }
}
class HandlebarsTemplateRenderer {
  path;
  constructor(props) {
    this.path = props?.path ?? "";
  }
  async render(data) {
    try {
      return await renderTemplate(this.path, data);
    } catch (e2) {
      error("Failed to render handlebars template", false, e2);
      return "";
    }
  }
}
class CustomTabBase {
}
class HandlebarsTab extends CustomTabBase {
  title = "";
  tabId = "";
  /**
   * The path to the handlebars template. Use a leading slash to look in the UserData directory.
   * @example A template in a module's templates directory
   * ```"/modules/my-module-id/templates/my-module-template.hbs"```
   */
  path = "";
  renderScheme = "handlebars";
  tabContentsClasses = [];
  activateDefaultSheetListeners = false;
  constructor(props) {
    super();
    const merged = foundry.utils.mergeObject(this, props);
    Object.assign(this, merged);
  }
  /**
   * An optional function that provides the relevant application context
   * (item sheet context, character sheet context, NPC sheet context, etc.)
   * and expects the same data or a replacement object in return.
   * The return value is passed to the Handlebars template.
   */
  getData;
  /**
   * Optional function to determine whether the tab should be visible when viewing the sheet. When excluded, it defaults to `true`.
   * The `context` field is the relevant application context (item sheet, character sheet, etc.).
   */
  enabled;
  /**
   * Optional function which is called each time a change detection cycle occurs on the sheet.
   * It is called after this tab's content is optionally re-rendered to the DOM.
   */
  onRender;
}
class HtmlTab extends CustomTabBase {
  title = "";
  tabId = "";
  html = "";
  renderScheme = "handlebars";
  tabContentsClasses = [];
  activateDefaultSheetListeners = false;
  constructor(props) {
    super();
    const merged = foundry.utils.mergeObject(this, props);
    Object.assign(this, merged);
  }
  enabled;
  onRender;
}
class SvelteTab extends CustomTabBase {
  /**
   * A reference to the `.svelte` component.
   */
  component = void 0;
  title = "";
  tabId = "";
  /**
   * For svelte-based tabs, the render scheme is set to 'force' and generally ignored.
   */
  renderScheme = "force";
  tabContentsClasses = [];
  activateDefaultSheetListeners = false;
  constructor(props) {
    super();
    const merged = foundry.utils.mergeObject(this, props);
    Object.assign(this, merged);
  }
  /**
   * An optional function that provides the relevant application context
   * (item sheet context, character sheet context, NPC sheet context, etc.)
   * and expects an object in return.
   * The return value is passed to the svelte component as its props.
   */
  getProps;
  /**
   * An optional function that provides the relevant svelte context map and
   * expects the component's ideal context map in return.
   * 
   * @remarks 
   * For most sheets, a guaranteed entry in the context map is a readable store 
   * of the sheet's application context 
   * (item sheet context, character sheet context, NPC sheet context, etc.).
   */
  getContext;
  enabled;
  onRender;
}
class TabManager {
  static async prepareTabsForRender(context, registeredTabs) {
    let enabledTabs = getOrderedEnabledSheetTabs(context, registeredTabs);
    let tabs = [];
    for (let sheetTab of enabledTabs) {
      try {
        let tab = {
          id: sheetTab.id,
          title: TabManager.getTabTitle(sheetTab),
          onRender: sheetTab.onRender,
          content: await getTabContent(context, sheetTab),
          activateDefaultSheetListeners: sheetTab.activateDefaultSheetListeners,
          autoHeight: sheetTab.autoHeight
        };
        tabs.push(tab);
      } catch (e2) {
        error("Unable to prepare tab for rendering", false, {
          error: e2,
          tab: sheetTab
        });
      }
    }
    return tabs;
  }
  static getTabsAsConfigOptions(tabs) {
    return tabs.reduce((prev, curr) => {
      prev[curr.id] = TabManager.getTabTitle(curr);
      return prev;
    }, {});
  }
  static validateTab(tab) {
    if (isNil(tab.tabId?.trim(), "")) {
      error("A tab ID is required for registered tabs.", true);
      return false;
    }
    return true;
  }
  static mapCustomTabToRegisteredTab(tab, layout) {
    let registeredTab;
    layout ??= CONSTANTS.SHEET_LAYOUT_ALL;
    if (tab instanceof HandlebarsTab) {
      registeredTab = {
        content: new HandlebarsTemplateRenderer({ path: tab.path }),
        id: tab.tabId,
        title: tab.title,
        enabled: tab.enabled,
        layout,
        onRender: tab.onRender,
        renderScheme: tab.renderScheme,
        tabContentsClasses: tab.tabContentsClasses,
        getData: tab.getData,
        activateDefaultSheetListeners: tab.activateDefaultSheetListeners
      };
    } else if (tab instanceof HtmlTab) {
      registeredTab = {
        content: {
          html: tab.html,
          type: "html",
          renderScheme: tab.renderScheme,
          cssClass: tab.tabContentsClasses.join(" ")
        },
        id: tab.tabId,
        title: tab.title,
        enabled: tab.enabled,
        layout,
        onRender: tab.onRender,
        renderScheme: tab.renderScheme,
        tabContentsClasses: tab.tabContentsClasses,
        activateDefaultSheetListeners: tab.activateDefaultSheetListeners
      };
    } else if (tab instanceof SvelteTab) {
      if (tab.component) {
        registeredTab = {
          content: {
            type: "svelte",
            component: tab.component,
            cssClass: tab.tabContentsClasses?.join(" ") ?? "",
            getProps: tab.getProps,
            getContext: tab.getContext
          },
          id: tab.tabId,
          title: tab.title,
          enabled: tab.enabled,
          layout,
          onRender: tab.onRender,
          renderScheme: "force",
          tabContentsClasses: tab.tabContentsClasses,
          activateDefaultSheetListeners: tab.activateDefaultSheetListeners
        };
      }
    }
    return registeredTab;
  }
  static getTabTitle(tab) {
    try {
      return typeof tab.title === "function" ? tab.title() : tab.title;
    } catch (e2) {
      error("An error occurred while getting the tab title", false, e2);
      debug("Tab title error troubleshooting info", { tab });
      return "";
    }
  }
}
function getOrderedEnabledSheetTabs(context, registeredTabs) {
  return [...registeredTabs].filter((t2) => {
    try {
      return isNil(t2.enabled) || typeof t2.enabled === "function" && t2.enabled(context);
    } catch (e2) {
      error(
        "An error occurred while determining if a tab should be enabled.",
        false,
        e2
      );
      debug("Tab-enabled error troubleshooting info", { tab: t2 });
      return false;
    }
  });
}
async function getTabContent(data, tab) {
  if ("type" in tab.content && tab.content.type === "svelte") {
    return tab.content;
  }
  if ("type" in tab.content && tab.content.type === "html") {
    return tab.content;
  }
  if (tab.content instanceof HandlebarsTemplateRenderer) {
    const handlebarsData = typeof tab.getData === "function" ? await tab.getData(data) : data;
    return {
      html: await tab.content.render(handlebarsData),
      renderScheme: tab.renderScheme ?? "handlebars",
      type: "html",
      cssClass: tab.tabContentsClasses?.join(" ")
    };
  }
  error(
    "Unble to get tab content. The provided tab information is unable to be rendered.",
    false,
    tab
  );
  return {
    html: "",
    renderScheme: "force",
    type: "html"
  };
}
class CustomContentBase {
}
class HandlebarsContent extends CustomContentBase {
  injectParams;
  /**
   * The path to the handlebars template. Use a leading slash to look in the UserData directory.
   * @example A template in a module's templates directory
   * ```"/modules/my-module-id/templates/my-module-template.hbs"```
   */
  path = "";
  renderScheme = "handlebars";
  activateDefaultSheetListeners = false;
  constructor(props) {
    super();
    const merged = foundry.utils.mergeObject(this, props);
    Object.assign(this, merged);
  }
  onContentReady;
  /**
   * An optional function that provides the relevant application context
   * (item sheet context, character sheet context, NPC sheet context, etc.)
   * and expects the same data or a replacement object in return.
   * The return value is passed to the Handlebars template.
   */
  getData;
  enabled;
  onRender;
}
class CustomContentManager {
  static async prepareContentForRender(context, registeredContent) {
    let enabledContent = getEnabledContent(context, registeredContent);
    let customContent = [];
    for (let content of enabledContent) {
      let c2 = {
        content: await mapRenderableContent(context, content),
        position: content.injectParams?.position,
        selector: content.injectParams?.selector,
        activateDefaultSheetListeners: content.activateDefaultSheetListeners,
        onContentReady: content.onContentReady,
        onRender: content.onRender
      };
      customContent.push(c2);
    }
    return customContent;
  }
  static mapToRegisteredContent(content, layout) {
    let mappedContent = content instanceof HandlebarsContent ? new HandlebarsTemplateRenderer({
      path: content.path
    }) : {
      html: content.html,
      renderScheme: content.renderScheme,
      type: "html"
    };
    return {
      content: mappedContent,
      activateDefaultSheetListeners: content.activateDefaultSheetListeners,
      enabled: content.enabled,
      injectParams: content.injectParams,
      layout: layout ?? "all",
      renderScheme: content.renderScheme,
      getData: content instanceof HandlebarsContent ? content.getData : void 0,
      onContentReady: content.onContentReady,
      onRender: content.onRender
    };
  }
}
function getEnabledContent(context, registeredContent) {
  return [...registeredContent].filter((c2) => {
    try {
      return c2.enabled?.(context) ?? true;
    } catch (e2) {
      error(
        "Unable to check custom content to determine if it is enabled because of an error",
        false,
        e2
      );
      return false;
    }
  });
}
async function mapRenderableContent(data, registeredContent) {
  if ("type" in registeredContent.content && registeredContent.content.type === "html") {
    return registeredContent.content;
  }
  if (registeredContent.content instanceof HandlebarsTemplateRenderer) {
    const handlebarsData = typeof registeredContent.getData === "function" ? await registeredContent.getData(data) : data;
    return {
      html: await registeredContent.content.render(handlebarsData),
      renderScheme: registeredContent.renderScheme ?? "handlebars",
      type: "html"
    };
  }
  error(
    "Unble to get custom content. The provided custom content information is unable to be rendered.",
    false,
    registeredContent
  );
  return {
    html: "",
    renderScheme: "force",
    type: "html"
  };
}
class CharacterSheetRuntime {
  static _content = [];
  static _tabs = [
    {
      title: "TIDY5E.Actions.TabName",
      content: {
        component: ActorActionsTab,
        type: "svelte"
      },
      id: CONSTANTS.TAB_ACTOR_ACTIONS,
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_CHARACTER_ATTRIBUTES,
      title: "DND5E.Attributes",
      content: {
        component: CharacterAttributesTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_CHARACTER_INVENTORY,
      title: "DND5E.Inventory",
      content: {
        component: ActorInventoryTab,
        type: "svelte",
        getProps() {
          return {
            tabId: CONSTANTS.TAB_CHARACTER_INVENTORY
          };
        }
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_CHARACTER_SPELLBOOK,
      title: "DND5E.Spellbook",
      content: {
        component: CharacterSpellbookTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_CHARACTER_FEATURES,
      title: "DND5E.Features",
      content: {
        component: CharacterFeaturesTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_CHARACTER_EFFECTS,
      title: "DND5E.Effects",
      content: {
        component: CharacterEffectsTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_CHARACTER_BIOGRAPHY,
      title: "DND5E.Biography",
      content: {
        component: CharacterBiographyTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_CHARACTER_JOURNAL,
      title: "TIDY5E.JournalTabName",
      content: {
        component: ActorJournalTab,
        type: "svelte"
      },
      enabled: (context) => context.owner,
      layout: "classic"
    }
  ];
  static async getContent(context) {
    return await CustomContentManager.prepareContentForRender(
      context,
      CharacterSheetRuntime._content
    );
  }
  static async getTabs(context) {
    return await TabManager.prepareTabsForRender(
      context,
      CharacterSheetRuntime._tabs
    );
  }
  static getAllRegisteredTabs() {
    return [...CharacterSheetRuntime._tabs];
  }
  static registerContent(registeredContent) {
    this._content.push(registeredContent);
  }
  static registerTab(tab, options) {
    const tabExists = CharacterSheetRuntime._tabs.some((t2) => t2.id === tab.id);
    if (tabExists && !options?.overrideExisting) {
      warn(`Tab with id ${tab.id} already exists.`);
      return;
    }
    if (tabExists && options?.overrideExisting) {
      const index = CharacterSheetRuntime._tabs.findIndex(
        (t2) => t2.id === tab.id
      );
      if (index >= 0) {
        CharacterSheetRuntime._tabs.splice(index, 1);
      }
    }
    CharacterSheetRuntime._tabs.push(tab);
  }
  static getTabTitle(tabId) {
    try {
      let tabTitle = this._tabs.find((t2) => t2.id === tabId)?.title;
      if (typeof tabTitle === "function") {
        tabTitle = tabTitle();
      }
      return tabTitle ? FoundryAdapter.localize(tabTitle) : tabId;
    } catch (e2) {
      error("An error occurred while searching for a tab title.", false, e2);
      debug("Tab title error troubleshooting information", { tabId });
    }
  }
}
function create_else_block$I(ctx) {
  let input;
  let input_disabled_value;
  let input_data_tooltip_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    { id: (
      /*id*/
      ctx[4]
    ) },
    { checked: (
      /*checked*/
      ctx[0]
    ) },
    { title: (
      /*title*/
      ctx[2]
    ) },
    {
      disabled: input_disabled_value = /*disabled*/
      ctx[5] || /*activeEffectApplied*/
      ctx[9]
    },
    {
      "data-tooltip": input_data_tooltip_value = /*activeEffectApplied*/
      ctx[9] ? (
        /*overrideTooltip*/
        ctx[8]
      ) : (
        /*tooltip*/
        ctx[3]
      )
    },
    /*datasetAttributes*/
    ctx[11],
    { class: (
      /*checkboxCssClass*/
      ctx[7]
    ) },
    { "data-tidy-field": (
      /*field*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus) input.focus();
      set_input_value(
        input,
        /*draftValue*/
        ctx[10]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[26]
          ),
          listen(
            input,
            "change",
            /*saveChange*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        dirty & /*id*/
        16 && { id: (
          /*id*/
          ctx2[4]
        ) },
        dirty & /*checked*/
        1 && { checked: (
          /*checked*/
          ctx2[0]
        ) },
        dirty & /*title*/
        4 && { title: (
          /*title*/
          ctx2[2]
        ) },
        dirty & /*disabled, activeEffectApplied*/
        544 && input_disabled_value !== (input_disabled_value = /*disabled*/
        ctx2[5] || /*activeEffectApplied*/
        ctx2[9]) && { disabled: input_disabled_value },
        dirty & /*activeEffectApplied, overrideTooltip, tooltip*/
        776 && input_data_tooltip_value !== (input_data_tooltip_value = /*activeEffectApplied*/
        ctx2[9] ? (
          /*overrideTooltip*/
          ctx2[8]
        ) : (
          /*tooltip*/
          ctx2[3]
        )) && { "data-tooltip": input_data_tooltip_value },
        dirty & /*datasetAttributes*/
        2048 && /*datasetAttributes*/
        ctx2[11],
        dirty & /*checkboxCssClass*/
        128 && { class: (
          /*checkboxCssClass*/
          ctx2[7]
        ) },
        dirty & /*field*/
        2 && { "data-tidy-field": (
          /*field*/
          ctx2[1]
        ) }
      ]));
      if (dirty & /*draftValue*/
      1024) {
        set_input_value(
          input,
          /*draftValue*/
          ctx2[10]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$15(ctx) {
  let label;
  let input;
  let input_disabled_value;
  let t2;
  let label_class_value;
  let label_data_tooltip_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    { id: (
      /*id*/
      ctx[4]
    ) },
    { checked: (
      /*checked*/
      ctx[0]
    ) },
    {
      disabled: input_disabled_value = /*disabled*/
      ctx[5] || /*activeEffectApplied*/
      ctx[9]
    },
    /*datasetAttributes*/
    ctx[11],
    { class: (
      /*checkboxCssClass*/
      ctx[7]
    ) },
    { "data-tidy-field": (
      /*field*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  return {
    c() {
      label = element("label");
      input = element("input");
      t2 = space();
      if (default_slot) default_slot.c();
      set_attributes(input, input_data);
      attr(label, "class", label_class_value = null_to_empty(
        /*labelCssClass*/
        ctx[6]
      ) + " svelte-1i0rlif");
      attr(
        label,
        "title",
        /*title*/
        ctx[2]
      );
      attr(
        label,
        "style",
        /*greenCheckboxStyle*/
        ctx[12]
      );
      attr(label, "data-tooltip", label_data_tooltip_value = /*activeEffectApplied*/
      ctx[9] ? (
        /*overrideTooltip*/
        ctx[8]
      ) : (
        /*tooltip*/
        ctx[3]
      ));
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      if (input.autofocus) input.focus();
      set_input_value(
        input,
        /*draftValue*/
        ctx[10]
      );
      append(label, t2);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[25]
          ),
          listen(
            input,
            "change",
            /*saveChange*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        (!current || dirty & /*id*/
        16) && { id: (
          /*id*/
          ctx2[4]
        ) },
        (!current || dirty & /*checked*/
        1) && { checked: (
          /*checked*/
          ctx2[0]
        ) },
        (!current || dirty & /*disabled, activeEffectApplied*/
        544 && input_disabled_value !== (input_disabled_value = /*disabled*/
        ctx2[5] || /*activeEffectApplied*/
        ctx2[9])) && { disabled: input_disabled_value },
        dirty & /*datasetAttributes*/
        2048 && /*datasetAttributes*/
        ctx2[11],
        (!current || dirty & /*checkboxCssClass*/
        128) && { class: (
          /*checkboxCssClass*/
          ctx2[7]
        ) },
        (!current || dirty & /*field*/
        2) && { "data-tidy-field": (
          /*field*/
          ctx2[1]
        ) }
      ]));
      if (dirty & /*draftValue*/
      1024) {
        set_input_value(
          input,
          /*draftValue*/
          ctx2[10]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*labelCssClass*/
      64 && label_class_value !== (label_class_value = null_to_empty(
        /*labelCssClass*/
        ctx2[6]
      ) + " svelte-1i0rlif")) {
        attr(label, "class", label_class_value);
      }
      if (!current || dirty & /*title*/
      4) {
        attr(
          label,
          "title",
          /*title*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*greenCheckboxStyle*/
      4096) {
        attr(
          label,
          "style",
          /*greenCheckboxStyle*/
          ctx2[12]
        );
      }
      if (!current || dirty & /*activeEffectApplied, overrideTooltip, tooltip*/
      776 && label_data_tooltip_value !== (label_data_tooltip_value = /*activeEffectApplied*/
      ctx2[9] ? (
        /*overrideTooltip*/
        ctx2[8]
      ) : (
        /*tooltip*/
        ctx2[3]
      ))) {
        attr(label, "data-tooltip", label_data_tooltip_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2j(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$15, create_else_block$I];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[15].default
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2j($$self, $$props, $$invalidate) {
  let greenCheckboxStyle;
  let draftValue;
  let datasetAttributes;
  let activeEffectApplied;
  let isEnchanted;
  let overrideTooltip;
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { value = null } = $$props;
  let { checked = false } = $$props;
  let { field } = $$props;
  let { document: document2 } = $$props;
  let { title = null } = $$props;
  let { tooltip = null } = $$props;
  let { id = null } = $$props;
  let { disabled = null } = $$props;
  let { dataset = null } = $$props;
  let { labelCssClass = null } = $$props;
  let { checkboxCssClass = null } = $$props;
  let { onDataPreparing = null } = $$props;
  let { greenCheckboxWidthOverride = null } = $$props;
  async function saveChange(event) {
    let data = onDataPreparing?.(event) ?? {
      [field]: value ?? event.currentTarget.checked
    };
    await document2.update(data);
    $$invalidate(10, draftValue = value);
  }
  const context = getContext("context");
  component_subscribe($$self, context, (value2) => $$invalidate(22, $context = value2));
  const localize = FoundryAdapter.localize;
  function input_change_handler() {
    draftValue = this.value;
    $$invalidate(10, draftValue), $$invalidate(16, value);
  }
  function input_change_handler_1() {
    draftValue = this.value;
    $$invalidate(10, draftValue), $$invalidate(16, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(16, value = $$props2.value);
    if ("checked" in $$props2) $$invalidate(0, checked = $$props2.checked);
    if ("field" in $$props2) $$invalidate(1, field = $$props2.field);
    if ("document" in $$props2) $$invalidate(17, document2 = $$props2.document);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("tooltip" in $$props2) $$invalidate(3, tooltip = $$props2.tooltip);
    if ("id" in $$props2) $$invalidate(4, id = $$props2.id);
    if ("disabled" in $$props2) $$invalidate(5, disabled = $$props2.disabled);
    if ("dataset" in $$props2) $$invalidate(18, dataset = $$props2.dataset);
    if ("labelCssClass" in $$props2) $$invalidate(6, labelCssClass = $$props2.labelCssClass);
    if ("checkboxCssClass" in $$props2) $$invalidate(7, checkboxCssClass = $$props2.checkboxCssClass);
    if ("onDataPreparing" in $$props2) $$invalidate(19, onDataPreparing = $$props2.onDataPreparing);
    if ("greenCheckboxWidthOverride" in $$props2) $$invalidate(20, greenCheckboxWidthOverride = $$props2.greenCheckboxWidthOverride);
    if ("$$scope" in $$props2) $$invalidate(23, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*greenCheckboxWidthOverride*/
    1048576) {
      $$invalidate(12, greenCheckboxStyle = greenCheckboxWidthOverride !== null ? `width: ${greenCheckboxWidthOverride}` : "");
    }
    if ($$self.$$.dirty & /*value*/
    65536) {
      $$invalidate(10, draftValue = value);
    }
    if ($$self.$$.dirty & /*dataset*/
    262144) {
      $$invalidate(11, datasetAttributes = buildDataset(dataset));
    }
    if ($$self.$$.dirty & /*document, field*/
    131074) {
      $$invalidate(9, activeEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(document2, field));
    }
    if ($$self.$$.dirty & /*$context, field*/
    4194306) {
      $$invalidate(21, isEnchanted = $context.itemOverrides instanceof Set && $context.itemOverrides.has(field));
    }
    if ($$self.$$.dirty & /*isEnchanted*/
    2097152) {
      $$invalidate(8, overrideTooltip = isEnchanted ? localize("DND5E.Enchantment.Warning.Override") : localize("DND5E.ActiveEffectOverrideWarning"));
    }
  };
  return [
    checked,
    field,
    title,
    tooltip,
    id,
    disabled,
    labelCssClass,
    checkboxCssClass,
    overrideTooltip,
    activeEffectApplied,
    draftValue,
    datasetAttributes,
    greenCheckboxStyle,
    saveChange,
    context,
    $$slots,
    value,
    document2,
    dataset,
    onDataPreparing,
    greenCheckboxWidthOverride,
    isEnchanted,
    $context,
    $$scope,
    slots,
    input_change_handler,
    input_change_handler_1
  ];
}
class Checkbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2j, create_fragment$2j, safe_not_equal, {
      value: 16,
      checked: 0,
      field: 1,
      document: 17,
      title: 2,
      tooltip: 3,
      id: 4,
      disabled: 5,
      dataset: 18,
      labelCssClass: 6,
      checkboxCssClass: 7,
      onDataPreparing: 19,
      greenCheckboxWidthOverride: 20
    });
  }
}
function create_fragment$2i(ctx) {
  let div6;
  let div1;
  let h40;
  let t1;
  let div0;
  let numberinput0;
  let t2;
  let span0;
  let t4;
  let numberinput1;
  let t5;
  let div3;
  let h41;
  let t7;
  let div2;
  let numberinput2;
  let t8;
  let span1;
  let t10;
  let numberinput3;
  let t11;
  let div5;
  let h42;
  let t13;
  let div4;
  let checkbox;
  let t14;
  let textinput;
  let current;
  numberinput0 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.resources.legact.value",
      value: (
        /*$context*/
        ctx[0].system.resources.legact.value
      ),
      step: "any",
      placeholder: "0",
      title: (
        /*localize*/
        ctx[2]("DND5E.LegActRemaining")
      ),
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  numberinput1 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.resources.legact.max",
      value: (
        /*$context*/
        ctx[0].system.resources.legact.max
      ),
      min: 0,
      step: "1",
      placeholder: "0",
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].lockSensitiveFields
    }
  });
  numberinput2 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.resources.legres.value",
      value: (
        /*$context*/
        ctx[0].system.resources.legres.value
      ),
      step: "any",
      placeholder: "0",
      title: (
        /*localize*/
        ctx[2]("DND5E.LegResRemaining")
      ),
      selectOnFocus: true
    }
  });
  numberinput3 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.resources.legres.max",
      value: (
        /*$context*/
        ctx[0].system.resources.legres.max
      ),
      min: "0",
      step: "1",
      placeholder: "0",
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].lockSensitiveFields
    }
  });
  checkbox = new Checkbox({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.resources.lair.value",
      checked: (
        /*$context*/
        ctx[0].system.resources.lair.value
      ),
      disabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].lockSensitiveFields
    }
  });
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.resources.lair.initiative",
      value: (
        /*$context*/
        ctx[0].system.resources.lair.initiative
      ),
      placeholder: "Init.",
      allowDeltaChanges: true,
      selectOnFocus: true,
      saveEmptyAsNull: true,
      disabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].lockSensitiveFields
    }
  });
  return {
    c() {
      div6 = element("div");
      div1 = element("div");
      h40 = element("h4");
      h40.textContent = `${/*localize*/
      ctx[2]("DND5E.LegAct")}`;
      t1 = space();
      div0 = element("div");
      create_component(numberinput0.$$.fragment);
      t2 = space();
      span0 = element("span");
      span0.textContent = "/";
      t4 = space();
      create_component(numberinput1.$$.fragment);
      t5 = space();
      div3 = element("div");
      h41 = element("h4");
      h41.textContent = `${/*localize*/
      ctx[2]("DND5E.LegRes")}`;
      t7 = space();
      div2 = element("div");
      create_component(numberinput2.$$.fragment);
      t8 = space();
      span1 = element("span");
      span1.textContent = "/";
      t10 = space();
      create_component(numberinput3.$$.fragment);
      t11 = space();
      div5 = element("div");
      h42 = element("h4");
      h42.textContent = `${/*localize*/
      ctx[2]("DND5E.LairAct")}`;
      t13 = space();
      div4 = element("div");
      create_component(checkbox.$$.fragment);
      t14 = space();
      create_component(textinput.$$.fragment);
      attr(h40, "class", "svelte-8y8xv0");
      attr(span0, "class", "sep");
      attr(div0, "class", "counter-value svelte-8y8xv0");
      attr(div1, "class", "counter legendary svelte-8y8xv0");
      attr(h41, "class", "svelte-8y8xv0");
      attr(span1, "class", "sep");
      attr(div2, "class", "counter-value svelte-8y8xv0");
      attr(div3, "class", "counter legendary svelte-8y8xv0");
      attr(h42, "class", "svelte-8y8xv0");
      attr(div4, "class", "counter-value svelte-8y8xv0");
      attr(div5, "class", "counter lair svelte-8y8xv0");
      attr(div6, "class", "counters svelte-8y8xv0");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div1);
      append(div1, h40);
      append(div1, t1);
      append(div1, div0);
      mount_component(numberinput0, div0, null);
      append(div0, t2);
      append(div0, span0);
      append(div0, t4);
      mount_component(numberinput1, div0, null);
      append(div6, t5);
      append(div6, div3);
      append(div3, h41);
      append(div3, t7);
      append(div3, div2);
      mount_component(numberinput2, div2, null);
      append(div2, t8);
      append(div2, span1);
      append(div2, t10);
      mount_component(numberinput3, div2, null);
      append(div6, t11);
      append(div6, div5);
      append(div5, h42);
      append(div5, t13);
      append(div5, div4);
      mount_component(checkbox, div4, null);
      append(div4, t14);
      mount_component(textinput, div4, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const numberinput0_changes = {};
      if (dirty & /*$context*/
      1) numberinput0_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) numberinput0_changes.value = /*$context*/
      ctx2[0].system.resources.legact.value;
      if (dirty & /*$context*/
      1) numberinput0_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput0.$set(numberinput0_changes);
      const numberinput1_changes = {};
      if (dirty & /*$context*/
      1) numberinput1_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) numberinput1_changes.value = /*$context*/
      ctx2[0].system.resources.legact.max;
      if (dirty & /*$context*/
      1) numberinput1_changes.disabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].lockSensitiveFields;
      numberinput1.$set(numberinput1_changes);
      const numberinput2_changes = {};
      if (dirty & /*$context*/
      1) numberinput2_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) numberinput2_changes.value = /*$context*/
      ctx2[0].system.resources.legres.value;
      numberinput2.$set(numberinput2_changes);
      const numberinput3_changes = {};
      if (dirty & /*$context*/
      1) numberinput3_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) numberinput3_changes.value = /*$context*/
      ctx2[0].system.resources.legres.max;
      if (dirty & /*$context*/
      1) numberinput3_changes.disabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].lockSensitiveFields;
      numberinput3.$set(numberinput3_changes);
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.resources.lair.value;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].lockSensitiveFields;
      checkbox.$set(checkbox_changes);
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.resources.lair.initiative;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].lockSensitiveFields;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(checkbox.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(checkbox.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(numberinput2);
      destroy_component(numberinput3);
      destroy_component(checkbox);
      destroy_component(textinput);
    }
  };
}
function instance$2i($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class NpcLegendaryActions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2i, create_fragment$2i, safe_not_equal, {});
  }
}
function create_else_block$H(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text("");
      attr(
        span,
        "title",
        /*localize*/
        ctx[4]("TIDY5E.LayoutNotSupported")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$14(ctx) {
  let button;
  let i2;
  let i_class_value;
  let button_title_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", i_class_value = null_to_empty(
        /*toggleButtonPresentation*/
        ctx[2]?.iconClass
      ) + " svelte-11xs01w");
      attr(button, "type", "button");
      attr(button, "class", "icon-button");
      attr(button, "title", button_title_value = /*toggleButtonPresentation*/
      ctx[2]?.title);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[3].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*toggleButtonPresentation*/
      4 && i_class_value !== (i_class_value = null_to_empty(
        /*toggleButtonPresentation*/
        ctx2[2]?.iconClass
      ) + " svelte-11xs01w")) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & /*toggleButtonPresentation*/
      4 && button_title_value !== (button_title_value = /*toggleButtonPresentation*/
      ctx2[2]?.title)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$settingStore*/
      8 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[3].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_dynamic_element(ctx) {
  let svelte_element;
  function select_block_type(ctx2, dirty) {
    if (
      /*mode*/
      ctx2[0] === "grid" || /*mode*/
      ctx2[0] === "list"
    ) return create_if_block$14;
    return create_else_block$H;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      svelte_element = element(
        /*element*/
        ctx[1]
      );
      if_block.c();
      set_dynamic_element_data(
        /*element*/
        ctx[1]
      )(svelte_element, { class: "toggle-layout svelte-11xs01w" });
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if_block.m(svelte_element, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(svelte_element, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if_block.d();
    }
  };
}
function create_fragment$2h(ctx) {
  let previous_tag = (
    /*element*/
    ctx[1]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*element*/
    ctx[1] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*element*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*element*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*element*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*element*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*element*/
        ctx2[1];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element) svelte_element.d(detaching);
    }
  };
}
function instance$2h($$self, $$props, $$invalidate) {
  let toggleButtonPresentation;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(3, $settingStore = $$value));
  let { mode } = $$props;
  let { element: element2 = "li" } = $$props;
  const localize = FoundryAdapter.localize;
  const dispatcher = createEventDispatcher();
  const click_handler = () => dispatcher("toggle");
  $$self.$$set = ($$props2) => {
    if ("mode" in $$props2) $$invalidate(0, mode = $$props2.mode);
    if ("element" in $$props2) $$invalidate(1, element2 = $$props2.element);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*mode*/
    1) {
      $$invalidate(2, toggleButtonPresentation = mode === "grid" ? {
        title: localize("TIDY5E.ListLayout"),
        iconClass: "fas fa-th-list fa-fw toggle-list"
      } : mode === "list" ? {
        title: localize("TIDY5E.GridLayout"),
        iconClass: "fas fa-th-large fa-fw toggle-grid"
      } : null);
    }
  };
  return [
    mode,
    element2,
    toggleButtonPresentation,
    $settingStore,
    localize,
    dispatcher,
    click_handler
  ];
}
class ItemFilterLayoutToggle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2h, create_fragment$2h, safe_not_equal, { mode: 0, element: 1 });
  }
}
const get_default_slot_changes$1 = (dirty) => ({ item: dirty & /*item*/
8388608 });
const get_default_slot_context$1 = (ctx) => ({ item: (
  /*item*/
  ctx[23]
) });
function fallback_block(ctx) {
  let t_value = (
    /*item*/
    ctx[23][
      /*labelProp*/
      ctx[2]
    ] + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*item, labelProp*/
      8388612 && t_value !== (t_value = /*item*/
      ctx2[23][
        /*labelProp*/
        ctx2[2]
      ] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_default_slot_context$1
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    c() {
      if (default_slot_or_fallback) default_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, item*/
        10485760)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_default_slot_changes$1
            ),
            get_default_slot_context$1
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*item, labelProp*/
        8388612)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    }
  };
}
function create_fragment$2g(ctx) {
  let div1;
  let div0;
  let button0;
  let i0;
  let button0_disabled_value;
  let t0;
  let button1;
  let i1;
  let button1_disabled_value;
  let t1;
  let listbox;
  let updating_items;
  let updating_selectedItemIndex;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  function listbox_items_binding(value) {
    ctx[16](value);
  }
  function listbox_selectedItemIndex_binding(value) {
    ctx[17](value);
  }
  let listbox_props = {
    labelProp: (
      /*labelProp*/
      ctx[2]
    ),
    valueProp: (
      /*valueProp*/
      ctx[3]
    ),
    class: "flex-1 " + /*listboxCssClass*/
    (ctx[4] ?? ""),
    draggable: true,
    $$slots: {
      default: [
        create_default_slot$10,
        ({ item }) => ({ 23: item }),
        ({ item }) => item ? 8388608 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (
    /*items*/
    ctx[0] !== void 0
  ) {
    listbox_props.items = /*items*/
    ctx[0];
  }
  if (
    /*selectedItemIndex*/
    ctx[1] !== void 0
  ) {
    listbox_props.selectedItemIndex = /*selectedItemIndex*/
    ctx[1];
  }
  listbox = new Listbox({ props: listbox_props });
  binding_callbacks.push(() => bind(listbox, "items", listbox_items_binding));
  binding_callbacks.push(() => bind(listbox, "selectedItemIndex", listbox_selectedItemIndex_binding));
  listbox.$on(
    "keydown",
    /*handleListboxKeydown*/
    ctx[5]
  );
  listbox.$on(
    "dragstart",
    /*dragstart_handler*/
    ctx[18]
  );
  listbox.$on(
    "drop",
    /*drop_handler*/
    ctx[19]
  );
  listbox.$on(
    "listboxDrop",
    /*listboxDrop_handler*/
    ctx[20]
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      i0 = element("i");
      t0 = space();
      button1 = element("button");
      i1 = element("i");
      t1 = space();
      create_component(listbox.$$.fragment);
      attr(i0, "class", "fas fa-angle-up");
      attr(
        button0,
        "title",
        /*localize*/
        ctx[11]("TIDY5E.Listbox.MoveUp")
      );
      attr(button0, "type", "button");
      button0.disabled = button0_disabled_value = /*selectedItemIndex*/
      ctx[1] === null || /*selectedItemIndex*/
      ctx[1] === 0;
      attr(button0, "aria-keyshortcuts", "Alt+ArrowUp");
      attr(button0, "data-testid", "sorting-listbox-move-up");
      attr(button0, "class", "svelte-2izq8o");
      attr(i1, "class", "fas fa-angle-down");
      attr(
        button1,
        "title",
        /*localize*/
        ctx[11]("TIDY5E.Listbox.MoveDown")
      );
      attr(button1, "type", "button");
      button1.disabled = button1_disabled_value = /*selectedItemIndex*/
      ctx[1] === null || /*items*/
      ctx[0] === null || /*selectedItemIndex*/
      ctx[1] >= /*items*/
      ctx[0].length - 1;
      attr(button1, "aria-keyshortcuts", "Alt+ArrowDown");
      attr(button1, "data-testid", "sorting-listbox-move-down");
      attr(button1, "class", "svelte-2izq8o");
      attr(div0, "class", "controls svelte-2izq8o");
      attr(div1, "class", div1_class_value = "sorting-listbox flex-row small-gap " + /*$$restProps*/
      (ctx[12].class ?? "") + " svelte-2izq8o");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(button0, i0);
      append(div0, t0);
      append(div0, button1);
      append(button1, i1);
      append(div1, t1);
      mount_component(listbox, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[14]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[15]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*selectedItemIndex*/
      2 && button0_disabled_value !== (button0_disabled_value = /*selectedItemIndex*/
      ctx2[1] === null || /*selectedItemIndex*/
      ctx2[1] === 0)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty & /*selectedItemIndex, items*/
      3 && button1_disabled_value !== (button1_disabled_value = /*selectedItemIndex*/
      ctx2[1] === null || /*items*/
      ctx2[0] === null || /*selectedItemIndex*/
      ctx2[1] >= /*items*/
      ctx2[0].length - 1)) {
        button1.disabled = button1_disabled_value;
      }
      const listbox_changes = {};
      if (dirty & /*labelProp*/
      4) listbox_changes.labelProp = /*labelProp*/
      ctx2[2];
      if (dirty & /*valueProp*/
      8) listbox_changes.valueProp = /*valueProp*/
      ctx2[3];
      if (dirty & /*listboxCssClass*/
      16) listbox_changes.class = "flex-1 " + /*listboxCssClass*/
      (ctx2[4] ?? "");
      if (dirty & /*$$scope, item, labelProp*/
      10485764) {
        listbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_items && dirty & /*items*/
      1) {
        updating_items = true;
        listbox_changes.items = /*items*/
        ctx2[0];
        add_flush_callback(() => updating_items = false);
      }
      if (!updating_selectedItemIndex && dirty & /*selectedItemIndex*/
      2) {
        updating_selectedItemIndex = true;
        listbox_changes.selectedItemIndex = /*selectedItemIndex*/
        ctx2[1];
        add_flush_callback(() => updating_selectedItemIndex = false);
      }
      listbox.$set(listbox_changes);
      if (!current || dirty & /*$$restProps*/
      4096 && div1_class_value !== (div1_class_value = "sorting-listbox flex-row small-gap " + /*$$restProps*/
      (ctx2[12].class ?? "") + " svelte-2izq8o")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(listbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(listbox);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2g($$self, $$props, $$invalidate) {
  const omit_props_names = ["items", "selectedItemIndex", "labelProp", "valueProp", "listboxCssClass"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { items } = $$props;
  let { selectedItemIndex = null } = $$props;
  let { labelProp } = $$props;
  let { valueProp } = $$props;
  let { listboxCssClass = null } = $$props;
  function handleListboxKeydown(e2) {
    if (e2.detail.key === "ArrowUp" && e2.detail.altKey) {
      moveUp();
    } else if (e2.detail.key === "ArrowDown" && e2.detail.altKey) {
      moveDown();
    }
  }
  function moveUp() {
    if (selectedItemIndex === null || selectedItemIndex === 0 || items === null) {
      return;
    }
    const topValue = items[selectedItemIndex - 1];
    const bottomValue = items[selectedItemIndex];
    $$invalidate(0, items[selectedItemIndex - 1] = bottomValue, items);
    $$invalidate(0, items[selectedItemIndex] = topValue, items);
    if (selectedItemIndex) {
      $$invalidate(1, selectedItemIndex -= 1);
      $$invalidate(0, items);
    }
    itemsMoved();
  }
  function moveDown() {
    if (items === null || selectedItemIndex === null || selectedItemIndex >= items.length - 1) {
      return;
    }
    const topValue = items[selectedItemIndex];
    const bottomValue = items[selectedItemIndex + 1];
    $$invalidate(0, items[selectedItemIndex] = bottomValue, items);
    $$invalidate(0, items[selectedItemIndex + 1] = topValue, items);
    if (selectedItemIndex !== null) {
      $$invalidate(1, selectedItemIndex += 1);
      $$invalidate(0, items);
    }
    itemsMoved();
  }
  function itemsMoved() {
    if (selectedItemIndex !== null && items.at(selectedItemIndex) === void 0) {
      $$invalidate(1, selectedItemIndex = items.length ? items.length - 1 : null);
    }
  }
  function onDragStart(ev) {
    $$invalidate(1, selectedItemIndex = ev.detail.index);
    ev.detail.event.dataTransfer?.setData("text/plain", ev.detail.index.toString());
  }
  function onDrop(ev) {
    ev.detail.event.stopPropagation();
    ev.detail.event.preventDefault();
    const draggedIndex = parseInt(ev.detail.event.dataTransfer?.getData("text/plain") ?? "");
    if (isNaN(draggedIndex)) {
      return;
    }
    const theDragged = items.at(draggedIndex);
    if (!theDragged) {
      return;
    }
    const dropTargetIndex = ev.detail.index;
    $$invalidate(0, items = items.reduce(
      (acc, item, index) => {
        if (index === dropTargetIndex && draggedIndex > dropTargetIndex) {
          acc.push(theDragged);
        }
        if (index === draggedIndex) {
          return acc;
        }
        acc.push(item);
        if (index === dropTargetIndex && draggedIndex < dropTargetIndex) {
          acc.push(theDragged);
        }
        return acc;
      },
      []
    ));
    $$invalidate(1, selectedItemIndex = items.indexOf(theDragged));
  }
  function onListboxDrop(ev) {
    const draggedIndex = parseInt(ev.detail.event.dataTransfer?.getData("text/plain") ?? "");
    if (isNaN(draggedIndex)) {
      return;
    }
    const theDragged = items.splice(draggedIndex, 1);
    items.push(...theDragged);
    $$invalidate(0, items);
  }
  const localize = FoundryAdapter.localize;
  const click_handler = () => moveUp();
  const click_handler_1 = () => moveDown();
  function listbox_items_binding(value) {
    items = value;
    $$invalidate(0, items);
  }
  function listbox_selectedItemIndex_binding(value) {
    selectedItemIndex = value;
    $$invalidate(1, selectedItemIndex);
  }
  const dragstart_handler = (ev) => onDragStart(ev);
  const drop_handler = (ev) => onDrop(ev);
  const listboxDrop_handler = (ev) => onListboxDrop(ev);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("items" in $$new_props) $$invalidate(0, items = $$new_props.items);
    if ("selectedItemIndex" in $$new_props) $$invalidate(1, selectedItemIndex = $$new_props.selectedItemIndex);
    if ("labelProp" in $$new_props) $$invalidate(2, labelProp = $$new_props.labelProp);
    if ("valueProp" in $$new_props) $$invalidate(3, valueProp = $$new_props.valueProp);
    if ("listboxCssClass" in $$new_props) $$invalidate(4, listboxCssClass = $$new_props.listboxCssClass);
    if ("$$scope" in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  return [
    items,
    selectedItemIndex,
    labelProp,
    valueProp,
    listboxCssClass,
    handleListboxKeydown,
    moveUp,
    moveDown,
    onDragStart,
    onDrop,
    onListboxDrop,
    localize,
    $$restProps,
    slots,
    click_handler,
    click_handler_1,
    listbox_items_binding,
    listbox_selectedItemIndex_binding,
    dragstart_handler,
    drop_handler,
    listboxDrop_handler,
    $$scope
  ];
}
class SortingListbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2g, create_fragment$2g, safe_not_equal, {
      items: 0,
      selectedItemIndex: 1,
      labelProp: 2,
      valueProp: 3,
      listboxCssClass: 4
    });
  }
}
function create_else_block$G(ctx) {
  let button;
  let i2;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[6](
        /*item*/
        ctx[11]
      )
    );
  }
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "far fa-eye-slash fa-fw");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[4]("TIDY5E.Section.ConfigDialog.showTooltip")
      );
      attr(button, "data-testid", "section-config-show");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$13(ctx) {
  let button;
  let i2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*item*/
        ctx[11]
      )
    );
  }
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "far fa-eye fa-fw");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[4]("TIDY5E.Section.ConfigDialog.hideTooltip")
      );
      attr(button, "data-testid", "section-config-hide");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$$(ctx) {
  let span;
  let t0_value = (
    /*item*/
    ctx[11].label + ""
  );
  let t0;
  let span_data_section_key_value;
  let t1;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*item*/
      ctx2[11].show !== false
    ) return create_if_block$13;
    return create_else_block$G;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if_block.c();
      if_block_anchor = empty();
      attr(span, "data-section-key", span_data_section_key_value = /*item*/
      ctx[11]["key"]);
      attr(span, "data-testid", "section-config-item-label");
      attr(span, "class", "flex-1 svelte-izvopf");
      toggle_class(
        span,
        "marked-as-hidden",
        /*item*/
        ctx[11].show === false
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      2048 && t0_value !== (t0_value = /*item*/
      ctx2[11].label + "")) set_data(t0, t0_value);
      if (dirty & /*item*/
      2048 && span_data_section_key_value !== (span_data_section_key_value = /*item*/
      ctx2[11]["key"])) {
        attr(span, "data-section-key", span_data_section_key_value);
      }
      if (dirty & /*item*/
      2048) {
        toggle_class(
          span,
          "marked-as-hidden",
          /*item*/
          ctx2[11].show === false
        );
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_fragment$2f(ctx) {
  let section;
  let sortinglistbox;
  let updating_items;
  let t0;
  let div;
  let button0;
  let i0;
  let t1;
  let t2_value = (
    /*localize*/
    ctx[4]("TIDY5E.UseDefault") + ""
  );
  let t2;
  let t3;
  let button1;
  let i1;
  let t4;
  let t5_value = (
    /*localize*/
    ctx[4]("TIDY5E.SaveChanges") + ""
  );
  let t5;
  let t6;
  let button2;
  let i2;
  let t7;
  let t8_value = (
    /*localize*/
    ctx[4]("TIDY5E.ApplyChanges") + ""
  );
  let t8;
  let current;
  let mounted;
  let dispose;
  function sortinglistbox_items_binding(value) {
    ctx[7](value);
  }
  let sortinglistbox_props = {
    labelProp: "label",
    valueProp: "key",
    listboxCssClass: "scroll-container",
    class: "flex-1",
    $$slots: {
      default: [
        create_default_slot$$,
        ({ item }) => ({ 11: item }),
        ({ item }) => item ? 2048 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (
    /*sections*/
    ctx[0] !== void 0
  ) {
    sortinglistbox_props.items = /*sections*/
    ctx[0];
  }
  sortinglistbox = new SortingListbox({ props: sortinglistbox_props });
  binding_callbacks.push(() => bind(sortinglistbox, "items", sortinglistbox_items_binding));
  return {
    c() {
      section = element("section");
      create_component(sortinglistbox.$$.fragment);
      t0 = space();
      div = element("div");
      button0 = element("button");
      i0 = element("i");
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      button1 = element("button");
      i1 = element("i");
      t4 = space();
      t5 = text(t5_value);
      t6 = space();
      button2 = element("button");
      i2 = element("i");
      t7 = space();
      t8 = text(t8_value);
      attr(i0, "class", "fas fa-rotate-right");
      attr(button0, "type", "button");
      attr(button0, "class", "use-default-btn");
      attr(button0, "data-testid", "section-config-use-default");
      attr(i1, "class", "fas fa-save");
      attr(button1, "type", "button");
      attr(button1, "data-testid", "section-config-save-changes");
      attr(button1, "class", "save-changes-btn");
      attr(i2, "class", "fas fa-check");
      attr(button2, "type", "button");
      attr(button2, "class", "apply-changes-btn");
      attr(button2, "data-testid", "section-config-apply-changes");
      attr(div, "class", "flex-row small-gap");
      attr(section, "class", "flex-column svelte-izvopf");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      mount_component(sortinglistbox, section, null);
      append(section, t0);
      append(section, div);
      append(div, button0);
      append(button0, i0);
      append(button0, t1);
      append(button0, t2);
      append(div, t3);
      append(div, button1);
      append(button1, i1);
      append(button1, t4);
      append(button1, t5);
      append(div, t6);
      append(div, button2);
      append(button2, i2);
      append(button2, t7);
      append(button2, t8);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler_2*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*click_handler_3*/
            ctx[9]
          ),
          listen(
            button2,
            "click",
            /*click_handler_4*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const sortinglistbox_changes = {};
      if (dirty & /*$$scope, item, sections*/
      6145) {
        sortinglistbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_items && dirty & /*sections*/
      1) {
        updating_items = true;
        sortinglistbox_changes.items = /*sections*/
        ctx2[0];
        add_flush_callback(() => updating_items = false);
      }
      sortinglistbox.$set(sortinglistbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sortinglistbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sortinglistbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(sortinglistbox);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2f($$self, $$props, $$invalidate) {
  let { sections } = $$props;
  let { onSaveChanges } = $$props;
  let { onApply } = $$props;
  let { useDefault } = $$props;
  const localize = FoundryAdapter.localize;
  const click_handler = (item) => {
    item.show = false;
    $$invalidate(0, sections);
  };
  const click_handler_1 = (item) => {
    item.show = true;
    $$invalidate(0, sections);
  };
  function sortinglistbox_items_binding(value) {
    sections = value;
    $$invalidate(0, sections);
  }
  const click_handler_2 = (ev) => useDefault();
  const click_handler_3 = (ev) => onSaveChanges(sections);
  const click_handler_4 = () => onApply(sections);
  $$self.$$set = ($$props2) => {
    if ("sections" in $$props2) $$invalidate(0, sections = $$props2.sections);
    if ("onSaveChanges" in $$props2) $$invalidate(1, onSaveChanges = $$props2.onSaveChanges);
    if ("onApply" in $$props2) $$invalidate(2, onApply = $$props2.onApply);
    if ("useDefault" in $$props2) $$invalidate(3, useDefault = $$props2.useDefault);
  };
  return [
    sections,
    onSaveChanges,
    onApply,
    useDefault,
    localize,
    click_handler,
    click_handler_1,
    sortinglistbox_items_binding,
    click_handler_2,
    click_handler_3,
    click_handler_4
  ];
}
class DocumentTabSectionConfig extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2f, create_fragment$2f, safe_not_equal, {
      sections: 0,
      onSaveChanges: 1,
      onApply: 2,
      useDefault: 3
    });
  }
}
class DocumentTabSectionConfigApplication extends SvelteFormApplicationBase {
  document;
  sections;
  tabId;
  tabTitle;
  constructor({
    document: document2,
    sections,
    tabId,
    tabTitle
  }) {
    super();
    this.document = document2;
    this.sections = sections.map((section) => ({
      key: section.key,
      label: section.label,
      show: section.show !== false
    }));
    this.tabId = tabId;
    this.tabTitle = tabTitle;
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      width: 650,
      height: 500,
      id: "tidy-5e-sheets-section-configuration",
      popOut: true
    });
  }
  get title() {
    return FoundryAdapter.localize("TIDY5E.Section.ConfigDialog.title", {
      tabTitle: this.tabTitle
    });
  }
  createComponent(node) {
    return new DocumentTabSectionConfig({
      target: node,
      props: {
        sections: this.sections.map((curr) => {
          return {
            key: curr.key,
            label: FoundryAdapter.localize(curr.label),
            show: curr.show
          };
        }, {}),
        onSaveChanges: this._onSaveChanges.bind(this),
        onApply: this._onApply.bind(this),
        useDefault: this._useDefault.bind(this)
      }
    });
  }
  async _onSaveChanges(sections) {
    await this._onApply(sections);
    this.close();
  }
  async _onApply(sections) {
    const sectionConfig = TidyFlags.sectionConfig.get(this.document) ?? {};
    sectionConfig[this.tabId] = sections.reduce(
      (result, curr, i2) => {
        result[curr.key] = {
          key: curr.key,
          order: i2,
          show: curr.show !== false
        };
        return result;
      },
      {}
    );
    await TidyFlags.sectionConfig.set(this.document, sectionConfig);
  }
  _useDefault() {
    Dialog.confirm({
      title: FoundryAdapter.localize("TIDY5E.UseDefaultDialog.title"),
      content: `<p>${FoundryAdapter.localize(
        "TIDY5E.UseDefaultDialog.text"
      )}</p>`,
      yes: () => {
        const sectionConfig = TidyFlags.sectionConfig.get(this.document) ?? {};
        delete sectionConfig[this.tabId];
        sectionConfig[`-=${this.tabId}`] = {};
        TidyFlags.sectionConfig.set(this.document, sectionConfig);
        this.close();
      },
      no: () => {
      },
      defaultYes: false
    });
  }
}
function get_each_context$t(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  return child_ctx;
}
function get_each_context_1$e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  return child_ctx;
}
function get_each_context_2$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[4].itemContext[
      /*item*/
      child_ctx[31].id
    ]
  );
  child_ctx[32] = constants_0;
  return child_ctx;
}
function get_if_ctx$7(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = ItemVisibility.countVisibleItems(
    /*section*/
    child_ctx[25].items,
    /*$itemIdsToShow*/
    child_ctx[11]
  );
  child_ctx[30] = constants_0;
  return child_ctx;
}
function get_each_context_3$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i2];
  return child_ctx;
}
function create_each_block_3$1(key_1, ctx) {
  let first;
  let utilitytoolbarcommand;
  let current;
  function execute_handler(...args) {
    return (
      /*execute_handler*/
      ctx[19](
        /*command*/
        ctx[36],
        ...args
      )
    );
  }
  utilitytoolbarcommand = new UtilityToolbarCommand({
    props: {
      title: (
        /*command*/
        ctx[36].title
      ),
      iconClass: (
        /*command*/
        ctx[36].iconClass
      ),
      text: (
        /*command*/
        ctx[36].text
      ),
      visible: (
        /*command*/
        ctx[36].visible ?? true
      )
    }
  });
  utilitytoolbarcommand.$on("execute", execute_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(utilitytoolbarcommand.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(utilitytoolbarcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const utilitytoolbarcommand_changes = {};
      if (dirty[0] & /*utilityBarCommands*/
      512) utilitytoolbarcommand_changes.title = /*command*/
      ctx[36].title;
      if (dirty[0] & /*utilityBarCommands*/
      512) utilitytoolbarcommand_changes.iconClass = /*command*/
      ctx[36].iconClass;
      if (dirty[0] & /*utilityBarCommands*/
      512) utilitytoolbarcommand_changes.text = /*command*/
      ctx[36].text;
      if (dirty[0] & /*utilityBarCommands*/
      512) utilitytoolbarcommand_changes.visible = /*command*/
      ctx[36].visible ?? true;
      utilitytoolbarcommand.$set(utilitytoolbarcommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbarcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbarcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(utilitytoolbarcommand, detaching);
    }
  };
}
function create_default_slot_14$4(ctx) {
  let search;
  let updating_value;
  let t0;
  let pinnedfiltertoggles;
  let t1;
  let filtermenu;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  function search_value_binding(value) {
    ctx[18](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[0] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[0];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  pinnedfiltertoggles = new PinnedFilterToggles({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[13]
      ),
      filters: ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx[4].filterPins,
        /*$context*/
        ctx[4].filterData,
        /*tabId*/
        ctx[13]
      )
    }
  });
  filtermenu = new FilterMenu({ props: { tabId: (
    /*tabId*/
    ctx[13]
  ) } });
  let each_value_3 = ensure_array_like(
    /*utilityBarCommands*/
    ctx[9]
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[36].title
  );
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    let child_ctx = get_each_context_3$1(ctx, each_value_3, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_3$1(key, child_ctx));
  }
  return {
    c() {
      create_component(search.$$.fragment);
      t0 = space();
      create_component(pinnedfiltertoggles.$$.fragment);
      t1 = space();
      create_component(filtermenu.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      insert(target, t0, anchor);
      mount_component(pinnedfiltertoggles, target, anchor);
      insert(target, t1, anchor);
      mount_component(filtermenu, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_changes = {};
      if (!updating_value && dirty[0] & /*searchCriteria*/
      1) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      const pinnedfiltertoggles_changes = {};
      if (dirty[0] & /*$context*/
      16) pinnedfiltertoggles_changes.filters = ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx2[4].filterPins,
        /*$context*/
        ctx2[4].filterData,
        /*tabId*/
        ctx2[13]
      );
      pinnedfiltertoggles.$set(pinnedfiltertoggles_changes);
      if (dirty[0] & /*utilityBarCommands*/
      512) {
        each_value_3 = ensure_array_like(
          /*utilityBarCommands*/
          ctx2[9]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_3, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_3$1, each_1_anchor, get_each_context_3$1);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(pinnedfiltertoggles.$$.fragment, local);
      transition_in(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(pinnedfiltertoggles.$$.fragment, local);
      transition_out(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(search, detaching);
      destroy_component(pinnedfiltertoggles, detaching);
      destroy_component(filtermenu, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block_27(ctx) {
  let traits;
  let current;
  traits = new Traits({
    props: {
      toggleable: !/*$settingStore*/
      ctx[5].alwaysShowNpcTraits
    }
  });
  return {
    c() {
      create_component(traits.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traits, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traits_changes = {};
      if (dirty[0] & /*$settingStore*/
      32) traits_changes.toggleable = !/*$settingStore*/
      ctx2[5].alwaysShowNpcTraits;
      traits.$set(traits_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traits.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traits.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traits, detaching);
    }
  };
}
function create_default_slot_13$6(ctx) {
  let npclegendaryactions;
  let current;
  npclegendaryactions = new NpcLegendaryActions({});
  return {
    c() {
      create_component(npclegendaryactions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(npclegendaryactions, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(npclegendaryactions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(npclegendaryactions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(npclegendaryactions, detaching);
    }
  };
}
function create_if_block_26(ctx) {
  let traits;
  let current;
  traits = new Traits({
    props: {
      toggleable: !/*$settingStore*/
      ctx[5].alwaysShowNpcTraits
    }
  });
  return {
    c() {
      create_component(traits.$$.fragment);
    },
    m(target, anchor) {
      mount_component(traits, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const traits_changes = {};
      if (dirty[0] & /*$settingStore*/
      32) traits_changes.toggleable = !/*$settingStore*/
      ctx2[5].alwaysShowNpcTraits;
      traits.$set(traits_changes);
    },
    i(local) {
      if (current) return;
      transition_in(traits.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(traits.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(traits, detaching);
    }
  };
}
function create_if_block_7$9(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    (ctx[4].unlocked || /*visibleItemCount*/
    ctx[30] > 0) && create_if_block_8$6(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[4].unlocked || /*visibleItemCount*/
        ctx2[30] > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$context, features, $itemIdsToShow*/
          2072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_8$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_8$6(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[25].key
      ),
      "data-custom-section": (
        /*section*/
        ctx[25].custom ? true : null
      ),
      $$slots: {
        body: [create_body_slot$7],
        header: [create_header_slot$8]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtable_changes = {};
      if (dirty[0] & /*features*/
      8) itemtable_changes.key = /*section*/
      ctx2[25].key;
      if (dirty[0] & /*features*/
      8) itemtable_changes["data-custom-section"] = /*section*/
      ctx2[25].custom ? true : null;
      if (dirty[0] & /*$context, features, $itemIdsToShow, classicControlsColumnWidth, controls*/
      2330 | dirty[1] & /*$$scope*/
      256) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function create_default_slot_12$6(ctx) {
  let t_value = (
    /*localize*/
    ctx[17](
      /*section*/
      ctx[25].label
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*features*/
      8 && t_value !== (t_value = /*localize*/
      ctx2[17](
        /*section*/
        ctx2[25].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_25(ctx) {
  let itemtablecolumn0;
  let t2;
  let itemtablecolumn1;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_11$7] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_10$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t2 = space();
      create_component(itemtablecolumn1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty[1] & /*$$scope*/
      256) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty[1] & /*$$scope*/
      256) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
    }
  };
}
function create_default_slot_11$7(ctx) {
  let t_value = (
    /*localize*/
    ctx[17]("DND5E.Uses") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_10$a(ctx) {
  let t_value = (
    /*localize*/
    ctx[17]("DND5E.Usage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_24(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: "3rem",
      $$slots: { default: [create_default_slot_9$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty[1] & /*$$scope*/
      256) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_9$a(ctx) {
  let t_value = (
    /*localize*/
    ctx[17]("DND5E.QuantityAbbr") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty[0] & /*classicControlsColumnWidth*/
      256) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[8];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_8$b(ctx) {
  let itemtablecolumn;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_12$6] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*section*/
    ctx[25].hasActions && create_if_block_25(ctx)
  );
  let if_block1 = (
    /*section*/
    ctx[25].dataset.type === "loot" && create_if_block_24(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[4].editable && /*$context*/
    ctx[4].useClassicControls && create_if_block_23(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty[0] & /*features*/
      8 | dirty[1] & /*$$scope*/
      256) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
      if (
        /*section*/
        ctx2[25].hasActions
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*features*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_25(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[25].dataset.type === "loot"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*features*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_24(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[4].editable && /*$context*/
        ctx2[4].useClassicControls
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*$context*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_23(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block2_anchor);
      }
      destroy_component(itemtablecolumn, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_header_slot$8(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_8$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty[0] & /*classicControlsColumnWidth, $context, features*/
      280 | dirty[1] & /*$$scope*/
      256) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let inlinecontainertoggle;
  let current;
  inlinecontainertoggle = new InlineContainerToggle({
    props: {
      item: (
        /*item*/
        ctx[31]
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[14]
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainertoggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainertoggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainertoggle_changes = {};
      if (dirty[0] & /*features*/
      8) inlinecontainertoggle_changes.item = /*item*/
      ctx2[31];
      inlinecontainertoggle.$set(inlinecontainertoggle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainertoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainertoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainertoggle, detaching);
    }
  };
}
function create_if_block_21(ctx) {
  let t2;
  return {
    c() {
      t2 = text("");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_20(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa-solid fa-link-slash align-self-center");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_19(ctx) {
  let span;
  let ammoselector;
  let current;
  ammoselector = new AmmoSelector({ props: { item: (
    /*item*/
    ctx[31]
  ) } });
  return {
    c() {
      span = element("span");
      create_component(ammoselector.$$.fragment);
      attr(span, "class", "ammo");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(ammoselector, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ammoselector_changes = {};
      if (dirty[0] & /*features*/
      8) ammoselector_changes.item = /*item*/
      ctx2[31];
      ammoselector.$set(ammoselector_changes);
    },
    i(local) {
      if (current) return;
      transition_in(ammoselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ammoselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(ammoselector);
    }
  };
}
function create_default_slot_7$c(ctx) {
  let t0;
  let t1;
  let span;
  let t2_value = (
    /*item*/
    ctx[31].name + ""
  );
  let t2;
  let span_data_tidy_item_name_value;
  let t3;
  let show_if = (
    /*item*/
    ctx[31].system?.properties?.has("amm")
  );
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*ctx*/
    ctx[32].parent && create_if_block_21()
  );
  let if_block1 = !/*section*/
  ctx[25].isClass && /*item*/
  ctx[31].type === "subclass" && create_if_block_20();
  let if_block2 = show_if && create_if_block_19(ctx);
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
      t3 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
      attr(span, "class", "truncate");
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*item*/
      ctx[31].name);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, span, anchor);
      append(span, t2);
      insert(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*ctx*/
        ctx2[32].parent
      ) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_21();
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*section*/
      ctx2[25].isClass && /*item*/
      ctx2[31].type === "subclass") {
        if (if_block1) ;
        else {
          if_block1 = create_if_block_20();
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty[0] & /*features*/
      8) && t2_value !== (t2_value = /*item*/
      ctx2[31].name + "")) set_data(t2, t2_value);
      if (!current || dirty[0] & /*features*/
      8 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*item*/
      ctx2[31].name)) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
      if (dirty[0] & /*features*/
      8) show_if = /*item*/
      ctx2[31].system?.properties?.has("amm");
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*features*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_19(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(span);
        detach(t3);
        detach(if_block2_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_18(ctx) {
  let levelupdropdown;
  let current;
  levelupdropdown = new LevelUpDropdown({
    props: {
      availableLevels: (
        /*ctx*/
        ctx[32]?.availableLevels
      ),
      item: (
        /*item*/
        ctx[31]
      ),
      disabled: !/*$context*/
      ctx[4].editable || /*$context*/
      ctx[4].lockLevelSelector
    }
  });
  return {
    c() {
      create_component(levelupdropdown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(levelupdropdown, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const levelupdropdown_changes = {};
      if (dirty[0] & /*$context, features*/
      24) levelupdropdown_changes.availableLevels = /*ctx*/
      ctx2[32]?.availableLevels;
      if (dirty[0] & /*features*/
      8) levelupdropdown_changes.item = /*item*/
      ctx2[31];
      if (dirty[0] & /*$context*/
      16) levelupdropdown_changes.disabled = !/*$context*/
      ctx2[4].editable || /*$context*/
      ctx2[4].lockLevelSelector;
      levelupdropdown.$set(levelupdropdown_changes);
    },
    i(local) {
      if (current) return;
      transition_in(levelupdropdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(levelupdropdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(levelupdropdown, detaching);
    }
  };
}
function create_default_slot_6$e(ctx) {
  let itemusebutton;
  let t0;
  let t1;
  let itemname;
  let t2;
  let if_block1_anchor;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[4].editable,
      item: (
        /*item*/
        ctx[31]
      )
    }
  });
  let if_block0 = "containerContents" in /*ctx*/
  ctx[32] && !!/*ctx*/
  ctx[32].containerContents && create_if_block_22(ctx);
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[20](
        /*toggleSummary*/
        ctx[35]
      )
    );
  }
  itemname = new ItemName({
    props: {
      cssClass: "extra-small-gap",
      item: (
        /*item*/
        ctx[31]
      ),
      $$slots: { default: [create_default_slot_7$c] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  let if_block1 = (
    /*item*/
    ctx[31].type === "class" && create_if_block_18(ctx)
  );
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      create_component(itemname.$$.fragment);
      t2 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemname, target, anchor);
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty[0] & /*$context*/
      16) itemusebutton_changes.disabled = !/*$context*/
      ctx[4].editable;
      if (dirty[0] & /*features*/
      8) itemusebutton_changes.item = /*item*/
      ctx[31];
      itemusebutton.$set(itemusebutton_changes);
      if ("containerContents" in /*ctx*/
      ctx[32] && !!/*ctx*/
      ctx[32].containerContents) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*$context, features*/
          24) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemname_changes = {};
      if (dirty[0] & /*features*/
      8) itemname_changes.item = /*item*/
      ctx[31];
      if (dirty[0] & /*features, $context*/
      24 | dirty[1] & /*$$scope*/
      256) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
      if (
        /*item*/
        ctx[31].type === "class"
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty[0] & /*features*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_18(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemname.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemname.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block1_anchor);
      }
      destroy_component(itemusebutton, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemname, detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_if_block_13$3(ctx) {
  let itemtablecell0;
  let t2;
  let itemtablecell1;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_5$i] },
      $$scope: { ctx }
    }
  });
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_4$l] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t2 = space();
      create_component(itemtablecell1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecell1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty[0] & /*features, $context*/
      24 | dirty[1] & /*$$scope*/
      256) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      const itemtablecell1_changes = {};
      if (dirty[0] & /*features*/
      8 | dirty[1] & /*$$scope*/
      256) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(itemtablecell1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(itemtablecell1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtablecell0, detaching);
      destroy_component(itemtablecell1, detaching);
    }
  };
}
function create_else_block_4$1(ctx) {
  let itemadduses;
  let current;
  itemadduses = new ItemAddUses({ props: { item: (
    /*item*/
    ctx[31]
  ) } });
  return {
    c() {
      create_component(itemadduses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemadduses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemadduses_changes = {};
      if (dirty[0] & /*features*/
      8) itemadduses_changes.item = /*item*/
      ctx2[31];
      itemadduses.$set(itemadduses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemadduses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemadduses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemadduses, detaching);
    }
  };
}
function create_if_block_17(ctx) {
  let itemuses;
  let current;
  itemuses = new ItemUses({ props: { item: (
    /*item*/
    ctx[31]
  ) } });
  return {
    c() {
      create_component(itemuses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemuses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemuses_changes = {};
      if (dirty[0] & /*features*/
      8) itemuses_changes.item = /*item*/
      ctx2[31];
      itemuses.$set(itemuses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemuses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemuses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemuses, detaching);
    }
  };
}
function create_if_block_16(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-bolt");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[17]("DND5E.Charged")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_15$2(ctx) {
  let rechargecontrol;
  let current;
  rechargecontrol = new RechargeControl({ props: { item: (
    /*item*/
    ctx[31]
  ) } });
  return {
    c() {
      create_component(rechargecontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rechargecontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rechargecontrol_changes = {};
      if (dirty[0] & /*features*/
      8) rechargecontrol_changes.item = /*item*/
      ctx2[31];
      rechargecontrol.$set(rechargecontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rechargecontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rechargecontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rechargecontrol, detaching);
    }
  };
}
function create_default_slot_5$i(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_15$2,
    create_if_block_16,
    create_if_block_17,
    create_else_block_4$1
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*item*/
      ctx2[31].isOnCooldown
    ) return 0;
    if (
      /*item*/
      ctx2[31].system.recharge?.value
    ) return 1;
    if (
      /*ctx*/
      ctx2[32]?.hasUses
    ) return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_14$3(ctx) {
  let t_value = (
    /*item*/
    (ctx[31].labels?.activation ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*features*/
      8 && t_value !== (t_value = /*item*/
      (ctx2[31].labels?.activation ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_4$l(ctx) {
  let if_block_anchor;
  let if_block = (
    /*item*/
    ctx[31].system.activation?.type && create_if_block_14$3(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[31].system.activation?.type
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_14$3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_12$3(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "3rem",
      $$slots: { default: [create_default_slot_3$o] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty[0] & /*features, $context*/
      24 | dirty[1] & /*$$scope*/
      256) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_3$o(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[31]
      ),
      field: "system.quantity",
      value: (
        /*item*/
        ctx[31].system.quantity
      ),
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[4].editable || /*$context*/
      ctx[4].lockItemQuantity,
      placeholder: "0",
      allowDeltaChanges: true,
      cssClass: "text-align-center"
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty[0] & /*features*/
      8) textinput_changes.document = /*item*/
      ctx2[31];
      if (dirty[0] & /*features*/
      8) textinput_changes.value = /*item*/
      ctx2[31].system.quantity;
      if (dirty[0] & /*$context*/
      16) textinput_changes.disabled = !/*$context*/
      ctx2[4].editable || /*$context*/
      ctx2[4].lockItemQuantity;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_11$3(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot_2$p] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty[0] & /*classicControlsColumnWidth*/
      256) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[8];
      if (dirty[0] & /*controls, features*/
      10 | dirty[1] & /*$$scope*/
      256) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_2$p(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[1]
      ),
      params: { item: (
        /*item*/
        ctx[31]
      ) }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty[0] & /*controls*/
      2) classiccontrols_changes.controls = /*controls*/
      ctx2[1];
      if (dirty[0] & /*features*/
      8) classiccontrols_changes.params = { item: (
        /*item*/
        ctx2[31]
      ) };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot_1$u(ctx) {
  let itemtablecell;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_6$e] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*section*/
    ctx[25].hasActions && create_if_block_13$3(ctx)
  );
  let if_block1 = (
    /*section*/
    ctx[25].dataset.type === "loot" && create_if_block_12$3(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[4].editable && /*$context*/
    ctx[4].useClassicControls && create_if_block_11$3(ctx)
  );
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty[0] & /*$context, features*/
      24 | dirty[1] & /*$$scope, toggleSummary*/
      272) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
      if (
        /*section*/
        ctx2[25].hasActions
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*features*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[25].dataset.type === "loot"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*features*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12$3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[4].editable && /*$context*/
        ctx2[4].useClassicControls
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*$context*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_11$3(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block2_anchor);
      }
      destroy_component(itemtablecell, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_if_block_10$4(ctx) {
  let inlinecontainerview;
  let current;
  inlinecontainerview = new InlineContainerView({
    props: {
      container: (
        /*item*/
        ctx[31]
      ),
      containerContents: (
        /*ctx*/
        ctx[32].containerContents
      ),
      editable: (
        /*$context*/
        ctx[4].editable
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[14]
      ),
      lockItemQuantity: (
        /*$context*/
        ctx[4].lockItemQuantity
      ),
      sheetDocument: (
        /*$context*/
        ctx[4].actor
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainerview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainerview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainerview_changes = {};
      if (dirty[0] & /*features*/
      8) inlinecontainerview_changes.container = /*item*/
      ctx2[31];
      if (dirty[0] & /*$context, features*/
      24) inlinecontainerview_changes.containerContents = /*ctx*/
      ctx2[32].containerContents;
      if (dirty[0] & /*$context*/
      16) inlinecontainerview_changes.editable = /*$context*/
      ctx2[4].editable;
      if (dirty[0] & /*$context*/
      16) inlinecontainerview_changes.lockItemQuantity = /*$context*/
      ctx2[4].lockItemQuantity;
      if (dirty[0] & /*$context*/
      16) inlinecontainerview_changes.sheetDocument = /*$context*/
      ctx2[4].actor;
      inlinecontainerview.$set(inlinecontainerview_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainerview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainerview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainerview, detaching);
    }
  };
}
function create_each_block_2$5(ctx) {
  let itemtablerow;
  let t2;
  let if_block_anchor;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[21](
        /*item*/
        ctx[31],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[31].uuid
        )
      },
      item: (
        /*item*/
        ctx[31]
      ),
      cssClass: FoundryAdapter.getInventoryRowClasses(
        /*item*/
        ctx[31],
        /*ctx*/
        ctx[32]
      ),
      hidden: !!/*$itemIdsToShow*/
      ctx[11] && !/*$itemIdsToShow*/
      ctx[11].has(
        /*item*/
        ctx[31].id
      ),
      $$slots: {
        default: [
          create_default_slot_1$u,
          ({ toggleSummary }) => ({ 35: toggleSummary }),
          ({ toggleSummary }) => [0, toggleSummary ? 16 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  let if_block = "containerContents" in /*ctx*/
  ctx[32] && !!/*ctx*/
  ctx[32].containerContents && create_if_block_10$4(ctx);
  return {
    c() {
      create_component(itemtablerow.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablerow, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty[0] & /*features*/
      8) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[31].uuid
        )
      };
      if (dirty[0] & /*features*/
      8) itemtablerow_changes.item = /*item*/
      ctx[31];
      if (dirty[0] & /*features, $context*/
      24) itemtablerow_changes.cssClass = FoundryAdapter.getInventoryRowClasses(
        /*item*/
        ctx[31],
        /*ctx*/
        ctx[32]
      );
      if (dirty[0] & /*$itemIdsToShow, features*/
      2056) itemtablerow_changes.hidden = !!/*$itemIdsToShow*/
      ctx[11] && !/*$itemIdsToShow*/
      ctx[11].has(
        /*item*/
        ctx[31].id
      );
      if (dirty[0] & /*classicControlsColumnWidth, controls, features, $context*/
      282 | dirty[1] & /*$$scope, toggleSummary*/
      272) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
      if ("containerContents" in /*ctx*/
      ctx[32] && !!/*ctx*/
      ctx[32].containerContents) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*$context, features*/
          24) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_10$4(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablerow, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_9$6(ctx) {
  let itemtablefooter;
  let current;
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[4].actor
      ),
      section: (
        /*section*/
        ctx[25]
      ),
      isItem: true
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablefooter_changes = {};
      if (dirty[0] & /*$context*/
      16) itemtablefooter_changes.actor = /*$context*/
      ctx2[4].actor;
      if (dirty[0] & /*features*/
      8) itemtablefooter_changes.section = /*section*/
      ctx2[25];
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$7(ctx) {
  let t2;
  let if_block_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*section*/
    ctx[25].items
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$5(get_each_context_2$5(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = (
    /*$context*/
    ctx[4].unlocked && /*section*/
    ctx[25].dataset && create_if_block_9$6(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*features, $context, inlineContainerToggleService, $itemIdsToShow, classicControlsColumnWidth, controls, localize*/
      149786 | dirty[1] & /*toggleSummary*/
      16) {
        each_value_2 = ensure_array_like(
          /*section*/
          ctx2[25].items
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$5(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (
        /*$context*/
        ctx2[4].unlocked && /*section*/
        ctx2[25].dataset
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$context, features*/
          24) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_9$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_each_block_1$e(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[25].show && create_if_block_7$9(get_if_ctx$7(ctx))
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*section*/
        ctx[25].show
      ) {
        if (if_block) {
          if_block.p(get_if_ctx$7(ctx), dirty);
          if (dirty[0] & /*features*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7$9(get_if_ctx$7(ctx));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_1$G(ctx) {
  let current_block_type_index;
  let if_block0;
  let t0;
  let div;
  let current_block_type_index_1;
  let if_block1;
  let t1;
  let spellbookfooter;
  let current;
  const if_block_creators = [create_if_block_5$e, create_else_block_3$2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*noSpellLevels*/
      ctx2[10]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block_2$w, create_else_block$F];
  const if_blocks_1 = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*noSpellLevels*/
      ctx2[10]
    ) return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_3(ctx);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  spellbookfooter = new SpellbookFooter({
    props: {
      includeAttackMod: false,
      includePreparedSpells: false,
      cssClass: "npc-abilities-spellbook-footer"
    }
  });
  return {
    c() {
      if_block0.c();
      t0 = space();
      div = element("div");
      if_block1.c();
      t1 = space();
      create_component(spellbookfooter.$$.fragment);
      attr(div, "class", "flex-1 flex-column small-padding-bottom no-gap");
      toggle_class(
        div,
        "hidden",
        /*noSpellLevels*/
        ctx[10] && !/*showNoSpellsView*/
        ctx[7]
      );
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if_blocks_1[current_block_type_index_1].m(div, null);
      append(div, t1);
      mount_component(spellbookfooter, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t0.parentNode, t0);
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_3(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      if (!current || dirty[0] & /*noSpellLevels, showNoSpellsView*/
      1152) {
        toggle_class(
          div,
          "hidden",
          /*noSpellLevels*/
          ctx2[10] && !/*showNoSpellsView*/
          ctx2[7]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(spellbookfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(spellbookfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
      if_blocks[current_block_type_index].d(detaching);
      if_blocks_1[current_block_type_index_1].d();
      destroy_component(spellbookfooter);
    }
  };
}
function create_else_block_3$2(ctx) {
  let h2;
  let span0;
  let t1;
  let span1;
  let itemfilterlayouttoggle;
  let t2;
  let itemcontrol;
  let current;
  itemfilterlayouttoggle = new ItemFilterLayoutToggle({
    props: {
      mode: (
        /*layoutMode*/
        ctx[6]
      ),
      element: "span"
    }
  });
  itemfilterlayouttoggle.$on(
    "toggle",
    /*toggle_handler_1*/
    ctx[23]
  );
  itemcontrol = new ItemControl({
    props: {
      iconCssClass: "fas fa-cog",
      title: "TIDY5E.Utilities.ConfigureSections",
      onclick: (
        /*func*/
        ctx[24]
      )
    }
  });
  return {
    c() {
      h2 = element("h2");
      span0 = element("span");
      span0.textContent = `${/*localize*/
      ctx[17]("DND5E.Spellbook")}`;
      t1 = space();
      span1 = element("span");
      create_component(itemfilterlayouttoggle.$$.fragment);
      t2 = space();
      create_component(itemcontrol.$$.fragment);
      attr(span1, "class", "flex-row extra-small-gap");
      attr(h2, "class", "spellbook-title svelte-m1az87");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, span0);
      append(h2, t1);
      append(h2, span1);
      mount_component(itemfilterlayouttoggle, span1, null);
      append(span1, t2);
      mount_component(itemcontrol, span1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const itemfilterlayouttoggle_changes = {};
      if (dirty[0] & /*layoutMode*/
      64) itemfilterlayouttoggle_changes.mode = /*layoutMode*/
      ctx2[6];
      itemfilterlayouttoggle.$set(itemfilterlayouttoggle_changes);
      const itemcontrol_changes = {};
      if (dirty[0] & /*$context*/
      16) itemcontrol_changes.onclick = /*func*/
      ctx2[24];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemfilterlayouttoggle.$$.fragment, local);
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemfilterlayouttoggle.$$.fragment, local);
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
      destroy_component(itemfilterlayouttoggle);
      destroy_component(itemcontrol);
    }
  };
}
function create_if_block_5$e(ctx) {
  let h2;
  let button;
  let t0_value = (
    /*localize*/
    ctx[17]("DND5E.Spellbook") + ""
  );
  let t0;
  let t1;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*showNoSpellsView*/
      ctx2[7]
    ) return create_if_block_6$b;
    return create_else_block_2$2;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      h2 = element("h2");
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      if_block.c();
      attr(button, "type", "button");
      attr(button, "class", "transparent-button spellbook-title toggle-spellbook svelte-m1az87");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, button);
      append(button, t0);
      append(button, t1);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[22]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_2(ctx2))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_2$2(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-caret-down");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_6$b(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-caret-up");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_else_block$F(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*spellbook*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[25].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$t(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$t(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "flex-1 small-padding-bottom flex-column small-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*spellbook, layoutMode*/
      68) {
        each_value = ensure_array_like(
          /*spellbook*/
          ctx2[2]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$t, null, get_each_context$t);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_if_block_2$w(ctx) {
  let nospells;
  let current;
  nospells = new NoSpells({
    props: {
      cssClass: "flex-1",
      editable: (
        /*$context*/
        ctx[4].unlocked
      )
    }
  });
  return {
    c() {
      create_component(nospells.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nospells, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const nospells_changes = {};
      if (dirty[0] & /*$context*/
      16) nospells_changes.editable = /*$context*/
      ctx2[4].unlocked;
      nospells.$set(nospells_changes);
    },
    i(local) {
      if (current) return;
      transition_in(nospells.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nospells.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nospells, detaching);
    }
  };
}
function create_if_block_3$p(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$h, create_else_block_1$9];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*layoutMode*/
      ctx2[6] === "list"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_1$9(ctx) {
  let spellbookgrid;
  let current;
  spellbookgrid = new SpellbookGrid({
    props: {
      spells: (
        /*section*/
        ctx[25].spells
      ),
      section: (
        /*section*/
        ctx[25]
      )
    }
  });
  return {
    c() {
      create_component(spellbookgrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellbookgrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellbookgrid_changes = {};
      if (dirty[0] & /*spellbook*/
      4) spellbookgrid_changes.spells = /*section*/
      ctx2[25].spells;
      if (dirty[0] & /*spellbook*/
      4) spellbookgrid_changes.section = /*section*/
      ctx2[25];
      spellbookgrid.$set(spellbookgrid_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellbookgrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellbookgrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellbookgrid, detaching);
    }
  };
}
function create_if_block_4$h(ctx) {
  let spellbooklist;
  let current;
  spellbooklist = new SpellbookList({
    props: {
      spells: (
        /*section*/
        ctx[25].spells
      ),
      section: (
        /*section*/
        ctx[25]
      ),
      allowFavorites: false,
      includeRange: false,
      includeSchool: false,
      spellComponentsBaseWidth: "3.125rem",
      targetBaseWidth: "5.625rem",
      usageBaseWidth: "5.625rem"
    }
  });
  return {
    c() {
      create_component(spellbooklist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellbooklist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellbooklist_changes = {};
      if (dirty[0] & /*spellbook*/
      4) spellbooklist_changes.spells = /*section*/
      ctx2[25].spells;
      if (dirty[0] & /*spellbook*/
      4) spellbooklist_changes.section = /*section*/
      ctx2[25];
      spellbooklist.$set(spellbooklist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellbooklist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellbooklist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellbooklist, detaching);
    }
  };
}
function create_each_block$t(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[25].show && create_if_block_3$p(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*section*/
        ctx[25].show
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*spellbook*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$p(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block$12(ctx) {
  let encumbrancebar;
  let current;
  encumbrancebar = new EncumbranceBar({});
  return {
    c() {
      create_component(encumbrancebar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(encumbrancebar, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(encumbrancebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(encumbrancebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(encumbrancebar, detaching);
    }
  };
}
function create_default_slot$_(ctx) {
  let currency;
  let t2;
  let if_block_anchor;
  let current;
  currency = new Currency({
    props: { document: (
      /*$context*/
      ctx[4].actor
    ) }
  });
  let if_block = (
    /*$settingStore*/
    ctx[5].useNpcEncumbranceBar && create_if_block$12()
  );
  return {
    c() {
      create_component(currency.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(currency, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const currency_changes = {};
      if (dirty[0] & /*$context*/
      16) currency_changes.document = /*$context*/
      ctx2[4].actor;
      currency.$set(currency_changes);
      if (
        /*$settingStore*/
        ctx2[5].useNpcEncumbranceBar
      ) {
        if (if_block) {
          if (dirty[0] & /*$settingStore*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$12();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(currency.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(currency.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(currency, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$2e(ctx) {
  let utilitytoolbar;
  let t0;
  let section_1;
  let div0;
  let skillslist;
  let t1;
  let t2;
  let div1;
  let expandablecontainer;
  let t3;
  let t4;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t5;
  let t6;
  let tabfooter;
  let current;
  utilitytoolbar = new UtilityToolbar({
    props: {
      class: "abilities-toolbar",
      $$slots: { default: [create_default_slot_14$4] },
      $$scope: { ctx }
    }
  });
  skillslist = new SkillsList({
    props: {
      actor: (
        /*$context*/
        ctx[4].actor
      ),
      toggleable: !/*$settingStore*/
      ctx[5].alwaysShowNpcSkills,
      expanded: !!TidyFlags.skillsExpanded.get(
        /*$context*/
        ctx[4].actor
      ),
      toggleField: TidyFlags.skillsExpanded.prop
    }
  });
  let if_block0 = !/*$settingStore*/
  ctx[5].moveTraitsBelowNpcResources && create_if_block_27(ctx);
  expandablecontainer = new ExpandableContainer({
    props: {
      expanded: (
        /*$context*/
        ctx[4].showLegendaryToolbar
      ),
      class: "legendary-wrapper " + /*$context*/
      (ctx[4].showLegendaryToolbar ? "legendary-expanded" : ""),
      $$slots: { default: [create_default_slot_13$6] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$settingStore*/
    ctx[5].moveTraitsBelowNpcResources && create_if_block_26(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*features*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[25].key
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$e(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$e(key, child_ctx));
  }
  let if_block2 = !/*$settingStore*/
  ctx[5].showSpellbookTabNpc && create_if_block_1$G(ctx);
  tabfooter = new TabFooter({
    props: {
      mode: "vertical",
      cssClass: "abilities-footer",
      $$slots: { default: [create_default_slot$_] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(utilitytoolbar.$$.fragment);
      t0 = space();
      section_1 = element("section");
      div0 = element("div");
      create_component(skillslist.$$.fragment);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      div1 = element("div");
      create_component(expandablecontainer.$$.fragment);
      t3 = space();
      if (if_block1) if_block1.c();
      t4 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t5 = space();
      if (if_block2) if_block2.c();
      t6 = space();
      create_component(tabfooter.$$.fragment);
      attr(div0, "class", "side-panel svelte-m1az87");
      attr(div1, "class", "main-panel svelte-m1az87");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NPC_ABILITIES_CONTAINER);
      attr(section_1, "class", "npc-abilities-content svelte-m1az87");
      attr(section_1, "data-tidy-track-scroll-y", "");
    },
    m(target, anchor) {
      mount_component(utilitytoolbar, target, anchor);
      insert(target, t0, anchor);
      insert(target, section_1, anchor);
      append(section_1, div0);
      mount_component(skillslist, div0, null);
      append(div0, t1);
      if (if_block0) if_block0.m(div0, null);
      append(section_1, t2);
      append(section_1, div1);
      mount_component(expandablecontainer, div1, null);
      append(div1, t3);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t4);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t5);
      if (if_block2) if_block2.m(div1, null);
      insert(target, t6, anchor);
      mount_component(tabfooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const utilitytoolbar_changes = {};
      if (dirty[0] & /*utilityBarCommands, $context, searchCriteria*/
      529 | dirty[1] & /*$$scope*/
      256) {
        utilitytoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      utilitytoolbar.$set(utilitytoolbar_changes);
      const skillslist_changes = {};
      if (dirty[0] & /*$context*/
      16) skillslist_changes.actor = /*$context*/
      ctx2[4].actor;
      if (dirty[0] & /*$settingStore*/
      32) skillslist_changes.toggleable = !/*$settingStore*/
      ctx2[5].alwaysShowNpcSkills;
      if (dirty[0] & /*$context*/
      16) skillslist_changes.expanded = !!TidyFlags.skillsExpanded.get(
        /*$context*/
        ctx2[4].actor
      );
      skillslist.$set(skillslist_changes);
      if (!/*$settingStore*/
      ctx2[5].moveTraitsBelowNpcResources) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$settingStore*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_27(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const expandablecontainer_changes = {};
      if (dirty[0] & /*$context*/
      16) expandablecontainer_changes.expanded = /*$context*/
      ctx2[4].showLegendaryToolbar;
      if (dirty[0] & /*$context*/
      16) expandablecontainer_changes.class = "legendary-wrapper " + /*$context*/
      (ctx2[4].showLegendaryToolbar ? "legendary-expanded" : "");
      if (dirty[1] & /*$$scope*/
      256) {
        expandablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandablecontainer.$set(expandablecontainer_changes);
      if (
        /*$settingStore*/
        ctx2[5].moveTraitsBelowNpcResources
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$settingStore*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_26(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*features, $context, inlineContainerToggleService, $itemIdsToShow, classicControlsColumnWidth, controls, localize*/
      149786 | dirty[1] & /*toggleSummary*/
      16) {
        each_value_1 = ensure_array_like(
          /*features*/
          ctx2[3]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div1, outro_and_destroy_block, create_each_block_1$e, t5, get_each_context_1$e);
        check_outros();
      }
      if (!/*$settingStore*/
      ctx2[5].showSpellbookTabNpc) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*$settingStore*/
          32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$G(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const tabfooter_changes = {};
      if (dirty[0] & /*$settingStore, $context*/
      48 | dirty[1] & /*$$scope*/
      256) {
        tabfooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabfooter.$set(tabfooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbar.$$.fragment, local);
      transition_in(skillslist.$$.fragment, local);
      transition_in(if_block0);
      transition_in(expandablecontainer.$$.fragment, local);
      transition_in(if_block1);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block2);
      transition_in(tabfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbar.$$.fragment, local);
      transition_out(skillslist.$$.fragment, local);
      transition_out(if_block0);
      transition_out(expandablecontainer.$$.fragment, local);
      transition_out(if_block1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block2);
      transition_out(tabfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(section_1);
        detach(t6);
      }
      destroy_component(utilitytoolbar, detaching);
      destroy_component(skillslist);
      if (if_block0) if_block0.d();
      destroy_component(expandablecontainer);
      if (if_block1) if_block1.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block2) if_block2.d();
      destroy_component(tabfooter, detaching);
    }
  };
}
let classicControlsIconWidth$4 = 1.25;
function instance$2e($$self, $$props, $$invalidate) {
  let noSpellLevels;
  let utilityBarCommands;
  let features;
  let spellbook;
  let classicControlsColumnWidth;
  let $context;
  let $itemIdsToShow;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(4, $context = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  let inlineContainerToggleService = getContext(CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE);
  let searchCriteria = "";
  const itemIdsToShow = writable(void 0);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(11, $itemIdsToShow = value));
  setContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW, itemIdsToShow);
  function toggleLayout() {
    if (layoutMode === "grid") {
      TidyFlags.spellbookGrid.unset($context.actor);
      return;
    }
    TidyFlags.spellbookGrid.set($context.actor);
  }
  let layoutMode;
  let showNoSpellsView = false;
  const localize = FoundryAdapter.localize;
  declareLocation("abilities");
  let controls = [];
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(0, searchCriteria);
  }
  const execute_handler = (command, ev) => command.execute?.(ev.detail);
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (item, event) => FoundryAdapter.editOnMiddleClick(event.detail, item);
  const click_handler = () => $$invalidate(7, showNoSpellsView = !showNoSpellsView);
  const toggle_handler_1 = () => toggleLayout();
  const func2 = () => new DocumentTabSectionConfigApplication({
    document: $context.actor,
    sections: $context.spellbook,
    tabId: CONSTANTS.TAB_NPC_SPELLBOOK,
    tabTitle: NpcSheetRuntime.getTabTitle(CONSTANTS.TAB_NPC_SPELLBOOK)
  }).render(true);
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$context*/
    16) {
      $$invalidate(10, noSpellLevels = !$context.spellbook.length);
    }
    if ($$self.$$.dirty[0] & /*$context*/
    16) {
      $$invalidate(9, utilityBarCommands = $context.utilities[tabId]?.utilityToolbarCommands ?? []);
    }
    if ($$self.$$.dirty[0] & /*$context*/
    16) {
      $$invalidate(3, features = SheetSections.configureFeatures($context.features, $context, tabId, SheetPreferencesService.getByType($context.actor.type), TidyFlags.sectionConfig.get($context.actor)?.[tabId]));
    }
    if ($$self.$$.dirty[0] & /*$settingStore, $context*/
    48) {
      $$invalidate(2, spellbook = !$settingStore.showSpellbookTabNpc ? SheetSections.configureSpellbook($context.actor, tabId, $context.spellbook) : []);
    }
    if ($$self.$$.dirty[0] & /*searchCriteria, $context, features, spellbook*/
    29) {
      {
        set_store_value(
          itemIdsToShow,
          $itemIdsToShow = ItemVisibility.getItemsToShowAtDepth({
            criteria: searchCriteria,
            itemContext: $context.itemContext,
            sections: [...features, ...spellbook],
            tabId
          }),
          $itemIdsToShow
        );
      }
    }
    if ($$self.$$.dirty[0] & /*$context*/
    16) {
      $$invalidate(6, layoutMode = TidyFlags.spellbookGrid.get($context.actor) ? "grid" : "list");
    }
    if ($$self.$$.dirty[0] & /*$context, controls*/
    18) {
      {
        $$invalidate(1, controls = [
          {
            component: ItemEditControl,
            props: ({ item }) => ({ item })
          }
        ]);
        if ($context.unlocked) {
          controls.push({
            component: ItemDeleteControl,
            props: ({ item }) => ({ item })
          });
        }
        if ($context.useActionsFeature) {
          controls.push({
            component: ActionFilterOverrideControl,
            props: ({ item }) => ({ item })
          });
        }
      }
    }
    if ($$self.$$.dirty[0] & /*controls*/
    2) {
      $$invalidate(8, classicControlsColumnWidth = `${classicControlsIconWidth$4 * controls.length}rem`);
    }
  };
  return [
    searchCriteria,
    controls,
    spellbook,
    features,
    $context,
    $settingStore,
    layoutMode,
    showNoSpellsView,
    classicControlsColumnWidth,
    utilityBarCommands,
    noSpellLevels,
    $itemIdsToShow,
    context,
    tabId,
    inlineContainerToggleService,
    itemIdsToShow,
    toggleLayout,
    localize,
    search_value_binding,
    execute_handler,
    toggle_handler,
    mousedown_handler,
    click_handler,
    toggle_handler_1,
    func2
  ];
}
class NpcAbilitiesTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2e, create_fragment$2e, safe_not_equal, {}, null, [-1, -1]);
  }
}
function get_each_context$s(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function get_if_ctx$6(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = ItemVisibility.countVisibleItems(
    /*section*/
    child_ctx[14].spells,
    /*$itemIdsToShow*/
    child_ctx[6]
  );
  child_ctx[17] = constants_0;
  return child_ctx;
}
function get_each_context_1$d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function create_default_slot_2$o(ctx) {
  let t_value = (
    /*localize*/
    ctx[10]("TIDY5E.Utilities.AssignSpellsToClasses") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$t(ctx) {
  let buttonmenucommand;
  let current;
  buttonmenucommand = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-list-check",
      disabled: !/*$context*/
      ctx[2].editable,
      $$slots: { default: [create_default_slot_2$o] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand.$on(
    "click",
    /*click_handler*/
    ctx[12]
  );
  return {
    c() {
      create_component(buttonmenucommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenucommand, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const buttonmenucommand_changes = {};
      if (dirty & /*$context*/
      4) buttonmenucommand_changes.disabled = !/*$context*/
      ctx2[2].editable;
      if (dirty & /*$$scope*/
      2097152) {
        buttonmenucommand_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand.$set(buttonmenucommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenucommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenucommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenucommand, detaching);
    }
  };
}
function create_each_block_1$d(key_1, ctx) {
  let first;
  let utilitytoolbarcommand;
  let current;
  function execute_handler(...args) {
    return (
      /*execute_handler*/
      ctx[13](
        /*command*/
        ctx[18],
        ...args
      )
    );
  }
  utilitytoolbarcommand = new UtilityToolbarCommand({
    props: {
      title: (
        /*command*/
        ctx[18].title
      ),
      iconClass: (
        /*command*/
        ctx[18].iconClass
      ),
      text: (
        /*command*/
        ctx[18].text
      ),
      visible: (
        /*command*/
        ctx[18].visible ?? true
      )
    }
  });
  utilitytoolbarcommand.$on("execute", execute_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(utilitytoolbarcommand.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(utilitytoolbarcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const utilitytoolbarcommand_changes = {};
      if (dirty & /*utilityBarCommands*/
      16) utilitytoolbarcommand_changes.title = /*command*/
      ctx[18].title;
      if (dirty & /*utilityBarCommands*/
      16) utilitytoolbarcommand_changes.iconClass = /*command*/
      ctx[18].iconClass;
      if (dirty & /*utilityBarCommands*/
      16) utilitytoolbarcommand_changes.text = /*command*/
      ctx[18].text;
      if (dirty & /*utilityBarCommands*/
      16) utilitytoolbarcommand_changes.visible = /*command*/
      ctx[18].visible ?? true;
      utilitytoolbarcommand.$set(utilitytoolbarcommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbarcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbarcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(utilitytoolbarcommand, detaching);
    }
  };
}
function create_default_slot$Z(ctx) {
  let search;
  let updating_value;
  let t0;
  let pinnedfiltertoggles;
  let t1;
  let filtermenu;
  let t2;
  let buttonmenu;
  let t3;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  function search_value_binding(value) {
    ctx[11](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[0] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[0];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  pinnedfiltertoggles = new PinnedFilterToggles({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[8]
      ),
      filters: ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx[2].filterPins,
        /*$context*/
        ctx[2].filterData,
        /*tabId*/
        ctx[8]
      )
    }
  });
  filtermenu = new FilterMenu({ props: { tabId: (
    /*tabId*/
    ctx[8]
  ) } });
  buttonmenu = new ButtonMenu({
    props: {
      iconClass: "ra ra-fairy-wand",
      buttonClass: "inline-icon-button",
      position: "bottom",
      anchor: "right",
      title: (
        /*localize*/
        ctx[10]("TIDY5E.Utilities.Tools")
      ),
      menuElement: "div",
      $$slots: { default: [create_default_slot_1$t] },
      $$scope: { ctx }
    }
  });
  let each_value_1 = ensure_array_like(
    /*utilityBarCommands*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[18].title
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$d(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$d(key, child_ctx));
  }
  return {
    c() {
      create_component(search.$$.fragment);
      t0 = space();
      create_component(pinnedfiltertoggles.$$.fragment);
      t1 = space();
      create_component(filtermenu.$$.fragment);
      t2 = space();
      create_component(buttonmenu.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      insert(target, t0, anchor);
      mount_component(pinnedfiltertoggles, target, anchor);
      insert(target, t1, anchor);
      mount_component(filtermenu, target, anchor);
      insert(target, t2, anchor);
      mount_component(buttonmenu, target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_changes = {};
      if (!updating_value && dirty & /*searchCriteria*/
      1) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      const pinnedfiltertoggles_changes = {};
      if (dirty & /*$context*/
      4) pinnedfiltertoggles_changes.filters = ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx2[2].filterPins,
        /*$context*/
        ctx2[2].filterData,
        /*tabId*/
        ctx2[8]
      );
      pinnedfiltertoggles.$set(pinnedfiltertoggles_changes);
      const buttonmenu_changes = {};
      if (dirty & /*$$scope, $context*/
      2097156) {
        buttonmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenu.$set(buttonmenu_changes);
      if (dirty & /*utilityBarCommands*/
      16) {
        each_value_1 = ensure_array_like(
          /*utilityBarCommands*/
          ctx2[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$d, each_1_anchor, get_each_context_1$d);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(pinnedfiltertoggles.$$.fragment, local);
      transition_in(filtermenu.$$.fragment, local);
      transition_in(buttonmenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(pinnedfiltertoggles.$$.fragment, local);
      transition_out(filtermenu.$$.fragment, local);
      transition_out(buttonmenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(each_1_anchor);
      }
      destroy_component(search, detaching);
      destroy_component(pinnedfiltertoggles, detaching);
      destroy_component(filtermenu, detaching);
      destroy_component(buttonmenu, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_else_block$E(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*spellbook*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[14].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$s(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$s(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*spellbook, layoutMode, searchCriteria, $context, $itemIdsToShow*/
      79) {
        each_value = ensure_array_like(
          /*spellbook*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$s, each_1_anchor, get_each_context$s);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block$11(ctx) {
  let nospells;
  let current;
  nospells = new NoSpells({
    props: { editable: (
      /*$context*/
      ctx[2].unlocked
    ) }
  });
  return {
    c() {
      create_component(nospells.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nospells, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const nospells_changes = {};
      if (dirty & /*$context*/
      4) nospells_changes.editable = /*$context*/
      ctx2[2].unlocked;
      nospells.$set(nospells_changes);
    },
    i(local) {
      if (current) return;
      transition_in(nospells.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nospells.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nospells, detaching);
    }
  };
}
function create_if_block_1$F(ctx) {
  let show_if = (
    /*searchCriteria*/
    ctx[0].trim() === "" && /*$context*/
    ctx[2].unlocked || /*visibleItemCount*/
    ctx[17] > 0 || !!/*section*/
    ctx[14].slots
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_2$v(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*searchCriteria, $context, spellbook, $itemIdsToShow*/
      71) show_if = /*searchCriteria*/
      ctx2[0].trim() === "" && /*$context*/
      ctx2[2].unlocked || /*visibleItemCount*/
      ctx2[17] > 0 || !!/*section*/
      ctx2[14].slots;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*searchCriteria, $context, spellbook, $itemIdsToShow*/
          71) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$v(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_2$v(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$o, create_else_block_1$8];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*layoutMode*/
      ctx2[3] === "list"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_1$8(ctx) {
  let spellbookgrid;
  let current;
  spellbookgrid = new SpellbookGrid({
    props: {
      spells: (
        /*section*/
        ctx[14].spells
      ),
      section: (
        /*section*/
        ctx[14]
      )
    }
  });
  return {
    c() {
      create_component(spellbookgrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellbookgrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellbookgrid_changes = {};
      if (dirty & /*spellbook*/
      2) spellbookgrid_changes.spells = /*section*/
      ctx2[14].spells;
      if (dirty & /*spellbook*/
      2) spellbookgrid_changes.section = /*section*/
      ctx2[14];
      spellbookgrid.$set(spellbookgrid_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellbookgrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellbookgrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellbookgrid, detaching);
    }
  };
}
function create_if_block_3$o(ctx) {
  let spellbooklist;
  let current;
  spellbooklist = new SpellbookList({
    props: {
      allowFavorites: false,
      spells: (
        /*section*/
        ctx[14].spells
      ),
      section: (
        /*section*/
        ctx[14]
      )
    }
  });
  return {
    c() {
      create_component(spellbooklist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spellbooklist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const spellbooklist_changes = {};
      if (dirty & /*spellbook*/
      2) spellbooklist_changes.spells = /*section*/
      ctx2[14].spells;
      if (dirty & /*spellbook*/
      2) spellbooklist_changes.section = /*section*/
      ctx2[14];
      spellbooklist.$set(spellbooklist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(spellbooklist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spellbooklist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spellbooklist, detaching);
    }
  };
}
function create_each_block$s(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*section*/
    ctx[14].show && create_if_block_1$F(get_if_ctx$6(ctx))
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*section*/
        ctx[14].show
      ) {
        if (if_block) {
          if_block.p(get_if_ctx$6(ctx), dirty);
          if (dirty & /*spellbook*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$F(get_if_ctx$6(ctx));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$2d(ctx) {
  let utilitytoolbar;
  let t0;
  let div;
  let current_block_type_index;
  let if_block;
  let t1;
  let spellbookfooter;
  let current;
  utilitytoolbar = new UtilityToolbar({
    props: {
      $$slots: { default: [create_default_slot$Z] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block$11, create_else_block$E];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noSpellLevels*/
      ctx2[5]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  spellbookfooter = new SpellbookFooter({});
  return {
    c() {
      create_component(utilitytoolbar.$$.fragment);
      t0 = space();
      div = element("div");
      if_block.c();
      t1 = space();
      create_component(spellbookfooter.$$.fragment);
      attr(div, "class", "scroll-container flex-column small-gap");
    },
    m(target, anchor) {
      mount_component(utilitytoolbar, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      insert(target, t1, anchor);
      mount_component(spellbookfooter, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const utilitytoolbar_changes = {};
      if (dirty & /*$$scope, utilityBarCommands, $context, searchCriteria*/
      2097173) {
        utilitytoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      utilitytoolbar.$set(utilitytoolbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbar.$$.fragment, local);
      transition_in(if_block);
      transition_in(spellbookfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbar.$$.fragment, local);
      transition_out(if_block);
      transition_out(spellbookfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t1);
      }
      destroy_component(utilitytoolbar, detaching);
      if_blocks[current_block_type_index].d();
      destroy_component(spellbookfooter, detaching);
    }
  };
}
function instance$2d($$self, $$props, $$invalidate) {
  let spellbook;
  let noSpellLevels;
  let utilityBarCommands;
  let $context;
  let $itemIdsToShow;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  let searchCriteria = "";
  const itemIdsToShow = writable(void 0);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(6, $itemIdsToShow = value));
  setContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW, itemIdsToShow);
  let layoutMode;
  const localize = FoundryAdapter.localize;
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(0, searchCriteria);
  }
  const click_handler = () => {
    new SpellSourceClassAssignmentsFormApplication($context.actor).render(true);
  };
  const execute_handler = (command, ev) => command.execute?.(ev.detail);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(1, spellbook = SheetSections.configureSpellbook($context.actor, tabId, $context.spellbook));
    }
    if ($$self.$$.dirty & /*searchCriteria, $context, spellbook*/
    7) {
      {
        set_store_value(
          itemIdsToShow,
          $itemIdsToShow = ItemVisibility.getItemsToShowAtDepth({
            criteria: searchCriteria,
            itemContext: $context.itemContext,
            sections: spellbook,
            tabId
          }),
          $itemIdsToShow
        );
      }
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(3, layoutMode = TidyFlags.spellbookGrid.get($context.actor) ? "grid" : "list");
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(5, noSpellLevels = !$context.spellbook.length);
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(4, utilityBarCommands = $context.utilities[tabId]?.utilityToolbarCommands ?? []);
    }
  };
  return [
    searchCriteria,
    spellbook,
    $context,
    layoutMode,
    utilityBarCommands,
    noSpellLevels,
    $itemIdsToShow,
    context,
    tabId,
    itemIdsToShow,
    localize,
    search_value_binding,
    click_handler,
    execute_handler
  ];
}
class NpcSpellbookTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2d, create_fragment$2d, safe_not_equal, {});
  }
}
function get_each_context$r(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_each_block$r(key_1, ctx) {
  let li;
  let span;
  let t0_value = (
    /*localize*/
    ctx[5](
      /*bioField*/
      ctx[7].text
    ) + ""
  );
  let t0;
  let t1;
  let t2;
  let contenteditableformfield;
  let t3;
  let current;
  contenteditableformfield = new ContentEditableFormField({
    props: {
      selectOnFocus: true,
      element: "span",
      editable: (
        /*$context*/
        ctx[0].editable && !/*$context*/
        ctx[0].lockSensitiveFields
      ),
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: (
        /*bioField*/
        ctx[7].prop
      ),
      value: (
        /*bioField*/
        ctx[7].value ?? ""
      ),
      cssClass: "detail-input"
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      span = element("span");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      create_component(contenteditableformfield.$$.fragment);
      t3 = space();
      attr(li, "class", "svelte-ui61i9");
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span);
      append(span, t0);
      append(span, t1);
      append(li, t2);
      mount_component(contenteditableformfield, li, null);
      append(li, t3);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*bioFields*/
      2) && t0_value !== (t0_value = /*localize*/
      ctx[5](
        /*bioField*/
        ctx[7].text
      ) + "")) set_data(t0, t0_value);
      const contenteditableformfield_changes = {};
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.editable = /*$context*/
      ctx[0].editable && !/*$context*/
      ctx[0].lockSensitiveFields;
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.document = /*$context*/
      ctx[0].actor;
      if (dirty & /*bioFields*/
      2) contenteditableformfield_changes.field = /*bioField*/
      ctx[7].prop;
      if (dirty & /*bioFields*/
      2) contenteditableformfield_changes.value = /*bioField*/
      ctx[7].value ?? "";
      contenteditableformfield.$set(contenteditableformfield_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contenteditableformfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contenteditableformfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(contenteditableformfield);
    }
  };
}
function create_else_block$D(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-angle-double-right");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_1$E(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-angle-double-left");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block$10(ctx) {
  let div;
  let rerenderafterformsubmission0;
  let t0;
  let rerenderafterformsubmission1;
  let t1;
  let rerenderafterformsubmission2;
  let t2;
  let rerenderafterformsubmission3;
  let current;
  rerenderafterformsubmission0 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: TidyFlags.trait.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      $$slots: { default: [create_default_slot_5$h] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission1 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.ideal
      ),
      $$slots: { default: [create_default_slot_4$k] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission2 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.bond
      ),
      $$slots: { default: [create_default_slot_3$n] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission3 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.flaw
      ),
      $$slots: { default: [create_default_slot_2$n] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(rerenderafterformsubmission0.$$.fragment);
      t0 = space();
      create_component(rerenderafterformsubmission1.$$.fragment);
      t1 = space();
      create_component(rerenderafterformsubmission2.$$.fragment);
      t2 = space();
      create_component(rerenderafterformsubmission3.$$.fragment);
      attr(div, "class", "left-notes note-entries svelte-ui61i9");
      toggle_class(
        div,
        "limited",
        /*$context*/
        ctx[0].showLimitedSheet
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(rerenderafterformsubmission0, div, null);
      append(div, t0);
      mount_component(rerenderafterformsubmission1, div, null);
      append(div, t1);
      mount_component(rerenderafterformsubmission2, div, null);
      append(div, t2);
      mount_component(rerenderafterformsubmission3, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const rerenderafterformsubmission0_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission0_changes.andOnValueChange = TidyFlags.trait.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$$scope, $context*/
      1025) {
        rerenderafterformsubmission0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission0.$set(rerenderafterformsubmission0_changes);
      const rerenderafterformsubmission1_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission1_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.ideal;
      if (dirty & /*$$scope, $context*/
      1025) {
        rerenderafterformsubmission1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission1.$set(rerenderafterformsubmission1_changes);
      const rerenderafterformsubmission2_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission2_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.bond;
      if (dirty & /*$$scope, $context*/
      1025) {
        rerenderafterformsubmission2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission2.$set(rerenderafterformsubmission2_changes);
      const rerenderafterformsubmission3_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission3_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.flaw;
      if (dirty & /*$$scope, $context*/
      1025) {
        rerenderafterformsubmission3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission3.$set(rerenderafterformsubmission3_changes);
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div,
          "limited",
          /*$context*/
          ctx2[0].showLimitedSheet
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(rerenderafterformsubmission0.$$.fragment, local);
      transition_in(rerenderafterformsubmission1.$$.fragment, local);
      transition_in(rerenderafterformsubmission2.$$.fragment, local);
      transition_in(rerenderafterformsubmission3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rerenderafterformsubmission0.$$.fragment, local);
      transition_out(rerenderafterformsubmission1.$$.fragment, local);
      transition_out(rerenderafterformsubmission2.$$.fragment, local);
      transition_out(rerenderafterformsubmission3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(rerenderafterformsubmission0);
      destroy_component(rerenderafterformsubmission1);
      destroy_component(rerenderafterformsubmission2);
      destroy_component(rerenderafterformsubmission3);
    }
  };
}
function create_default_slot_5$h(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].traitEnrichedHtml
      ),
      target: TidyFlags.trait.prop,
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[5]("DND5E.PersonalityTraits")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].traitEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$k(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].idealEnrichedHtml
      ),
      target: "system.details.ideal",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[5]("DND5E.Ideals")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].idealEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$n(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].bondEnrichedHtml
      ),
      target: "system.details.bond",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[5]("DND5E.Bonds")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].bondEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$n(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].flawEnrichedHtml
      ),
      target: "system.details.flaw",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[5]("DND5E.Flaws")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].flawEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$s(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].appearanceEnrichedHtml
      ),
      target: TidyFlags.appearance.prop,
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[5]("DND5E.Appearance")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles biopage");
      attr(article, "class", "appearance-notes");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].appearanceEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$Y(ctx) {
  let article;
  let div;
  let t3;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].biographyEnrichedHtml
      ),
      target: "system.details.biography.value",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[5]("DND5E.Background")}/${/*localize*/
      ctx[5]("DND5E.Biography")}`;
      t3 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles");
      attr(article, "class", "biography-notes");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t3);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].biographyEnrichedHtml;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2c(ctx) {
  let div5;
  let div4;
  let div0;
  let article;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div3;
  let button;
  let button_tabindex_value;
  let t1;
  let div2;
  let t2;
  let div1;
  let rerenderafterformsubmission0;
  let t3;
  let rerenderafterformsubmission1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*bioFields*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*bioField*/
    ctx2[7].prop
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$r(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$r(key, child_ctx));
  }
  function select_block_type(ctx2, dirty) {
    if (
      /*showNpcPersonalityInfo*/
      ctx2[2]
    ) return create_if_block_1$E;
    return create_else_block$D;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*showNpcPersonalityInfo*/
    ctx[2] && create_if_block$10(ctx)
  );
  rerenderafterformsubmission0 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: TidyFlags.appearance.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      $$slots: { default: [create_default_slot_1$s] },
      $$scope: { ctx }
    }
  });
  rerenderafterformsubmission1 = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.biography.value
      ),
      $$slots: { default: [create_default_slot$Y] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      article = element("article");
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div3 = element("div");
      button = element("button");
      if_block0.c();
      t1 = space();
      div2 = element("div");
      if (if_block1) if_block1.c();
      t2 = space();
      div1 = element("div");
      create_component(rerenderafterformsubmission0.$$.fragment);
      t3 = space();
      create_component(rerenderafterformsubmission1.$$.fragment);
      attr(ul, "class", "character-details svelte-ui61i9");
      attr(div0, "class", "top-notes note-entries svelte-ui61i9");
      toggle_class(
        div0,
        "limited",
        /*$context*/
        ctx[0].showLimitedSheet
      );
      attr(button, "type", "button");
      attr(button, "class", "toggle-personality-info svelte-ui61i9");
      attr(
        button,
        "title",
        /*localize*/
        ctx[5]("TIDY5E.TogglePersonalityInfo")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[3].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div1, "class", "right-notes note-entries svelte-ui61i9");
      toggle_class(
        div1,
        "limited",
        /*$context*/
        ctx[0].showLimitedSheet
      );
      attr(div2, "class", "main-notes svelte-ui61i9");
      attr(div3, "class", "flex-row extra-small-gap full-height");
      attr(div4, "class", "notes-container svelte-ui61i9");
      attr(div5, "class", "scroll-container");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div0, article);
      append(article, ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      append(div4, t0);
      append(div4, div3);
      append(div3, button);
      if_block0.m(button, null);
      append(div3, t1);
      append(div3, div2);
      if (if_block1) if_block1.m(div2, null);
      append(div2, t2);
      append(div2, div1);
      mount_component(rerenderafterformsubmission0, div1, null);
      append(div1, t3);
      mount_component(rerenderafterformsubmission1, div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*togglePersonalityInfo*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context, bioFields, localize*/
      35) {
        each_value = ensure_array_like(
          /*bioFields*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$r, null, get_each_context$r);
        check_outros();
      }
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div0,
          "limited",
          /*$context*/
          ctx2[0].showLimitedSheet
        );
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(button, null);
        }
      }
      if (!current || dirty & /*$settingStore*/
      8 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[3].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (
        /*showNpcPersonalityInfo*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showNpcPersonalityInfo*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$10(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const rerenderafterformsubmission0_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission0_changes.andOnValueChange = TidyFlags.appearance.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$$scope, $context*/
      1025) {
        rerenderafterformsubmission0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission0.$set(rerenderafterformsubmission0_changes);
      const rerenderafterformsubmission1_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission1_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.biography.value;
      if (dirty & /*$$scope, $context*/
      1025) {
        rerenderafterformsubmission1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission1.$set(rerenderafterformsubmission1_changes);
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div1,
          "limited",
          /*$context*/
          ctx2[0].showLimitedSheet
        );
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block1);
      transition_in(rerenderafterformsubmission0.$$.fragment, local);
      transition_in(rerenderafterformsubmission1.$$.fragment, local);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block1);
      transition_out(rerenderafterformsubmission0.$$.fragment, local);
      transition_out(rerenderafterformsubmission1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if_block0.d();
      if (if_block1) if_block1.d();
      destroy_component(rerenderafterformsubmission0);
      destroy_component(rerenderafterformsubmission1);
      mounted = false;
      dispose();
    }
  };
}
function instance$2c($$self, $$props, $$invalidate) {
  let showNpcPersonalityInfo;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(3, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function togglePersonalityInfo() {
    TidyFlags.setFlag($context.actor, "showNpcPersonalityInfo", !showNpcPersonalityInfo);
  }
  let bioFields = [];
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, showNpcPersonalityInfo = TidyFlags.showNpcPersonalityInfo.get($context.actor) ?? false);
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, bioFields = [
        {
          prop: TidyFlags.gender.prop,
          value: TidyFlags.gender.get($context.actor),
          text: "DND5E.Gender"
        },
        {
          prop: TidyFlags.age.prop,
          value: TidyFlags.age.get($context.actor),
          text: "DND5E.Age"
        },
        {
          prop: TidyFlags.height.prop,
          value: TidyFlags.height.get($context.actor),
          text: "DND5E.Height"
        },
        {
          prop: TidyFlags.weight.prop,
          value: TidyFlags.weight.get($context.actor),
          text: "DND5E.Weight"
        },
        {
          prop: TidyFlags.eyes.prop,
          value: TidyFlags.eyes.get($context.actor),
          text: "DND5E.Eyes"
        },
        {
          prop: TidyFlags.skin.prop,
          value: TidyFlags.skin.get($context.actor),
          text: "DND5E.Skin"
        },
        {
          prop: TidyFlags.hair.prop,
          value: TidyFlags.hair.get($context.actor),
          text: "DND5E.Hair"
        },
        {
          prop: TidyFlags.faith.prop,
          value: TidyFlags.faith.get($context.actor),
          text: "DND5E.Faith"
        }
      ]);
    }
  };
  return [
    $context,
    bioFields,
    showNpcPersonalityInfo,
    $settingStore,
    context,
    localize,
    togglePersonalityInfo
  ];
}
class NpcBiographyTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2c, create_fragment$2c, safe_not_equal, {});
  }
}
function get_each_context$q(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  return child_ctx;
}
function get_each_context_1$c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function create_if_block_7$8(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot_10$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      65536) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_default_slot_10$9(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("TIDY5E.GMOnlyEdit") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_else_block$C(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*effectSections*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$q(get_each_context$q(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections, $context, classicControlsColumnWidth, controls, localize*/
      79) {
        each_value = ensure_array_like(
          /*effectSections*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$q(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$q(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$D(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot$X] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      65536) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_if_block_2$u(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    (ctx[2].unlocked && /*$context*/
    ctx[2].allowEffectsManagement || /*section*/
    ctx[10].effects.length > 0) && create_if_block_3$n(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[2].unlocked && /*$context*/
        ctx2[2].allowEffectsManagement || /*section*/
        ctx2[10].effects.length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context, effectSections*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$n(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_3$n(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[10].label
      ),
      $$slots: {
        body: [create_body_slot$6],
        header: [create_header_slot$7]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtable_changes = {};
      if (dirty & /*effectSections*/
      2) itemtable_changes.key = /*section*/
      ctx2[10].label;
      if (dirty & /*$$scope, $context, effectSections, classicControlsColumnWidth, controls*/
      65551) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function create_default_slot_9$9(ctx) {
  let t_value = (
    /*localize*/
    ctx[6](
      /*section*/
      ctx[10].label
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[6](
        /*section*/
        ctx2[10].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_8$a(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Source") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7$b(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Duration") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_6$a(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      8) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[3];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_6$d(ctx) {
  let itemtablecolumn0;
  let t0;
  let itemtablecolumn1;
  let t1;
  let itemtablecolumn2;
  let t2;
  let if_block_anchor;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_9$9] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: "12.5rem",
      $$slots: { default: [create_default_slot_8$a] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn2 = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_7$b] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_6$a(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t1 = space();
      create_component(itemtablecolumn2.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope, effectSections*/
      65538) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty & /*$$scope*/
      65536) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
      const itemtablecolumn2_changes = {};
      if (dirty & /*$$scope*/
      65536) {
        itemtablecolumn2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn2.$set(itemtablecolumn2_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6$a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(itemtablecolumn2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(itemtablecolumn2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
      destroy_component(itemtablecolumn2, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_header_slot$7(ctx) {
  let itemtableheaderrow;
  let t2;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_6$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, classicControlsColumnWidth, $context, effectSections*/
      65550) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_default_slot_5$g(ctx) {
  let itemimage;
  let t0;
  let span;
  let t1_value = (
    /*effectContext*/
    ctx[13].name + ""
  );
  let t1;
  let span_data_tidy_effect_name_value;
  let current;
  itemimage = new ItemImage({
    props: { src: (
      /*effectContext*/
      ctx[13].img
    ) }
  });
  return {
    c() {
      create_component(itemimage.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(span, "class", "align-self-center truncate");
      attr(span, "data-tidy-effect-name", span_data_tidy_effect_name_value = /*effectContext*/
      ctx[13].name);
    },
    m(target, anchor) {
      mount_component(itemimage, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const itemimage_changes = {};
      if (dirty & /*effectSections*/
      2) itemimage_changes.src = /*effectContext*/
      ctx2[13].img;
      itemimage.$set(itemimage_changes);
      if ((!current || dirty & /*effectSections*/
      2) && t1_value !== (t1_value = /*effectContext*/
      ctx2[13].name + "")) set_data(t1, t1_value);
      if (!current || dirty & /*effectSections*/
      2 && span_data_tidy_effect_name_value !== (span_data_tidy_effect_name_value = /*effectContext*/
      ctx2[13].name)) {
        attr(span, "data-tidy-effect-name", span_data_tidy_effect_name_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemimage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemimage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      destroy_component(itemimage, detaching);
    }
  };
}
function create_default_slot_4$j(ctx) {
  let t_value = (
    /*effectContext*/
    (ctx[13].source?.name ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*effectContext*/
      (ctx2[13].source?.name ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$m(ctx) {
  let t_value = (
    /*effectContext*/
    (ctx[13].duration?.label ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*effectContext*/
      (ctx2[13].duration?.label ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_5$d(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_2$m] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      8) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[3];
      if (dirty & /*$$scope, controls, effectSections*/
      65539) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_2$m(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[0]
      ),
      params: { effect: (
        /*effectContext*/
        ctx[13]
      ) }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      1) classiccontrols_changes.controls = /*controls*/
      ctx2[0];
      if (dirty & /*effectSections*/
      2) classiccontrols_changes.params = { effect: (
        /*effectContext*/
        ctx2[13]
      ) };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot_1$r(ctx) {
  let itemtablecell0;
  let t0;
  let itemtablecell1;
  let t1;
  let itemtablecell2;
  let t2;
  let if_block_anchor;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      attributes: {
        "data-tidy-effect-name-container": true,
        "data-effect-id": (
          /*effectContext*/
          ctx[13].id
        )
      },
      $$slots: { default: [create_default_slot_5$g] },
      $$scope: { ctx }
    }
  });
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "12.5rem",
      $$slots: { default: [create_default_slot_4$j] },
      $$scope: { ctx }
    }
  });
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_3$m] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_5$d(ctx)
  );
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      create_component(itemtablecell1.$$.fragment);
      t1 = space();
      create_component(itemtablecell2.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*effectSections*/
      2) itemtablecell0_changes.attributes = {
        "data-tidy-effect-name-container": true,
        "data-effect-id": (
          /*effectContext*/
          ctx2[13].id
        )
      };
      if (dirty & /*$$scope, effectSections*/
      65538) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      const itemtablecell1_changes = {};
      if (dirty & /*$$scope, effectSections*/
      65538) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      const itemtablecell2_changes = {};
      if (dirty & /*$$scope, effectSections*/
      65538) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$d(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(itemtablecell2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(itemtablecell2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecell0, detaching);
      destroy_component(itemtablecell1, detaching);
      destroy_component(itemtablecell2, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_each_block_1$c(ctx) {
  let itemtablerow;
  let current;
  function func2() {
    return (
      /*func*/
      ctx[7](
        /*effectContext*/
        ctx[13]
      )
    );
  }
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[8](
        /*effectContext*/
        ctx[13],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS,
        uuid: (
          /*effectContext*/
          ctx[13].uuid
        )
      },
      getDragData: func2,
      effect: (
        /*effectContext*/
        ctx[13]
      ),
      $$slots: { default: [create_default_slot_1$r] },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    c() {
      create_component(itemtablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*effectSections*/
      2) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS,
        uuid: (
          /*effectContext*/
          ctx[13].uuid
        )
      };
      if (dirty & /*$context, effectSections*/
      6) itemtablerow_changes.getDragData = func2;
      if (dirty & /*effectSections*/
      2) itemtablerow_changes.effect = /*effectContext*/
      ctx[13];
      if (dirty & /*$$scope, classicControlsColumnWidth, controls, effectSections, $context*/
      65551) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_if_block_4$g(ctx) {
  let itemtablefooter;
  let current;
  function func_12() {
    return (
      /*func_1*/
      ctx[9](
        /*section*/
        ctx[10]
      )
    );
  }
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[2].actor
      ),
      section: (
        /*section*/
        ctx[10]
      ),
      create: func_12,
      isItem: false
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablefooter_changes = {};
      if (dirty & /*$context*/
      4) itemtablefooter_changes.actor = /*$context*/
      ctx[2].actor;
      if (dirty & /*effectSections*/
      2) itemtablefooter_changes.section = /*section*/
      ctx[10];
      if (dirty & /*effectSections, $context*/
      6) itemtablefooter_changes.create = func_12;
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$6(ctx) {
  let t0;
  let t1;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[10].effects
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$c(get_each_context_1$c(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = (
    /*$context*/
    ctx[2].unlocked && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_4$g(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections, $context, classicControlsColumnWidth, controls*/
      15) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[10].effects
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$c(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$c(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].unlocked && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4$g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_each_block$q(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*section*/
  ctx[10].hidden && create_if_block_2$u(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*section*/
      ctx2[10].hidden) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*effectSections*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$u(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$X(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("TIDY5E.EmptySection") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$$(ctx) {
  let actorconditions;
  let current;
  actorconditions = new ActorConditions({});
  return {
    c() {
      create_component(actorconditions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actorconditions, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(actorconditions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorconditions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actorconditions, detaching);
    }
  };
}
function create_fragment$2b(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let current;
  let if_block0 = !/*$context*/
  ctx[2].allowEffectsManagement && /*$context*/
  ctx[2].unlocked && create_if_block_7$8(ctx);
  const if_block_creators = [create_if_block_1$D, create_else_block$C];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noEffects*/
      ctx2[4] && !/*$context*/
      ctx2[2].unlocked && /*$context*/
      ctx2[2].allowEffectsManagement
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = (
    /*$context*/
    ctx[2].conditions && create_if_block$$()
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      attr(div, "class", "scroll-container flex-column small-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      if (if_block2) if_block2.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*$context*/
      ctx2[2].allowEffectsManagement && /*$context*/
      ctx2[2].unlocked) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7$8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      if (
        /*$context*/
        ctx2[2].conditions
      ) {
        if (if_block2) {
          if (dirty & /*$context*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$$();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if_blocks[current_block_type_index].d();
      if (if_block2) if_block2.d();
    }
  };
}
let classicControlsIconWidth$3 = 1.25;
function instance$2b($$self, $$props, $$invalidate) {
  let effectSections;
  let noEffects;
  let classicControlsColumnWidth;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  const localize = FoundryAdapter.localize;
  declareLocation("effects");
  let controls = [];
  const func2 = (effectContext) => FoundryAdapter.getEffect({
    document: $context.actor,
    effectId: effectContext.id,
    parentId: effectContext.parentId
  })?.toDragData();
  const mousedown_handler = (effectContext, event) => FoundryAdapter.editOnMiddleClick(event.detail, FoundryAdapter.getEffect({
    document: $context.actor,
    effectId: effectContext.id,
    parentId: effectContext.parentId
  }));
  const func_12 = (section) => FoundryAdapter.addEffect(section.type, $context.actor);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(1, effectSections = Object.values($context.effects));
    }
    if ($$self.$$.dirty & /*effectSections*/
    2) {
      $$invalidate(4, noEffects = effectSections.some((section) => section.effects.length > 0) === false);
    }
    if ($$self.$$.dirty & /*controls, $context*/
    5) {
      {
        $$invalidate(0, controls = []);
        controls.push(
          {
            component: ActorEffectToggleControl,
            props: ({ effect }) => ({ effect })
          },
          {
            component: ItemControl,
            props: ({ effect }) => ({
              onclick: () => FoundryAdapter.getEffect({
                document: $context.actor,
                effectId: effect.id,
                parentId: effect.parentId
              }).sheet.render(true),
              title: localize("DND5E.EffectEdit"),
              iconCssClass: "fas fa-edit"
            })
          }
        );
        if ($context.unlocked) {
          controls.push({
            component: ItemControl,
            props: ({ effect }) => ({
              onclick: () => FoundryAdapter.getEffect({
                document: $context.actor,
                effectId: effect.id,
                parentId: effect.parentId
              }).deleteDialog(),
              title: localize("DND5E.EffectDelete"),
              iconCssClass: "fas fa-trash"
            })
          });
        }
      }
    }
    if ($$self.$$.dirty & /*controls*/
    1) {
      $$invalidate(3, classicControlsColumnWidth = `${classicControlsIconWidth$3 * controls.length}rem`);
    }
  };
  return [
    controls,
    effectSections,
    $context,
    classicControlsColumnWidth,
    noEffects,
    context,
    localize,
    func2,
    mousedown_handler,
    func_12
  ];
}
class NpcEffectsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2b, create_fragment$2b, safe_not_equal, {});
  }
}
class NpcSheetRuntime {
  static _content = [];
  static _tabs = [
    {
      title: "TIDY5E.Actions.TabName",
      content: {
        component: ActorActionsTab,
        type: "svelte"
      },
      id: CONSTANTS.TAB_ACTOR_ACTIONS,
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_NPC_ABILITIES,
      title: "TIDY5E.Abilities",
      content: {
        component: NpcAbilitiesTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_NPC_SPELLBOOK,
      title: "DND5E.Spellbook",
      content: {
        component: NpcSpellbookTab,
        type: "svelte"
      },
      enabled: (context) => !context.hideEmptySpellbook && context.showSpellbookTab,
      layout: "classic"
    },
    {
      id: "effects",
      title: "DND5E.Effects",
      content: {
        component: NpcEffectsTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: "biography",
      title: "DND5E.Biography",
      content: {
        component: NpcBiographyTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: "journal",
      title: "TIDY5E.JournalTabName",
      content: {
        component: ActorJournalTab,
        type: "svelte"
      },
      enabled: (context) => context.owner,
      layout: "classic"
    },
    {
      id: "inventory",
      title: "DND5E.Inventory",
      content: {
        component: ActorInventoryTab,
        type: "svelte",
        getProps() {
          return {
            tabId: CONSTANTS.TAB_NPC_INVENTORY
          };
        }
      },
      enabled: (context) => context.owner,
      layout: "classic"
    }
  ];
  static async getContent(context) {
    return await CustomContentManager.prepareContentForRender(
      context,
      NpcSheetRuntime._content
    );
  }
  static getTabs(context) {
    return TabManager.prepareTabsForRender(context, NpcSheetRuntime._tabs);
  }
  static getAllRegisteredTabs() {
    return [...NpcSheetRuntime._tabs];
  }
  static registerContent(registeredContent) {
    this._content.push(registeredContent);
  }
  static registerTab(tab, options) {
    const tabExists = NpcSheetRuntime._tabs.some((t2) => t2.id === tab.id);
    if (tabExists) {
      warn(`Tab with id ${tab.id} already exists.`);
      return;
    }
    if (tabExists && options?.overrideExisting) {
      const index = NpcSheetRuntime._tabs.findIndex((t2) => t2.id === tab.id);
      if (index >= 0) {
        NpcSheetRuntime._tabs.splice(index, 1);
      }
    }
    NpcSheetRuntime._tabs.push(tab);
  }
  static getTabTitle(tabId) {
    try {
      let tabTitle = this._tabs.find((t2) => t2.id === tabId)?.title;
      if (typeof tabTitle === "function") {
        tabTitle = tabTitle();
      }
      return tabTitle ? FoundryAdapter.localize(tabTitle) : tabId;
    } catch (e2) {
      error("An error occurred while searching for a tab title.", false, e2);
      debug("Tab title error troubleshooting information", { tabId });
    }
  }
}
function get_each_context$p(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function get_each_context_1$b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  return child_ctx;
}
function create_if_block_6$9(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot_10$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_default_slot_10$8(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("TIDY5E.GMOnlyEdit") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_else_block$B(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*effectSections*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$p(get_each_context$p(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections, $context, classicControlsColumnWidth, controls, localize*/
      79) {
        each_value = ensure_array_like(
          /*effectSections*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$p(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$p(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block$_(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot$W] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_if_block_1$C(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    (ctx[2].unlocked && /*$context*/
    ctx[2].allowEffectsManagement || /*section*/
    ctx[9].effects.length > 0) && create_if_block_2$t(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[2].unlocked && /*$context*/
        ctx2[2].allowEffectsManagement || /*section*/
        ctx2[9].effects.length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context, effectSections*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$t(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_2$t(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[9].label
      ),
      $$slots: {
        body: [create_body_slot$5],
        header: [create_header_slot$6]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtable_changes = {};
      if (dirty & /*effectSections*/
      2) itemtable_changes.key = /*section*/
      ctx2[9].label;
      if (dirty & /*$$scope, $context, effectSections, classicControlsColumnWidth, controls*/
      32783) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function create_default_slot_9$8(ctx) {
  let t_value = (
    /*localize*/
    ctx[6](
      /*section*/
      ctx[9].label
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[6](
        /*section*/
        ctx2[9].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_8$9(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Source") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_7$a(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Duration") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_5$c(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      8) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[3];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_6$c(ctx) {
  let itemtablecolumn0;
  let t0;
  let itemtablecolumn1;
  let t1;
  let itemtablecolumn2;
  let t2;
  let if_block_anchor;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_9$8] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: "12.5rem",
      $$slots: { default: [create_default_slot_8$9] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn2 = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_7$a] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_5$c(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t0 = space();
      create_component(itemtablecolumn1.$$.fragment);
      t1 = space();
      create_component(itemtablecolumn2.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecolumn2, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope, effectSections*/
      32770) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
      const itemtablecolumn2_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        itemtablecolumn2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn2.$set(itemtablecolumn2_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      transition_in(itemtablecolumn2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      transition_out(itemtablecolumn2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
      destroy_component(itemtablecolumn2, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_header_slot$6(ctx) {
  let itemtableheaderrow;
  let t2;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_6$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, classicControlsColumnWidth, $context, effectSections*/
      32782) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_default_slot_5$f(ctx) {
  let itemimage;
  let t0;
  let span;
  let t1_value = (
    /*effect*/
    ctx[12].name + ""
  );
  let t1;
  let span_data_tidy_effect_name_value;
  let current;
  itemimage = new ItemImage({
    props: {
      src: (
        /*effect*/
        ctx[12].img ?? /*effect*/
        ctx[12].icon
      )
    }
  });
  return {
    c() {
      create_component(itemimage.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(span, "class", "align-self-center truncate");
      attr(span, "data-tidy-effect-name", span_data_tidy_effect_name_value = /*effect*/
      ctx[12].name);
    },
    m(target, anchor) {
      mount_component(itemimage, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const itemimage_changes = {};
      if (dirty & /*effectSections*/
      2) itemimage_changes.src = /*effect*/
      ctx2[12].img ?? /*effect*/
      ctx2[12].icon;
      itemimage.$set(itemimage_changes);
      if ((!current || dirty & /*effectSections*/
      2) && t1_value !== (t1_value = /*effect*/
      ctx2[12].name + "")) set_data(t1, t1_value);
      if (!current || dirty & /*effectSections*/
      2 && span_data_tidy_effect_name_value !== (span_data_tidy_effect_name_value = /*effect*/
      ctx2[12].name)) {
        attr(span, "data-tidy-effect-name", span_data_tidy_effect_name_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemimage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemimage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      destroy_component(itemimage, detaching);
    }
  };
}
function create_default_slot_4$i(ctx) {
  let t_value = (
    /*effect*/
    (ctx[12].sourceName ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*effect*/
      (ctx2[12].sourceName ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$l(ctx) {
  let t_value = (
    /*effect*/
    (ctx[12].duration.label ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections*/
      2 && t_value !== (t_value = /*effect*/
      (ctx2[12].duration.label ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_4$f(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_2$l] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      8) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[3];
      if (dirty & /*$$scope, controls, effectSections*/
      32771) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_2$l(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[0]
      ),
      params: { effect: (
        /*effect*/
        ctx[12]
      ) }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      1) classiccontrols_changes.controls = /*controls*/
      ctx2[0];
      if (dirty & /*effectSections*/
      2) classiccontrols_changes.params = { effect: (
        /*effect*/
        ctx2[12]
      ) };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot_1$q(ctx) {
  let itemtablecell0;
  let t0;
  let itemtablecell1;
  let t1;
  let itemtablecell2;
  let t2;
  let if_block_anchor;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      primary: true,
      attributes: {
        "data-tidy-effect-name-container": true,
        "data-effect-id": (
          /*effect*/
          ctx[12].id
        )
      },
      $$slots: { default: [create_default_slot_5$f] },
      $$scope: { ctx }
    }
  });
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "12.5rem",
      $$slots: { default: [create_default_slot_4$i] },
      $$scope: { ctx }
    }
  });
  itemtablecell2 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_3$l] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_4$f(ctx)
  );
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t0 = space();
      create_component(itemtablecell1.$$.fragment);
      t1 = space();
      create_component(itemtablecell2.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemtablecell1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemtablecell2, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*effectSections*/
      2) itemtablecell0_changes.attributes = {
        "data-tidy-effect-name-container": true,
        "data-effect-id": (
          /*effect*/
          ctx2[12].id
        )
      };
      if (dirty & /*$$scope, effectSections*/
      32770) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      const itemtablecell1_changes = {};
      if (dirty & /*$$scope, effectSections*/
      32770) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
      const itemtablecell2_changes = {};
      if (dirty & /*$$scope, effectSections*/
      32770) {
        itemtablecell2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell2.$set(itemtablecell2_changes);
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4$f(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(itemtablecell1.$$.fragment, local);
      transition_in(itemtablecell2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(itemtablecell1.$$.fragment, local);
      transition_out(itemtablecell2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecell0, detaching);
      destroy_component(itemtablecell1, detaching);
      destroy_component(itemtablecell2, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_each_block_1$b(ctx) {
  let itemtablerow;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[7](
        /*effect*/
        ctx[12],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS,
        uuid: (
          /*effect*/
          ctx[12].uuid
        )
      },
      effect: (
        /*effect*/
        ctx[12]
      ),
      $$slots: { default: [create_default_slot_1$q] },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    c() {
      create_component(itemtablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*effectSections*/
      2) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS,
        uuid: (
          /*effect*/
          ctx[12].uuid
        )
      };
      if (dirty & /*effectSections*/
      2) itemtablerow_changes.effect = /*effect*/
      ctx[12];
      if (dirty & /*$$scope, classicControlsColumnWidth, controls, effectSections, $context*/
      32783) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_if_block_3$m(ctx) {
  let itemtablefooter;
  let current;
  function func2() {
    return (
      /*func*/
      ctx[8](
        /*section*/
        ctx[9]
      )
    );
  }
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[2].actor
      ),
      section: (
        /*section*/
        ctx[9]
      ),
      create: func2,
      isItem: false
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablefooter_changes = {};
      if (dirty & /*$context*/
      4) itemtablefooter_changes.actor = /*$context*/
      ctx[2].actor;
      if (dirty & /*effectSections*/
      2) itemtablefooter_changes.section = /*section*/
      ctx[9];
      if (dirty & /*effectSections, $context*/
      6) itemtablefooter_changes.create = func2;
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$5(ctx) {
  let t0;
  let t1;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[9].effects
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$b(get_each_context_1$b(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = (
    /*$context*/
    ctx[2].unlocked && /*$context*/
    ctx[2].allowEffectsManagement && create_if_block_3$m(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*effectSections, classicControlsColumnWidth, controls, $context*/
      15) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[9].effects
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$b(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$b(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].unlocked && /*$context*/
        ctx2[2].allowEffectsManagement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_each_block$p(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*section*/
  ctx[9].hidden && create_if_block_1$C(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*section*/
      ctx2[9].hidden) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*effectSections*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$C(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$W(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("TIDY5E.EmptySection") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$2a(ctx) {
  let div;
  let t2;
  let current_block_type_index;
  let if_block1;
  let current;
  let if_block0 = !/*$context*/
  ctx[2].allowEffectsManagement && /*$context*/
  ctx[2].unlocked && create_if_block_6$9(ctx);
  const if_block_creators = [create_if_block$_, create_else_block$B];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noEffects*/
      ctx2[4] && !/*$context*/
      ctx2[2].unlocked && /*$context*/
      ctx2[2].allowEffectsManagement
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t2 = space();
      if_block1.c();
      attr(div, "class", "scroll-container flex-column small-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t2);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*$context*/
      ctx2[2].allowEffectsManagement && /*$context*/
      ctx2[2].unlocked) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
let classicControlsIconWidth$2 = 1.25;
function instance$2a($$self, $$props, $$invalidate) {
  let effectSections;
  let noEffects;
  let classicControlsColumnWidth;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  const localize = FoundryAdapter.localize;
  declareLocation("effects");
  let controls = [];
  const mousedown_handler = (effect, event) => FoundryAdapter.editOnMiddleClick(event.detail, effect);
  const func2 = (section) => FoundryAdapter.addEffect(section.type, $context.actor);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(1, effectSections = Object.values($context.effects));
    }
    if ($$self.$$.dirty & /*effectSections*/
    2) {
      $$invalidate(4, noEffects = effectSections.some((section) => section.effects.length > 0) === false);
    }
    if ($$self.$$.dirty & /*controls, $context*/
    5) {
      {
        $$invalidate(0, controls = []);
        controls.push(
          {
            component: ActorEffectToggleControl,
            props: ({ effect }) => ({ effect })
          },
          {
            component: ItemControl,
            props: ({ effect }) => ({
              onclick: () => effect.sheet.render(true),
              title: localize("DND5E.EffectEdit"),
              iconCssClass: "fas fa-edit"
            })
          }
        );
        if ($context.unlocked) {
          controls.push({
            component: ItemControl,
            props: ({ effect }) => ({
              onclick: () => effect.deleteDialog(),
              title: localize("DND5E.EffectDelete"),
              iconCssClass: "fas fa-trash"
            })
          });
        }
      }
    }
    if ($$self.$$.dirty & /*controls*/
    1) {
      $$invalidate(3, classicControlsColumnWidth = `${classicControlsIconWidth$2 * controls.length}rem`);
    }
  };
  return [
    controls,
    effectSections,
    $context,
    classicControlsColumnWidth,
    noEffects,
    context,
    localize,
    mousedown_handler,
    func2
  ];
}
class ActorEffectsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2a, create_fragment$2a, safe_not_equal, {});
  }
}
function create_default_slot$V(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[5]("DND5E.VehicleActionStations")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$Z(ctx) {
  let div8;
  let horizontallineseparator0;
  let t0;
  let div1;
  let h40;
  let t2;
  let div0;
  let numberinput0;
  let t3;
  let horizontallineseparator1;
  let t4;
  let div3;
  let h41;
  let t6;
  let div2;
  let span0;
  let t8;
  let numberinput1;
  let t9;
  let span1;
  let t11;
  let numberinput2;
  let t12;
  let span2;
  let t14;
  let numberinput3;
  let t15;
  let horizontallineseparator2;
  let t16;
  let div5;
  let h42;
  let t18;
  let div4;
  let t19;
  let t20;
  let horizontallineseparator3;
  let t21;
  let div7;
  let h43;
  let t23;
  let div6;
  let t24;
  let div8_transition;
  let current;
  horizontallineseparator0 = new HorizontalLineSeparator({});
  numberinput0 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[2].actor
      ),
      field: "system.attributes.actions.value",
      value: (
        /*$context*/
        ctx[2].system.attributes.actions.value
      ),
      step: "1",
      min: "0",
      placeholder: "0",
      title: (
        /*localize*/
        ctx[5]("DND5E.VehicleActionsHint")
      ),
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockSensitiveFields
    }
  });
  horizontallineseparator1 = new HorizontalLineSeparator({});
  numberinput1 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[2].actor
      ),
      field: "system.attributes.actions.thresholds.2",
      value: (
        /*$context*/
        ctx[2].system.attributes.actions.thresholds["2"]
      ),
      min: "0",
      step: "1",
      placeholder: "",
      title: (
        /*localize*/
        ctx[5]("DND5E.VehicleActionThresholdsFull")
      ),
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockSensitiveFields
    }
  });
  numberinput2 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[2].actor
      ),
      field: "system.attributes.actions.thresholds.1",
      value: (
        /*$context*/
        ctx[2].system.attributes.actions.thresholds["1"]
      ),
      min: "0",
      step: "1",
      placeholder: "",
      title: (
        /*localize*/
        ctx[5]("DND5E.VehicleActionThresholdsMid")
      ),
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockSensitiveFields
    }
  });
  numberinput3 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[2].actor
      ),
      field: "system.attributes.actions.thresholds.0",
      value: (
        /*$context*/
        ctx[2].system.attributes.actions.thresholds["0"]
      ),
      min: "0",
      step: "1",
      placeholder: "",
      title: (
        /*localize*/
        ctx[5]("DND5E.VehicleActionThresholdsMin")
      ),
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockSensitiveFields
    }
  });
  horizontallineseparator2 = new HorizontalLineSeparator({});
  horizontallineseparator3 = new HorizontalLineSeparator({});
  return {
    c() {
      div8 = element("div");
      create_component(horizontallineseparator0.$$.fragment);
      t0 = space();
      div1 = element("div");
      h40 = element("h4");
      h40.textContent = `${/*localize*/
      ctx[5]("DND5E.ActionPl")}`;
      t2 = space();
      div0 = element("div");
      create_component(numberinput0.$$.fragment);
      t3 = space();
      create_component(horizontallineseparator1.$$.fragment);
      t4 = space();
      div3 = element("div");
      h41 = element("h4");
      h41.textContent = `${/*localize*/
      ctx[5]("DND5E.VehicleActionThresholds")}`;
      t6 = space();
      div2 = element("div");
      span0 = element("span");
      span0.textContent = "<";
      t8 = space();
      create_component(numberinput1.$$.fragment);
      t9 = space();
      span1 = element("span");
      span1.textContent = "<";
      t11 = space();
      create_component(numberinput2.$$.fragment);
      t12 = space();
      span2 = element("span");
      span2.textContent = "<";
      t14 = space();
      create_component(numberinput3.$$.fragment);
      t15 = space();
      create_component(horizontallineseparator2.$$.fragment);
      t16 = space();
      div5 = element("div");
      h42 = element("h4");
      h42.textContent = `${/*localize*/
      ctx[5]("TIDY5E.TotalCrewCount")}`;
      t18 = space();
      div4 = element("div");
      t19 = text(
        /*totalCrew*/
        ctx[1]
      );
      t20 = space();
      create_component(horizontallineseparator3.$$.fragment);
      t21 = space();
      div7 = element("div");
      h43 = element("h4");
      h43.textContent = `${/*localize*/
      ctx[5]("TIDY5E.ActionsPerTurn")}`;
      t23 = space();
      div6 = element("div");
      t24 = text(
        /*actionsPerTurn*/
        ctx[0]
      );
      attr(div0, "class", "counter-value svelte-1e2xbpr");
      attr(div1, "class", "counter actions");
      attr(span0, "class", "sep");
      attr(span1, "class", "sep");
      attr(span2, "class", "sep");
      attr(div2, "class", "counter-value svelte-1e2xbpr");
      attr(div3, "class", "counter action-thresholds");
      attr(div4, "class", "counter-value svelte-1e2xbpr");
      attr(
        div4,
        "title",
        /*crewTallyDescription*/
        ctx[3]
      );
      attr(div5, "class", "counter action-summary");
      attr(div6, "class", "counter-value svelte-1e2xbpr");
      attr(div7, "class", "counter action-summary");
      attr(div8, "class", "counter-flex svelte-1e2xbpr");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      mount_component(horizontallineseparator0, div8, null);
      append(div8, t0);
      append(div8, div1);
      append(div1, h40);
      append(div1, t2);
      append(div1, div0);
      mount_component(numberinput0, div0, null);
      append(div8, t3);
      mount_component(horizontallineseparator1, div8, null);
      append(div8, t4);
      append(div8, div3);
      append(div3, h41);
      append(div3, t6);
      append(div3, div2);
      append(div2, span0);
      append(div2, t8);
      mount_component(numberinput1, div2, null);
      append(div2, t9);
      append(div2, span1);
      append(div2, t11);
      mount_component(numberinput2, div2, null);
      append(div2, t12);
      append(div2, span2);
      append(div2, t14);
      mount_component(numberinput3, div2, null);
      append(div8, t15);
      mount_component(horizontallineseparator2, div8, null);
      append(div8, t16);
      append(div8, div5);
      append(div5, h42);
      append(div5, t18);
      append(div5, div4);
      append(div4, t19);
      append(div8, t20);
      mount_component(horizontallineseparator3, div8, null);
      append(div8, t21);
      append(div8, div7);
      append(div7, h43);
      append(div7, t23);
      append(div7, div6);
      append(div6, t24);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput0_changes = {};
      if (dirty & /*$context*/
      4) numberinput0_changes.document = /*$context*/
      ctx2[2].actor;
      if (dirty & /*$context*/
      4) numberinput0_changes.value = /*$context*/
      ctx2[2].system.attributes.actions.value;
      if (dirty & /*$context*/
      4) numberinput0_changes.disabled = !/*$context*/
      ctx2[2].editable || /*$context*/
      ctx2[2].lockSensitiveFields;
      numberinput0.$set(numberinput0_changes);
      const numberinput1_changes = {};
      if (dirty & /*$context*/
      4) numberinput1_changes.document = /*$context*/
      ctx2[2].actor;
      if (dirty & /*$context*/
      4) numberinput1_changes.value = /*$context*/
      ctx2[2].system.attributes.actions.thresholds["2"];
      if (dirty & /*$context*/
      4) numberinput1_changes.disabled = !/*$context*/
      ctx2[2].editable || /*$context*/
      ctx2[2].lockSensitiveFields;
      numberinput1.$set(numberinput1_changes);
      const numberinput2_changes = {};
      if (dirty & /*$context*/
      4) numberinput2_changes.document = /*$context*/
      ctx2[2].actor;
      if (dirty & /*$context*/
      4) numberinput2_changes.value = /*$context*/
      ctx2[2].system.attributes.actions.thresholds["1"];
      if (dirty & /*$context*/
      4) numberinput2_changes.disabled = !/*$context*/
      ctx2[2].editable || /*$context*/
      ctx2[2].lockSensitiveFields;
      numberinput2.$set(numberinput2_changes);
      const numberinput3_changes = {};
      if (dirty & /*$context*/
      4) numberinput3_changes.document = /*$context*/
      ctx2[2].actor;
      if (dirty & /*$context*/
      4) numberinput3_changes.value = /*$context*/
      ctx2[2].system.attributes.actions.thresholds["0"];
      if (dirty & /*$context*/
      4) numberinput3_changes.disabled = !/*$context*/
      ctx2[2].editable || /*$context*/
      ctx2[2].lockSensitiveFields;
      numberinput3.$set(numberinput3_changes);
      if (!current || dirty & /*totalCrew*/
      2) set_data(
        t19,
        /*totalCrew*/
        ctx2[1]
      );
      if (!current || dirty & /*crewTallyDescription*/
      8) {
        attr(
          div4,
          "title",
          /*crewTallyDescription*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*actionsPerTurn*/
      1) set_data(
        t24,
        /*actionsPerTurn*/
        ctx2[0]
      );
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator0.$$.fragment, local);
      transition_in(numberinput0.$$.fragment, local);
      transition_in(horizontallineseparator1.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(numberinput3.$$.fragment, local);
      transition_in(horizontallineseparator2.$$.fragment, local);
      transition_in(horizontallineseparator3.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div8_transition) div8_transition = create_bidirectional_transition(div8, slide, { duration: 200, easing: quadInOut }, true);
          div8_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator0.$$.fragment, local);
      transition_out(numberinput0.$$.fragment, local);
      transition_out(horizontallineseparator1.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(numberinput3.$$.fragment, local);
      transition_out(horizontallineseparator2.$$.fragment, local);
      transition_out(horizontallineseparator3.$$.fragment, local);
      if (local) {
        if (!div8_transition) div8_transition = create_bidirectional_transition(div8, slide, { duration: 200, easing: quadInOut }, false);
        div8_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div8);
      }
      destroy_component(horizontallineseparator0);
      destroy_component(numberinput0);
      destroy_component(horizontallineseparator1);
      destroy_component(numberinput1);
      destroy_component(numberinput2);
      destroy_component(numberinput3);
      destroy_component(horizontallineseparator2);
      destroy_component(horizontallineseparator3);
      if (detaching && div8_transition) div8_transition.end();
    }
  };
}
function create_fragment$29(ctx) {
  let div6;
  let div1;
  let h40;
  let t1;
  let div0;
  let contenteditableformfield;
  let t2;
  let horizontallineseparator0;
  let t3;
  let div3;
  let h41;
  let t5;
  let div2;
  let numberinput;
  let t6;
  let horizontallineseparator1;
  let t7;
  let div5;
  let div4;
  let checkbox;
  let t8;
  let current;
  contenteditableformfield = new ContentEditableFormField({
    props: {
      element: "div",
      document: (
        /*$context*/
        ctx[2].actor
      ),
      field: "system.attributes.capacity.creature",
      editable: (
        /*$context*/
        ctx[2].editable && !/*$context*/
        ctx[2].lockSensitiveFields
      ),
      placeholder: "",
      value: (
        /*$context*/
        ctx[2].system.attributes.capacity.creature
      ),
      dataMaxLength: 1e3
    }
  });
  horizontallineseparator0 = new HorizontalLineSeparator({});
  numberinput = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[2].actor
      ),
      field: "system.attributes.capacity.cargo",
      value: (
        /*$context*/
        ctx[2].system.attributes.capacity.cargo
      ),
      min: "0",
      placeholder: "0",
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockSensitiveFields
    }
  });
  horizontallineseparator1 = new HorizontalLineSeparator({});
  checkbox = new Checkbox({
    props: {
      document: (
        /*$context*/
        ctx[2].actor
      ),
      field: "system.attributes.actions.stations",
      checked: (
        /*$context*/
        ctx[2].system.attributes.actions.stations
      ),
      labelCssClass: "action-stations-label",
      disabled: !/*$context*/
      ctx[2].editable || /*$context*/
      ctx[2].lockSensitiveFields,
      $$slots: { default: [create_default_slot$V] },
      $$scope: { ctx }
    }
  });
  let if_block = !/*$context*/
  ctx[2].system.attributes.actions.stations && create_if_block$Z(ctx);
  return {
    c() {
      div6 = element("div");
      div1 = element("div");
      h40 = element("h4");
      h40.textContent = `${/*localize*/
      ctx[5]("DND5E.VehicleCreatureCapacity")}`;
      t1 = space();
      div0 = element("div");
      create_component(contenteditableformfield.$$.fragment);
      t2 = space();
      create_component(horizontallineseparator0.$$.fragment);
      t3 = space();
      div3 = element("div");
      h41 = element("h4");
      h41.textContent = `${/*localize*/
      ctx[5]("DND5E.VehicleCargoCapacity")}`;
      t5 = space();
      div2 = element("div");
      create_component(numberinput.$$.fragment);
      t6 = space();
      create_component(horizontallineseparator1.$$.fragment);
      t7 = space();
      div5 = element("div");
      div4 = element("div");
      create_component(checkbox.$$.fragment);
      t8 = space();
      if (if_block) if_block.c();
      attr(div0, "class", "counter-value svelte-1e2xbpr");
      attr(div1, "class", "counter creature-cap");
      attr(h41, "class", "flex-1");
      attr(div2, "class", "counter-value svelte-1e2xbpr");
      attr(div3, "class", "counter cargo-cap");
      attr(div4, "class", "counter-value svelte-1e2xbpr");
      attr(div5, "class", "counter stations");
      attr(div6, "class", "counters counter-flex svelte-1e2xbpr");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div1);
      append(div1, h40);
      append(div1, t1);
      append(div1, div0);
      mount_component(contenteditableformfield, div0, null);
      append(div6, t2);
      mount_component(horizontallineseparator0, div6, null);
      append(div6, t3);
      append(div6, div3);
      append(div3, h41);
      append(div3, t5);
      append(div3, div2);
      mount_component(numberinput, div2, null);
      append(div6, t6);
      mount_component(horizontallineseparator1, div6, null);
      append(div6, t7);
      append(div6, div5);
      append(div5, div4);
      mount_component(checkbox, div4, null);
      append(div6, t8);
      if (if_block) if_block.m(div6, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const contenteditableformfield_changes = {};
      if (dirty & /*$context*/
      4) contenteditableformfield_changes.document = /*$context*/
      ctx2[2].actor;
      if (dirty & /*$context*/
      4) contenteditableformfield_changes.editable = /*$context*/
      ctx2[2].editable && !/*$context*/
      ctx2[2].lockSensitiveFields;
      if (dirty & /*$context*/
      4) contenteditableformfield_changes.value = /*$context*/
      ctx2[2].system.attributes.capacity.creature;
      contenteditableformfield.$set(contenteditableformfield_changes);
      const numberinput_changes = {};
      if (dirty & /*$context*/
      4) numberinput_changes.document = /*$context*/
      ctx2[2].actor;
      if (dirty & /*$context*/
      4) numberinput_changes.value = /*$context*/
      ctx2[2].system.attributes.capacity.cargo;
      if (dirty & /*$context*/
      4) numberinput_changes.disabled = !/*$context*/
      ctx2[2].editable || /*$context*/
      ctx2[2].lockSensitiveFields;
      numberinput.$set(numberinput_changes);
      const checkbox_changes = {};
      if (dirty & /*$context*/
      4) checkbox_changes.document = /*$context*/
      ctx2[2].actor;
      if (dirty & /*$context*/
      4) checkbox_changes.checked = /*$context*/
      ctx2[2].system.attributes.actions.stations;
      if (dirty & /*$context*/
      4) checkbox_changes.disabled = !/*$context*/
      ctx2[2].editable || /*$context*/
      ctx2[2].lockSensitiveFields;
      if (dirty & /*$$scope*/
      128) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
      if (!/*$context*/
      ctx2[2].system.attributes.actions.stations) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$Z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div6, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(contenteditableformfield.$$.fragment, local);
      transition_in(horizontallineseparator0.$$.fragment, local);
      transition_in(numberinput.$$.fragment, local);
      transition_in(horizontallineseparator1.$$.fragment, local);
      transition_in(checkbox.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(contenteditableformfield.$$.fragment, local);
      transition_out(horizontallineseparator0.$$.fragment, local);
      transition_out(numberinput.$$.fragment, local);
      transition_out(horizontallineseparator1.$$.fragment, local);
      transition_out(checkbox.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      destroy_component(contenteditableformfield);
      destroy_component(horizontallineseparator0);
      destroy_component(numberinput);
      destroy_component(horizontallineseparator1);
      destroy_component(checkbox);
      if (if_block) if_block.d();
    }
  };
}
function instance$29($$self, $$props, $$invalidate) {
  let totalCrew;
  let totalActions;
  let actionsPerTurn;
  let crewTallyDescription;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  const localize = FoundryAdapter.localize;
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(1, totalCrew = $context.system.cargo.crew.reduce((count, c2) => count + c2.quantity, 0));
    }
    if ($$self.$$.dirty & /*$context*/
    4) {
      $$invalidate(6, totalActions = $context.system.attributes.actions.value ?? 0);
    }
    if ($$self.$$.dirty & /*totalCrew, $context, totalActions*/
    70) {
      $$invalidate(0, actionsPerTurn = totalCrew >= $context.system.attributes.actions.thresholds[2] ? totalActions : totalCrew >= $context.system.attributes.actions.thresholds[1] ? Math.max(totalActions - 1, 0) : totalCrew >= $context.system.attributes.actions.thresholds[0] ? Math.max(totalActions - 2, 0) : 0);
    }
    if ($$self.$$.dirty & /*actionsPerTurn, totalActions*/
    65) {
      $$invalidate(3, crewTallyDescription = actionsPerTurn === totalActions ? localize("DND5E.VehicleActionThresholdsFull") : actionsPerTurn === totalActions - 1 ? localize("DND5E.VehicleActionThresholdsMid") : actionsPerTurn === totalActions - 2 ? localize("DND5E.VehicleActionThresholdsMin") : null);
    }
  };
  return [
    actionsPerTurn,
    totalCrew,
    $context,
    crewTallyDescription,
    context,
    localize,
    totalActions
  ];
}
class VehicleAttributes extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$29, create_fragment$29, safe_not_equal, {});
  }
}
function create_fragment$28(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "bar " + /*cssClass*/
      ctx[1] + " svelte-qx955f");
      set_style(
        div,
        "width",
        /*barPercentage*/
        ctx[2] + "%"
      );
      set_style(
        div,
        "--bar-color",
        /*color*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*cssClass*/
      2 && div_class_value !== (div_class_value = "bar " + /*cssClass*/
      ctx2[1] + " svelte-qx955f")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*barPercentage*/
      4) {
        set_style(
          div,
          "width",
          /*barPercentage*/
          ctx2[2] + "%"
        );
      }
      if (dirty & /*color*/
      1) {
        set_style(
          div,
          "--bar-color",
          /*color*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$28($$self, $$props, $$invalidate) {
  let barPercentage;
  let { value = null } = $$props;
  let { max = null } = $$props;
  let { percentage = null } = $$props;
  let { color = "var(--t5e-hp-bar-color)" } = $$props;
  let { cssClass = null } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(3, value = $$props2.value);
    if ("max" in $$props2) $$invalidate(4, max = $$props2.max);
    if ("percentage" in $$props2) $$invalidate(5, percentage = $$props2.percentage);
    if ("color" in $$props2) $$invalidate(0, color = $$props2.color);
    if ("cssClass" in $$props2) $$invalidate(1, cssClass = $$props2.cssClass);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*percentage, value, max*/
    56) {
      $$invalidate(2, barPercentage = percentage ?? getPercentage(value, max));
    }
  };
  return [color, cssClass, barPercentage, value, max, percentage];
}
class Bar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$28, create_fragment$28, safe_not_equal, {
      value: 3,
      max: 4,
      percentage: 5,
      color: 0,
      cssClass: 1
    });
  }
}
function create_fragment$27(ctx) {
  let bar;
  let current;
  bar = new Bar({
    props: {
      value: (
        /*value*/
        ctx[0]
      ),
      max: (
        /*max*/
        ctx[1]
      ),
      percentage: (
        /*percentage*/
        ctx[2]
      ),
      color: "var(--t5e-hp-bar-color)"
    }
  });
  return {
    c() {
      create_component(bar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bar, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const bar_changes = {};
      if (dirty & /*value*/
      1) bar_changes.value = /*value*/
      ctx2[0];
      if (dirty & /*max*/
      2) bar_changes.max = /*max*/
      ctx2[1];
      if (dirty & /*percentage*/
      4) bar_changes.percentage = /*percentage*/
      ctx2[2];
      bar.$set(bar_changes);
    },
    i(local) {
      if (current) return;
      transition_in(bar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(bar, detaching);
    }
  };
}
function instance$27($$self, $$props, $$invalidate) {
  let { value = null } = $$props;
  let { max = null } = $$props;
  let { percentage = null } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("max" in $$props2) $$invalidate(1, max = $$props2.max);
    if ("percentage" in $$props2) $$invalidate(2, percentage = $$props2.percentage);
  };
  return [value, max, percentage];
}
class HpBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$27, create_fragment$27, safe_not_equal, { value: 0, max: 1, percentage: 2 });
  }
}
function create_if_block_1$B(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*Bar*/
    ctx[10]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        percentage: (
          /*percentage*/
          ctx2[9]
        ),
        value: (
          /*value*/
          ctx2[1]
        ),
        max: (
          /*max*/
          ctx2[5]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*Bar*/
      1024 && switch_value !== (switch_value = /*Bar*/
      ctx2[10])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*percentage*/
        512) switch_instance_changes.percentage = /*percentage*/
        ctx2[9];
        if (dirty & /*value*/
        2) switch_instance_changes.value = /*value*/
        ctx2[1];
        if (dirty & /*max*/
        32) switch_instance_changes.max = /*max*/
        ctx2[5];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_else_block$A(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(
        /*max*/
        ctx[5]
      );
      attr(span, "class", "resource-max");
      attr(
        span,
        "title",
        /*maxTitle*/
        ctx[7]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*max*/
      32) set_data(
        t2,
        /*max*/
        ctx2[5]
      );
      if (dirty & /*maxTitle*/
      128) {
        attr(
          span,
          "title",
          /*maxTitle*/
          ctx2[7]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$Y(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      cssClass: "resource-max",
      document: (
        /*document*/
        ctx[0]
      ),
      field: (
        /*maxField*/
        ctx[6]
      ),
      value: (
        /*max*/
        ctx[5]
      ),
      placeholder: "0",
      title: (
        /*maxTitle*/
        ctx[7]
      ),
      selectOnFocus: true,
      allowDeltaChanges: true,
      maxlength: 5,
      ariaDescribedBy: "tooltip",
      disabled: (
        /*maxDisabled*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*document*/
      1) textinput_changes.document = /*document*/
      ctx2[0];
      if (dirty & /*maxField*/
      64) textinput_changes.field = /*maxField*/
      ctx2[6];
      if (dirty & /*max*/
      32) textinput_changes.value = /*max*/
      ctx2[5];
      if (dirty & /*maxTitle*/
      128) textinput_changes.title = /*maxTitle*/
      ctx2[7];
      if (dirty & /*maxDisabled*/
      256) textinput_changes.disabled = /*maxDisabled*/
      ctx2[8];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_fragment$26(ctx) {
  let div;
  let t0;
  let textinput;
  let t1;
  let span;
  let t3;
  let current_block_type_index;
  let if_block1;
  let current;
  let if_block0 = (
    /*Bar*/
    ctx[10] && create_if_block_1$B(ctx)
  );
  textinput = new TextInput$1({
    props: {
      cssClass: "resource-value",
      document: (
        /*document*/
        ctx[0]
      ),
      field: (
        /*valueField*/
        ctx[2]
      ),
      value: (
        /*value*/
        ctx[1]
      ),
      placeholder: "0",
      title: (
        /*valueTitle*/
        ctx[3]
      ),
      selectOnFocus: true,
      allowDeltaChanges: true,
      maxlength: 5,
      ariaDescribedBy: "tooltip",
      disabled: (
        /*valueDisabled*/
        ctx[4]
      )
    }
  });
  const if_block_creators = [create_if_block$Y, create_else_block$A];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*maxDisabled*/
    ctx2[8]) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      create_component(textinput.$$.fragment);
      t1 = space();
      span = element("span");
      span.textContent = "/";
      t3 = space();
      if_block1.c();
      attr(span, "class", "resource-separator");
      attr(div, "class", "resource-container svelte-129gcyy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      mount_component(textinput, div, null);
      append(div, t1);
      append(div, span);
      append(div, t3);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*Bar*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*Bar*/
          1024) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$B(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const textinput_changes = {};
      if (dirty & /*document*/
      1) textinput_changes.document = /*document*/
      ctx2[0];
      if (dirty & /*valueField*/
      4) textinput_changes.field = /*valueField*/
      ctx2[2];
      if (dirty & /*value*/
      2) textinput_changes.value = /*value*/
      ctx2[1];
      if (dirty & /*valueTitle*/
      8) textinput_changes.title = /*valueTitle*/
      ctx2[3];
      if (dirty & /*valueDisabled*/
      16) textinput_changes.disabled = /*valueDisabled*/
      ctx2[4];
      textinput.$set(textinput_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(textinput.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(textinput.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      destroy_component(textinput);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$26($$self, $$props, $$invalidate) {
  let { document: document2 } = $$props;
  let { value } = $$props;
  let { valueField } = $$props;
  let { valueTitle = null } = $$props;
  let { valueDisabled = false } = $$props;
  let { max } = $$props;
  let { maxField } = $$props;
  let { maxTitle = null } = $$props;
  let { maxDisabled = false } = $$props;
  let { percentage = null } = $$props;
  let { Bar: Bar2 = null } = $$props;
  $$self.$$set = ($$props2) => {
    if ("document" in $$props2) $$invalidate(0, document2 = $$props2.document);
    if ("value" in $$props2) $$invalidate(1, value = $$props2.value);
    if ("valueField" in $$props2) $$invalidate(2, valueField = $$props2.valueField);
    if ("valueTitle" in $$props2) $$invalidate(3, valueTitle = $$props2.valueTitle);
    if ("valueDisabled" in $$props2) $$invalidate(4, valueDisabled = $$props2.valueDisabled);
    if ("max" in $$props2) $$invalidate(5, max = $$props2.max);
    if ("maxField" in $$props2) $$invalidate(6, maxField = $$props2.maxField);
    if ("maxTitle" in $$props2) $$invalidate(7, maxTitle = $$props2.maxTitle);
    if ("maxDisabled" in $$props2) $$invalidate(8, maxDisabled = $$props2.maxDisabled);
    if ("percentage" in $$props2) $$invalidate(9, percentage = $$props2.percentage);
    if ("Bar" in $$props2) $$invalidate(10, Bar2 = $$props2.Bar);
  };
  return [
    document2,
    value,
    valueField,
    valueTitle,
    valueDisabled,
    max,
    maxField,
    maxTitle,
    maxDisabled,
    percentage,
    Bar2
  ];
}
class ResourceWithBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$26, create_fragment$26, safe_not_equal, {
      document: 0,
      value: 1,
      valueField: 2,
      valueTitle: 3,
      valueDisabled: 4,
      max: 5,
      maxField: 6,
      maxTitle: 7,
      maxDisabled: 8,
      percentage: 9,
      Bar: 10
    });
  }
}
function create_fragment$25(ctx) {
  let itemcontrol;
  let current;
  itemcontrol = new ItemControl({
    props: {
      iconCssClass: "fas fa-user-alt " + /*ctx*/
      ctx[1]?.toggleClass,
      title: (
        /*ctx*/
        ctx[1]?.toggleTitle
      ),
      active: (
        /*ctx*/
        ctx[1]?.toggleClass === "active"
      ),
      onclick: (
        /*func*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(itemcontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemcontrol, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemcontrol_changes = {};
      if (dirty & /*ctx*/
      2) itemcontrol_changes.iconCssClass = "fas fa-user-alt " + /*ctx*/
      ctx2[1]?.toggleClass;
      if (dirty & /*ctx*/
      2) itemcontrol_changes.title = /*ctx*/
      ctx2[1]?.toggleTitle;
      if (dirty & /*ctx*/
      2) itemcontrol_changes.active = /*ctx*/
      ctx2[1]?.toggleClass === "active";
      if (dirty & /*item*/
      1) itemcontrol_changes.onclick = /*func*/
      ctx2[2];
      itemcontrol.$set(itemcontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemcontrol, detaching);
    }
  };
}
function instance$25($$self, $$props, $$invalidate) {
  let { item } = $$props;
  let { ctx } = $$props;
  const func2 = () => item.update({ ["system.crewed"]: !item.system.crewed });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("ctx" in $$props2) $$invalidate(1, ctx = $$props2.ctx);
  };
  return [item, ctx, func2];
}
class ItemCrewedControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$25, create_fragment$25, safe_not_equal, { item: 0, ctx: 1 });
  }
}
function get_each_context$o(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  return child_ctx;
}
function get_each_context_3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function get_each_context_1$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  const constants_0 = (
    /*$context*/
    child_ctx[1].itemContext[
      /*item*/
      child_ctx[13].id
    ]
  );
  child_ctx[14] = constants_0;
  return child_ctx;
}
function get_each_context_2$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function get_else_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*column*/
    child_ctx[18].editable === "Number"
  );
  child_ctx[21] = constants_0;
  const constants_1 = (
    /*isNumber*/
    child_ctx[21] ? "0" : ""
  );
  child_ctx[22] = constants_1;
  const constants_2 = FoundryAdapter.getProperty(
    /*item*/
    child_ctx[13],
    /*column*/
    child_ctx[18].property
  )?.toString() ?? FoundryAdapter.getProperty(
    /*ctx*/
    child_ctx[14],
    /*column*/
    child_ctx[18].property
  )?.toString() ?? /*fallback*/
  child_ctx[22];
  child_ctx[23] = constants_2;
  return child_ctx;
}
function create_else_block$z(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[1].features
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[10].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$o(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$o(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, classicControlsColumnWidth, controls, localize, baseWidths, toggleSummary, alternateColumnHeaderContent*/
      131303) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[1].features
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$o, each_1_anchor, get_each_context$o);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block$X(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot$U] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_if_block_1$A(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[10].key
      ),
      $$slots: {
        body: [create_body_slot$4],
        header: [create_header_slot$5]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtable_changes = {};
      if (dirty & /*$context*/
      2) itemtable_changes.key = /*section*/
      ctx2[10].key;
      if (dirty & /*$$scope, $context, classicControlsColumnWidth, controls*/
      67108871) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
function create_default_slot_13$5(ctx) {
  let t_value = (
    /*localize*/
    ctx[5](
      /*section*/
      ctx[10].label
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[5](
        /*section*/
        ctx2[10].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_15$1(ctx) {
  let itemtablecolumn0;
  let t2;
  let itemtablecolumn1;
  let current;
  itemtablecolumn0 = new ItemTableColumn({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_12$5] },
      $$scope: { ctx }
    }
  });
  itemtablecolumn1 = new ItemTableColumn({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_11$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn0.$$.fragment);
      t2 = space();
      create_component(itemtablecolumn1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecolumn1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn0_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        itemtablecolumn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn0.$set(itemtablecolumn0_changes);
      const itemtablecolumn1_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        itemtablecolumn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn1.$set(itemtablecolumn1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn0.$$.fragment, local);
      transition_in(itemtablecolumn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn0.$$.fragment, local);
      transition_out(itemtablecolumn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtablecolumn0, detaching);
      destroy_component(itemtablecolumn1, detaching);
    }
  };
}
function create_default_slot_12$5(ctx) {
  let t_value = (
    /*localize*/
    ctx[5]("DND5E.Uses") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_11$6(ctx) {
  let t_value = (
    /*localize*/
    ctx[5]("DND5E.Usage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_13$2(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = ensure_array_like(
    /*section*/
    ctx[10].columns
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3(get_each_context_3(ctx, each_value_3, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, baseWidths, alternateColumnHeaderContent*/
      194) {
        each_value_3 = ensure_array_like(
          /*section*/
          ctx2[10].columns
        );
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_3.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block_4(ctx) {
  let t_value = (
    /*column*/
    ctx[18].label + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && t_value !== (t_value = /*column*/
      ctx2[18].label + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_14$2(ctx) {
  let html_tag;
  let raw_value = (
    /*alternateColumnHeaderContent*/
    ctx[7][
      /*column*/
      ctx[18].property
    ] + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && raw_value !== (raw_value = /*alternateColumnHeaderContent*/
      ctx2[7][
        /*column*/
        ctx2[18].property
      ] + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_default_slot_10$7(ctx) {
  let t2;
  function select_block_type_4(ctx2, dirty) {
    if (
      /*alternateColumnHeaderContent*/
      ctx2[7][
        /*column*/
        ctx2[18].property
      ]
    ) return create_if_block_14$2;
    return create_else_block_4;
  }
  let current_block_type = select_block_type_4(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      t2 = space();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_4(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if_block.d(detaching);
    }
  };
}
function create_each_block_3(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      cssClass: "items-header-" + /*column*/
      ctx[18].css,
      baseWidth: (
        /*baseWidths*/
        ctx[6][
          /*column*/
          ctx[18].property
        ] ?? "3.125rem"
      ),
      $$slots: { default: [create_default_slot_10$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$context*/
      2) itemtablecolumn_changes.cssClass = "items-header-" + /*column*/
      ctx2[18].css;
      if (dirty & /*$context*/
      2) itemtablecolumn_changes.baseWidth = /*baseWidths*/
      ctx2[6][
        /*column*/
        ctx2[18].property
      ] ?? "3.125rem";
      if (dirty & /*$$scope, $context*/
      67108866) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_if_block_12$2(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      4) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[2];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_9$7(ctx) {
  let itemtablecolumn;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_13$5] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*section*/
    ctx[10].hasActions && create_if_block_15$1(ctx)
  );
  let if_block1 = (
    /*section*/
    ctx[10].columns && create_if_block_13$2(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[1].editable && /*$context*/
    ctx[1].useClassicControls && create_if_block_12$2(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope, $context*/
      67108866) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
      if (
        /*section*/
        ctx2[10].hasActions
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_15$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[10].columns
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_13$2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[1].editable && /*$context*/
        ctx2[1].useClassicControls
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_12$2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block2_anchor);
      }
      destroy_component(itemtablecolumn, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_header_slot$5(ctx) {
  let itemtableheaderrow;
  let t2;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_9$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, classicControlsColumnWidth, $context*/
      67108870) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_default_slot_8$8(ctx) {
  let span;
  let t_value = (
    /*item*/
    ctx[13].name + ""
  );
  let t2;
  let span_data_tidy_item_name_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "truncate");
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*item*/
      ctx[13].name);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && t_value !== (t_value = /*item*/
      ctx2[13].name + "")) set_data(t2, t_value);
      if (dirty & /*$context*/
      2 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*item*/
      ctx2[13].name)) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_7$9(ctx) {
  let itemusebutton;
  let t2;
  let itemname;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[1].editable,
      item: (
        /*item*/
        ctx[13]
      )
    }
  });
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[8](
        /*toggleSummary*/
        ctx[17]
      )
    );
  }
  itemname = new ItemName({
    props: {
      cssClass: "extra-small-gap",
      item: (
        /*item*/
        ctx[13]
      ),
      $$slots: { default: [create_default_slot_8$8] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t2 = space();
      create_component(itemname.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemname, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty & /*$context*/
      2) itemusebutton_changes.disabled = !/*$context*/
      ctx[1].editable;
      if (dirty & /*$context*/
      2) itemusebutton_changes.item = /*item*/
      ctx[13];
      itemusebutton.$set(itemusebutton_changes);
      const itemname_changes = {};
      if (dirty & /*$context*/
      2) itemname_changes.item = /*item*/
      ctx[13];
      if (dirty & /*$$scope, $context*/
      67108866) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(itemname.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(itemname.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemusebutton, detaching);
      destroy_component(itemname, detaching);
    }
  };
}
function create_if_block_7$7(ctx) {
  let itemtablecell0;
  let t2;
  let itemtablecell1;
  let current;
  itemtablecell0 = new ItemTableCell({
    props: {
      baseWidth: "3.125rem",
      $$slots: { default: [create_default_slot_6$b] },
      $$scope: { ctx }
    }
  });
  itemtablecell1 = new ItemTableCell({
    props: {
      baseWidth: "7.5rem",
      $$slots: { default: [create_default_slot_5$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell0.$$.fragment);
      t2 = space();
      create_component(itemtablecell1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemtablecell1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell0_changes = {};
      if (dirty & /*$$scope, $context*/
      67108866) {
        itemtablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell0.$set(itemtablecell0_changes);
      const itemtablecell1_changes = {};
      if (dirty & /*$$scope, $context*/
      67108866) {
        itemtablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell1.$set(itemtablecell1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell0.$$.fragment, local);
      transition_in(itemtablecell1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell0.$$.fragment, local);
      transition_out(itemtablecell1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemtablecell0, detaching);
      destroy_component(itemtablecell1, detaching);
    }
  };
}
function create_else_block_3$1(ctx) {
  let itemadduses;
  let current;
  itemadduses = new ItemAddUses({ props: { item: (
    /*item*/
    ctx[13]
  ) } });
  return {
    c() {
      create_component(itemadduses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemadduses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemadduses_changes = {};
      if (dirty & /*$context*/
      2) itemadduses_changes.item = /*item*/
      ctx2[13];
      itemadduses.$set(itemadduses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemadduses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemadduses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemadduses, detaching);
    }
  };
}
function create_if_block_11$2(ctx) {
  let itemuses;
  let current;
  itemuses = new ItemUses({ props: { item: (
    /*item*/
    ctx[13]
  ) } });
  return {
    c() {
      create_component(itemuses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemuses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemuses_changes = {};
      if (dirty & /*$context*/
      2) itemuses_changes.item = /*item*/
      ctx2[13];
      itemuses.$set(itemuses_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemuses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemuses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemuses, detaching);
    }
  };
}
function create_if_block_10$3(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-bolt");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[5]("DND5E.Charged")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_9$5(ctx) {
  let rechargecontrol;
  let current;
  rechargecontrol = new RechargeControl({ props: { item: (
    /*item*/
    ctx[13]
  ) } });
  return {
    c() {
      create_component(rechargecontrol.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rechargecontrol, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rechargecontrol_changes = {};
      if (dirty & /*$context*/
      2) rechargecontrol_changes.item = /*item*/
      ctx2[13];
      rechargecontrol.$set(rechargecontrol_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rechargecontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rechargecontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rechargecontrol, detaching);
    }
  };
}
function create_default_slot_6$b(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_9$5, create_if_block_10$3, create_if_block_11$2, create_else_block_3$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*item*/
      ctx2[13].isOnCooldown
    ) return 0;
    if (
      /*item*/
      ctx2[13].system.recharge?.value
    ) return 1;
    if (
      /*ctx*/
      ctx2[14]?.hasUses
    ) return 2;
    return 3;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_8$5(ctx) {
  let span;
  let t_value = (
    /*item*/
    (ctx[13].labels?.activation ?? "") + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && t_value !== (t_value = /*item*/
      (ctx2[13].labels?.activation ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_5$e(ctx) {
  let if_block_anchor;
  let if_block = (
    /*item*/
    ctx[13].system.activation?.type && create_if_block_8$5(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[13].system.activation?.type
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_8$5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_4$e(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*section*/
    ctx[10].columns
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*localize, $context, baseWidths*/
      98) {
        each_value_2 = ensure_array_like(
          /*section*/
          ctx2[10].columns
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$4(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block_1$7(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*baseWidths*/
        ctx[6][
          /*column*/
          ctx[18].property
        ] ?? "3.125rem"
      ),
      $$slots: { default: [create_default_slot_4$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$context*/
      2) itemtablecell_changes.baseWidth = /*baseWidths*/
      ctx2[6][
        /*column*/
        ctx2[18].property
      ] ?? "3.125rem";
      if (dirty & /*$$scope, $context*/
      67108866) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_if_block_5$b(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: "4.375rem",
      $$slots: { default: [create_default_slot_3$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, $context*/
      67108866) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_else_block_2$1(ctx) {
  let t_value = (FoundryAdapter.getProperty(
    /*item*/
    ctx[13],
    /*column*/
    ctx[18].property
  ) ?? FoundryAdapter.getProperty(
    /*ctx*/
    ctx[14],
    /*column*/
    ctx[18].property
  ) ?? /*fallback*/
  ctx[22]) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && t_value !== (t_value = (FoundryAdapter.getProperty(
        /*item*/
        ctx2[13],
        /*column*/
        ctx2[18].property
      ) ?? FoundryAdapter.getProperty(
        /*ctx*/
        ctx2[14],
        /*column*/
        ctx2[18].property
      ) ?? /*fallback*/
      ctx2[22]) + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_6$8(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[13]
      ),
      field: (
        /*column*/
        ctx[18].property
      ),
      allowDeltaChanges: (
        /*isNumber*/
        ctx[21]
      ),
      selectOnFocus: true,
      value: (
        /*value*/
        ctx[23]
      ),
      disabled: !/*$context*/
      ctx[1].editable
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*item*/
      ctx2[13];
      if (dirty & /*$context*/
      2) textinput_changes.field = /*column*/
      ctx2[18].property;
      if (dirty & /*$context*/
      2) textinput_changes.allowDeltaChanges = /*isNumber*/
      ctx2[21];
      if (dirty & /*$context*/
      2) textinput_changes.value = /*value*/
      ctx2[23];
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_4$h(ctx) {
  let current_block_type_index;
  let if_block;
  let t2;
  let current;
  const if_block_creators = [create_if_block_6$8, create_else_block_2$1];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*column*/
      ctx2[18].editable
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      t2 = space();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t2.parentNode, t2);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_default_slot_3$k(ctx) {
  let div;
  let resourcewithbar;
  let t2;
  let current;
  resourcewithbar = new ResourceWithBar({
    props: {
      document: (
        /*item*/
        ctx[13]
      ),
      value: (
        /*item*/
        ctx[13].system.hp.value
      ),
      valueField: "system.hp.value",
      valueTitle: (
        /*localize*/
        ctx[5]("DND5E.HitPointsCurrent")
      ),
      valueDisabled: !/*$context*/
      ctx[1].editable,
      max: (
        /*item*/
        ctx[13].system.hp.max
      ),
      maxField: "system.hp.max",
      maxTitle: (
        /*localize*/
        ctx[5]("DND5E.HitPointsMax")
      ),
      maxDisabled: !/*$context*/
      ctx[1].editable || /*$context*/
      ctx[1].lockSensitiveFields,
      Bar: HpBar
    }
  });
  return {
    c() {
      div = element("div");
      create_component(resourcewithbar.$$.fragment);
      t2 = space();
      attr(div, "class", "item-hp svelte-1pf41lf");
      attr(
        div,
        "title",
        /*localize*/
        ctx[5]("DND5E.HitPoints")
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(resourcewithbar, div, null);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const resourcewithbar_changes = {};
      if (dirty & /*$context*/
      2) resourcewithbar_changes.document = /*item*/
      ctx2[13];
      if (dirty & /*$context*/
      2) resourcewithbar_changes.value = /*item*/
      ctx2[13].system.hp.value;
      if (dirty & /*$context*/
      2) resourcewithbar_changes.valueDisabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$context*/
      2) resourcewithbar_changes.max = /*item*/
      ctx2[13].system.hp.max;
      if (dirty & /*$context*/
      2) resourcewithbar_changes.maxDisabled = !/*$context*/
      ctx2[1].editable || /*$context*/
      ctx2[1].lockSensitiveFields;
      resourcewithbar.$set(resourcewithbar_changes);
    },
    i(local) {
      if (current) return;
      transition_in(resourcewithbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resourcewithbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
      }
      destroy_component(resourcewithbar);
    }
  };
}
function create_each_block_2$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5$b, create_else_block_1$7];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*column*/
      ctx2[18].property === "system.hp.value"
    ) return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 1) return get_else_ctx(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(select_block_ctx(ctx2, current_block_type_index), dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block.c();
        } else {
          if_block.p(select_block_ctx(ctx2, current_block_type_index), dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_3$l(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot_2$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      4) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[2];
      if (dirty & /*$$scope, controls, $context*/
      67108867) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_2$k(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[0]
      ),
      params: {
        item: (
          /*item*/
          ctx[13]
        ),
        ctx: (
          /*ctx*/
          ctx[14]
        )
      }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      1) classiccontrols_changes.controls = /*controls*/
      ctx2[0];
      if (dirty & /*$context*/
      2) classiccontrols_changes.params = {
        item: (
          /*item*/
          ctx2[13]
        ),
        ctx: (
          /*ctx*/
          ctx2[14]
        )
      };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot_1$p(ctx) {
  let itemtablecell;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_7$9] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*section*/
    ctx[10].hasActions && create_if_block_7$7(ctx)
  );
  let if_block1 = (
    /*section*/
    ctx[10].columns && create_if_block_4$e(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[1].editable && /*$context*/
    ctx[1].useClassicControls && create_if_block_3$l(ctx)
  );
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, $context, toggleSummary*/
      67239938) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
      if (
        /*section*/
        ctx2[10].hasActions
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*section*/
        ctx2[10].columns
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$e(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[1].editable && /*$context*/
        ctx2[1].useClassicControls
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$l(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block2_anchor);
      }
      destroy_component(itemtablecell, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_each_block_1$a(key_1, ctx) {
  let first;
  let itemtablerow;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[9](
        /*item*/
        ctx[13],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[13].uuid
        )
      },
      item: (
        /*item*/
        ctx[13]
      ),
      cssClass: FoundryAdapter.getInventoryRowClasses(
        /*item*/
        ctx[13],
        /*ctx*/
        ctx[14]
      ),
      $$slots: {
        default: [
          create_default_slot_1$p,
          ({ toggleSummary }) => ({ 17: toggleSummary }),
          ({ toggleSummary }) => toggleSummary ? 131072 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*$context*/
      2) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[13].uuid
        )
      };
      if (dirty & /*$context*/
      2) itemtablerow_changes.item = /*item*/
      ctx[13];
      if (dirty & /*$context*/
      2) itemtablerow_changes.cssClass = FoundryAdapter.getInventoryRowClasses(
        /*item*/
        ctx[13],
        /*ctx*/
        ctx[14]
      );
      if (dirty & /*$$scope, classicControlsColumnWidth, controls, $context, toggleSummary*/
      67239943) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_if_block_2$s(ctx) {
  let itemtablefooter;
  let current;
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[1].actor
      ),
      section: (
        /*section*/
        ctx[10]
      ),
      isItem: true
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablefooter_changes = {};
      if (dirty & /*$context*/
      2) itemtablefooter_changes.actor = /*$context*/
      ctx2[1].actor;
      if (dirty & /*$context*/
      2) itemtablefooter_changes.section = /*section*/
      ctx2[10];
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$4(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let t1;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[10].items
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[13].id
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$a(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$a(key, child_ctx));
  }
  let if_block = (
    /*$context*/
    ctx[1].unlocked && /*section*/
    ctx[10].dataset && create_if_block_2$s(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, classicControlsColumnWidth, controls, localize, baseWidths, toggleSummary*/
      131175) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[10].items
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, t0.parentNode, outro_and_destroy_block, create_each_block_1$a, t0, get_each_context_1$a);
        check_outros();
      }
      if (
        /*$context*/
        ctx2[1].unlocked && /*section*/
        ctx2[10].dataset
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$s(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_each_block$o(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    (ctx[1].unlocked || /*section*/
    ctx[10].items.length) && create_if_block_1$A(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*$context*/
        ctx[1].unlocked || /*section*/
        ctx[10].items.length
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$A(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$U(ctx) {
  let t_value = (
    /*localize*/
    ctx[5]("TIDY5E.EmptySection") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$24(ctx) {
  let div2;
  let div0;
  let vehicleattributes;
  let t0;
  let traits;
  let t1;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  vehicleattributes = new VehicleAttributes({});
  traits = new Traits({
    props: {
      toggleable: true,
      useSenses: false,
      enableSpecialTraitsConfiguration: false
    }
  });
  const if_block_creators = [create_if_block$X, create_else_block$z];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*noFeatures*/
      ctx2[3] && !/*$context*/
      ctx2[1].unlocked
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(vehicleattributes.$$.fragment);
      t0 = space();
      create_component(traits.$$.fragment);
      t1 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "side-panel svelte-1pf41lf");
      attr(div1, "class", "main-panel flex-column small-gap svelte-1pf41lf");
      attr(div2, "class", "attributes-tab-contents svelte-1pf41lf");
      attr(div2, "data-tidy-track-scroll-y", "");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(vehicleattributes, div0, null);
      append(div0, t0);
      mount_component(traits, div0, null);
      append(div2, t1);
      append(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
    },
    i(local) {
      if (current) return;
      transition_in(vehicleattributes.$$.fragment, local);
      transition_in(traits.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(vehicleattributes.$$.fragment, local);
      transition_out(traits.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(vehicleattributes);
      destroy_component(traits);
      if_blocks[current_block_type_index].d();
    }
  };
}
let classicControlsIconWidth$1 = 1.25;
function instance$24($$self, $$props, $$invalidate) {
  let noFeatures;
  let classicControlsColumnWidth;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const localize = FoundryAdapter.localize;
  let baseWidths = {
    cover: "3.125rem",
    "system.quantity": "4.375rem",
    "system.armor.value": "2.5rem",
    "system.hp.value": "4.375rem",
    threshold: "2.5rem"
  };
  let alternateColumnHeaderContent = {
    threshold: `<i class="fas fa-heart-crack" title="${localize("DND5E.Threshold")}"></i>`
  };
  declareLocation("attributes");
  let controls = [];
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (item, event) => FoundryAdapter.editOnMiddleClick(event.detail, item);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    2) {
      $$invalidate(3, noFeatures = !$context.features.some((section) => section.items.length));
    }
    if ($$self.$$.dirty & /*controls, $context*/
    3) {
      {
        $$invalidate(0, controls = []);
        controls.push(
          {
            component: ItemCrewedControl,
            props: ({ item, ctx }) => ({ item, ctx })
          },
          {
            component: ItemEditControl,
            props: ({ item }) => ({ item })
          }
        );
        if ($context.unlocked) {
          controls.push({
            component: ItemDeleteControl,
            props: ({ item }) => ({ item })
          });
        }
        if ($context.useActionsFeature) {
          controls.push({
            component: ActionFilterOverrideControl,
            props: ({ item }) => ({ item })
          });
        }
      }
    }
    if ($$self.$$.dirty & /*controls*/
    1) {
      $$invalidate(2, classicControlsColumnWidth = `${classicControlsIconWidth$1 * controls.length}rem`);
    }
  };
  return [
    controls,
    $context,
    classicControlsColumnWidth,
    noFeatures,
    context,
    localize,
    baseWidths,
    alternateColumnHeaderContent,
    toggle_handler,
    mousedown_handler
  ];
}
class VehicleAttributesTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$24, create_fragment$24, safe_not_equal, {});
  }
}
function get_each_context_2$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function get_each_context$n(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[14] = i2;
  const constants_0 = (
    /*$context*/
    child_ctx[2].itemContext[
      /*item*/
      child_ctx[11].id
    ]
  );
  child_ctx[12] = constants_0;
  return child_ctx;
}
function get_each_context_1$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  const constants_0 = (
    /*column*/
    child_ctx[16].editable === "Number"
  );
  child_ctx[17] = constants_0;
  const constants_1 = (
    /*isNumber*/
    child_ctx[17] ? "0" : ""
  );
  child_ctx[18] = constants_1;
  const constants_2 = FoundryAdapter.getProperty(
    /*item*/
    child_ctx[11],
    /*column*/
    child_ctx[16].property
  )?.toString() ?? FoundryAdapter.getProperty(
    /*ctx*/
    child_ctx[12],
    /*column*/
    child_ctx[16].property
  )?.toString() ?? /*fallback*/
  child_ctx[18];
  child_ctx[19] = constants_2;
  return child_ctx;
}
function create_default_slot_7$8(ctx) {
  let t_value = (
    /*localize*/
    ctx[7](
      /*section*/
      ctx[0].label
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*localize*/
      ctx2[7](
        /*section*/
        ctx2[0].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_6$a(ctx) {
  let t_value = (
    /*column*/
    ctx[16].label + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*column*/
      ctx2[16].label + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_2$3(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      cssClass: "items-header-" + /*column*/
      ctx[16].css,
      baseWidth: (
        /*baseWidths*/
        ctx[6][
          /*column*/
          ctx[16].property
        ] ?? "3.125rem"
      ),
      $$slots: { default: [create_default_slot_6$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*section*/
      1) itemtablecolumn_changes.cssClass = "items-header-" + /*column*/
      ctx2[16].css;
      if (dirty & /*section*/
      1) itemtablecolumn_changes.baseWidth = /*baseWidths*/
      ctx2[6][
        /*column*/
        ctx2[16].property
      ] ?? "3.125rem";
      if (dirty & /*$$scope, section*/
      16777217) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_if_block_6$7(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      8) itemtablecolumn_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[3];
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_5$d(ctx) {
  let itemtablecolumn;
  let t0;
  let t1;
  let if_block_anchor;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_7$8] },
      $$scope: { ctx }
    }
  });
  let each_value_2 = ensure_array_like(
    /*section*/
    ctx[0].columns
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && create_if_block_6$7(ctx)
  );
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      insert(target, t0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t1, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope, section*/
      16777217) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
      if (dirty & /*section, baseWidths*/
      65) {
        each_value_2 = ensure_array_like(
          /*section*/
          ctx2[0].columns
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$3(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecolumn, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_header_slot$4(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_5$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, classicControlsColumnWidth, $context, section*/
      16777229) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_if_block_5$a(ctx) {
  let inlinecontainertoggle;
  let current;
  inlinecontainertoggle = new InlineContainerToggle({
    props: {
      item: (
        /*item*/
        ctx[11]
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainertoggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainertoggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainertoggle_changes = {};
      if (dirty & /*section*/
      1) inlinecontainertoggle_changes.item = /*item*/
      ctx2[11];
      inlinecontainertoggle.$set(inlinecontainertoggle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainertoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainertoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainertoggle, detaching);
    }
  };
}
function create_default_slot_4$g(ctx) {
  let span;
  let t_value = (
    /*item*/
    ctx[11].name + ""
  );
  let t2;
  let span_data_tidy_item_name_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "truncate");
      attr(span, "data-tidy-item-name", span_data_tidy_item_name_value = /*item*/
      ctx[11].name);
      attr(span, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_NAME);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*item*/
      ctx2[11].name + "")) set_data(t2, t_value);
      if (dirty & /*section*/
      1 && span_data_tidy_item_name_value !== (span_data_tidy_item_name_value = /*item*/
      ctx2[11].name)) {
        attr(span, "data-tidy-item-name", span_data_tidy_item_name_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_3$j(ctx) {
  let itemusebutton;
  let t0;
  let t1;
  let itemname;
  let current;
  itemusebutton = new ItemUseButton({
    props: {
      disabled: !/*$context*/
      ctx[2].editable,
      item: (
        /*item*/
        ctx[11]
      )
    }
  });
  let if_block = "containerContents" in /*ctx*/
  ctx[12] && !!/*ctx*/
  ctx[12].containerContents && create_if_block_5$a(ctx);
  function toggle_handler() {
    return (
      /*toggle_handler*/
      ctx[8](
        /*toggleSummary*/
        ctx[15]
      )
    );
  }
  itemname = new ItemName({
    props: {
      cssClass: "extra-small-gap",
      item: (
        /*item*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_4$g] },
      $$scope: { ctx }
    }
  });
  itemname.$on("toggle", toggle_handler);
  return {
    c() {
      create_component(itemusebutton.$$.fragment);
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      create_component(itemname.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemusebutton, target, anchor);
      insert(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemname, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemusebutton_changes = {};
      if (dirty & /*$context*/
      4) itemusebutton_changes.disabled = !/*$context*/
      ctx[2].editable;
      if (dirty & /*section*/
      1) itemusebutton_changes.item = /*item*/
      ctx[11];
      itemusebutton.$set(itemusebutton_changes);
      if ("containerContents" in /*ctx*/
      ctx[12] && !!/*ctx*/
      ctx[12].containerContents) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$context, section*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$a(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const itemname_changes = {};
      if (dirty & /*section*/
      1) itemname_changes.item = /*item*/
      ctx[11];
      if (dirty & /*$$scope, section*/
      16777217) {
        itemname_changes.$$scope = { dirty, ctx };
      }
      itemname.$set(itemname_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemusebutton.$$.fragment, local);
      transition_in(if_block);
      transition_in(itemname.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemusebutton.$$.fragment, local);
      transition_out(if_block);
      transition_out(itemname.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(itemusebutton, detaching);
      if (if_block) if_block.d(detaching);
      destroy_component(itemname, detaching);
    }
  };
}
function create_if_block_3$k(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[0].columns
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$9(get_each_context_1$9(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*baseWidths, section, $context*/
      69) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[0].columns
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$9(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block$y(ctx) {
  let t_value = (FoundryAdapter.getProperty(
    /*item*/
    ctx[11],
    /*column*/
    ctx[16].property
  ) ?? FoundryAdapter.getProperty(
    /*ctx*/
    ctx[12],
    /*column*/
    ctx[16].property
  ) ?? /*fallback*/
  ctx[18]) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section, $context*/
      5 && t_value !== (t_value = (FoundryAdapter.getProperty(
        /*item*/
        ctx2[11],
        /*column*/
        ctx2[16].property
      ) ?? FoundryAdapter.getProperty(
        /*ctx*/
        ctx2[12],
        /*column*/
        ctx2[16].property
      ) ?? /*fallback*/
      ctx2[18]) + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_4$d(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[11]
      ),
      field: (
        /*column*/
        ctx[16].property
      ),
      allowDeltaChanges: (
        /*isNumber*/
        ctx[17]
      ),
      selectOnFocus: true,
      value: (
        /*value*/
        ctx[19]
      ),
      disabled: !/*$context*/
      ctx[2].editable || /*column*/
      ctx[16].property === "quantity" && /*$context*/
      ctx[2].lockItemQuantity
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*section*/
      1) textinput_changes.document = /*item*/
      ctx2[11];
      if (dirty & /*section*/
      1) textinput_changes.field = /*column*/
      ctx2[16].property;
      if (dirty & /*section*/
      1) textinput_changes.allowDeltaChanges = /*isNumber*/
      ctx2[17];
      if (dirty & /*section, $context*/
      5) textinput_changes.value = /*value*/
      ctx2[19];
      if (dirty & /*$context, section*/
      5) textinput_changes.disabled = !/*$context*/
      ctx2[2].editable || /*column*/
      ctx2[16].property === "quantity" && /*$context*/
      ctx2[2].lockItemQuantity;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_2$j(ctx) {
  let current_block_type_index;
  let if_block;
  let t2;
  let current;
  const if_block_creators = [create_if_block_4$d, create_else_block$y];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*column*/
      ctx2[16].editable
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      t2 = space();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t2.parentNode, t2);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block_1$9(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*baseWidths*/
        ctx[6][
          /*column*/
          ctx[16].property
        ] ?? "3.125rem"
      ),
      $$slots: { default: [create_default_slot_2$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*section*/
      1) itemtablecell_changes.baseWidth = /*baseWidths*/
      ctx2[6][
        /*column*/
        ctx2[16].property
      ] ?? "3.125rem";
      if (dirty & /*$$scope, section, $context*/
      16777221) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_if_block_2$r(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*classicControlsColumnWidth*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_1$o] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*classicControlsColumnWidth*/
      8) itemtablecell_changes.baseWidth = /*classicControlsColumnWidth*/
      ctx2[3];
      if (dirty & /*$$scope, controls, section*/
      16777219) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_1$o(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[1]
      ),
      params: { item: (
        /*item*/
        ctx[11]
      ) }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      2) classiccontrols_changes.controls = /*controls*/
      ctx2[1];
      if (dirty & /*section*/
      1) classiccontrols_changes.params = { item: (
        /*item*/
        ctx2[11]
      ) };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot$T(ctx) {
  let itemtablecell;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_3$j] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*section*/
    ctx[0].columns && create_if_block_3$k(ctx)
  );
  let if_block1 = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].useClassicControls && create_if_block_2$r(ctx)
  );
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, section, toggleSummary, $context*/
      16809989) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
      if (
        /*section*/
        ctx2[0].columns
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*section*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$k(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].useClassicControls
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$r(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block1_anchor);
      }
      destroy_component(itemtablecell, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_if_block_1$z(ctx) {
  let inlinecontainerview;
  let current;
  inlinecontainerview = new InlineContainerView({
    props: {
      container: (
        /*item*/
        ctx[11]
      ),
      containerContents: (
        /*ctx*/
        ctx[12].containerContents
      ),
      editable: (
        /*$context*/
        ctx[2].editable
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[5]
      ),
      lockItemQuantity: (
        /*$context*/
        ctx[2].lockItemQuantity
      ),
      sheetDocument: (
        /*$context*/
        ctx[2].actor
      )
    }
  });
  return {
    c() {
      create_component(inlinecontainerview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinecontainerview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinecontainerview_changes = {};
      if (dirty & /*section*/
      1) inlinecontainerview_changes.container = /*item*/
      ctx2[11];
      if (dirty & /*$context, section*/
      5) inlinecontainerview_changes.containerContents = /*ctx*/
      ctx2[12].containerContents;
      if (dirty & /*$context*/
      4) inlinecontainerview_changes.editable = /*$context*/
      ctx2[2].editable;
      if (dirty & /*$context*/
      4) inlinecontainerview_changes.lockItemQuantity = /*$context*/
      ctx2[2].lockItemQuantity;
      if (dirty & /*$context*/
      4) inlinecontainerview_changes.sheetDocument = /*$context*/
      ctx2[2].actor;
      inlinecontainerview.$set(inlinecontainerview_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecontainerview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontainerview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinecontainerview, detaching);
    }
  };
}
function create_each_block$n(key_1, ctx) {
  let first;
  let itemtablerow;
  let t2;
  let if_block_anchor;
  let current;
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[9](
        /*item*/
        ctx[11],
        ...args
      )
    );
  }
  itemtablerow = new ItemTableRow({
    props: {
      contextMenu: {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[11].uuid
        )
      },
      item: (
        /*item*/
        ctx[11]
      ),
      cssClass: FoundryAdapter.getInventoryRowClasses(
        /*item*/
        ctx[11],
        /*ctx*/
        ctx[12]
      ),
      $$slots: {
        default: [
          create_default_slot$T,
          ({ toggleSummary }) => ({ 15: toggleSummary }),
          ({ toggleSummary }) => toggleSummary ? 32768 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemtablerow.$on("mousedown", mousedown_handler);
  let if_block = "containerContents" in /*ctx*/
  ctx[12] && !!/*ctx*/
  ctx[12].containerContents && create_if_block_1$z(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*section*/
      1) itemtablerow_changes.contextMenu = {
        type: CONSTANTS.CONTEXT_MENU_TYPE_ITEMS,
        uuid: (
          /*item*/
          ctx[11].uuid
        )
      };
      if (dirty & /*section*/
      1) itemtablerow_changes.item = /*item*/
      ctx[11];
      if (dirty & /*section, $context*/
      5) itemtablerow_changes.cssClass = FoundryAdapter.getInventoryRowClasses(
        /*item*/
        ctx[11],
        /*ctx*/
        ctx[12]
      );
      if (dirty & /*$$scope, classicControlsColumnWidth, controls, section, $context, toggleSummary*/
      16809999) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
      if ("containerContents" in /*ctx*/
      ctx[12] && !!/*ctx*/
      ctx[12].containerContents) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$context, section*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$z(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemtablerow, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block$W(ctx) {
  let itemtablefooter;
  let current;
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[2].actor
      ),
      section: (
        /*section*/
        ctx[0]
      ),
      create: (
        /*func*/
        ctx[10]
      ),
      isItem: (
        /*section*/
        ctx[0].dataset.type !== "crew" && /*section*/
        ctx[0].dataset.type !== "passengers"
      )
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablefooter_changes = {};
      if (dirty & /*$context*/
      4) itemtablefooter_changes.actor = /*$context*/
      ctx2[2].actor;
      if (dirty & /*section*/
      1) itemtablefooter_changes.section = /*section*/
      ctx2[0];
      if (dirty & /*section, $context*/
      5) itemtablefooter_changes.create = /*func*/
      ctx2[10];
      if (dirty & /*section*/
      1) itemtablefooter_changes.isItem = /*section*/
      ctx2[0].dataset.type !== "crew" && /*section*/
      ctx2[0].dataset.type !== "passengers";
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let if_block_anchor;
  let current;
  let each_value = ensure_array_like(
    /*section*/
    ctx[0].items
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[11].id ?? /*index*/
    ctx2[14]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$n(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$n(key, child_ctx));
  }
  let if_block = (
    /*$context*/
    ctx[2].unlocked && /*section*/
    ctx[0].dataset && create_if_block$W(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*section, $context, inlineContainerToggleService, classicControlsColumnWidth, controls, baseWidths, toggleSummary*/
      32879) {
        each_value = ensure_array_like(
          /*section*/
          ctx2[0].items
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t2.parentNode, outro_and_destroy_block, create_each_block$n, t2, get_each_context$n);
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].unlocked && /*section*/
        ctx2[0].dataset
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context, section*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$W(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$23(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[0].key
      ),
      $$slots: {
        body: [create_body_slot$3],
        header: [create_header_slot$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*section*/
      1) itemtable_changes.key = /*section*/
      ctx2[0].key;
      if (dirty & /*$$scope, $context, section, classicControlsColumnWidth, controls*/
      16777231) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
let classicControlsIconWidth = 1.25;
function instance$23($$self, $$props, $$invalidate) {
  let classicControlsColumnWidth;
  let $context;
  let { section } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let inlineContainerToggleService = getContext(CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE);
  let baseWidths = {
    quantity: "5rem",
    price: "4.375rem",
    weight: "3.75rem"
  };
  let controls = [];
  const localize = FoundryAdapter.localize;
  const toggle_handler = (toggleSummary) => toggleSummary($context.actor);
  const mousedown_handler = (item, event) => FoundryAdapter.editOnMiddleClick(event.detail, item);
  const func2 = () => FoundryAdapter.createItem({ type: section.dataset.type }, $context.actor);
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, controls*/
    6) {
      {
        $$invalidate(1, controls = [
          {
            component: ItemEditControl,
            props: ({ item }) => ({ item })
          }
        ]);
        if ($context.unlocked) {
          controls.push({
            component: ItemDeleteControl,
            props: ({ item }) => ({ item })
          });
        }
        if ($context.useActionsFeature) {
          controls.push({
            component: ActionFilterOverrideControl,
            props: ({ item }) => ({ item })
          });
        }
      }
    }
    if ($$self.$$.dirty & /*controls*/
    2) {
      $$invalidate(3, classicControlsColumnWidth = `${classicControlsIconWidth * controls.length}rem`);
    }
  };
  return [
    section,
    controls,
    $context,
    classicControlsColumnWidth,
    context,
    inlineContainerToggleService,
    baseWidths,
    localize,
    toggle_handler,
    mousedown_handler,
    func2
  ];
}
class CargoList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$23, create_fragment$23, safe_not_equal, { section: 0 });
  }
}
function get_each_context_2$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function get_each_context$m(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[15] = i2;
  const constants_0 = (
    /*$context*/
    child_ctx[2].itemContext[
      /*item*/
      child_ctx[12].id
    ]
  );
  child_ctx[13] = constants_0;
  return child_ctx;
}
function get_each_context_1$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  const constants_0 = (
    /*column*/
    child_ctx[16].editable === "Number"
  );
  child_ctx[17] = constants_0;
  const constants_1 = (
    /*isNumber*/
    child_ctx[17] ? "0" : ""
  );
  child_ctx[18] = constants_1;
  const constants_2 = FoundryAdapter.getProperty(
    /*item*/
    child_ctx[12],
    /*column*/
    child_ctx[16].property
  )?.toString() ?? FoundryAdapter.getProperty(
    /*ctx*/
    child_ctx[13],
    /*column*/
    child_ctx[16].property
  )?.toString() ?? /*fallback*/
  child_ctx[18];
  child_ctx[19] = constants_2;
  return child_ctx;
}
function create_default_slot_6$9(ctx) {
  let t_value = (
    /*localize*/
    ctx[7](
      /*section*/
      ctx[0].label
    ) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*localize*/
      ctx2[7](
        /*section*/
        ctx2[0].label
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_5$c(ctx) {
  let t_value = (
    /*column*/
    ctx[16].label + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section*/
      1 && t_value !== (t_value = /*column*/
      ctx2[16].label + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_2$2(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      cssClass: "items-header-" + /*column*/
      ctx[16].css,
      baseWidth: (
        /*baseWidths*/
        ctx[3][
          /*column*/
          ctx[16].property
        ] ?? "3.125rem"
      ),
      $$slots: { default: [create_default_slot_5$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*section*/
      1) itemtablecolumn_changes.cssClass = "items-header-" + /*column*/
      ctx2[16].css;
      if (dirty & /*section*/
      1) itemtablecolumn_changes.baseWidth = /*baseWidths*/
      ctx2[3][
        /*column*/
        ctx2[16].property
      ] ?? "3.125rem";
      if (dirty & /*$$scope, section*/
      16777217) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_if_block_4$c(ctx) {
  let itemtablecolumn;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      baseWidth: classicControlsEditableRowBaseWidth
    }
  });
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecolumn, detaching);
    }
  };
}
function create_default_slot_4$f(ctx) {
  let itemtablecolumn;
  let t0;
  let t1;
  let if_block_anchor;
  let current;
  itemtablecolumn = new ItemTableColumn({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_6$9] },
      $$scope: { ctx }
    }
  });
  let each_value_2 = ensure_array_like(
    /*section*/
    ctx[0].columns
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].unlocked && create_if_block_4$c()
  );
  return {
    c() {
      create_component(itemtablecolumn.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecolumn, target, anchor);
      insert(target, t0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t1, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecolumn_changes = {};
      if (dirty & /*$$scope, section*/
      16777217) {
        itemtablecolumn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecolumn.$set(itemtablecolumn_changes);
      if (dirty & /*section, baseWidths*/
      9) {
        each_value_2 = ensure_array_like(
          /*section*/
          ctx2[0].columns
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].unlocked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4$c();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecolumn.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemtablecolumn.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block_anchor);
      }
      destroy_component(itemtablecolumn, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_header_slot$3(ctx) {
  let itemtableheaderrow;
  let current;
  itemtableheaderrow = new ItemTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_4$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtableheaderrow_changes = {};
      if (dirty & /*$$scope, $context, section*/
      16777221) {
        itemtableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtableheaderrow.$set(itemtableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtableheaderrow, detaching);
    }
  };
}
function create_default_slot_3$i(ctx) {
  let textinput;
  let current;
  function func2(...args) {
    return (
      /*func*/
      ctx[8](
        /*index*/
        ctx[15],
        ...args
      )
    );
  }
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[12]
      ),
      field: "name",
      selectOnFocus: true,
      onSaveChange: func2,
      value: (
        /*item*/
        ctx[12].name
      ),
      cssClass: "editable-name",
      disabled: !/*$context*/
      ctx[2].editable,
      attributes: {
        "data-tidy-item-name": (
          /*item*/
          ctx[12].name
        )
      }
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const textinput_changes = {};
      if (dirty & /*section*/
      1) textinput_changes.document = /*item*/
      ctx[12];
      if (dirty & /*section*/
      1) textinput_changes.onSaveChange = func2;
      if (dirty & /*section*/
      1) textinput_changes.value = /*item*/
      ctx[12].name;
      if (dirty & /*$context*/
      4) textinput_changes.disabled = !/*$context*/
      ctx[2].editable;
      if (dirty & /*section*/
      1) textinput_changes.attributes = {
        "data-tidy-item-name": (
          /*item*/
          ctx[12].name
        )
      };
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_2$q(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[0].columns
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*baseWidths, section, $context, saveNonItemSectionData*/
      45) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[0].columns
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$8(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$8(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block$x(ctx) {
  let t_value = (FoundryAdapter.getProperty(
    /*item*/
    ctx[12],
    /*column*/
    ctx[16].property
  ) ?? FoundryAdapter.getProperty(
    /*ctx*/
    ctx[13],
    /*column*/
    ctx[16].property
  ) ?? /*fallback*/
  ctx[18]) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*section, $context*/
      5 && t_value !== (t_value = (FoundryAdapter.getProperty(
        /*item*/
        ctx2[12],
        /*column*/
        ctx2[16].property
      ) ?? FoundryAdapter.getProperty(
        /*ctx*/
        ctx2[13],
        /*column*/
        ctx2[16].property
      ) ?? /*fallback*/
      ctx2[18]) + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_3$j(ctx) {
  let textinput;
  let current;
  function func_12(...args) {
    return (
      /*func_1*/
      ctx[9](
        /*index*/
        ctx[15],
        /*column*/
        ctx[16],
        ...args
      )
    );
  }
  textinput = new TextInput$1({
    props: {
      document: (
        /*item*/
        ctx[12]
      ),
      field: (
        /*column*/
        ctx[16].property
      ),
      allowDeltaChanges: (
        /*isNumber*/
        ctx[17]
      ),
      selectOnFocus: true,
      value: (
        /*value*/
        ctx[19]
      ),
      onSaveChange: func_12,
      disabled: !/*$context*/
      ctx[2].editable || /*column*/
      ctx[16].property === "quantity" && /*$context*/
      ctx[2].lockItemQuantity
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const textinput_changes = {};
      if (dirty & /*section*/
      1) textinput_changes.document = /*item*/
      ctx[12];
      if (dirty & /*section*/
      1) textinput_changes.field = /*column*/
      ctx[16].property;
      if (dirty & /*section*/
      1) textinput_changes.allowDeltaChanges = /*isNumber*/
      ctx[17];
      if (dirty & /*section, $context*/
      5) textinput_changes.value = /*value*/
      ctx[19];
      if (dirty & /*section*/
      1) textinput_changes.onSaveChange = func_12;
      if (dirty & /*$context, section*/
      5) textinput_changes.disabled = !/*$context*/
      ctx[2].editable || /*column*/
      ctx[16].property === "quantity" && /*$context*/
      ctx[2].lockItemQuantity;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_2$i(ctx) {
  let current_block_type_index;
  let if_block;
  let t2;
  let current;
  const if_block_creators = [create_if_block_3$j, create_else_block$x];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*column*/
      ctx2[16].editable && !/*item*/
      ctx2[12].id
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      t2 = space();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t2.parentNode, t2);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block_1$8(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: (
        /*baseWidths*/
        ctx[3][
          /*column*/
          ctx[16].property
        ] ?? "3.125rem"
      ),
      $$slots: { default: [create_default_slot_2$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*section*/
      1) itemtablecell_changes.baseWidth = /*baseWidths*/
      ctx2[3][
        /*column*/
        ctx2[16].property
      ] ?? "3.125rem";
      if (dirty & /*$$scope, section, $context*/
      16777221) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_if_block_1$y(ctx) {
  let itemtablecell;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      baseWidth: classicControlsEditableRowBaseWidth,
      $$slots: { default: [create_default_slot_1$n] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, controls, section*/
      16777219) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablecell, detaching);
    }
  };
}
function create_default_slot_1$n(ctx) {
  let classiccontrols;
  let current;
  classiccontrols = new ClassicControls({
    props: {
      controls: (
        /*controls*/
        ctx[1]
      ),
      params: {
        item: (
          /*item*/
          ctx[12]
        ),
        index: (
          /*index*/
          ctx[15]
        ),
        section: (
          /*section*/
          ctx[0]
        )
      }
    }
  });
  return {
    c() {
      create_component(classiccontrols.$$.fragment);
    },
    m(target, anchor) {
      mount_component(classiccontrols, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const classiccontrols_changes = {};
      if (dirty & /*controls*/
      2) classiccontrols_changes.controls = /*controls*/
      ctx2[1];
      if (dirty & /*section*/
      1) classiccontrols_changes.params = {
        item: (
          /*item*/
          ctx2[12]
        ),
        index: (
          /*index*/
          ctx2[15]
        ),
        section: (
          /*section*/
          ctx2[0]
        )
      };
      classiccontrols.$set(classiccontrols_changes);
    },
    i(local) {
      if (current) return;
      transition_in(classiccontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(classiccontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(classiccontrols, detaching);
    }
  };
}
function create_default_slot$S(ctx) {
  let itemtablecell;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  itemtablecell = new ItemTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_3$i] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*section*/
    ctx[0].columns && create_if_block_2$q(ctx)
  );
  let if_block1 = (
    /*$context*/
    ctx[2].editable && /*$context*/
    ctx[2].unlocked && create_if_block_1$y(ctx)
  );
  return {
    c() {
      create_component(itemtablecell.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemtablecell, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablecell_changes = {};
      if (dirty & /*$$scope, section, $context*/
      16777221) {
        itemtablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtablecell.$set(itemtablecell_changes);
      if (
        /*section*/
        ctx2[0].columns
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*section*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$q(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].editable && /*$context*/
        ctx2[2].unlocked
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$y(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemtablecell.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(itemtablecell.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block1_anchor);
      }
      destroy_component(itemtablecell, detaching);
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
    }
  };
}
function create_each_block$m(key_1, ctx) {
  let first;
  let itemtablerow;
  let current;
  itemtablerow = new ItemTableRow({
    props: {
      $$slots: { default: [create_default_slot$S] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(itemtablerow.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(itemtablerow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itemtablerow_changes = {};
      if (dirty & /*$$scope, controls, section, $context*/
      16777223) {
        itemtablerow_changes.$$scope = { dirty, ctx };
      }
      itemtablerow.$set(itemtablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(itemtablerow, detaching);
    }
  };
}
function create_if_block$V(ctx) {
  let itemtablefooter;
  let current;
  itemtablefooter = new ItemTableFooter({
    props: {
      actor: (
        /*$context*/
        ctx[2].actor
      ),
      section: (
        /*section*/
        ctx[0]
      ),
      create: (
        /*func_2*/
        ctx[10]
      ),
      isItem: (
        /*section*/
        ctx[0].dataset.type !== "crew" && /*section*/
        ctx[0].dataset.type !== "passengers"
      )
    }
  });
  return {
    c() {
      create_component(itemtablefooter.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtablefooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemtablefooter_changes = {};
      if (dirty & /*$context*/
      4) itemtablefooter_changes.actor = /*$context*/
      ctx2[2].actor;
      if (dirty & /*section*/
      1) itemtablefooter_changes.section = /*section*/
      ctx2[0];
      if (dirty & /*section*/
      1) itemtablefooter_changes.create = /*func_2*/
      ctx2[10];
      if (dirty & /*section*/
      1) itemtablefooter_changes.isItem = /*section*/
      ctx2[0].dataset.type !== "crew" && /*section*/
      ctx2[0].dataset.type !== "passengers";
      itemtablefooter.$set(itemtablefooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtablefooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtablefooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtablefooter, detaching);
    }
  };
}
function create_body_slot$2(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let if_block_anchor;
  let current;
  let each_value = ensure_array_like(
    /*section*/
    ctx[0].items
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[12].id ?? /*index*/
    ctx2[15]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$m(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$m(key, child_ctx));
  }
  let if_block = (
    /*$context*/
    ctx[2].unlocked && /*section*/
    ctx[0].dataset && create_if_block$V(ctx)
  );
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*classicControlsEditableRowBaseWidth, controls, section, $context, baseWidths, saveNonItemSectionData*/
      47) {
        each_value = ensure_array_like(
          /*section*/
          ctx2[0].items
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t2.parentNode, outro_and_destroy_block, create_each_block$m, t2, get_each_context$m);
        check_outros();
      }
      if (
        /*$context*/
        ctx2[2].unlocked && /*section*/
        ctx2[0].dataset
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context, section*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$V(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$22(ctx) {
  let itemtable;
  let current;
  itemtable = new ItemTable({
    props: {
      key: (
        /*section*/
        ctx[0].key
      ),
      $$slots: {
        body: [create_body_slot$2],
        header: [create_header_slot$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemtable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemtable, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemtable_changes = {};
      if (dirty & /*section*/
      1) itemtable_changes.key = /*section*/
      ctx2[0].key;
      if (dirty & /*$$scope, $context, section, controls*/
      16777223) {
        itemtable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemtable.$set(itemtable_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemtable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemtable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemtable, detaching);
    }
  };
}
const classicControlsEditableRowBaseWidth = "1.5rem";
function instance$22($$self, $$props, $$invalidate) {
  let $context;
  let { section } = $$props;
  let baseWidths = {
    quantity: "5rem",
    price: "4.375rem",
    weight: "3.75rem"
  };
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  function saveNonItemSectionData(ev, index, field, section2) {
    const cargo = foundry.utils.deepClone($context.actor.system.cargo[section2.dataset.type]);
    const value = ev.currentTarget.value;
    const item = cargo[index];
    if (item) {
      item[field] = ev.currentTarget.type === "number" ? Number(value) : value;
      $context.actor.update({
        [`system.cargo.${section2.dataset.type}`]: cargo
      });
    }
    return false;
  }
  function deleteCrewOrPassenger(section2, index) {
    const cargo = foundry.utils.deepClone($context.actor.system.cargo[section2.dataset.type]).filter((_, i2) => i2 !== index);
    $context.actor.update({
      [`system.cargo.${section2.dataset.type}`]: cargo
    });
    return false;
  }
  async function onItemCreate(type) {
    const actor = $context.actor;
    const cargo = foundry.utils.deepClone(actor.system.cargo[type]);
    cargo.push(FoundryAdapter.getNewCargo());
    return actor.update({ [`system.cargo.${type}`]: cargo });
  }
  let controls = [];
  const localize = FoundryAdapter.localize;
  const func2 = (index, ev) => saveNonItemSectionData(ev, index, "name", section);
  const func_12 = (index, column, ev) => saveNonItemSectionData(ev, index, column.property, section);
  const func_2 = () => onItemCreate(section.dataset.type);
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2) $$invalidate(0, section = $$props2.section);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, controls*/
    6) {
      {
        $$invalidate(1, controls = []);
        if ($context.unlocked) {
          controls.push({
            component: ItemDeleteControl,
            props: ({ item, index, section: section2 }) => ({
              onDelete: () => deleteCrewOrPassenger(section2, index),
              item
            })
          });
        }
      }
    }
  };
  return [
    section,
    controls,
    $context,
    baseWidths,
    context,
    saveNonItemSectionData,
    onItemCreate,
    localize,
    func2,
    func_12,
    func_2
  ];
}
class PassengerOrCrewList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$22, create_fragment$22, safe_not_equal, { section: 0 });
  }
}
function get_each_context$l(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_if_block_3$i(ctx) {
  let notice;
  let current;
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot_1$m] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & /*$$scope*/
      256) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current) return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_default_slot_1$m(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("TIDY5E.EmptySection") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$x(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$p, create_else_block$w];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*section*/
      ctx2[5].editableName
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$w(ctx) {
  let cargolist;
  let current;
  cargolist = new CargoList({ props: { section: (
    /*section*/
    ctx[5]
  ) } });
  return {
    c() {
      create_component(cargolist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cargolist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cargolist_changes = {};
      if (dirty & /*$context*/
      1) cargolist_changes.section = /*section*/
      ctx2[5];
      cargolist.$set(cargolist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(cargolist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cargolist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cargolist, detaching);
    }
  };
}
function create_if_block_2$p(ctx) {
  let passengerorcrewlist;
  let current;
  passengerorcrewlist = new PassengerOrCrewList({ props: { section: (
    /*section*/
    ctx[5]
  ) } });
  return {
    c() {
      create_component(passengerorcrewlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(passengerorcrewlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const passengerorcrewlist_changes = {};
      if (dirty & /*$context*/
      1) passengerorcrewlist_changes.section = /*section*/
      ctx2[5];
      passengerorcrewlist.$set(passengerorcrewlist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(passengerorcrewlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(passengerorcrewlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(passengerorcrewlist, detaching);
    }
  };
}
function create_each_block$l(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    (ctx[0].unlocked || /*section*/
    ctx[5].items.length) && create_if_block_1$x(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*$context*/
        ctx[0].unlocked || /*section*/
        ctx[5].items.length
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$x(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block$U(ctx) {
  let encumbrancebar;
  let current;
  encumbrancebar = new EncumbranceBar({});
  return {
    c() {
      create_component(encumbrancebar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(encumbrancebar, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(encumbrancebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(encumbrancebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(encumbrancebar, detaching);
    }
  };
}
function create_default_slot$R(ctx) {
  let div;
  let currency;
  let t2;
  let if_block_anchor;
  let current;
  currency = new Currency({
    props: { document: (
      /*$context*/
      ctx[0].actor
    ) }
  });
  let if_block = (
    /*$settingStore*/
    ctx[2].useVehicleEncumbranceBar && create_if_block$U()
  );
  return {
    c() {
      div = element("div");
      create_component(currency.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "currency");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(currency, div, null);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const currency_changes = {};
      if (dirty & /*$context*/
      1) currency_changes.document = /*$context*/
      ctx2[0].actor;
      currency.$set(currency_changes);
      if (
        /*$settingStore*/
        ctx2[2].useVehicleEncumbranceBar
      ) {
        if (if_block) {
          if (dirty & /*$settingStore*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$U();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(currency.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(currency.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(currency);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$21(ctx) {
  let t0;
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let tabfooter;
  let current;
  let if_block = (
    /*noCargoOrCrew*/
    ctx[1] && !/*$context*/
    ctx[0].unlocked && create_if_block_3$i(ctx)
  );
  let each_value = ensure_array_like(
    /*$context*/
    ctx[0].cargo
  );
  const get_key = (ctx2) => (
    /*section*/
    ctx2[5].key
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$l(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$l(key, child_ctx));
  }
  tabfooter = new TabFooter({
    props: {
      mode: "vertical",
      $$slots: { default: [create_default_slot$R] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      if (if_block) if_block.c();
      t0 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(tabfooter.$$.fragment);
      attr(div, "class", "scroll-container flex-column small-gap");
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      insert(target, t1, anchor);
      mount_component(tabfooter, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*noCargoOrCrew*/
        ctx2[1] && !/*$context*/
        ctx2[0].unlocked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*noCargoOrCrew, $context*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$i(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*$context*/
      1) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[0].cargo
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$l, null, get_each_context$l);
        check_outros();
      }
      const tabfooter_changes = {};
      if (dirty & /*$$scope, $settingStore, $context*/
      261) {
        tabfooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabfooter.$set(tabfooter_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(tabfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(tabfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t1);
      }
      if (if_block) if_block.d(detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      destroy_component(tabfooter, detaching);
    }
  };
}
function instance$21($$self, $$props, $$invalidate) {
  let noCargoOrCrew;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, noCargoOrCrew = $context.cargo.some((section) => section.items.length > 0) === false);
    }
  };
  return [$context, noCargoOrCrew, $settingStore, context, localize];
}
class VehicleCargoAndCrewTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$21, create_fragment$21, safe_not_equal, {});
  }
}
function create_default_slot$Q(ctx) {
  let article;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].biographyHTML
      ),
      target: "system.details.biography.value",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      create_component(sheeteditor.$$.fragment);
      attr(article, "class", "biography-notes");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].biographyHTML;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$20(ctx) {
  let div;
  let rerenderafterformsubmission;
  let current;
  rerenderafterformsubmission = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.biography.value
      ),
      $$slots: { default: [create_default_slot$Q] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(rerenderafterformsubmission.$$.fragment);
      attr(div, "class", "note-entries svelte-1u4yr9j");
      attr(div, "data-tidy-track-scroll-y", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(rerenderafterformsubmission, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rerenderafterformsubmission_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.biography.value;
      if (dirty & /*$$scope, $context*/
      5) {
        rerenderafterformsubmission_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission.$set(rerenderafterformsubmission_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rerenderafterformsubmission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rerenderafterformsubmission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(rerenderafterformsubmission);
    }
  };
}
function instance$20($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  return [$context, context];
}
class VehicleDescriptionTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$20, create_fragment$20, safe_not_equal, {});
  }
}
class VehicleSheetRuntime {
  static _content = [];
  static _tabs = [
    {
      title: "TIDY5E.Actions.TabName",
      content: {
        component: ActorActionsTab,
        type: "svelte"
      },
      id: CONSTANTS.TAB_ACTOR_ACTIONS,
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_VEHICLE_ATTRIBUTES,
      title: "DND5E.Attributes",
      content: {
        component: VehicleAttributesTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_VEHICLE_CARGO_AND_CREW,
      title: "DND5E.VehicleCargoCrew",
      content: {
        component: VehicleCargoAndCrewTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_NPC_EFFECTS,
      title: "DND5E.Effects",
      content: {
        component: ActorEffectsTab,
        type: "svelte"
      },
      layout: "classic"
    },
    {
      id: CONSTANTS.TAB_VEHICLE_DESCRIPTION,
      title: "DND5E.Description",
      content: {
        component: VehicleDescriptionTab,
        type: "svelte"
      },
      layout: "classic"
    }
  ];
  static async getContent(context) {
    return await CustomContentManager.prepareContentForRender(
      context,
      VehicleSheetRuntime._content
    );
  }
  static getTabs(context) {
    return TabManager.prepareTabsForRender(context, VehicleSheetRuntime._tabs);
  }
  static getAllRegisteredTabs() {
    return [...VehicleSheetRuntime._tabs];
  }
  static registerContent(registeredContent) {
    this._content.push(registeredContent);
  }
  static registerTab(tab, options) {
    const tabExists = VehicleSheetRuntime._tabs.some((t2) => t2.id === tab.id);
    if (tabExists) {
      warn(`Tab with id ${tab.id} already exists.`);
      return;
    }
    if (tabExists && options?.overrideExisting) {
      const index = VehicleSheetRuntime._tabs.findIndex((t2) => t2.id === tab.id);
      if (index >= 0) {
        VehicleSheetRuntime._tabs.splice(index, 1);
      }
    }
    VehicleSheetRuntime._tabs.push(tab);
  }
  static getTabTitle(tabId) {
    try {
      let tabTitle = this._tabs.find((t2) => t2.id === tabId)?.title;
      if (typeof tabTitle === "function") {
        tabTitle = tabTitle();
      }
      return tabTitle ? FoundryAdapter.localize(tabTitle) : tabId;
    } catch (e2) {
      error("An error occurred while searching for a tab title.", false, e2);
      debug("Tab title error troubleshooting information", { tabId });
    }
  }
}
class WorldSettingsFormApplication extends SvelteFormApplicationBase {
  unchangedSettings;
  static get defaultOptions() {
    return {
      ...super.defaultOptions,
      height: 750,
      title: "TIDY5E.WorldSettings.Menu.title",
      width: 750,
      classes: [...super.defaultOptions.classes, "settings"],
      id: "tidy-5e-sheets-world-settings",
      popOut: true
    };
  }
  get template() {
    return FoundryAdapter.getTemplate("empty-form-template.hbs");
  }
  getData() {
    const currentSettings = getCurrentSettings();
    return {
      settings: {
        hideDeathSavesFromPlayers: currentSettings.hideDeathSavesFromPlayers,
        useCharacterEncumbranceBar: currentSettings.useCharacterEncumbranceBar,
        useNpcEncumbranceBar: currentSettings.useNpcEncumbranceBar,
        useVehicleEncumbranceBar: currentSettings.useVehicleEncumbranceBar,
        showPlayerName: currentSettings.showPlayerName,
        showExpandedLimitedView: currentSettings.showExpandedLimitedView,
        itemCardsFixKey: currentSettings.itemCardsFixKey,
        useCircularPortraitStyle: currentSettings.useCircularPortraitStyle,
        permanentlyUnlockCharacterSheetForGm: currentSettings.permanentlyUnlockCharacterSheetForGm,
        permanentlyUnlockNpcSheetForGm: currentSettings.permanentlyUnlockNpcSheetForGm,
        permanentlyUnlockVehicleSheetForGm: currentSettings.permanentlyUnlockVehicleSheetForGm,
        limitEffectsManagementToGm: currentSettings.limitEffectsManagementToGm,
        useCharacterInspiration: currentSettings.useCharacterInspiration,
        useVehicleMotion: currentSettings.useVehicleMotion,
        useExhaustion: currentSettings.useExhaustion,
        showTraitLabels: currentSettings.showTraitLabels,
        allowCantripsToBePrepared: currentSettings.allowCantripsToBePrepared,
        allowHpMaxOverride: currentSettings.allowHpMaxOverride,
        showActiveEffectsMarker: currentSettings.showActiveEffectsMarker,
        useTotalSheetLock: currentSettings.useTotalSheetLock,
        lockExpChanges: currentSettings.lockExpChanges,
        lockHpMaxChanges: currentSettings.lockHpMaxChanges,
        lockConfigureSheet: currentSettings.lockConfigureSheet,
        lockMoneyChanges: currentSettings.lockMoneyChanges,
        lockLevelSelector: currentSettings.lockLevelSelector,
        lockItemQuantity: currentSettings.lockItemQuantity,
        initialNpcSheetTab: currentSettings.initialNpcSheetTab,
        showNpcRestInChat: currentSettings.showNpcRestInChat,
        showNpcActorLinkMarker: currentSettings.showNpcActorLinkMarker,
        initialCharacterSheetTab: currentSettings.initialCharacterSheetTab,
        initialVehicleSheetTab: currentSettings.initialVehicleSheetTab,
        itemIdentificationPermission: currentSettings.itemIdentificationPermission,
        includeFlagsInSpellScrollCreation: currentSettings.includeFlagsInSpellScrollCreation,
        useTidySpellSchoolIcons: currentSettings.useTidySpellSchoolIcons
      },
      defaultCharacterTabs: this.mapTabSelectionFields(
        CharacterSheetRuntime.getAllRegisteredTabs(),
        currentSettings.defaultCharacterSheetTabs
      ),
      defaultNpcTabs: this.mapTabSelectionFields(
        NpcSheetRuntime.getAllRegisteredTabs(),
        currentSettings.defaultNpcSheetTabs
      ),
      defaultVehicleTabs: this.mapTabSelectionFields(
        VehicleSheetRuntime.getAllRegisteredTabs(),
        currentSettings.defaultVehicleSheetTabs
      ),
      exhaustionConfig: {
        ...SettingsProvider.settings.exhaustionConfig.options.default,
        ...currentSettings.exhaustionConfig
      },
      vehicleExhaustionConfig: {
        ...SettingsProvider.settings.vehicleExhaustionConfig.options.default,
        ...currentSettings.vehicleExhaustionConfig
      }
    };
  }
  createComponent(node) {
    const data = this.getData();
    debug("World Settings context data", data);
    return new WorldSettings({
      target: node,
      context: /* @__PURE__ */ new Map([
        ["context", writable(data)],
        [
          "functions",
          {
            save: this.saveChangedSettings.bind(this),
            apply: this.applyChangedSettings.bind(this),
            resetDefaultTabs: this.resetDefaultTabs.bind(this)
          }
        ],
        ["appId", this.appId]
      ])
    });
  }
  mapTabSelectionFields(registeredTabs, selectedTabIds) {
    const available = registeredTabs.filter((t2) => !selectedTabIds.includes(t2.id)).map((t2) => ({
      id: t2.id,
      label: FoundryAdapter.localize(TabManager.getTabTitle(t2))
    }));
    const selected = registeredTabs.filter((t2) => selectedTabIds.includes(t2.id)).sort(
      (a2, b2) => selectedTabIds.indexOf(a2.id) - selectedTabIds.indexOf(b2.id)
    ).map((t2) => ({
      id: t2.id,
      label: FoundryAdapter.localize(TabManager.getTabTitle(t2))
    }));
    return {
      available,
      selected
    };
  }
  validate(context) {
    let valid = true;
    if (context.defaultCharacterTabs.selected.length === 0 || context.defaultNpcTabs.selected.length === 0 || context.defaultVehicleTabs.selected.length === 0) {
      valid = false;
      error(
        FoundryAdapter.localize(
          "TIDY5E.Settings.DefaultSheetTabs.AtLeastOneTabRequiredErrorMessage"
        ),
        true
      );
    }
    if (context.exhaustionConfig.type === "specific" && context.exhaustionConfig.levels < 1) {
      valid = false;
      error(
        FoundryAdapter.localize(
          "TIDY5E.WorldSettings.Exhaustion.AtLeastOneLevelRequiredErrorMessage"
        ),
        true
      );
    }
    if (context.vehicleExhaustionConfig.type === "specific" && context.vehicleExhaustionConfig.levels < 1) {
      valid = false;
      error(
        FoundryAdapter.localize(
          "TIDY5E.WorldSettings.VehicleExhaustion.AtLeastOneLevelRequiredErrorMessage"
        ),
        true
      );
    }
    return valid;
  }
  async applyChangedSettings(context) {
    if (!this.validate(context)) {
      return false;
    }
    if (context.exhaustionConfig.type === "specific") {
      context.exhaustionConfig.hints = context.exhaustionConfig.hints.slice(
        0,
        context.exhaustionConfig.levels + 1
      );
    }
    if (context.vehicleExhaustionConfig.type === "specific") {
      context.vehicleExhaustionConfig.hints = context.vehicleExhaustionConfig.hints.slice(
        0,
        context.vehicleExhaustionConfig.levels + 1
      );
    }
    const newSettings = {
      ...context.settings,
      defaultCharacterSheetTabs: context.defaultCharacterTabs.selected.map(
        (t2) => t2.id
      ),
      defaultNpcSheetTabs: context.defaultNpcTabs.selected.map((t2) => t2.id),
      defaultVehicleSheetTabs: context.defaultVehicleTabs.selected.map(
        (t2) => t2.id
      ),
      exhaustionConfig: context.exhaustionConfig,
      vehicleExhaustionConfig: context.vehicleExhaustionConfig
    };
    const currentSettings = getCurrentSettings();
    const keys = Object.keys(newSettings);
    for (let key of keys) {
      const currentValue = currentSettings[key];
      const newValue = newSettings[key];
      if (currentValue !== newValue) {
        await FoundryAdapter.setTidySetting(key, newValue);
        debug(`Updated ${key} to ${newValue}`);
      }
    }
    return true;
  }
  async saveChangedSettings(context) {
    const changesApplied = await this.applyChangedSettings(context);
    if (!changesApplied) {
      return;
    }
    this.close();
  }
  resetDefaultTabs(store, actorType) {
    switch (actorType) {
      case CONSTANTS.SHEET_TYPE_CHARACTER:
        store.update((context) => {
          context.defaultCharacterTabs = this.mapTabSelectionFields(
            CharacterSheetRuntime.getAllRegisteredTabs(),
            [
              ...SettingsProvider.settings.defaultCharacterSheetTabs.options.default
            ]
          );
          return context;
        });
        break;
      case CONSTANTS.SHEET_TYPE_NPC:
        store.update((context) => {
          context.defaultNpcTabs = this.mapTabSelectionFields(
            NpcSheetRuntime.getAllRegisteredTabs(),
            [...SettingsProvider.settings.defaultNpcSheetTabs.options.default]
          );
          return context;
        });
        break;
      case CONSTANTS.SHEET_TYPE_VEHICLE:
        store.update((context) => {
          context.defaultVehicleTabs = this.mapTabSelectionFields(
            VehicleSheetRuntime.getAllRegisteredTabs(),
            [
              ...SettingsProvider.settings.defaultVehicleSheetTabs.options.default
            ]
          );
          return context;
        });
        break;
    }
  }
}
function get_each_context$k(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2][0];
  child_ctx[7] = list[i2][1];
  return child_ctx;
}
function create_each_block$k(ctx) {
  let option;
  let t_value = (
    /*localize*/
    ctx[4](
      /*value*/
      ctx[7]
    ) + ""
  );
  let t2;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = /*key*/
      ctx[6];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot$P(ctx) {
  let label;
  let t0_value = (
    /*localize*/
    ctx[4]("TIDY5E.SheetMenu.themeLabel") + ""
  );
  let t0;
  let t1;
  let select;
  let select_value_value;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*themes*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$k(get_each_context$k(ctx, each_value, i2));
  }
  return {
    c() {
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(label, "class", "theme-label svelte-r5xyb9");
      attr(label, "for", "sheet-menu-" + /*idSuffix*/
      ctx[2]);
      attr(select, "id", "sheet-menu-" + /*idSuffix*/
      ctx[2]);
      attr(select, "class", "svelte-r5xyb9");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t0);
      insert(target, t1, anchor);
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select, null);
        }
      }
      select_option(
        select,
        /*$settingStore*/
        ctx[0].colorScheme
      );
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*change_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*themes, localize*/
      18) {
        each_value = ensure_array_like(
          /*themes*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$k(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$k(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$settingStore, themes*/
      3 && select_value_value !== (select_value_value = /*$settingStore*/
      ctx2[0].colorScheme)) {
        select_option(
          select,
          /*$settingStore*/
          ctx2[0].colorScheme
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(label);
        detach(t1);
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1$(ctx) {
  let buttonmenuitem;
  let current;
  buttonmenuitem = new ButtonMenuItem({
    props: {
      cssClass: "flex-column extra-small-gap",
      $$slots: { default: [create_default_slot$P] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(buttonmenuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenuitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const buttonmenuitem_changes = {};
      if (dirty & /*$$scope, $settingStore*/
      1025) {
        buttonmenuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenuitem.$set(buttonmenuitem_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenuitem, detaching);
    }
  };
}
function instance$1$($$self, $$props, $$invalidate) {
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(0, $settingStore = $$value));
  const themes = Object.entries(getCoreThemes(true));
  const idSuffix = Date.now().toString();
  function setTheme(value) {
    FoundryAdapter.setTidySetting("colorScheme", value);
  }
  const localize = FoundryAdapter.localize;
  const change_handler = (ev) => setTheme(ev.currentTarget.value);
  return [$settingStore, themes, idSuffix, setTheme, localize, change_handler];
}
class ThemeSelectorButtonMenuCommand extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1$, create_fragment$1$, safe_not_equal, {});
  }
}
function create_default_slot_4$e(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("TIDY5E.ThemeSettings.Sheet.import") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$h(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("TIDY5E.ThemeSettings.Sheet.export") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$h(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("TIDY5E.ThemeSettings.Sheet.useDefaultLightColors") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$l(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("TIDY5E.ThemeSettings.Sheet.useDefaultDarkColors") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$O(ctx) {
  let themeselectorbuttonmenucommand;
  let t0;
  let buttonmenudivider;
  let t1;
  let buttonmenucommand0;
  let t2;
  let buttonmenucommand1;
  let t3;
  let buttonmenucommand2;
  let t4;
  let buttonmenucommand3;
  let current;
  themeselectorbuttonmenucommand = new ThemeSelectorButtonMenuCommand({});
  buttonmenudivider = new ButtonMenuDivider({});
  buttonmenucommand0 = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-file-import",
      $$slots: { default: [create_default_slot_4$e] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand0.$on(
    "click",
    /*click_handler*/
    ctx[6]
  );
  buttonmenucommand1 = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-file-export",
      $$slots: { default: [create_default_slot_3$h] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand1.$on(
    "click",
    /*click_handler_1*/
    ctx[7]
  );
  buttonmenucommand2 = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-sun",
      $$slots: { default: [create_default_slot_2$h] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand2.$on(
    "click",
    /*click_handler_2*/
    ctx[8]
  );
  buttonmenucommand3 = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-moon",
      $$slots: { default: [create_default_slot_1$l] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand3.$on(
    "click",
    /*click_handler_3*/
    ctx[9]
  );
  return {
    c() {
      create_component(themeselectorbuttonmenucommand.$$.fragment);
      t0 = space();
      create_component(buttonmenudivider.$$.fragment);
      t1 = space();
      create_component(buttonmenucommand0.$$.fragment);
      t2 = space();
      create_component(buttonmenucommand1.$$.fragment);
      t3 = space();
      create_component(buttonmenucommand2.$$.fragment);
      t4 = space();
      create_component(buttonmenucommand3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themeselectorbuttonmenucommand, target, anchor);
      insert(target, t0, anchor);
      mount_component(buttonmenudivider, target, anchor);
      insert(target, t1, anchor);
      mount_component(buttonmenucommand0, target, anchor);
      insert(target, t2, anchor);
      mount_component(buttonmenucommand1, target, anchor);
      insert(target, t3, anchor);
      mount_component(buttonmenucommand2, target, anchor);
      insert(target, t4, anchor);
      mount_component(buttonmenucommand3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const buttonmenucommand0_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        buttonmenucommand0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand0.$set(buttonmenucommand0_changes);
      const buttonmenucommand1_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        buttonmenucommand1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand1.$set(buttonmenucommand1_changes);
      const buttonmenucommand2_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        buttonmenucommand2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand2.$set(buttonmenucommand2_changes);
      const buttonmenucommand3_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        buttonmenucommand3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand3.$set(buttonmenucommand3_changes);
    },
    i(local) {
      if (current) return;
      transition_in(themeselectorbuttonmenucommand.$$.fragment, local);
      transition_in(buttonmenudivider.$$.fragment, local);
      transition_in(buttonmenucommand0.$$.fragment, local);
      transition_in(buttonmenucommand1.$$.fragment, local);
      transition_in(buttonmenucommand2.$$.fragment, local);
      transition_in(buttonmenucommand3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themeselectorbuttonmenucommand.$$.fragment, local);
      transition_out(buttonmenudivider.$$.fragment, local);
      transition_out(buttonmenucommand0.$$.fragment, local);
      transition_out(buttonmenucommand1.$$.fragment, local);
      transition_out(buttonmenucommand2.$$.fragment, local);
      transition_out(buttonmenucommand3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
      }
      destroy_component(themeselectorbuttonmenucommand, detaching);
      destroy_component(buttonmenudivider, detaching);
      destroy_component(buttonmenucommand0, detaching);
      destroy_component(buttonmenucommand1, detaching);
      destroy_component(buttonmenucommand2, detaching);
      destroy_component(buttonmenucommand3, detaching);
    }
  };
}
function create_fragment$1_(ctx) {
  let buttonmenu;
  let t2;
  let input;
  let current;
  let mounted;
  let dispose;
  buttonmenu = new ButtonMenu({
    props: {
      iconClass: {
        opened: "fas fa-caret-up",
        closed: "fas fa-caret-down"
      },
      position: "bottom",
      anchor: "right",
      openerPadding: "0.125rem 0.5rem",
      buttonText: (
        /*localize*/
        ctx[4]("TIDY5E.ThemeSettings.Sheet.menuLabel")
      ),
      $$slots: { default: [create_default_slot$O] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(buttonmenu.$$.fragment);
      t2 = space();
      input = element("input");
      attr(input, "class", "theme-import-input svelte-agyjx4");
      attr(input, "type", "file");
      attr(input, "accept", CONSTANTS.THEME_EXTENSION_WITH_DOT);
    },
    m(target, anchor) {
      mount_component(buttonmenu, target, anchor);
      insert(target, t2, anchor);
      insert(target, input, anchor);
      ctx[10](input);
      current = true;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*onFileChanged*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const buttonmenu_changes = {};
      if (dirty & /*$$scope, $context, fileImportInput*/
      4099) {
        buttonmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenu.$set(buttonmenu_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(input);
      }
      destroy_component(buttonmenu, detaching);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$1_($$self, $$props, $$invalidate) {
  let $context;
  let functions = getContext(CONSTANTS.SVELTE_CONTEXT.FUNCTIONS);
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const dispatch2 = createEventDispatcher();
  let fileImportInput;
  const localize = FoundryAdapter.localize;
  function onFileChanged(ev) {
    const file = ev.currentTarget.files?.[0];
    ev.currentTarget.value = "";
    if (!file) {
      return;
    }
    dispatch2("selectFile", file);
  }
  const click_handler = () => fileImportInput.click();
  const click_handler_1 = () => functions.exportTheme($context);
  const click_handler_2 = () => functions.useExistingThemeColors(CONSTANTS.THEME_ID_DEFAULT_LIGHT);
  const click_handler_3 = () => functions.useExistingThemeColors(CONSTANTS.THEME_ID_DEFAULT_DARK);
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileImportInput = $$value;
      $$invalidate(0, fileImportInput);
    });
  }
  return [
    fileImportInput,
    $context,
    functions,
    context,
    localize,
    onFileChanged,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    input_binding
  ];
}
class ThemeSettingSheetMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1_, create_fragment$1_, safe_not_equal, {});
  }
}
function create_if_block$T(ctx) {
  let input;
  return {
    c() {
      input = element("input");
      attr(input, "type", "hidden");
      attr(
        input,
        "name",
        /*name*/
        ctx[3]
      );
      input.value = /*value*/
      ctx[0];
    },
    m(target, anchor) {
      insert(target, input, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      8) {
        attr(
          input,
          "name",
          /*name*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      1) {
        input.value = /*value*/
        ctx2[0];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
    }
  };
}
function create_fragment$1Z(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let div2_aria_valuetext_value;
  let t1;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = (
    /*name*/
    ctx[3] && create_if_block$T(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "track svelte-pjqaqp");
      attr(div1, "class", "thumb svelte-pjqaqp");
      attr(div2, "class", "slider svelte-pjqaqp");
      attr(div2, "role", "slider");
      attr(
        div2,
        "aria-orientation",
        /*direction*/
        ctx[4]
      );
      attr(
        div2,
        "aria-valuemax",
        /*_max*/
        ctx[11]
      );
      attr(
        div2,
        "aria-valuemin",
        /*_min*/
        ctx[10]
      );
      attr(
        div2,
        "aria-valuenow",
        /*value*/
        ctx[0]
      );
      attr(div2, "aria-valuetext", div2_aria_valuetext_value = /*ariaValueText*/
      ctx[2](
        /*value*/
        ctx[0]
      ));
      attr(
        div2,
        "aria-label",
        /*ariaLabel*/
        ctx[7]
      );
      attr(
        div2,
        "aria-labelledby",
        /*ariaLabelledBy*/
        ctx[8]
      );
      attr(
        div2,
        "aria-controls",
        /*ariaControls*/
        ctx[9]
      );
      attr(div2, "tabindex", "0");
      toggle_class(
        div2,
        "reverse",
        /*reverse*/
        ctx[5]
      );
      set_style(
        div2,
        "--position",
        /*position*/
        ctx[12]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      ctx[22](div2);
      insert(target, t1, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(
            window,
            "mousemove",
            /*drag*/
            ctx[15]
          ),
          listen(
            window,
            "mouseup",
            /*endDrag*/
            ctx[16]
          ),
          listen(
            div2,
            "keydown",
            /*keyHandler*/
            ctx[13]
          ),
          listen(div2, "mousedown", self(function() {
            if (is_function(
              /*keyboardOnly*/
              ctx[6] ? void 0 : (
                /*jump*/
                ctx[14]
              )
            )) /*keyboardOnly*/
            (ctx[6] ? void 0 : (
              /*jump*/
              ctx[14]
            )).apply(this, arguments);
          })),
          listen(
            div2,
            "touchstart",
            prevent_default(function() {
              if (is_function(
                /*keyboardOnly*/
                ctx[6] ? void 0 : (
                  /*touch*/
                  ctx[17]
                )
              )) /*keyboardOnly*/
              (ctx[6] ? void 0 : (
                /*touch*/
                ctx[17]
              )).apply(this, arguments);
            }),
            { passive: false }
          ),
          listen(
            div2,
            "touchmove",
            prevent_default(function() {
              if (is_function(
                /*keyboardOnly*/
                ctx[6] ? void 0 : (
                  /*touch*/
                  ctx[17]
                )
              )) /*keyboardOnly*/
              (ctx[6] ? void 0 : (
                /*touch*/
                ctx[17]
              )).apply(this, arguments);
            }),
            { passive: false }
          ),
          listen(
            div2,
            "touchend",
            prevent_default(function() {
              if (is_function(
                /*keyboardOnly*/
                ctx[6] ? void 0 : (
                  /*touch*/
                  ctx[17]
                )
              )) /*keyboardOnly*/
              (ctx[6] ? void 0 : (
                /*touch*/
                ctx[17]
              )).apply(this, arguments);
            }),
            { passive: false }
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*direction*/
      16) {
        attr(
          div2,
          "aria-orientation",
          /*direction*/
          ctx[4]
        );
      }
      if (dirty & /*_max*/
      2048) {
        attr(
          div2,
          "aria-valuemax",
          /*_max*/
          ctx[11]
        );
      }
      if (dirty & /*_min*/
      1024) {
        attr(
          div2,
          "aria-valuemin",
          /*_min*/
          ctx[10]
        );
      }
      if (dirty & /*value*/
      1) {
        attr(
          div2,
          "aria-valuenow",
          /*value*/
          ctx[0]
        );
      }
      if (dirty & /*ariaValueText, value*/
      5 && div2_aria_valuetext_value !== (div2_aria_valuetext_value = /*ariaValueText*/
      ctx[2](
        /*value*/
        ctx[0]
      ))) {
        attr(div2, "aria-valuetext", div2_aria_valuetext_value);
      }
      if (dirty & /*ariaLabel*/
      128) {
        attr(
          div2,
          "aria-label",
          /*ariaLabel*/
          ctx[7]
        );
      }
      if (dirty & /*ariaLabelledBy*/
      256) {
        attr(
          div2,
          "aria-labelledby",
          /*ariaLabelledBy*/
          ctx[8]
        );
      }
      if (dirty & /*ariaControls*/
      512) {
        attr(
          div2,
          "aria-controls",
          /*ariaControls*/
          ctx[9]
        );
      }
      if (dirty & /*reverse*/
      32) {
        toggle_class(
          div2,
          "reverse",
          /*reverse*/
          ctx[5]
        );
      }
      if (dirty & /*position*/
      4096) {
        set_style(
          div2,
          "--position",
          /*position*/
          ctx[12]
        );
      }
      if (
        /*name*/
        ctx[3]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$T(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(if_block_anchor);
      }
      ctx[22](null);
      if (if_block) if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1Z($$self, $$props, $$invalidate) {
  let _min;
  let _max;
  let _step;
  let position;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { value = 50 } = $$props;
  let { ariaValueText = (current) => current.toString() } = $$props;
  let { name = void 0 } = $$props;
  let { direction = "horizontal" } = $$props;
  let { reverse = false } = $$props;
  let { keyboardOnly = false } = $$props;
  let { slider = void 0 } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { ariaLabelledBy = void 0 } = $$props;
  let { ariaControls = void 0 } = $$props;
  let { isDragging = false } = $$props;
  const dispatch2 = createEventDispatcher();
  function bound(value2) {
    const ratio = 1 / _step;
    const rounded = Math.round(value2 * ratio) / ratio;
    return Math.max(_min, Math.min(_max, rounded));
  }
  function keyHandler(e2) {
    const inc = e2.shiftKey ? _step * 10 : _step;
    if (e2.key === "ArrowUp" || e2.key === "ArrowRight") {
      $$invalidate(0, value += inc);
      e2.preventDefault();
    } else if (e2.key === "ArrowDown" || e2.key === "ArrowLeft") {
      $$invalidate(0, value -= inc);
      e2.preventDefault();
    } else if (e2.key === "Home") {
      $$invalidate(0, value = _min);
      e2.preventDefault();
    } else if (e2.key === "End") {
      $$invalidate(0, value = _max);
      e2.preventDefault();
    } else if (e2.key === "PageUp") {
      $$invalidate(0, value += _step * 10);
      e2.preventDefault();
    } else if (e2.key === "PageDown") {
      $$invalidate(0, value -= _step * 10);
      e2.preventDefault();
    }
    $$invalidate(0, value = bound(value));
    dispatch2("input", value);
  }
  const config = {
    horizontal: {
      clientSize: "clientWidth",
      offset: "left",
      client: "clientX"
    },
    vertical: {
      clientSize: "clientHeight",
      offset: "top",
      client: "clientY"
    }
  };
  function updateValue(e2) {
    const clientWidth = slider?.[config[direction].clientSize] || 120;
    const sliderOffsetX = slider?.getBoundingClientRect()[config[direction].offset] || 0;
    let offsetX = e2[config[direction].client] - sliderOffsetX;
    if (direction === "vertical") offsetX = -1 * offsetX + clientWidth;
    if (reverse) {
      $$invalidate(0, value = _max - offsetX / clientWidth * (_max - _min));
    } else {
      $$invalidate(0, value = offsetX / clientWidth * (_max - _min) + _min);
    }
    $$invalidate(0, value = bound(value));
    dispatch2("input", value);
  }
  function jump(e2) {
    updateValue(e2);
    $$invalidate(18, isDragging = true);
  }
  function drag(e2) {
    if (isDragging) updateValue(e2);
  }
  function endDrag() {
    $$invalidate(18, isDragging = false);
  }
  function touch(e2) {
    updateValue({
      clientX: e2.changedTouches[0].clientX,
      clientY: e2.changedTouches[0].clientY
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      slider = $$value;
      $$invalidate(1, slider);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("min" in $$props2) $$invalidate(19, min = $$props2.min);
    if ("max" in $$props2) $$invalidate(20, max = $$props2.max);
    if ("step" in $$props2) $$invalidate(21, step = $$props2.step);
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("ariaValueText" in $$props2) $$invalidate(2, ariaValueText = $$props2.ariaValueText);
    if ("name" in $$props2) $$invalidate(3, name = $$props2.name);
    if ("direction" in $$props2) $$invalidate(4, direction = $$props2.direction);
    if ("reverse" in $$props2) $$invalidate(5, reverse = $$props2.reverse);
    if ("keyboardOnly" in $$props2) $$invalidate(6, keyboardOnly = $$props2.keyboardOnly);
    if ("slider" in $$props2) $$invalidate(1, slider = $$props2.slider);
    if ("ariaLabel" in $$props2) $$invalidate(7, ariaLabel = $$props2.ariaLabel);
    if ("ariaLabelledBy" in $$props2) $$invalidate(8, ariaLabelledBy = $$props2.ariaLabelledBy);
    if ("ariaControls" in $$props2) $$invalidate(9, ariaControls = $$props2.ariaControls);
    if ("isDragging" in $$props2) $$invalidate(18, isDragging = $$props2.isDragging);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*min*/
    524288) {
      $$invalidate(10, _min = typeof min === "string" ? parseFloat(min) : min);
    }
    if ($$self.$$.dirty & /*max*/
    1048576) {
      $$invalidate(11, _max = typeof max === "string" ? parseFloat(max) : max);
    }
    if ($$self.$$.dirty & /*step*/
    2097152) {
      _step = typeof step === "string" ? parseFloat(step) : step;
    }
    if ($$self.$$.dirty & /*value, _min, _max*/
    3073) {
      $$invalidate(12, position = ((value - _min) / (_max - _min) * 1).toFixed(4));
    }
  };
  return [
    value,
    slider,
    ariaValueText,
    name,
    direction,
    reverse,
    keyboardOnly,
    ariaLabel,
    ariaLabelledBy,
    ariaControls,
    _min,
    _max,
    position,
    keyHandler,
    jump,
    drag,
    endDrag,
    touch,
    isDragging,
    min,
    max,
    step,
    div2_binding
  ];
}
class Slider extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Z, create_fragment$1Z, safe_not_equal, {
      min: 19,
      max: 20,
      step: 21,
      value: 0,
      ariaValueText: 2,
      name: 3,
      direction: 4,
      reverse: 5,
      keyboardOnly: 6,
      slider: 1,
      ariaLabel: 7,
      ariaLabelledBy: 8,
      ariaControls: 9,
      isDragging: 18
    });
  }
}
function create_fragment$1Y(ctx) {
  let div2;
  let switch_instance;
  let t0;
  let div0;
  let slider0;
  let updating_value;
  let t1;
  let div1;
  let slider1;
  let updating_value_1;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*components*/
    ctx[2].pickerIndicator
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        pos: (
          /*pos*/
          ctx2[6]
        ),
        isDark: (
          /*isDark*/
          ctx2[3]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  function slider0_value_binding(value) {
    ctx[13](value);
  }
  let slider0_props = {
    keyboardOnly: true,
    ariaValueText: func,
    ariaLabel: "saturation color"
  };
  if (
    /*s*/
    ctx[0] !== void 0
  ) {
    slider0_props.value = /*s*/
    ctx[0];
  }
  slider0 = new Slider({ props: slider0_props });
  binding_callbacks.push(() => bind(slider0, "value", slider0_value_binding));
  function slider1_value_binding(value) {
    ctx[14](value);
  }
  let slider1_props = {
    keyboardOnly: true,
    ariaValueText: func_1,
    direction: "vertical",
    ariaLabel: "brightness color"
  };
  if (
    /*v*/
    ctx[1] !== void 0
  ) {
    slider1_props.value = /*v*/
    ctx[1];
  }
  slider1 = new Slider({ props: slider1_props });
  binding_callbacks.push(() => bind(slider1, "value", slider1_value_binding));
  return {
    c() {
      div2 = element("div");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(slider0.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(slider1.$$.fragment);
      attr(div0, "class", "s svelte-1x9tz9y");
      set_style(
        div0,
        "--pos-y",
        /*pos*/
        ctx[6].y
      );
      attr(div1, "class", "v svelte-1x9tz9y");
      set_style(
        div1,
        "--pos-x",
        /*pos*/
        ctx[6].x
      );
      attr(div2, "class", "picker svelte-1x9tz9y");
      set_style(
        div2,
        "--picker-color-bg",
        /*pickerColorBg*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (switch_instance) mount_component(switch_instance, div2, null);
      append(div2, t0);
      append(div2, div0);
      mount_component(slider0, div0, null);
      append(div2, t1);
      append(div2, div1);
      mount_component(slider1, div1, null);
      ctx[15](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "mouseup",
            /*mouseUp*/
            ctx[8]
          ),
          listen(
            window,
            "mousedown",
            /*mouseDown*/
            ctx[10]
          ),
          listen(
            window,
            "mousemove",
            /*mouseMove*/
            ctx[9]
          ),
          listen(div2, "mousedown", prevent_default(
            /*pickerMousedown*/
            ctx[7]
          )),
          listen(
            div2,
            "touchstart",
            /*touch*/
            ctx[11],
            { passive: false }
          ),
          listen(div2, "touchmove", prevent_default(
            /*touch*/
            ctx[11]
          ), { passive: false }),
          listen(
            div2,
            "touchend",
            /*touch*/
            ctx[11],
            { passive: false }
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*components*/
      4 && switch_value !== (switch_value = /*components*/
      ctx2[2].pickerIndicator)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div2, t0);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*pos*/
        64) switch_instance_changes.pos = /*pos*/
        ctx2[6];
        if (dirty & /*isDark*/
        8) switch_instance_changes.isDark = /*isDark*/
        ctx2[3];
        switch_instance.$set(switch_instance_changes);
      }
      const slider0_changes = {};
      if (!updating_value && dirty & /*s*/
      1) {
        updating_value = true;
        slider0_changes.value = /*s*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      slider0.$set(slider0_changes);
      if (dirty & /*pos*/
      64) {
        set_style(
          div0,
          "--pos-y",
          /*pos*/
          ctx2[6].y
        );
      }
      const slider1_changes = {};
      if (!updating_value_1 && dirty & /*v*/
      2) {
        updating_value_1 = true;
        slider1_changes.value = /*v*/
        ctx2[1];
        add_flush_callback(() => updating_value_1 = false);
      }
      slider1.$set(slider1_changes);
      if (dirty & /*pos*/
      64) {
        set_style(
          div1,
          "--pos-x",
          /*pos*/
          ctx2[6].x
        );
      }
      if (dirty & /*pickerColorBg*/
      32) {
        set_style(
          div2,
          "--picker-color-bg",
          /*pickerColorBg*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      transition_in(slider0.$$.fragment, local);
      transition_in(slider1.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      transition_out(slider0.$$.fragment, local);
      transition_out(slider1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (switch_instance) destroy_component(switch_instance);
      destroy_component(slider0);
      destroy_component(slider1);
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function clamp(value, min, max) {
  return Math.min(Math.max(min, value), max);
}
const func = (value) => `${value}%`;
const func_1 = (value) => `${value}%`;
function instance$1Y($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { components } = $$props;
  let { h: h2 } = $$props;
  let { s: s2 } = $$props;
  let { v: v2 } = $$props;
  let { isDark } = $$props;
  let picker;
  let isMouseDown = false;
  let pickerColorBg;
  let pos = { x: 100, y: 0 };
  function onClick(e2) {
    const { width, left, height, top } = picker.getBoundingClientRect();
    const mouse = {
      x: clamp(e2.clientX - left, 0, width),
      y: clamp(e2.clientY - top, 0, height)
    };
    $$invalidate(0, s2 = clamp(mouse.x / width, 0, 1) * 100);
    $$invalidate(1, v2 = clamp((height - mouse.y) / height, 0, 1) * 100);
  }
  function pickerMousedown(e2) {
    if (e2.button === 0) {
      isMouseDown = true;
      onClick(e2);
    }
  }
  function mouseUp() {
    isMouseDown = false;
  }
  function mouseMove(e2) {
    if (isMouseDown) onClick(e2);
  }
  function mouseDown(e2) {
    if (!e2.target.isSameNode(picker)) ;
  }
  function touch(e2) {
    e2.preventDefault();
    onClick(e2.changedTouches[0]);
  }
  function slider0_value_binding(value) {
    s2 = value;
    $$invalidate(0, s2);
  }
  function slider1_value_binding(value) {
    v2 = value;
    $$invalidate(1, v2);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      picker = $$value;
      $$invalidate(4, picker);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("components" in $$props2) $$invalidate(2, components = $$props2.components);
    if ("h" in $$props2) $$invalidate(12, h2 = $$props2.h);
    if ("s" in $$props2) $$invalidate(0, s2 = $$props2.s);
    if ("v" in $$props2) $$invalidate(1, v2 = $$props2.v);
    if ("isDark" in $$props2) $$invalidate(3, isDark = $$props2.isDark);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*h*/
    4096) {
      if (typeof h2 === "number") $$invalidate(5, pickerColorBg = w({ h: h2, s: 100, v: 100, a: 1 }).toHex());
    }
    if ($$self.$$.dirty & /*s, v, picker*/
    19) {
      if (typeof s2 === "number" && typeof v2 === "number" && picker) $$invalidate(6, pos = { x: s2, y: 100 - v2 });
    }
    if ($$self.$$.dirty & /*s, v*/
    3) {
      dispatch2("input", { s: s2, v: v2 });
    }
  };
  return [
    s2,
    v2,
    components,
    isDark,
    picker,
    pickerColorBg,
    pos,
    pickerMousedown,
    mouseUp,
    mouseMove,
    mouseDown,
    touch,
    h2,
    slider0_value_binding,
    slider1_value_binding,
    div2_binding
  ];
}
class Picker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Y, create_fragment$1Y, safe_not_equal, {
      components: 2,
      h: 12,
      s: 0,
      v: 1,
      isDark: 3
    });
  }
}
function create_fragment$1X(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "picker-indicator svelte-i5mg2p");
      toggle_class(
        div,
        "is-dark",
        /*isDark*/
        ctx[1]
      );
      set_style(
        div,
        "--pos-x",
        /*pos*/
        ctx[0].x
      );
      set_style(
        div,
        "--pos-y",
        /*pos*/
        ctx[0].y
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isDark*/
      2) {
        toggle_class(
          div,
          "is-dark",
          /*isDark*/
          ctx2[1]
        );
      }
      if (dirty & /*pos*/
      1) {
        set_style(
          div,
          "--pos-x",
          /*pos*/
          ctx2[0].x
        );
      }
      if (dirty & /*pos*/
      1) {
        set_style(
          div,
          "--pos-y",
          /*pos*/
          ctx2[0].y
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance$1X($$self, $$props, $$invalidate) {
  let { pos } = $$props;
  let { isDark } = $$props;
  $$self.$$set = ($$props2) => {
    if ("pos" in $$props2) $$invalidate(0, pos = $$props2.pos);
    if ("isDark" in $$props2) $$invalidate(1, isDark = $$props2.isDark);
  };
  return [pos, isDark];
}
class PickerIndicator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1X, create_fragment$1X, safe_not_equal, { pos: 0, isDark: 1 });
  }
}
function create_else_block_1$6(ctx) {
  let input0;
  let input0_aria_label_value;
  let t0;
  let input1;
  let input1_aria_label_value;
  let t1;
  let input2;
  let input2_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      input2 = element("input");
      attr(input0, "aria-label", input0_aria_label_value = /*texts*/
      ctx[4].label.h);
      input0.value = /*h*/
      ctx[9];
      attr(input0, "type", "number");
      attr(input0, "min", "0");
      attr(input0, "max", "360");
      attr(input0, "class", "svelte-qtukzs");
      attr(input1, "aria-label", input1_aria_label_value = /*texts*/
      ctx[4].label.s);
      input1.value = /*s*/
      ctx[8];
      attr(input1, "type", "number");
      attr(input1, "min", "0");
      attr(input1, "max", "100");
      attr(input1, "class", "svelte-qtukzs");
      attr(input2, "aria-label", input2_aria_label_value = /*texts*/
      ctx[4].label.v);
      input2.value = /*v*/
      ctx[7];
      attr(input2, "type", "number");
      attr(input2, "min", "0");
      attr(input2, "max", "100");
      attr(input2, "class", "svelte-qtukzs");
    },
    m(target, anchor) {
      insert(target, input0, anchor);
      insert(target, t0, anchor);
      insert(target, input1, anchor);
      insert(target, t1, anchor);
      insert(target, input2, anchor);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*updateHsv*/
            ctx[13]("h")
          ),
          listen(
            input1,
            "input",
            /*updateHsv*/
            ctx[13]("s")
          ),
          listen(
            input2,
            "input",
            /*updateHsv*/
            ctx[13]("v")
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*texts*/
      16 && input0_aria_label_value !== (input0_aria_label_value = /*texts*/
      ctx2[4].label.h)) {
        attr(input0, "aria-label", input0_aria_label_value);
      }
      if (dirty & /*h*/
      512 && input0.value !== /*h*/
      ctx2[9]) {
        input0.value = /*h*/
        ctx2[9];
      }
      if (dirty & /*texts*/
      16 && input1_aria_label_value !== (input1_aria_label_value = /*texts*/
      ctx2[4].label.s)) {
        attr(input1, "aria-label", input1_aria_label_value);
      }
      if (dirty & /*s*/
      256 && input1.value !== /*s*/
      ctx2[8]) {
        input1.value = /*s*/
        ctx2[8];
      }
      if (dirty & /*texts*/
      16 && input2_aria_label_value !== (input2_aria_label_value = /*texts*/
      ctx2[4].label.v)) {
        attr(input2, "aria-label", input2_aria_label_value);
      }
      if (dirty & /*v*/
      128 && input2.value !== /*v*/
      ctx2[7]) {
        input2.value = /*v*/
        ctx2[7];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input0);
        detach(t0);
        detach(input1);
        detach(t1);
        detach(input2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3$h(ctx) {
  let input0;
  let input0_aria_label_value;
  let input0_value_value;
  let t0;
  let input1;
  let input1_aria_label_value;
  let input1_value_value;
  let t1;
  let input2;
  let input2_aria_label_value;
  let input2_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      input2 = element("input");
      attr(input0, "aria-label", input0_aria_label_value = /*texts*/
      ctx[4].label.r);
      input0.value = input0_value_value = /*rgb*/
      ctx[0].r;
      attr(input0, "type", "number");
      attr(input0, "min", "0");
      attr(input0, "max", "255");
      attr(input0, "class", "svelte-qtukzs");
      attr(input1, "aria-label", input1_aria_label_value = /*texts*/
      ctx[4].label.g);
      input1.value = input1_value_value = /*rgb*/
      ctx[0].g;
      attr(input1, "type", "number");
      attr(input1, "min", "0");
      attr(input1, "max", "255");
      attr(input1, "class", "svelte-qtukzs");
      attr(input2, "aria-label", input2_aria_label_value = /*texts*/
      ctx[4].label.b);
      input2.value = input2_value_value = /*rgb*/
      ctx[0].b;
      attr(input2, "type", "number");
      attr(input2, "min", "0");
      attr(input2, "max", "255");
      attr(input2, "class", "svelte-qtukzs");
    },
    m(target, anchor) {
      insert(target, input0, anchor);
      insert(target, t0, anchor);
      insert(target, input1, anchor);
      insert(target, t1, anchor);
      insert(target, input2, anchor);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*updateRgb*/
            ctx[12]("r")
          ),
          listen(
            input1,
            "input",
            /*updateRgb*/
            ctx[12]("g")
          ),
          listen(
            input2,
            "input",
            /*updateRgb*/
            ctx[12]("b")
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*texts*/
      16 && input0_aria_label_value !== (input0_aria_label_value = /*texts*/
      ctx2[4].label.r)) {
        attr(input0, "aria-label", input0_aria_label_value);
      }
      if (dirty & /*rgb*/
      1 && input0_value_value !== (input0_value_value = /*rgb*/
      ctx2[0].r) && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (dirty & /*texts*/
      16 && input1_aria_label_value !== (input1_aria_label_value = /*texts*/
      ctx2[4].label.g)) {
        attr(input1, "aria-label", input1_aria_label_value);
      }
      if (dirty & /*rgb*/
      1 && input1_value_value !== (input1_value_value = /*rgb*/
      ctx2[0].g) && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if (dirty & /*texts*/
      16 && input2_aria_label_value !== (input2_aria_label_value = /*texts*/
      ctx2[4].label.b)) {
        attr(input2, "aria-label", input2_aria_label_value);
      }
      if (dirty & /*rgb*/
      1 && input2_value_value !== (input2_value_value = /*rgb*/
      ctx2[0].b) && input2.value !== input2_value_value) {
        input2.value = input2_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input0);
        detach(t0);
        detach(input1);
        detach(t1);
        detach(input2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$o(ctx) {
  let input;
  let input_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "aria-label", input_aria_label_value = /*texts*/
      ctx[4].label.hex);
      input.value = /*hex*/
      ctx[1];
      attr(input, "class", "svelte-qtukzs");
      set_style(input, "flex", 3);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*updateHex*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*texts*/
      16 && input_aria_label_value !== (input_aria_label_value = /*texts*/
      ctx2[4].label.hex)) {
        attr(input, "aria-label", input_aria_label_value);
      }
      if (dirty & /*hex*/
      2 && input.value !== /*hex*/
      ctx2[1]) {
        input.value = /*hex*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$w(ctx) {
  let input;
  let input_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "aria-label", input_aria_label_value = /*texts*/
      ctx[4].label.a);
      input.value = /*a*/
      ctx[6];
      attr(input, "type", "number");
      attr(input, "min", "0");
      attr(input, "max", "1");
      attr(input, "step", "0.01");
      attr(input, "class", "svelte-qtukzs");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", function() {
          if (is_function(
            /*mode*/
            ctx[5] === "hsv" ? (
              /*updateHsv*/
              ctx[13]("a")
            ) : (
              /*updateRgb*/
              ctx[12]("a")
            )
          )) /*mode*/
          (ctx[5] === "hsv" ? (
            /*updateHsv*/
            ctx[13]("a")
          ) : (
            /*updateRgb*/
            ctx[12]("a")
          )).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*texts*/
      16 && input_aria_label_value !== (input_aria_label_value = /*texts*/
      ctx[4].label.a)) {
        attr(input, "aria-label", input_aria_label_value);
      }
      if (dirty & /*a*/
      64 && input.value !== /*a*/
      ctx[6]) {
        input.value = /*a*/
        ctx[6];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$v(ctx) {
  let div;
  let t_value = (
    /*texts*/
    ctx[4].color[
      /*mode*/
      ctx[5]
    ] + ""
  );
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", "button-like svelte-qtukzs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*texts, mode*/
      48 && t_value !== (t_value = /*texts*/
      ctx2[4].color[
        /*mode*/
        ctx2[5]
      ] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$S(ctx) {
  let button;
  let span0;
  let t0_value = (
    /*texts*/
    ctx[4].color[
      /*mode*/
      ctx[5]
    ] + ""
  );
  let t0;
  let t1;
  let span1;
  let t2_value = (
    /*texts*/
    ctx[4].changeTo + ""
  );
  let t2;
  let t3;
  let t4;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(
        /*nextMode*/
        ctx[10]
      );
      attr(span0, "class", "disappear svelte-qtukzs");
      attr(span0, "aria-hidden", "true");
      attr(span1, "class", "appear svelte-qtukzs");
      attr(button, "type", "button");
      attr(button, "class", "svelte-qtukzs");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span0);
      append(span0, t0);
      append(button, t1);
      append(button, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[15]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*texts, mode*/
      48 && t0_value !== (t0_value = /*texts*/
      ctx2[4].color[
        /*mode*/
        ctx2[5]
      ] + "")) set_data(t0, t0_value);
      if (dirty & /*texts*/
      16 && t2_value !== (t2_value = /*texts*/
      ctx2[4].changeTo + "")) set_data(t2, t2_value);
      if (dirty & /*nextMode*/
      1024) set_data(
        t4,
        /*nextMode*/
        ctx2[10]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1W(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  function select_block_type(ctx2, dirty) {
    if (
      /*mode*/
      ctx2[5] === "hex"
    ) return create_if_block_2$o;
    if (
      /*mode*/
      ctx2[5] === "rgb"
    ) return create_if_block_3$h;
    return create_else_block_1$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*isAlpha*/
    ctx[2] && create_if_block_1$w(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*textInputModes*/
      ctx2[3].length > 1
    ) return create_if_block$S;
    return create_else_block$v;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block2 = current_block_type_1(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if_block2.c();
      attr(div0, "class", "input-container svelte-qtukzs");
      attr(div1, "class", "text-input svelte-qtukzs");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_block0.m(div0, null);
      append(div0, t0);
      if (if_block1) if_block1.m(div0, null);
      append(div1, t1);
      if_block2.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, t0);
        }
      }
      if (
        /*isAlpha*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$w(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type_1(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div1, null);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_block0.d();
      if (if_block1) if_block1.d();
      if_block2.d();
    }
  };
}
const HEX_COLOR_REGEX = /^#?([A-F0-9]{6}|[A-F0-9]{8})$/i;
function instance$1W($$self, $$props, $$invalidate) {
  let nextMode;
  let h2;
  let s2;
  let v2;
  let a2;
  const dispatch2 = createEventDispatcher();
  let { isAlpha } = $$props;
  let { rgb } = $$props;
  let { hsv } = $$props;
  let { hex } = $$props;
  let { textInputModes } = $$props;
  let { texts } = $$props;
  let mode = textInputModes[0] || "hex";
  function updateHex(e2) {
    const target = e2.target;
    if (HEX_COLOR_REGEX.test(target.value)) {
      $$invalidate(1, hex = target.value);
      dispatch2("input", { hex });
    }
  }
  function updateRgb(property) {
    return function(e2) {
      $$invalidate(0, rgb = {
        ...rgb,
        [property]: parseFloat(e2.target.value)
      });
      dispatch2("input", { rgb });
    };
  }
  function updateHsv(property) {
    return function(e2) {
      $$invalidate(14, hsv = {
        ...hsv,
        [property]: parseFloat(e2.target.value)
      });
      dispatch2("input", { hsv });
    };
  }
  const click_handler = () => $$invalidate(5, mode = nextMode);
  $$self.$$set = ($$props2) => {
    if ("isAlpha" in $$props2) $$invalidate(2, isAlpha = $$props2.isAlpha);
    if ("rgb" in $$props2) $$invalidate(0, rgb = $$props2.rgb);
    if ("hsv" in $$props2) $$invalidate(14, hsv = $$props2.hsv);
    if ("hex" in $$props2) $$invalidate(1, hex = $$props2.hex);
    if ("textInputModes" in $$props2) $$invalidate(3, textInputModes = $$props2.textInputModes);
    if ("texts" in $$props2) $$invalidate(4, texts = $$props2.texts);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*textInputModes, mode*/
    40) {
      $$invalidate(10, nextMode = textInputModes[(textInputModes.indexOf(mode) + 1) % textInputModes.length]);
    }
    if ($$self.$$.dirty & /*hsv*/
    16384) {
      $$invalidate(9, h2 = Math.round(hsv.h));
    }
    if ($$self.$$.dirty & /*hsv*/
    16384) {
      $$invalidate(8, s2 = Math.round(hsv.s));
    }
    if ($$self.$$.dirty & /*hsv*/
    16384) {
      $$invalidate(7, v2 = Math.round(hsv.v));
    }
    if ($$self.$$.dirty & /*hsv*/
    16384) {
      $$invalidate(6, a2 = hsv.a === void 0 ? 1 : Math.round(hsv.a * 100) / 100);
    }
  };
  return [
    rgb,
    hex,
    isAlpha,
    textInputModes,
    texts,
    mode,
    a2,
    v2,
    s2,
    h2,
    nextMode,
    updateHex,
    updateRgb,
    updateHsv,
    hsv,
    click_handler
  ];
}
class TextInput2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1W, create_fragment$1W, safe_not_equal, {
      isAlpha: 2,
      rgb: 0,
      hsv: 14,
      hex: 1,
      textInputModes: 3,
      texts: 4
    });
  }
}
function create_fragment$1V(ctx) {
  let label_1;
  let div2;
  let input;
  let t0;
  let div0;
  let t1;
  let div1;
  let t2;
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      label_1 = element("label");
      div2 = element("div");
      input = element("input");
      t0 = space();
      div0 = element("div");
      t1 = space();
      div1 = element("div");
      t2 = space();
      t3 = text(
        /*label*/
        ctx[2]
      );
      attr(input, "type", "color");
      attr(
        input,
        "name",
        /*name*/
        ctx[3]
      );
      input.value = /*hex*/
      ctx[1];
      attr(input, "aria-haspopup", "dialog");
      attr(input, "class", "svelte-lemcb1");
      attr(div0, "class", "alpha svelte-lemcb1");
      attr(div1, "class", "color svelte-lemcb1");
      set_style(
        div1,
        "background",
        /*hex*/
        ctx[1]
      );
      attr(div2, "class", "container svelte-lemcb1");
      attr(label_1, "class", "svelte-lemcb1");
    },
    m(target, anchor) {
      insert(target, label_1, anchor);
      append(label_1, div2);
      append(div2, input);
      append(div2, t0);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(label_1, t2);
      append(label_1, t3);
      ctx[5](label_1);
      if (!mounted) {
        dispose = [
          listen(input, "click", prevent_default(noop)),
          listen(input, "mousedown", prevent_default(noop)),
          listen(label_1, "click", prevent_default(noop)),
          listen(label_1, "mousedown", prevent_default(noop))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*name*/
      8) {
        attr(
          input,
          "name",
          /*name*/
          ctx2[3]
        );
      }
      if (dirty & /*hex*/
      2) {
        input.value = /*hex*/
        ctx2[1];
      }
      if (dirty & /*hex*/
      2) {
        set_style(
          div1,
          "background",
          /*hex*/
          ctx2[1]
        );
      }
      if (dirty & /*label*/
      4) set_data(
        t3,
        /*label*/
        ctx2[2]
      );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(label_1);
      }
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function noop() {
}
function instance$1V($$self, $$props, $$invalidate) {
  let { labelElement } = $$props;
  let { hex } = $$props;
  let { label } = $$props;
  let { name = void 0 } = $$props;
  let { isOpen } = $$props;
  function label_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      labelElement = $$value;
      $$invalidate(0, labelElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("labelElement" in $$props2) $$invalidate(0, labelElement = $$props2.labelElement);
    if ("hex" in $$props2) $$invalidate(1, hex = $$props2.hex);
    if ("label" in $$props2) $$invalidate(2, label = $$props2.label);
    if ("name" in $$props2) $$invalidate(3, name = $$props2.name);
    if ("isOpen" in $$props2) $$invalidate(4, isOpen = $$props2.isOpen);
  };
  return [labelElement, hex, label, name, isOpen, label_1_binding];
}
class Input extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1V, create_fragment$1V, safe_not_equal, {
      labelElement: 0,
      hex: 1,
      label: 2,
      name: 3,
      isOpen: 4
    });
  }
}
function create_fragment$1U(ctx) {
  let div;
  let div_role_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr(div, "class", "wrapper svelte-h9ar9");
      attr(div, "role", div_role_value = /*isDialog*/
      ctx[2] ? "dialog" : void 0);
      attr(div, "aria-label", "color picker");
      toggle_class(
        div,
        "is-open",
        /*isOpen*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[5](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*isDialog*/
      4 && div_role_value !== (div_role_value = /*isDialog*/
      ctx2[2] ? "dialog" : void 0)) {
        attr(div, "role", div_role_value);
      }
      if (!current || dirty & /*isOpen*/
      2) {
        toggle_class(
          div,
          "is-open",
          /*isOpen*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      ctx[5](null);
    }
  };
}
function instance$1U($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { wrapper } = $$props;
  let { isOpen } = $$props;
  let { isDialog } = $$props;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(0, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("wrapper" in $$props2) $$invalidate(0, wrapper = $$props2.wrapper);
    if ("isOpen" in $$props2) $$invalidate(1, isOpen = $$props2.isOpen);
    if ("isDialog" in $$props2) $$invalidate(2, isDialog = $$props2.isDialog);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [wrapper, isOpen, isDialog, $$scope, slots, div_binding];
}
class Wrapper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1U, create_fragment$1U, safe_not_equal, { wrapper: 0, isOpen: 1, isDialog: 2 });
  }
}
const defaultTexts = {
  label: {
    h: "hue channel",
    s: "saturation channel",
    v: "brightness channel",
    r: "red channel",
    g: "green channel",
    b: "blue channel",
    a: "alpha channel",
    hex: "hex color",
    withoutColor: "without color"
  },
  color: {
    rgb: "rgb",
    hsv: "hsv",
    hex: "hex"
  },
  changeTo: "change to "
};
const FOCUSABLE_ELEMENTS = "a[href], area[href], input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]";
function trapFocusListener(trapFocusElement) {
  return function(event) {
    if (event.target === window) {
      return;
    }
    const eventTarget = event.target;
    if (!trapFocusElement.contains(eventTarget)) {
      return;
    }
    const focusable = trapFocusElement.querySelectorAll(FOCUSABLE_ELEMENTS);
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    function isNext(event2) {
      return event2.code === "Tab" && !event2.shiftKey;
    }
    function isPrevious(event2) {
      return event2.code === "Tab" && event2.shiftKey;
    }
    if (isNext(event) && event.target === last) {
      event.preventDefault();
      first.focus();
    } else if (isPrevious(event) && event.target === first) {
      event.preventDefault();
      last.focus();
    }
  };
}
const trapFocus = (node) => {
  const first = node.querySelector(FOCUSABLE_ELEMENTS);
  if (first)
    first.focus();
  const listener = trapFocusListener(node);
  document.addEventListener("keydown", listener);
  return {
    destroy() {
      document.removeEventListener("keydown", listener);
    }
  };
};
function create_fragment$1T(ctx) {
  let label;
  let div;
  let input;
  let t0;
  let span;
  let t1;
  let t2_value = (
    /*texts*/
    ctx[1].label.withoutColor + ""
  );
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      label = element("label");
      div = element("div");
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = space();
      t2 = text(t2_value);
      attr(input, "type", "checkbox");
      attr(input, "class", "svelte-oskb5b");
      attr(span, "class", "svelte-oskb5b");
      attr(div, "class", "svelte-oskb5b");
      attr(label, "class", "nullability-checkbox svelte-oskb5b");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, div);
      append(div, input);
      input.checked = /*isUndefined*/
      ctx[0];
      append(div, t0);
      append(div, span);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isUndefined*/
      1) {
        input.checked = /*isUndefined*/
        ctx2[0];
      }
      if (dirty & /*texts*/
      2 && t2_value !== (t2_value = /*texts*/
      ctx2[1].label.withoutColor + "")) set_data(t2, t2_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1T($$self, $$props, $$invalidate) {
  let { isUndefined } = $$props;
  let { texts } = $$props;
  function input_change_handler() {
    isUndefined = this.checked;
    $$invalidate(0, isUndefined);
  }
  $$self.$$set = ($$props2) => {
    if ("isUndefined" in $$props2) $$invalidate(0, isUndefined = $$props2.isUndefined);
    if ("texts" in $$props2) $$invalidate(1, texts = $$props2.texts);
  };
  return [isUndefined, texts, input_change_handler];
}
class NullabilityCheckbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1T, create_fragment$1T, safe_not_equal, { isUndefined: 0, texts: 1 });
  }
}
function create_if_block_5$9(ctx) {
  let input;
  return {
    c() {
      input = element("input");
      attr(input, "type", "hidden");
      input.value = /*hex*/
      ctx[2];
      attr(
        input,
        "name",
        /*name*/
        ctx[6]
      );
    },
    m(target, anchor) {
      insert(target, input, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*hex*/
      4) {
        input.value = /*hex*/
        ctx2[2];
      }
      if (dirty[0] & /*name*/
      64) {
        attr(
          input,
          "name",
          /*name*/
          ctx2[6]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(input);
      }
    }
  };
}
function create_if_block_4$b(ctx) {
  let switch_instance;
  let updating_labelElement;
  let switch_instance_anchor;
  let current;
  function switch_instance_labelElement_binding(value) {
    ctx[33](value);
  }
  var switch_value = (
    /*getComponents*/
    ctx[23]().input
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      isOpen: true,
      hex: (
        /*hex*/
        ctx2[2]
      ),
      label: (
        /*label*/
        ctx2[5]
      ),
      name: (
        /*name*/
        ctx2[6]
      )
    };
    if (
      /*labelElement*/
      ctx2[21] !== void 0
    ) {
      switch_instance_props.labelElement = /*labelElement*/
      ctx2[21];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "labelElement", switch_instance_labelElement_binding));
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = /*getComponents*/
      ctx2[23]().input)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "labelElement", switch_instance_labelElement_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*hex*/
        4) switch_instance_changes.hex = /*hex*/
        ctx2[2];
        if (dirty[0] & /*label*/
        32) switch_instance_changes.label = /*label*/
        ctx2[5];
        if (dirty[0] & /*name*/
        64) switch_instance_changes.name = /*name*/
        ctx2[6];
        if (!updating_labelElement && dirty[0] & /*labelElement*/
        2097152) {
          updating_labelElement = true;
          switch_instance_changes.labelElement = /*labelElement*/
          ctx2[21];
          add_flush_callback(() => updating_labelElement = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_3$g(ctx) {
  let switch_instance;
  let updating_isUndefined;
  let switch_instance_anchor;
  let current;
  function switch_instance_isUndefined_binding(value) {
    ctx[34](value);
  }
  var switch_value = (
    /*getComponents*/
    ctx[23]().nullabilityCheckbox
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = { texts: (
      /*getTexts*/
      ctx2[24]()
    ) };
    if (
      /*isUndefined*/
      ctx2[16] !== void 0
    ) {
      switch_instance_props.isUndefined = /*isUndefined*/
      ctx2[16];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "isUndefined", switch_instance_isUndefined_binding));
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = /*getComponents*/
      ctx2[23]().nullabilityCheckbox)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "isUndefined", switch_instance_isUndefined_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (!updating_isUndefined && dirty[0] & /*isUndefined*/
        65536) {
          updating_isUndefined = true;
          switch_instance_changes.isUndefined = /*isUndefined*/
          ctx2[16];
          add_flush_callback(() => updating_isUndefined = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_2$n(ctx) {
  let div;
  let slider;
  let current;
  slider = new Slider({
    props: {
      min: 0,
      max: 1,
      step: 0.01,
      value: (
        /*hsv*/
        ctx[1]?.a ?? /*_hsv*/
        ctx[18].a
      ),
      direction: (
        /*sliderDirection*/
        ctx[12]
      ),
      reverse: (
        /*sliderDirection*/
        ctx[12] === "vertical"
      ),
      ariaLabel: (
        /*getTexts*/
        ctx[24]().label.a
      )
    }
  });
  slider.$on(
    "input",
    /*updateLetter*/
    ctx[27]("a")
  );
  return {
    c() {
      div = element("div");
      create_component(slider.$$.fragment);
      attr(div, "class", "a svelte-tsvobk");
      set_style(
        div,
        "--alphaless-color",
        /*hex*/
        (ctx[2] ? (
          /*hex*/
          ctx[2]
        ) : (
          /*_hex*/
          ctx[19]
        )).substring(0, 7)
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(slider, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const slider_changes = {};
      if (dirty[0] & /*hsv, _hsv*/
      262146) slider_changes.value = /*hsv*/
      ctx2[1]?.a ?? /*_hsv*/
      ctx2[18].a;
      if (dirty[0] & /*sliderDirection*/
      4096) slider_changes.direction = /*sliderDirection*/
      ctx2[12];
      if (dirty[0] & /*sliderDirection*/
      4096) slider_changes.reverse = /*sliderDirection*/
      ctx2[12] === "vertical";
      slider.$set(slider_changes);
      if (dirty[0] & /*hex, _hex*/
      524292) {
        set_style(
          div,
          "--alphaless-color",
          /*hex*/
          (ctx2[2] ? (
            /*hex*/
            ctx2[2]
          ) : (
            /*_hex*/
            ctx2[19]
          )).substring(0, 7)
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(slider);
    }
  };
}
function create_if_block_1$v(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*getComponents*/
    ctx[23]().textInput
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        hex: (
          /*hex*/
          ctx2[2] ?? /*_hex*/
          ctx2[19]
        ),
        rgb: (
          /*rgb*/
          ctx2[0] ?? /*_rgb*/
          ctx2[17]
        ),
        hsv: (
          /*hsv*/
          ctx2[1] ?? /*_hsv*/
          ctx2[18]
        ),
        isAlpha: (
          /*isAlpha*/
          ctx2[8]
        ),
        textInputModes: (
          /*textInputModes*/
          ctx2[11]
        ),
        texts: (
          /*getTexts*/
          ctx2[24]()
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    switch_instance.$on(
      "input",
      /*input_handler*/
      ctx[35]
    );
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = /*getComponents*/
      ctx2[23]().textInput)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          switch_instance.$on(
            "input",
            /*input_handler*/
            ctx2[35]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*hex, _hex*/
        524292) switch_instance_changes.hex = /*hex*/
        ctx2[2] ?? /*_hex*/
        ctx2[19];
        if (dirty[0] & /*rgb, _rgb*/
        131073) switch_instance_changes.rgb = /*rgb*/
        ctx2[0] ?? /*_rgb*/
        ctx2[17];
        if (dirty[0] & /*hsv, _hsv*/
        262146) switch_instance_changes.hsv = /*hsv*/
        ctx2[1] ?? /*_hsv*/
        ctx2[18];
        if (dirty[0] & /*isAlpha*/
        256) switch_instance_changes.isAlpha = /*isAlpha*/
        ctx2[8];
        if (dirty[0] & /*textInputModes*/
        2048) switch_instance_changes.textInputModes = /*textInputModes*/
        ctx2[11];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block$R(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*getComponents*/
    ctx[23]().a11yNotice
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        components: (
          /*getComponents*/
          ctx2[23]()
        ),
        a11yColors: (
          /*a11yColors*/
          ctx2[13]
        ),
        hex: (
          /*hex*/
          ctx2[2] || "#00000000"
        ),
        a11yTexts: (
          /*a11yTexts*/
          ctx2[15]
        ),
        a11yLevel: (
          /*a11yLevel*/
          ctx2[14]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = /*getComponents*/
      ctx2[23]().a11yNotice)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*a11yColors*/
        8192) switch_instance_changes.a11yColors = /*a11yColors*/
        ctx2[13];
        if (dirty[0] & /*hex*/
        4) switch_instance_changes.hex = /*hex*/
        ctx2[2] || "#00000000";
        if (dirty[0] & /*a11yTexts*/
        32768) switch_instance_changes.a11yTexts = /*a11yTexts*/
        ctx2[15];
        if (dirty[0] & /*a11yLevel*/
        16384) switch_instance_changes.a11yLevel = /*a11yLevel*/
        ctx2[14];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot$N(ctx) {
  let t0;
  let picker;
  let t1;
  let div;
  let slider;
  let t2;
  let t3;
  let t4;
  let show_if = (
    /*getComponents*/
    ctx[23]().a11yNotice
  );
  let if_block3_anchor;
  let current;
  let if_block0 = (
    /*nullable*/
    ctx[7] && create_if_block_3$g(ctx)
  );
  picker = new Picker({
    props: {
      components: (
        /*getComponents*/
        ctx[23]()
      ),
      h: (
        /*hsv*/
        ctx[1]?.h ?? /*_hsv*/
        ctx[18].h
      ),
      s: (
        /*hsv*/
        ctx[1]?.s ?? /*_hsv*/
        ctx[18].s
      ),
      v: (
        /*hsv*/
        ctx[1]?.v ?? /*_hsv*/
        ctx[18].v
      ),
      isDark: (
        /*isDark*/
        ctx[3]
      )
    }
  });
  picker.$on(
    "input",
    /*updateLetters*/
    ctx[28](["s", "v"])
  );
  slider = new Slider({
    props: {
      min: 0,
      max: 360,
      step: 1,
      value: (
        /*hsv*/
        ctx[1]?.h ?? /*_hsv*/
        ctx[18].h
      ),
      direction: (
        /*sliderDirection*/
        ctx[12]
      ),
      reverse: (
        /*sliderDirection*/
        ctx[12] === "vertical"
      ),
      ariaLabel: (
        /*getTexts*/
        ctx[24]().label.h
      )
    }
  });
  slider.$on(
    "input",
    /*updateLetter*/
    ctx[27]("h")
  );
  let if_block1 = (
    /*isAlpha*/
    ctx[8] && create_if_block_2$n(ctx)
  );
  let if_block2 = (
    /*isTextInput*/
    ctx[10] && create_if_block_1$v(ctx)
  );
  let if_block3 = show_if && create_if_block$R(ctx);
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      create_component(picker.$$.fragment);
      t1 = space();
      div = element("div");
      create_component(slider.$$.fragment);
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      t4 = space();
      if (if_block3) if_block3.c();
      if_block3_anchor = empty();
      attr(div, "class", "h svelte-tsvobk");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      mount_component(picker, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      mount_component(slider, div, null);
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*nullable*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*nullable*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$g(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const picker_changes = {};
      if (dirty[0] & /*hsv, _hsv*/
      262146) picker_changes.h = /*hsv*/
      ctx2[1]?.h ?? /*_hsv*/
      ctx2[18].h;
      if (dirty[0] & /*hsv, _hsv*/
      262146) picker_changes.s = /*hsv*/
      ctx2[1]?.s ?? /*_hsv*/
      ctx2[18].s;
      if (dirty[0] & /*hsv, _hsv*/
      262146) picker_changes.v = /*hsv*/
      ctx2[1]?.v ?? /*_hsv*/
      ctx2[18].v;
      if (dirty[0] & /*isDark*/
      8) picker_changes.isDark = /*isDark*/
      ctx2[3];
      picker.$set(picker_changes);
      const slider_changes = {};
      if (dirty[0] & /*hsv, _hsv*/
      262146) slider_changes.value = /*hsv*/
      ctx2[1]?.h ?? /*_hsv*/
      ctx2[18].h;
      if (dirty[0] & /*sliderDirection*/
      4096) slider_changes.direction = /*sliderDirection*/
      ctx2[12];
      if (dirty[0] & /*sliderDirection*/
      4096) slider_changes.reverse = /*sliderDirection*/
      ctx2[12] === "vertical";
      slider.$set(slider_changes);
      if (
        /*isAlpha*/
        ctx2[8]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*isAlpha*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$n(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*isTextInput*/
        ctx2[10]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*isTextInput*/
          1024) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$v(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (show_if) if_block3.p(ctx2, dirty);
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(picker.$$.fragment, local);
      transition_in(slider.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(picker.$$.fragment, local);
      transition_out(slider.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(div);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block3_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      destroy_component(picker, detaching);
      destroy_component(slider);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
    }
  };
}
function create_fragment$1S(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t2;
  let switch_instance;
  let updating_wrapper;
  let span_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_4$b, create_if_block_5$9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isDialog*/
      ctx2[9]
    ) return 0;
    if (
      /*name*/
      ctx2[6]
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  function switch_instance_wrapper_binding(value) {
    ctx[36](value);
  }
  var switch_value = (
    /*getComponents*/
    ctx[23]().wrapper
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      isOpen: (
        /*isOpen*/
        ctx2[4]
      ),
      isDialog: (
        /*isDialog*/
        ctx2[9]
      ),
      $$slots: { default: [create_default_slot$N] },
      $$scope: { ctx: ctx2 }
    };
    if (
      /*wrapper*/
      ctx2[22] !== void 0
    ) {
      switch_instance_props.wrapper = /*wrapper*/
      ctx2[22];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "wrapper", switch_instance_wrapper_binding));
  }
  return {
    c() {
      span = element("span");
      if (if_block) if_block.c();
      t2 = space();
      if (switch_instance) create_component(switch_instance.$$.fragment);
      attr(span, "class", span_class_value = "color-picker " + /*sliderDirection*/
      ctx[12] + " svelte-tsvobk");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append(span, t2);
      if (switch_instance) mount_component(switch_instance, span, null);
      ctx[37](span);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "mousedown",
            /*mousedown*/
            ctx[25]
          ),
          listen(
            window,
            "keyup",
            /*keyup*/
            ctx[26]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t2);
        } else {
          if_block = null;
        }
      }
      if (switch_value !== (switch_value = /*getComponents*/
      ctx2[23]().wrapper)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "wrapper", switch_instance_wrapper_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, span, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*isOpen*/
        16) switch_instance_changes.isOpen = /*isOpen*/
        ctx2[4];
        if (dirty[0] & /*isDialog*/
        512) switch_instance_changes.isDialog = /*isDialog*/
        ctx2[9];
        if (dirty[0] & /*a11yColors, hex, a11yTexts, a11yLevel, _hex, rgb, _rgb, hsv, _hsv, isAlpha, textInputModes, isTextInput, sliderDirection, isDark, isUndefined, nullable*/
        1047951 | dirty[1] & /*$$scope*/
        4096) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        if (!updating_wrapper && dirty[0] & /*wrapper*/
        4194304) {
          updating_wrapper = true;
          switch_instance_changes.wrapper = /*wrapper*/
          ctx2[22];
          add_flush_callback(() => updating_wrapper = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*sliderDirection*/
      4096 && span_class_value !== (span_class_value = "color-picker " + /*sliderDirection*/
      ctx2[12] + " svelte-tsvobk")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (switch_instance) destroy_component(switch_instance);
      ctx[37](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1S($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { components = {} } = $$props;
  let { label = "Choose a color" } = $$props;
  let { name = void 0 } = $$props;
  let { nullable = false } = $$props;
  let { rgb = nullable ? void 0 : { r: 255, g: 0, b: 0, a: 1 } } = $$props;
  let { hsv = nullable ? void 0 : { h: 0, s: 100, v: 100, a: 1 } } = $$props;
  let { hex = nullable ? void 0 : "#ff0000" } = $$props;
  let { color = void 0 } = $$props;
  let { isDark = false } = $$props;
  let { isAlpha = true } = $$props;
  let { isDialog = true } = $$props;
  let { isOpen = !isDialog } = $$props;
  let { isTextInput = true } = $$props;
  let { textInputModes = ["hex", "rgb", "hsv"] } = $$props;
  let { sliderDirection = "vertical" } = $$props;
  let { disableCloseClickOutside = false } = $$props;
  let { a11yColors = [{ bgHex: "#ffffff" }] } = $$props;
  let { a11yLevel = "AA" } = $$props;
  let { texts = void 0 } = $$props;
  let { a11yTexts = void 0 } = $$props;
  let _rgb = { r: 255, g: 0, b: 0, a: 1 };
  let _hsv = { h: 0, s: 100, v: 100, a: 1 };
  let _hex = "#ff0000";
  let isUndefined = false;
  let _isUndefined = isUndefined;
  let spanElement;
  let labelElement;
  let wrapper;
  let trap = void 0;
  const default_components = {
    pickerIndicator: PickerIndicator,
    textInput: TextInput2,
    input: Input,
    nullabilityCheckbox: NullabilityCheckbox,
    wrapper: Wrapper
  };
  function getComponents() {
    return { ...default_components, ...components };
  }
  function getTexts() {
    return {
      label: { ...defaultTexts.label, ...texts?.label },
      color: { ...defaultTexts.color, ...texts?.color },
      changeTo: texts?.changeTo ?? defaultTexts.changeTo
    };
  }
  function mousedown({ target }) {
    if (isDialog) {
      if (labelElement.contains(target) || labelElement.isSameNode(target)) {
        $$invalidate(4, isOpen = !isOpen);
      } else if (isOpen && !wrapper.contains(target) && !disableCloseClickOutside) {
        $$invalidate(4, isOpen = false);
      }
    }
  }
  function keyup({ key, target }) {
    if (!isDialog) {
      return;
    } else if (key === "Enter" && labelElement.contains(target)) {
      $$invalidate(4, isOpen = !isOpen);
      setTimeout(() => {
        trap = trapFocus(wrapper);
      });
    } else if (key === "Escape" && isOpen) {
      $$invalidate(4, isOpen = false);
      if (spanElement.contains(target)) {
        labelElement?.focus();
        trap?.destroy();
      }
    }
  }
  function updateColor() {
    if (isUndefined && !_isUndefined) {
      _isUndefined = true;
      $$invalidate(1, hsv = $$invalidate(0, rgb = $$invalidate(2, hex = void 0)));
      dispatch2("input", { color, hsv, rgb, hex });
      return;
    } else if (_isUndefined && !isUndefined) {
      _isUndefined = false;
      $$invalidate(1, hsv = _hsv);
      $$invalidate(0, rgb = _rgb);
      $$invalidate(2, hex = _hex);
      dispatch2("input", { color, hsv, rgb, hex });
      return;
    }
    if (!hsv && !rgb && !hex) {
      $$invalidate(16, isUndefined = true);
      _isUndefined = true;
      dispatch2("input", { color: void 0, hsv, rgb, hex });
      return;
    }
    if (hsv && rgb && hsv.h === _hsv.h && hsv.s === _hsv.s && hsv.v === _hsv.v && hsv.a === _hsv.a && rgb.r === _rgb.r && rgb.g === _rgb.g && rgb.b === _rgb.b && rgb.a === _rgb.a && hex === _hex) {
      return;
    }
    $$invalidate(16, isUndefined = false);
    if (hsv && hsv.a === void 0) $$invalidate(1, hsv.a = 1, hsv);
    if (_hsv.a === void 0) $$invalidate(18, _hsv.a = 1, _hsv);
    if (rgb && rgb.a === void 0) $$invalidate(0, rgb.a = 1, rgb);
    if (_rgb.a === void 0) $$invalidate(17, _rgb.a = 1, _rgb);
    if (hex?.substring(7) === "ff") $$invalidate(2, hex = hex.substring(0, 7));
    if (hex?.substring(7) === "ff") $$invalidate(2, hex = hex.substring(0, 7));
    if (hsv && (hsv.h !== _hsv.h || hsv.s !== _hsv.s || hsv.v !== _hsv.v || hsv.a !== _hsv.a)) {
      $$invalidate(29, color = w(hsv));
      $$invalidate(0, rgb = color.toRgb());
      $$invalidate(2, hex = color.toHex());
    } else if (rgb && (rgb.r !== _rgb.r || rgb.g !== _rgb.g || rgb.b !== _rgb.b || rgb.a !== _rgb.a)) {
      $$invalidate(29, color = w(rgb));
      $$invalidate(2, hex = color.toHex());
      $$invalidate(1, hsv = color.toHsv());
    } else if (hex && hex !== _hex) {
      $$invalidate(29, color = w(hex));
      $$invalidate(0, rgb = color.toRgb());
      $$invalidate(1, hsv = color.toHsv());
    }
    if (color) {
      $$invalidate(3, isDark = color.isDark());
    }
    if (!hex) return;
    $$invalidate(18, _hsv = Object.assign({}, hsv));
    $$invalidate(17, _rgb = Object.assign({}, rgb));
    $$invalidate(19, _hex = hex);
    _isUndefined = isUndefined;
    dispatch2("input", { color, hsv, rgb, hex });
  }
  function updateLetter(letter) {
    return (e2) => {
      if (!hsv) $$invalidate(1, hsv = { ..._hsv });
      $$invalidate(1, hsv[letter] = e2.detail, hsv);
    };
  }
  function updateLetters(letters) {
    return (e2) => {
      if (!hsv) $$invalidate(1, hsv = { ..._hsv });
      letters.forEach((letter) => {
        if (hsv) $$invalidate(1, hsv[letter] = e2.detail[letter], hsv);
      });
    };
  }
  function switch_instance_labelElement_binding(value) {
    labelElement = value;
    $$invalidate(21, labelElement);
  }
  function switch_instance_isUndefined_binding(value) {
    isUndefined = value;
    $$invalidate(16, isUndefined);
  }
  const input_handler = ({ detail }) => {
    if (detail.hsv) {
      $$invalidate(1, hsv = detail.hsv);
    } else if (detail.rgb) {
      $$invalidate(0, rgb = detail.rgb);
    } else if (detail.hex) {
      $$invalidate(2, hex = detail.hex);
    }
  };
  function switch_instance_wrapper_binding(value) {
    wrapper = value;
    $$invalidate(22, wrapper);
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      spanElement = $$value;
      $$invalidate(20, spanElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("components" in $$props2) $$invalidate(30, components = $$props2.components);
    if ("label" in $$props2) $$invalidate(5, label = $$props2.label);
    if ("name" in $$props2) $$invalidate(6, name = $$props2.name);
    if ("nullable" in $$props2) $$invalidate(7, nullable = $$props2.nullable);
    if ("rgb" in $$props2) $$invalidate(0, rgb = $$props2.rgb);
    if ("hsv" in $$props2) $$invalidate(1, hsv = $$props2.hsv);
    if ("hex" in $$props2) $$invalidate(2, hex = $$props2.hex);
    if ("color" in $$props2) $$invalidate(29, color = $$props2.color);
    if ("isDark" in $$props2) $$invalidate(3, isDark = $$props2.isDark);
    if ("isAlpha" in $$props2) $$invalidate(8, isAlpha = $$props2.isAlpha);
    if ("isDialog" in $$props2) $$invalidate(9, isDialog = $$props2.isDialog);
    if ("isOpen" in $$props2) $$invalidate(4, isOpen = $$props2.isOpen);
    if ("isTextInput" in $$props2) $$invalidate(10, isTextInput = $$props2.isTextInput);
    if ("textInputModes" in $$props2) $$invalidate(11, textInputModes = $$props2.textInputModes);
    if ("sliderDirection" in $$props2) $$invalidate(12, sliderDirection = $$props2.sliderDirection);
    if ("disableCloseClickOutside" in $$props2) $$invalidate(31, disableCloseClickOutside = $$props2.disableCloseClickOutside);
    if ("a11yColors" in $$props2) $$invalidate(13, a11yColors = $$props2.a11yColors);
    if ("a11yLevel" in $$props2) $$invalidate(14, a11yLevel = $$props2.a11yLevel);
    if ("texts" in $$props2) $$invalidate(32, texts = $$props2.texts);
    if ("a11yTexts" in $$props2) $$invalidate(15, a11yTexts = $$props2.a11yTexts);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*hsv, rgb, hex*/
    7) {
      if (hsv || rgb || hex) {
        updateColor();
      }
    }
    if ($$self.$$.dirty[0] & /*isUndefined*/
    65536) {
      updateColor();
    }
  };
  return [
    rgb,
    hsv,
    hex,
    isDark,
    isOpen,
    label,
    name,
    nullable,
    isAlpha,
    isDialog,
    isTextInput,
    textInputModes,
    sliderDirection,
    a11yColors,
    a11yLevel,
    a11yTexts,
    isUndefined,
    _rgb,
    _hsv,
    _hex,
    spanElement,
    labelElement,
    wrapper,
    getComponents,
    getTexts,
    mousedown,
    keyup,
    updateLetter,
    updateLetters,
    color,
    components,
    disableCloseClickOutside,
    texts,
    switch_instance_labelElement_binding,
    switch_instance_isUndefined_binding,
    input_handler,
    switch_instance_wrapper_binding,
    span_binding
  ];
}
class ColorPicker extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$1S,
      create_fragment$1S,
      safe_not_equal,
      {
        components: 30,
        label: 5,
        name: 6,
        nullable: 7,
        rgb: 0,
        hsv: 1,
        hex: 2,
        color: 29,
        isDark: 3,
        isAlpha: 8,
        isDialog: 9,
        isOpen: 4,
        isTextInput: 10,
        textInputModes: 11,
        sliderDirection: 12,
        disableCloseClickOutside: 31,
        a11yColors: 13,
        a11yLevel: 14,
        texts: 32,
        a11yTexts: 15
      },
      null,
      [-1, -1]
    );
  }
}
function create_if_block$Q(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fas fa-eye-dropper"></i>`;
      attr(button, "type", "button");
      attr(button, "class", "eye-dropper svelte-18isctn");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1R(ctx) {
  let article_1;
  let div0;
  let label;
  let t0_value = (
    /*localize*/
    ctx[9](
      /*colorToConfigure*/
      ctx[0].name
    ) + ""
  );
  let t0;
  let label_for_value;
  let t1;
  let div1;
  let colorpicker;
  let updating_isOpen;
  let t2;
  let input;
  let input_id_value;
  let input_value_value;
  let t3;
  let current;
  let mounted;
  let dispose;
  function colorpicker_isOpen_binding(value) {
    ctx[10](value);
  }
  let colorpicker_props = {
    isDialog: true,
    label: "",
    hex: settingValueToHexaString(
      /*$context*/
      ctx[3][
        /*colorToConfigure*/
        ctx[0].key
      ]?.toString() ?? ""
    ).hexa
  };
  if (
    /*colorPickerIsOpen*/
    ctx[1] !== void 0
  ) {
    colorpicker_props.isOpen = /*colorPickerIsOpen*/
    ctx[1];
  }
  colorpicker = new ColorPicker({ props: colorpicker_props });
  binding_callbacks.push(() => bind(colorpicker, "isOpen", colorpicker_isOpen_binding));
  colorpicker.$on(
    "input",
    /*input_handler*/
    ctx[11]
  );
  let if_block = (
    /*eyeDropperEnabled*/
    ctx[6] && create_if_block$Q(ctx)
  );
  return {
    c() {
      article_1 = element("article");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      create_component(colorpicker.$$.fragment);
      t2 = space();
      input = element("input");
      t3 = space();
      if (if_block) if_block.c();
      attr(label, "for", label_for_value = /*colorToConfigure*/
      ctx[0].key + "-" + /*appId*/
      ctx[4]);
      attr(label, "class", "svelte-18isctn");
      attr(div0, "class", "description");
      attr(input, "type", "text");
      attr(input, "id", input_id_value = /*colorToConfigure*/
      ctx[0].key + "-" + /*appId*/
      ctx[4]);
      input.value = input_value_value = /*$context*/
      ctx[3][
        /*colorToConfigure*/
        ctx[0].key
      ];
      attr(input, "class", "theme-color-textbox svelte-18isctn");
      attr(div1, "class", "theme-settings-group flex-row align-items-center extra-small-gap svelte-18isctn");
      attr(article_1, "class", "svelte-18isctn");
    },
    m(target, anchor) {
      insert(target, article_1, anchor);
      append(article_1, div0);
      append(div0, label);
      append(label, t0);
      append(article_1, t1);
      append(article_1, div1);
      mount_component(colorpicker, div1, null);
      append(div1, t2);
      append(div1, input);
      append(div1, t3);
      if (if_block) if_block.m(div1, null);
      ctx[14](article_1);
      current = true;
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*change_handler*/
          ctx[12]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*colorToConfigure*/
      1) && t0_value !== (t0_value = /*localize*/
      ctx2[9](
        /*colorToConfigure*/
        ctx2[0].name
      ) + "")) set_data(t0, t0_value);
      if (!current || dirty & /*colorToConfigure*/
      1 && label_for_value !== (label_for_value = /*colorToConfigure*/
      ctx2[0].key + "-" + /*appId*/
      ctx2[4])) {
        attr(label, "for", label_for_value);
      }
      const colorpicker_changes = {};
      if (dirty & /*$context, colorToConfigure*/
      9) colorpicker_changes.hex = settingValueToHexaString(
        /*$context*/
        ctx2[3][
          /*colorToConfigure*/
          ctx2[0].key
        ]?.toString() ?? ""
      ).hexa;
      if (!updating_isOpen && dirty & /*colorPickerIsOpen*/
      2) {
        updating_isOpen = true;
        colorpicker_changes.isOpen = /*colorPickerIsOpen*/
        ctx2[1];
        add_flush_callback(() => updating_isOpen = false);
      }
      colorpicker.$set(colorpicker_changes);
      if (!current || dirty & /*colorToConfigure*/
      1 && input_id_value !== (input_id_value = /*colorToConfigure*/
      ctx2[0].key + "-" + /*appId*/
      ctx2[4])) {
        attr(input, "id", input_id_value);
      }
      if (!current || dirty & /*$context, colorToConfigure*/
      9 && input_value_value !== (input_value_value = /*$context*/
      ctx2[3][
        /*colorToConfigure*/
        ctx2[0].key
      ]) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (
        /*eyeDropperEnabled*/
        ctx2[6]
      ) if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current) return;
      transition_in(colorpicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(colorpicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article_1);
      }
      destroy_component(colorpicker);
      if (if_block) if_block.d();
      ctx[14](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$1R($$self, $$props, $$invalidate) {
  let $context;
  let { colorToConfigure } = $$props;
  let appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  let colorPickerIsOpen = false;
  const eyeDropperEnabled = "EyeDropper" in window;
  function activateEyeDropper(colorToConfigure2) {
    if ("EyeDropper" in window) {
      const EyeDropper = window.EyeDropper;
      const eyeDropper = new EyeDropper();
      eyeDropper.open().then(({ sRGBHex }) => {
        onColorSelected(colorToConfigure2, sRGBHex);
      });
    }
  }
  function onColorSelected(colorToConfigure2, value) {
    const parsedColor = settingValueToHexaString(value);
    if (!parsedColor) {
      return;
    }
    trySetRootCssVariable(colorToConfigure2.cssVariable, value, $context.colorPickerEnabled);
    set_store_value(
      context,
      $context = {
        ...$context,
        [colorToConfigure2.key]: value
      },
      $context
    );
  }
  let article;
  onMount(() => {
    article.querySelectorAll("button").forEach((button) => {
      if (button.type === "submit") {
        button.type = "button";
      }
    });
  });
  const localize = FoundryAdapter.localize;
  function colorpicker_isOpen_binding(value) {
    colorPickerIsOpen = value;
    $$invalidate(1, colorPickerIsOpen);
  }
  const input_handler = (ev) => colorPickerIsOpen && onColorSelected(colorToConfigure, colorToHexaString(ev.detail.color));
  const change_handler = (ev) => onColorSelected(colorToConfigure, ev.currentTarget.value);
  const click_handler = () => activateEyeDropper(colorToConfigure);
  function article_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      article = $$value;
      $$invalidate(2, article);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("colorToConfigure" in $$props2) $$invalidate(0, colorToConfigure = $$props2.colorToConfigure);
  };
  return [
    colorToConfigure,
    colorPickerIsOpen,
    article,
    $context,
    appId,
    context,
    eyeDropperEnabled,
    activateEyeDropper,
    onColorSelected,
    localize,
    colorpicker_isOpen_binding,
    input_handler,
    change_handler,
    click_handler,
    article_1_binding
  ];
}
class ThemeSettingColorArticle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1R, create_fragment$1R, safe_not_equal, { colorToConfigure: 0 });
  }
}
function downloadTextFile(filename, text2) {
  const a2 = document.createElement("a");
  const blob = new Blob([text2], { type: "text/json;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  a2.setAttribute("href", url);
  a2.setAttribute("download", filename);
  a2.click();
}
function getSingleFileFromDropEvent(ev) {
  ev.preventDefault();
  let file = null;
  if (ev.dataTransfer?.items) {
    file = ev.dataTransfer.items[0]?.getAsFile();
  } else if (ev.dataTransfer?.files) {
    file = ev.dataTransfer.files[0];
  }
  return file;
}
function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.addEventListener("load", (event) => {
      try {
        const result = event.target?.result?.toString();
        resolve(result ?? "");
      } catch (e2) {
        reject(e2);
      }
    });
    fileReader.readAsText(file);
  });
}
function get_each_context$j(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function create_each_block$j(ctx) {
  let themesettingcolorarticle;
  let current;
  themesettingcolorarticle = new ThemeSettingColorArticle({
    props: {
      colorToConfigure: (
        /*colorToConfigure*/
        ctx[9]
      )
    }
  });
  return {
    c() {
      create_component(themesettingcolorarticle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themesettingcolorarticle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const themesettingcolorarticle_changes = {};
      if (dirty & /*themeableColors*/
      1) themesettingcolorarticle_changes.colorToConfigure = /*colorToConfigure*/
      ctx2[9];
      themesettingcolorarticle.$set(themesettingcolorarticle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(themesettingcolorarticle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themesettingcolorarticle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(themesettingcolorarticle, detaching);
    }
  };
}
function create_fragment$1Q(ctx) {
  let section;
  let div2;
  let h2;
  let t0_value = (
    /*localize*/
    ctx[4]("TIDY5E.ThemeSettings.Sheet.header") + ""
  );
  let t0;
  let t1;
  let themesettingsheetmenu;
  let t2;
  let div0;
  let label;
  let input;
  let t3;
  let t4_value = (
    /*localize*/
    ctx[4]("TIDY5E.Settings.ColorPickerEnabled.name") + ""
  );
  let t4;
  let t5;
  let p0;
  let t7;
  let p1;
  let t9;
  let div1;
  let t10;
  let div3;
  let button;
  let i2;
  let t11;
  let t12_value = (
    /*localize*/
    ctx[4]("TIDY5E.SaveChanges") + ""
  );
  let t12;
  let current;
  let mounted;
  let dispose;
  themesettingsheetmenu = new ThemeSettingSheetMenu({});
  themesettingsheetmenu.$on(
    "selectFile",
    /*selectFile_handler*/
    ctx[7]
  );
  let each_value = ensure_array_like(
    /*themeableColors*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$j(get_each_context$j(ctx, each_value, i3));
  }
  const out = (i3) => transition_out(each_blocks[i3], 1, 1, () => {
    each_blocks[i3] = null;
  });
  return {
    c() {
      section = element("section");
      div2 = element("div");
      h2 = element("h2");
      t0 = text(t0_value);
      t1 = space();
      create_component(themesettingsheetmenu.$$.fragment);
      t2 = space();
      div0 = element("div");
      label = element("label");
      input = element("input");
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      p0 = element("p");
      p0.textContent = `${/*localize*/
      ctx[4]("TIDY5E.ThemeSettings.Sheet.explanation")}`;
      t7 = space();
      p1 = element("p");
      p1.textContent = `${/*localize*/
      ctx[4]("TIDY5E.ThemeSettings.Sheet.importDropHint")}`;
      t9 = space();
      div1 = element("div");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t10 = space();
      div3 = element("div");
      button = element("button");
      i2 = element("i");
      t11 = space();
      t12 = text(t12_value);
      attr(h2, "class", "header flex-row justify-content-space-between svelte-1zri33");
      attr(input, "type", "checkbox");
      attr(input, "id", "colorPickerEnabled-" + /*appId*/
      ctx[3]);
      attr(label, "for", "colorPickerEnabled-" + /*appId*/
      ctx[3]);
      attr(label, "class", "flex-row align-items-center extra-small-gap");
      attr(p0, "class", "explanation svelte-1zri33");
      attr(p1, "class", "explanation drop-hint svelte-1zri33");
      attr(div1, "class", "color-pickers");
      attr(div2, "class", "theme-settings-form scroll-container svelte-1zri33");
      attr(i2, "class", "fas fa-save");
      attr(button, "type", "submit");
      attr(button, "class", "save-changes-btn svelte-1zri33");
      attr(div3, "class", "button-bar svelte-1zri33");
      attr(section, "class", "theme-settings-wrapper svelte-1zri33");
      attr(section, "aria-label", "dropzone");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, h2);
      append(h2, t0);
      append(h2, t1);
      mount_component(themesettingsheetmenu, h2, null);
      append(div2, t2);
      append(div2, div0);
      append(div0, label);
      append(label, input);
      input.checked = /*$context*/
      ctx[1].colorPickerEnabled;
      append(label, t3);
      append(label, t4);
      append(div2, t5);
      append(div2, p0);
      append(div2, t7);
      append(div2, p1);
      append(div2, t9);
      append(div2, div1);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(div1, null);
        }
      }
      append(section, t10);
      append(section, div3);
      append(div3, button);
      append(button, i2);
      append(button, t11);
      append(button, t12);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[8]
          ),
          listen(
            section,
            "drop",
            /*onDrop*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      2) {
        input.checked = /*$context*/
        ctx2[1].colorPickerEnabled;
      }
      if (dirty & /*themeableColors*/
      1) {
        each_value = ensure_array_like(
          /*themeableColors*/
          ctx2[0]
        );
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$j(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
            transition_in(each_blocks[i3], 1);
          } else {
            each_blocks[i3] = create_each_block$j(child_ctx);
            each_blocks[i3].c();
            transition_in(each_blocks[i3], 1);
            each_blocks[i3].m(div1, null);
          }
        }
        group_outros();
        for (i3 = each_value.length; i3 < each_blocks.length; i3 += 1) {
          out(i3);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(themesettingsheetmenu.$$.fragment, local);
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        transition_in(each_blocks[i3]);
      }
      current = true;
    },
    o(local) {
      transition_out(themesettingsheetmenu.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        transition_out(each_blocks[i3]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(themesettingsheetmenu);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1Q($$self, $$props, $$invalidate) {
  let $context;
  let { themeableColors } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  const localize = FoundryAdapter.localize;
  async function processImportFile(file) {
    try {
      let result = await readFileAsText(file);
      result = result.replaceAll(`"--t5ek-`, `"--t5e-`);
      const theme = JSON.parse(result);
      const isValid = validateImportFile(theme);
      if (!isValid) {
        throw new Error(`Theme file ${file.name} is in an invalid format.`);
      }
      const storeUpdateData = extractSettingsUpdateDeltaFromTheme(theme, themeableColors);
      context.update((settings) => ({ ...settings, ...storeUpdateData }));
      ui.notifications.info(localize("TIDY5E.ThemeSettings.Sheet.importSuccess"));
    } catch (e2) {
      ui.notifications.error(localize("TIDY5E.ThemeSettings.Sheet.importError"));
      error("An error occurred while attempting to import a theme file. See the devtools console for more details.", true, e2);
    }
  }
  function onDrop(ev) {
    let file = getSingleFileFromDropEvent(ev);
    if (file) {
      processImportFile(file);
    }
  }
  onDestroy(() => {
    clearTidy5eRootCssVariables();
  });
  const selectFile_handler = (ev) => processImportFile(ev.detail);
  function input_change_handler() {
    $context.colorPickerEnabled = this.checked;
    context.set($context);
  }
  $$self.$$set = ($$props2) => {
    if ("themeableColors" in $$props2) $$invalidate(0, themeableColors = $$props2.themeableColors);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, themeableColors*/
    3) {
      {
        if ($context.colorPickerEnabled) {
          themeableColors.forEach((color) => trySetRootCssVariable(color.cssVariable, $context[color.key]?.toString(), $context.colorPickerEnabled));
        } else {
          clearTidy5eRootCssVariables();
          applyCurrentTheme(false);
        }
      }
    }
  };
  return [
    themeableColors,
    $context,
    context,
    appId,
    localize,
    processImportFile,
    onDrop,
    selectFile_handler,
    input_change_handler
  ];
}
class ThemeSettingsSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Q, create_fragment$1Q, safe_not_equal, { themeableColors: 0 });
  }
}
class ThemeSettingsFormApplication extends SvelteFormApplicationBase {
  themeableColors = getThemeableColors();
  context = writable(getCurrentSettings());
  static get defaultOptions() {
    return {
      ...super.defaultOptions,
      height: 750,
      width: 400,
      submitOnClose: false,
      minimizable: true,
      id: "tidy-5e-sheets-theme-settings",
      popOut: true,
      resizable: true
    };
  }
  get title() {
    return FoundryAdapter.localize("TIDY5E.ThemeSettings.Sheet.title", {
      userName: game.user.name
    });
  }
  createComponent(node) {
    return new ThemeSettingsSheet({
      target: node,
      props: {
        themeableColors: this.themeableColors
      },
      context: /* @__PURE__ */ new Map([
        ["context", this.context],
        [
          "functions",
          {
            save: this.saveChangedSettings.bind(this),
            useExistingThemeColors: this.useExistingThemeColors.bind(this),
            exportTheme: this.exportTheme.bind(this)
          }
        ],
        ["appId", this.appId]
      ])
    });
  }
  refreshContext() {
    this.context.set(getCurrentSettings());
  }
  async saveChangedSettings(newSettings) {
    for (let color of this.themeableColors) {
      await FoundryAdapter.setTidySetting(color.key, newSettings[color.key]);
    }
    await FoundryAdapter.setTidySetting(
      "colorPickerEnabled",
      newSettings.colorPickerEnabled
    );
    applyCurrentTheme();
    this.close();
  }
  useExistingThemeColors(themeId) {
    const targetTheme = getThemeOrDefault(themeId);
    const colorsToUpdate = this.themeableColors.reduce(
      (prev, color) => {
        prev[color.key] = targetTheme.variables[color.cssVariable];
        return prev;
      },
      {}
    );
    this.context.update((current) => {
      return {
        ...current,
        ...colorsToUpdate
      };
    });
  }
  exportTheme(settings) {
    const variables = this.themeableColors.reduce(
      (prev, curr) => {
        prev[curr.cssVariable] = settings[curr.key]?.toString();
        return prev;
      },
      {}
    );
    const exportData = {
      version: 1,
      variables
    };
    downloadTextFile(
      "theme" + CONSTANTS.THEME_EXTENSION_WITH_DOT,
      JSON.stringify(exportData, null, " ")
    );
  }
  async _updateObject() {
    const settings = get_store_value(this.context);
    await this.saveChangedSettings(settings);
  }
}
async function migrateNpcDeathFlagsToSystem({
  npc,
  overwrite,
  clearDeathFlagData
}) {
  const tidyDeath = TidyFlags.tryGetFlag(npc, "death");
  if (!tidyDeath) {
    return;
  }
  const systemDeath = npc.system.attributes?.death;
  if (!systemDeath) {
    return;
  }
  const update2 = {};
  if (systemDeath?.success === 0 || overwrite) {
    update2["system.attributes.death.success"] = tidyDeath.success;
  }
  if (systemDeath?.failure === 0 || overwrite) {
    update2["system.attributes.death.failure"] = tidyDeath.failure;
  }
  if (Object.keys(systemDeath).length) {
    await npc.update(update2);
  }
  if (clearDeathFlagData) {
    TidyFlags.unsetFlag(npc, "death");
  }
}
function get_each_context_2$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function get_each_context$i(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  child_ctx[16] = list;
  child_ctx[17] = i2;
  return child_ctx;
}
function get_each_context_1$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  const constants_0 = (
    /*column*/
    child_ctx[18].field
  );
  child_ctx[19] = constants_0;
  return child_ctx;
}
function get_if_ctx$5(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = FoundryAdapter.getProperty(
    /*selectable*/
    child_ctx[15].document,
    /*field*/
    child_ctx[19].propPath
  ) ?? "";
  child_ctx[22] = constants_0;
  return child_ctx;
}
function create_default_slot_5$b(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(
        input,
        "title",
        /*localize*/
        ctx[8]("TIDY5E.Settings.Migrations.Selection.SelectAllNoneTooltip")
      );
      attr(input, "class", "svelte-16v6ss3");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*allSelected*/
      ctx[4];
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[12]
          ),
          listen(
            input,
            "click",
            /*click_handler_1*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*allSelected*/
      16) {
        input.checked = /*allSelected*/
        ctx2[4];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_4$d(ctx) {
  let t0_value = (
    /*column*/
    (ctx[18].name ?? "") + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*params*/
      1 && t0_value !== (t0_value = /*column*/
      (ctx2[18].name ?? "") + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block_2$1(ctx) {
  let tidytableheadercell;
  let current;
  tidytableheadercell = new TidyTableHeaderCell({
    props: {
      primary: (
        /*column*/
        ctx[18]?.cellWidth === "primary"
      ),
      $$slots: { default: [create_default_slot_4$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheadercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheadercell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheadercell_changes = {};
      if (dirty & /*params*/
      1) tidytableheadercell_changes.primary = /*column*/
      ctx2[18]?.cellWidth === "primary";
      if (dirty & /*$$scope, params*/
      33554433) {
        tidytableheadercell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell.$set(tidytableheadercell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheadercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheadercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytableheadercell, detaching);
    }
  };
}
function create_default_slot_3$g(ctx) {
  let tidytableheadercell;
  let t2;
  let each_1_anchor;
  let current;
  tidytableheadercell = new TidyTableHeaderCell({
    props: {
      $$slots: { default: [create_default_slot_5$b] },
      $$scope: { ctx }
    }
  });
  let each_value_2 = ensure_array_like(
    /*params*/
    ctx[0].columns
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(tidytableheadercell.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(tidytableheadercell, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheadercell_changes = {};
      if (dirty & /*$$scope, allSelected*/
      33554448) {
        tidytableheadercell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell.$set(tidytableheadercell_changes);
      if (dirty & /*params*/
      1) {
        each_value_2 = ensure_array_like(
          /*params*/
          ctx2[0].columns
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheadercell.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(tidytableheadercell.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(tidytableheadercell, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_header_slot$2(ctx) {
  let tidytableheaderrow;
  let current;
  tidytableheaderrow = new TidyTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_3$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheaderrow_changes = {};
      if (dirty & /*$$scope, params, allSelected*/
      33554449) {
        tidytableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheaderrow.$set(tidytableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytableheaderrow, detaching);
    }
  };
}
function create_default_slot_2$g(ctx) {
  let input;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[10].call(
      input,
      /*each_value*/
      ctx[16],
      /*selectable_index*/
      ctx[17]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "class", "svelte-16v6ss3");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*selectable*/
      ctx[15].selected;
      if (!mounted) {
        dispose = listen(input, "change", input_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*params*/
      1) {
        input.checked = /*selectable*/
        ctx[15].selected;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$u(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*field*/
      ctx2[19].onClick
    ) return create_if_block_2$m;
    return create_else_block$u;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block$P(ctx) {
  let t_value = (
    /*field*/
    (ctx[19].getText(
      /*selectable*/
      ctx[15].document
    ) ?? "") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*params*/
      1 && t_value !== (t_value = /*field*/
      (ctx2[19].getText(
        /*selectable*/
        ctx2[15].document
      ) ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_else_block$u(ctx) {
  let div;
  let t_value = (
    /*text*/
    ctx[22] + ""
  );
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*params*/
      1 && t_value !== (t_value = /*text*/
      ctx2[22] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_2$m(ctx) {
  let button;
  let t_value = (
    /*text*/
    ctx[22] + ""
  );
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[11](
        /*field*/
        ctx[19],
        /*selectable*/
        ctx[15]
      )
    );
  }
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "inline-transparent-button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*params*/
      1 && t_value !== (t_value = /*text*/
      ctx[22] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$k(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*field*/
      ctx2[19].type === "contextual"
    ) return create_if_block$P;
    if (
      /*column*/
      ctx2[18].field.type === "simple"
    ) return create_if_block_1$u;
  }
  function select_block_ctx(ctx2, type) {
    if (type === create_if_block_1$u) return get_if_ctx$5(ctx2);
    return ctx2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(select_block_ctx(ctx, current_block_type));
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(select_block_ctx(ctx2, current_block_type), dirty);
      } else {
        if (if_block) if_block.d(1);
        if_block = current_block_type && current_block_type(select_block_ctx(ctx2, current_block_type));
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function create_each_block_1$7(ctx) {
  let tidytablecell;
  let current;
  tidytablecell = new TidyTableCell({
    props: {
      primary: (
        /*column*/
        ctx[18]?.cellWidth === "primary"
      ),
      class: "flex-row small-gap",
      $$slots: { default: [create_default_slot_1$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytablecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytablecell_changes = {};
      if (dirty & /*params*/
      1) tidytablecell_changes.primary = /*column*/
      ctx2[18]?.cellWidth === "primary";
      if (dirty & /*$$scope, params*/
      33554433) {
        tidytablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell.$set(tidytablecell_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytablecell, detaching);
    }
  };
}
function create_default_slot$M(ctx) {
  let tidytablecell;
  let t0;
  let t1;
  let current;
  tidytablecell = new TidyTableCell({
    props: {
      $$slots: { default: [create_default_slot_2$g] },
      $$scope: { ctx }
    }
  });
  let each_value_1 = ensure_array_like(
    /*params*/
    ctx[0].columns
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(tidytablecell.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
    },
    m(target, anchor) {
      mount_component(tidytablecell, target, anchor);
      insert(target, t0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytablecell_changes = {};
      if (dirty & /*$$scope, params*/
      33554433) {
        tidytablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell.$set(tidytablecell_changes);
      if (dirty & /*params*/
      1) {
        each_value_1 = ensure_array_like(
          /*params*/
          ctx2[0].columns
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$7(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(tidytablecell.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(tidytablecell.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(tidytablecell, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$i(ctx) {
  let tidytablerow;
  let current;
  tidytablerow = new TidyTableRow({
    props: {
      hidden: !/*visibleSelectablesIdSubset*/
      ctx[5].has(
        /*selectable*/
        ctx[15].document.id
      ),
      $$slots: { default: [create_default_slot$M] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytablerow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytablerow_changes = {};
      if (dirty & /*visibleSelectablesIdSubset, params*/
      33) tidytablerow_changes.hidden = !/*visibleSelectablesIdSubset*/
      ctx2[5].has(
        /*selectable*/
        ctx2[15].document.id
      );
      if (dirty & /*$$scope, params*/
      33554433) {
        tidytablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablerow.$set(tidytablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytablerow, detaching);
    }
  };
}
function create_body_slot$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*params*/
    ctx[0].selectables
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$i(get_each_context$i(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*visibleSelectablesIdSubset, params*/
      33) {
        each_value = ensure_array_like(
          /*params*/
          ctx2[0].selectables
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$i(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$i(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$1P(ctx) {
  let section;
  let div0;
  let search;
  let updating_value;
  let t0;
  let div1;
  let tidytable;
  let div;
  let t1;
  let footer;
  let p2;
  let t2_value = (
    /*localize*/
    ctx[8]("TIDY5E.Settings.Migrations.Selection.TotalSelectedLabel", { total: (
      /*totalSelected*/
      ctx[2]
    ) }) + ""
  );
  let t2;
  let t3;
  let button;
  let current;
  let mounted;
  let dispose;
  function search_value_binding(value) {
    ctx[9](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[1] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[1];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  tidytable = new TidyTable({
    props: {
      key: "bulk-selection",
      toggleable: false,
      $$slots: {
        body: [create_body_slot$1],
        header: [create_header_slot$2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section = element("section");
      div0 = element("div");
      create_component(search.$$.fragment);
      t0 = space();
      div1 = element("div");
      div = element("div");
      create_component(tidytable.$$.fragment);
      t1 = space();
      footer = element("footer");
      p2 = element("p");
      t2 = text(t2_value);
      t3 = space();
      button = element("button");
      button.textContent = `${/*localize*/
      ctx[8]("TIDY5E.ButtonConfirm.Text")}`;
      attr(div0, "role", "presentation");
      attr(div0, "class", "search-container svelte-16v6ss3");
      set_style(div, "display", "contents");
      set_style(
        div,
        "--grid-template-columns",
        /*gridTemplateColumns*/
        ctx[3]
      );
      attr(div1, "role", "presentation");
      attr(div1, "class", "scroll-container svelte-16v6ss3");
      attr(footer, "class", "svelte-16v6ss3");
      attr(section, "class", "svelte-16v6ss3");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div0);
      mount_component(search, div0, null);
      append(section, t0);
      append(section, div1);
      append(div1, div);
      mount_component(tidytable, div, null);
      append(section, t1);
      append(section, footer);
      append(footer, p2);
      append(p2, t2);
      append(footer, t3);
      append(footer, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const search_changes = {};
      if (!updating_value && dirty & /*searchCriteria*/
      2) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      if (dirty & /*gridTemplateColumns*/
      8) {
        set_style(
          div,
          "--grid-template-columns",
          /*gridTemplateColumns*/
          ctx2[3]
        );
      }
      const tidytable_changes = {};
      if (dirty & /*$$scope, params, visibleSelectablesIdSubset, allSelected*/
      33554481) {
        tidytable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytable.$set(tidytable_changes);
      if ((!current || dirty & /*totalSelected*/
      4) && t2_value !== (t2_value = /*localize*/
      ctx2[8]("TIDY5E.Settings.Migrations.Selection.TotalSelectedLabel", { total: (
        /*totalSelected*/
        ctx2[2]
      ) }) + "")) set_data(t2, t2_value);
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(tidytable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(tidytable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(search);
      destroy_component(tidytable);
      mounted = false;
      dispose();
    }
  };
}
function instance$1P($$self, $$props, $$invalidate) {
  let visibleSelectablesIdSubset;
  let totalSelected;
  let allSelected;
  let { params } = $$props;
  let searchCriteria = "";
  let gridTemplateColumns;
  function onMigrateClicked() {
    const selectedTargets = params.selectables.filter((t2) => t2.selected).map((t2) => t2.document);
    params.onConfirm(selectedTargets);
  }
  function toggleAll() {
    const targetState = !allSelected;
    params.selectables.forEach((o2) => o2.selected = targetState);
  }
  const localize = FoundryAdapter.localize;
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(1, searchCriteria);
  }
  function input_change_handler(each_value, selectable_index) {
    each_value[selectable_index].selected = this.checked;
    $$invalidate(0, params);
  }
  const click_handler = (field, selectable) => field.onClick?.(selectable.document);
  function input_change_handler_1() {
    allSelected = this.checked;
    $$invalidate(4, allSelected), $$invalidate(2, totalSelected), $$invalidate(0, params);
  }
  const click_handler_1 = () => toggleAll();
  const click_handler_2 = () => onMigrateClicked();
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2) $$invalidate(0, params = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*params, searchCriteria*/
    3) {
      $$invalidate(5, visibleSelectablesIdSubset = new Set(params.selectables.filter((s2) => searchCriteria.trim() === "" || s2.document.name?.toLowerCase().includes(searchCriteria.toLowerCase())).map((d2) => d2.document.id)));
    }
    if ($$self.$$.dirty & /*params, gridTemplateColumns*/
    9) {
      {
        $$invalidate(3, gridTemplateColumns = `/* Select */ 2.5rem`);
        params.columns.forEach((c2) => {
          const measurement = c2.cellWidth === "primary" ? "1fr" : c2.cellWidth;
          $$invalidate(3, gridTemplateColumns += ` /* ${c2.name} */ ${measurement}`);
        });
      }
    }
    if ($$self.$$.dirty & /*params*/
    1) {
      $$invalidate(2, totalSelected = params.selectables.filter((t2) => t2.selected).length);
    }
    if ($$self.$$.dirty & /*totalSelected, params*/
    5) {
      $$invalidate(4, allSelected = totalSelected >= params.selectables.length);
    }
  };
  return [
    params,
    searchCriteria,
    totalSelected,
    gridTemplateColumns,
    allSelected,
    visibleSelectablesIdSubset,
    onMigrateClicked,
    toggleAll,
    localize,
    search_value_binding,
    input_change_handler,
    click_handler,
    input_change_handler_1,
    click_handler_1,
    click_handler_2
  ];
}
class MigrationSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1P, create_fragment$1P, safe_not_equal, { params: 0 });
  }
}
class MigrationSelectionApplication extends SvelteFormApplicationBase {
  _params;
  _onClose;
  constructor(params, onClose, options) {
    super(
      {},
      FoundryAdapter.mergeObject(
        MigrationSelectionApplication.defaultOptions,
        options
      )
    );
    this._params = params;
    this._onClose = onClose;
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      width: 650,
      height: 500,
      id: "tidy-5e-sheets-migration-selection",
      popOut: true
    });
  }
  get title() {
    return this._params.title ?? FoundryAdapter.localize("TIDY5E.Settings.Migrations.dialogTitle");
  }
  createComponent(node) {
    const selectableParams = {
      ...this._params,
      selectables: this._params.documents.map((d2) => ({
        document: d2,
        selected: true
      }))
    };
    return new MigrationSelection({
      target: node,
      props: {
        params: selectableParams
      }
    });
  }
  close(...args) {
    this._onClose?.();
    super.close(...args);
  }
}
function create_fragment$1O(ctx) {
  let section;
  let h2;
  let t1;
  let ul;
  let li;
  let t3;
  let p2;
  let t5;
  let h3;
  let t7;
  let div;
  let label0;
  let input0;
  let t8;
  let t9_value = (
    /*localize*/
    ctx[4]("TIDY5E.Settings.Migrations.OptionOverwrite.Text") + ""
  );
  let t9;
  let t10;
  let label1;
  let input1;
  let t11;
  let t12_value = (
    /*localize*/
    ctx[4]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Text") + ""
  );
  let t12;
  let t13;
  let button;
  let t14_value = (
    /*localize*/
    ctx[4]("TIDY5E.Settings.Migrations.ButtonMigration.Text") + ""
  );
  let t14;
  let mounted;
  let dispose;
  return {
    c() {
      section = element("section");
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[4]("TIDY5E.Settings.Migrations.NpcDeathSaves.sectionTitle")}`;
      t1 = space();
      ul = element("ul");
      li = element("li");
      li.textContent = `${/*localize*/
      ctx[4]("DND5E.DeathSave")}`;
      t3 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[4]("TIDY5E.Settings.Migrations.UnlinkedExplanation")}`;
      t5 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[4]("TIDY5E.Settings.Migrations.OptionsHeader")}`;
      t7 = space();
      div = element("div");
      label0 = element("label");
      input0 = element("input");
      t8 = space();
      t9 = text(t9_value);
      t10 = space();
      label1 = element("label");
      input1 = element("input");
      t11 = space();
      t12 = text(t12_value);
      t13 = space();
      button = element("button");
      t14 = text(t14_value);
      attr(input0, "type", "checkbox");
      input0.disabled = /*migrating*/
      ctx[0];
      attr(label0, "class", "green-checkbox");
      attr(
        label0,
        "data-tooltip",
        /*localize*/
        ctx[4]("TIDY5E.Settings.Migrations.OptionOverwrite.Tooltip")
      );
      attr(input1, "type", "checkbox");
      input1.disabled = /*migrating*/
      ctx[0];
      attr(label1, "class", "green-checkbox");
      attr(
        label1,
        "data-tooltip",
        /*localize*/
        ctx[4]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Tooltip")
      );
      attr(div, "class", "options grid-auto-columns svelte-f3txbi");
      attr(button, "type", "button");
      button.disabled = /*migrating*/
      ctx[0];
      attr(button, "class", "svelte-f3txbi");
      attr(section, "class", "svelte-f3txbi");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h2);
      append(section, t1);
      append(section, ul);
      append(ul, li);
      append(section, t3);
      append(section, p2);
      append(section, t5);
      append(section, h3);
      append(section, t7);
      append(section, div);
      append(div, label0);
      append(label0, input0);
      input0.checked = /*overwrite*/
      ctx[1];
      append(label0, t8);
      append(label0, t9);
      append(div, t10);
      append(div, label1);
      append(label1, input1);
      input1.checked = /*deleteFlags*/
      ctx[2];
      append(label1, t11);
      append(label1, t12);
      append(section, t13);
      append(section, button);
      append(button, t14);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[5]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[6]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*migrating*/
      1) {
        input0.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*overwrite*/
      2) {
        input0.checked = /*overwrite*/
        ctx2[1];
      }
      if (dirty & /*migrating*/
      1) {
        input1.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*deleteFlags*/
      4) {
        input1.checked = /*deleteFlags*/
        ctx2[2];
      }
      if (dirty & /*migrating*/
      1) {
        button.disabled = /*migrating*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1O($$self, $$props, $$invalidate) {
  let migrating = false;
  let overwrite = false;
  let deleteFlags = false;
  async function migrate() {
    try {
      const actorsToMigrate = Array.from(game.actors).filter((a2) => a2.type === CONSTANTS.SHEET_TYPE_NPC && a2.isOwner).map((a2) => ({ actor: a2, unlinked: false }));
      const tokenActors = Array.from(canvas?.scene?.tokens ?? []).map((t2) => ({ actor: t2.actor, unlinked: true })).filter((a2) => a2.actor && !a2.actor.prototypeToken?.actorLink && a2.actor.isOwner);
      actorsToMigrate.push(...tokenActors);
      new MigrationSelectionApplication(
        {
          onConfirm: async (selected) => {
            $$invalidate(0, migrating = true);
            ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationBeginningMessage"));
            migrateActors(selected.map((s2) => s2.actor));
          },
          columns: [
            {
              cellWidth: "primary",
              field: {
                type: "simple",
                propPath: "actor.name",
                onClick: (target) => target.actor.sheet.render(true)
              },
              name: localize("TIDY5E.Settings.Migrations.Selection.ToMigrate")
            },
            {
              cellWidth: "5rem",
              field: {
                type: "simple",
                propPath: `actor.flags.${CONSTANTS.MODULE_ID}.death.success`
              },
              name: localize("DND5E.DeathSaveSuccesses")
            },
            {
              cellWidth: "5rem",
              field: {
                type: "simple",
                propPath: `actor.flags.${CONSTANTS.MODULE_ID}.death.failure`
              },
              name: localize("DND5E.DeathSaveFailures")
            },
            {
              cellWidth: "10rem",
              name: "",
              field: {
                type: "contextual",
                getText: ({ unlinked }) => unlinked ? FoundryAdapter.localize("TIDY5E.TokenUnlinked") : FoundryAdapter.localize("DOCUMENT.Actor")
              }
            }
          ],
          documents: actorsToMigrate,
          title: FoundryAdapter.localize("TIDY5E.Settings.Migrations.NpcDeathSaves.selectionDialogTitle")
        },
        () => {
          $$invalidate(0, migrating = false);
        }
      ).render(true);
    } catch (e2) {
      error("An error occurred while preparing a bulk migration", false, e2);
    }
  }
  async function migrateActors(actors) {
    try {
      for (let actorToMigrate of actors) {
        await migrateActor(actorToMigrate);
      }
    } finally {
      $$invalidate(0, migrating = false);
      ui.notifications.info(FoundryAdapter.localize("TIDY5E.Settings.Migrations.migrationCompleteMessage"));
      resetOptions();
    }
  }
  function resetOptions() {
    $$invalidate(1, overwrite = false);
    $$invalidate(2, deleteFlags = false);
  }
  async function migrateActor(actor) {
    try {
      debug(`Migrating actor ${actor?.name}...`);
      migrateNpcDeathFlagsToSystem({
        npc: actor,
        overwrite,
        clearDeathFlagData: deleteFlags
      });
      debug(`Actor ${actor?.name} migration successful!`);
    } catch (e2) {
      error(`An error occurred while migrating NPC death save data for ${actor?.name}`, false, e2);
      ui.notifications.error(FoundryAdapter.localize("TIDY5E.Settings.Migrations.migrationErrorMessage"), { permanent: true });
    }
  }
  const localize = FoundryAdapter.localize;
  function input0_change_handler() {
    overwrite = this.checked;
    $$invalidate(1, overwrite);
  }
  function input1_change_handler() {
    deleteFlags = this.checked;
    $$invalidate(2, deleteFlags);
  }
  const click_handler = (ev) => migrate();
  return [
    migrating,
    overwrite,
    deleteFlags,
    migrate,
    localize,
    input0_change_handler,
    input1_change_handler,
    click_handler
  ];
}
class NpcDeathSavesMigration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1O, create_fragment$1O, safe_not_equal, {});
  }
}
const mappings = [
  {
    system: "system.details.gender",
    tidy: "flags.tidy5e-sheet.gender",
    tidyDelete: "flags.tidy5e-sheet.-=gender"
  },
  {
    system: "system.details.eyes",
    tidy: "flags.tidy5e-sheet.eyes",
    tidyDelete: "flags.tidy5e-sheet.-=eyes"
  },
  {
    system: "system.details.height",
    tidy: "flags.tidy5e-sheet.height",
    tidyDelete: "flags.tidy5e-sheet.-=height"
  },
  {
    system: "system.details.hair",
    tidy: "flags.tidy5e-sheet.hair",
    tidyDelete: "flags.tidy5e-sheet.-=hair"
  },
  {
    system: "system.details.skin",
    tidy: "flags.tidy5e-sheet.skin",
    tidyDelete: "flags.tidy5e-sheet.-=skin"
  },
  {
    system: "system.details.age",
    tidy: "flags.tidy5e-sheet.age",
    tidyDelete: "flags.tidy5e-sheet.-=age"
  },
  {
    system: "system.details.weight",
    tidy: "flags.tidy5e-sheet.weight",
    tidyDelete: "flags.tidy5e-sheet.-=weight"
  }
];
async function migrateBiographicalFlagsToSystemData(params) {
  const { document: document2, overwrite, clearBiographicalFlagData } = params;
  let diff = {};
  for (let { system, tidy, tidyDelete } of mappings) {
    const systemValue = foundry.utils.getProperty(document2, system) ?? "";
    const tidyValue = foundry.utils.getProperty(document2, tidy) ?? "";
    if (isNil(systemValue, "") || overwrite) {
      diff[system] = tidyValue;
    }
    if (clearBiographicalFlagData) {
      diff[tidyDelete] = null;
    }
  }
  if (Object.keys(diff).length) {
    await document2.update(diff);
  }
}
function create_fragment$1N(ctx) {
  let section;
  let h2;
  let t1;
  let ul;
  let li0;
  let t3;
  let li1;
  let t5;
  let li2;
  let t7;
  let li3;
  let t9;
  let li4;
  let t11;
  let li5;
  let t13;
  let li6;
  let t15;
  let h3;
  let t17;
  let div;
  let label0;
  let input0;
  let t18;
  let t19_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.OptionOverwrite.Text") + ""
  );
  let t19;
  let t20;
  let label1;
  let input1;
  let t21;
  let t22_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Text") + ""
  );
  let t22;
  let t23;
  let button;
  let t24_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.ButtonMigration.Text") + ""
  );
  let t24;
  let mounted;
  let dispose;
  return {
    c() {
      section = element("section");
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.CharacterBiography.sectionTitle")}`;
      t1 = space();
      ul = element("ul");
      li0 = element("li");
      li0.textContent = `${/*localize*/
      ctx[3]("DND5E.Age")}`;
      t3 = space();
      li1 = element("li");
      li1.textContent = `${/*localize*/
      ctx[3]("DND5E.Eyes")}`;
      t5 = space();
      li2 = element("li");
      li2.textContent = `${/*localize*/
      ctx[3]("DND5E.Gender")}`;
      t7 = space();
      li3 = element("li");
      li3.textContent = `${/*localize*/
      ctx[3]("DND5E.Hair")}`;
      t9 = space();
      li4 = element("li");
      li4.textContent = `${/*localize*/
      ctx[3]("DND5E.Height")}`;
      t11 = space();
      li5 = element("li");
      li5.textContent = `${/*localize*/
      ctx[3]("DND5E.Skin")}`;
      t13 = space();
      li6 = element("li");
      li6.textContent = `${/*localize*/
      ctx[3]("DND5E.Weight")}`;
      t15 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.OptionsHeader")}`;
      t17 = space();
      div = element("div");
      label0 = element("label");
      input0 = element("input");
      t18 = space();
      t19 = text(t19_value);
      t20 = space();
      label1 = element("label");
      input1 = element("input");
      t21 = space();
      t22 = text(t22_value);
      t23 = space();
      button = element("button");
      t24 = text(t24_value);
      attr(input0, "type", "checkbox");
      input0.disabled = /*migrating*/
      ctx[0];
      attr(label0, "class", "green-checkbox");
      attr(
        label0,
        "data-tooltip",
        /*localize*/
        ctx[3]("TIDY5E.Settings.Migrations.OptionOverwrite.Tooltip")
      );
      attr(input1, "type", "checkbox");
      input1.disabled = /*migrating*/
      ctx[0];
      attr(label1, "class", "green-checkbox");
      attr(
        label1,
        "data-tooltip",
        /*localize*/
        ctx[3]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Tooltip")
      );
      attr(div, "class", "options grid-auto-columns svelte-f3txbi");
      attr(button, "type", "button");
      button.disabled = /*migrating*/
      ctx[0];
      attr(button, "class", "svelte-f3txbi");
      attr(section, "class", "svelte-f3txbi");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h2);
      append(section, t1);
      append(section, ul);
      append(ul, li0);
      append(ul, t3);
      append(ul, li1);
      append(ul, t5);
      append(ul, li2);
      append(ul, t7);
      append(ul, li3);
      append(ul, t9);
      append(ul, li4);
      append(ul, t11);
      append(ul, li5);
      append(ul, t13);
      append(ul, li6);
      append(section, t15);
      append(section, h3);
      append(section, t17);
      append(section, div);
      append(div, label0);
      append(label0, input0);
      input0.checked = /*overwrite*/
      ctx[1];
      append(label0, t18);
      append(label0, t19);
      append(div, t20);
      append(div, label1);
      append(label1, input1);
      input1.checked = /*deleteFlags*/
      ctx[2];
      append(label1, t21);
      append(label1, t22);
      append(section, t23);
      append(section, button);
      append(button, t24);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[5]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[6]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*migrating*/
      1) {
        input0.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*overwrite*/
      2) {
        input0.checked = /*overwrite*/
        ctx2[1];
      }
      if (dirty & /*migrating*/
      1) {
        input1.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*deleteFlags*/
      4) {
        input1.checked = /*deleteFlags*/
        ctx2[2];
      }
      if (dirty & /*migrating*/
      1) {
        button.disabled = /*migrating*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1N($$self, $$props, $$invalidate) {
  let migrating = false;
  let overwrite = false;
  let deleteFlags = false;
  const localize = FoundryAdapter.localize;
  async function migrate() {
    try {
      const actorsToMigrate = Array.from(game.actors).filter((a2) => a2.type === CONSTANTS.SHEET_TYPE_CHARACTER);
      new MigrationSelectionApplication(
        {
          onConfirm: async (selected) => {
            $$invalidate(0, migrating = true);
            ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationBeginningMessage"));
            migrateActors(selected);
          },
          columns: [
            {
              cellWidth: "primary",
              field: {
                type: "simple",
                propPath: "name",
                onClick: (target) => target.sheet.render(true)
              },
              name: localize("TIDY5E.Settings.Migrations.Selection.ToMigrate")
            }
          ],
          documents: actorsToMigrate,
          title: FoundryAdapter.localize("TIDY5E.Settings.Migrations.CharacterBiography.selectionDialogTitle")
        },
        () => {
          $$invalidate(0, migrating = false);
        }
      ).render(true);
    } catch (e2) {
      error("An error occurred while preparing a bulk migration", false, e2);
    }
  }
  async function migrateActors(actors) {
    try {
      for (let actorToMigrate of actors) {
        await migrateActor(actorToMigrate);
      }
    } finally {
      $$invalidate(0, migrating = false);
      ui.notifications.info(FoundryAdapter.localize("TIDY5E.Settings.Migrations.migrationCompleteMessage"));
      resetOptions();
    }
  }
  function resetOptions() {
    $$invalidate(1, overwrite = false);
    $$invalidate(2, deleteFlags = false);
  }
  async function migrateActor(actor) {
    try {
      debug(`Migrating actor ${actor?.name}...`);
      migrateBiographicalFlagsToSystemData({
        document: actor,
        clearBiographicalFlagData: deleteFlags,
        overwrite
      });
      debug(`Actor ${actor?.name} migration successful!`);
    } catch (e2) {
      error(`An error occurred while migrating biographical data for ${actor?.name}`, false, e2);
      ui.notifications.error(FoundryAdapter.localize("TIDY5E.Settings.Migrations.migrationErrorMessage"), { permanent: true });
    }
  }
  function input0_change_handler() {
    overwrite = this.checked;
    $$invalidate(1, overwrite);
  }
  function input1_change_handler() {
    deleteFlags = this.checked;
    $$invalidate(2, deleteFlags);
  }
  const click_handler = (ev) => migrate();
  return [
    migrating,
    overwrite,
    deleteFlags,
    localize,
    migrate,
    input0_change_handler,
    input1_change_handler,
    click_handler
  ];
}
class CharacterBiographyMigration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1N, create_fragment$1N, safe_not_equal, {});
  }
}
async function migrateOgFlagsToV1() {
  const flagDifferences = [
    {
      v1: "skillsExpanded",
      og: "npcSkillsExpanded"
    }
  ];
  for (let actor of game.actors) {
    try {
      let update2 = {};
      for (let diff of flagDifferences) {
        const flagValue = actor.flags[CONSTANTS.MODULE_ID]?.[diff.og];
        if (flagValue !== null) {
          update2[diff.v1] = flagValue;
        }
      }
      if (Object.keys(update2).length) {
        await actor.update({
          flags: {
            [CONSTANTS.MODULE_ID]: update2
          }
        });
      }
    } catch (e2) {
      const message = `${actor.name}: Transfer failed. See devtools console error for more details.`;
      ui.notifications.error(
        FoundryAdapter.localize(
          "TIDY5E.Settings.Migrations.migrationErrorMessage"
        ),
        { permanent: true }
      );
      error(message, false, e2);
    }
  }
  ui.notifications.info(
    FoundryAdapter.localize(
      "TIDY5E.Settings.Migrations.migrationCompleteMessage"
    )
  );
}
const settingsMap = [
  {
    v1Key: "showTraitLabels",
    ogKey: "traitLabelsEnabled"
  },
  {
    v1Key: "showPlayerName",
    ogKey: "playerNameEnabled"
  },
  {
    v1Key: "showExpandedLimitedView",
    ogKey: "expandedSheetEnabled"
  },
  {
    v1Key: "useCircularPortraitStyle",
    ogKey: "portraitStyle"
  },
  {
    v1Key: "useTotalSheetLock",
    ogKey: "editTotalLockEnabled"
  },
  {
    v1Key: "permanentlyUnlockCharacterSheetForGm",
    ogKey: "editGmAlwaysEnabled"
  },
  {
    v1Key: "limitEffectsManagementToGm",
    ogKey: "editEffectsGmOnlyEnabled"
  },
  {
    v1Key: "hideDeathSavesFromPlayers",
    ogKey: "hiddenDeathSavesEnabled"
  },
  {
    v1Key: "useExhaustion",
    ogKey: "exhaustionDisabled",
    convert: (setting) => !setting
  },
  {
    v1Key: "useCharacterInspiration",
    ogKey: "inspirationDisabled",
    convert: (setting) => !setting
  },
  {
    v1Key: "showNpcRestInChat",
    ogKey: "restingForNpcsChatDisabled",
    convert: (setting) => !setting
  },
  {
    v1Key: "showNpcActorLinkMarker",
    ogKey: "linkMarkerNpc"
  },
  {
    v1Key: "showActiveEffectsMarker",
    ogKey: "activeEffectsMarker"
  },
  {
    v1Key: "permanentlyUnlockNpcSheetForGm",
    ogKey: "enablePermanentUnlockOnNPCIfYouAreGM"
  },
  {
    v1Key: "permanentlyUnlockVehicleSheetForGm",
    ogKey: "enablePermanentUnlockOnVehicleIfYouAreGM"
  },
  {
    v1Key: "allowCantripsToBePrepared",
    ogKey: "allowCantripToBePreparedOnContext"
  }
];
async function migrateOgSettingsToV1() {
  const tidyGmSettings = game.settings.storage.get("world").filter((s2) => s2.key.startsWith(CONSTANTS.MODULE_ID));
  for (let setting of tidyGmSettings) {
    try {
      const originalKey = setting.key.replace(`${CONSTANTS.MODULE_ID}.`, "");
      const mappedSetting = settingsMap.find((s2) => s2.ogKey === originalKey);
      if (!mappedSetting) {
        continue;
      }
      const value = mappedSetting.convert ? mappedSetting.convert(setting.value) : setting.value;
      if (game.settings.settings.has(
        `${CONSTANTS.MODULE_ID}.${mappedSetting.v1Key}`
      )) {
        await game.settings.set(
          CONSTANTS.MODULE_ID,
          mappedSetting.v1Key,
          value
        );
      }
    } catch (e2) {
      const message = `An error occurred while remapping setting "${setting.key}"`;
      ui.notifications.error(
        FoundryAdapter.localize(
          "TIDY5E.Settings.Migrations.migrationErrorMessage"
        ),
        { permanent: true }
      );
      error(message, false, e2);
    }
  }
  ui.notifications.info(
    FoundryAdapter.localize(
      "TIDY5E.Settings.Migrations.migrationCompleteMessage"
    )
  );
}
function create_fragment$1M(ctx) {
  let h20;
  let t1;
  let div1;
  let div0;
  let p0;
  let raw0_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.Migrations.v1.mainExplanation1") + ""
  );
  let t2;
  let p1;
  let raw1_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.Migrations.v1.mainExplanation2", { boldStart: "<b>", boldEnd: "</b>" }) + ""
  );
  let t3;
  let h21;
  let i0;
  let html_tag;
  let raw2_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.Migrations.v1.originalHeader") + ""
  );
  let t4;
  let p2;
  let raw3_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.Migrations.v1.originalExplanation") + ""
  );
  let t5;
  let div2;
  let button0;
  let i1;
  let t6;
  let html_tag_1;
  let raw4_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.Migrations.migrateDocumentFlagsButtonLabel") + ""
  );
  let t7;
  let button1;
  let i2;
  let t8;
  let html_tag_2;
  let raw5_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.Migrations.migrateGmSettingsButtonLabel") + ""
  );
  let mounted;
  let dispose;
  return {
    c() {
      h20 = element("h2");
      h20.textContent = `${/*localize*/
      ctx[0]("TIDY5E.Settings.Migrations.v1.sectionTitle")}`;
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      p0 = element("p");
      t2 = space();
      p1 = element("p");
      t3 = space();
      h21 = element("h2");
      i0 = element("i");
      html_tag = new HtmlTag(false);
      t4 = space();
      p2 = element("p");
      t5 = space();
      div2 = element("div");
      button0 = element("button");
      i1 = element("i");
      t6 = space();
      html_tag_1 = new HtmlTag(false);
      t7 = space();
      button1 = element("button");
      i2 = element("i");
      t8 = space();
      html_tag_2 = new HtmlTag(false);
      attr(div1, "class", "flex-row align-items-center callout-banner svelte-ppo5ka");
      attr(i0, "class", "fas fa-scroll");
      html_tag.a = null;
      attr(h21, "class", "flex-row align-items-center");
      attr(i1, "class", "fas fa-flag");
      html_tag_1.a = null;
      attr(button0, "type", "button");
      attr(i2, "class", "fas fa-cog");
      html_tag_2.a = null;
      attr(button1, "type", "button");
      attr(div2, "class", "flex-row extra-small-gap");
    },
    m(target, anchor) {
      insert(target, h20, anchor);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, p0);
      p0.innerHTML = raw0_value;
      append(div0, t2);
      append(div0, p1);
      p1.innerHTML = raw1_value;
      insert(target, t3, anchor);
      insert(target, h21, anchor);
      append(h21, i0);
      html_tag.m(raw2_value, h21);
      insert(target, t4, anchor);
      insert(target, p2, anchor);
      p2.innerHTML = raw3_value;
      insert(target, t5, anchor);
      insert(target, div2, anchor);
      append(div2, button0);
      append(button0, i1);
      append(button0, t6);
      html_tag_1.m(raw4_value, button0);
      append(div2, t7);
      append(div2, button1);
      append(button1, i2);
      append(button1, t8);
      html_tag_2.m(raw5_value, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[2]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h20);
        detach(t1);
        detach(div1);
        detach(t3);
        detach(h21);
        detach(t4);
        detach(p2);
        detach(t5);
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1M($$self) {
  const localize = FoundryAdapter.localize;
  const confirm = getContext(CONSTANTS.SVELTE_CONTEXT.CONFIRM);
  const click_handler = () => confirm(migrateOgFlagsToV1);
  const click_handler_1 = () => confirm(migrateOgSettingsToV1);
  return [localize, confirm, click_handler, click_handler_1];
}
class V1OnboardingMigration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1M, create_fragment$1M, safe_not_equal, {});
  }
}
const ccssFlagPropPath = "flags.custom-character-sheet-sections.sectionName";
async function migrateCcssToTidyForItem({
  item,
  overwrite,
  clearCcssFlagData
}) {
  try {
    const sectionName = getCcssSectionName(item);
    if (isNil(sectionName, "")) {
      return;
    }
    const tidySection = TidyFlags.section.get(item);
    const shouldUpdateTidy = isNil(tidySection, "") || overwrite;
    if (shouldUpdateTidy) {
      TidyFlags.section.set(item, sectionName);
    }
    if (clearCcssFlagData) {
      item.update({
        "flags.custom-character-sheet-sections.-=sectionName": null
      });
    }
  } catch (e2) {
    error("An error occurred while migrating CCSS data from item.", false, e2);
    debug("CCSS Item Migration troubleshooting info", {
      item: item?.toObject?.(),
      overwrite,
      clearCcssFlagData
    });
  }
}
function getCcssSectionName(item) {
  return foundry.utils.getProperty(item, ccssFlagPropPath)?.trim();
}
function create_fragment$1L(ctx) {
  let section;
  let h2;
  let t1;
  let div0;
  let p0;
  let t3;
  let p1;
  let t5;
  let h3;
  let t7;
  let div1;
  let label0;
  let input0;
  let t8;
  let t9_value = (
    /*localize*/
    ctx[5]("TIDY5E.Settings.Migrations.CcssToTidy.overwrite") + ""
  );
  let t9;
  let t10;
  let label1;
  let input1;
  let t11;
  let t12_value = (
    /*localize*/
    ctx[5]("TIDY5E.Settings.Migrations.CcssToTidy.deleteFlags") + ""
  );
  let t12;
  let t13;
  let footer;
  let button0;
  let t14_value = (
    /*localize*/
    ctx[5]("TIDY5E.Settings.Migrations.MigrateCompendia.Title") + ""
  );
  let t14;
  let t15;
  let button1;
  let t16_value = (
    /*localize*/
    ctx[5]("TIDY5E.Settings.Migrations.ButtonMigration.Text") + ""
  );
  let t16;
  let mounted;
  let dispose;
  return {
    c() {
      section = element("section");
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[5]("TIDY5E.Settings.Migrations.CcssToTidy.sectionTitle")}`;
      t1 = space();
      div0 = element("div");
      p0 = element("p");
      p0.textContent = `${/*localize*/
      ctx[5]("TIDY5E.Settings.Migrations.CcssToTidy.explanation1")}`;
      t3 = space();
      p1 = element("p");
      p1.textContent = `${/*localize*/
      ctx[5]("TIDY5E.Settings.Migrations.UnlinkedExplanation")}`;
      t5 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[5]("TIDY5E.Settings.Migrations.OptionsHeader")}`;
      t7 = space();
      div1 = element("div");
      label0 = element("label");
      input0 = element("input");
      t8 = space();
      t9 = text(t9_value);
      t10 = space();
      label1 = element("label");
      input1 = element("input");
      t11 = space();
      t12 = text(t12_value);
      t13 = space();
      footer = element("footer");
      button0 = element("button");
      t14 = text(t14_value);
      t15 = space();
      button1 = element("button");
      t16 = text(t16_value);
      attr(div0, "class", "callout-banner svelte-11aceoq");
      attr(input0, "type", "checkbox");
      input0.disabled = /*migrating*/
      ctx[0];
      attr(label0, "class", "green-checkbox");
      attr(
        label0,
        "data-tooltip",
        /*localize*/
        ctx[5]("TIDY5E.Settings.Migrations.CcssToTidy.overwriteTooltip")
      );
      attr(input1, "type", "checkbox");
      input1.disabled = /*migrating*/
      ctx[0];
      attr(label1, "class", "green-checkbox");
      attr(
        label1,
        "data-tooltip",
        /*localize*/
        ctx[5]("TIDY5E.Settings.Migrations.CcssToTidy.deleteFlagsTooltip")
      );
      attr(div1, "class", "options grid-auto-columns svelte-11aceoq");
      attr(button0, "type", "button");
      button0.disabled = /*migrating*/
      ctx[0];
      attr(button1, "type", "button");
      button1.disabled = /*migrating*/
      ctx[0];
      attr(footer, "class", "flex-row extra-small-gap svelte-11aceoq");
      attr(section, "class", "svelte-11aceoq");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h2);
      append(section, t1);
      append(section, div0);
      append(div0, p0);
      append(section, t3);
      append(section, p1);
      append(section, t5);
      append(section, h3);
      append(section, t7);
      append(section, div1);
      append(div1, label0);
      append(label0, input0);
      input0.checked = /*overwrite*/
      ctx[1];
      append(label0, t8);
      append(label0, t9);
      append(div1, t10);
      append(div1, label1);
      append(label1, input1);
      input1.checked = /*deleteFlags*/
      ctx[2];
      append(label1, t11);
      append(label1, t12);
      append(section, t13);
      append(section, footer);
      append(footer, button0);
      append(button0, t14);
      append(footer, t15);
      append(footer, button1);
      append(button1, t16);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[7]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*migrating*/
      1) {
        input0.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*overwrite*/
      2) {
        input0.checked = /*overwrite*/
        ctx2[1];
      }
      if (dirty & /*migrating*/
      1) {
        input1.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*deleteFlags*/
      4) {
        input1.checked = /*deleteFlags*/
        ctx2[2];
      }
      if (dirty & /*migrating*/
      1) {
        button0.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*migrating*/
      1) {
        button1.disabled = /*migrating*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1L($$self, $$props, $$invalidate) {
  let migrating = false;
  let overwrite = false;
  let deleteFlags = false;
  async function migrate() {
    try {
      const actorItemsToMigrate = Array.from(game.actors).filter((a2) => a2.isOwner).map((a2) => ({ actor: a2, unlinked: false })).flatMap((value) => Array.from(value.actor.items).map((item) => ({ item, unlinked: value.unlinked })));
      const tokenActorItemsToMigrate = Array.from(canvas?.scene?.tokens ?? []).map((t2) => ({ actor: t2.actor, unlinked: true })).filter((a2) => a2.actor && !a2.actor.prototypeToken?.actorLink && a2.actor.isOwner).flatMap((value) => Array.from(value.actor.items).map((item) => ({ item, unlinked: value.unlinked })));
      const worldItemsToMigrate = Array.from(game.items).map((item) => ({ item, unlinked: true }));
      const itemsToMigrate = [
        ...tokenActorItemsToMigrate,
        ...actorItemsToMigrate,
        ...worldItemsToMigrate
      ].filter((value) => !isNil(getCcssSectionName(value.item), ""));
      new MigrationSelectionApplication(
        {
          onConfirm: async (selected) => {
            $$invalidate(0, migrating = true);
            ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationBeginningMessage"));
            for (let choice of selected) {
              await migrateCcssToTidyForItem({
                item: choice.item,
                overwrite,
                clearCcssFlagData: deleteFlags
              });
            }
            $$invalidate(0, migrating = false);
            ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationCompleteMessage"));
            resetOptions();
          },
          columns: [
            {
              cellWidth: "primary",
              field: {
                type: "simple",
                propPath: "item.name",
                onClick: (target) => target.item.sheet.render(true)
              },
              name: localize("TIDY5E.Settings.Migrations.Selection.ToMigrate")
            },
            {
              cellWidth: "8rem",
              field: {
                type: "simple",
                propPath: `item.${ccssFlagPropPath}`
              },
              name: localize("TIDY5E.Settings.Migrations.CcssToTidy.ccss")
            },
            {
              cellWidth: "8rem",
              field: {
                type: "simple",
                propPath: `item.${TidyFlags.section.prop}`
              },
              name: localize("TIDY5E.Settings.Migrations.CcssToTidy.section")
            },
            {
              cellWidth: "10rem",
              field: {
                type: "simple",
                propPath: `item.parent.name`,
                onClick: (target) => target.item.parent?.sheet?.render(true)
              },
              name: localize("TIDY5E.Settings.Migrations.Parent")
            },
            {
              cellWidth: "10rem",
              name: "",
              field: {
                type: "contextual",
                getText: ({ unlinked }) => unlinked ? FoundryAdapter.localize("TIDY5E.TokenUnlinked") : FoundryAdapter.localize("DOCUMENT.Actor")
              }
            }
          ],
          documents: itemsToMigrate,
          title: FoundryAdapter.localize("TIDY5E.Settings.Migrations.CcssToTidy.selectionDialogTitle")
        },
        () => {
          $$invalidate(0, migrating = false);
        },
        { width: 960 }
      ).render(true);
    } catch (e2) {
      error("An error occurred while preparing a bulk migration", false, e2);
    }
  }
  async function migrateCompendia() {
    const compendiaForMigrating = Array.from(game.packs.values()).filter((c2) => !c2.locked && c2.documentName === "Item").map((c2) => ({
      label: c2.metadata.label,
      type: c2.metadata.type,
      id: c2.metadata.id,
      size: c2.index.size
    }));
    new MigrationSelectionApplication({
      onConfirm: async (selected) => {
        ui.notifications.info(localize(`TIDY5E.Settings.Migrations.migrationBeginningMessage`));
        for (const compendium of selected) {
          debug(`Migrating compendium "${compendium.label}"...`);
          try {
            const items = await game.packs.get(compendium.id).getDocuments();
            for (const item of items) {
              await migrateCcssToTidyForItem({
                item,
                overwrite,
                clearCcssFlagData: deleteFlags
              });
            }
            debug(`Compendium "${compendium.label}" migration successful.`);
          } catch (e2) {
            error(localize("TIDY5E.Settings.Migrations.migrationErrorMessage"), true);
            error(`Error while migrating compendium "${compendium.label}"`, false, e2);
          }
        }
        ui.notifications.info(localize(`TIDY5E.Settings.Migrations.migrationCompleteMessage`));
      },
      columns: [
        {
          cellWidth: "primary",
          field: {
            type: "simple",
            propPath: "label",
            onClick: (target) => game.packs.get(target.id).render(true)
          },
          name: localize("TIDY5E.Settings.Migrations.MigrateCompendia.CompendiumLabel")
        },
        {
          cellWidth: "5rem",
          field: {
            type: "contextual",
            getText: (c2) => localize(`DOCUMENT.${c2.type}`)
          },
          name: localize("Type")
        },
        {
          cellWidth: "10rem",
          field: { type: "simple", propPath: "size" },
          name: localize("TIDY5E.Settings.Migrations.MigrateCompendia.TotalEntriesLabel")
        }
      ],
      documents: compendiaForMigrating,
      title: localize("TIDY5E.Settings.Migrations.MigrateCompendia.SelectionDialogTitle")
    }).render(true);
  }
  function resetOptions() {
    $$invalidate(1, overwrite = false);
    $$invalidate(2, deleteFlags = false);
  }
  const localize = FoundryAdapter.localize;
  function input0_change_handler() {
    overwrite = this.checked;
    $$invalidate(1, overwrite);
  }
  function input1_change_handler() {
    deleteFlags = this.checked;
    $$invalidate(2, deleteFlags);
  }
  const click_handler = (ev) => migrateCompendia();
  const click_handler_1 = (ev) => migrate();
  return [
    migrating,
    overwrite,
    deleteFlags,
    migrate,
    migrateCompendia,
    localize,
    input0_change_handler,
    input1_change_handler,
    click_handler,
    click_handler_1
  ];
}
class CcssToTidyMigration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1L, create_fragment$1L, safe_not_equal, {});
  }
}
const tidyFlagFavorite = "favorite";
async function migrateFavoritesToSystem({
  pc,
  clearFavoriteFlagData
}) {
  if (!pc) {
    return;
  }
  try {
    const tidyFavorites = Array.from(pc.items).filter(
      (i2) => !!i2.flags[CONSTANTS.MODULE_ID]?.favorite
    );
    for (const favorite of tidyFavorites) {
      await pc.system.addFavorite({
        id: favorite.getRelativeUUID(pc),
        type: "item"
      });
      if (clearFavoriteFlagData) {
        await TidyFlags.unsetFlag(favorite, tidyFlagFavorite);
      }
    }
  } catch (e2) {
    error("An error occurred while migrating an actor's favorites", false, {
      error: e2,
      actor: pc
    });
    error(
      FoundryAdapter.localize(
        "TIDY5E.Settings.Migrations.migrationErrorMessage"
      ),
      true
    );
  }
}
function create_fragment$1K(ctx) {
  let section;
  let h2;
  let t1;
  let h3;
  let t3;
  let div;
  let label;
  let input;
  let t4;
  let t5_value = (
    /*localize*/
    ctx[2]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Text") + ""
  );
  let t5;
  let t6;
  let footer;
  let button;
  let t7_value = (
    /*localize*/
    ctx[2]("TIDY5E.Settings.Migrations.ButtonMigration.Text") + ""
  );
  let t7;
  let mounted;
  let dispose;
  return {
    c() {
      section = element("section");
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[2]("TIDY5E.Settings.Migrations.FavoritesToSystem.sectionTitle")}`;
      t1 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[2]("TIDY5E.Settings.Migrations.OptionsHeader")}`;
      t3 = space();
      div = element("div");
      label = element("label");
      input = element("input");
      t4 = space();
      t5 = text(t5_value);
      t6 = space();
      footer = element("footer");
      button = element("button");
      t7 = text(t7_value);
      attr(input, "type", "checkbox");
      input.disabled = /*migrating*/
      ctx[0];
      attr(label, "class", "green-checkbox");
      attr(
        label,
        "data-tooltip",
        /*localize*/
        ctx[2]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Tooltip")
      );
      attr(div, "class", "options grid-auto-columns svelte-1fnhfkf");
      attr(button, "type", "button");
      button.disabled = /*migrating*/
      ctx[0];
      attr(footer, "class", "flex-row extra-small-gap svelte-1fnhfkf");
      attr(section, "class", "svelte-1fnhfkf");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h2);
      append(section, t1);
      append(section, h3);
      append(section, t3);
      append(section, div);
      append(div, label);
      append(label, input);
      input.checked = /*deleteFlags*/
      ctx[1];
      append(label, t4);
      append(label, t5);
      append(section, t6);
      append(section, footer);
      append(footer, button);
      append(button, t7);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[4]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*migrating*/
      1) {
        input.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*deleteFlags*/
      2) {
        input.checked = /*deleteFlags*/
        ctx2[1];
      }
      if (dirty & /*migrating*/
      1) {
        button.disabled = /*migrating*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1K($$self, $$props, $$invalidate) {
  let migrating = false;
  let deleteFlags = false;
  const localize = FoundryAdapter.localize;
  async function migrate() {
    const actorsToMigrate = Array.from(game.actors).filter((a2) => a2.isOwner && a2.type === CONSTANTS.SHEET_TYPE_CHARACTER);
    new MigrationSelectionApplication({
      onConfirm: async (selected) => {
        $$invalidate(0, migrating = true);
        ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationBeginningMessage"));
        for (let choice of selected) {
          await migrateFavoritesToSystem({
            pc: choice,
            clearFavoriteFlagData: deleteFlags
          });
        }
        ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationCompleteMessage"));
        resetOptions();
        $$invalidate(0, migrating = false);
      },
      columns: [
        {
          cellWidth: "primary",
          field: {
            type: "simple",
            propPath: "name",
            onClick: (target) => target.sheet.render(true)
          },
          name: localize("TIDY5E.Settings.Migrations.Selection.ToMigrate")
        }
      ],
      documents: actorsToMigrate,
      title: FoundryAdapter.localize("TIDY5E.Settings.Migrations.FavoritesToSystem.selectionDialogTitle")
    }).render(true);
    function resetOptions() {
      $$invalidate(1, deleteFlags = false);
    }
  }
  function input_change_handler() {
    deleteFlags = this.checked;
    $$invalidate(1, deleteFlags);
  }
  const click_handler = (ev) => migrate();
  return [migrating, deleteFlags, localize, migrate, input_change_handler, click_handler];
}
class FavoritesToSystemMigration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1K, create_fragment$1K, safe_not_equal, {});
  }
}
const ApiConstants = {
  TAB_ID_CHARACTER_ATTRIBUTES: CONSTANTS.TAB_CHARACTER_ATTRIBUTES,
  TAB_ID_CHARACTER_INVENTORY: CONSTANTS.TAB_CHARACTER_INVENTORY,
  TAB_ID_CHARACTER_SPELLBOOK: CONSTANTS.TAB_CHARACTER_SPELLBOOK,
  TAB_ID_CHARACTER_FEATURES: CONSTANTS.TAB_CHARACTER_FEATURES,
  TAB_ID_CHARACTER_EFFECTS: CONSTANTS.TAB_CHARACTER_EFFECTS,
  TAB_ID_CHARACTER_BIOGRAPHY: CONSTANTS.TAB_CHARACTER_BIOGRAPHY,
  TAB_ID_CHARACTER_JOURNAL: CONSTANTS.TAB_CHARACTER_JOURNAL,
  TAB_ID_NPC_ABILITIES: CONSTANTS.TAB_NPC_ABILITIES,
  TAB_ID_NPC_SPELLBOOK: CONSTANTS.TAB_NPC_SPELLBOOK,
  TAB_ID_NPC_EFFECTS: CONSTANTS.TAB_NPC_EFFECTS,
  TAB_ID_NPC_BIOGRAPHY: CONSTANTS.TAB_NPC_BIOGRAPHY,
  TAB_ID_NPC_JOURNAL: CONSTANTS.TAB_NPC_JOURNAL,
  TAB_ID_VEHICLE_ATTRIBUTES: CONSTANTS.TAB_VEHICLE_ATTRIBUTES,
  TAB_ID_VEHICLE_CARGO_AND_CREW: CONSTANTS.TAB_VEHICLE_CARGO_AND_CREW,
  TAB_ID_VEHICLE_EFFECTS: CONSTANTS.TAB_VEHICLE_EFFECTS,
  TAB_ID_VEHICLE_DESCRIPTION: CONSTANTS.TAB_VEHICLE_DESCRIPTION,
  TAB_ID_ACTOR_ACTIONS: CONSTANTS.TAB_ACTOR_ACTIONS,
  /** The attribute which indicates a particular part of a sheet. */
  SHEET_PART_ATTRIBUTE: CONSTANTS.SHEET_PART_ATTRIBUTE,
  /**
   * Values used in conjunction with the attribute `api.constants.SHEET_PART_ATTRIBUTE` to identify a part of a Tidy 5e sheet.
   *
   * @example an element which is tagged with a sheet part value
   * ```html
   * <div class="resources" data-tidy-sheet-part="resources-container">...</div>
   * ```
   *
   * @example targeting a sheet part for content injection during Tidy render
   * ```js
   * // Every time Tidy renders, whether a full render or a partial
   * Hooks.on("tidy5e-sheet.renderActorSheet", (sheet, element, data) => {
   *   const api = game.modules.get('tidy5e-sheet').api;
   *   const selector = api.getSheetPartSelector(
   *     api.constants.SHEET_PARTS.RESOURCES_CONTAINER
   *   );
   *   // get the resources container of the target actor sheet
   *   element
   *     .querySelector(selector)
   *     // inject some HTML
   *     ?.insertAdjacentHTML(
   *       // put it as the first element inside the resources container; see https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML#afterbegin
   *       "afterbegin",
   *       // here's my content
   *       // pro tip: `data-tidy-render-scheme="handlebars"` causes this content to re-render on every Tidy render, full or partial
   *       `<div style="display: contents;" data-tidy-render-scheme="handlebars">
   *           <h2 type="button" style="width: 100%;">Resources for ${data.actor.name}</h2>
   *         </div>`
   *     );
   * });
   * ```
   *
   * @remarks
   * Tidy 5e Sheets are tagged with `data-tidy-sheet-part` attributes
   * so that most parts of the sheet can be generally identified.
   * This module uses specific attributes rather than classes because of
   * HTML classes' multiple purposes, including use for CSS styling.
   * Using sheet part attributes allows for identifying the same general thing
   * even when considering a potentially alternate Tidy sheet layout.
   */
  SHEET_PARTS: CONSTANTS.SHEET_PARTS
};
class ActionListApi {
  /**
   * Remap how activation types are treated when the Action List organizes items into sections.
   * @param mappings an object with `key`s and `value`s representing a mapping from source activation type to intended target activation type.
   * @example Treating Midi-QoL reaction sub-types like a reaction
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.config.actionList.mapActivationTypesToSections({
   *     reactionpreattack: 'reaction',
   *     reactiondamage: 'reaction',
   *     reactionmanual: 'reaction',
   *   });
   * });
   * ```
   * @remarks
   * In terms of UI, the `key` and `value` fields are the `value` attribute on the Activation Type dropdown, or the database value.
   * 
   * Multiple calls to this API function merge the latest results in, resulting in last-come, last-server.
   * If multiple modules remap the same activation type, the last caller's remapping will be the winner.
   */
  mapActivationTypesToSections(mappings2) {
    ActionListRuntime.addActivationTypeMappings(mappings2);
  }
}
class ActorItemApi {
  /**
   * Registers actor item section commands which Tidy 5e can render at select locations on the sheet.
   * @param commands actor item section commands for Tidy 5e to render
   *
   * @example Registering a command that sorts items
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.config.actorItem.registerSectionFooterCommands([
   *     {
   *       enabled: (params) =>
   *         params.section.items?.length > 1 || params.section.spells?.length > 1,
   *       iconClass: 'fa-solid fa-arrow-up-a-z',
   *       tooltip: 'Sort by Name Ascending',
   *       execute: async (params) => {
   *         const actor = params.actor;
   *         const itemsToSort = params.section.items ?? params.section.spells;
   *         await actor.updateEmbeddedDocuments(
   *           'Item',
   *           [...itemsToSort]
   *             .sort((a, b) => {
   *               return a.name.localeCompare(b.name);
   *             })
   *             .map((item, idx) => {
   *               return { _id: item.id, sort: idx };
   *             })
   *         );
   *       },
   *     },
   *   ]);
   * });
   * ```
   */
  registerSectionFooterCommands(commands) {
    ActorItemRuntime.registerActorItemSectionCommands(commands);
  }
}
class ActorPortraitRuntime {
  static _portraitMenuCommands = [
    {
      label: "TIDY5E.ShowPortraitArt",
      execute: (params) => {
        FoundryAdapter.renderImagePopout(params.actor.img, {
          title: FoundryAdapter.localize("TIDY5E.PortraitTitle", {
            subject: params.actor.name
          }),
          shareable: true,
          uuid: params.actor.uuid
        });
      },
      iconClass: "fa-solid fa-image fa-fw"
    },
    {
      label: "TIDY5E.ShowTokenArt",
      execute: async (params) => {
        let imageSrc = params.actor.token?.texture?.src;
        if (!imageSrc) {
          let images = await params.actor.getTokenImages();
          imageSrc = images.length > 1 ? (
            // Grab a random wildcard token upon request... for chaos.
            images[Math.floor(Math.random() * images.length)]
          ) : images[0];
        }
        FoundryAdapter.renderImagePopout(imageSrc, {
          title: FoundryAdapter.localize("TIDY5E.PortraitTitle", {
            subject: params.actor.name
          }),
          shareable: true,
          uuid: params.actor.uuid
        });
      },
      iconClass: "fa-regular fa-circle-user fa-fw"
    }
  ];
  static registerMenuCommands(commands) {
    ActorPortraitRuntime._portraitMenuCommands.push(...commands);
  }
  static getEnabledPortraitMenuCommands(actor) {
    return ActorPortraitRuntime._portraitMenuCommands.filter((c2) => {
      try {
        return c2.enabled?.({ actor }) ?? true;
      } catch (e2) {
        error(
          "Failed to check if actor portrait menu command is enabled",
          false,
          { error: e2, actor }
        );
        return false;
      }
    });
  }
}
class ActorPortraitApi {
  /**
   * Register actor portrait menu commands which Tidy 5e can render on the sheet when appropriate.
   * @param commands actor portrait menu commands for Tidy 5e to render
   *
   * @example Registering a command
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.config.actorPortrait.registerMenuCommands([
   *     {
   *       label: "Test",
   *       iconClass: "fa-solid fa-flask",
   *       tooltip: "Click for test result",
   *       enabled: (params) => params.actor.type !== "vehicle",
   *       execute: (params) => {
   *         console.log(params);
   *         ui.notifications.info(
   *           "Hello, Test Portrait Menu Command for " + params.actor.name
   *         );
   *       },
   *     },
   *   ]);
   * });
   * ```
   */
  registerMenuCommands(commands) {
    ActorPortraitRuntime.registerMenuCommands([...commands]);
  }
}
class CustomActorTraitsRuntime {
  static _traits = [];
  static registerCustomActorTraits(traits) {
    const registeredTraits = traits.map((t2) => ({
      title: t2.title,
      iconClass: t2.iconClass,
      alwaysShow: t2.alwaysShow,
      openConfiguration: t2.openConfiguration,
      openConfigurationTooltip: t2.openConfigurationTooltip,
      enabled: t2.enabled
    }));
    CustomActorTraitsRuntime._traits.push(...registeredTraits);
  }
  static getEnabledTraits(context) {
    return this._traits.filter((t2) => {
      try {
        return t2.enabled?.({ context }) ?? true;
      } catch (e2) {
        error(
          "An error occurred while determining if a custom actor trait is enabled.",
          false,
          e2
        );
        debug("Custom actor trait enabled error details", {
          context,
          trait: t2
        });
        return false;
      }
    });
  }
}
class ActorTraitsApi {
  /**
   * Registers multiple custom traits to the actor traits section of the actor sheet.
   * @param traits traits to register
   *
   * @example Registering vehicle traits
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.config.actorTraits.registerActorTraits([
   *     {
   *       title: "Vehicle Customization Options",
   *       iconClass: "fa-solid fa-ferry",
   *       enabled: (params) => params.context.actor.type === "vehicle",
   *       openConfiguration: (params) => {
   *         // TODO: Open totally awesome config dialog for setting custom vehicle stuff.
   *       },
   *       openConfigurationTooltip: "Click to customize!",
   *     },
   *     {
   *       title: "Vehicle Tribble Manager",
   *       iconClass: "fa-solid fa-ghost",
   *       enabled: (params) => params.context.actor.type === "vehicle",
   *       openConfiguration: (params) => {
   *         // TODO: Open a hopeless manager dialog for dealing with a tribble infestation.
   *       },
   *       openConfigurationTooltip: "Click to manage the unmanageable tribble problem ",
   *       alwaysShow: true,
   *     },
   *   ]);
   * });
   * ```
   */
  registerActorTraits(traits) {
    CustomActorTraitsRuntime.registerCustomActorTraits(traits);
  }
  /**
   * Registers a custom actor trait to the actor traits section of the actor sheet.
   * @param trait the trait to register
   *
   * @example Registering an actor trait
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.config.actorTraits.registerActorTrait({
   *     title: "Configure My Module",
   *     iconClass: "fa-solid fa-spaghetti-monster-flying",
   *     enabled: (params) =>
   *       ["character", "npc"].includes(params.context.actor.type),
   *     openConfiguration: (params) => {
   *       // TODO: For example, open another form to input some data.
   *     },
   *     openConfigurationTooltip: "Click to configure my module",
   *   });
   * });
   * ```
   *
   * @remarks
   * The actor traits section is a good place to put a configuration button for opening another dialog for a custom module.
   */
  registerActorTrait(trait) {
    this.registerActorTraits([trait]);
  }
}
class SpellSchoolApi {
  /**
   * Sets an icon class for a target school key.
   * @param schoolKey the key that represents a spell school, e.g. "abj" for Abjuration, "nec" for Necromancy, and "trs" for Transmutation
   * @param iconClass a class string for an `<i>` element
   *
   * @example Changing the transmutation icon to some nice coins.
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.config.spellSchool.setIcon('trs', 'fa-solid fa-coins');
   * });
   * ```
   */
  setIcon(schoolKey, iconClass) {
    SpellSchool.setIcon(schoolKey, iconClass);
  }
}
class ItemSummaryApi {
  /**
   * Registers item summary commands which Tidy 5e can render at select locations on the sheet.
   * @param commands item summary commands for Tidy 5e to render
   *
   * @example Registering commands that show for specific actor types
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.config.itemSummary.registerCommands([
   *     {
   *       label: 'Character Button',
   *       enabled: (params) => params.item.actor?.type === 'character',
   *       iconClass: 'fas fa-dice-d20',
   *       execute: (params) => {
   *         console.log('Clicked Character button', params.item);
   *       },
   *     },
   *     {
   *       label: 'NPC Button',
   *       enabled: (params) => params.item.actor?.type === 'npc',
   *       execute: (params) => {
   *         console.log('Clicked NPC button', params.item);
   *       },
   *     },
   *     {
   *       label: 'Vehicle Button',
   *       enabled: (params) => params.item.actor?.type === 'vehicle',
   *       execute: (params) => {
   *         console.log('Clicked Vehicle button', params.item);
   *       },
   *     },
   *   ]);
   * });
   * ```
   *
   * @example Displaying a button for versatile weapons only
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.config.itemSummary.registerCommands([
   *     {
   *       label: 'Versatile Weapon Button',
   *       enabled: (params) =>
   *         params.item.type === 'weapon' &&
   *         params.item.system?.properties?.has('ver') &&
   *         params.item.system?.damage?.versatile,
   *       iconClass: 'fa-solid fa-hands-praying',
   *       execute: (params) => {
   *         console.log('Do something versatile', params.item);
   *       },
   *     },
   *   ]);
   * });
   * ```
   */
  registerCommands(commands = []) {
    ItemSummaryRuntime.registerItemSummaryCommands(commands);
  }
}
class ExhaustionApi {
  /**
   * Configures exhaustion to use an open number field,
   * rather than a constrained set of levels.
   *
   * @example
   * ```js
   * Hooks.once('tidy5e-sheet.ready', async (api) => {
   *   await api.config.exhaustion.useOpenNumberExhaustion();
   * });
   * ```
   */
  async useOpenNumberExhaustion() {
    const config = {
      type: "open"
    };
    await FoundryAdapter.setTidySetting("exhaustionConfig", config);
  }
  /**
   * Configures exhaustion to use a constrained set of levels
   * with optional hints (usually rendered as tooltips).
   * @param params information needed to configure specific-level exhaustion
   *
   * @example Setting 3-level exhaustion
   * ```js
   * Hooks.once('tidy5e-sheet.ready', async (api) => {
   *   await api.config.exhaustion.useSpecificLevelExhaustion({
   *     totalLevels: 3,
   *     hints: [
   *       'No exhaustion',
   *       'You are kind of tired',
   *       'You look unwell',
   *       'Dead ',
   *     ],
   *   });
   * });
   * ```
   */
  async useSpecificLevelExhaustion(params) {
    const config = {
      type: "specific",
      hints: params?.hints ?? [],
      levels: Math.max(params?.totalLevels ?? 1, 1)
    };
    await FoundryAdapter.setTidySetting("exhaustionConfig", config);
  }
  /**
   * Configures vehicle exhaustion to use an open number field,
   * rather than a constrained set of levels.
   *
   * @example
   * ```js
   * Hooks.once('tidy5e-sheet.ready', async (api) => {
   *   await api.config.exhaustion.useOpenNumberVehicleExhaustion();
   * });
   * ```
   */
  async useOpenNumberVehicleExhaustion() {
    const config = {
      type: "open"
    };
    await FoundryAdapter.setTidySetting("vehicleExhaustionConfig", config);
  }
  /**
   * Configures vehicle exhaustion to use a constrained set of levels
   * with optional hints (usually rendered as tooltips).
   * @param params information needed to configure specific-level vehicle exhaustion
   *
   * @example Setting 3-level vehicle exhaustion
   * ```js
   * Hooks.once('tidy5e-sheet.ready', async (api) => {
   *   await api.config.exhaustion.useSpecificLevelVehicleExhaustion({
   *     totalLevels: 3,
   *     hints: ['Ship shape', 'A shape', "Uh oh, it's falling apart", 'Borked'],
   *   });
   * });
   * ```
   */
  async useSpecificLevelVehicleExhaustion(params) {
    const config = {
      type: "specific",
      hints: params?.hints ?? [],
      levels: Math.max(params?.totalLevels ?? 1, 1)
    };
    await FoundryAdapter.setTidySetting("vehicleExhaustionConfig", config);
  }
}
class FloatingContextMenu extends ContextMenu {
  constructor(...args) {
    super(...args);
  }
  /** @override */
  _setPosition([html], [target]) {
    const positionInfo = {
      insertTarget: document.body,
      html,
      target
    };
    if (!TidyHooks.tidy5eSheetsPrepareFloatingContextMenuPosition(positionInfo)) {
      return;
    }
    positionInfo.insertTarget.appendChild(html);
    const { clientWidth, clientHeight } = positionInfo.insertTarget;
    const { width, height } = html.getBoundingClientRect();
    const { clientX, clientY } = window.event;
    const left = Math.min(clientX + 1, clientWidth - width);
    this._expandUp = clientY + height > clientHeight;
    html.classList.add("floating");
    html.classList.add("tidy5e-sheet");
    html.classList.toggle("expand-up", this._expandUp);
    html.classList.toggle("expand-down", !this._expandUp);
    html.style.visibility = "";
    html.style.left = `${left}px`;
    if (this._expandUp) html.style.bottom = `${clientHeight - clientY}px`;
    else html.style.top = `${clientY}px`;
    target.classList.add("context");
  }
}
function instance$1J($$self, $$props, $$invalidate) {
  let { containingElement } = $$props;
  let { targetSelector } = $$props;
  let { options } = $$props;
  function initContextMenu(el) {
    new FloatingContextMenu(
      FoundryAdapter.getJqueryWrappedElement(el),
      targetSelector,
      [],
      {
        onOpen: () => {
          ui.context.menuItems = options;
        }
      }
    );
  }
  $$self.$$set = ($$props2) => {
    if ("containingElement" in $$props2) $$invalidate(0, containingElement = $$props2.containingElement);
    if ("targetSelector" in $$props2) $$invalidate(1, targetSelector = $$props2.targetSelector);
    if ("options" in $$props2) $$invalidate(2, options = $$props2.options);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*containingElement*/
    1) {
      {
        if (containingElement) {
          initContextMenu(containingElement);
        }
      }
    }
  };
  return [containingElement, targetSelector, options];
}
class FloatingContextMenu_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1J, null, safe_not_equal, {
      containingElement: 0,
      targetSelector: 1,
      options: 2
    });
  }
}
function create_fragment$1J(ctx) {
  let floatingcontextmenu;
  let t0;
  let div1;
  let img;
  let img_src_value;
  let img_alt_value;
  let t1;
  let div0;
  let current;
  let mounted;
  let dispose;
  floatingcontextmenu = new FloatingContextMenu_1({
    props: {
      containingElement: (
        /*itemImageContainer*/
        ctx[1]
      ),
      targetSelector: "[data-tidy-sheet-part=" + CONSTANTS.SHEET_PARTS.ITEM_IMAGE_CONTAINER + "]",
      options: (
        /*contextMenuOptions*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(floatingcontextmenu.$$.fragment);
      t0 = space();
      div1 = element("div");
      img = element("img");
      t1 = space();
      div0 = element("div");
      div0.innerHTML = `<i class="fas fa-question"></i>`;
      attr(img, "class", "profile");
      if (!src_url_equal(img.src, img_src_value = /*$context*/
      ctx[0].item.img)) attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*$context*/
      ctx[0].item.name);
      attr(
        img,
        "title",
        /*localize*/
        ctx[4]("TIDY5E.EditActorImage") + " / " + /*localize*/
        ctx[4]("TIDY5E.ShowItemImage")
      );
      attr(img, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_IMAGE);
      toggle_class(
        img,
        "conceal",
        /*$context*/
        ctx[0].item.system.identified === false
      );
      attr(div0, "role", "presentation");
      attr(div0, "aria-hidden", "true");
      attr(div0, "class", "unidentified-glyph");
      toggle_class(
        div0,
        "conceal",
        /*$context*/
        ctx[0].item.system.identified === false
      );
      attr(div1, "class", "item-image item-image-show-item-art");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_IMAGE_CONTAINER);
    },
    m(target, anchor) {
      mount_component(floatingcontextmenu, target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, img);
      append(div1, t1);
      append(div1, div0);
      ctx[7](div1);
      current = true;
      if (!mounted) {
        dispose = listen(
          img,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const floatingcontextmenu_changes = {};
      if (dirty & /*itemImageContainer*/
      2) floatingcontextmenu_changes.containingElement = /*itemImageContainer*/
      ctx2[1];
      if (dirty & /*contextMenuOptions*/
      4) floatingcontextmenu_changes.options = /*contextMenuOptions*/
      ctx2[2];
      floatingcontextmenu.$set(floatingcontextmenu_changes);
      if (!current || dirty & /*$context*/
      1 && !src_url_equal(img.src, img_src_value = /*$context*/
      ctx2[0].item.img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*$context*/
      1 && img_alt_value !== (img_alt_value = /*$context*/
      ctx2[0].item.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          img,
          "conceal",
          /*$context*/
          ctx2[0].item.system.identified === false
        );
      }
      if (!current || dirty & /*$context*/
      1) {
        toggle_class(
          div0,
          "conceal",
          /*$context*/
          ctx2[0].item.system.identified === false
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(floatingcontextmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingcontextmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div1);
      }
      destroy_component(floatingcontextmenu, detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$1I($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function openItemImagePicker(target, item) {
    const rect = target.getBoundingClientRect();
    const current = item.img;
    return FoundryAdapter.browseFilePicker({
      type: "image",
      current,
      callback: (path) => {
        item.update({ img: path });
      },
      top: rect.top + 40,
      left: rect.left + 10
    });
  }
  function showItemArt(item) {
    FoundryAdapter.renderImagePopout(item.img, {
      title: FoundryAdapter.localize("TIDY5E.ItemImageTitle", { subject: item.name }),
      shareable: true,
      uuid: item.uuid
    });
  }
  let itemImageContainer;
  let contextMenuOptions = [];
  const click_handler = (event) => openItemImagePicker(event.currentTarget, $context.item);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      itemImageContainer = $$value;
      $$invalidate(1, itemImageContainer);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, contextMenuOptions = [
        {
          name: "TIDY5E.ShowItemArt",
          icon: '<i class="fa-solid fa-image fa-fw"></i>',
          callback: () => showItemArt($context.item)
        }
      ]);
    }
  };
  return [
    $context,
    itemImageContainer,
    contextMenuOptions,
    context,
    localize,
    openItemImagePicker,
    click_handler,
    div1_binding
  ];
}
class ItemProfilePicture extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1I, create_fragment$1J, safe_not_equal, {});
  }
}
function create_else_block$t(ctx) {
  let span;
  let t_value = (
    /*source*/
    (ctx[3]?.label ?? "") + ""
  );
  let t2;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "source-label truncate svelte-rlyf3i");
      attr(span, "title", span_title_value = /*source*/
      ctx[3]?.label ?? "");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*source*/
      8 && t_value !== (t_value = /*source*/
      (ctx2[3]?.label ?? "") + "")) set_data(t2, t_value);
      if (dirty & /*source*/
      8 && span_title_value !== (span_title_value = /*source*/
      ctx2[3]?.label ?? "")) {
        attr(span, "title", span_title_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$t(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*document*/
        ctx[0]
      ),
      field: (
        /*keyPathToCustom*/
        ctx[4]
      ),
      value: (
        /*source*/
        ctx[3]?.custom
      ),
      placeholder: (
        /*localize*/
        ctx[6]("DND5E.Source")
      ),
      cssClass: "source-custom"
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*document*/
      1) textinput_changes.document = /*document*/
      ctx2[0];
      if (dirty & /*keyPathToCustom*/
      16) textinput_changes.field = /*keyPathToCustom*/
      ctx2[4];
      if (dirty & /*source*/
      8) textinput_changes.value = /*source*/
      ctx2[3]?.custom;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block$O(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button config-button svelte-rlyf3i");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1I(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t2;
  let current;
  const if_block_creators = [create_if_block_1$t, create_else_block$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*source*/
      ctx2[3]?.custom === /*source*/
      ctx2[3]?.label || /*source*/
      ctx2[3]?.label === ""
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*editable*/
    ctx[2] && create_if_block$O(ctx)
  );
  return {
    c() {
      div = element("div");
      if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      attr(div, "class", "source-container flex-row extra-small-gap align-items-center svelte-rlyf3i");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t2);
      if (if_block1) if_block1.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t2);
      }
      if (
        /*editable*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$O(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1) if_block1.d();
    }
  };
}
function instance$1H($$self, $$props, $$invalidate) {
  let keyPathToCustom;
  let source;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { document: document2 } = $$props;
  let { keyPath } = $$props;
  let { editable } = $$props;
  const localize = FoundryAdapter.localize;
  const click_handler = () => FoundryAdapter.renderSourceConfig(document2, keyPath);
  $$self.$$set = ($$props2) => {
    if ("document" in $$props2) $$invalidate(0, document2 = $$props2.document);
    if ("keyPath" in $$props2) $$invalidate(1, keyPath = $$props2.keyPath);
    if ("editable" in $$props2) $$invalidate(2, editable = $$props2.editable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*keyPath*/
    2) {
      $$invalidate(4, keyPathToCustom = `${keyPath}.custom`);
    }
    if ($$self.$$.dirty & /*document, keyPath*/
    3) {
      $$invalidate(3, source = FoundryAdapter.getProperty(document2, keyPath));
    }
  };
  return [
    document2,
    keyPath,
    editable,
    source,
    keyPathToCustom,
    $settingStore,
    localize,
    click_handler
  ];
}
class Source extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1H, create_fragment$1I, safe_not_equal, { document: 0, keyPath: 1, editable: 2 });
  }
}
function create_else_block$s(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.unidentified.name",
      value: (
        /*$context*/
        ctx[0].system.unidentified.name
      ),
      attributes: {
        "data-tidy-item-name": (
          /*$context*/
          ctx[0].system.unidentified.name
        )
      },
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.NameUnidentified")
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      title: (
        /*$context*/
        ctx[0].identifiedName
      )
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.unidentified.name;
      if (dirty & /*$context*/
      1) textinput_changes.attributes = {
        "data-tidy-item-name": (
          /*$context*/
          ctx2[0].system.unidentified.name
        )
      };
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$context*/
      1) textinput_changes.title = /*$context*/
      ctx2[0].identifiedName;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block$N(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "name",
      value: (
        /*$context*/
        ctx[0].item.name
      ),
      attributes: {
        "data-tidy-item-name": (
          /*$context*/
          ctx[0].item.name
        )
      },
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.ItemName")
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      title: (
        /*$context*/
        ctx[0].item.name
      )
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].item.name;
      if (dirty & /*$context*/
      1) textinput_changes.attributes = {
        "data-tidy-item-name": (
          /*$context*/
          ctx2[0].item.name
        )
      };
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$context*/
      1) textinput_changes.title = /*$context*/
      ctx2[0].item.name;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_fragment$1H(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$N, create_else_block$s];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].system.identified
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$1G($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemIdentifiableName extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1G, create_fragment$1H, safe_not_equal, {});
  }
}
function create_if_block_1$s(ctx) {
  let dnd5eicon;
  let current;
  dnd5eicon = new Dnd5eIcon({ props: { src: (
    /*iconSrc*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(dnd5eicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eicon_changes = {};
      if (dirty & /*iconSrc*/
      4) dnd5eicon_changes.src = /*iconSrc*/
      ctx2[2];
      dnd5eicon.$set(dnd5eicon_changes);
    },
    i(local) {
      if (current) return;
      transition_in(dnd5eicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eicon, detaching);
    }
  };
}
function create_if_block$M(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(
        i2,
        "class",
        /*iconClass*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*iconClass*/
      8) {
        attr(
          i2,
          "class",
          /*iconClass*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot$L(ctx) {
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*iconSrc*/
    ctx[2] && create_if_block_1$s(ctx)
  );
  let if_block1 = (
    /*iconClass*/
    ctx[3] && create_if_block$M(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (default_slot) default_slot.c();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*iconSrc*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*iconSrc*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$s(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*iconClass*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$M(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_fragment$1G(ctx) {
  let tidyswitch;
  let updating_value;
  let current;
  function tidyswitch_value_binding(value) {
    ctx[10](value);
  }
  let tidyswitch_props = {
    class: "flex-row small-gap tidy-property-toggle " + /*switchOn*/
    (ctx[4] ? "active" : "inactive"),
    title: (
      /*title*/
      ctx[0]
    ),
    disabled: (
      /*disabled*/
      ctx[1]
    ),
    $$slots: { default: [create_default_slot$L] },
    $$scope: { ctx }
  };
  if (
    /*switchOn*/
    ctx[4] !== void 0
  ) {
    tidyswitch_props.value = /*switchOn*/
    ctx[4];
  }
  tidyswitch = new TidySwitch({ props: tidyswitch_props });
  binding_callbacks.push(() => bind(tidyswitch, "value", tidyswitch_value_binding));
  tidyswitch.$on(
    "change",
    /*change_handler*/
    ctx[11]
  );
  return {
    c() {
      create_component(tidyswitch.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidyswitch, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tidyswitch_changes = {};
      if (dirty & /*switchOn*/
      16) tidyswitch_changes.class = "flex-row small-gap tidy-property-toggle " + /*switchOn*/
      (ctx2[4] ? "active" : "inactive");
      if (dirty & /*title*/
      1) tidyswitch_changes.title = /*title*/
      ctx2[0];
      if (dirty & /*disabled*/
      2) tidyswitch_changes.disabled = /*disabled*/
      ctx2[1];
      if (dirty & /*$$scope, iconClass, iconSrc*/
      4108) {
        tidyswitch_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & /*switchOn*/
      16) {
        updating_value = true;
        tidyswitch_changes.value = /*switchOn*/
        ctx2[4];
        add_flush_callback(() => updating_value = false);
      }
      tidyswitch.$set(tidyswitch_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidyswitch.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidyswitch.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidyswitch, detaching);
    }
  };
}
function instance$1F($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { document: document2 } = $$props;
  let { field } = $$props;
  let { checked } = $$props;
  let { title = "" } = $$props;
  let { disabled = false } = $$props;
  let { iconSrc = null } = $$props;
  let { iconClass = null } = $$props;
  let switchOn = checked;
  async function handleChange(originalValue) {
    try {
      document2.update({ [field]: !originalValue });
    } catch (e2) {
      error("An error occurred while toggling a property", false, e2);
      debug("Property toggle error troubleshooting info", { originalValue, state: switchOn });
      $$invalidate(4, switchOn = originalValue);
    }
  }
  function tidyswitch_value_binding(value) {
    switchOn = value;
    $$invalidate(4, switchOn), $$invalidate(8, checked);
  }
  const change_handler = (ev) => handleChange(ev.detail.originalValue);
  $$self.$$set = ($$props2) => {
    if ("document" in $$props2) $$invalidate(6, document2 = $$props2.document);
    if ("field" in $$props2) $$invalidate(7, field = $$props2.field);
    if ("checked" in $$props2) $$invalidate(8, checked = $$props2.checked);
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("disabled" in $$props2) $$invalidate(1, disabled = $$props2.disabled);
    if ("iconSrc" in $$props2) $$invalidate(2, iconSrc = $$props2.iconSrc);
    if ("iconClass" in $$props2) $$invalidate(3, iconClass = $$props2.iconClass);
    if ("$$scope" in $$props2) $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*checked*/
    256) {
      {
        $$invalidate(4, switchOn = checked);
      }
    }
  };
  return [
    title,
    disabled,
    iconSrc,
    iconClass,
    switchOn,
    handleChange,
    document2,
    field,
    checked,
    slots,
    tidyswitch_value_binding,
    change_handler,
    $$scope
  ];
}
class PropertyToggle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1F, create_fragment$1G, safe_not_equal, {
      document: 6,
      field: 7,
      checked: 8,
      title: 0,
      disabled: 1,
      iconSrc: 2,
      iconClass: 3
    });
  }
}
function create_default_slot_1$j(ctx) {
  let div;
  let t_value = (
    /*$context*/
    (ctx[2].system.equipped ? (
      /*localize*/
      ctx[4]("DND5E.Equipped")
    ) : (
      /*localize*/
      ctx[4]("DND5E.Unequipped")
    )) + ""
  );
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      set_style(
        div,
        "width",
        /*equipLabelWidthCh*/
        ctx[1] + "ch"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      4 && t_value !== (t_value = /*$context*/
      (ctx2[2].system.equipped ? (
        /*localize*/
        ctx2[4]("DND5E.Equipped")
      ) : (
        /*localize*/
        ctx2[4]("DND5E.Unequipped")
      )) + "")) set_data(t2, t_value);
      if (dirty & /*equipLabelWidthCh*/
      2) {
        set_style(
          div,
          "width",
          /*equipLabelWidthCh*/
          ctx2[1] + "ch"
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$L(ctx) {
  let propertytoggle;
  let current;
  propertytoggle = new PropertyToggle({
    props: {
      document: (
        /*$context*/
        ctx[2].item
      ),
      field: "system.identified",
      checked: (
        /*$context*/
        ctx[2].system.identified
      ),
      disabled: !/*$context*/
      ctx[2].editable,
      title: (
        /*$context*/
        ctx[2].system.identified ? (
          /*localize*/
          ctx[4]("DND5E.Identified")
        ) : (
          /*localize*/
          ctx[4]("DND5E.Unidentified.Title")
        )
      ),
      iconClass: "fas fa-magnifying-glass fa-fw",
      $$slots: { default: [create_default_slot$K] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(propertytoggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(propertytoggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const propertytoggle_changes = {};
      if (dirty & /*$context*/
      4) propertytoggle_changes.document = /*$context*/
      ctx2[2].item;
      if (dirty & /*$context*/
      4) propertytoggle_changes.checked = /*$context*/
      ctx2[2].system.identified;
      if (dirty & /*$context*/
      4) propertytoggle_changes.disabled = !/*$context*/
      ctx2[2].editable;
      if (dirty & /*$context*/
      4) propertytoggle_changes.title = /*$context*/
      ctx2[2].system.identified ? (
        /*localize*/
        ctx2[4]("DND5E.Identified")
      ) : (
        /*localize*/
        ctx2[4]("DND5E.Unidentified.Title")
      );
      if (dirty & /*$$scope, identifiedLabelWidthCh, $context*/
      37) {
        propertytoggle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      propertytoggle.$set(propertytoggle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(propertytoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(propertytoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(propertytoggle, detaching);
    }
  };
}
function create_default_slot$K(ctx) {
  let div;
  let t_value = (
    /*$context*/
    (ctx[2].system.identified ? (
      /*localize*/
      ctx[4]("DND5E.Identified")
    ) : (
      /*localize*/
      ctx[4]("DND5E.Unidentified.Title")
    )) + ""
  );
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      set_style(
        div,
        "width",
        /*identifiedLabelWidthCh*/
        ctx[0] + "ch"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      4 && t_value !== (t_value = /*$context*/
      (ctx2[2].system.identified ? (
        /*localize*/
        ctx2[4]("DND5E.Identified")
      ) : (
        /*localize*/
        ctx2[4]("DND5E.Unidentified.Title")
      )) + "")) set_data(t2, t_value);
      if (dirty & /*identifiedLabelWidthCh*/
      1) {
        set_style(
          div,
          "width",
          /*identifiedLabelWidthCh*/
          ctx2[0] + "ch"
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$1F(ctx) {
  let div;
  let propertytoggle;
  let t2;
  let show_if = FoundryAdapter.canIdentify(
    /*$context*/
    ctx[2].item
  );
  let current;
  propertytoggle = new PropertyToggle({
    props: {
      document: (
        /*$context*/
        ctx[2].item
      ),
      field: "system.equipped",
      checked: (
        /*$context*/
        ctx[2].system.equipped
      ),
      disabled: !/*$context*/
      ctx[2].editable,
      title: (
        /*$context*/
        ctx[2].system.equipped ? (
          /*localize*/
          ctx[4]("DND5E.Equipped")
        ) : (
          /*localize*/
          ctx[4]("DND5E.Unequipped")
        )
      ),
      iconClass: "fas fa-user-alt fa-fw",
      $$slots: { default: [create_default_slot_1$j] },
      $$scope: { ctx }
    }
  });
  let if_block = show_if && create_if_block$L(ctx);
  return {
    c() {
      div = element("div");
      create_component(propertytoggle.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      attr(div, "class", "flex-row extra-small-gap flex-wrap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(propertytoggle, div, null);
      append(div, t2);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const propertytoggle_changes = {};
      if (dirty & /*$context*/
      4) propertytoggle_changes.document = /*$context*/
      ctx2[2].item;
      if (dirty & /*$context*/
      4) propertytoggle_changes.checked = /*$context*/
      ctx2[2].system.equipped;
      if (dirty & /*$context*/
      4) propertytoggle_changes.disabled = !/*$context*/
      ctx2[2].editable;
      if (dirty & /*$context*/
      4) propertytoggle_changes.title = /*$context*/
      ctx2[2].system.equipped ? (
        /*localize*/
        ctx2[4]("DND5E.Equipped")
      ) : (
        /*localize*/
        ctx2[4]("DND5E.Unequipped")
      );
      if (dirty & /*$$scope, equipLabelWidthCh, $context*/
      38) {
        propertytoggle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      propertytoggle.$set(propertytoggle_changes);
      if (dirty & /*$context*/
      4) show_if = FoundryAdapter.canIdentify(
        /*$context*/
        ctx2[2].item
      );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$L(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(propertytoggle.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(propertytoggle.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(propertytoggle);
      if (if_block) if_block.d();
    }
  };
}
function instance$1E($$self, $$props, $$invalidate) {
  let equipLabelWidthCh;
  let identifiedLabelWidthCh;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  const localize = FoundryAdapter.localize;
  $$invalidate(1, equipLabelWidthCh = Math.max(localize("DND5E.Equipped").length, localize("DND5E.Unequipped").length));
  $$invalidate(0, identifiedLabelWidthCh = Math.max(localize("DND5E.Identified").length, localize("DND5E.Unidentified.Title").length));
  return [identifiedLabelWidthCh, equipLabelWidthCh, $context, context, localize];
}
class ItemHeaderToggles extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1E, create_fragment$1F, safe_not_equal, {});
  }
}
function create_else_block$r(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.rarity",
      value: (
        /*$context*/
        ctx[1].system.rarity
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      blankValue: "",
      $$slots: { default: [create_default_slot$J] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      2) select_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select_changes.value = /*$context*/
      ctx2[1].system.rarity;
      if (dirty & /*$context*/
      2) select_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      34) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block$K(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[3]("DND5E.Unidentified.Title")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot$J(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.itemRarity
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.itemRarity;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_fragment$1E(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let itemidentifiablename;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let ul;
  let li0;
  let t4_value = (
    /*$context*/
    ctx[1].system.type.label + ""
  );
  let t4;
  let t5;
  let li1;
  let current_block_type_index;
  let if_block;
  let t6;
  let li2;
  let source;
  let t7;
  let itemheadertoggles;
  let t8;
  let tabs;
  let updating_selectedTabId;
  let t9;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  itemidentifiablename = new ItemIdentifiableName({});
  const if_block_creators = [create_if_block$K, create_else_block$r];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].concealDetails
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable && !/*$context*/
        ctx[1].concealDetails
      )
    }
  });
  itemheadertoggles = new ItemHeaderToggles({});
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(itemidentifiablename.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      t4 = text(t4_value);
      t5 = space();
      li1 = element("li");
      if_block.c();
      t6 = space();
      li2 = element("li");
      create_component(source.$$.fragment);
      t7 = space();
      create_component(itemheadertoggles.$$.fragment);
      t8 = space();
      create_component(tabs.$$.fragment);
      t9 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(div0, "class", "item-subtitle");
      attr(li2, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(itemidentifiablename, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div1, t3);
      append(div1, ul);
      append(ul, li0);
      append(li0, t4);
      append(ul, t5);
      append(ul, li1);
      if_blocks[current_block_type_index].m(li1, null);
      append(ul, t6);
      append(ul, li2);
      mount_component(source, li2, null);
      append(div1, t7);
      mount_component(itemheadertoggles, div1, null);
      insert(target, t8, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t9, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      ctx2[1].system.type.label + "")) set_data(t4, t4_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li1, null);
      }
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable && !/*$context*/
      ctx2[1].concealDetails;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(itemidentifiablename.$$.fragment, local);
      transition_in(if_block);
      transition_in(source.$$.fragment, local);
      transition_in(itemheadertoggles.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(itemidentifiablename.$$.fragment, local);
      transition_out(if_block);
      transition_out(source.$$.fragment, local);
      transition_out(itemheadertoggles.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t8);
        detach(t9);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(itemidentifiablename);
      if_blocks[current_block_type_index].d();
      destroy_component(source);
      destroy_component(itemheadertoggles);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$1D($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class EquipmentSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1D, create_fragment$1E, safe_not_equal, {});
  }
}
function create_fragment$1D(ctx) {
  let div1;
  let div0;
  let strong;
  let t1;
  let p2;
  let div1_transition;
  let current;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      strong = element("strong");
      strong.textContent = `${/*localize*/
      ctx[0]("DND5E.Unidentified.Title")}`;
      t1 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[0]("DND5E.Unidentified.Notice")}`;
      attr(strong, "class", "svelte-ak5nvu");
      attr(div0, "class", "svelte-ak5nvu");
      attr(div1, "class", "unidentified-notice svelte-ak5nvu");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, strong);
      append(div0, t1);
      append(div0, p2);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { delay: 0, duration: 750 }, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { delay: 0, duration: 750 }, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (detaching && div1_transition) div1_transition.end();
    }
  };
}
function instance$1C($$self) {
  const localize = FoundryAdapter.localize;
  return [localize];
}
class UnidentifiedNotice extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1C, create_fragment$1D, safe_not_equal, {});
  }
}
function create_if_block$J(ctx) {
  let unidentifiednotice;
  let current;
  unidentifiednotice = new UnidentifiedNotice({});
  return {
    c() {
      create_component(unidentifiednotice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(unidentifiednotice, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(unidentifiednotice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(unidentifiednotice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(unidentifiednotice, detaching);
    }
  };
}
function create_fragment$1C(ctx) {
  let div1;
  let div0;
  let t2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let if_block = (
    /*conceal*/
    ctx[0] && create_if_block$J()
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      t2 = space();
      if (if_block) if_block.c();
      attr(div0, "role", "presentation");
      div0.inert = /*conceal*/
      ctx[0];
      attr(div1, "role", "presentation");
      attr(div1, "class", "concealing-parent inert-animation-container svelte-127wf1k");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append(div1, t2);
      if (if_block) if_block.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*conceal*/
      1) {
        div0.inert = /*conceal*/
        ctx2[0];
      }
      if (
        /*conceal*/
        ctx2[0]
      ) {
        if (if_block) {
          if (dirty & /*conceal*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$J();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d();
    }
  };
}
function instance$1B($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { conceal } = $$props;
  $$self.$$set = ($$props2) => {
    if ("conceal" in $$props2) $$invalidate(0, conceal = $$props2.conceal);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [conceal, $$scope, slots];
}
class ContentConcealer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1B, create_fragment$1C, safe_not_equal, { conceal: 0 });
  }
}
function get_each_context$h(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2][0];
  child_ctx[15] = list[i2][1];
  return child_ctx;
}
function get_each_context_1$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function create_if_block$I(ctx) {
  let li;
  let h3;
  let t0_value = (
    /*localize*/
    ctx[4](
      /*section*/
      ctx[15].label
    ) + ""
  );
  let t0;
  let t1;
  let div0;
  let t3;
  let div1;
  let t5;
  let div2;
  let li_data_effect_type_value;
  let t6;
  let t7;
  let ol;
  let t8;
  let if_block0 = (
    /*$context*/
    ctx[0].editable && create_if_block_4$a(ctx)
  );
  let if_block1 = (
    /*section*/
    ctx[15].info && create_if_block_3$f(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*section*/
    ctx[15].effects
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i2));
  }
  return {
    c() {
      li = element("li");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      div0.textContent = `${/*localize*/
      ctx[4]("DND5E.Source")}`;
      t3 = space();
      div1 = element("div");
      div1.textContent = `${/*localize*/
      ctx[4]("DND5E.Duration")}`;
      t5 = space();
      div2 = element("div");
      if (if_block0) if_block0.c();
      t6 = space();
      if (if_block1) if_block1.c();
      t7 = space();
      ol = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t8 = space();
      attr(h3, "class", "item-name effect-name flexrow");
      attr(div0, "class", "effect-source");
      attr(div1, "class", "effect-source");
      attr(div2, "class", "item-controls active-effect-controls flexrow");
      attr(li, "class", "items-header flexrow");
      attr(li, "data-effect-type", li_data_effect_type_value = /*section*/
      ctx[15].type);
      attr(ol, "class", "item-list");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, h3);
      append(h3, t0);
      append(li, t1);
      append(li, div0);
      append(li, t3);
      append(li, div1);
      append(li, t5);
      append(li, div2);
      if (if_block0) if_block0.m(div2, null);
      insert(target, t6, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t7, anchor);
      insert(target, ol, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
      append(ol, t8);
    },
    p(ctx2, dirty) {
      if (dirty & /*effects*/
      2 && t0_value !== (t0_value = /*localize*/
      ctx2[4](
        /*section*/
        ctx2[15].label
      ) + "")) set_data(t0, t0_value);
      if (
        /*$context*/
        ctx2[0].editable
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$a(ctx2);
          if_block0.c();
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*effects*/
      2 && li_data_effect_type_value !== (li_data_effect_type_value = /*section*/
      ctx2[15].type)) {
        attr(li, "data-effect-type", li_data_effect_type_value);
      }
      if (
        /*section*/
        ctx2[15].info
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3$f(ctx2);
          if_block1.c();
          if_block1.m(t7.parentNode, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*effects, handleMiddleClickToEdit, handleDragStart, localize, $settingStore, $context*/
      87) {
        each_value_1 = ensure_array_like(
          /*section*/
          ctx2[15].effects
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$6(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$6(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ol, t8);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
        detach(t6);
        detach(t7);
        detach(ol);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_4$a(ctx) {
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[4]("DND5E.Add") + ""
  );
  let t1;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[7](
        /*section*/
        ctx[15],
        ...args
      )
    );
  }
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-plus");
      attr(button, "type", "button");
      attr(button, "class", "active-effect-control inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[4]("DND5E.EffectCreate")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$f(ctx) {
  let ol;
  let each_value_2 = ensure_array_like(
    /*section*/
    ctx[15].info
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  return {
    c() {
      ol = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ol, "class", "info");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*effects*/
      2) {
        each_value_2 = ensure_array_like(
          /*section*/
          ctx2[15].info
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ol, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_2(ctx) {
  let li;
  let t_value = (
    /*info*/
    (ctx[21] ?? "") + ""
  );
  let t2;
  return {
    c() {
      li = element("li");
      t2 = text(t_value);
      attr(li, "class", "notification info");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*effects*/
      2 && t_value !== (t_value = /*info*/
      (ctx2[21] ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block_1$r(ctx) {
  let t0;
  let button0;
  let i0;
  let button0_tabindex_value;
  let t1;
  let button1;
  let i1;
  let button1_tabindex_value;
  let mounted;
  let dispose;
  let if_block = (
    /*section*/
    ctx[15].type !== "enchantment" && create_if_block_2$l(ctx)
  );
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[9](
        /*effect*/
        ctx[18]
      )
    );
  }
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[10](
        /*effect*/
        ctx[18]
      )
    );
  }
  return {
    c() {
      if (if_block) if_block.c();
      t0 = space();
      button0 = element("button");
      i0 = element("i");
      t1 = space();
      button1 = element("button");
      i1 = element("i");
      attr(i0, "class", "fas fa-edit");
      attr(button0, "type", "button");
      attr(button0, "class", "active-effect-control inline-transparent-button");
      attr(
        button0,
        "title",
        /*localize*/
        ctx[4]("DND5E.EffectEdit")
      );
      attr(button0, "tabindex", button0_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
      attr(i1, "class", "fas fa-trash");
      attr(button1, "type", "button");
      attr(button1, "class", "active-effect-control inline-transparent-button");
      attr(
        button1,
        "title",
        /*localize*/
        ctx[4]("DND5E.EffectDelete")
      );
      attr(button1, "tabindex", button1_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, button0, anchor);
      append(button0, i0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, i1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_2),
          listen(button1, "click", click_handler_3)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*section*/
        ctx[15].type !== "enchantment"
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_2$l(ctx);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$settingStore*/
      4 && button0_tabindex_value !== (button0_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button0, "tabindex", button0_tabindex_value);
      }
      if (dirty & /*$settingStore*/
      4 && button1_tabindex_value !== (button1_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button1, "tabindex", button1_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(button0);
        detach(t1);
        detach(button1);
      }
      if (if_block) if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$l(ctx) {
  let button;
  let i2;
  let button_title_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[8](
        /*effect*/
        ctx[18]
      )
    );
  }
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas");
      toggle_class(
        i2,
        "fa-check",
        /*effect*/
        ctx[18].disabled
      );
      toggle_class(i2, "fa-times", !/*effect*/
      ctx[18].disabled);
      attr(button, "type", "button");
      attr(button, "class", "active-effect-control inline-transparent-button");
      attr(button, "title", button_title_value = /*effect*/
      ctx[18].disabled ? "DND5E.EffectEnable" : "DND5E.EffectDisable");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*effects*/
      2) {
        toggle_class(
          i2,
          "fa-check",
          /*effect*/
          ctx[18].disabled
        );
      }
      if (dirty & /*effects*/
      2) {
        toggle_class(i2, "fa-times", !/*effect*/
        ctx[18].disabled);
      }
      if (dirty & /*effects*/
      2 && button_title_value !== (button_title_value = /*effect*/
      ctx[18].disabled ? "DND5E.EffectEnable" : "DND5E.EffectDisable")) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$6(ctx) {
  let li;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let h4;
  let t1_value = (
    /*effect*/
    (ctx[18].name ?? "") + ""
  );
  let t1;
  let t2;
  let div1;
  let t3_value = (
    /*effect*/
    (ctx[18].sourceName ?? "") + ""
  );
  let t3;
  let t4;
  let div2;
  let t5_value = (
    /*effect*/
    (ctx[18].duration.label ?? "") + ""
  );
  let t5;
  let t6;
  let div3;
  let li_data_effect_id_value;
  let mounted;
  let dispose;
  let if_block = (
    /*$context*/
    ctx[0].editable && create_if_block_1$r(ctx)
  );
  function mousedown_handler(...args) {
    return (
      /*mousedown_handler*/
      ctx[11](
        /*effect*/
        ctx[18],
        ...args
      )
    );
  }
  function dragstart_handler(...args) {
    return (
      /*dragstart_handler*/
      ctx[12](
        /*effect*/
        ctx[18],
        ...args
      )
    );
  }
  return {
    c() {
      li = element("li");
      div0 = element("div");
      img = element("img");
      t0 = space();
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div2 = element("div");
      t5 = text(t5_value);
      t6 = space();
      div3 = element("div");
      if (if_block) if_block.c();
      attr(img, "class", "item-image");
      if (!src_url_equal(img.src, img_src_value = /*effect*/
      ctx[18].img ?? /*effect*/
      ctx[18].icon)) attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*effect*/
      ctx[18].name ?? "");
      attr(div0, "class", "item-name effect-name flexrow");
      attr(div1, "class", "effect-source");
      attr(div2, "class", "effect-duration");
      attr(div3, "class", "item-controls active-effect-controls flexrow");
      attr(li, "class", "item effect flexrow");
      attr(li, "data-effect-id", li_data_effect_id_value = /*effect*/
      ctx[18].id);
      attr(li, "draggable", true);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, h4);
      append(h4, t1);
      append(li, t2);
      append(li, div1);
      append(div1, t3);
      append(li, t4);
      append(li, div2);
      append(div2, t5);
      append(li, t6);
      append(li, div3);
      if (if_block) if_block.m(div3, null);
      if (!mounted) {
        dispose = [
          listen(li, "mousedown", mousedown_handler),
          listen(li, "dragstart", dragstart_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*effects*/
      2 && !src_url_equal(img.src, img_src_value = /*effect*/
      ctx[18].img ?? /*effect*/
      ctx[18].icon)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*effects*/
      2 && img_alt_value !== (img_alt_value = /*effect*/
      ctx[18].name ?? "")) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*effects*/
      2 && t1_value !== (t1_value = /*effect*/
      (ctx[18].name ?? "") + "")) set_data(t1, t1_value);
      if (dirty & /*effects*/
      2 && t3_value !== (t3_value = /*effect*/
      (ctx[18].sourceName ?? "") + "")) set_data(t3, t3_value);
      if (dirty & /*effects*/
      2 && t5_value !== (t5_value = /*effect*/
      (ctx[18].duration.label ?? "") + "")) set_data(t5, t5_value);
      if (
        /*$context*/
        ctx[0].editable
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$r(ctx);
          if_block.c();
          if_block.m(div3, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*effects*/
      2 && li_data_effect_id_value !== (li_data_effect_id_value = /*effect*/
      ctx[18].id)) {
        attr(li, "data-effect-id", li_data_effect_id_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$h(ctx) {
  let if_block_anchor;
  let if_block = !/*section*/
  ctx[15].hidden && create_if_block$I(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (!/*section*/
      ctx2[15].hidden) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$I(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot$I(ctx) {
  let ol;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*effects*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$h(get_each_context$h(ctx, each_value, i2));
  }
  return {
    c() {
      ol = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ol, "class", "items-list effects-list");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          ol,
          "drop",
          /*drop_handler*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*effects, handleMiddleClickToEdit, handleDragStart, localize, $settingStore, $context, onAddClicked*/
      119) {
        each_value = ensure_array_like(
          /*effects*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$h(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$h(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ol, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1B(ctx) {
  let contentconcealer;
  let current;
  contentconcealer = new ContentConcealer({
    props: {
      conceal: (
        /*$context*/
        ctx[0].concealDetails
      ),
      $$slots: { default: [create_default_slot$I] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(contentconcealer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contentconcealer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const contentconcealer_changes = {};
      if (dirty & /*$context*/
      1) contentconcealer_changes.conceal = /*$context*/
      ctx2[0].concealDetails;
      if (dirty & /*$$scope, $context, effects, $settingStore*/
      16777223) {
        contentconcealer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contentconcealer.$set(contentconcealer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contentconcealer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contentconcealer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contentconcealer, detaching);
    }
  };
}
function handleDragStart(event, effect) {
  if (!effect) {
    return;
  }
  const dragData = effect.toDragData();
  event.dataTransfer?.setData("text/plain", JSON.stringify(dragData));
}
function instance$1A($$self, $$props, $$invalidate) {
  let effects;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function onAddClicked(section) {
    const owner = $context.item;
    return FoundryAdapter.addEffect(section.type, owner);
  }
  function handleMiddleClickToEdit(event, effect) {
    if (event.button === CONSTANTS.MOUSE_BUTTON_AUXILIARY) {
      effect.sheet.render(true);
    }
  }
  const click_handler = (section, event) => onAddClicked(section);
  const click_handler_1 = (effect) => effect.update({ disabled: !effect.disabled });
  const click_handler_2 = (effect) => effect.sheet.render(true);
  const click_handler_3 = (effect) => effect.deleteDialog();
  const mousedown_handler = (effect, event) => handleMiddleClickToEdit(event, effect);
  const dragstart_handler = (effect, ev) => handleDragStart(ev, effect);
  const drop_handler = (ev) => $context.item.sheet._onDrop(ev);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, effects = Object.entries($context.effects));
    }
  };
  return [
    $context,
    effects,
    $settingStore,
    context,
    localize,
    onAddClicked,
    handleMiddleClickToEdit,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    mousedown_handler,
    dragstart_handler,
    drop_handler
  ];
}
class ItemActiveEffectsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1A, create_fragment$1B, safe_not_equal, {});
  }
}
function create_key_block$4(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = /*svgHtml*/
      ctx[0];
      if (!mounted) {
        dispose = action_destroyer(
          /*preprocessSvg*/
          ctx[1].call(null, div)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*svgHtml*/
      1) div.innerHTML = /*svgHtml*/
      ctx2[0];
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1A(ctx) {
  let previous_key = (
    /*svgHtml*/
    ctx[0]
  );
  let key_block_anchor;
  let key_block = create_key_block$4(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*svgHtml*/
      1 && safe_not_equal(previous_key, previous_key = /*svgHtml*/
      ctx2[0])) {
        key_block.d(1);
        key_block = create_key_block$4(ctx2);
        key_block.c();
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
function instance$1z($$self, $$props, $$invalidate) {
  let { svgUrl } = $$props;
  let { removeInlineStyles = true } = $$props;
  let svgHtml = "";
  function preprocessSvg(node) {
    removeInlineStyles && node.querySelector("svg")?.removeAttribute("style");
  }
  $$self.$$set = ($$props2) => {
    if ("svgUrl" in $$props2) $$invalidate(2, svgUrl = $$props2.svgUrl);
    if ("removeInlineStyles" in $$props2) $$invalidate(3, removeInlineStyles = $$props2.removeInlineStyles);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*svgUrl*/
    4) {
      {
        (async () => {
          if (!svgUrl) {
            return;
          }
          try {
            const response = await fetch(svgUrl);
            if (response.ok) {
              $$invalidate(0, svgHtml = await response.text());
            }
          } catch (e2) {
            error("An error occurred while getting SVG images. See devtools console for more details.", true, e2);
            $$invalidate(0, svgHtml = `<img src="${svgUrl}" alt="" />`);
          }
        })();
      }
    }
  };
  return [svgHtml, preprocessSvg, svgUrl, removeInlineStyles];
}
class InlineSvg extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1z, create_fragment$1A, safe_not_equal, { svgUrl: 2, removeInlineStyles: 3 });
  }
}
function get_each_context$g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2][0];
  child_ctx[15] = list[i2][1];
  return child_ctx;
}
function get_each_context_1$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  const constants_0 = isSvg(
    /*advancement*/
    child_ctx[18].icon
  );
  child_ctx[19] = constants_0;
  return child_ctx;
}
function create_if_block_11$1(ctx) {
  let li;
  let div;
  let t2;
  let if_block0 = (
    /*$context*/
    ctx[0].editable && /*$context*/
    ctx[0].isEmbedded && create_if_block_13$1(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].editable && /*$context*/
      ctx2[0].advancementEditable
    ) return create_if_block_12$1;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      li = element("li");
      div = element("div");
      if (if_block0) if_block0.c();
      t2 = space();
      if_block1.c();
      attr(div, "class", "item-controls configuration-mode-control");
      attr(li, "class", "items-header main-controls advancement flex-row justify-content-space-between");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      if (if_block0) if_block0.m(div, null);
      append(li, t2);
      if_block1.m(li, null);
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].editable && /*$context*/
        ctx2[0].isEmbedded
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_13$1(ctx2);
          if_block0.c();
          if_block0.m(div, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(li, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block0) if_block0.d();
      if_block1.d();
    }
  };
}
function create_if_block_13$1(ctx) {
  let button;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].advancementEditable
    ) return create_if_block_14$1;
    return create_else_block_3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", "inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[4]("DND5E.AdvancementConfigurationActionDisable")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_3(ctx) {
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[4]("DND5E.AdvancementConfigurationModeDisabled") + ""
  );
  let t1;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-lock");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_if_block_14$1(ctx) {
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[4]("DND5E.AdvancementConfigurationModeEnabled") + ""
  );
  let t1;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-lock-open");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_else_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_12$1(ctx) {
  let div;
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[4]("DND5E.Add") + ""
  );
  let t1;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-plus");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[4]("DND5E.AdvancementControlCreate")
      );
      attr(
        button,
        "aria-label",
        /*localize*/
        ctx[4]("DND5E.AdvancementControlCreate")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div, "class", "item-controls add-button");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1$5(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("DND5E.AdvancementLevelHeader", { level: (
      /*level*/
      ctx[14]
    ) }) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*advancements*/
      2 && t_value !== (t_value = /*localize*/
      ctx2[4]("DND5E.AdvancementLevelHeader", { level: (
        /*level*/
        ctx2[14]
      ) }) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_10$2(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("DND5E.AdvancementLevelNoneHeader") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_9$4(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("DND5E.AdvancementLevelAnyHeader") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_8$4(ctx) {
  let div;
  let button;
  let t_value = (
    /*localize*/
    ctx[4]("DND5E.AdvancementModifyChoices") + ""
  );
  let t2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[9](
        /*level*/
        ctx[14]
      )
    );
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      t2 = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "inline-transparent-button");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7$6(ctx) {
  let div;
  let i2;
  return {
    c() {
      div = element("div");
      i2 = element("i");
      attr(i2, "class", "fas fa-exclamation-triangle");
      attr(div, "class", "item-warning");
      attr(
        div,
        "title",
        /*localize*/
        ctx[4]("DND5E.AdvancementConfiguredIncomplete")
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, i2);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_6$6(ctx) {
  let div;
  let i2;
  return {
    c() {
      div = element("div");
      i2 = element("i");
      attr(i2, "class", "fas fa-check-circle");
      attr(div, "class", "item-checkmark");
      attr(
        div,
        "title",
        /*localize*/
        ctx[4]("DND5E.AdvancementConfiguredComplete")
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, i2);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_else_block$q(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*advancement*/
      ctx[18].icon)) attr(img, "src", img_src_value);
      attr(img, "alt", "");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*advancements*/
      2 && !src_url_equal(img.src, img_src_value = /*advancement*/
      ctx2[18].icon)) {
        attr(img, "src", img_src_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_if_block_5$8(ctx) {
  let inlinesvg;
  let current;
  inlinesvg = new InlineSvg({
    props: { svgUrl: (
      /*advancement*/
      ctx[18].icon
    ) }
  });
  return {
    c() {
      create_component(inlinesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinesvg, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinesvg_changes = {};
      if (dirty & /*advancements*/
      2) inlinesvg_changes.svgUrl = /*advancement*/
      ctx2[18].icon;
      inlinesvg.$set(inlinesvg_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinesvg, detaching);
    }
  };
}
function create_if_block_2$k(ctx) {
  let div;
  function select_block_type_5(ctx2, dirty) {
    if (
      /*advancement*/
      ctx2[18].classRestriction === "primary"
    ) return create_if_block_3$e;
    if (
      /*advancement*/
      ctx2[18].classRestriction === "secondary"
    ) return create_if_block_4$9;
  }
  let current_block_type = select_block_type_5(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      attr(div, "class", "flexrow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_5(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block) if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_if_block_4$9(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("DND5E.AdvancementClassRestrictionSecondary") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_3$e(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("DND5E.AdvancementClassRestrictionPrimary") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$q(ctx) {
  let div;
  let button0;
  let i0;
  let button0_tabindex_value;
  let t2;
  let button1;
  let i1;
  let button1_tabindex_value;
  let mounted;
  let dispose;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[10](
        /*advancement*/
        ctx[18]
      )
    );
  }
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[11](
        /*advancement*/
        ctx[18]
      )
    );
  }
  return {
    c() {
      div = element("div");
      button0 = element("button");
      i0 = element("i");
      t2 = space();
      button1 = element("button");
      i1 = element("i");
      attr(i0, "class", "fas fa-edit");
      attr(button0, "type", "button");
      attr(button0, "class", "inline-icon-button");
      attr(
        button0,
        "title",
        /*localize*/
        ctx[4]("DND5E.AdvancementControlEdit")
      );
      attr(
        button0,
        "aria-label",
        /*localize*/
        ctx[4]("DND5E.AdvancementControlEdit")
      );
      attr(button0, "tabindex", button0_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
      attr(i1, "class", "fas fa-trash");
      attr(button1, "type", "button");
      attr(button1, "class", "inline-icon-button");
      attr(
        button1,
        "title",
        /*localize*/
        ctx[4]("DND5E.AdvancementControlDelete")
      );
      attr(
        button1,
        "aria-label",
        /*localize*/
        ctx[4]("DND5E.AdvancementControlDelete")
      );
      attr(button1, "tabindex", button1_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div, "class", "item-controls flexrow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, i0);
      append(div, t2);
      append(div, button1);
      append(button1, i1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_3),
          listen(button1, "click", click_handler_4)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$settingStore*/
      4 && button0_tabindex_value !== (button0_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button0, "tabindex", button0_tabindex_value);
      }
      if (dirty & /*$settingStore*/
      4 && button1_tabindex_value !== (button1_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button1, "tabindex", button1_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$H(ctx) {
  let div;
  let raw_value = (
    /*advancement*/
    ctx[18].summary + ""
  );
  return {
    c() {
      div = element("div");
      attr(div, "class", "item-summary");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & /*advancements*/
      2 && raw_value !== (raw_value = /*advancement*/
      ctx2[18].summary + "")) div.innerHTML = raw_value;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block_1$5(ctx) {
  let li;
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t0;
  let h4;
  let raw_value = (
    /*advancement*/
    ctx[18].title + ""
  );
  let t1;
  let t2;
  let t3;
  let li_data_id_value;
  let li_draggable_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_5$8, create_else_block$q];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*isSvgIcon*/
      ctx2[19]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*$context*/
    (ctx[0].advancementEditable || !/*$context*/
    ctx[0].isEmbedded) && create_if_block_2$k(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[0].editable && /*$context*/
    ctx[0].advancementEditable && create_if_block_1$q(ctx)
  );
  let if_block3 = (
    /*advancement*/
    ctx[18].summary && create_if_block$H(ctx)
  );
  function dragstart_handler(...args) {
    return (
      /*dragstart_handler*/
      ctx[12](
        /*advancement*/
        ctx[18],
        ...args
      )
    );
  }
  return {
    c() {
      li = element("li");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      h4 = element("h4");
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      t3 = space();
      if (if_block3) if_block3.c();
      attr(div0, "class", "item-image");
      toggle_class(
        div0,
        "svg",
        /*isSvgIcon*/
        ctx[19]
      );
      attr(div1, "class", "item-name flexrow");
      attr(li, "class", "advancement-item item flexrow");
      attr(li, "data-id", li_data_id_value = /*advancement*/
      ctx[18].id);
      attr(li, "draggable", li_draggable_value = /*$context*/
      ctx[0].owner);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div1);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div1, t0);
      append(div1, h4);
      h4.innerHTML = raw_value;
      append(li, t1);
      if (if_block1) if_block1.m(li, null);
      append(li, t2);
      if (if_block2) if_block2.m(li, null);
      append(li, t3);
      if (if_block3) if_block3.m(li, null);
      current = true;
      if (!mounted) {
        dispose = listen(li, "dragstart", dragstart_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        } else {
          if_block0.p(ctx, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      if (!current || dirty & /*isSvg, advancements*/
      2) {
        toggle_class(
          div0,
          "svg",
          /*isSvgIcon*/
          ctx[19]
        );
      }
      if ((!current || dirty & /*advancements*/
      2) && raw_value !== (raw_value = /*advancement*/
      ctx[18].title + "")) h4.innerHTML = raw_value;
      if (
        /*$context*/
        ctx[0].advancementEditable || !/*$context*/
        ctx[0].isEmbedded
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2$k(ctx);
          if_block1.c();
          if_block1.m(li, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$context*/
        ctx[0].editable && /*$context*/
        ctx[0].advancementEditable
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_1$q(ctx);
          if_block2.c();
          if_block2.m(li, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*advancement*/
        ctx[18].summary
      ) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
        } else {
          if_block3 = create_if_block$H(ctx);
          if_block3.c();
          if_block3.m(li, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!current || dirty & /*advancements*/
      2 && li_data_id_value !== (li_data_id_value = /*advancement*/
      ctx[18].id)) {
        attr(li, "data-id", li_data_id_value);
      }
      if (!current || dirty & /*$context*/
      1 && li_draggable_value !== (li_draggable_value = /*$context*/
      ctx[0].owner)) {
        attr(li, "draggable", li_draggable_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$g(ctx) {
  let li;
  let h3;
  let t0;
  let t1;
  let li_data_level_value;
  let t2;
  let ol;
  let t3;
  let current;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*level*/
      ctx2[14] === "0"
    ) return create_if_block_9$4;
    if (
      /*level*/
      ctx2[14] === "unconfigured"
    ) return create_if_block_10$2;
    return create_else_block_1$5;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*$context*/
    ctx[0].editable && /*data*/
    ctx[15].configured && /*level*/
    ctx[14] !== "unconfigured" && create_if_block_8$4(ctx)
  );
  function select_block_type_3(ctx2, dirty) {
    if (
      /*data*/
      ctx2[15].configured === "full"
    ) return create_if_block_6$6;
    if (
      /*data*/
      ctx2[15].configured === "partial"
    ) return create_if_block_7$6;
  }
  let current_block_type_1 = select_block_type_3(ctx);
  let if_block2 = current_block_type_1 && current_block_type_1(ctx);
  let each_value_1 = ensure_array_like(
    /*data*/
    ctx[15].items
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      li = element("li");
      h3 = element("h3");
      if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      ol = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      attr(h3, "class", "item-name flexrow");
      attr(li, "class", "items-header flexrow");
      attr(li, "data-level", li_data_level_value = /*level*/
      ctx[14]);
      attr(ol, "class", "item-list");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, h3);
      if_block0.m(h3, null);
      append(li, t0);
      if (if_block1) if_block1.m(li, null);
      append(li, t1);
      if (if_block2) if_block2.m(li, null);
      insert(target, t2, anchor);
      insert(target, ol, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
      append(ol, t3);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(h3, null);
        }
      }
      if (
        /*$context*/
        ctx2[0].editable && /*data*/
        ctx2[15].configured && /*level*/
        ctx2[14] !== "unconfigured"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_8$4(ctx2);
          if_block1.c();
          if_block1.m(li, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx2)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if (if_block2) if_block2.d(1);
        if_block2 = current_block_type_1 && current_block_type_1(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(li, null);
        }
      }
      if (!current || dirty & /*advancements*/
      2 && li_data_level_value !== (li_data_level_value = /*level*/
      ctx2[14])) {
        attr(li, "data-level", li_data_level_value);
      }
      if (dirty & /*advancements, $context, handleAdvancementDragStart, localize, $settingStore, isSvg*/
      87) {
        each_value_1 = ensure_array_like(
          /*data*/
          ctx2[15].items
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$5(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(ol, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
        detach(t2);
        detach(ol);
      }
      if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) {
        if_block2.d();
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$1z(ctx) {
  let ol;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$context*/
    ctx[0].editable && create_if_block_11$1(ctx)
  );
  let each_value = ensure_array_like(
    /*advancements*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$g(get_each_context$g(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      ol = element("ol");
      if (if_block) if_block.c();
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ol, "class", "items-list flex-1");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      if (if_block) if_block.m(ol, null);
      append(ol, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          ol,
          "drop",
          /*drop_handler*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$context*/
        ctx2[0].editable
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_11$1(ctx2);
          if_block.c();
          if_block.m(ol, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*advancements, $context, handleAdvancementDragStart, localize, $settingStore, isSvg*/
      87) {
        each_value = ensure_array_like(
          /*advancements*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$g(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$g(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(ol, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      if (if_block) if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
const basicSvgFilePathRegex = /\.svg$/i;
function isSvg(iconPath) {
  return basicSvgFilePathRegex.test(iconPath?.trim());
}
function instance$1y($$self, $$props, $$invalidate) {
  let advancements;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  function toggleAdvancementLock(item) {
    $context.toggleAdvancementLock();
  }
  function handleAdvancementDragStart(event, advancement) {
    if (!advancement) {
      return;
    }
    const dragData = $context.item.advancement.byId[advancement.id]?.toDragData();
    event.dataTransfer?.setData("text/plain", JSON.stringify(dragData));
  }
  const click_handler = () => toggleAdvancementLock($context.item);
  const click_handler_1 = () => FoundryAdapter.createAdvancementSelectionDialog($context.item);
  const click_handler_2 = (level) => FoundryAdapter.modifyAdvancementChoices(level, $context.item);
  const click_handler_3 = (advancement) => FoundryAdapter.editAdvancement(advancement.id, $context.item);
  const click_handler_4 = (advancement) => FoundryAdapter.deleteAdvancement(advancement.id, $context.item);
  const dragstart_handler = (advancement, ev) => handleAdvancementDragStart(ev, advancement);
  const drop_handler = (ev) => $context.owner && $context.item.sheet._onDrop(ev);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, advancements = Object.entries($context.advancement));
    }
  };
  return [
    $context,
    advancements,
    $settingStore,
    context,
    localize,
    toggleAdvancementLock,
    handleAdvancementDragStart,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    dragstart_handler,
    drop_handler
  ];
}
class ItemAdvancementTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1y, create_fragment$1z, safe_not_equal, {});
  }
}
const get_default_slot_changes = (dirty) => ({ inputId: dirty & /*inputId*/
8 });
const get_default_slot_context = (ctx) => ({ inputId: (
  /*inputId*/
  ctx[3]
) });
const get_inside_after_label_slot_changes = (dirty) => ({});
const get_inside_after_label_slot_context = (ctx) => ({});
function create_if_block$G(ctx) {
  let label;
  let t0;
  let t1;
  let current;
  const inside_after_label_slot_template = (
    /*#slots*/
    ctx[7]["inside-after-label"]
  );
  const inside_after_label_slot = create_slot(
    inside_after_label_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_inside_after_label_slot_context
  );
  return {
    c() {
      label = element("label");
      t0 = text(
        /*labelText*/
        ctx[1]
      );
      t1 = space();
      if (inside_after_label_slot) inside_after_label_slot.c();
      attr(
        label,
        "for",
        /*inputId*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t0);
      append(label, t1);
      if (inside_after_label_slot) {
        inside_after_label_slot.m(label, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*labelText*/
      2) set_data(
        t0,
        /*labelText*/
        ctx2[1]
      );
      if (inside_after_label_slot) {
        if (inside_after_label_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            inside_after_label_slot,
            inside_after_label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              inside_after_label_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_inside_after_label_slot_changes
            ),
            get_inside_after_label_slot_context
          );
        }
      }
      if (!current || dirty & /*inputId*/
      8) {
        attr(
          label,
          "for",
          /*inputId*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(inside_after_label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(inside_after_label_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (inside_after_label_slot) inside_after_label_slot.d(detaching);
    }
  };
}
function create_fragment$1y(ctx) {
  let div;
  let t2;
  let div_class_value;
  let div_data_form_group_for_value;
  let current;
  let if_block = (
    /*labelText*/
    ctx[1] !== null && create_if_block$G(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context
  );
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      if (default_slot) default_slot.c();
      attr(div, "class", div_class_value = "form-group " + /*cssClass*/
      ctx[2]);
      attr(div, "data-form-group-for", div_data_form_group_for_value = /*field*/
      ctx[0] ?? null);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*labelText*/
        ctx2[1] !== null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*labelText*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$G(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, inputId*/
        72)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      if (!current || dirty & /*cssClass*/
      4 && div_class_value !== (div_class_value = "form-group " + /*cssClass*/
      ctx2[2])) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*field*/
      1 && div_data_form_group_for_value !== (div_data_form_group_for_value = /*field*/
      ctx2[0] ?? null)) {
        attr(div, "data-form-group-for", div_data_form_group_for_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$1x($$self, $$props, $$invalidate) {
  let inputId;
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { field = null } = $$props;
  let { labelText = null } = $$props;
  let { cssClass = "" } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(5, $context = value));
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2) $$invalidate(0, field = $$props2.field);
    if ("labelText" in $$props2) $$invalidate(1, labelText = $$props2.labelText);
    if ("cssClass" in $$props2) $$invalidate(2, cssClass = $$props2.cssClass);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*field, $context*/
    33) {
      $$invalidate(3, inputId = field !== null ? `${$context.appId}-${field.replaceAll(".", "-")}` : null);
    }
  };
  return [field, labelText, cssClass, inputId, context, $context, $$scope, slots];
}
class ItemFormGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1x, create_fragment$1y, safe_not_equal, { field: 0, labelText: 1, cssClass: 2 });
  }
}
function create_fragment$1x(ctx) {
  let h3;
  let t0_value = (
    /*localize*/
    ctx[2]("DND5E.StartingEquipment.Title") + ""
  );
  let t0;
  let t1;
  let span;
  let button;
  let i2;
  let t2;
  let html_tag;
  let raw_value = coalesce(
    /*$context*/
    ctx[0].system.startingEquipmentDescription,
    /*localize*/
    ctx[2]("None")
  ) + "";
  let html_anchor;
  let mounted;
  let dispose;
  return {
    c() {
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      button = element("button");
      i2 = element("i");
      t2 = space();
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      attr(i2, "class", "fas fa-gear");
      attr(button, "type", "button");
      attr(button, "class", "configure-starting-equipment inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[2]("DND5E.StartingEquipment.Action.Configure")
      );
      attr(
        button,
        "aria-label",
        /*localize*/
        ctx[2]("DND5E.StartingEquipment.Action.Configure")
      );
      attr(span, "class", "svelte-1jv7hqs");
      attr(h3, "class", "form-header flex-row justify-content-space-between");
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, t1);
      append(h3, span);
      append(span, button);
      append(button, i2);
      insert(target, t2, anchor);
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      1 && raw_value !== (raw_value = coalesce(
        /*$context*/
        ctx2[0].system.startingEquipmentDescription,
        /*localize*/
        ctx2[2]("None")
      ) + "")) html_tag.p(raw_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t2);
        detach(html_anchor);
        html_tag.d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$1w($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = () => FoundryAdapter.openStartingEquipmentConfig($context.item);
  return [$context, context, localize, click_handler];
}
class ItemStartingEquipment extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1w, create_fragment$1x, safe_not_equal, {});
  }
}
function create_default_slot$H(ctx) {
  let div;
  let textinput;
  let t0;
  let p2;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.identifier",
      value: (
        /*$context*/
        ctx[0].system.identifier
      ),
      placeholder: (
        /*$context*/
        ctx[0].item.identifier
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[2]("DND5E.IdentifierError")}`;
      attr(div, "class", "form-fields");
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.identifier;
      if (dirty & /*$context*/
      1) textinput_changes.placeholder = /*$context*/
      ctx2[0].item.identifier;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p2);
      }
      destroy_component(textinput);
    }
  };
}
function create_fragment$1w(ctx) {
  let itemformgroup;
  let t2;
  let itemstartingequipment;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Identifier")
      ),
      $$slots: { default: [create_default_slot$H] },
      $$scope: { ctx }
    }
  });
  itemstartingequipment = new ItemStartingEquipment({});
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
      t2 = space();
      create_component(itemstartingequipment.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemstartingequipment, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, $context*/
      9) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      transition_in(itemstartingequipment.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      transition_out(itemstartingequipment.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemformgroup, detaching);
      destroy_component(itemstartingequipment, detaching);
    }
  };
}
function instance$1v($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemBackgroundDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1v, create_fragment$1w, safe_not_equal, {});
  }
}
function create_default_slot_3$f(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.spellProgression
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.spellProgression;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_2$f(ctx) {
  let div;
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.spellcasting.progression",
      value: (
        /*$context*/
        ctx[0].system.spellcasting.progression
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_3$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.spellcasting.progression;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(select);
    }
  };
}
function create_default_slot_1$i(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.abilities
      ),
      labelProp: "label",
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.abilities;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot$G(ctx) {
  let div;
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.spellcasting.ability",
      value: (
        /*$context*/
        ctx[0].system.spellcasting.ability
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_1$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.spellcasting.ability;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(select);
    }
  };
}
function create_fragment$1v(ctx) {
  let itemformgroup0;
  let t2;
  let itemformgroup1;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      field: "system.spellcasting.progression",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellProgression")
      ),
      $$slots: {
        default: [
          create_default_slot_2$f,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      field: "system.spellcasting.ability",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellAbility")
      ),
      $$slots: {
        default: [
          create_default_slot$G,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      create_component(itemformgroup1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
    }
  };
}
function instance$1u($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemSpellcasting extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1u, create_fragment$1v, safe_not_equal, {});
  }
}
function get_each_context$f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_default_slot_4$c(ctx) {
  let div;
  let textinput;
  let t0;
  let p2;
  let html_tag;
  let raw_value = (
    /*localize*/
    ctx[2]("DND5E.ClassIdentifierHint", {
      identifier: (
        /*$context*/
        ctx[0].item.identifier
      )
    }) + ""
  );
  let t1;
  let t2_value = (
    /*localize*/
    ctx[2]("DND5E.IdentifierError") + ""
  );
  let t2;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.identifier",
      value: (
        /*$context*/
        ctx[0].system.identifier
      ),
      placeholder: (
        /*$context*/
        ctx[0].item.identifier
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      p2 = element("p");
      html_tag = new HtmlTag(false);
      t1 = space();
      t2 = text(t2_value);
      attr(div, "class", "form-fields");
      html_tag.a = t1;
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      html_tag.m(raw_value, p2);
      append(p2, t1);
      append(p2, t2);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.identifier;
      if (dirty & /*$context*/
      1) textinput_changes.placeholder = /*$context*/
      ctx2[0].item.identifier;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
      if ((!current || dirty & /*$context*/
      1) && raw_value !== (raw_value = /*localize*/
      ctx2[2]("DND5E.ClassIdentifierHint", {
        identifier: (
          /*$context*/
          ctx2[0].item.identifier
        )
      }) + "")) html_tag.p(raw_value);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p2);
      }
      destroy_component(textinput);
    }
  };
}
function create_each_block$f(ctx) {
  let option;
  let t_value = (
    /*type*/
    ctx[4] + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*type*/
      ctx[4];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && t_value !== (t_value = /*type*/
      ctx2[4] + "")) set_data(t2, t_value);
      if (dirty & /*$context*/
      1 && option_value_value !== (option_value_value = /*type*/
      ctx2[4])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot_3$e(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[0].config.hitDieTypes
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$f(get_each_context$f(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[0].config.hitDieTypes
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$f(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$f(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_2$e(ctx) {
  let div;
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.hitDice",
      value: (
        /*$context*/
        ctx[0].system.hitDice
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_3$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.hitDice;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      129) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(select);
    }
  };
}
function create_default_slot_1$h(ctx) {
  let div;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.hitDiceUsed",
      value: (
        /*$context*/
        ctx[0].system.hitDiceUsed
      ),
      placeholder: "0",
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.hitDiceUsed;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_default_slot$F(ctx) {
  let div;
  let textinput;
  let t0;
  let p2;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.wealth
      ),
      field: "system.wealth",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[2]("DND5E.StartingEquipment.Wealth.Hint")}`;
      attr(div, "class", "form-fields");
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.wealth;
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p2);
      }
      destroy_component(textinput);
    }
  };
}
function create_fragment$1u(ctx) {
  let itemformgroup0;
  let t0;
  let itemformgroup1;
  let t1;
  let itemformgroup2;
  let t2;
  let h3;
  let t4;
  let itemspellcasting;
  let t5;
  let itemstartingequipment;
  let t6;
  let itemformgroup3;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Identifier")
      ),
      field: "system.identifier",
      $$slots: {
        default: [
          create_default_slot_4$c,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.HitDice")
      ),
      field: "system.hitDice",
      $$slots: {
        default: [
          create_default_slot_2$e,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup2 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.HitDiceUsed")
      ),
      field: "system.hitDiceUsed",
      $$slots: {
        default: [
          create_default_slot_1$h,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemspellcasting = new ItemSpellcasting({});
  itemstartingequipment = new ItemStartingEquipment({});
  itemformgroup3 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.StartingEquipment.Wealth.Label")
      ),
      field: "system.wealth",
      $$slots: {
        default: [
          create_default_slot$F,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t0 = space();
      create_component(itemformgroup1.$$.fragment);
      t1 = space();
      create_component(itemformgroup2.$$.fragment);
      t2 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[2]("DND5E.Spellcasting")}`;
      t4 = space();
      create_component(itemspellcasting.$$.fragment);
      t5 = space();
      create_component(itemstartingequipment.$$.fragment);
      t6 = space();
      create_component(itemformgroup3.$$.fragment);
      attr(h3, "class", "form-header");
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t2, anchor);
      insert(target, h3, anchor);
      insert(target, t4, anchor);
      mount_component(itemspellcasting, target, anchor);
      insert(target, t5, anchor);
      mount_component(itemstartingequipment, target, anchor);
      insert(target, t6, anchor);
      mount_component(itemformgroup3, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      137) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      const itemformgroup3_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup3.$set(itemformgroup3_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(itemspellcasting.$$.fragment, local);
      transition_in(itemstartingequipment.$$.fragment, local);
      transition_in(itemformgroup3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(itemspellcasting.$$.fragment, local);
      transition_out(itemstartingequipment.$$.fragment, local);
      transition_out(itemformgroup3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(h3);
        detach(t4);
        detach(t5);
        detach(t6);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemformgroup2, detaching);
      destroy_component(itemspellcasting, detaching);
      destroy_component(itemstartingequipment, detaching);
      destroy_component(itemformgroup3, detaching);
    }
  };
}
function instance$1t($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemClassDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1t, create_fragment$1u, safe_not_equal, {});
  }
}
function create_if_block_15(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.activation.cost
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.ConsumeQuanity")
      ),
      field: "system.activation.cost",
      placeholder: "",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.activation.cost;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_default_slot_23(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.abilityActivationTypes
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.abilityActivationTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_22(ctx) {
  let div;
  let t2;
  let select;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].system.activation.type && !/*$context*/
    ctx[0].isCostlessAction && create_if_block_15(ctx)
  );
  select = new Select({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-activation-type"
      ),
      value: (
        /*$context*/
        ctx[0].system.activation.type?.toString() ?? ""
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.ItemActivationType")
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.activation.type",
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].system.activation.type && !/*$context*/
        ctx2[0].isCostlessAction
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (dirty & /*$context*/
      1) select_changes.id = /*$context*/
      ctx2[0].appId + "-system-activation-type";
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.activation.type?.toString() ?? "";
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      destroy_component(select);
    }
  };
}
function create_if_block$F(ctx) {
  let itemformgroup0;
  let t0;
  let t1;
  let itemformgroup1;
  let t2;
  let t3;
  let itemformgroup2;
  let t4;
  let itemformgroup3;
  let t5;
  let itemformgroup4;
  let t6;
  let t7;
  let itemformgroup5;
  let t8;
  let itemformgroup6;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemActivationCondition")
      ),
      field: "system.activation.condition",
      $$slots: {
        default: [
          create_default_slot_21,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$context*/
    ctx[0].isCrewed && create_if_block_14(ctx)
  );
  itemformgroup1 = new ItemFormGroup({
    props: {
      cssClass: "input-select-select",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Target")
      ),
      field: "system.target.type",
      $$slots: {
        default: [
          create_default_slot_16$1,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$context*/
    ctx[0].isLine && create_if_block_11(ctx)
  );
  itemformgroup2 = new ItemFormGroup({
    props: {
      cssClass: "input-select",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Range")
      ),
      field: "system.range.units",
      $$slots: {
        default: [
          create_default_slot_13$4,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup3 = new ItemFormGroup({
    props: {
      cssClass: "input-select",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Duration")
      ),
      field: "system.duration.units",
      $$slots: {
        default: [
          create_default_slot_11$5,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup4 = new ItemFormGroup({
    props: {
      cssClass: "uses-per",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.LimitedUses")
      ),
      field: "system.uses.per",
      $$slots: {
        default: [
          create_default_slot_9$6,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block2 = (
    /*$context*/
    ctx[0].isFormulaRecharge && create_if_block_7$5(ctx)
  );
  itemformgroup5 = new ItemFormGroup({
    props: {
      cssClass: "consumption",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ConsumeTitle")
      ),
      field: "system.consume.type",
      $$slots: {
        default: [
          create_default_slot_5$a,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup6 = new ItemFormGroup({
    props: {
      cssClass: "stacked",
      $$slots: { default: [create_default_slot$E] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      create_component(itemformgroup1.$$.fragment);
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      create_component(itemformgroup2.$$.fragment);
      t4 = space();
      create_component(itemformgroup3.$$.fragment);
      t5 = space();
      create_component(itemformgroup4.$$.fragment);
      t6 = space();
      if (if_block2) if_block2.c();
      t7 = space();
      create_component(itemformgroup5.$$.fragment);
      t8 = space();
      create_component(itemformgroup6.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t3, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t4, anchor);
      mount_component(itemformgroup3, target, anchor);
      insert(target, t5, anchor);
      mount_component(itemformgroup4, target, anchor);
      insert(target, t6, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t7, anchor);
      mount_component(itemformgroup5, target, anchor);
      insert(target, t8, anchor);
      mount_component(itemformgroup6, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      if (
        /*$context*/
        ctx2[0].isCrewed
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      if (
        /*$context*/
        ctx2[0].isLine
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_11(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      const itemformgroup3_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup3.$set(itemformgroup3_changes);
      const itemformgroup4_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup4.$set(itemformgroup4_changes);
      if (
        /*$context*/
        ctx2[0].isFormulaRecharge
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_7$5(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t7.parentNode, t7);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const itemformgroup5_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup5.$set(itemformgroup5_changes);
      const itemformgroup6_changes = {};
      if (dirty & /*$$scope, $context*/
      17) {
        itemformgroup6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup6.$set(itemformgroup6_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(itemformgroup3.$$.fragment, local);
      transition_in(itemformgroup4.$$.fragment, local);
      transition_in(if_block2);
      transition_in(itemformgroup5.$$.fragment, local);
      transition_in(itemformgroup6.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(itemformgroup3.$$.fragment, local);
      transition_out(itemformgroup4.$$.fragment, local);
      transition_out(if_block2);
      transition_out(itemformgroup5.$$.fragment, local);
      transition_out(itemformgroup6.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
      }
      destroy_component(itemformgroup0, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemformgroup1, detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(itemformgroup2, detaching);
      destroy_component(itemformgroup3, detaching);
      destroy_component(itemformgroup4, detaching);
      if (if_block2) if_block2.d(detaching);
      destroy_component(itemformgroup5, detaching);
      destroy_component(itemformgroup6, detaching);
    }
  };
}
function create_default_slot_21(ctx) {
  let div;
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.activation.condition
      ),
      field: "system.activation.condition",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.activation.condition;
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput);
    }
  };
}
function create_if_block_14(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Cover")
      ),
      field: "system.cover",
      $$slots: {
        default: [
          create_default_slot_19,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_20(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.cover
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.cover;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_19(ctx) {
  let div;
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.cover?.toString()
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.ItemActivationType")
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.cover",
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_20] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.cover?.toString();
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(select);
    }
  };
}
function create_if_block_13(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-target-value"
      ),
      value: (
        /*$context*/
        ctx[0].system.target.value
      ),
      placeholder: "",
      field: "system.target.value",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*$context*/
      1) numberinput_changes.id = /*$context*/
      ctx2[0].appId + "-system-target-value";
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.target.value;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-target-units"
      ),
      value: (
        /*$context*/
        ctx[0].system.target.units
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.TargetUnits")
      ),
      field: "system.target.units",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      1) select_changes.id = /*$context*/
      ctx2[0].appId + "-system-target-units";
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.target.units;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_18(ctx) {
  let option;
  let t2;
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.movementUnits
      )
    }
  });
  return {
    c() {
      option = element("option");
      t2 = space();
      create_component(selectoptions.$$.fragment);
      option.__value = "";
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      insert(target, t2, anchor);
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.movementUnits;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option);
        detach(t2);
      }
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_17(ctx) {
  let option;
  let t1;
  let optgroup0;
  let selectoptions0;
  let t2;
  let optgroup1;
  let selectoptions1;
  let current;
  selectoptions0 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.individualTargetTypes
      )
    }
  });
  selectoptions1 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.areaTargetTypes
      ),
      labelProp: "label"
    }
  });
  return {
    c() {
      option = element("option");
      option.textContent = `${/*localize*/
      ctx[2]("DND5E.None")}`;
      t1 = space();
      optgroup0 = element("optgroup");
      create_component(selectoptions0.$$.fragment);
      t2 = space();
      optgroup1 = element("optgroup");
      create_component(selectoptions1.$$.fragment);
      option.__value = "";
      set_input_value(option, option.__value);
      attr(
        optgroup0,
        "label",
        /*localize*/
        ctx[2]("DND5E.TargetTypeIndividual")
      );
      attr(
        optgroup1,
        "label",
        /*localize*/
        ctx[2]("DND5E.TargetTypeArea")
      );
    },
    m(target, anchor) {
      insert(target, option, anchor);
      insert(target, t1, anchor);
      insert(target, optgroup0, anchor);
      mount_component(selectoptions0, optgroup0, null);
      insert(target, t2, anchor);
      insert(target, optgroup1, anchor);
      mount_component(selectoptions1, optgroup1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions0_changes = {};
      if (dirty & /*$context*/
      1) selectoptions0_changes.data = /*$context*/
      ctx2[0].config.individualTargetTypes;
      selectoptions0.$set(selectoptions0_changes);
      const selectoptions1_changes = {};
      if (dirty & /*$context*/
      1) selectoptions1_changes.data = /*$context*/
      ctx2[0].config.areaTargetTypes;
      selectoptions1.$set(selectoptions1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions0.$$.fragment, local);
      transition_in(selectoptions1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions0.$$.fragment, local);
      transition_out(selectoptions1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option);
        detach(t1);
        detach(optgroup0);
        detach(t2);
        detach(optgroup1);
      }
      destroy_component(selectoptions0);
      destroy_component(selectoptions1);
    }
  };
}
function create_default_slot_16$1(ctx) {
  let div;
  let t0;
  let t1;
  let select;
  let current;
  let if_block0 = (
    /*$context*/
    ctx[0].system.hasScalarTarget && create_if_block_13(ctx)
  );
  let if_block1 = (
    /*$context*/
    ctx[0].system.hasAreaTarget && create_if_block_12(ctx)
  );
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.target.type
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.TargetType")
      ),
      field: "system.target.type",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if (if_block1) if_block1.m(div, null);
      append(div, t1);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].system.hasScalarTarget
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].system.hasAreaTarget
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.target.type;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      destroy_component(select);
    }
  };
}
function create_if_block_11(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      cssClass: "input-select-select",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.TargetWidth")
      ),
      field: "system.target.width",
      $$slots: {
        default: [
          create_default_slot_15$1,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_15$1(ctx) {
  let div;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.target.width
      ),
      placeholder: "",
      field: "system.target.width",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.target.width;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_if_block_10$1(ctx) {
  let numberinput0;
  let t0;
  let span;
  let t2;
  let numberinput1;
  let current;
  numberinput0 = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-target-width"
      ),
      value: (
        /*$context*/
        ctx[0].system.range.value
      ),
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.Normal")
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.RangeNormal")
      ),
      field: "system.range.value",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  numberinput1 = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-range-long"
      ),
      value: (
        /*$context*/
        ctx[0].system.range.long
      ),
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.Long")
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.RangeLong")
      ),
      field: "system.range.long",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(numberinput0.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "/";
      t2 = space();
      create_component(numberinput1.$$.fragment);
      attr(span, "class", "sep");
    },
    m(target, anchor) {
      mount_component(numberinput0, target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      insert(target, t2, anchor);
      mount_component(numberinput1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput0_changes = {};
      if (dirty & /*$context*/
      1) numberinput0_changes.id = /*$context*/
      ctx2[0].appId + "-system-target-width";
      if (dirty & /*$context*/
      1) numberinput0_changes.value = /*$context*/
      ctx2[0].system.range.value;
      if (dirty & /*$context*/
      1) numberinput0_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput0_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput0.$set(numberinput0_changes);
      const numberinput1_changes = {};
      if (dirty & /*$context*/
      1) numberinput1_changes.id = /*$context*/
      ctx2[0].appId + "-system-range-long";
      if (dirty & /*$context*/
      1) numberinput1_changes.value = /*$context*/
      ctx2[0].system.range.long;
      if (dirty & /*$context*/
      1) numberinput1_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput1_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput1.$set(numberinput1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
        detach(t2);
      }
      destroy_component(numberinput0, detaching);
      destroy_component(numberinput1, detaching);
    }
  };
}
function create_default_slot_14$3(ctx) {
  let option;
  let t1;
  let optgroup;
  let selectoptions0;
  let t2;
  let selectoptions1;
  let current;
  selectoptions0 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.movementUnits
      )
    }
  });
  selectoptions1 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.rangeTypes
      )
    }
  });
  return {
    c() {
      option = element("option");
      option.textContent = `${/*localize*/
      ctx[2]("DND5E.None")}`;
      t1 = space();
      optgroup = element("optgroup");
      create_component(selectoptions0.$$.fragment);
      t2 = space();
      create_component(selectoptions1.$$.fragment);
      option.__value = "";
      set_input_value(option, option.__value);
      attr(
        optgroup,
        "label",
        /*localize*/
        ctx[2]("DND5E.RangeDistance")
      );
    },
    m(target, anchor) {
      insert(target, option, anchor);
      insert(target, t1, anchor);
      insert(target, optgroup, anchor);
      mount_component(selectoptions0, optgroup, null);
      insert(target, t2, anchor);
      mount_component(selectoptions1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions0_changes = {};
      if (dirty & /*$context*/
      1) selectoptions0_changes.data = /*$context*/
      ctx2[0].config.movementUnits;
      selectoptions0.$set(selectoptions0_changes);
      const selectoptions1_changes = {};
      if (dirty & /*$context*/
      1) selectoptions1_changes.data = /*$context*/
      ctx2[0].config.rangeTypes;
      selectoptions1.$set(selectoptions1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions0.$$.fragment, local);
      transition_in(selectoptions1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions0.$$.fragment, local);
      transition_out(selectoptions1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option);
        detach(t1);
        detach(optgroup);
        detach(t2);
      }
      destroy_component(selectoptions0);
      destroy_component(selectoptions1, detaching);
    }
  };
}
function create_default_slot_13$4(ctx) {
  let div;
  let t2;
  let select;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].system.hasScalarRange && create_if_block_10$1(ctx)
  );
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.range.units
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.RangeUnits")
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.range.units",
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_14$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].system.hasScalarRange
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_10$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.range.units;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      destroy_component(select);
    }
  };
}
function create_if_block_9$3(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-source-duration-value"
      ),
      value: (
        /*$context*/
        ctx[0].source.duration.value
      ),
      placeholder: "",
      title: (
        /*localize*/
        ctx[2]("DND5E.DurationValue")
      ),
      field: "system.duration.value",
      document: (
        /*$context*/
        ctx[0].item
      ),
      dataset: { formulaEditor: true },
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.id = /*$context*/
      ctx2[0].appId + "-source-duration-value";
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].source.duration.value;
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_12$4(ctx) {
  let option;
  let t1;
  let optgroup0;
  let selectoptions0;
  let t2;
  let optgroup1;
  let selectoptions1;
  let t3;
  let selectoptions2;
  let current;
  selectoptions0 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.scalarTimePeriods
      )
    }
  });
  selectoptions1 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.permanentTimePeriods
      )
    }
  });
  selectoptions2 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.specialTimePeriods
      )
    }
  });
  return {
    c() {
      option = element("option");
      option.textContent = `${/*localize*/
      ctx[2]("DND5E.None")}`;
      t1 = space();
      optgroup0 = element("optgroup");
      create_component(selectoptions0.$$.fragment);
      t2 = space();
      optgroup1 = element("optgroup");
      create_component(selectoptions1.$$.fragment);
      t3 = space();
      create_component(selectoptions2.$$.fragment);
      option.__value = "";
      set_input_value(option, option.__value);
      attr(
        optgroup0,
        "label",
        /*localize*/
        ctx[2]("DND5E.DurationTime")
      );
      attr(
        optgroup1,
        "label",
        /*localize*/
        ctx[2]("DND5E.DurationPermanent")
      );
    },
    m(target, anchor) {
      insert(target, option, anchor);
      insert(target, t1, anchor);
      insert(target, optgroup0, anchor);
      mount_component(selectoptions0, optgroup0, null);
      insert(target, t2, anchor);
      insert(target, optgroup1, anchor);
      mount_component(selectoptions1, optgroup1, null);
      insert(target, t3, anchor);
      mount_component(selectoptions2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions0_changes = {};
      if (dirty & /*$context*/
      1) selectoptions0_changes.data = /*$context*/
      ctx2[0].config.scalarTimePeriods;
      selectoptions0.$set(selectoptions0_changes);
      const selectoptions1_changes = {};
      if (dirty & /*$context*/
      1) selectoptions1_changes.data = /*$context*/
      ctx2[0].config.permanentTimePeriods;
      selectoptions1.$set(selectoptions1_changes);
      const selectoptions2_changes = {};
      if (dirty & /*$context*/
      1) selectoptions2_changes.data = /*$context*/
      ctx2[0].config.specialTimePeriods;
      selectoptions2.$set(selectoptions2_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions0.$$.fragment, local);
      transition_in(selectoptions1.$$.fragment, local);
      transition_in(selectoptions2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions0.$$.fragment, local);
      transition_out(selectoptions1.$$.fragment, local);
      transition_out(selectoptions2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option);
        detach(t1);
        detach(optgroup0);
        detach(t2);
        detach(optgroup1);
        detach(t3);
      }
      destroy_component(selectoptions0);
      destroy_component(selectoptions1);
      destroy_component(selectoptions2, detaching);
    }
  };
}
function create_default_slot_11$5(ctx) {
  let div;
  let t2;
  let select;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].system.hasScalarDuration && create_if_block_9$3(ctx)
  );
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.duration.units
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.DurationType")
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.duration.units",
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_12$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].system.hasScalarDuration
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_9$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.duration.units;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      destroy_component(select);
    }
  };
}
function create_if_block_8$3(ctx) {
  let numberinput;
  let t0;
  let span0;
  let t2;
  let textinput;
  let t3;
  let span1;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-uses-value"
      ),
      value: (
        /*$context*/
        ctx[0].system.uses.value
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.UsesAvailable")
      ),
      field: "system.uses.value",
      document: (
        /*$context*/
        ctx[0].item
      )
    }
  });
  textinput = new TextInput$1({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-uses-max"
      ),
      value: (
        /*$context*/
        ctx[0].source.uses.max
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.UsesMax")
      ),
      field: "system.uses.max",
      document: (
        /*$context*/
        ctx[0].item
      ),
      dataset: { formulaEditor: true },
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
      t0 = space();
      span0 = element("span");
      span0.textContent = `${/*localize*/
      ctx[2]("DND5E.of")}`;
      t2 = space();
      create_component(textinput.$$.fragment);
      t3 = space();
      span1 = element("span");
      span1.textContent = `${/*localize*/
      ctx[2]("DND5E.per")}`;
      attr(span0, "class", "sep");
      attr(span1, "class", "sep");
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      insert(target, t0, anchor);
      insert(target, span0, anchor);
      insert(target, t2, anchor);
      mount_component(textinput, target, anchor);
      insert(target, t3, anchor);
      insert(target, span1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*$context*/
      1) numberinput_changes.id = /*$context*/
      ctx2[0].appId + "-system-uses-value";
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.uses.value;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      numberinput.$set(numberinput_changes);
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.id = /*$context*/
      ctx2[0].appId + "-system-uses-max";
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].source.uses.max;
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span0);
        detach(t2);
        detach(t3);
        detach(span1);
      }
      destroy_component(numberinput, detaching);
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_10$6(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.limitedUsePeriods
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.None")
      ),
      labelProp: "label"
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.limitedUsePeriods;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_9$6(ctx) {
  let div;
  let t2;
  let select;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].system.uses.per && create_if_block_8$3(ctx)
  );
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.uses.per
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.UsesPeriod")
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.uses.per",
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_10$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].system.uses.per
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_8$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.uses.per;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      destroy_component(select);
    }
  };
}
function create_if_block_7$5(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.RecoveryFormula")
      ),
      field: "system.uses.recovery",
      $$slots: {
        default: [
          create_default_slot_8$7,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_8$7(ctx) {
  let div;
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.uses.recovery
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.uses.recovery",
      dataset: { formulaEditor: true },
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.uses.recovery;
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput);
    }
  };
}
function create_if_block_5$7(ctx) {
  let numberinput;
  let t2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-consume-amount"
      ),
      value: (
        /*$context*/
        ctx[0].system.consume.amount
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.ConsumeAmount")
      ),
      field: "system.consume.amount",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.QuantityAbbr")
      ),
      cssClass: "qty-flex-basis"
    }
  });
  const if_block_creators = [create_if_block_6$5, create_else_block$p];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].abilityConsumptionHint
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(numberinput.$$.fragment);
      t2 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      insert(target, t2, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*$context*/
      1) numberinput_changes.id = /*$context*/
      ctx2[0].appId + "-system-consume-amount";
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.consume.amount;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(numberinput, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$p(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-consume-target"
      ),
      value: (
        /*$context*/
        ctx[0].system.consume.target
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.ConsumeTarget")
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.consume.target",
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_7$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      1) select_changes.id = /*$context*/
      ctx2[0].appId + "-system-consume-target";
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.consume.target;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_6$5(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.consume.target",
      value: (
        /*$context*/
        ctx[0].system.consume.target
      ),
      placeholder: (
        /*localize*/
        ctx[2](
          /*$context*/
          ctx[0].abilityConsumptionHint
        )
      )
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.consume.target;
      if (dirty & /*$context*/
      1) textinput_changes.placeholder = /*localize*/
      ctx2[2](
        /*$context*/
        ctx2[0].abilityConsumptionHint
      );
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_7$7(ctx) {
  let option;
  let t2;
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].abilityConsumptionTargets
      )
    }
  });
  return {
    c() {
      option = element("option");
      t2 = space();
      create_component(selectoptions.$$.fragment);
      option.__value = "";
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      insert(target, t2, anchor);
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].abilityConsumptionTargets;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option);
        detach(t2);
      }
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_6$8(ctx) {
  let option;
  let t1;
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.abilityConsumptionTypes
      )
    }
  });
  return {
    c() {
      option = element("option");
      option.textContent = `${/*localize*/
      ctx[2]("DND5E.None")}`;
      t1 = space();
      create_component(selectoptions.$$.fragment);
      option.__value = "";
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      insert(target, t1, anchor);
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.abilityConsumptionTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option);
        detach(t1);
      }
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_5$a(ctx) {
  let div;
  let t2;
  let select;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].system.consume.type && create_if_block_5$7(ctx)
  );
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.consume.type
      ),
      title: (
        /*localize*/
        ctx[2]("DND5E.ConsumeType")
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.consume.type",
      disabled: !/*$context*/
      ctx[0].editable,
      class: "flex-basis-full",
      $$slots: { default: [create_default_slot_6$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block) if_block.c();
      t2 = space();
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields flex-wrap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append(div, t2);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].system.consume.type
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.consume.type;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block) if_block.d();
      destroy_component(select);
    }
  };
}
function create_if_block_4$8(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox({
    props: {
      labelCssClass: "checkbox",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.uses.autoDestroy",
      checked: (
        /*$context*/
        ctx[0].system.uses.autoDestroy
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      title: (
        /*localize*/
        ctx[2]("DND5E.ItemDestroyEmptyTooltip")
      ),
      $$slots: { default: [create_default_slot_4$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.uses.autoDestroy;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope*/
      16) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_default_slot_4$b(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("DND5E.ItemDestroyEmpty") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_3$d(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox({
    props: {
      labelCssClass: "checkbox",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.target.prompt",
      checked: (
        /*$context*/
        ctx[0].system.target.prompt
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      title: (
        /*localize*/
        ctx[2]("DND5E.TemplatePromptTooltip")
      ),
      $$slots: { default: [create_default_slot_3$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.target.prompt;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope*/
      16) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_default_slot_3$d(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("DND5E.TemplatePrompt") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_2$j(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox({
    props: {
      labelCssClass: "checkbox",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.uses.prompt",
      checked: (
        /*$context*/
        ctx[0].system.uses.prompt
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      title: (
        /*localize*/
        ctx[2]("DND5E.LimitedUsesPromptTooltip")
      ),
      $$slots: { default: [create_default_slot_2$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.uses.prompt;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope*/
      16) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_default_slot_2$d(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("DND5E.LimitedUsesPrompt") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$p(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox({
    props: {
      labelCssClass: "checkbox",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.consume.scale",
      checked: (
        /*$context*/
        ctx[0].system.consume.scale
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      title: (
        /*localize*/
        ctx[2]("DND5E.ConsumeScalingTooltip")
      ),
      $$slots: { default: [create_default_slot_1$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.consume.scale;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope*/
      16) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_default_slot_1$g(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("DND5E.ConsumeScaling") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$E(ctx) {
  let t0;
  let t1;
  let t2;
  let if_block3_anchor;
  let current;
  let if_block0 = (
    /*$context*/
    ctx[0].item.type === "consumable" && create_if_block_4$8(ctx)
  );
  let if_block1 = (
    /*$context*/
    ctx[0].item.hasAreaTarget && create_if_block_3$d(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[0].system.uses.per && create_if_block_2$j(ctx)
  );
  let if_block3 = (
    /*$context*/
    ctx[0].item.type === "spell" && /*$context*/
    ctx[0].system.consume.type && create_if_block_1$p(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      if (if_block3) if_block3.c();
      if_block3_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].item.type === "consumable"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].item.hasAreaTarget
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$d(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].system.uses.per
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$j(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].item.type === "spell" && /*$context*/
        ctx2[0].system.consume.type
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$p(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block3_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
    }
  };
}
function create_fragment$1t(ctx) {
  let itemformgroup;
  let t2;
  let if_block_anchor;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemActivationCost")
      ),
      cssClass: "input-select",
      field: "system.activation.cost",
      $$slots: {
        default: [
          create_default_slot_22,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[0].system.activation.type && create_if_block$F(ctx)
  );
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      25) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
      if (
        /*$context*/
        ctx2[0].system.activation.type
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$F(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemformgroup, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance$1s($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemActivation extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1s, create_fragment$1t, safe_not_equal, {});
  }
}
function get_each_context$e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function get_each_context_1$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i2][0];
  child_ctx[25] = list[i2][1];
  child_ctx[26] = list;
  child_ctx[27] = i2;
  return child_ctx;
}
function create_default_slot_16(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.itemActionTypes
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.itemActionTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_15(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      value: (
        /*$context*/
        ctx[1].system.actionType
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.actionType",
      disabled: !/*$context*/
      ctx[1].editable,
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      1048576) select_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) select_changes.value = /*$context*/
      ctx2[1].system.actionType;
      if (dirty & /*$context*/
      2) select_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      268435458) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block$E(ctx) {
  let itemformgroup0;
  let t0;
  let t1;
  let h4;
  let t2;
  let t3_value = (
    /*localize*/
    ctx[6]("DND5E.Formula") + ""
  );
  let t3;
  let t4;
  let button;
  let i2;
  let button_disabled_value;
  let button_tabindex_value;
  let t5;
  let t6;
  let t7;
  let itemformgroup1;
  let t8;
  let itemformgroup2;
  let t9;
  let t10;
  let t11;
  let itemformgroup3;
  let current;
  let mounted;
  let dispose;
  itemformgroup0 = new ItemFormGroup({
    props: {
      cssClass: "select",
      labelText: (
        /*localize*/
        ctx[6]("DND5E.AbilityModifier")
      ),
      field: "system.ability",
      $$slots: {
        default: [
          create_default_slot_13$3,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$context*/
    ctx[1].system.hasAttack && create_if_block_9$2(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].isHealing
    ) return create_if_block_8$2;
    return create_else_block_1$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  let if_block2 = (
    /*damageParts*/
    ctx[2]?.length && create_if_block_7$4(ctx)
  );
  let if_block3 = (
    /*$context*/
    ctx[1].system.damage.parts.length && create_if_block_6$4(ctx)
  );
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[6]("DND5E.OtherFormula")
      ),
      field: "system.formula",
      $$slots: {
        default: [
          create_default_slot_7$6,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup2 = new ItemFormGroup({
    props: {
      cssClass: "input-select",
      labelText: (
        /*localize*/
        ctx[6]("DND5E.ActionSave")
      ),
      field: "system.save.ability",
      $$slots: {
        default: [
          create_default_slot_4$a,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block4 = (
    /*$context*/
    ctx[1].system.isEnchantment && create_if_block_2$i(ctx)
  );
  let if_block5 = (
    /*$context*/
    ctx[1].system.actionType === "summ" && create_if_block_1$o(ctx)
  );
  itemformgroup3 = new ItemFormGroup({
    props: {
      cssClass: "stacked",
      labelText: (
        /*localize*/
        ctx[6]("DND5E.ChatFlavor")
      ),
      field: "system.chatFlavor",
      $$slots: {
        default: [
          create_default_slot$D,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      h4 = element("h4");
      if_block1.c();
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      button = element("button");
      i2 = element("i");
      t5 = space();
      if (if_block2) if_block2.c();
      t6 = space();
      if (if_block3) if_block3.c();
      t7 = space();
      create_component(itemformgroup1.$$.fragment);
      t8 = space();
      create_component(itemformgroup2.$$.fragment);
      t9 = space();
      if (if_block4) if_block4.c();
      t10 = space();
      if (if_block5) if_block5.c();
      t11 = space();
      create_component(itemformgroup3.$$.fragment);
      attr(i2, "class", "fas fa-plus");
      attr(button, "type", "button");
      attr(button, "class", "damage-formula-control add-damage");
      button.disabled = button_disabled_value = !/*$context*/
      ctx[1].editable || /*damageIsEnchanted*/
      ctx[0];
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1);
      attr(
        button,
        "data-tooltip",
        /*enchantedTooltip*/
        ctx[3]
      );
      attr(h4, "class", "damage-header");
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, h4, anchor);
      if_block1.m(h4, null);
      append(h4, t2);
      append(h4, t3);
      append(h4, t4);
      append(h4, button);
      append(button, i2);
      insert(target, t5, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t7, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t8, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t9, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t10, anchor);
      if (if_block5) if_block5.m(target, anchor);
      insert(target, t11, anchor);
      mount_component(itemformgroup3, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      269484034) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      if (
        /*$context*/
        ctx2[1].system.hasAttack
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_9$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(h4, t2);
        }
      }
      if (!current || dirty & /*$context, damageIsEnchanted*/
      3 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx2[1].editable || /*damageIsEnchanted*/
      ctx2[0])) {
        button.disabled = button_disabled_value;
      }
      if (!current || dirty & /*$settingStore*/
      16 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[4].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*enchantedTooltip*/
      8) {
        attr(
          button,
          "data-tooltip",
          /*enchantedTooltip*/
          ctx2[3]
        );
      }
      if (
        /*damageParts*/
        ctx2[2]?.length
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*damageParts*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_7$4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t6.parentNode, t6);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[1].system.damage.parts.length
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_6$4(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t7.parentNode, t7);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      269484034) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      269484034) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      if (
        /*$context*/
        ctx2[1].system.isEnchantment
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2$i(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t10.parentNode, t10);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[1].system.actionType === "summ"
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1$o(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t11.parentNode, t11);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      const itemformgroup3_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      269484034) {
        itemformgroup3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup3.$set(itemformgroup3_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(itemformgroup3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(itemformgroup3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(h4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(t9);
        detach(t10);
        detach(t11);
      }
      destroy_component(itemformgroup0, detaching);
      if (if_block0) if_block0.d(detaching);
      if_block1.d();
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemformgroup2, detaching);
      if (if_block4) if_block4.d(detaching);
      if (if_block5) if_block5.d(detaching);
      destroy_component(itemformgroup3, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_14$2(ctx) {
  let option0;
  let t1;
  let option1;
  let t3;
  let optgroup;
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.abilities
      ),
      labelProp: "label"
    }
  });
  return {
    c() {
      option0 = element("option");
      option0.textContent = `${/*localize*/
      ctx[6]("DND5E.Default")}`;
      t1 = space();
      option1 = element("option");
      option1.textContent = `${/*localize*/
      ctx[6]("DND5E.None")}`;
      t3 = space();
      optgroup = element("optgroup");
      create_component(selectoptions.$$.fragment);
      option0.__value = "";
      set_input_value(option0, option0.__value);
      option1.__value = "none";
      set_input_value(option1, option1.__value);
      attr(
        optgroup,
        "label",
        /*localize*/
        ctx[6]("DND5E.Ability")
      );
    },
    m(target, anchor) {
      insert(target, option0, anchor);
      insert(target, t1, anchor);
      insert(target, option1, anchor);
      insert(target, t3, anchor);
      insert(target, optgroup, anchor);
      mount_component(selectoptions, optgroup, null);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.abilities;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option0);
        detach(t1);
        detach(option1);
        detach(t3);
        detach(optgroup);
      }
      destroy_component(selectoptions);
    }
  };
}
function create_default_slot_13$3(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      value: (
        /*$context*/
        ctx[1].system.ability
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.ability",
      disabled: !/*$context*/
      ctx[1].editable,
      $$slots: { default: [create_default_slot_14$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      1048576) select_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) select_changes.value = /*$context*/
      ctx2[1].system.ability;
      if (dirty & /*$context*/
      2) select_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      268435458) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_9$2(ctx) {
  let itemformgroup0;
  let t0;
  let itemformgroup1;
  let t1;
  let itemformgroup2;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[6]("DND5E.ItemAttackBonus")
      ),
      field: "system.attack.bonus",
      $$slots: {
        default: [
          create_default_slot_11$4,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[6]("DND5E.ItemCritThreshold")
      ),
      field: "system.critical.threshold",
      $$slots: {
        default: [
          create_default_slot_10$5,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup2 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[6]("DND5E.ItemCritExtraDamage")
      ),
      field: "system.critical.damage",
      $$slots: {
        default: [
          create_default_slot_9$5,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t0 = space();
      create_component(itemformgroup1.$$.fragment);
      t1 = space();
      create_component(itemformgroup2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      269484034) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      269484034) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      269484034) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemformgroup2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemformgroup2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemformgroup2, detaching);
    }
  };
}
function create_default_slot_12$3(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.ItemAttackFlat") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_11$4(ctx) {
  let div;
  let textinput;
  let t2;
  let checkbox;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.attack.bonus",
      value: (
        /*$context*/
        ctx[1].system.attack.bonus
      ),
      dataset: { formulaEditor: true },
      disabled: !/*$context*/
      ctx[1].editable
    }
  });
  checkbox = new Checkbox({
    props: {
      id: (
        /*$context*/
        ctx[1].appId + "-system-attack-flat"
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.attack.flat",
      checked: (
        /*$context*/
        ctx[1].system.attack.flat
      ),
      labelCssClass: "checkbox",
      greenCheckboxWidthOverride: (
        /*localize*/
        ctx[6]("DND5E.ItemAttackFlat").length + 4 + "ch"
      ),
      title: (
        /*localize*/
        ctx[6]("DND5E.ItemAttackFlatHint")
      ),
      $$slots: { default: [create_default_slot_12$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t2 = space();
      create_component(checkbox.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      append(div, t2);
      mount_component(checkbox, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      1048576) textinput_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].system.attack.bonus;
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      textinput.$set(textinput_changes);
      const checkbox_changes = {};
      if (dirty & /*$context*/
      2) checkbox_changes.id = /*$context*/
      ctx2[1].appId + "-system-attack-flat";
      if (dirty & /*$context*/
      2) checkbox_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) checkbox_changes.checked = /*$context*/
      ctx2[1].system.attack.flat;
      if (dirty & /*$$scope*/
      268435456) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput);
      destroy_component(checkbox);
    }
  };
}
function create_default_slot_10$5(ctx) {
  let div;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      value: (
        /*$context*/
        ctx[1].system.critical.threshold
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.critical.threshold",
      placeholder: "20",
      max: "20",
      min: "1",
      step: "1",
      disabled: !/*$context*/
      ctx[1].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      1048576) numberinput_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) numberinput_changes.value = /*$context*/
      ctx2[1].system.critical.threshold;
      if (dirty & /*$context*/
      2) numberinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) numberinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_default_slot_9$5(ctx) {
  let div;
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.critical.damage",
      value: (
        /*$context*/
        ctx[1].system.critical.damage
      ),
      disabled: !/*$context*/
      ctx[1].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      1048576) textinput_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].system.critical.damage;
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput);
    }
  };
}
function create_else_block_1$4(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Damage") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_8$2(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Healing") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_7$4(ctx) {
  let ol;
  let current;
  let each_value_1 = ensure_array_like(
    /*damageParts*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      ol = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ol, "class", "damage-parts form-group");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, damageIsEnchanted, $settingStore, enchantedTooltip, deleteDamageFormula, damageParts, saveDamageFormulae, localize*/
      863) {
        each_value_1 = ensure_array_like(
          /*damageParts*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$4(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(ol, null);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$4(ctx) {
  let li;
  let input;
  let input_id_value;
  let input_disabled_value;
  let t0;
  let select;
  let option;
  let optgroup0;
  let selectoptions0;
  let optgroup1;
  let selectoptions1;
  let select_id_value;
  let select_disabled_value;
  let t2;
  let button;
  let i_1;
  let button_disabled_value;
  let button_tabindex_value;
  let t3;
  let current;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[11].call(
      input,
      /*each_value_1*/
      ctx[26],
      /*i*/
      ctx[27]
    );
  }
  selectoptions0 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.damageTypes
      ),
      labelProp: "label"
    }
  });
  selectoptions1 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.healingTypes
      ),
      labelProp: "label"
    }
  });
  function select_change_handler() {
    ctx[13].call(
      select,
      /*each_value_1*/
      ctx[26],
      /*i*/
      ctx[27]
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[15](
        /*i*/
        ctx[27]
      )
    );
  }
  return {
    c() {
      li = element("li");
      input = element("input");
      t0 = space();
      select = element("select");
      option = element("option");
      option.textContent = `${/*localize*/
      ctx[6]("DND5E.None")}`;
      optgroup0 = element("optgroup");
      create_component(selectoptions0.$$.fragment);
      optgroup1 = element("optgroup");
      create_component(selectoptions1.$$.fragment);
      t2 = space();
      button = element("button");
      i_1 = element("i");
      t3 = space();
      attr(input, "id", input_id_value = /*$context*/
      ctx[1].appId + "-system-damage-part-" + /*i*/
      ctx[27] + "-0");
      attr(input, "type", "text");
      attr(input, "data-formula-editor", "");
      input.disabled = input_disabled_value = !/*$context*/
      ctx[1].editable || /*damageIsEnchanted*/
      ctx[0];
      attr(input, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.DAMAGE_PART_FORMULA);
      attr(input, "data-tidy-field", `system.damage.part-${/*i*/
      ctx[27]}-0`);
      attr(
        input,
        "data-tooltip",
        /*enchantedTooltip*/
        ctx[3]
      );
      option.__value = "";
      set_input_value(option, option.__value);
      attr(
        optgroup0,
        "label",
        /*localize*/
        ctx[6]("DND5E.Damage")
      );
      attr(
        optgroup1,
        "label",
        /*localize*/
        ctx[6]("DND5E.Healing")
      );
      attr(select, "id", select_id_value = /*$context*/
      ctx[1].appId + "-system-damage-part-" + /*i*/
      ctx[27] + "-1");
      attr(select, "data-formula-editor", "");
      select.disabled = select_disabled_value = !/*$context*/
      ctx[1].editable || /*damageIsEnchanted*/
      ctx[0];
      attr(select, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.DAMAGE_PART_TYPE);
      attr(select, "data-tidy-field", `system.damage.part-${/*i*/
      ctx[27]}-1`);
      attr(
        select,
        "data-tooltip",
        /*enchantedTooltip*/
        ctx[3]
      );
      if (
        /*damageType*/
        ctx[25] === void 0
      ) add_render_callback(select_change_handler);
      attr(i_1, "class", "fas fa-minus");
      attr(button, "type", "button");
      attr(button, "class", "damage-formula-control delete-damage");
      button.disabled = button_disabled_value = !/*$context*/
      ctx[1].editable || /*damageIsEnchanted*/
      ctx[0];
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.DAMAGE_PART_DELETE_COMMAND);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1);
      attr(
        button,
        "data-tooltip",
        /*enchantedTooltip*/
        ctx[3]
      );
      attr(li, "class", "damage-part flexrow");
      attr(li, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.DAMAGE_PART_CONTAINER);
      attr(
        li,
        "data-tidy-damage-part-index",
        /*i*/
        ctx[27]
      );
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, input);
      set_input_value(
        input,
        /*formula*/
        ctx[24]
      );
      append(li, t0);
      append(li, select);
      append(select, option);
      append(select, optgroup0);
      mount_component(selectoptions0, optgroup0, null);
      append(select, optgroup1);
      mount_component(selectoptions1, optgroup1, null);
      select_option(
        select,
        /*damageType*/
        ctx[25],
        true
      );
      append(li, t2);
      append(li, button);
      append(button, i_1);
      append(li, t3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", input_input_handler),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[12]
          ),
          listen(select, "change", select_change_handler),
          listen(
            select,
            "change",
            /*change_handler_1*/
            ctx[14]
          ),
          listen(button, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*$context*/
      2 && input_id_value !== (input_id_value = /*$context*/
      ctx[1].appId + "-system-damage-part-" + /*i*/
      ctx[27] + "-0")) {
        attr(input, "id", input_id_value);
      }
      if (!current || dirty & /*$context, damageIsEnchanted*/
      3 && input_disabled_value !== (input_disabled_value = !/*$context*/
      ctx[1].editable || /*damageIsEnchanted*/
      ctx[0])) {
        input.disabled = input_disabled_value;
      }
      if (!current || dirty & /*enchantedTooltip*/
      8) {
        attr(
          input,
          "data-tooltip",
          /*enchantedTooltip*/
          ctx[3]
        );
      }
      if (dirty & /*damageParts*/
      4 && input.value !== /*formula*/
      ctx[24]) {
        set_input_value(
          input,
          /*formula*/
          ctx[24]
        );
      }
      const selectoptions0_changes = {};
      if (dirty & /*$context*/
      2) selectoptions0_changes.data = /*$context*/
      ctx[1].config.damageTypes;
      selectoptions0.$set(selectoptions0_changes);
      const selectoptions1_changes = {};
      if (dirty & /*$context*/
      2) selectoptions1_changes.data = /*$context*/
      ctx[1].config.healingTypes;
      selectoptions1.$set(selectoptions1_changes);
      if (!current || dirty & /*$context*/
      2 && select_id_value !== (select_id_value = /*$context*/
      ctx[1].appId + "-system-damage-part-" + /*i*/
      ctx[27] + "-1")) {
        attr(select, "id", select_id_value);
      }
      if (!current || dirty & /*$context, damageIsEnchanted*/
      3 && select_disabled_value !== (select_disabled_value = !/*$context*/
      ctx[1].editable || /*damageIsEnchanted*/
      ctx[0])) {
        select.disabled = select_disabled_value;
      }
      if (!current || dirty & /*enchantedTooltip*/
      8) {
        attr(
          select,
          "data-tooltip",
          /*enchantedTooltip*/
          ctx[3]
        );
      }
      if (dirty & /*damageParts*/
      4) {
        select_option(
          select,
          /*damageType*/
          ctx[25]
        );
      }
      if (!current || dirty & /*$context, damageIsEnchanted*/
      3 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx[1].editable || /*damageIsEnchanted*/
      ctx[0])) {
        button.disabled = button_disabled_value;
      }
      if (!current || dirty & /*$settingStore*/
      16 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*enchantedTooltip*/
      8) {
        attr(
          button,
          "data-tooltip",
          /*enchantedTooltip*/
          ctx[3]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions0.$$.fragment, local);
      transition_in(selectoptions1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions0.$$.fragment, local);
      transition_out(selectoptions1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(selectoptions0);
      destroy_component(selectoptions1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_6$4(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[6]("DND5E.VersatileDamage")
      ),
      field: "system.damage.versatile",
      $$slots: {
        default: [
          create_default_slot_8$6,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context, damageParts*/
      269484038) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_8$6(ctx) {
  let div;
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      value: (
        /*$context*/
        ctx[1].system.damage.versatile
      ),
      placeholder: (
        /*localize*/
        ctx[6]("DND5E.Formula")
      ),
      dataset: { formulaEditor: true },
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.damage.versatile",
      disabled: !/*$context*/
      ctx[1].editable,
      additionalDataToSave: {
        // TODO: Use more universal/generalized batch saving scheme that shares the same logic between here and the related properties.
        "system.damage.parts": (
          /*damageParts*/
          ctx[2]
        )
      }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      1048576) textinput_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].system.damage.versatile;
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*damageParts*/
      4) textinput_changes.additionalDataToSave = {
        // TODO: Use more universal/generalized batch saving scheme that shares the same logic between here and the related properties.
        "system.damage.parts": (
          /*damageParts*/
          ctx2[2]
        )
      };
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput);
    }
  };
}
function create_default_slot_7$6(ctx) {
  let div;
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.formula",
      value: (
        /*$context*/
        ctx[1].system.formula
      ),
      placeholder: (
        /*localize*/
        ctx[6]("DND5E.Formula")
      ),
      dataset: { formulaEditor: true },
      disabled: !/*$context*/
      ctx[1].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      1048576) textinput_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].system.formula;
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput);
    }
  };
}
function create_default_slot_6$7(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.abilities
      ),
      labelProp: "label",
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.abilities;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_5$9(ctx) {
  let option0;
  let t1;
  let selectoptions;
  let t2;
  let option1;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.abilities
      ),
      labelProp: "label"
    }
  });
  return {
    c() {
      option0 = element("option");
      option0.textContent = `${/*localize*/
      ctx[6]("DND5E.Spellcasting")}`;
      t1 = space();
      create_component(selectoptions.$$.fragment);
      t2 = space();
      option1 = element("option");
      option1.textContent = `${/*localize*/
      ctx[6]("DND5E.Flat")}`;
      option0.__value = "spell";
      set_input_value(option0, option0.__value);
      option1.__value = "flat";
      set_input_value(option1, option1.__value);
    },
    m(target, anchor) {
      insert(target, option0, anchor);
      insert(target, t1, anchor);
      mount_component(selectoptions, target, anchor);
      insert(target, t2, anchor);
      insert(target, option1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.abilities;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option0);
        detach(t1);
        detach(t2);
        detach(option1);
      }
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_4$a(ctx) {
  let div;
  let select0;
  let t0;
  let span;
  let t2;
  let numberinput;
  let t3;
  let select1;
  let current;
  select0 = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      value: (
        /*$context*/
        ctx[1].system.save.ability
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.save.ability",
      disabled: !/*$context*/
      ctx[1].editable,
      $$slots: { default: [create_default_slot_6$7] },
      $$scope: { ctx }
    }
  });
  numberinput = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[1].appId + "-system-save-dc"
      ),
      step: "any",
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.save.dc",
      value: (
        /*$context*/
        ctx[1].system.save.dc ?? null
      ),
      placeholder: (
        /*localize*/
        ctx[6]("DND5E.AbbreviationDC")
      ),
      disabled: !/*$context*/
      ctx[1].editable || !/*$context*/
      ctx[1].isFlatDC
    }
  });
  select1 = new Select({
    props: {
      id: (
        /*$context*/
        ctx[1].appId + "-system-save-scaling"
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.save.scaling",
      value: (
        /*$context*/
        ctx[1].system.save.scaling
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      $$slots: { default: [create_default_slot_5$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(select0.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[6]("DND5E.VsDC")}`;
      t2 = space();
      create_component(numberinput.$$.fragment);
      t3 = space();
      create_component(select1.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(select0, div, null);
      append(div, t0);
      append(div, span);
      append(div, t2);
      mount_component(numberinput, div, null);
      append(div, t3);
      mount_component(select1, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const select0_changes = {};
      if (dirty & /*inputId*/
      1048576) select0_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) select0_changes.value = /*$context*/
      ctx2[1].system.save.ability;
      if (dirty & /*$context*/
      2) select0_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select0_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      268435458) {
        select0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select0.$set(select0_changes);
      const numberinput_changes = {};
      if (dirty & /*$context*/
      2) numberinput_changes.id = /*$context*/
      ctx2[1].appId + "-system-save-dc";
      if (dirty & /*$context*/
      2) numberinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) numberinput_changes.value = /*$context*/
      ctx2[1].system.save.dc ?? null;
      if (dirty & /*$context*/
      2) numberinput_changes.disabled = !/*$context*/
      ctx2[1].editable || !/*$context*/
      ctx2[1].isFlatDC;
      numberinput.$set(numberinput_changes);
      const select1_changes = {};
      if (dirty & /*$context*/
      2) select1_changes.id = /*$context*/
      ctx2[1].appId + "-system-save-scaling";
      if (dirty & /*$context*/
      2) select1_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select1_changes.value = /*$context*/
      ctx2[1].system.save.scaling;
      if (dirty & /*$context*/
      2) select1_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      268435458) {
        select1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select1.$set(select1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select0.$$.fragment, local);
      transition_in(numberinput.$$.fragment, local);
      transition_in(select1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select0.$$.fragment, local);
      transition_out(numberinput.$$.fragment, local);
      transition_out(select1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(select0);
      destroy_component(numberinput);
      destroy_component(select1);
    }
  };
}
function create_if_block_2$i(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[6]("DND5E.Enchantment.Label")
      ),
      cssClass: "enchantment",
      $$slots: { default: [create_default_slot_3$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, $context*/
      268435458) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_if_block_3$c(ctx) {
  let ul;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[1].appliedEnchantments
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$e(get_each_context$e(ctx, each_value, i2));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "separated-list");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, localize*/
      66) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[1].appliedEnchantments
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$e(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$e(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ul, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block$o(ctx) {
  let html_tag;
  let raw_value = (
    /*ae*/
    ctx[21].name + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && raw_value !== (raw_value = /*ae*/
      ctx2[21].name + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block_5$6(ctx) {
  let html_tag;
  let raw_value = (
    /*localize*/
    ctx[6]("DND5E.Enchantment.Items.Entry", {
      item: (
        /*ae*/
        ctx[21].name
      ),
      actor: (
        /*ae*/
        ctx[21].actor.name
      )
    }) + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && raw_value !== (raw_value = /*localize*/
      ctx2[6]("DND5E.Enchantment.Items.Entry", {
        item: (
          /*ae*/
          ctx2[21].name
        ),
        actor: (
          /*ae*/
          ctx2[21].actor.name
        )
      }) + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block_4$7(ctx) {
  let button0;
  let i0;
  let button0_data_uuid_value;
  let t2;
  let button1;
  let i1;
  let mounted;
  let dispose;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[17](
        /*ae*/
        ctx[21]
      )
    );
  }
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[18](
        /*ae*/
        ctx[21]
      )
    );
  }
  return {
    c() {
      button0 = element("button");
      i0 = element("i");
      t2 = space();
      button1 = element("button");
      i1 = element("i");
      attr(i0, "class", "fa-solid fa-eye");
      attr(i0, "aria-hidden", "true");
      attr(button0, "type", "button");
      attr(button0, "class", "transparent-button");
      attr(button0, "data-uuid", button0_data_uuid_value = /*ae*/
      ctx[21].item.uuid);
      attr(button0, "data-tooltip", "DND5E.ItemView");
      attr(
        button0,
        "aria-label",
        /*localize*/
        ctx[6]("DND5E.ItemView")
      );
      attr(i1, "class", "fa-solid fa-rotate-left");
      attr(i1, "aria-hidden", "true");
      attr(button1, "type", "button");
      attr(button1, "class", "transparent-button");
      attr(button1, "data-tooltip", "DND5E.Enchantment.Action.Remove");
      attr(
        button1,
        "aria-label",
        /*localize*/
        ctx[6]("DND5E.Enchantment.Action.Remove")
      );
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, i0);
      insert(target, t2, anchor);
      insert(target, button1, anchor);
      append(button1, i1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_3),
          listen(button1, "click", click_handler_4)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$context*/
      2 && button0_data_uuid_value !== (button0_data_uuid_value = /*ae*/
      ctx[21].item.uuid)) {
        attr(button0, "data-uuid", button0_data_uuid_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t2);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$e(ctx) {
  let li;
  let div1;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let span;
  let t1;
  let div0;
  let t2;
  let li_data_enchantment_uuid_value;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*ae*/
      ctx2[21].actor
    ) return create_if_block_5$6;
    return create_else_block$o;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*ae*/
    ctx[21].item.isOwner && create_if_block_4$7(ctx)
  );
  return {
    c() {
      li = element("li");
      div1 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      if_block0.c();
      t1 = space();
      div0 = element("div");
      if (if_block1) if_block1.c();
      t2 = space();
      attr(img, "class", "list-icon");
      if (!src_url_equal(img.src, img_src_value = /*ae*/
      ctx[21].item.img)) attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*ae*/
      ctx[21].name);
      attr(span, "class", "name");
      attr(div0, "class", "list-controls flexrow");
      attr(div1, "class", "details flexrow");
      attr(li, "class", "item");
      attr(li, "data-enchantment-uuid", li_data_enchantment_uuid_value = /*ae*/
      ctx[21].enchantment.uuid);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div1);
      append(div1, img);
      append(div1, t0);
      append(div1, span);
      if_block0.m(span, null);
      append(div1, t1);
      append(div1, div0);
      if (if_block1) if_block1.m(div0, null);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      2 && !src_url_equal(img.src, img_src_value = /*ae*/
      ctx2[21].item.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$context*/
      2 && img_alt_value !== (img_alt_value = /*ae*/
      ctx2[21].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(span, null);
        }
      }
      if (
        /*ae*/
        ctx2[21].item.isOwner
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4$7(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$context*/
      2 && li_data_enchantment_uuid_value !== (li_data_enchantment_uuid_value = /*ae*/
      ctx2[21].enchantment.uuid)) {
        attr(li, "data-enchantment-uuid", li_data_enchantment_uuid_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if_block0.d();
      if (if_block1) if_block1.d();
    }
  };
}
function create_default_slot_3$c(ctx) {
  let div;
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[6]("DND5E.Enchantment.Action.Configure") + ""
  );
  let t1;
  let t2;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = (
    /*$context*/
    ctx[1].appliedEnchantments?.length && create_if_block_3$c(ctx)
  );
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr(i2, "class", "fa-solid fa-gear");
      attr(i2, "aria-hidden", "true");
      attr(button, "type", "button");
      attr(button, "class", "inline-transparent-button no-wrap highlight-on-hover");
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[16]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[1].appliedEnchantments?.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$c(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$o(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[6]("DND5E.Summoning.Label")
      ),
      field: "summon-config",
      cssClass: "summoning",
      $$slots: {
        default: [
          create_default_slot_1$f,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, $context, inputId, $settingStore*/
      269484050) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_2$c(ctx) {
  let t_value = (
    /*localize*/
    ctx[6]("DND5E.Summoning.Prompt.Label") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$f(ctx) {
  let div1;
  let div0;
  let button;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[6]("DND5E.Summoning.Action.Configure") + ""
  );
  let t1;
  let button_id_value;
  let button_tabindex_value;
  let t2;
  let checkbox;
  let current;
  let mounted;
  let dispose;
  checkbox = new Checkbox({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.summons.prompt",
      checked: (
        /*$context*/
        ctx[1].system.summons?.prompt === true
      ),
      title: (
        /*localize*/
        ctx[6]("DND5E.Summoning.Prompt.Hint")
      ),
      labelCssClass: "green-checkbox align-items-center",
      $$slots: { default: [create_default_slot_2$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      create_component(checkbox.$$.fragment);
      attr(i2, "class", "fa-solid fa-gear");
      attr(i2, "aria-hidden", "true");
      attr(button, "id", button_id_value = /*inputId*/
      ctx[20]);
      attr(button, "type", "button");
      attr(button, "class", "inline-transparent-button no-wrap highlight-on-hover");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div0, "role", "presentation");
      attr(div0, "class", "summon-controls flex-row justify-content-space-between flex-wrap extra-small-row-gap");
      attr(div1, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      append(div0, t2);
      mount_component(checkbox, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_5*/
          ctx[19]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*inputId*/
      1048576 && button_id_value !== (button_id_value = /*inputId*/
      ctx2[20])) {
        attr(button, "id", button_id_value);
      }
      if (!current || dirty & /*$settingStore*/
      16 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[4].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      const checkbox_changes = {};
      if (dirty & /*$context*/
      2) checkbox_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) checkbox_changes.checked = /*$context*/
      ctx2[1].system.summons?.prompt === true;
      if (dirty & /*$$scope*/
      268435456) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(checkbox);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$D(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[20]
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.chatFlavor",
      value: (
        /*$context*/
        ctx[1].system.chatFlavor
      ),
      disabled: !/*$context*/
      ctx[1].editable
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      1048576) textinput_changes.id = /*inputId*/
      ctx2[20];
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].system.chatFlavor;
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_fragment$1s(ctx) {
  let itemformgroup;
  let t2;
  let if_block_anchor;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      cssClass: "select",
      labelText: (
        /*localize*/
        ctx[6]("DND5E.ItemActionType")
      ),
      field: "system.actionType",
      $$slots: {
        default: [
          create_default_slot_15,
          ({ inputId }) => ({ 20: inputId }),
          ({ inputId }) => inputId ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[1].system.actionType && create_if_block$E(ctx)
  );
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      269484034) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
      if (
        /*$context*/
        ctx2[1].system.actionType
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemformgroup, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance$1r($$self, $$props, $$invalidate) {
  let damageIsEnchanted;
  let enchantedTooltip;
  let damageParts;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(4, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const localize = FoundryAdapter.localize;
  function addDamageFormula() {
    const damage = $context.item.system.damage;
    return $context.item.update({
      "system.damage.parts": damage.parts.concat([["", ""]])
    });
  }
  function deleteDamageFormula(index) {
    const damage = FoundryAdapter.deepClone($context.item.system.damage);
    damage.parts.splice(index, 1);
    return $context.item.update({ "system.damage.parts": damage.parts });
  }
  function saveDamageFormulae() {
    $context.item.update({ "system.damage.parts": damageParts });
  }
  const click_handler = () => addDamageFormula();
  function input_input_handler(each_value_1, i2) {
    each_value_1[i2][0] = this.value;
    $$invalidate(2, damageParts), $$invalidate(1, $context);
  }
  const change_handler = () => saveDamageFormulae();
  function select_change_handler(each_value_1, i2) {
    each_value_1[i2][1] = select_value(this);
    $$invalidate(2, damageParts), $$invalidate(1, $context);
  }
  const change_handler_1 = () => saveDamageFormulae();
  const click_handler_1 = (i2) => deleteDamageFormula(i2);
  const click_handler_2 = () => FoundryAdapter.openEnchantmentConfig($context.item);
  const click_handler_3 = (ae) => FoundryAdapter.renderFromUuid(ae.item.uuid);
  const click_handler_4 = (ae) => FoundryAdapter.removeEnchantment(ae.enchantment.uuid, $context.item.sheet);
  const click_handler_5 = () => FoundryAdapter.openSummonConfig($context.item);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    2) {
      $$invalidate(0, damageIsEnchanted = !!FoundryAdapter.getProperty($context.item.overrides, "system.damage.parts"));
    }
    if ($$self.$$.dirty & /*damageIsEnchanted*/
    1) {
      $$invalidate(3, enchantedTooltip = damageIsEnchanted ? localize("DND5E.Enchantment.Warning.Override") : null);
    }
    if ($$self.$$.dirty & /*$context*/
    2) {
      $$invalidate(2, damageParts = [...$context.system.damage.parts]);
    }
  };
  return [
    damageIsEnchanted,
    $context,
    damageParts,
    enchantedTooltip,
    $settingStore,
    context,
    localize,
    addDamageFormula,
    deleteDamageFormula,
    saveDamageFormulae,
    click_handler,
    input_input_handler,
    change_handler,
    select_change_handler,
    change_handler_1,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5
  ];
}
class ItemAction extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1r, create_fragment$1s, safe_not_equal, {});
  }
}
function mapPropertiesToSave(context, ev, keyToSave) {
  const allProperties = context.properties;
  const propertiesToSave = Object.entries(allProperties).filter(
    ([key, value]) => key !== keyToSave && value.selected && !context.itemOverrides.has(`system.properties.${key}`)
  ).map(([key, _]) => key);
  if (ev.currentTarget.checked) {
    propertiesToSave.push(keyToSave);
  }
  return {
    "system.properties": propertiesToSave
  };
}
function get_each_context$d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2][0];
  child_ctx[6] = list[i2][1];
  const constants_0 = `system.properties.${/*key*/
  child_ctx[5]}`;
  child_ctx[7] = constants_0;
  const constants_1 = (
    /*$context*/
    child_ctx[0].itemOverrides.has(
      /*field*/
      child_ctx[7]
    )
  );
  child_ctx[8] = constants_1;
  const constants_2 = (
    /*isEnchanted*/
    child_ctx[8] ? (
      /*localize*/
      child_ctx[3]("DND5E.Enchantment.Warning.Override")
    ) : null
  );
  child_ctx[9] = constants_2;
  return child_ctx;
}
function create_default_slot$C(ctx) {
  let t0_value = (
    /*property*/
    ctx[6].label + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*properties*/
      2 && t0_value !== (t0_value = /*property*/
      ctx2[6].label + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block$d(ctx) {
  let checkbox;
  let current;
  function func2(...args) {
    return (
      /*func*/
      ctx[4](
        /*key*/
        ctx[5],
        ...args
      )
    );
  }
  checkbox = new Checkbox({
    props: {
      labelCssClass: "checkbox",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: (
        /*field*/
        ctx[7]
      ),
      checked: (
        /*property*/
        ctx[6].selected
      ),
      disabled: !/*$context*/
      ctx[0].editable || /*isEnchanted*/
      ctx[8],
      onDataPreparing: func2,
      tooltip: (
        /*enchantedTooltip*/
        ctx[9]
      ),
      $$slots: { default: [create_default_slot$C] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx[0].item;
      if (dirty & /*properties*/
      2) checkbox_changes.field = /*field*/
      ctx[7];
      if (dirty & /*properties*/
      2) checkbox_changes.checked = /*property*/
      ctx[6].selected;
      if (dirty & /*$context, properties*/
      3) checkbox_changes.disabled = !/*$context*/
      ctx[0].editable || /*isEnchanted*/
      ctx[8];
      if (dirty & /*$context, properties*/
      3) checkbox_changes.onDataPreparing = func2;
      if (dirty & /*$context, properties*/
      3) checkbox_changes.tooltip = /*enchantedTooltip*/
      ctx[9];
      if (dirty & /*$$scope, properties*/
      4098) {
        checkbox_changes.$$scope = { dirty, ctx };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_fragment$1r(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*properties*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$d(get_each_context$d(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context, properties, localize*/
      11) {
        each_value = ensure_array_like(
          /*properties*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$d(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1q($$self, $$props, $$invalidate) {
  let properties;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const func2 = (key, ev) => mapPropertiesToSave($context, ev, key);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, properties = Object.entries($context.properties));
    }
  };
  return [$context, properties, context, localize, func2];
}
class ItemProperties extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1q, create_fragment$1r, safe_not_equal, {});
  }
}
function get_if_ctx$4(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*localize*/
    child_ctx[2]("DND5E.ItemConsumableSubtype", {
      category: (
        /*$context*/
        child_ctx[0].config.consumableTypes[
          /*$context*/
          child_ctx[0].system.type.value
        ]?.label
      )
    })
  );
  child_ctx[4] = constants_0;
  return child_ctx;
}
function create_default_slot_8$5(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.consumableTypes
      ),
      labelProp: "label"
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.consumableTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_7$5(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.value",
      value: (
        /*$context*/
        ctx[0].system.type.value
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_8$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.value;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_1$n(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*consumableSubTypeLabel*/
        ctx[4]
      ),
      field: "system.type.subtype",
      $$slots: {
        default: [
          create_default_slot_5$8,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$context*/
      1) itemformgroup_changes.labelText = /*consumableSubTypeLabel*/
      ctx2[4];
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_6$6(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].itemSubtypes
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].itemSubtypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_5$8(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.subtype",
      value: (
        /*$context*/
        ctx[0].system.type.subtype
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_6$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.subtype;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_4$9(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.attunementTypes
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.AttunementNone")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.attunementTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_3$b(ctx) {
  let checkbox;
  let t2;
  let select;
  let current;
  checkbox = new Checkbox({
    props: {
      id: `${/*$context*/
      ctx[0].appId}-system-attuned`,
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attuned",
      checked: (
        /*$context*/
        ctx[0].system.attuned
      ),
      disabled: !/*$context*/
      ctx[0].editable || !/*$context*/
      ctx[0].system.attunement,
      title: (
        /*localize*/
        ctx[2]("DND5E.AttunementAttuned")
      )
    }
  });
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attunement",
      value: (
        /*$context*/
        ctx[0].system.attunement
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_4$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      insert(target, t2, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.id = `${/*$context*/
      ctx2[0].appId}-system-attuned`;
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.attuned;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable || !/*$context*/
      ctx2[0].system.attunement;
      checkbox.$set(checkbox_changes);
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.attunement;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(checkbox, detaching);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_2$b(ctx) {
  let itemproperties;
  let current;
  itemproperties = new ItemProperties({});
  return {
    c() {
      create_component(itemproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemproperties, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemproperties, detaching);
    }
  };
}
function create_if_block$D(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.MagicalBonus")
      ),
      field: "system.magicalBonus",
      $$slots: {
        default: [
          create_default_slot_1$e,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_1$e(ctx) {
  let div;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.magicalBonus
      ),
      field: "system.magicalBonus",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      min: "0",
      step: "1",
      placeholder: "0"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.magicalBonus;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_default_slot$B(ctx) {
  let h30;
  let t1;
  let itemformgroup0;
  let t2;
  let t3;
  let itemformgroup1;
  let t4;
  let itemformgroup2;
  let t5;
  let t6;
  let h31;
  let t8;
  let itemactivation;
  let t9;
  let h32;
  let t11;
  let itemaction;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemConsumableType")
      ),
      field: "system.type.value",
      $$slots: {
        default: [
          create_default_slot_7$5,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$context*/
    ctx[0].itemSubtypes && create_if_block_1$n(get_if_ctx$4(ctx))
  );
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Attunement")
      ),
      field: "system.attunement",
      $$slots: {
        default: [
          create_default_slot_3$b,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup2 = new ItemFormGroup({
    props: {
      cssClass: "stacked weapon-properties",
      labelText: (
        /*$context*/
        ctx[0].system.type.value === "ammo" ? (
          /*localize*/
          ctx[2]("DND5E.ItemAmmoProperties")
        ) : (
          /*localize*/
          ctx[2]("DND5E.ItemConsumableProperties")
        )
      ),
      $$slots: { default: [create_default_slot_2$b] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$context*/
    ctx[0].properties.mgc.selected && /*$context*/
    ctx[0].system.type.value === CONSTANTS.ITEM_SYSTEM_TYPE_AMMO && create_if_block$D(ctx)
  );
  itemactivation = new ItemActivation({});
  itemaction = new ItemAction({});
  return {
    c() {
      h30 = element("h3");
      h30.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemConsumableDetails")}`;
      t1 = space();
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      if (if_block0) if_block0.c();
      t3 = space();
      create_component(itemformgroup1.$$.fragment);
      t4 = space();
      create_component(itemformgroup2.$$.fragment);
      t5 = space();
      if (if_block1) if_block1.c();
      t6 = space();
      h31 = element("h3");
      h31.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemConsumableUsage")}`;
      t8 = space();
      create_component(itemactivation.$$.fragment);
      t9 = space();
      h32 = element("h3");
      h32.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemConsumableActivation")}`;
      t11 = space();
      create_component(itemaction.$$.fragment);
      attr(h30, "class", "form-header");
      attr(h31, "class", "form-header");
      attr(h32, "class", "form-header");
    },
    m(target, anchor) {
      insert(target, h30, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t3, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t4, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t5, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t6, anchor);
      insert(target, h31, anchor);
      insert(target, t8, anchor);
      mount_component(itemactivation, target, anchor);
      insert(target, t9, anchor);
      insert(target, h32, anchor);
      insert(target, t11, anchor);
      mount_component(itemaction, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      if (
        /*$context*/
        ctx2[0].itemSubtypes
      ) {
        if (if_block0) {
          if_block0.p(get_if_ctx$4(ctx2), dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$n(get_if_ctx$4(ctx2));
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t3.parentNode, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      const itemformgroup2_changes = {};
      if (dirty & /*$context*/
      1) itemformgroup2_changes.labelText = /*$context*/
      ctx2[0].system.type.value === "ammo" ? (
        /*localize*/
        ctx2[2]("DND5E.ItemAmmoProperties")
      ) : (
        /*localize*/
        ctx2[2]("DND5E.ItemConsumableProperties")
      );
      if (dirty & /*$$scope*/
      32) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      if (
        /*$context*/
        ctx2[0].properties.mgc.selected && /*$context*/
        ctx2[0].system.type.value === CONSTANTS.ITEM_SYSTEM_TYPE_AMMO
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$D(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t6.parentNode, t6);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(if_block1);
      transition_in(itemactivation.$$.fragment, local);
      transition_in(itemaction.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(if_block1);
      transition_out(itemactivation.$$.fragment, local);
      transition_out(itemaction.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h30);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(h31);
        detach(t8);
        detach(t9);
        detach(h32);
        detach(t11);
      }
      destroy_component(itemformgroup0, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemformgroup2, detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(itemactivation, detaching);
      destroy_component(itemaction, detaching);
    }
  };
}
function create_fragment$1q(ctx) {
  let contentconcealer;
  let current;
  contentconcealer = new ContentConcealer({
    props: {
      conceal: (
        /*$context*/
        ctx[0].concealDetails
      ),
      $$slots: { default: [create_default_slot$B] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(contentconcealer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contentconcealer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const contentconcealer_changes = {};
      if (dirty & /*$context*/
      1) contentconcealer_changes.conceal = /*$context*/
      ctx2[0].concealDetails;
      if (dirty & /*$$scope, $context*/
      33) {
        contentconcealer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contentconcealer.$set(contentconcealer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contentconcealer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contentconcealer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contentconcealer, detaching);
    }
  };
}
function instance$1p($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemConsumableDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1p, create_fragment$1q, safe_not_equal, {});
  }
}
function get_each_context$c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function create_each_block$c(key_1, ctx) {
  let first;
  let utilitytoolbarcommand;
  let current;
  function execute_handler(...args) {
    return (
      /*execute_handler*/
      ctx[11](
        /*command*/
        ctx[16],
        ...args
      )
    );
  }
  utilitytoolbarcommand = new UtilityToolbarCommand({
    props: {
      title: (
        /*command*/
        ctx[16].title
      ),
      iconClass: (
        /*command*/
        ctx[16].iconClass
      ),
      text: (
        /*command*/
        ctx[16].text
      ),
      visible: (
        /*command*/
        ctx[16].visible ?? true
      )
    }
  });
  utilitytoolbarcommand.$on("execute", execute_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(utilitytoolbarcommand.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(utilitytoolbarcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const utilitytoolbarcommand_changes = {};
      if (dirty & /*utilityBarCommands*/
      8) utilitytoolbarcommand_changes.title = /*command*/
      ctx[16].title;
      if (dirty & /*utilityBarCommands*/
      8) utilitytoolbarcommand_changes.iconClass = /*command*/
      ctx[16].iconClass;
      if (dirty & /*utilityBarCommands*/
      8) utilitytoolbarcommand_changes.text = /*command*/
      ctx[16].text;
      if (dirty & /*utilityBarCommands*/
      8) utilitytoolbarcommand_changes.visible = /*command*/
      ctx[16].visible ?? true;
      utilitytoolbarcommand.$set(utilitytoolbarcommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(utilitytoolbarcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(utilitytoolbarcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(utilitytoolbarcommand, detaching);
    }
  };
}
function create_if_block$C(ctx) {
  let buttonmenu;
  let updating_open;
  let current;
  function buttonmenu_open_binding(value) {
    ctx[14](value);
  }
  let buttonmenu_props = {
    iconClass: "ra ra-fairy-wand",
    buttonClass: "inline-icon-button " + /*menuOpen*/
    (ctx[2] ? "menu-is-open" : ""),
    position: "bottom",
    anchor: "right",
    title: (
      /*localize*/
      ctx[9]("TIDY5E.Utilities.GMTools")
    ),
    menuElement: "div",
    $$slots: { default: [create_default_slot_1$d] },
    $$scope: { ctx }
  };
  if (
    /*menuOpen*/
    ctx[2] !== void 0
  ) {
    buttonmenu_props.open = /*menuOpen*/
    ctx[2];
  }
  buttonmenu = new ButtonMenu({ props: buttonmenu_props });
  binding_callbacks.push(() => bind(buttonmenu, "open", buttonmenu_open_binding));
  return {
    c() {
      create_component(buttonmenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const buttonmenu_changes = {};
      if (dirty & /*menuOpen*/
      4) buttonmenu_changes.buttonClass = "inline-icon-button " + /*menuOpen*/
      (ctx2[2] ? "menu-is-open" : "");
      if (dirty & /*$$scope, $context, allItems*/
      524306) {
        buttonmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & /*menuOpen*/
      4) {
        updating_open = true;
        buttonmenu_changes.open = /*menuOpen*/
        ctx2[2];
        add_flush_callback(() => updating_open = false);
      }
      buttonmenu.$set(buttonmenu_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenu, detaching);
    }
  };
}
function create_default_slot_3$a(ctx) {
  let t_value = (
    /*localize*/
    ctx[9]("TIDY5E.Utilities.IdentifyAll") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$a(ctx) {
  let t_value = (
    /*localize*/
    ctx[9]("TIDY5E.Utilities.MarkAllAsUnidentified") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$d(ctx) {
  let buttonmenucommand0;
  let t2;
  let buttonmenucommand1;
  let current;
  buttonmenucommand0 = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-magnifying-glass",
      $$slots: { default: [create_default_slot_3$a] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand0.$on(
    "click",
    /*click_handler*/
    ctx[12]
  );
  buttonmenucommand1 = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-question",
      $$slots: { default: [create_default_slot_2$a] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand1.$on(
    "click",
    /*click_handler_1*/
    ctx[13]
  );
  return {
    c() {
      create_component(buttonmenucommand0.$$.fragment);
      t2 = space();
      create_component(buttonmenucommand1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenucommand0, target, anchor);
      insert(target, t2, anchor);
      mount_component(buttonmenucommand1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const buttonmenucommand0_changes = {};
      if (dirty & /*$$scope*/
      524288) {
        buttonmenucommand0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand0.$set(buttonmenucommand0_changes);
      const buttonmenucommand1_changes = {};
      if (dirty & /*$$scope*/
      524288) {
        buttonmenucommand1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand1.$set(buttonmenucommand1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenucommand0.$$.fragment, local);
      transition_in(buttonmenucommand1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenucommand0.$$.fragment, local);
      transition_out(buttonmenucommand1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(buttonmenucommand0, detaching);
      destroy_component(buttonmenucommand1, detaching);
    }
  };
}
function create_default_slot$A(ctx) {
  let search;
  let updating_value;
  let t0;
  let pinnedfiltertoggles;
  let t1;
  let filtermenu;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t3;
  let show_if = FoundryAdapter.userIsGm();
  let if_block_anchor;
  let current;
  function search_value_binding(value) {
    ctx[10](value);
  }
  let search_props = {};
  if (
    /*searchCriteria*/
    ctx[0] !== void 0
  ) {
    search_props.value = /*searchCriteria*/
    ctx[0];
  }
  search = new Search({ props: search_props });
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  pinnedfiltertoggles = new PinnedFilterToggles({
    props: {
      filterGroupName: (
        /*tabId*/
        ctx[6]
      ),
      filters: ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx[1].filterPins,
        /*$context*/
        ctx[1].filterData,
        /*tabId*/
        ctx[6]
      )
    }
  });
  filtermenu = new FilterMenu({ props: { tabId: (
    /*tabId*/
    ctx[6]
  ) } });
  let each_value = ensure_array_like(
    /*utilityBarCommands*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*command*/
    ctx2[16].title
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$c(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$c(key, child_ctx));
  }
  let if_block = show_if && create_if_block$C(ctx);
  return {
    c() {
      create_component(search.$$.fragment);
      t0 = space();
      create_component(pinnedfiltertoggles.$$.fragment);
      t1 = space();
      create_component(filtermenu.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      insert(target, t0, anchor);
      mount_component(pinnedfiltertoggles, target, anchor);
      insert(target, t1, anchor);
      mount_component(filtermenu, target, anchor);
      insert(target, t2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t3, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const search_changes = {};
      if (!updating_value && dirty & /*searchCriteria*/
      1) {
        updating_value = true;
        search_changes.value = /*searchCriteria*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
      const pinnedfiltertoggles_changes = {};
      if (dirty & /*$context*/
      2) pinnedfiltertoggles_changes.filters = ItemFilterRuntime.getPinnedFiltersForTab(
        /*$context*/
        ctx2[1].filterPins,
        /*$context*/
        ctx2[1].filterData,
        /*tabId*/
        ctx2[6]
      );
      pinnedfiltertoggles.$set(pinnedfiltertoggles_changes);
      if (dirty & /*utilityBarCommands*/
      8) {
        each_value = ensure_array_like(
          /*utilityBarCommands*/
          ctx2[3]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t3.parentNode, outro_and_destroy_block, create_each_block$c, t3, get_each_context$c);
        check_outros();
      }
      if (show_if) if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current) return;
      transition_in(search.$$.fragment, local);
      transition_in(pinnedfiltertoggles.$$.fragment, local);
      transition_in(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      transition_out(pinnedfiltertoggles.$$.fragment, local);
      transition_out(filtermenu.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block_anchor);
      }
      destroy_component(search, detaching);
      destroy_component(pinnedfiltertoggles, detaching);
      destroy_component(filtermenu, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$1p(ctx) {
  let div2;
  let div0;
  let currency;
  let t0;
  let utilitytoolbar;
  let t1;
  let div1;
  let containercontentssections;
  let t2;
  let footer;
  let capacitybar;
  let current;
  currency = new Currency({
    props: { document: (
      /*$context*/
      ctx[1].item
    ) }
  });
  utilitytoolbar = new UtilityToolbar({
    props: {
      $$slots: { default: [create_default_slot$A] },
      $$scope: { ctx }
    }
  });
  containercontentssections = new ContainerContentsSections({
    props: {
      contents: (
        /*$context*/
        ctx[1].containerContents.contents
      ),
      container: (
        /*$context*/
        ctx[1].item
      ),
      editable: (
        /*$context*/
        ctx[1].editable
      ),
      itemContext: (
        /*$context*/
        ctx[1].containerContents.itemContext
      ),
      inlineContainerToggleService: (
        /*inlineContainerToggleService*/
        ctx[7]
      ),
      lockItemQuantity: (
        /*$context*/
        ctx[1].lockItemQuantity
      ),
      sheetDocument: (
        /*$context*/
        ctx[1].item
      )
    }
  });
  capacitybar = new CapacityBar({
    props: {
      container: (
        /*$context*/
        ctx[1].item
      ),
      capacity: (
        /*$context*/
        ctx[1].capacity
      )
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(currency.$$.fragment);
      t0 = space();
      create_component(utilitytoolbar.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(containercontentssections.$$.fragment);
      t2 = space();
      footer = element("footer");
      create_component(capacitybar.$$.fragment);
      attr(div0, "role", "presentation");
      attr(div0, "class", "currency-wrapper svelte-aulymd");
      attr(div1, "class", "tidy-container-contents scroll-container flex-column small-gap svelte-aulymd");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEMS_CONTAINER);
      attr(footer, "class", "container-contents-footer svelte-aulymd");
      attr(div2, "class", "container-contents-wrapper svelte-aulymd");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(currency, div0, null);
      append(div2, t0);
      mount_component(utilitytoolbar, div2, null);
      append(div2, t1);
      append(div2, div1);
      mount_component(containercontentssections, div1, null);
      append(div2, t2);
      append(div2, footer);
      mount_component(capacitybar, footer, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const currency_changes = {};
      if (dirty & /*$context*/
      2) currency_changes.document = /*$context*/
      ctx2[1].item;
      currency.$set(currency_changes);
      const utilitytoolbar_changes = {};
      if (dirty & /*$$scope, menuOpen, $context, allItems, utilityBarCommands, searchCriteria*/
      524319) {
        utilitytoolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      utilitytoolbar.$set(utilitytoolbar_changes);
      const containercontentssections_changes = {};
      if (dirty & /*$context*/
      2) containercontentssections_changes.contents = /*$context*/
      ctx2[1].containerContents.contents;
      if (dirty & /*$context*/
      2) containercontentssections_changes.container = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) containercontentssections_changes.editable = /*$context*/
      ctx2[1].editable;
      if (dirty & /*$context*/
      2) containercontentssections_changes.itemContext = /*$context*/
      ctx2[1].containerContents.itemContext;
      if (dirty & /*$context*/
      2) containercontentssections_changes.lockItemQuantity = /*$context*/
      ctx2[1].lockItemQuantity;
      if (dirty & /*$context*/
      2) containercontentssections_changes.sheetDocument = /*$context*/
      ctx2[1].item;
      containercontentssections.$set(containercontentssections_changes);
      const capacitybar_changes = {};
      if (dirty & /*$context*/
      2) capacitybar_changes.container = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) capacitybar_changes.capacity = /*$context*/
      ctx2[1].capacity;
      capacitybar.$set(capacitybar_changes);
    },
    i(local) {
      if (current) return;
      transition_in(currency.$$.fragment, local);
      transition_in(utilitytoolbar.$$.fragment, local);
      transition_in(containercontentssections.$$.fragment, local);
      transition_in(capacitybar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(currency.$$.fragment, local);
      transition_out(utilitytoolbar.$$.fragment, local);
      transition_out(containercontentssections.$$.fragment, local);
      transition_out(capacitybar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(currency);
      destroy_component(utilitytoolbar);
      destroy_component(containercontentssections);
      destroy_component(capacitybar);
    }
  };
}
function instance$1o($$self, $$props, $$invalidate) {
  let allItems;
  let utilityBarCommands;
  let menuOpen;
  let $context;
  let $itemIdsToShow;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let tabId = getContext(CONSTANTS.SVELTE_CONTEXT.TAB_ID);
  let inlineContainerToggleService = getContext(CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE);
  let searchCriteria = "";
  const itemIdsToShow = writable(void 0);
  component_subscribe($$self, itemIdsToShow, (value) => $$invalidate(15, $itemIdsToShow = value));
  setContext(CONSTANTS.SVELTE_CONTEXT.ITEM_IDS_TO_SHOW, itemIdsToShow);
  const localize = FoundryAdapter.localize;
  function search_value_binding(value) {
    searchCriteria = value;
    $$invalidate(0, searchCriteria);
  }
  const execute_handler = (command, ev) => command.execute?.(ev.detail);
  const click_handler = () => {
    FoundryAdapter.identifyAllItemsForContainer($context.item, allItems);
  };
  const click_handler_1 = () => {
    FoundryAdapter.markAllItemsAsUnidentifiedForContainer($context.item, allItems);
  };
  function buttonmenu_open_binding(value) {
    menuOpen = value;
    $$invalidate(2, menuOpen);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    2) {
      $$invalidate(4, allItems = $context.containerContents.contents.flatMap((x2) => x2.items));
    }
    if ($$self.$$.dirty & /*searchCriteria, $context*/
    3) {
      {
        set_store_value(
          itemIdsToShow,
          $itemIdsToShow = ItemVisibility.getItemsToShowAtDepth({
            criteria: searchCriteria,
            itemContext: $context.itemContext,
            sections: $context.containerContents.contents,
            tabId
          }),
          $itemIdsToShow
        );
      }
    }
    if ($$self.$$.dirty & /*$context*/
    2) {
      $$invalidate(3, utilityBarCommands = $context.utilities[tabId]?.utilityToolbarCommands ?? []);
    }
  };
  $$invalidate(2, menuOpen = false);
  return [
    searchCriteria,
    $context,
    menuOpen,
    utilityBarCommands,
    allItems,
    context,
    tabId,
    inlineContainerToggleService,
    itemIdsToShow,
    localize,
    search_value_binding,
    execute_handler,
    click_handler,
    click_handler_1,
    buttonmenu_open_binding
  ];
}
class ItemContainerContentsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1o, create_fragment$1p, safe_not_equal, {});
  }
}
function create_default_slot_6$5(ctx) {
  let itemproperties;
  let current;
  itemproperties = new ItemProperties({});
  return {
    c() {
      create_component(itemproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemproperties, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemproperties, detaching);
    }
  };
}
function create_default_slot_5$7(ctx) {
  let div;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.capacity.value",
      value: (
        /*$context*/
        ctx[0].system.capacity.value
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      placeholder: ""
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.capacity.value;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_default_slot_4$8(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.itemCapacityTypes
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.itemCapacityTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_3$9(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.capacity.type",
      value: (
        /*$context*/
        ctx[0].system.capacity.type
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_4$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.capacity.type;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_2$9(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.attunementTypes
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.AttunementNone")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.attunementTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_1$c(ctx) {
  let checkbox;
  let t2;
  let select;
  let current;
  checkbox = new Checkbox({
    props: {
      id: `${/*$context*/
      ctx[0].appId}-system-attuned`,
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attuned",
      checked: (
        /*$context*/
        ctx[0].system.attuned
      ),
      disabled: !/*$context*/
      ctx[0].editable || !/*$context*/
      ctx[0].system.attunement,
      title: (
        /*localize*/
        ctx[2]("DND5E.AttunementAttuned")
      )
    }
  });
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attunement",
      value: (
        /*$context*/
        ctx[0].system.attunement
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_2$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      insert(target, t2, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.id = `${/*$context*/
      ctx2[0].appId}-system-attuned`;
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.attuned;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable || !/*$context*/
      ctx2[0].system.attunement;
      checkbox.$set(checkbox_changes);
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.attunement;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(checkbox, detaching);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot$z(ctx) {
  let h3;
  let t1;
  let itemformgroup0;
  let t2;
  let itemformgroup1;
  let t3;
  let itemformgroup2;
  let t4;
  let itemformgroup3;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      cssClass: "stacked container-properties",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemContainerProperties")
      ),
      $$slots: { default: [create_default_slot_6$5] },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemContainerCapacity")
      ),
      field: "system.capacity.value",
      $$slots: {
        default: [
          create_default_slot_5$7,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup2 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemContainerCapacityType")
      ),
      $$slots: { default: [create_default_slot_3$9] },
      $$scope: { ctx }
    }
  });
  itemformgroup3 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Attunement")
      ),
      field: "system.attunement",
      $$slots: {
        default: [
          create_default_slot_1$c,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemContainerDetails")}`;
      t1 = space();
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      create_component(itemformgroup1.$$.fragment);
      t3 = space();
      create_component(itemformgroup2.$$.fragment);
      t4 = space();
      create_component(itemformgroup3.$$.fragment);
      attr(h3, "class", "form-header");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t3, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t4, anchor);
      mount_component(itemformgroup3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope*/
      16) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope, $context*/
      17) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      const itemformgroup3_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup3.$set(itemformgroup3_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(itemformgroup3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(itemformgroup3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemformgroup2, detaching);
      destroy_component(itemformgroup3, detaching);
    }
  };
}
function create_fragment$1o(ctx) {
  let contentconcealer;
  let current;
  contentconcealer = new ContentConcealer({
    props: {
      conceal: (
        /*$context*/
        ctx[0].concealDetails
      ),
      $$slots: { default: [create_default_slot$z] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(contentconcealer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contentconcealer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const contentconcealer_changes = {};
      if (dirty & /*$context*/
      1) contentconcealer_changes.conceal = /*$context*/
      ctx2[0].concealDetails;
      if (dirty & /*$$scope, $context*/
      17) {
        contentconcealer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contentconcealer.$set(contentconcealer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contentconcealer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contentconcealer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contentconcealer, detaching);
    }
  };
}
function instance$1n($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemContainerDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1n, create_fragment$1o, safe_not_equal, {});
  }
}
function create_default_slot$y(ctx) {
  let article;
  let h2;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].enriched.description
      ),
      editable: (
        /*$context*/
        ctx[0].editable
      ),
      target: "system.description.value"
    }
  });
  return {
    c() {
      article = element("article");
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[2]("TIDY5E.ItemDetailsHeadline")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(h2, "class", "details-headline");
      attr(article, "class", "editor-container");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, h2);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].enriched.description;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1n(ctx) {
  let rerenderafterformsubmission;
  let current;
  rerenderafterformsubmission = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].item.system.description.value
      ),
      $$slots: { default: [create_default_slot$y] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(rerenderafterformsubmission.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rerenderafterformsubmission, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rerenderafterformsubmission_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission_changes.andOnValueChange = /*$context*/
      ctx2[0].item.system.description.value;
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission.$set(rerenderafterformsubmission_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rerenderafterformsubmission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rerenderafterformsubmission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rerenderafterformsubmission, detaching);
    }
  };
}
function instance$1m($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemDescriptionTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1m, create_fragment$1n, safe_not_equal, {});
  }
}
function create_default_slot$x(ctx) {
  let div;
  let textinput;
  let t0;
  let p2;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.identifier",
      value: (
        /*$context*/
        ctx[0].system.identifier
      ),
      placeholder: (
        /*$context*/
        ctx[0].item.identifier
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[2]("DND5E.IdentifierError")}`;
      attr(div, "class", "form-fields");
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.identifier;
      if (dirty & /*$context*/
      1) textinput_changes.placeholder = /*$context*/
      ctx2[0].item.identifier;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p2);
      }
      destroy_component(textinput);
    }
  };
}
function create_fragment$1m(ctx) {
  let div;
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Identifier")
      ),
      field: "system.identifier",
      $$slots: {
        default: [
          create_default_slot$x,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(itemformgroup.$$.fragment);
      attr(div, "class", "form-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(itemformgroup, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(itemformgroup);
    }
  };
}
function instance$1l($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemRaceDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1l, create_fragment$1m, safe_not_equal, {});
  }
}
function create_fragment$1l(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "vertical-line-separator svelte-ziqoq");
      attr(div, "aria-hidden", "true");
      attr(div, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
class VerticalLineSeparator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1l, safe_not_equal, {});
  }
}
function create_key_block$3(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr(div, "class", div_class_value = /*$$props*/
      ctx[1].class);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$$props*/
      2 && div_class_value !== (div_class_value = /*$$props*/
      ctx2[1].class)) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_fragment$1k(ctx) {
  let previous_key = (
    /*multiple*/
    ctx[0]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block$3(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*multiple*/
      1 && safe_not_equal(previous_key, previous_key = /*multiple*/
      ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$3(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current) return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
function instance$1k($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { multiple = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("multiple" in $$new_props) $$invalidate(0, multiple = $$new_props.multiple);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*multiple*/
    1) {
      setContext(CONSTANTS.SVELTE_CONTEXT.ACCORDION_CONTEXT, { selected: multiple ? void 0 : writable() });
    }
  };
  $$props = exclude_internal_props($$props);
  return [multiple, $$props, $$scope, slots];
}
class Accordion extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1k, create_fragment$1k, safe_not_equal, { multiple: 0 });
  }
}
const get_header_slot_changes = (dirty) => ({});
const get_header_slot_context = (ctx) => ({});
function create_default_slot$w(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr(div, "class", "accordion-item-content svelte-1b84u34");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function create_fragment$1j(ctx) {
  let section;
  let h2;
  let button;
  let span;
  let t0;
  let button_tabindex_value;
  let t1;
  let expandablecontainer;
  let section_class_value;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = (
    /*#slots*/
    ctx[5].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_header_slot_context
  );
  expandablecontainer = new ExpandableContainer({
    props: {
      expanded: (
        /*open*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot$w] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      section = element("section");
      h2 = element("h2");
      button = element("button");
      span = element("span");
      span.innerHTML = `<i class="fas fa-chevron-right"></i>`;
      t0 = space();
      if (header_slot) header_slot.c();
      t1 = space();
      create_component(expandablecontainer.$$.fragment);
      attr(span, "class", "accordion-arrow svelte-1b84u34");
      toggle_class(
        span,
        "open",
        /*open*/
        ctx[0]
      );
      attr(button, "class", "accordion-item-toggle transparent-button svelte-1b84u34");
      attr(button, "type", "button");
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.EXPANSION_TOGGLE);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
      attr(h2, "class", "accordion-item-header svelte-1b84u34");
      toggle_class(
        h2,
        "open",
        /*open*/
        ctx[0]
      );
      attr(section, "class", section_class_value = "accordion-item " + /*$$props*/
      (ctx[4].class ?? "") + " svelte-1b84u34");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h2);
      append(h2, button);
      append(button, span);
      append(button, t0);
      if (header_slot) {
        header_slot.m(button, null);
      }
      append(section, t1);
      mount_component(expandablecontainer, section, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*open*/
      1) {
        toggle_class(
          span,
          "open",
          /*open*/
          ctx2[0]
        );
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & /*open*/
      1) {
        toggle_class(
          h2,
          "open",
          /*open*/
          ctx2[0]
        );
      }
      const expandablecontainer_changes = {};
      if (dirty & /*open*/
      1) expandablecontainer_changes.expanded = /*open*/
      ctx2[0];
      if (dirty & /*$$scope*/
      128) {
        expandablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expandablecontainer.$set(expandablecontainer_changes);
      if (!current || dirty & /*$$props*/
      16 && section_class_value !== (section_class_value = "accordion-item " + /*$$props*/
      (ctx2[4].class ?? "") + " svelte-1b84u34")) {
        attr(section, "class", section_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(header_slot, local);
      transition_in(expandablecontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(expandablecontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (header_slot) header_slot.d(detaching);
      destroy_component(expandablecontainer);
      mounted = false;
      dispose();
    }
  };
}
function instance$1j($$self, $$props, $$invalidate) {
  let $selected;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { open = false } = $$props;
  const ctx = getContext(CONSTANTS.SVELTE_CONTEXT.ACCORDION_CONTEXT) ?? {};
  const self2 = {};
  const selected = ctx.selected ?? writable();
  component_subscribe($$self, selected, (value) => $$invalidate(8, $selected = value));
  function toggle() {
    selected.set(open ? {} : self2);
  }
  onMount(() => {
    if (open) {
      set_store_value(selected, $selected = self2, $selected);
    }
    return selected.subscribe((x2) => $$invalidate(0, open = x2 === self2));
  });
  const click_handler = () => toggle();
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [open, $settingStore, selected, toggle, $$props, slots, click_handler, $$scope];
}
class AccordionItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1j, create_fragment$1j, safe_not_equal, { open: 0 });
  }
}
function get_each_context$b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  child_ctx[11] = list;
  child_ctx[12] = i2;
  return child_ctx;
}
function create_if_block$B(ctx) {
  let div;
  let accordion;
  let current;
  accordion = new Accordion({
    props: {
      multiple: true,
      $$slots: { default: [create_default_slot$v] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(accordion.$$.fragment);
      attr(div, "class", "item-descriptions-container svelte-x08twt");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(accordion, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_changes = {};
      if (dirty & /*$$scope, $context, editorsContainers, accordionItemOpenStates, $settingStore*/
      8222) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current) return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(accordion);
    }
  };
}
function create_default_slot_1$b(ctx) {
  let div;
  let raw_value = (
    /*itemDescription*/
    ctx[10].content + ""
  );
  let div_data_edit_value;
  return {
    c() {
      div = element("div");
      attr(div, "data-edit", div_data_edit_value = /*itemDescription*/
      ctx[10].field);
      attr(div, "class", "item-editor-descriptions-html-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && raw_value !== (raw_value = /*itemDescription*/
      ctx2[10].content + "")) div.innerHTML = raw_value;
      if (dirty & /*$context*/
      8 && div_data_edit_value !== (div_data_edit_value = /*itemDescription*/
      ctx2[10].field)) {
        attr(div, "data-edit", div_data_edit_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_1$m(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[7](
        /*itemDescription*/
        ctx[10]
      )
    );
  }
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-edit");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button edit-item-description svelte-x08twt");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$settingStore*/
      16 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_header_slot$1(ctx) {
  let span;
  let t0_value = (
    /*itemDescription*/
    ctx[10].label + ""
  );
  let t0;
  let t1;
  let if_block = (
    /*$context*/
    ctx[3].editable && create_if_block_1$m(ctx)
  );
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      attr(span, "slot", "header");
      attr(span, "class", "flex-1 flex-row justify-content-space-between");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      if (if_block) if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t0_value !== (t0_value = /*itemDescription*/
      ctx2[10].label + "")) set_data(t0, t0_value);
      if (
        /*$context*/
        ctx2[3].editable
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$m(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block) if_block.d();
    }
  };
}
function create_key_block$2(ctx) {
  let div;
  let accordionitem;
  let updating_open;
  let t2;
  let i2 = (
    /*i*/
    ctx[12]
  );
  let current;
  let mounted;
  let dispose;
  function accordionitem_open_binding(value) {
    ctx[8](
      value,
      /*i*/
      ctx[12]
    );
  }
  let accordionitem_props = {
    class: "editor",
    $$slots: {
      header: [create_header_slot$1],
      default: [create_default_slot_1$b]
    },
    $$scope: { ctx }
  };
  if (
    /*accordionItemOpenStates*/
    ctx[2][
      /*i*/
      ctx[12]
    ] !== void 0
  ) {
    accordionitem_props.open = /*accordionItemOpenStates*/
    ctx[2][
      /*i*/
      ctx[12]
    ];
  }
  accordionitem = new AccordionItem({ props: accordionitem_props });
  binding_callbacks.push(() => bind(accordionitem, "open", accordionitem_open_binding));
  const assign_div = () => (
    /*div_binding*/
    ctx[9](div, i2)
  );
  const unassign_div = () => (
    /*div_binding*/
    ctx[9](null, i2)
  );
  return {
    c() {
      div = element("div");
      create_component(accordionitem.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(accordionitem, div, null);
      append(div, t2);
      assign_div();
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[3].activateEditors(div)
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const accordionitem_changes = {};
      if (dirty & /*$$scope, $settingStore, $context*/
      8216) {
        accordionitem_changes.$$scope = { dirty, ctx };
      }
      if (!updating_open && dirty & /*accordionItemOpenStates, $context*/
      12) {
        updating_open = true;
        accordionitem_changes.open = /*accordionItemOpenStates*/
        ctx[2][
          /*i*/
          ctx[12]
        ];
        add_flush_callback(() => updating_open = false);
      }
      accordionitem.$set(accordionitem_changes);
      if (i2 !== /*i*/
      ctx[12]) {
        unassign_div();
        i2 = /*i*/
        ctx[12];
        assign_div();
      }
    },
    i(local) {
      if (current) return;
      transition_in(accordionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(accordionitem);
      unassign_div();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$b(key_1, ctx) {
  let first;
  let previous_key = (
    /*itemDescription*/
    ctx[10].content
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block$2(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      key_block.c();
      key_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$context*/
      8 && safe_not_equal(previous_key, previous_key = /*itemDescription*/
      ctx[10].content)) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$2(ctx);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx, dirty);
      }
    },
    i(local) {
      if (current) return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
function create_default_slot$v(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[3].itemDescriptions
  );
  const get_key = (ctx2) => (
    /*itemDescription*/
    ctx2[10].field
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$b(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$b(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$context, editorsContainers, accordionItemOpenStates, $settingStore, dispatcher*/
      94) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[3].itemDescriptions
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$b, each_1_anchor, get_each_context$b);
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_fragment$1i(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*renderDescriptions*/
    ctx[0] && create_if_block$B(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*renderDescriptions*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*renderDescriptions*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$B(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance$1i($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(4, $settingStore = $$value));
  let { renderDescriptions = true } = $$props;
  let editorsContainers = [];
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  const dispatcher = createEventDispatcher();
  let accordionItemOpenStates = $context.itemDescriptions.map((_, i2) => i2 === 0);
  const click_handler = (itemDescription) => dispatcher("edit", {
    valueToEdit: itemDescription.content,
    fieldToEdit: itemDescription.field
  });
  function accordionitem_open_binding(value, i2) {
    if ($$self.$$.not_equal(accordionItemOpenStates[i2], value)) {
      accordionItemOpenStates[i2] = value;
      $$invalidate(2, accordionItemOpenStates);
    }
  }
  function div_binding($$value, i2) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      editorsContainers[i2] = $$value;
      $$invalidate(1, editorsContainers);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("renderDescriptions" in $$props2) $$invalidate(0, renderDescriptions = $$props2.renderDescriptions);
  };
  return [
    renderDescriptions,
    editorsContainers,
    accordionItemOpenStates,
    $context,
    $settingStore,
    context,
    dispatcher,
    click_handler,
    accordionitem_open_binding,
    div_binding
  ];
}
class ItemDescriptions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1i, create_fragment$1i, safe_not_equal, { renderDescriptions: 0 });
  }
}
function create_fragment$1h(ctx) {
  let html_tag;
  let raw_value = FoundryAdapter.createOpenEditorHtml(
    /*content*/
    ctx[0],
    /*target*/
    ctx[1]
  ) + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*content, target*/
      3 && raw_value !== (raw_value = FoundryAdapter.createOpenEditorHtml(
        /*content*/
        ctx2[0],
        /*target*/
        ctx2[1]
      ) + "")) html_tag.p(raw_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function instance$1h($$self, $$props, $$invalidate) {
  let { content } = $$props;
  let { target } = $$props;
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2) $$invalidate(0, content = $$props2.content);
    if ("target" in $$props2) $$invalidate(1, target = $$props2.target);
  };
  return [content, target];
}
class OpenSheetEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1h, create_fragment$1h, safe_not_equal, { content: 0, target: 1 });
  }
}
function get_each_context$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  const constants_0 = (
    /*derivedDamage*/
    child_ctx[14].label
  );
  child_ctx[15] = constants_0;
  return child_ctx;
}
function create_if_block_7$3(ctx) {
  let t0;
  let div0;
  let label0;
  let t1_value = (
    /*localize*/
    ctx[7]("DND5E.Weight") + ""
  );
  let t1;
  let label0_for_value;
  let t2;
  let numberinput;
  let t3;
  let horizontallineseparator;
  let t4;
  let div1;
  let label1;
  let t5_value = (
    /*localize*/
    ctx[7]("DND5E.Price") + ""
  );
  let t5;
  let label1_for_value;
  let t6;
  let current_block_type_index;
  let if_block1;
  let current;
  let if_block0 = (
    /*$context*/
    ctx[3].item.type !== CONSTANTS.ITEM_TYPE_CONTAINER && create_if_block_9$1(ctx)
  );
  numberinput = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[3].appId + "-" + /*$context*/
        ctx[3].item.id + "-weight-value"
      ),
      value: (
        /*$context*/
        ctx[3].system.weight.value
      ),
      step: "any",
      field: "system.weight.value",
      document: (
        /*$context*/
        ctx[3].item
      ),
      disabled: !/*$context*/
      ctx[3].editable,
      selectOnFocus: true
    }
  });
  horizontallineseparator = new HorizontalLineSeparator({});
  const if_block_creators = [create_if_block_8$1, create_else_block$n];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[3].concealDetails
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div0 = element("div");
      label0 = element("label");
      t1 = text(t1_value);
      t2 = space();
      create_component(numberinput.$$.fragment);
      t3 = space();
      create_component(horizontallineseparator.$$.fragment);
      t4 = space();
      div1 = element("div");
      label1 = element("label");
      t5 = text(t5_value);
      t6 = space();
      if_block1.c();
      attr(label0, "for", label0_for_value = /*$context*/
      ctx[3].appId + "-" + /*$context*/
      ctx[3].item.id + "-weight-value");
      attr(div0, "class", "form-group");
      attr(label1, "for", label1_for_value = /*$context*/
      ctx[3].appId + "-" + /*$context*/
      ctx[3].item.id + "-price");
      attr(div1, "class", "form-group stacked");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div0, anchor);
      append(div0, label0);
      append(label0, t1);
      append(div0, t2);
      mount_component(numberinput, div0, null);
      insert(target, t3, anchor);
      mount_component(horizontallineseparator, target, anchor);
      insert(target, t4, anchor);
      insert(target, div1, anchor);
      append(div1, label1);
      append(label1, t5);
      append(div1, t6);
      if_blocks[current_block_type_index].m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[3].item.type !== CONSTANTS.ITEM_TYPE_CONTAINER
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_9$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$context*/
      8 && label0_for_value !== (label0_for_value = /*$context*/
      ctx2[3].appId + "-" + /*$context*/
      ctx2[3].item.id + "-weight-value")) {
        attr(label0, "for", label0_for_value);
      }
      const numberinput_changes = {};
      if (dirty & /*$context*/
      8) numberinput_changes.id = /*$context*/
      ctx2[3].appId + "-" + /*$context*/
      ctx2[3].item.id + "-weight-value";
      if (dirty & /*$context*/
      8) numberinput_changes.value = /*$context*/
      ctx2[3].system.weight.value;
      if (dirty & /*$context*/
      8) numberinput_changes.document = /*$context*/
      ctx2[3].item;
      if (dirty & /*$context*/
      8) numberinput_changes.disabled = !/*$context*/
      ctx2[3].editable;
      numberinput.$set(numberinput_changes);
      if (!current || dirty & /*$context*/
      8 && label1_for_value !== (label1_for_value = /*$context*/
      ctx2[3].appId + "-" + /*$context*/
      ctx2[3].item.id + "-price")) {
        attr(label1, "for", label1_for_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div1, null);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(numberinput.$$.fragment, local);
      transition_in(horizontallineseparator.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(numberinput.$$.fragment, local);
      transition_out(horizontallineseparator.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div0);
        detach(t3);
        detach(t4);
        detach(div1);
      }
      if (if_block0) if_block0.d(detaching);
      destroy_component(numberinput);
      destroy_component(horizontallineseparator, detaching);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_if_block_9$1(ctx) {
  let div;
  let label_1;
  let t0_value = (
    /*localize*/
    ctx[7]("DND5E.Quantity") + ""
  );
  let t0;
  let label_1_for_value;
  let t1;
  let numberinput;
  let t2;
  let horizontallineseparator;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[3].appId + "-" + /*$context*/
        ctx[3].item.id + "-quantity"
      ),
      value: (
        /*$context*/
        ctx[3].system.quantity
      ),
      field: "system.quantity",
      document: (
        /*$context*/
        ctx[3].item
      ),
      step: "1",
      disabled: !/*$context*/
      ctx[3].editable || /*$context*/
      ctx[3].lockItemQuantity,
      selectOnFocus: true
    }
  });
  horizontallineseparator = new HorizontalLineSeparator({});
  return {
    c() {
      div = element("div");
      label_1 = element("label");
      t0 = text(t0_value);
      t1 = space();
      create_component(numberinput.$$.fragment);
      t2 = space();
      create_component(horizontallineseparator.$$.fragment);
      attr(label_1, "for", label_1_for_value = /*$context*/
      ctx[3].appId + "-" + /*$context*/
      ctx[3].item.id + "-quantity");
      attr(div, "class", "form-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label_1);
      append(label_1, t0);
      append(div, t1);
      mount_component(numberinput, div, null);
      insert(target, t2, anchor);
      mount_component(horizontallineseparator, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$context*/
      8 && label_1_for_value !== (label_1_for_value = /*$context*/
      ctx2[3].appId + "-" + /*$context*/
      ctx2[3].item.id + "-quantity")) {
        attr(label_1, "for", label_1_for_value);
      }
      const numberinput_changes = {};
      if (dirty & /*$context*/
      8) numberinput_changes.id = /*$context*/
      ctx2[3].appId + "-" + /*$context*/
      ctx2[3].item.id + "-quantity";
      if (dirty & /*$context*/
      8) numberinput_changes.value = /*$context*/
      ctx2[3].system.quantity;
      if (dirty & /*$context*/
      8) numberinput_changes.document = /*$context*/
      ctx2[3].item;
      if (dirty & /*$context*/
      8) numberinput_changes.disabled = !/*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].lockItemQuantity;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
      }
      destroy_component(numberinput);
      destroy_component(horizontallineseparator, detaching);
    }
  };
}
function create_else_block$n(ctx) {
  let numberinput;
  let t2;
  let select;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[3].appId + "-" + /*$context*/
        ctx[3].item.id + "-price"
      ),
      value: (
        /*$context*/
        ctx[3].system.price.value
      ),
      step: "any",
      field: "system.price.value",
      document: (
        /*$context*/
        ctx[3].item
      ),
      disabled: !/*$context*/
      ctx[3].editable,
      selectOnFocus: true,
      cssClass: "large-value"
    }
  });
  select = new Select({
    props: {
      value: (
        /*$context*/
        ctx[3].system.price.denomination
      ),
      field: "system.price.denomination",
      document: (
        /*$context*/
        ctx[3].item
      ),
      disabled: !/*$context*/
      ctx[3].editable,
      $$slots: { default: [create_default_slot_4$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      insert(target, t2, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*$context*/
      8) numberinput_changes.id = /*$context*/
      ctx2[3].appId + "-" + /*$context*/
      ctx2[3].item.id + "-price";
      if (dirty & /*$context*/
      8) numberinput_changes.value = /*$context*/
      ctx2[3].system.price.value;
      if (dirty & /*$context*/
      8) numberinput_changes.document = /*$context*/
      ctx2[3].item;
      if (dirty & /*$context*/
      8) numberinput_changes.disabled = !/*$context*/
      ctx2[3].editable;
      numberinput.$set(numberinput_changes);
      const select_changes = {};
      if (dirty & /*$context*/
      8) select_changes.value = /*$context*/
      ctx2[3].system.price.denomination;
      if (dirty & /*$context*/
      8) select_changes.document = /*$context*/
      ctx2[3].item;
      if (dirty & /*$context*/
      8) select_changes.disabled = !/*$context*/
      ctx2[3].editable;
      if (dirty & /*$$scope, $context*/
      262152) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(numberinput, detaching);
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_8$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[7]("DND5E.Unidentified.Value")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_4$7(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[3].config.currencies
      ),
      labelProp: "abbreviation"
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      8) selectoptions_changes.data = /*$context*/
      ctx2[3].config.currencies;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_if_block_4$6(ctx) {
  let h4;
  let t3;
  let ol;
  let t4;
  let t5;
  let ol_inert_value;
  let if_block0 = (
    /*$context*/
    ctx[3].labels.save && create_if_block_6$3(ctx)
  );
  let if_block1 = (
    /*$context*/
    ctx[3].labels.toHit && create_if_block_5$5(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*$context*/
    ctx[3].labels.derivedDamage ?? []
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i2));
  }
  return {
    c() {
      h4 = element("h4");
      h4.textContent = `${/*localize*/
      ctx[7]("DND5E.Attack")}/${/*localize*/
      ctx[7]("DND5E.Damage")}`;
      t3 = space();
      ol = element("ol");
      if (if_block0) if_block0.c();
      t4 = space();
      if (if_block1) if_block1.c();
      t5 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h4, "class", "properties-header");
      attr(ol, "class", "properties-list animate-inert");
      ol.inert = ol_inert_value = /*$context*/
      ctx[3].concealDetails;
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      insert(target, t3, anchor);
      insert(target, ol, anchor);
      if (if_block0) if_block0.m(ol, null);
      append(ol, t4);
      if (if_block1) if_block1.m(ol, null);
      append(ol, t5);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[3].labels.save
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$3(ctx2);
          if_block0.c();
          if_block0.m(ol, t4);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$context*/
        ctx2[3].labels.toHit
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$5(ctx2);
          if_block1.c();
          if_block1.m(ol, t5);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$context*/
      8) {
        each_value_1 = ensure_array_like(
          /*$context*/
          ctx2[3].labels.derivedDamage ?? []
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ol, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*$context*/
      8 && ol_inert_value !== (ol_inert_value = /*$context*/
      ctx2[3].concealDetails)) {
        ol.inert = ol_inert_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
        detach(t3);
        detach(ol);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_6$3(ctx) {
  let li;
  let t_value = (
    /*$context*/
    ctx[3].labels.save + ""
  );
  let t2;
  return {
    c() {
      li = element("li");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t_value !== (t_value = /*$context*/
      ctx2[3].labels.save + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block_5$5(ctx) {
  let li;
  let t0_value = (
    /*$context*/
    ctx[3].labels.toHit + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*localize*/
    ctx[7]("DND5E.ToHit") + ""
  );
  let t2;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t0_value !== (t0_value = /*$context*/
      ctx2[3].labels.toHit + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_each_block_1$3(ctx) {
  let li;
  let t0_value = (
    /*label*/
    ctx[15] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t0);
      append(li, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t0_value !== (t0_value = /*label*/
      ctx2[15] + "")) set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block_3$b(ctx) {
  let section;
  let h4;
  let t1;
  let ol;
  let ol_inert_value;
  let each_value = ensure_array_like(
    /*$context*/
    ctx[3].itemProperties
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$a(get_each_context$a(ctx, each_value, i2));
  }
  return {
    c() {
      section = element("section");
      h4 = element("h4");
      h4.textContent = `${/*localize*/
      ctx[7]("DND5E.Properties")}`;
      t1 = space();
      ol = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h4, "class", "properties-header");
      attr(ol, "class", "properties-list");
      ol.inert = ol_inert_value = /*$context*/
      ctx[3].concealDetails;
      attr(section, "class", "inert-animation-container");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h4);
      append(section, t1);
      append(section, ol);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[3].itemProperties
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$a(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ol, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$context*/
      8 && ol_inert_value !== (ol_inert_value = /*$context*/
      ctx2[3].concealDetails)) {
        ol.inert = ol_inert_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$a(ctx) {
  let li;
  let t_value = (
    /*prop*/
    ctx[11] + ""
  );
  let t2;
  return {
    c() {
      li = element("li");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      8 && t_value !== (t_value = /*prop*/
      ctx2[11] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_default_slot_3$8(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[3].item
      ),
      field: TidyFlags.section.prop,
      id: (
        /*inputId*/
        ctx[10]
      ),
      placeholder: (
        /*localize*/
        ctx[7]("TIDY5E.Section.Default")
      ),
      value: TidyFlags.section.get(
        /*$context*/
        ctx[3].item
      ) ?? "",
      selectOnFocus: true,
      title: (
        /*localize*/
        ctx[7]("TIDY5E.Section.Tooltip")
      )
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      8) textinput_changes.document = /*$context*/
      ctx2[3].item;
      if (dirty & /*inputId*/
      1024) textinput_changes.id = /*inputId*/
      ctx2[10];
      if (dirty & /*$context*/
      8) textinput_changes.value = TidyFlags.section.get(
        /*$context*/
        ctx2[3].item
      ) ?? "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_2$8(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[3].item
      ),
      field: TidyFlags.actionSection.prop,
      id: (
        /*inputId*/
        ctx[10]
      ),
      placeholder: (
        /*localize*/
        ctx[7]("TIDY5E.Section.Default")
      ),
      value: TidyFlags.actionSection.get(
        /*$context*/
        ctx[3].item
      ) ?? "",
      selectOnFocus: true,
      title: (
        /*localize*/
        ctx[7]("TIDY5E.Section.ActionTooltip")
      )
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      8) textinput_changes.document = /*$context*/
      ctx2[3].item;
      if (dirty & /*inputId*/
      1024) textinput_changes.id = /*inputId*/
      ctx2[10];
      if (dirty & /*$context*/
      8) textinput_changes.value = TidyFlags.actionSection.get(
        /*$context*/
        ctx2[3].item
      ) ?? "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_2$h(ctx) {
  let rerenderafterformsubmission;
  let current;
  rerenderafterformsubmission = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[3].enriched.unidentified
      ),
      $$slots: { default: [create_default_slot_1$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(rerenderafterformsubmission.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rerenderafterformsubmission, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rerenderafterformsubmission_changes = {};
      if (dirty & /*$context*/
      8) rerenderafterformsubmission_changes.andOnValueChange = /*$context*/
      ctx2[3].enriched.unidentified;
      if (dirty & /*$$scope, $context*/
      262152) {
        rerenderafterformsubmission_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission.$set(rerenderafterformsubmission_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rerenderafterformsubmission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rerenderafterformsubmission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rerenderafterformsubmission, detaching);
    }
  };
}
function create_if_block_1$l(ctx) {
  let itemdescriptions;
  let current;
  itemdescriptions = new ItemDescriptions({
    props: { renderDescriptions: !/*editing*/
    ctx[0] }
  });
  itemdescriptions.$on(
    "edit",
    /*edit_handler*/
    ctx[8]
  );
  return {
    c() {
      create_component(itemdescriptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemdescriptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemdescriptions_changes = {};
      if (dirty & /*editing*/
      1) itemdescriptions_changes.renderDescriptions = !/*editing*/
      ctx2[0];
      itemdescriptions.$set(itemdescriptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemdescriptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemdescriptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemdescriptions, detaching);
    }
  };
}
function create_default_slot_1$a(ctx) {
  let div;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[3].enriched.unidentified
      ),
      editable: (
        /*$context*/
        ctx[3].editable
      ),
      target: "system.unidentified.description"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "flexrow");
      attr(div, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sheeteditor, div, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[3].activateEditors(div)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      8) sheeteditor_changes.content = /*$context*/
      ctx2[3].enriched.unidentified;
      if (dirty & /*$context*/
      8) sheeteditor_changes.editable = /*$context*/
      ctx2[3].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$A(ctx) {
  let rerenderafterformsubmission;
  let current;
  rerenderafterformsubmission = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*valueToEdit*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot$u] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(rerenderafterformsubmission.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rerenderafterformsubmission, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rerenderafterformsubmission_changes = {};
      if (dirty & /*valueToEdit*/
      2) rerenderafterformsubmission_changes.andOnValueChange = /*valueToEdit*/
      ctx2[1];
      if (dirty & /*$$scope, valueToEdit, fieldToEdit*/
      262150) {
        rerenderafterformsubmission_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission.$set(rerenderafterformsubmission_changes);
    },
    i(local) {
      if (current) return;
      transition_in(rerenderafterformsubmission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rerenderafterformsubmission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rerenderafterformsubmission, detaching);
    }
  };
}
function create_default_slot$u(ctx) {
  let article;
  let opensheeteditor;
  let current;
  let mounted;
  let dispose;
  opensheeteditor = new OpenSheetEditor({
    props: {
      content: (
        /*valueToEdit*/
        ctx[1]
      ),
      target: (
        /*fieldToEdit*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      article = element("article");
      create_component(opensheeteditor.$$.fragment);
      attr(article, "class", "editor-container svelte-1reuv8e");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      mount_component(opensheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*onEditorActivation*/
          ctx[5].call(null, article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const opensheeteditor_changes = {};
      if (dirty & /*valueToEdit*/
      2) opensheeteditor_changes.content = /*valueToEdit*/
      ctx2[1];
      if (dirty & /*fieldToEdit*/
      4) opensheeteditor_changes.target = /*fieldToEdit*/
      ctx2[2];
      opensheeteditor.$set(opensheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(opensheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(opensheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(opensheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1g(ctx) {
  let div2;
  let div1;
  let t0;
  let t1;
  let t2;
  let div0;
  let itemformgroup0;
  let t3;
  let itemformgroup1;
  let t4;
  let verticallineseparator;
  let t5;
  let show_if;
  let current_block_type_index;
  let if_block3;
  let t6;
  let if_block4_anchor;
  let current;
  let if_block0 = (
    /*$context*/
    ctx[3].isPhysical && create_if_block_7$3(ctx)
  );
  let if_block1 = (
    /*$context*/
    (ctx[3].labels.toHit || /*$context*/
    ctx[3].labels.derivedDamage) && create_if_block_4$6(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[3].itemProperties.length && create_if_block_3$b(ctx)
  );
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[7]("TIDY5E.Section.Label")
      ),
      field: TidyFlags.section.prop,
      cssClass: "section",
      $$slots: {
        default: [
          create_default_slot_3$8,
          ({ inputId }) => ({ 10: inputId }),
          ({ inputId }) => inputId ? 1024 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[7]("TIDY5E.Section.ActionLabel")
      ),
      field: TidyFlags.actionSection.prop,
      cssClass: "section",
      $$slots: {
        default: [
          create_default_slot_2$8,
          ({ inputId }) => ({ 10: inputId }),
          ({ inputId }) => inputId ? 1024 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  verticallineseparator = new VerticalLineSeparator({});
  const if_block_creators = [create_if_block_1$l, create_if_block_2$h];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*$context*/
    8) show_if = null;
    if (show_if == null) show_if = !!(FoundryAdapter.userIsGm() || /*$context*/
    ctx2[3].isIdentified);
    if (show_if) return 0;
    if (
      /*$context*/
      ctx2[3].editable || /*$context*/
      ctx2[3].system.unidentified.description
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
    if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block4 = (
    /*editing*/
    ctx[0] && create_if_block$A(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      div0 = element("div");
      create_component(itemformgroup0.$$.fragment);
      t3 = space();
      create_component(itemformgroup1.$$.fragment);
      t4 = space();
      create_component(verticallineseparator.$$.fragment);
      t5 = space();
      if (if_block3) if_block3.c();
      t6 = space();
      if (if_block4) if_block4.c();
      if_block4_anchor = empty();
      attr(div0, "class", "flex-column small-gap");
      attr(div1, "class", "item-properties svelte-1reuv8e");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_SHEET_PROPERTIES);
      attr(div2, "class", "item-description flexrow align-items-stretch small-gap");
      toggle_class(
        div2,
        "hidden",
        /*editing*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      if (if_block0) if_block0.m(div1, null);
      append(div1, t0);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t1);
      if (if_block2) if_block2.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      mount_component(itemformgroup0, div0, null);
      append(div0, t3);
      mount_component(itemformgroup1, div0, null);
      append(div2, t4);
      mount_component(verticallineseparator, div2, null);
      append(div2, t5);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      insert(target, t6, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, if_block4_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$context*/
        ctx2[3].isPhysical
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[3].labels.toHit || /*$context*/
        ctx2[3].labels.derivedDamage
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4$6(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$context*/
        ctx2[3].itemProperties.length
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_3$b(ctx2);
          if_block2.c();
          if_block2.m(div1, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      263176) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      263176) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block3) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block3 = if_blocks[current_block_type_index];
          if (!if_block3) {
            if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block3.c();
          } else {
            if_block3.p(ctx2, dirty);
          }
          transition_in(if_block3, 1);
          if_block3.m(div2, null);
        } else {
          if_block3 = null;
        }
      }
      if (!current || dirty & /*editing*/
      1) {
        toggle_class(
          div2,
          "hidden",
          /*editing*/
          ctx2[0]
        );
      }
      if (
        /*editing*/
        ctx2[0]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*editing*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$A(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(verticallineseparator.$$.fragment, local);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(verticallineseparator.$$.fragment, local);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t6);
        detach(if_block4_anchor);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      destroy_component(itemformgroup0);
      destroy_component(itemformgroup1);
      destroy_component(verticallineseparator);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block4) if_block4.d(detaching);
    }
  };
}
function instance$1g($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  function onEditorActivation(node) {
    if (editorIsActive) {
      $$invalidate(0, editing = false);
      editorIsActive = false;
      return;
    }
    $context.activateEditors(node, { bindSecrets: false });
    editorIsActive = true;
  }
  let editing = false;
  let editorIsActive = false;
  let valueToEdit;
  let fieldToEdit;
  function edit(value, field) {
    $$invalidate(1, valueToEdit = value);
    $$invalidate(2, fieldToEdit = field);
    $$invalidate(0, editing = true);
  }
  const localize = FoundryAdapter.localize;
  const edit_handler = (ev) => edit(ev.detail.valueToEdit, ev.detail.fieldToEdit);
  return [
    editing,
    valueToEdit,
    fieldToEdit,
    $context,
    context,
    onEditorActivation,
    edit,
    localize,
    edit_handler
  ];
}
class ItemDescriptionWithSidebarTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {});
  }
}
function create_fragment$1f(ctx) {
  let div1;
  let label0;
  let t0_value = (
    /*localize*/
    ctx[4]("DND5E.HitPoints") + ""
  );
  let t0;
  let label0_for_value;
  let t1;
  let div0;
  let numberinput0;
  let t2;
  let span;
  let t4;
  let numberinput1;
  let t5;
  let numberinput2;
  let t6;
  let div3;
  let label1;
  let t7_value = (
    /*localize*/
    ctx[4]("DND5E.HealthConditions") + ""
  );
  let t7;
  let label1_for_value;
  let t8;
  let div2;
  let textinput;
  let current;
  numberinput0 = new NumberInput({
    props: {
      id: (
        /*$appId*/
        ctx[0] + "-system.hp.value"
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.hp.value",
      value: (
        /*$context*/
        ctx[1].item.system.hp.value
      ),
      placeholder: "0"
    }
  });
  numberinput1 = new NumberInput({
    props: {
      id: (
        /*$appId*/
        ctx[0] + "-system.hp.max"
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.hp.max",
      value: (
        /*$context*/
        ctx[1].item.system.hp.max
      ),
      placeholder: "0"
    }
  });
  numberinput2 = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.hp.dt",
      id: (
        /*$appId*/
        ctx[0] + "-system.hp.dt"
      ),
      placeholder: (
        /*localize*/
        ctx[4]("DND5E.Threshold")
      ),
      value: (
        /*$context*/
        ctx[1].item.system.hp.dt
      )
    }
  });
  textinput = new TextInput$1({
    props: {
      id: (
        /*$appId*/
        ctx[0] + "-system.hp.conditions"
      ),
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.hp.conditions",
      value: (
        /*$context*/
        ctx[1].item.system.hp.conditions
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      create_component(numberinput0.$$.fragment);
      t2 = space();
      span = element("span");
      span.textContent = "/";
      t4 = space();
      create_component(numberinput1.$$.fragment);
      t5 = space();
      create_component(numberinput2.$$.fragment);
      t6 = space();
      div3 = element("div");
      label1 = element("label");
      t7 = text(t7_value);
      t8 = space();
      div2 = element("div");
      create_component(textinput.$$.fragment);
      attr(label0, "for", label0_for_value = /*$appId*/
      ctx[0] + "-system.hp.value");
      attr(span, "class", "sep");
      attr(div0, "class", "form-fields");
      attr(div1, "class", "form-group");
      attr(label1, "for", label1_for_value = /*$appId*/
      ctx[0] + "-system.hp.conditions");
      attr(div2, "class", "form-fields");
      attr(div3, "class", "form-group");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, label0);
      append(label0, t0);
      append(div1, t1);
      append(div1, div0);
      mount_component(numberinput0, div0, null);
      append(div0, t2);
      append(div0, span);
      append(div0, t4);
      mount_component(numberinput1, div0, null);
      append(div0, t5);
      mount_component(numberinput2, div0, null);
      insert(target, t6, anchor);
      insert(target, div3, anchor);
      append(div3, label1);
      append(label1, t7);
      append(div3, t8);
      append(div3, div2);
      mount_component(textinput, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$appId*/
      1 && label0_for_value !== (label0_for_value = /*$appId*/
      ctx2[0] + "-system.hp.value")) {
        attr(label0, "for", label0_for_value);
      }
      const numberinput0_changes = {};
      if (dirty & /*$appId*/
      1) numberinput0_changes.id = /*$appId*/
      ctx2[0] + "-system.hp.value";
      if (dirty & /*$context*/
      2) numberinput0_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) numberinput0_changes.value = /*$context*/
      ctx2[1].item.system.hp.value;
      numberinput0.$set(numberinput0_changes);
      const numberinput1_changes = {};
      if (dirty & /*$appId*/
      1) numberinput1_changes.id = /*$appId*/
      ctx2[0] + "-system.hp.max";
      if (dirty & /*$context*/
      2) numberinput1_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) numberinput1_changes.value = /*$context*/
      ctx2[1].item.system.hp.max;
      numberinput1.$set(numberinput1_changes);
      const numberinput2_changes = {};
      if (dirty & /*$context*/
      2) numberinput2_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$appId*/
      1) numberinput2_changes.id = /*$appId*/
      ctx2[0] + "-system.hp.dt";
      if (dirty & /*$context*/
      2) numberinput2_changes.value = /*$context*/
      ctx2[1].item.system.hp.dt;
      numberinput2.$set(numberinput2_changes);
      if (!current || dirty & /*$appId*/
      1 && label1_for_value !== (label1_for_value = /*$appId*/
      ctx2[0] + "-system.hp.conditions")) {
        attr(label1, "for", label1_for_value);
      }
      const textinput_changes = {};
      if (dirty & /*$appId*/
      1) textinput_changes.id = /*$appId*/
      ctx2[0] + "-system.hp.conditions";
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].item.system.hp.conditions;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(numberinput2.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(numberinput2.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t6);
        detach(div3);
      }
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(numberinput2);
      destroy_component(textinput);
    }
  };
}
function instance$1f($$self, $$props, $$invalidate) {
  let $appId;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  component_subscribe($$self, appId, (value) => $$invalidate(0, $appId = value));
  const localize = FoundryAdapter.localize;
  return [$appId, $context, context, appId, localize];
}
class ItemMountable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {});
  }
}
function get_each_context$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$9(ctx) {
  let optgroup;
  let selectoptions;
  let optgroup_label_value;
  let current;
  selectoptions = new SelectOptions({ props: { data: (
    /*group*/
    ctx[4].types
  ) } });
  return {
    c() {
      optgroup = element("optgroup");
      create_component(selectoptions.$$.fragment);
      attr(optgroup, "label", optgroup_label_value = /*localize*/
      ctx[2](
        /*group*/
        ctx[4].label
      ));
    },
    m(target, anchor) {
      insert(target, optgroup, anchor);
      mount_component(selectoptions, optgroup, null);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*group*/
      ctx2[4].types;
      selectoptions.$set(selectoptions_changes);
      if (!current || dirty & /*$context*/
      1 && optgroup_label_value !== (optgroup_label_value = /*localize*/
      ctx2[2](
        /*group*/
        ctx2[4].label
      ))) {
        attr(optgroup, "label", optgroup_label_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(optgroup);
      }
      destroy_component(selectoptions);
    }
  };
}
function create_default_slot_14$1(ctx) {
  let option;
  let t0;
  let optgroup;
  let selectoptions0;
  let t1;
  let t2;
  let selectoptions1;
  let current;
  selectoptions0 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.armorTypes
      )
    }
  });
  let each_value = ensure_array_like(
    /*$context*/
    ctx[0].customEquipmentTypeGroups
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$9(get_each_context$9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  selectoptions1 = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.miscEquipmentTypes
      )
    }
  });
  return {
    c() {
      option = element("option");
      t0 = space();
      optgroup = element("optgroup");
      create_component(selectoptions0.$$.fragment);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      create_component(selectoptions1.$$.fragment);
      option.__value = "";
      set_input_value(option, option.__value);
      attr(
        optgroup,
        "label",
        /*localize*/
        ctx[2]("DND5E.Armor")
      );
    },
    m(target, anchor) {
      insert(target, option, anchor);
      insert(target, t0, anchor);
      insert(target, optgroup, anchor);
      mount_component(selectoptions0, optgroup, null);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      mount_component(selectoptions1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions0_changes = {};
      if (dirty & /*$context*/
      1) selectoptions0_changes.data = /*$context*/
      ctx2[0].config.armorTypes;
      selectoptions0.$set(selectoptions0_changes);
      if (dirty & /*localize, $context*/
      5) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[0].customEquipmentTypeGroups
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const selectoptions1_changes = {};
      if (dirty & /*$context*/
      1) selectoptions1_changes.data = /*$context*/
      ctx2[0].config.miscEquipmentTypes;
      selectoptions1.$set(selectoptions1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions0.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(selectoptions1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions0.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(selectoptions1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(option);
        detach(t0);
        detach(optgroup);
        detach(t1);
        detach(t2);
      }
      destroy_component(selectoptions0);
      destroy_each(each_blocks, detaching);
      destroy_component(selectoptions1, detaching);
    }
  };
}
function create_default_slot_13$2(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.type.value
      ),
      field: "system.type.value",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_14$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.value;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      129) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_12$2(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].baseItems
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].baseItems;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_11$3(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.type.baseItem
      ),
      field: "system.type.baseItem",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_12$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.baseItem;
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      129) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_5$4(ctx) {
  let itemformgroup0;
  let t2;
  let itemformgroup1;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Attunement")
      ),
      field: "system.attunement",
      $$slots: {
        default: [
          create_default_slot_9$4,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Proficiency")
      ),
      $$slots: { default: [create_default_slot_7$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      create_component(itemformgroup1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, $context*/
      129) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
    }
  };
}
function create_default_slot_10$4(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.attunementTypes
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.AttunementNone")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.attunementTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_9$4(ctx) {
  let checkbox;
  let t2;
  let select;
  let current;
  checkbox = new Checkbox({
    props: {
      id: `${/*$context*/
      ctx[0].appId}-system-attuned`,
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attuned",
      checked: (
        /*$context*/
        ctx[0].system.attuned
      ),
      disabled: !/*$context*/
      ctx[0].editable || !/*$context*/
      ctx[0].system.attunement,
      title: (
        /*localize*/
        ctx[2]("DND5E.AttunementAttuned")
      )
    }
  });
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attunement",
      value: (
        /*$context*/
        ctx[0].system.attunement
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_10$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      insert(target, t2, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.id = `${/*$context*/
      ctx2[0].appId}-system-attuned`;
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.attuned;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable || !/*$context*/
      ctx2[0].system.attunement;
      checkbox.$set(checkbox_changes);
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.attunement;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      129) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(checkbox, detaching);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_8$4(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.weaponAndArmorProficiencyLevels
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.Automatic")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.weaponAndArmorProficiencyLevels;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_7$4(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.proficient",
      value: (
        /*$context*/
        ctx[0].system.proficient
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_8$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.proficient;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      129) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_6$4(ctx) {
  let itemproperties;
  let current;
  itemproperties = new ItemProperties({});
  return {
    c() {
      create_component(itemproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemproperties, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemproperties, detaching);
    }
  };
}
function create_if_block_3$a(ctx) {
  let itemformgroup;
  let t2;
  let if_block_anchor;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ArmorClass")
      ),
      field: "system.armor.value",
      $$slots: {
        default: [
          create_default_slot_5$6,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[0].properties.mgc.selected && create_if_block_4$5(ctx)
  );
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
      if (
        /*$context*/
        ctx2[0].properties.mgc.selected
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(itemformgroup, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot_5$6(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].source.armor.value
      ),
      step: "1",
      field: "system.armor.value",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].source.armor.value;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_4$5(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.MagicalBonus")
      ),
      field: "system.armor.magicalBonus",
      $$slots: {
        default: [
          create_default_slot_4$6,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_4$6(ctx) {
  let div;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.armor.magicalBonus
      ),
      field: "system.armor.magicalBonus",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      min: "0",
      step: "1",
      placeholder: "0"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.armor.magicalBonus;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_if_block_2$g(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemEquipmentDexMod")
      ),
      field: "system.armor.dex",
      $$slots: {
        default: [
          create_default_slot_3$7,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_3$7(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      step: "1",
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.Unlimited")
      ),
      field: "system.armor.dex",
      document: (
        /*$context*/
        ctx[0].item
      ),
      value: (
        /*$context*/
        ctx[0].system.armor.dex
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.armor.dex;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_1$k(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      field: "system.strength",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemRequiredStr")
      ),
      $$slots: {
        default: [
          create_default_slot_2$7,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_2$7(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      step: "1",
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.None")
      ),
      field: "system.strength",
      document: (
        /*$context*/
        ctx[0].item
      ),
      value: (
        /*$context*/
        ctx[0].system.strength
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.strength;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block$z(ctx) {
  let itemmountable;
  let t2;
  let itemformgroup;
  let current;
  itemmountable = new ItemMountable({});
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Speed")
      ),
      $$slots: { default: [create_default_slot_1$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemmountable.$$.fragment);
      t2 = space();
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemmountable, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, $context*/
      129) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemmountable.$$.fragment, local);
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemmountable.$$.fragment, local);
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemmountable, detaching);
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_1$9(ctx) {
  let div;
  let numberinput;
  let t0;
  let span;
  let t2;
  let textinput;
  let current;
  numberinput = new NumberInput({
    props: {
      placeholder: "0",
      value: (
        /*$context*/
        ctx[0].system.speed.value
      ),
      field: "system.speed.value",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  textinput = new TextInput$1({
    props: {
      field: "system.speed.conditions",
      document: (
        /*$context*/
        ctx[0].item
      ),
      value: (
        /*$context*/
        ctx[0].system.speed.conditions
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[2]("DND5E.FeetAbbr")}`;
      t2 = space();
      create_component(textinput.$$.fragment);
      attr(span, "class", "sep");
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      append(div, t0);
      append(div, span);
      append(div, t2);
      mount_component(textinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.speed.value;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.speed.conditions;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
      destroy_component(textinput);
    }
  };
}
function create_default_slot$t(ctx) {
  let h30;
  let t1;
  let itemformgroup0;
  let t2;
  let itemformgroup1;
  let t3;
  let t4;
  let itemformgroup2;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let h31;
  let t11;
  let itemactivation;
  let t12;
  let h32;
  let t14;
  let itemaction;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      field: "system.type.value",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemEquipmentType")
      ),
      $$slots: {
        default: [
          create_default_slot_13$2,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      field: "system.baseItem",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemEquipmentBase")
      ),
      $$slots: {
        default: [
          create_default_slot_11$3,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = !/*$context*/
  ctx[0].system.isMountable && create_if_block_5$4(ctx);
  itemformgroup2 = new ItemFormGroup({
    props: {
      cssClass: "stacked weapon-properties",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemEquipmentProperties")
      ),
      $$slots: { default: [create_default_slot_6$4] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$context*/
    (ctx[0].system.isArmor || /*$context*/
    ctx[0].system.isMountable) && create_if_block_3$a(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[0].hasDexModifier && create_if_block_2$g(ctx)
  );
  let if_block3 = (
    /*$context*/
    ctx[0].system.isArmor && create_if_block_1$k(ctx)
  );
  let if_block4 = (
    /*$context*/
    ctx[0].system.isMountable && create_if_block$z(ctx)
  );
  itemactivation = new ItemActivation({});
  itemaction = new ItemAction({});
  return {
    c() {
      h30 = element("h3");
      h30.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemEquipmentDetails")}`;
      t1 = space();
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      create_component(itemformgroup1.$$.fragment);
      t3 = space();
      if (if_block0) if_block0.c();
      t4 = space();
      create_component(itemformgroup2.$$.fragment);
      t5 = space();
      if (if_block1) if_block1.c();
      t6 = space();
      if (if_block2) if_block2.c();
      t7 = space();
      if (if_block3) if_block3.c();
      t8 = space();
      if (if_block4) if_block4.c();
      t9 = space();
      h31 = element("h3");
      h31.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemEquipmentUsage")}`;
      t11 = space();
      create_component(itemactivation.$$.fragment);
      t12 = space();
      h32 = element("h3");
      h32.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemEquipmentAction")}`;
      t14 = space();
      create_component(itemaction.$$.fragment);
      attr(h30, "class", "form-header");
      attr(h31, "class", "form-header");
      attr(h32, "class", "form-header");
    },
    m(target, anchor) {
      insert(target, h30, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t3, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t4, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t5, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t7, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block4) if_block4.m(target, anchor);
      insert(target, t9, anchor);
      insert(target, h31, anchor);
      insert(target, t11, anchor);
      mount_component(itemactivation, target, anchor);
      insert(target, t12, anchor);
      insert(target, h32, anchor);
      insert(target, t14, anchor);
      mount_component(itemaction, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      137) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      if (!/*$context*/
      ctx2[0].system.isMountable) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t4.parentNode, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope*/
      128) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      if (
        /*$context*/
        ctx2[0].system.isArmor || /*$context*/
        ctx2[0].system.isMountable
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$a(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t6.parentNode, t6);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].hasDexModifier
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$g(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t7.parentNode, t7);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].system.isArmor
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$k(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t8.parentNode, t8);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].system.isMountable
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$z(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t9.parentNode, t9);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(itemactivation.$$.fragment, local);
      transition_in(itemaction.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(itemactivation.$$.fragment, local);
      transition_out(itemaction.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h30);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(t9);
        detach(h31);
        detach(t11);
        detach(t12);
        detach(h32);
        detach(t14);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemformgroup2, detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      if (if_block3) if_block3.d(detaching);
      if (if_block4) if_block4.d(detaching);
      destroy_component(itemactivation, detaching);
      destroy_component(itemaction, detaching);
    }
  };
}
function create_fragment$1e(ctx) {
  let contentconcealer;
  let current;
  contentconcealer = new ContentConcealer({
    props: {
      conceal: (
        /*$context*/
        ctx[0].concealDetails
      ),
      $$slots: { default: [create_default_slot$t] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(contentconcealer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contentconcealer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const contentconcealer_changes = {};
      if (dirty & /*$context*/
      1) contentconcealer_changes.conceal = /*$context*/
      ctx2[0].concealDetails;
      if (dirty & /*$$scope, $context*/
      129) {
        contentconcealer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contentconcealer.$set(contentconcealer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contentconcealer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contentconcealer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contentconcealer, detaching);
    }
  };
}
function instance$1e($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemEquipmentDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});
  }
}
function get_if_ctx$3(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*$context*/
    child_ctx[0].config.featureTypes[
      /*$context*/
      child_ctx[0].system.type.value
    ]?.label
  );
  child_ctx[4] = constants_0;
  return child_ctx;
}
function create_default_slot_10$3(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.featureTypes
      ),
      labelProp: "label",
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.featureTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_9$3(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.value",
      value: (
        /*$context*/
        ctx[0].system.type.value
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_10$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.value;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_2$f(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemFeatureSubtype", { category: (
          /*category*/
          ctx[4]
        ) })
      ),
      field: "system.type.subtype",
      $$slots: {
        default: [
          create_default_slot_7$3,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$context*/
      1) itemformgroup_changes.labelText = /*localize*/
      ctx2[2]("DND5E.ItemFeatureSubtype", { category: (
        /*category*/
        ctx2[4]
      ) });
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_8$3(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].itemSubtypes
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].itemSubtypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_7$3(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.subtype",
      value: (
        /*$context*/
        ctx[0].system.type.subtype
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_8$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.subtype;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_6$3(ctx) {
  let itemproperties;
  let current;
  itemproperties = new ItemProperties({});
  return {
    c() {
      create_component(itemproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemproperties, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemproperties, detaching);
    }
  };
}
function create_default_slot_5$5(ctx) {
  let numberinput;
  let t0;
  let p2;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.prerequisites.level",
      value: (
        /*$context*/
        ctx[0].system.prerequisites.level
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      step: "1"
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[2]("DND5E.Prerequisites.FIELDS.prerequisites.level.hint")}`;
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.prerequisites.level;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p2);
      }
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_1$j(ctx) {
  let h3;
  let t1;
  let itemformgroup0;
  let t2;
  let itemformgroup1;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Enchantment.FIELDS.enchantment.items.max.label")
      ),
      field: "system.enchantment.items.max",
      $$slots: {
        default: [
          create_default_slot_4$5,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Enchantment.FIELDS.enchantment.items.period.label")
      ),
      field: "system.enchantment.items.period",
      $$slots: {
        default: [
          create_default_slot_2$6,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[2]("DND5E.Enchantment.Label")}`;
      t1 = space();
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      create_component(itemformgroup1.$$.fragment);
      attr(h3, "class", "form-header");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(t2);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
    }
  };
}
function create_default_slot_4$5(ctx) {
  let textinput;
  let t0;
  let p2;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.enchantment.items.max",
      value: (
        /*$context*/
        ctx[0].source.enchantment?.items.max
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[2]("DND5E.Enchantment.FIELDS.enchantment.items.max.hint")}`;
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].source.enchantment?.items.max;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p2);
      }
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_3$6(ctx) {
  let selectoptions;
  let t0;
  let p2;
  let current;
  selectoptions = new SelectOptions({
    props: {
      blank: (
        /*localize*/
        ctx[2]("DND5E.UsesPeriods.Never")
      ),
      data: (
        /*$context*/
        ctx[0].config.enchantmentPeriods
      ),
      labelProp: "label"
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[2]("DND5E.Enchantment.FIELDS.enchantment.items.period.hint")}`;
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.enchantmentPeriods;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(p2);
      }
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_2$6(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.enchantment.items.period",
      value: (
        /*$context*/
        ctx[0].system.enchantment?.items.period
      ),
      blankValue: "",
      $$slots: { default: [create_default_slot_3$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.enchantment?.items.period;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block$y(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      cssClass: "recharge",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.FeatureActionRecharge")
      ),
      field: "system.recharge.value",
      $$slots: {
        default: [
          create_default_slot$s,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      41) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_1$8(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("DND5E.Charged") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$s(ctx) {
  let div;
  let span;
  let t1;
  let numberinput;
  let t2;
  let checkbox;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.recharge.value",
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.FeatureRechargeResult")
      ),
      value: (
        /*$context*/
        ctx[0].system.recharge.value
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  checkbox = new Checkbox({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-recharge-charged"
      ),
      labelCssClass: "checkbox",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.recharge.charged",
      checked: (
        /*$context*/
        ctx[0].system.recharge.charged
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      greenCheckboxWidthOverride: (
        /*localize*/
        ctx[2]("DND5E.Charged").length + 4 + "ch"
      ),
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[2]("DND5E.FeatureRechargeOn")}`;
      t1 = space();
      create_component(numberinput.$$.fragment);
      t2 = space();
      create_component(checkbox.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      mount_component(numberinput, div, null);
      append(div, t2);
      mount_component(checkbox, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.recharge.value;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.id = /*$context*/
      ctx2[0].appId + "-system-recharge-charged";
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.recharge.charged;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope*/
      32) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
      destroy_component(checkbox);
    }
  };
}
function create_fragment$1d(ctx) {
  let h30;
  let t1;
  let itemformgroup0;
  let t2;
  let t3;
  let itemformgroup1;
  let t4;
  let h31;
  let t6;
  let itemformgroup2;
  let t7;
  let t8;
  let h32;
  let t10;
  let itemactivation;
  let t11;
  let t12;
  let h33;
  let t14;
  let itemaction;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemFeatureType")
      ),
      field: "system.type.value",
      $$slots: {
        default: [
          create_default_slot_9$3,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*$context*/
    ctx[0].itemSubtypes && create_if_block_2$f(get_if_ctx$3(ctx))
  );
  itemformgroup1 = new ItemFormGroup({
    props: {
      cssClass: "stacked weapon-properties",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemEquipmentProperties")
      ),
      $$slots: { default: [create_default_slot_6$3] },
      $$scope: { ctx }
    }
  });
  itemformgroup2 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Prerequisites.FIELDS.prerequisites.level.label")
      ),
      field: "system.prerequisites.level",
      $$slots: {
        default: [
          create_default_slot_5$5,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$context*/
    ctx[0].system.isEnchantmentSource && create_if_block_1$j(ctx)
  );
  itemactivation = new ItemActivation({});
  let if_block2 = (
    /*$context*/
    ctx[0].system.activation.type && create_if_block$y(ctx)
  );
  itemaction = new ItemAction({});
  return {
    c() {
      h30 = element("h3");
      h30.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemFeatureDetails")}`;
      t1 = space();
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      if (if_block0) if_block0.c();
      t3 = space();
      create_component(itemformgroup1.$$.fragment);
      t4 = space();
      h31 = element("h3");
      h31.textContent = `${/*localize*/
      ctx[2]("DND5E.Prerequisites.Header")}`;
      t6 = space();
      create_component(itemformgroup2.$$.fragment);
      t7 = space();
      if (if_block1) if_block1.c();
      t8 = space();
      h32 = element("h3");
      h32.textContent = `${/*localize*/
      ctx[2]("DND5E.FeatureUsage")}`;
      t10 = space();
      create_component(itemactivation.$$.fragment);
      t11 = space();
      if (if_block2) if_block2.c();
      t12 = space();
      h33 = element("h3");
      h33.textContent = `${/*localize*/
      ctx[2]("DND5E.FeatureAttack")}`;
      t14 = space();
      create_component(itemaction.$$.fragment);
      attr(h30, "class", "form-header");
      attr(h31, "class", "form-header");
      attr(h32, "class", "form-header");
      attr(h33, "class", "form-header");
    },
    m(target, anchor) {
      insert(target, h30, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t3, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t4, anchor);
      insert(target, h31, anchor);
      insert(target, t6, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t7, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t8, anchor);
      insert(target, h32, anchor);
      insert(target, t10, anchor);
      mount_component(itemactivation, target, anchor);
      insert(target, t11, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t12, anchor);
      insert(target, h33, anchor);
      insert(target, t14, anchor);
      mount_component(itemaction, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      if (
        /*$context*/
        ctx2[0].itemSubtypes
      ) {
        if (if_block0) {
          if_block0.p(get_if_ctx$3(ctx2), dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$f(get_if_ctx$3(ctx2));
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t3.parentNode, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope*/
      32) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      if (
        /*$context*/
        ctx2[0].system.isEnchantmentSource
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$j(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t8.parentNode, t8);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].system.activation.type
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$y(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t12.parentNode, t12);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(if_block1);
      transition_in(itemactivation.$$.fragment, local);
      transition_in(if_block2);
      transition_in(itemaction.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(if_block1);
      transition_out(itemactivation.$$.fragment, local);
      transition_out(if_block2);
      transition_out(itemaction.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h30);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(h31);
        detach(t6);
        detach(t7);
        detach(t8);
        detach(h32);
        detach(t10);
        detach(t11);
        detach(t12);
        detach(h33);
        detach(t14);
      }
      destroy_component(itemformgroup0, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemformgroup2, detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(itemactivation, detaching);
      if (if_block2) if_block2.d(detaching);
      destroy_component(itemaction, detaching);
    }
  };
}
function instance$1d($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemFeatDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});
  }
}
function get_if_ctx$2(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*localize*/
    child_ctx[2]("DND5E.ItemLootSubtype", {
      category: (
        /*$context*/
        child_ctx[0].config.lootTypes[
          /*$context*/
          child_ctx[0].system.type.value
        ]?.label ?? ""
      )
    })
  );
  child_ctx[3] = constants_0;
  return child_ctx;
}
function create_default_slot_5$4(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.lootTypes
      ),
      labelProp: "label",
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.lootTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_4$4(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[4]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.value",
      value: (
        /*$context*/
        ctx[0].system.type.value
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_5$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      16) select_changes.id = /*inputId*/
      ctx2[4];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.value;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block$x(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*subTypeLabel*/
        ctx[3]
      ),
      field: "system.type.subtype",
      $$slots: {
        default: [
          create_default_slot_2$5,
          ({ inputId }) => ({ 4: inputId }),
          ({ inputId }) => inputId ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$context*/
      1) itemformgroup_changes.labelText = /*subTypeLabel*/
      ctx2[3];
      if (dirty & /*$$scope, inputId, $context*/
      49) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_3$5(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].lootSubtypes
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].lootSubtypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[4]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.subtype",
      value: (
        /*$context*/
        ctx[0].system.type.subtype
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      16) select_changes.id = /*inputId*/
      ctx2[4];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.subtype;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let itemproperties;
  let current;
  itemproperties = new ItemProperties({});
  return {
    c() {
      create_component(itemproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemproperties, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemproperties, detaching);
    }
  };
}
function create_default_slot$r(ctx) {
  let h3;
  let t1;
  let itemformgroup0;
  let t2;
  let t3;
  let itemformgroup1;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemLootType")
      ),
      field: "system.type.value",
      $$slots: {
        default: [
          create_default_slot_4$4,
          ({ inputId }) => ({ 4: inputId }),
          ({ inputId }) => inputId ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*$context*/
    ctx[0].lootSubtypes && create_if_block$x(get_if_ctx$2(ctx))
  );
  itemformgroup1 = new ItemFormGroup({
    props: {
      cssClass: "stacked loot-properties",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemLootProperties")
      ),
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemLootDetails")}`;
      t1 = space();
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      t3 = space();
      create_component(itemformgroup1.$$.fragment);
      attr(h3, "class", "form-header");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, t3, anchor);
      mount_component(itemformgroup1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      49) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      if (
        /*$context*/
        ctx2[0].lootSubtypes
      ) {
        if (if_block) {
          if_block.p(get_if_ctx$2(ctx2), dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$x(get_if_ctx$2(ctx2));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope*/
      32) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(if_block);
      transition_in(itemformgroup1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(if_block);
      transition_out(itemformgroup1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(t2);
        detach(t3);
      }
      destroy_component(itemformgroup0, detaching);
      if (if_block) if_block.d(detaching);
      destroy_component(itemformgroup1, detaching);
    }
  };
}
function create_fragment$1c(ctx) {
  let contentconcealer;
  let current;
  contentconcealer = new ContentConcealer({
    props: {
      conceal: (
        /*$context*/
        ctx[0].concealDetails
      ),
      $$slots: { default: [create_default_slot$r] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(contentconcealer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contentconcealer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const contentconcealer_changes = {};
      if (dirty & /*$context*/
      1) contentconcealer_changes.conceal = /*$context*/
      ctx2[0].concealDetails;
      if (dirty & /*$$scope, $context*/
      33) {
        contentconcealer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contentconcealer.$set(contentconcealer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contentconcealer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contentconcealer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contentconcealer, detaching);
    }
  };
}
function instance$1c($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemLootDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});
  }
}
function get_each_context$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_if_block_2$e(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "class", "inline-icon-button hidden-config-button");
      attr(button, "type", "button");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$i(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button hidden-config-button");
      attr(button, "data-action", "movement");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1$3(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.textContent = `${/*localize*/
      ctx[4]("DND5E.None")}`;
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_each_block_1$2(ctx) {
  let li;
  let t_value = (
    /*label*/
    ctx[8] + ""
  );
  let t2;
  return {
    c() {
      li = element("li");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*movementLabels*/
      2 && t_value !== (t_value = /*label*/
      ctx2[8] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block$w(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button hidden-config-button");
      attr(button, "data-action", "senses");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$m(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.textContent = `${/*localize*/
      ctx[4]("DND5E.None")}`;
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_each_block$8(ctx) {
  let li;
  let t_value = (
    /*label*/
    ctx[8] + ""
  );
  let t2;
  return {
    c() {
      li = element("li");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && t_value !== (t_value = /*label*/
      ctx2[8] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment$1b(ctx) {
  let div1;
  let div0;
  let h40;
  let t0_value = (
    /*localize*/
    ctx[4]("DND5E.Type") + ""
  );
  let t0;
  let t1;
  let t2;
  let ol0;
  let li;
  let t3_value = (
    /*$context*/
    ctx[0].item.system.typeLabel + ""
  );
  let t3;
  let t4;
  let h41;
  let t5_value = (
    /*localize*/
    ctx[4]("DND5E.Movement") + ""
  );
  let t5;
  let t6;
  let t7;
  let ol1;
  let t8;
  let h42;
  let t9_value = (
    /*localize*/
    ctx[4]("DND5E.Senses") + ""
  );
  let t9;
  let t10;
  let t11;
  let ol2;
  let t12;
  let verticallineseparator;
  let t13;
  let itemdescription;
  let current;
  let if_block0 = (
    /*$context*/
    ctx[0].editable && create_if_block_2$e(ctx)
  );
  let if_block1 = (
    /*$context*/
    ctx[0].editable && create_if_block_1$i(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*movementLabels*/
    ctx[1]
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i2));
  }
  let each0_else = null;
  if (!each_value_1.length) {
    each0_else = create_else_block_1$3(ctx);
  }
  let if_block2 = (
    /*$context*/
    ctx[0].editable && create_if_block$w(ctx)
  );
  let each_value = ensure_array_like(
    /*$context*/
    ctx[0].item.system.sensesLabels
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$8(get_each_context$8(ctx, each_value, i2));
  }
  let each1_else = null;
  if (!each_value.length) {
    each1_else = create_else_block$m(ctx);
  }
  verticallineseparator = new VerticalLineSeparator({});
  itemdescription = new ItemDescriptionTab({});
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h40 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      ol0 = element("ol");
      li = element("li");
      t3 = text(t3_value);
      t4 = space();
      h41 = element("h4");
      t5 = text(t5_value);
      t6 = space();
      if (if_block1) if_block1.c();
      t7 = space();
      ol1 = element("ol");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      if (each0_else) {
        each0_else.c();
      }
      t8 = space();
      h42 = element("h4");
      t9 = text(t9_value);
      t10 = space();
      if (if_block2) if_block2.c();
      t11 = space();
      ol2 = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each1_else) {
        each1_else.c();
      }
      t12 = space();
      create_component(verticallineseparator.$$.fragment);
      t13 = space();
      create_component(itemdescription.$$.fragment);
      attr(h40, "class", "properties-header flex-row justify-content-space-between");
      attr(ol0, "class", "properties-list");
      attr(h41, "class", "properties-header flex-row justify-content-space-between");
      attr(ol1, "class", "properties-list");
      attr(h42, "class", "properties-header flex-row justify-content-space-between");
      attr(ol2, "class", "properties-list");
      attr(div0, "class", "item-properties svelte-8romn0");
      attr(div0, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_SHEET_PROPERTIES);
      attr(div1, "class", "item-description flexrow align-items-stretch small-gap");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h40);
      append(h40, t0);
      append(h40, t1);
      if (if_block0) if_block0.m(h40, null);
      append(div0, t2);
      append(div0, ol0);
      append(ol0, li);
      append(li, t3);
      append(div0, t4);
      append(div0, h41);
      append(h41, t5);
      append(h41, t6);
      if (if_block1) if_block1.m(h41, null);
      append(div0, t7);
      append(div0, ol1);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(ol1, null);
        }
      }
      if (each0_else) {
        each0_else.m(ol1, null);
      }
      append(div0, t8);
      append(div0, h42);
      append(h42, t9);
      append(h42, t10);
      if (if_block2) if_block2.m(h42, null);
      append(div0, t11);
      append(div0, ol2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol2, null);
        }
      }
      if (each1_else) {
        each1_else.m(ol2, null);
      }
      append(div1, t12);
      mount_component(verticallineseparator, div1, null);
      append(div1, t13);
      mount_component(itemdescription, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$context*/
        ctx2[0].editable
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$e(ctx2);
          if_block0.c();
          if_block0.m(h40, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & /*$context*/
      1) && t3_value !== (t3_value = /*$context*/
      ctx2[0].item.system.typeLabel + "")) set_data(t3, t3_value);
      if (
        /*$context*/
        ctx2[0].editable
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$i(ctx2);
          if_block1.c();
          if_block1.m(h41, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*movementLabels, localize*/
      18) {
        each_value_1 = ensure_array_like(
          /*movementLabels*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_1$2(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(ol1, null);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_1.length;
        if (!each_value_1.length && each0_else) {
          each0_else.p(ctx2, dirty);
        } else if (!each_value_1.length) {
          each0_else = create_else_block_1$3(ctx2);
          each0_else.c();
          each0_else.m(ol1, null);
        } else if (each0_else) {
          each0_else.d(1);
          each0_else = null;
        }
      }
      if (
        /*$context*/
        ctx2[0].editable
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$w(ctx2);
          if_block2.c();
          if_block2.m(h42, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & /*$context, localize*/
      17) {
        each_value = ensure_array_like(
          /*$context*/
          ctx2[0].item.system.sensesLabels
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$8(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ol2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
        if (!each_value.length && each1_else) {
          each1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each1_else = create_else_block$m(ctx2);
          each1_else.c();
          each1_else.m(ol2, null);
        } else if (each1_else) {
          each1_else.d(1);
          each1_else = null;
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(verticallineseparator.$$.fragment, local);
      transition_in(itemdescription.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(verticallineseparator.$$.fragment, local);
      transition_out(itemdescription.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      destroy_each(each_blocks_1, detaching);
      if (each0_else) each0_else.d();
      if (if_block2) if_block2.d();
      destroy_each(each_blocks, detaching);
      if (each1_else) each1_else.d();
      destroy_component(verticallineseparator);
      destroy_component(itemdescription);
    }
  };
}
function instance$1b($$self, $$props, $$invalidate) {
  let movementLabels;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = () => FoundryAdapter.renderItemTypeConfig($context.item);
  const click_handler_1 = () => FoundryAdapter.renderItemMovementConfig($context.item);
  const click_handler_2 = () => FoundryAdapter.renderItemSensesConfig($context.item);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, movementLabels = Object.values($context.item.system.movementLabels));
    }
  };
  return [
    $context,
    movementLabels,
    $settingStore,
    context,
    localize,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class ItemRaceDescriptionTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {});
  }
}
function get_if_ctx$1(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*$context*/
    (child_ctx[0].system.sourceClass ?? "").trim() !== "" && !/*$context*/
    child_ctx[0].document.parent?.spellcastingClasses?.[
      /*$context*/
      child_ctx[0].system.sourceClass
    ]
  );
  child_ctx[4] = constants_0;
  return child_ctx;
}
function create_default_slot_14(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.spellLevels
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.spellLevels;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_13$1(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.level",
      value: (
        /*$context*/
        ctx[0].system.level
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.level;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_12$1(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.spellSchools
      ),
      labelProp: "label",
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.spellSchools;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_11$2(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.school",
      value: (
        /*$context*/
        ctx[0].system.school
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_12$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.school;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_10$2(ctx) {
  let itemproperties;
  let current;
  itemproperties = new ItemProperties({});
  return {
    c() {
      create_component(itemproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemproperties, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemproperties, detaching);
    }
  };
}
function create_if_block_3$9(ctx) {
  let div;
  let label0;
  let t0_value = (
    /*localize*/
    ctx[2]("DND5E.Supply") + ""
  );
  let t0;
  let label0_for_value;
  let t1;
  let numberinput0;
  let t2;
  let label1;
  let t3_value = (
    /*localize*/
    ctx[2]("DND5E.CostGP") + ""
  );
  let t3;
  let label1_for_value;
  let t4;
  let numberinput1;
  let t5;
  let checkbox;
  let current;
  numberinput0 = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-materials-supply"
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.materials.supply",
      value: (
        /*$context*/
        ctx[0].system.materials.supply
      ),
      placeholder: "0",
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  numberinput1 = new NumberInput({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-materials-cost"
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.materials.cost",
      value: (
        /*$context*/
        ctx[0].system.materials.cost
      ),
      placeholder: "",
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  checkbox = new Checkbox({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-materials-consumed"
      ),
      labelCssClass: "checkbox",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.materials.consumed",
      checked: (
        /*$context*/
        ctx[0].system.materials.consumed
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_9$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      t1 = space();
      create_component(numberinput0.$$.fragment);
      t2 = space();
      label1 = element("label");
      t3 = text(t3_value);
      t4 = space();
      create_component(numberinput1.$$.fragment);
      t5 = space();
      create_component(checkbox.$$.fragment);
      attr(label0, "for", label0_for_value = /*$context*/
      ctx[0].appId + "-system-materials-supply");
      attr(label1, "for", label1_for_value = /*$context*/
      ctx[0].appId + "-system-materials-cost");
      attr(div, "class", "spell-materials flexrow align-items-center small-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label0);
      append(label0, t0);
      append(div, t1);
      mount_component(numberinput0, div, null);
      append(div, t2);
      append(div, label1);
      append(label1, t3);
      append(div, t4);
      mount_component(numberinput1, div, null);
      append(div, t5);
      mount_component(checkbox, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$context*/
      1 && label0_for_value !== (label0_for_value = /*$context*/
      ctx2[0].appId + "-system-materials-supply")) {
        attr(label0, "for", label0_for_value);
      }
      const numberinput0_changes = {};
      if (dirty & /*$context*/
      1) numberinput0_changes.id = /*$context*/
      ctx2[0].appId + "-system-materials-supply";
      if (dirty & /*$context*/
      1) numberinput0_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput0_changes.value = /*$context*/
      ctx2[0].system.materials.supply;
      if (dirty & /*$context*/
      1) numberinput0_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput0.$set(numberinput0_changes);
      if (!current || dirty & /*$context*/
      1 && label1_for_value !== (label1_for_value = /*$context*/
      ctx2[0].appId + "-system-materials-cost")) {
        attr(label1, "for", label1_for_value);
      }
      const numberinput1_changes = {};
      if (dirty & /*$context*/
      1) numberinput1_changes.id = /*$context*/
      ctx2[0].appId + "-system-materials-cost";
      if (dirty & /*$context*/
      1) numberinput1_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput1_changes.value = /*$context*/
      ctx2[0].system.materials.cost;
      if (dirty & /*$context*/
      1) numberinput1_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput1.$set(numberinput1_changes);
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.id = /*$context*/
      ctx2[0].appId + "-system-materials-consumed";
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.materials.consumed;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope*/
      32) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput0.$$.fragment, local);
      transition_in(numberinput1.$$.fragment, local);
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput0.$$.fragment, local);
      transition_out(numberinput1.$$.fragment, local);
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput0);
      destroy_component(numberinput1);
      destroy_component(checkbox);
    }
  };
}
function create_default_slot_9$2(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("DND5E.Consumed") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_8$2(ctx) {
  let textinput;
  let t2;
  let if_block_anchor;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      cssClass: "materials",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.materials.value",
      value: (
        /*$context*/
        ctx[0].system.materials.value
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  let if_block = (
    /*$context*/
    ctx[0].system.materials.value && create_if_block_3$9(ctx)
  );
  return {
    c() {
      create_component(textinput.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.materials.value;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
      if (
        /*$context*/
        ctx2[0].system.materials.value
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(textinput, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot_7$2(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("DND5E.SpellPrepared") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_6$2(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.spellPreparationModes
      ),
      labelProp: "label"
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.spellPreparationModes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let div;
  let checkbox;
  let t2;
  let select;
  let current;
  checkbox = new Checkbox({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-preparation-prepared"
      ),
      labelCssClass: "checkbox prepared",
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.preparation.prepared",
      checked: (
        /*$context*/
        ctx[0].system.preparation.prepared
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      greenCheckboxWidthOverride: (
        /*localize*/
        ctx[2]("DND5E.SpellPrepared").length + 4 + "ch"
      ),
      $$slots: { default: [create_default_slot_7$2] },
      $$scope: { ctx }
    }
  });
  select = new Select({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-preparation-mode"
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.preparation.mode",
      value: (
        /*$context*/
        ctx[0].system.preparation.mode
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(checkbox.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
      attr(div, "class", "form-fields spell-preparation-mode");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkbox, div, null);
      append(div, t2);
      mount_component(select, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.id = /*$context*/
      ctx2[0].appId + "-system-preparation-prepared";
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.preparation.prepared;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope*/
      32) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
      const select_changes = {};
      if (dirty & /*$context*/
      1) select_changes.id = /*$context*/
      ctx2[0].appId + "-system-preparation-mode";
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.preparation.mode;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(checkbox);
      destroy_component(select);
    }
  };
}
function create_else_block$l(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellSourceClass")
      ),
      field: "system.sourceClass",
      $$slots: {
        default: [
          create_default_slot_4$3,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_if_block$v(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellSourceClass")
      ),
      field: "system.sourceClass",
      $$slots: {
        default: [
          create_default_slot_2$4,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      41) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_4$3(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.sourceClass",
      value: (
        /*$context*/
        ctx[0].system.sourceClass
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.sourceClass;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_2$d(ctx) {
  let option;
  let t_value = (
    /*localize*/
    ctx[2]("TIDY5E.SpellSourceIdentifierSelectText", {
      identifier: (
        /*$context*/
        ctx[0].system.sourceClass
      )
    }) + ""
  );
  let t2;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t2 = text(t_value);
      option.__value = option_value_value = /*$context*/
      ctx[0].system.sourceClass;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && t_value !== (t_value = /*localize*/
      ctx2[2]("TIDY5E.SpellSourceIdentifierSelectText", {
        identifier: (
          /*$context*/
          ctx2[0].system.sourceClass
        )
      }) + "")) set_data(t2, t_value);
      if (dirty & /*$context*/
      1 && option_value_value !== (option_value_value = /*$context*/
      ctx2[0].system.sourceClass)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot_3$4(ctx) {
  let selectoptions;
  let t2;
  let if_block_anchor;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].document.parent.spellcastingClasses
      ),
      labelProp: "name",
      blank: ""
    }
  });
  let if_block = (
    /*classIsInvalidForActor*/
    ctx[4] && create_if_block_2$d(ctx)
  );
  return {
    c() {
      create_component(selectoptions.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].document.parent.spellcastingClasses;
      selectoptions.$set(selectoptions_changes);
      if (
        /*classIsInvalidForActor*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$d(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(selectoptions, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_1$h(ctx) {
  let i2;
  let i_title_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-fw fa-info-circle source-class-unowned-class-hint-icon flex-0");
      attr(i2, "title", i_title_value = /*localize*/
      ctx[2]("TIDY5E.SpellSourceIdentifierLabelHint", {
        identifier: (
          /*$context*/
          ctx[0].system.sourceClass
        )
      }));
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && i_title_value !== (i_title_value = /*localize*/
      ctx2[2]("TIDY5E.SpellSourceIdentifierLabelHint", {
        identifier: (
          /*$context*/
          ctx2[0].system.sourceClass
        )
      }))) {
        attr(i2, "title", i_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_default_slot_2$4(ctx) {
  let select;
  let t2;
  let if_block_anchor;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.sourceClass",
      value: (
        /*$context*/
        ctx[0].system.sourceClass
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      blankValue: "",
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  let if_block = (
    /*classIsInvalidForActor*/
    ctx[4] && create_if_block_1$h(ctx)
  );
  return {
    c() {
      create_component(select.$$.fragment);
      t2 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      insert(target, t2, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.sourceClass;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
      if (
        /*classIsInvalidForActor*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$h(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(select, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_default_slot_1$6(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.spellScalingModes
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.spellScalingModes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot$q(ctx) {
  let div;
  let select;
  let t2;
  let textinput;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.scaling.mode",
      value: (
        /*$context*/
        ctx[0].system.scaling.mode
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  textinput = new TextInput$1({
    props: {
      id: (
        /*$context*/
        ctx[0].appId + "-system-scaling-formula"
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.scaling.formula",
      value: (
        /*$context*/
        ctx[0].system.scaling.formula
      ),
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.ScalingFormula")
      ),
      dataset: { formulaEditor: true },
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(select.$$.fragment);
      t2 = space();
      create_component(textinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(select, div, null);
      append(div, t2);
      mount_component(textinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.scaling.mode;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      33) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.id = /*$context*/
      ctx2[0].appId + "-system-scaling-formula";
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.scaling.formula;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(select);
      destroy_component(textinput);
    }
  };
}
function create_fragment$1a(ctx) {
  let h30;
  let t1;
  let itemformgroup0;
  let t2;
  let itemformgroup1;
  let t3;
  let itemformgroup2;
  let t4;
  let itemformgroup3;
  let t5;
  let itemformgroup4;
  let t6;
  let show_if;
  let current_block_type_index;
  let if_block;
  let t7;
  let h31;
  let t9;
  let itemactivation;
  let t10;
  let h32;
  let t12;
  let itemaction;
  let t13;
  let itemformgroup5;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellLevel")
      ),
      field: "system.level",
      $$slots: {
        default: [
          create_default_slot_13$1,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellSchool")
      ),
      field: "system.school",
      $$slots: {
        default: [
          create_default_slot_11$2,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup2 = new ItemFormGroup({
    props: {
      cssClass: "spell-components stacked",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellComponents")
      ),
      $$slots: { default: [create_default_slot_10$2] },
      $$scope: { ctx }
    }
  });
  itemformgroup3 = new ItemFormGroup({
    props: {
      cssClass: "stacked",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellMaterials")
      ),
      field: "system.materials.value",
      $$slots: {
        default: [
          create_default_slot_8$2,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup4 = new ItemFormGroup({
    props: {
      cssClass: "input-select",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.SpellPreparationMode")
      ),
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block$v, create_else_block$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*$context*/
    1) show_if = null;
    if (show_if == null) show_if = !!/*$context*/
    (ctx2[0].isEmbedded && !!Object.keys(
      /*$context*/
      ctx2[0].document.parent?.spellcastingClasses ?? {}
    )?.length);
    if (show_if) return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 0) return get_if_ctx$1(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  itemactivation = new ItemActivation({});
  itemaction = new ItemAction({});
  itemformgroup5 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.LevelScaling")
      ),
      field: "system.scaling.mode",
      $$slots: {
        default: [
          create_default_slot$q,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h30 = element("h3");
      h30.textContent = `${/*localize*/
      ctx[2]("DND5E.SpellDetails")}`;
      t1 = space();
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      create_component(itemformgroup1.$$.fragment);
      t3 = space();
      create_component(itemformgroup2.$$.fragment);
      t4 = space();
      create_component(itemformgroup3.$$.fragment);
      t5 = space();
      create_component(itemformgroup4.$$.fragment);
      t6 = space();
      if_block.c();
      t7 = space();
      h31 = element("h3");
      h31.textContent = `${/*localize*/
      ctx[2]("DND5E.SpellCastingHeader")}`;
      t9 = space();
      create_component(itemactivation.$$.fragment);
      t10 = space();
      h32 = element("h3");
      h32.textContent = `${/*localize*/
      ctx[2]("DND5E.SpellEffects")}`;
      t12 = space();
      create_component(itemaction.$$.fragment);
      t13 = space();
      create_component(itemformgroup5.$$.fragment);
      attr(h30, "class", "form-header");
      attr(h31, "class", "form-header");
      attr(h32, "class", "form-header");
    },
    m(target, anchor) {
      insert(target, h30, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t3, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t4, anchor);
      mount_component(itemformgroup3, target, anchor);
      insert(target, t5, anchor);
      mount_component(itemformgroup4, target, anchor);
      insert(target, t6, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t7, anchor);
      insert(target, h31, anchor);
      insert(target, t9, anchor);
      mount_component(itemactivation, target, anchor);
      insert(target, t10, anchor);
      insert(target, h32, anchor);
      insert(target, t12, anchor);
      mount_component(itemaction, target, anchor);
      insert(target, t13, anchor);
      mount_component(itemformgroup5, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      41) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope*/
      32) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      const itemformgroup3_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      41) {
        itemformgroup3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup3.$set(itemformgroup3_changes);
      const itemformgroup4_changes = {};
      if (dirty & /*$$scope, $context*/
      33) {
        itemformgroup4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup4.$set(itemformgroup4_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(select_block_ctx(ctx2, current_block_type_index), dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block.c();
        } else {
          if_block.p(select_block_ctx(ctx2, current_block_type_index), dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t7.parentNode, t7);
      }
      const itemformgroup5_changes = {};
      if (dirty & /*$$scope, $context, inputId*/
      41) {
        itemformgroup5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup5.$set(itemformgroup5_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(itemformgroup3.$$.fragment, local);
      transition_in(itemformgroup4.$$.fragment, local);
      transition_in(if_block);
      transition_in(itemactivation.$$.fragment, local);
      transition_in(itemaction.$$.fragment, local);
      transition_in(itemformgroup5.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(itemformgroup3.$$.fragment, local);
      transition_out(itemformgroup4.$$.fragment, local);
      transition_out(if_block);
      transition_out(itemactivation.$$.fragment, local);
      transition_out(itemaction.$$.fragment, local);
      transition_out(itemformgroup5.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h30);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(h31);
        detach(t9);
        detach(t10);
        detach(h32);
        detach(t12);
        detach(t13);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemformgroup2, detaching);
      destroy_component(itemformgroup3, detaching);
      destroy_component(itemformgroup4, detaching);
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(itemactivation, detaching);
      destroy_component(itemaction, detaching);
      destroy_component(itemformgroup5, detaching);
    }
  };
}
function instance$1a($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemSpellDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});
  }
}
function create_default_slot_1$5(ctx) {
  let div;
  let textinput;
  let t0;
  let p2;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.identifier",
      value: (
        /*$context*/
        ctx[0].system.identifier
      ),
      placeholder: (
        /*$context*/
        ctx[0].item.identifier
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[2]("DND5E.IdentifierError")}`;
      attr(div, "class", "form-fields");
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.identifier;
      if (dirty & /*$context*/
      1) textinput_changes.placeholder = /*$context*/
      ctx2[0].item.identifier;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p2);
      }
      destroy_component(textinput);
    }
  };
}
function create_default_slot$p(ctx) {
  let div;
  let textinput;
  let t0;
  let p2;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.classIdentifier",
      value: (
        /*$context*/
        ctx[0].system.classIdentifier
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[2]("DND5E.SubclassIdentifierHint")}`;
      attr(div, "class", "form-fields");
      attr(p2, "class", "hint");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput, div, null);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.classIdentifier;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(p2);
      }
      destroy_component(textinput);
    }
  };
}
function create_fragment$19(ctx) {
  let itemformgroup0;
  let t0;
  let itemformgroup1;
  let t1;
  let h3;
  let t3;
  let itemspellcasting;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Identifier")
      ),
      field: "system.identifier",
      $$slots: {
        default: [
          create_default_slot_1$5,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ClassIdentifier")
      ),
      field: "system.classIdentifier",
      $$slots: {
        default: [
          create_default_slot$p,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemspellcasting = new ItemSpellcasting({});
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t0 = space();
      create_component(itemformgroup1.$$.fragment);
      t1 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[2]("DND5E.Spellcasting")}`;
      t3 = space();
      create_component(itemspellcasting.$$.fragment);
      attr(h3, "class", "form-header");
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t1, anchor);
      insert(target, h3, anchor);
      insert(target, t3, anchor);
      mount_component(itemspellcasting, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemspellcasting.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemspellcasting.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(h3);
        detach(t3);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemspellcasting, detaching);
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemSubclassDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$19, create_fragment$19, safe_not_equal, {});
  }
}
function create_default_slot_13(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.toolTypes
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.toolTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.value",
      value: (
        /*$context*/
        ctx[0].system.type.value
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.value;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_11$1(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].baseItems
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].baseItems;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_10$1(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.baseItem",
      value: (
        /*$context*/
        ctx[0].system.type.baseItem
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_11$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.baseItem;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_9$1(ctx) {
  let itemproperties;
  let current;
  itemproperties = new ItemProperties({});
  return {
    c() {
      create_component(itemproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemproperties, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemproperties, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.attunementTypes
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.AttunementNone")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.attunementTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let checkbox;
  let t2;
  let select;
  let current;
  checkbox = new Checkbox({
    props: {
      id: `${/*$context*/
      ctx[0].appId}-system-attuned`,
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attuned",
      checked: (
        /*$context*/
        ctx[0].system.attuned
      ),
      disabled: !/*$context*/
      ctx[0].editable || !/*$context*/
      ctx[0].system.attunement,
      title: (
        /*localize*/
        ctx[2]("DND5E.AttunementAttuned")
      )
    }
  });
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attunement",
      value: (
        /*$context*/
        ctx[0].system.attunement
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      insert(target, t2, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.id = `${/*$context*/
      ctx2[0].appId}-system-attuned`;
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.attuned;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable || !/*$context*/
      ctx2[0].system.attunement;
      checkbox.$set(checkbox_changes);
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.attunement;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(checkbox, detaching);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_6$1(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.proficiencyLevels
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.Automatic")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.proficiencyLevels;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.proficient",
      value: (
        /*$context*/
        ctx[0].system.proficient
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.proficient;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.abilities
      ),
      labelProp: "label",
      blank: (
        /*localize*/
        ctx[2]("DND5E.Default")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.abilities;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.ability",
      value: (
        /*$context*/
        ctx[0].system.ability
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.ability;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.bonus",
      value: (
        /*$context*/
        ctx[0].system.bonus
      ),
      dataset: { formulaEditor: true },
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.bonus;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.chatFlavor",
      value: (
        /*$context*/
        ctx[0].system.chatFlavor
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*inputId*/
      8) textinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.chatFlavor;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot$o(ctx) {
  let itemformgroup0;
  let t0;
  let itemformgroup1;
  let t1;
  let itemformgroup2;
  let t2;
  let itemformgroup3;
  let t3;
  let itemformgroup4;
  let t4;
  let itemformgroup5;
  let t5;
  let itemformgroup6;
  let t6;
  let h3;
  let t8;
  let itemactivation;
  let t9;
  let itemformgroup7;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemToolType")
      ),
      field: "system.type.value",
      $$slots: {
        default: [
          create_default_slot_12,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemToolBase")
      ),
      field: "system.type.baseItem",
      $$slots: {
        default: [
          create_default_slot_10$1,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup2 = new ItemFormGroup({
    props: {
      cssClass: "stacked tool-properties",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemToolProperties")
      ),
      $$slots: { default: [create_default_slot_9$1] },
      $$scope: { ctx }
    }
  });
  itemformgroup3 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Attunement")
      ),
      field: "system.attunement",
      $$slots: {
        default: [
          create_default_slot_7$1,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup4 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemToolProficiency")
      ),
      field: "system.proficient",
      $$slots: {
        default: [
          create_default_slot_5$2,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup5 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.DefaultAbilityCheck")
      ),
      field: "system.ability",
      $$slots: {
        default: [
          create_default_slot_3$3,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup6 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemToolBonus")
      ),
      field: "system.bonus",
      $$slots: {
        default: [
          create_default_slot_2$3,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemactivation = new ItemActivation({});
  itemformgroup7 = new ItemFormGroup({
    props: {
      cssClass: "stacked",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ChatFlavor")
      ),
      field: "system.chatFlavor",
      $$slots: {
        default: [
          create_default_slot_1$4,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t0 = space();
      create_component(itemformgroup1.$$.fragment);
      t1 = space();
      create_component(itemformgroup2.$$.fragment);
      t2 = space();
      create_component(itemformgroup3.$$.fragment);
      t3 = space();
      create_component(itemformgroup4.$$.fragment);
      t4 = space();
      create_component(itemformgroup5.$$.fragment);
      t5 = space();
      create_component(itemformgroup6.$$.fragment);
      t6 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemToolUsage")}`;
      t8 = space();
      create_component(itemactivation.$$.fragment);
      t9 = space();
      create_component(itemformgroup7.$$.fragment);
      attr(h3, "class", "form-header");
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t0, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup3, target, anchor);
      insert(target, t3, anchor);
      mount_component(itemformgroup4, target, anchor);
      insert(target, t4, anchor);
      mount_component(itemformgroup5, target, anchor);
      insert(target, t5, anchor);
      mount_component(itemformgroup6, target, anchor);
      insert(target, t6, anchor);
      insert(target, h3, anchor);
      insert(target, t8, anchor);
      mount_component(itemactivation, target, anchor);
      insert(target, t9, anchor);
      mount_component(itemformgroup7, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope*/
      16) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      const itemformgroup3_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup3.$set(itemformgroup3_changes);
      const itemformgroup4_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup4.$set(itemformgroup4_changes);
      const itemformgroup5_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup5.$set(itemformgroup5_changes);
      const itemformgroup6_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup6.$set(itemformgroup6_changes);
      const itemformgroup7_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup7.$set(itemformgroup7_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(itemformgroup3.$$.fragment, local);
      transition_in(itemformgroup4.$$.fragment, local);
      transition_in(itemformgroup5.$$.fragment, local);
      transition_in(itemformgroup6.$$.fragment, local);
      transition_in(itemactivation.$$.fragment, local);
      transition_in(itemformgroup7.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(itemformgroup3.$$.fragment, local);
      transition_out(itemformgroup4.$$.fragment, local);
      transition_out(itemformgroup5.$$.fragment, local);
      transition_out(itemformgroup6.$$.fragment, local);
      transition_out(itemactivation.$$.fragment, local);
      transition_out(itemformgroup7.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(h3);
        detach(t8);
        detach(t9);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
      destroy_component(itemformgroup2, detaching);
      destroy_component(itemformgroup3, detaching);
      destroy_component(itemformgroup4, detaching);
      destroy_component(itemformgroup5, detaching);
      destroy_component(itemformgroup6, detaching);
      destroy_component(itemactivation, detaching);
      destroy_component(itemformgroup7, detaching);
    }
  };
}
function create_fragment$18(ctx) {
  let contentconcealer;
  let current;
  contentconcealer = new ContentConcealer({
    props: {
      conceal: (
        /*$context*/
        ctx[0].concealDetails
      ),
      $$slots: { default: [create_default_slot$o] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(contentconcealer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contentconcealer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const contentconcealer_changes = {};
      if (dirty & /*$context*/
      1) contentconcealer_changes.conceal = /*$context*/
      ctx2[0].concealDetails;
      if (dirty & /*$$scope, $context*/
      17) {
        contentconcealer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contentconcealer.$set(contentconcealer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contentconcealer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contentconcealer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contentconcealer, detaching);
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemToolDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$18, create_fragment$18, safe_not_equal, {});
  }
}
function create_default_slot_11(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.weaponTypes
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.weaponTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.value",
      value: (
        /*$context*/
        ctx[0].system.type.value
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.value;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_9(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].baseItems
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].baseItems;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.type.baseItem",
      value: (
        /*$context*/
        ctx[0].system.type.baseItem
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.type.baseItem;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_2$c(ctx) {
  let itemformgroup0;
  let t2;
  let itemformgroup1;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Attunement")
      ),
      field: "system.attunement",
      $$slots: {
        default: [
          create_default_slot_6,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.Proficiency")
      ),
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      create_component(itemformgroup1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, $context*/
      17) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.attunementTypes
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.AttunementNone")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.attunementTypes;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let checkbox;
  let t2;
  let select;
  let current;
  checkbox = new Checkbox({
    props: {
      id: `${/*$context*/
      ctx[0].appId}-system-attuned`,
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attuned",
      checked: (
        /*$context*/
        ctx[0].system.attuned
      ),
      disabled: !/*$context*/
      ctx[0].editable || !/*$context*/
      ctx[0].system.attunement,
      title: (
        /*localize*/
        ctx[2]("DND5E.AttunementAttuned")
      )
    }
  });
  select = new Select({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.attunement",
      value: (
        /*$context*/
        ctx[0].system.attunement
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(checkbox.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      insert(target, t2, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & /*$context*/
      1) checkbox_changes.id = `${/*$context*/
      ctx2[0].appId}-system-attuned`;
      if (dirty & /*$context*/
      1) checkbox_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) checkbox_changes.checked = /*$context*/
      ctx2[0].system.attuned;
      if (dirty & /*$context*/
      1) checkbox_changes.disabled = !/*$context*/
      ctx2[0].editable || !/*$context*/
      ctx2[0].system.attunement;
      checkbox.$set(checkbox_changes);
      const select_changes = {};
      if (dirty & /*inputId*/
      8) select_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.attunement;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(checkbox, detaching);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[0].config.weaponAndArmorProficiencyLevels
      ),
      blank: (
        /*localize*/
        ctx[2]("DND5E.Automatic")
      )
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      1) selectoptions_changes.data = /*$context*/
      ctx2[0].config.weaponAndArmorProficiencyLevels;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.proficient",
      value: (
        /*$context*/
        ctx[0].system.proficient
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      1) select_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) select_changes.value = /*$context*/
      ctx2[0].system.proficient;
      if (dirty & /*$context*/
      1) select_changes.disabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$$scope, $context*/
      17) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let itemproperties;
  let current;
  itemproperties = new ItemProperties({});
  return {
    c() {
      create_component(itemproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemproperties, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(itemproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemproperties, detaching);
    }
  };
}
function create_if_block_1$g(ctx) {
  let itemformgroup;
  let t2;
  let itemmountable;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ArmorClass")
      ),
      field: "system.armor.value",
      $$slots: {
        default: [
          create_default_slot_2$2,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemmountable = new ItemMountable({});
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
      t2 = space();
      create_component(itemmountable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemmountable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      transition_in(itemmountable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      transition_out(itemmountable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(itemformgroup, detaching);
      destroy_component(itemmountable, detaching);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let div;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      document: (
        /*$context*/
        ctx[0].item
      ),
      field: "system.armor.value",
      value: (
        /*$context*/
        ctx[0].system.armor.value
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.armor.value;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_if_block$u(ctx) {
  let itemformgroup;
  let current;
  itemformgroup = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.MagicalBonus")
      ),
      field: "system.magicalBonus",
      $$slots: {
        default: [
          create_default_slot_1$3,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(itemformgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemformgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup.$set(itemformgroup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemformgroup, detaching);
    }
  };
}
function create_default_slot_1$3(ctx) {
  let div;
  let numberinput;
  let current;
  numberinput = new NumberInput({
    props: {
      id: (
        /*inputId*/
        ctx[3]
      ),
      value: (
        /*$context*/
        ctx[0].system.magicalBonus
      ),
      field: "system.magicalBonus",
      document: (
        /*$context*/
        ctx[0].item
      ),
      disabled: !/*$context*/
      ctx[0].editable,
      min: "0",
      step: "1",
      placeholder: "0"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(numberinput.$$.fragment);
      attr(div, "class", "form-fields");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(numberinput, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*inputId*/
      8) numberinput_changes.id = /*inputId*/
      ctx2[3];
      if (dirty & /*$context*/
      1) numberinput_changes.value = /*$context*/
      ctx2[0].system.magicalBonus;
      if (dirty & /*$context*/
      1) numberinput_changes.document = /*$context*/
      ctx2[0].item;
      if (dirty & /*$context*/
      1) numberinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(numberinput);
    }
  };
}
function create_default_slot$n(ctx) {
  let h30;
  let t1;
  let itemformgroup0;
  let t2;
  let itemformgroup1;
  let t3;
  let t4;
  let itemformgroup2;
  let t5;
  let t6;
  let t7;
  let h31;
  let t9;
  let itemactivation;
  let t10;
  let h32;
  let t12;
  let itemaction;
  let current;
  itemformgroup0 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemWeaponType")
      ),
      field: "system.type.value",
      $$slots: {
        default: [
          create_default_slot_10,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  itemformgroup1 = new ItemFormGroup({
    props: {
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemWeaponBase")
      ),
      field: "system.type.baseItem",
      $$slots: {
        default: [
          create_default_slot_8,
          ({ inputId }) => ({ 3: inputId }),
          ({ inputId }) => inputId ? 8 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = !/*$context*/
  ctx[0].system.isMountable && create_if_block_2$c(ctx);
  itemformgroup2 = new ItemFormGroup({
    props: {
      cssClass: "stacked weapon-properties",
      labelText: (
        /*localize*/
        ctx[2]("DND5E.ItemWeaponProperties")
      ),
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  let if_block1 = (
    /*$context*/
    ctx[0].system.isMountable && create_if_block_1$g(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[0].properties.mgc.selected && create_if_block$u(ctx)
  );
  itemactivation = new ItemActivation({});
  itemaction = new ItemAction({});
  return {
    c() {
      h30 = element("h3");
      h30.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemWeaponDetails")}`;
      t1 = space();
      create_component(itemformgroup0.$$.fragment);
      t2 = space();
      create_component(itemformgroup1.$$.fragment);
      t3 = space();
      if (if_block0) if_block0.c();
      t4 = space();
      create_component(itemformgroup2.$$.fragment);
      t5 = space();
      if (if_block1) if_block1.c();
      t6 = space();
      if (if_block2) if_block2.c();
      t7 = space();
      h31 = element("h3");
      h31.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemWeaponUsage")}`;
      t9 = space();
      create_component(itemactivation.$$.fragment);
      t10 = space();
      h32 = element("h3");
      h32.textContent = `${/*localize*/
      ctx[2]("DND5E.ItemWeaponAttack")}`;
      t12 = space();
      create_component(itemaction.$$.fragment);
      attr(h30, "class", "form-header");
      attr(h31, "class", "form-header");
      attr(h32, "class", "form-header");
    },
    m(target, anchor) {
      insert(target, h30, anchor);
      insert(target, t1, anchor);
      mount_component(itemformgroup0, target, anchor);
      insert(target, t2, anchor);
      mount_component(itemformgroup1, target, anchor);
      insert(target, t3, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t4, anchor);
      mount_component(itemformgroup2, target, anchor);
      insert(target, t5, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t7, anchor);
      insert(target, h31, anchor);
      insert(target, t9, anchor);
      mount_component(itemactivation, target, anchor);
      insert(target, t10, anchor);
      insert(target, h32, anchor);
      insert(target, t12, anchor);
      mount_component(itemaction, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemformgroup0_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup0.$set(itemformgroup0_changes);
      const itemformgroup1_changes = {};
      if (dirty & /*$$scope, inputId, $context*/
      25) {
        itemformgroup1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup1.$set(itemformgroup1_changes);
      if (!/*$context*/
      ctx2[0].system.isMountable) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$c(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t4.parentNode, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const itemformgroup2_changes = {};
      if (dirty & /*$$scope*/
      16) {
        itemformgroup2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      itemformgroup2.$set(itemformgroup2_changes);
      if (
        /*$context*/
        ctx2[0].system.isMountable
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$g(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t6.parentNode, t6);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].properties.mgc.selected
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$u(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t7.parentNode, t7);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(itemformgroup0.$$.fragment, local);
      transition_in(itemformgroup1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(itemformgroup2.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(itemactivation.$$.fragment, local);
      transition_in(itemaction.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemformgroup0.$$.fragment, local);
      transition_out(itemformgroup1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(itemformgroup2.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(itemactivation.$$.fragment, local);
      transition_out(itemaction.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h30);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
        detach(t7);
        detach(h31);
        detach(t9);
        detach(t10);
        detach(h32);
        detach(t12);
      }
      destroy_component(itemformgroup0, detaching);
      destroy_component(itemformgroup1, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(itemformgroup2, detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
      destroy_component(itemactivation, detaching);
      destroy_component(itemaction, detaching);
    }
  };
}
function create_fragment$17(ctx) {
  let contentconcealer;
  let current;
  contentconcealer = new ContentConcealer({
    props: {
      conceal: (
        /*$context*/
        ctx[0].concealDetails
      ),
      $$slots: { default: [create_default_slot$n] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(contentconcealer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contentconcealer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const contentconcealer_changes = {};
      if (dirty & /*$context*/
      1) contentconcealer_changes.conceal = /*$context*/
      ctx2[0].concealDetails;
      if (dirty & /*$$scope, $context*/
      17) {
        contentconcealer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contentconcealer.$set(contentconcealer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contentconcealer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contentconcealer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contentconcealer, detaching);
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ItemWeaponDetailsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$17, create_fragment$17, safe_not_equal, {});
  }
}
const itemSheetTabs = {
  /**
   * Advancement create/read/update/delete interface.
   */
  advancement: {
    id: CONSTANTS.TAB_ITEM_ADVANCEMENT_ID,
    title: "DND5E.AdvancementTitle",
    content: {
      component: ItemAdvancementTab,
      cssClass: "detail-tab-contents items-list-container",
      type: "svelte"
    }
  },
  /**
   * Details form for background items.
   */
  backgroundDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemBackgroundDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * Details form for class items.
   */
  classDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemClassDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * Details form for consumable items.
   */
  consumableDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemConsumableDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  containerContents: {
    id: CONSTANTS.TAB_CONTAINER_CONTENTS,
    title: "DND5E.Contents",
    content: {
      component: ItemContainerContentsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    }
  },
  containerDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemContainerDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * Description editor and a header for mechanics/flavor.
   */
  description: {
    id: CONSTANTS.TAB_ITEM_DESCRIPTION_ID,
    title: "DND5E.Description",
    content: {
      component: ItemDescriptionTab,
      cssClass: "flexcol",
      type: "svelte"
    }
  },
  /**
   * A sidebar with item inputs and properties, and a description editor.
   */
  descriptionWithSidebar: {
    id: CONSTANTS.TAB_ITEM_DESCRIPTION_ID,
    title: "DND5E.Description",
    content: {
      component: ItemDescriptionWithSidebarTab,
      cssClass: "flexrow",
      type: "svelte"
    }
  },
  /**
   * Active Effects create/read/update/delete interface.
   */
  effects: {
    id: CONSTANTS.TAB_ITEM_EFFECTS_ID,
    title: "DND5E.Effects",
    content: {
      component: ItemActiveEffectsTab,
      cssClass: "flexcol items-list-container",
      type: "svelte"
    }
  },
  /**
   * Details form for equipment items.
   */
  equipmentDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemEquipmentDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * Details form for feat items.
   */
  featDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemFeatDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * Details form for loot.
   */
  lootDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemLootDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * A sidebar with race properties and configuration buttons, and a description editor.
   */
  raceDescription: {
    id: CONSTANTS.TAB_ITEM_DESCRIPTION_ID,
    title: "DND5E.Description",
    content: {
      component: ItemRaceDescriptionTab,
      cssClass: "flexrow",
      type: "svelte"
    }
  },
  /**
   * A sidebar with race properties and configuration buttons, and a description editor.
   */
  raceDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemRaceDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    }
  },
  /**
   * Details form for spell items.
   */
  spellDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemSpellDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * Details form for subclass items.
   */
  subclassDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemSubclassDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * Details form for tool items.
   */
  toolDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemToolDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  },
  /**
   * Details form for weapon items.
   */
  weaponDetails: {
    id: CONSTANTS.TAB_ITEM_DETAILS_ID,
    title: "DND5E.Details",
    content: {
      component: ItemWeaponDetailsTab,
      cssClass: "detail-tab-contents",
      type: "svelte"
    },
    autoHeight: true
  }
};
function create_fragment$16(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let textinput;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let span;
  let t4_value = (
    /*$context*/
    (ctx[1].itemStatus ?? "") + ""
  );
  let t4;
  let t5;
  let ul;
  let li;
  let source;
  let t6;
  let tabs;
  let updating_selectedTabId;
  let t7;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  textinput = new TextInput$1({
    props: {
      field: "name",
      document: (
        /*$context*/
        ctx[1].item
      ),
      value: (
        /*$context*/
        ctx[1].item.name
      ),
      attributes: {
        "data-tidy-item-name": (
          /*$context*/
          ctx[1].item.name
        )
      },
      placeholder: (
        /*localize*/
        ctx[3]("DND5E.BackgroundName")
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      title: (
        /*$context*/
        ctx[1].item.name
      )
    }
  });
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable
      )
    }
  });
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(textinput.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      ul = element("ul");
      li = element("li");
      create_component(source.$$.fragment);
      t6 = space();
      create_component(tabs.$$.fragment);
      t7 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(span, "class", "item-status");
      attr(div0, "class", "item-subtitle");
      attr(li, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(textinput, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div0, t3);
      append(div0, span);
      append(span, t4);
      append(div1, t5);
      append(div1, ul);
      append(ul, li);
      mount_component(source, li, null);
      insert(target, t6, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t7, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].item.name;
      if (dirty & /*$context*/
      2) textinput_changes.attributes = {
        "data-tidy-item-name": (
          /*$context*/
          ctx2[1].item.name
        )
      };
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$context*/
      2) textinput_changes.title = /*$context*/
      ctx2[1].item.name;
      textinput.$set(textinput_changes);
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      (ctx2[1].itemStatus ?? "") + "")) set_data(t4, t4_value);
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      transition_in(source.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      transition_out(source.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t6);
        detach(t7);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(textinput);
      destroy_component(source);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$16($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let { selectedTabId = "description" } = $$props;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  $$self.$$set = ($$props2) => {
    if ("selectedTabId" in $$props2) $$invalidate(0, selectedTabId = $$props2.selectedTabId);
  };
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class BackgroundSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$16, create_fragment$16, safe_not_equal, { selectedTabId: 0 });
  }
}
function create_fragment$15(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let textinput;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let span;
  let t4_value = (
    /*$context*/
    (ctx[1].itemStatus ?? "") + ""
  );
  let t4;
  let t5;
  let ul;
  let li;
  let source;
  let t6;
  let tabs;
  let updating_selectedTabId;
  let t7;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  textinput = new TextInput$1({
    props: {
      field: "name",
      document: (
        /*$context*/
        ctx[1].item
      ),
      value: (
        /*$context*/
        ctx[1].item.name
      ),
      attributes: {
        "data-tidy-item-name": (
          /*$context*/
          ctx[1].item.name
        )
      },
      placeholder: (
        /*localize*/
        ctx[3]("DND5E.ClassName")
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      title: (
        /*$context*/
        ctx[1].item.name
      )
    }
  });
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable
      )
    }
  });
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(textinput.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      ul = element("ul");
      li = element("li");
      create_component(source.$$.fragment);
      t6 = space();
      create_component(tabs.$$.fragment);
      t7 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(span, "class", "item-status");
      attr(div0, "class", "item-subtitle");
      attr(li, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(textinput, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div0, t3);
      append(div0, span);
      append(span, t4);
      append(div1, t5);
      append(div1, ul);
      append(ul, li);
      mount_component(source, li, null);
      insert(target, t6, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t7, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].item.name;
      if (dirty & /*$context*/
      2) textinput_changes.attributes = {
        "data-tidy-item-name": (
          /*$context*/
          ctx2[1].item.name
        )
      };
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$context*/
      2) textinput_changes.title = /*$context*/
      ctx2[1].item.name;
      textinput.$set(textinput_changes);
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      (ctx2[1].itemStatus ?? "") + "")) set_data(t4, t4_value);
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      transition_in(source.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      transition_out(source.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t6);
        detach(t7);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(textinput);
      destroy_component(source);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$15($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class ClassSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$15, create_fragment$15, safe_not_equal, {});
  }
}
function create_else_block$k(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.rarity",
      value: (
        /*$context*/
        ctx[1].system.rarity
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      blankValue: "",
      $$slots: { default: [create_default_slot$m] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      2) select_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select_changes.value = /*$context*/
      ctx2[1].system.rarity;
      if (dirty & /*$context*/
      2) select_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      34) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block$t(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[3]("DND5E.Unidentified.Title")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot$m(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.itemRarity
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.itemRarity;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_fragment$14(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let itemidentifiablename;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let ul;
  let li0;
  let t4_value = (
    /*$context*/
    ctx[1].itemType + ""
  );
  let t4;
  let t5;
  let li1;
  let current_block_type_index;
  let if_block;
  let t6;
  let li2;
  let source;
  let t7;
  let itemheadertoggles;
  let t8;
  let tabs;
  let updating_selectedTabId;
  let t9;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  itemidentifiablename = new ItemIdentifiableName({});
  const if_block_creators = [create_if_block$t, create_else_block$k];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].concealDetails
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable && !/*$context*/
        ctx[1].concealDetails
      )
    }
  });
  itemheadertoggles = new ItemHeaderToggles({});
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(itemidentifiablename.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      t4 = text(t4_value);
      t5 = space();
      li1 = element("li");
      if_block.c();
      t6 = space();
      li2 = element("li");
      create_component(source.$$.fragment);
      t7 = space();
      create_component(itemheadertoggles.$$.fragment);
      t8 = space();
      create_component(tabs.$$.fragment);
      t9 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(div0, "class", "item-subtitle");
      attr(li2, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(itemidentifiablename, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div1, t3);
      append(div1, ul);
      append(ul, li0);
      append(li0, t4);
      append(ul, t5);
      append(ul, li1);
      if_blocks[current_block_type_index].m(li1, null);
      append(ul, t6);
      append(ul, li2);
      mount_component(source, li2, null);
      append(div1, t7);
      mount_component(itemheadertoggles, div1, null);
      insert(target, t8, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t9, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      ctx2[1].itemType + "")) set_data(t4, t4_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li1, null);
      }
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable && !/*$context*/
      ctx2[1].concealDetails;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(itemidentifiablename.$$.fragment, local);
      transition_in(if_block);
      transition_in(source.$$.fragment, local);
      transition_in(itemheadertoggles.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(itemidentifiablename.$$.fragment, local);
      transition_out(if_block);
      transition_out(source.$$.fragment, local);
      transition_out(itemheadertoggles.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t8);
        detach(t9);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(itemidentifiablename);
      if_blocks[current_block_type_index].d();
      destroy_component(source);
      destroy_component(itemheadertoggles);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$14($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class ConsumableSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$14, create_fragment$14, safe_not_equal, {});
  }
}
function create_if_block_1$f(ctx) {
  let div;
  let span;
  let i2;
  let b2;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].system.uses.value + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*item*/
    ctx[0].system.uses.max + ""
  );
  let t5;
  let t6;
  let horizontallineseparator;
  let current;
  horizontallineseparator = new HorizontalLineSeparator({ props: { borderColor: "faint" } });
  return {
    c() {
      div = element("div");
      span = element("span");
      i2 = element("i");
      b2 = element("b");
      b2.textContent = `${/*localize*/
      ctx[5]("DND5E.Charges")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = text("/");
      t5 = text(t5_value);
      t6 = space();
      create_component(horizontallineseparator.$$.fragment);
      attr(i2, "class", "fas fa-bolt");
      attr(div, "class", "info-card-amount");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, i2);
      append(span, b2);
      append(span, t2);
      append(span, t3);
      append(span, t4);
      append(span, t5);
      insert(target, t6, anchor);
      mount_component(horizontallineseparator, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*item*/
      1) && t3_value !== (t3_value = /*item*/
      ctx2[0].system.uses.value + "")) set_data(t3, t3_value);
      if ((!current || dirty & /*item*/
      1) && t5_value !== (t5_value = /*item*/
      ctx2[0].system.uses.max + "")) set_data(t5, t5_value);
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t6);
      }
      destroy_component(horizontallineseparator, detaching);
    }
  };
}
function create_else_block$j(ctx) {
  let html_tag;
  let raw_value = (
    /*chatData*/
    ctx[1].description.value + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*chatData*/
      2 && raw_value !== (raw_value = /*chatData*/
      ctx2[1].description.value + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block$s(ctx) {
  let html_tag;
  let raw_value = (
    /*chatData*/
    ctx[1].unidentified.description + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*chatData*/
      2 && raw_value !== (raw_value = /*chatData*/
      ctx2[1].unidentified.description + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_fragment$13(ctx) {
  let div2;
  let p2;
  let t0_value = (
    /*item*/
    (ctx[0].system.identified === false ? coalesce(
      /*item*/
      ctx[0].system.unidentified.name,
      /*localize*/
      ctx[5]("DND5E.Unidentified.Title")
    ) : (
      /*item*/
      ctx[0].name
    )) + ""
  );
  let t0;
  let t1;
  let t2;
  let div1;
  let div0;
  let t3;
  let div2_class_value;
  let div2_data_item_id_value;
  let current;
  let if_block0 = "hasUses" in /*ctx*/
  ctx[3] && /*ctx*/
  ctx[3].hasUses && create_if_block_1$f(ctx);
  function select_block_type(ctx2, dirty) {
    if (
      /*concealDetails*/
      ctx2[2]
    ) return create_if_block$s;
    return create_else_block$j;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  return {
    c() {
      div2 = element("div");
      p2 = element("p");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      div1 = element("div");
      div0 = element("div");
      if_block1.c();
      t3 = space();
      if (default_slot) default_slot.c();
      attr(p2, "class", "info-card-name");
      attr(div0, "class", "info-card-description");
      attr(div1, "class", "description-wrap");
      attr(div2, "class", div2_class_value = "info-card " + /*item*/
      (ctx[0].attunement?.cls ?? ""));
      attr(div2, "data-item-id", div2_data_item_id_value = /*item*/
      ctx[0]._id);
      toggle_class(
        div2,
        "magic-item",
        /*item*/
        ctx[0].system.properties?.has("mgc")
      );
      toggle_class(
        div2,
        "equipped",
        /*item*/
        ctx[0].system.equipped
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p2);
      append(p2, t0);
      append(div2, t1);
      if (if_block0) if_block0.m(div2, null);
      append(div2, t2);
      append(div2, div1);
      append(div1, div0);
      if_block1.m(div0, null);
      append(div2, t3);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*item*/
      1) && t0_value !== (t0_value = /*item*/
      (ctx2[0].system.identified === false ? coalesce(
        /*item*/
        ctx2[0].system.unidentified.name,
        /*localize*/
        ctx2[5]("DND5E.Unidentified.Title")
      ) : (
        /*item*/
        ctx2[0].name
      )) + "")) set_data(t0, t0_value);
      if ("hasUses" in /*ctx*/
      ctx2[3] && /*ctx*/
      ctx2[3].hasUses) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*ctx*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$f(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div0, null);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*item*/
      1 && div2_class_value !== (div2_class_value = "info-card " + /*item*/
      (ctx2[0].attunement?.cls ?? ""))) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*item*/
      1 && div2_data_item_id_value !== (div2_data_item_id_value = /*item*/
      ctx2[0]._id)) {
        attr(div2, "data-item-id", div2_data_item_id_value);
      }
      if (!current || dirty & /*item, item*/
      1) {
        toggle_class(
          div2,
          "magic-item",
          /*item*/
          ctx2[0].system.properties?.has("mgc")
        );
      }
      if (!current || dirty & /*item, item*/
      1) {
        toggle_class(
          div2,
          "equipped",
          /*item*/
          ctx2[0].system.equipped
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0) if_block0.d();
      if_block1.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$13($$self, $$props, $$invalidate) {
  let ctx;
  let concealDetails;
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { item } = $$props;
  let { chatData } = $$props;
  let context = getContext("context");
  component_subscribe($$self, context, (value) => $$invalidate(6, $context = value));
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("chatData" in $$props2) $$invalidate(1, chatData = $$props2.chatData);
    if ("$$scope" in $$props2) $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, item*/
    65) {
      $$invalidate(3, ctx = $context.itemContext[item.id] ?? {});
    }
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(2, concealDetails = FoundryAdapter.concealDetails(item));
    }
  };
  return [
    item,
    chatData,
    concealDetails,
    ctx,
    context,
    localize,
    $context,
    $$scope,
    slots
  ];
}
class DefaultItemCardContentTemplate extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$13, create_fragment$13, safe_not_equal, { item: 0, chatData: 1 });
  }
}
function create_if_block_1$e(ctx) {
  let div;
  let span;
  let t0_value = (
    /*item*/
    (ctx[0].labels?.school ?? "") + ""
  );
  let t0;
  let t1;
  let t2;
  let horizontallineseparator;
  let current;
  let if_block = (
    /*$context*/
    ctx[2].owner && create_if_block_2$b(ctx)
  );
  horizontallineseparator = new HorizontalLineSeparator({ props: { borderColor: "faint" } });
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      t2 = space();
      create_component(horizontallineseparator.$$.fragment);
      attr(div, "class", "info-card-states");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(div, t1);
      if (if_block) if_block.m(div, null);
      insert(target, t2, anchor);
      mount_component(horizontallineseparator, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*item*/
      1) && t0_value !== (t0_value = /*item*/
      (ctx2[0].labels?.school ?? "") + "")) set_data(t0, t0_value);
      if (
        /*$context*/
        ctx2[2].owner
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$b(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t2);
      }
      if (if_block) if_block.d();
      destroy_component(horizontallineseparator, detaching);
    }
  };
}
function create_if_block_2$b(ctx) {
  let if_block_anchor;
  let if_block = (
    /*canPrepare*/
    ctx[3] && create_if_block_3$8(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*canPrepare*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_3$8(ctx) {
  let span;
  let t_value = (
    /*ctx*/
    (ctx[4]?.toggleTitle ?? "") + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*ctx*/
      16 && t_value !== (t_value = /*ctx*/
      (ctx2[4]?.toggleTitle ?? "") + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$r(ctx) {
  let div;
  let span;
  let i2;
  let b2;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].system.uses.value + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*item*/
    ctx[0].system.uses.max + ""
  );
  let t5;
  let t6;
  let horizontallineseparator;
  let current;
  horizontallineseparator = new HorizontalLineSeparator({ props: { borderColor: "faint" } });
  return {
    c() {
      div = element("div");
      span = element("span");
      i2 = element("i");
      b2 = element("b");
      b2.textContent = `${/*localize*/
      ctx[7]("DND5E.Charges")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = text("/");
      t5 = text(t5_value);
      t6 = space();
      create_component(horizontallineseparator.$$.fragment);
      attr(i2, "class", "fas fa-bolt");
      attr(div, "class", "info-card-amount");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, i2);
      append(span, b2);
      append(span, t2);
      append(span, t3);
      append(span, t4);
      append(span, t5);
      insert(target, t6, anchor);
      mount_component(horizontallineseparator, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*item*/
      1) && t3_value !== (t3_value = /*item*/
      ctx2[0].system.uses.value + "")) set_data(t3, t3_value);
      if ((!current || dirty & /*item*/
      1) && t5_value !== (t5_value = /*item*/
      ctx2[0].system.uses.max + "")) set_data(t5, t5_value);
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t6);
      }
      destroy_component(horizontallineseparator, detaching);
    }
  };
}
function create_fragment$12(ctx) {
  let div2;
  let p2;
  let t0_value = (
    /*item*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  let div1;
  let div0;
  let raw_value = (
    /*chatData*/
    ctx[1].description.value + ""
  );
  let t4;
  let div2_class_value;
  let div2_data_item_id_value;
  let current;
  let if_block0 = (
    /*item*/
    (ctx[0].labels?.school || /*$context*/
    ctx[2].owner && /*canPrepare*/
    ctx[3]) && create_if_block_1$e(ctx)
  );
  let if_block1 = (
    /*ctx*/
    ctx[4]?.hasUses && create_if_block$r(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  return {
    c() {
      div2 = element("div");
      p2 = element("p");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      div1 = element("div");
      div0 = element("div");
      t4 = space();
      if (default_slot) default_slot.c();
      attr(p2, "class", "info-card-name");
      attr(div0, "class", "info-card-description");
      attr(div1, "class", "description-wrap");
      attr(div2, "class", div2_class_value = "info-card spellbook " + /*spellRowClasses*/
      ctx[5]);
      attr(div2, "data-item-id", div2_data_item_id_value = /*item*/
      ctx[0]._id);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p2);
      append(p2, t0);
      append(div2, t1);
      if (if_block0) if_block0.m(div2, null);
      append(div2, t2);
      if (if_block1) if_block1.m(div2, null);
      append(div2, t3);
      append(div2, div1);
      append(div1, div0);
      div0.innerHTML = raw_value;
      append(div2, t4);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*item*/
      1) && t0_value !== (t0_value = /*item*/
      ctx2[0].name + "")) set_data(t0, t0_value);
      if (
        /*item*/
        ctx2[0].labels?.school || /*$context*/
        ctx2[2].owner && /*canPrepare*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*item, $context, canPrepare*/
          13) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$e(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*ctx*/
        ctx2[4]?.hasUses
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*ctx*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$r(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*chatData*/
      2) && raw_value !== (raw_value = /*chatData*/
      ctx2[1].description.value + "")) div0.innerHTML = raw_value;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*spellRowClasses*/
      32 && div2_class_value !== (div2_class_value = "info-card spellbook " + /*spellRowClasses*/
      ctx2[5])) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*item*/
      1 && div2_data_item_id_value !== (div2_data_item_id_value = /*item*/
      ctx2[0]._id)) {
        attr(div2, "data-item-id", div2_data_item_id_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let spellRowClasses;
  let ctx;
  let canPrepare;
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { item } = $$props;
  let { chatData } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("chatData" in $$props2) $$invalidate(1, chatData = $$props2.chatData);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(5, spellRowClasses = FoundryAdapter.getSpellRowClasses(item));
    }
    if ($$self.$$.dirty & /*$context, item*/
    5) {
      $$invalidate(4, ctx = $context.itemContext[item.id]);
    }
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(3, canPrepare = FoundryAdapter.canPrepareSpell(item));
    }
  };
  return [
    item,
    chatData,
    $context,
    canPrepare,
    ctx,
    spellRowClasses,
    context,
    localize,
    $$scope,
    slots
  ];
}
class SpellbookItemCardContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$12, create_fragment$12, safe_not_equal, { item: 0, chatData: 1 });
  }
}
function create_if_block_7$2(ctx) {
  let p2;
  let ammoselector;
  let p_data_id_value;
  let t2;
  let horizontallineseparator;
  let current;
  ammoselector = new AmmoSelector({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  horizontallineseparator = new HorizontalLineSeparator({ props: { borderColor: "faint" } });
  return {
    c() {
      p2 = element("p");
      create_component(ammoselector.$$.fragment);
      t2 = space();
      create_component(horizontallineseparator.$$.fragment);
      attr(p2, "class", "ammo-switch");
      attr(p2, "data-id", p_data_id_value = /*item*/
      ctx[0]._id);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      mount_component(ammoselector, p2, null);
      insert(target, t2, anchor);
      mount_component(horizontallineseparator, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ammoselector_changes = {};
      if (dirty & /*item*/
      1) ammoselector_changes.item = /*item*/
      ctx2[0];
      ammoselector.$set(ammoselector_changes);
      if (!current || dirty & /*item*/
      1 && p_data_id_value !== (p_data_id_value = /*item*/
      ctx2[0]._id)) {
        attr(p2, "data-id", p_data_id_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(ammoselector.$$.fragment, local);
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ammoselector.$$.fragment, local);
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p2);
        detach(t2);
      }
      destroy_component(ammoselector);
      destroy_component(horizontallineseparator, detaching);
    }
  };
}
function create_if_block_4$4(ctx) {
  let div;
  let show_if = (
    /*item*/
    ctx[0].system.properties?.has("mgc")
  );
  let t0;
  let t1;
  let horizontallineseparator;
  let current;
  let if_block0 = show_if && create_if_block_6$2();
  let if_block1 = (
    /*ctx*/
    ctx[3]?.attunement && !/*concealDetails*/
    ctx[2] && create_if_block_5$3(ctx)
  );
  horizontallineseparator = new HorizontalLineSeparator({ props: { borderColor: "faint" } });
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      create_component(horizontallineseparator.$$.fragment);
      attr(div, "class", "info-card-states");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if (if_block1) if_block1.m(div, null);
      insert(target, t1, anchor);
      mount_component(horizontallineseparator, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1) show_if = /*item*/
      ctx2[0].system.properties?.has("mgc");
      if (show_if) {
        if (if_block0) ;
        else {
          if_block0 = create_if_block_6$2();
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*ctx*/
        ctx2[3]?.attunement && !/*concealDetails*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$3(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t1);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      destroy_component(horizontallineseparator, detaching);
    }
  };
}
function create_if_block_6$2(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.innerHTML = `<i class="fas fa-magic"></i>Magic Item`;
      attr(span, "class", "flex-row extra-small-gap align-items-center");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_5$3(ctx) {
  let span;
  let i2;
  let t0;
  let t1_value = (
    /*localize*/
    ctx[5](
      /*ctx*/
      ctx[3].attunement.title
    ) + ""
  );
  let t1;
  let span_class_value;
  return {
    c() {
      span = element("span");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fas fa-sun");
      attr(span, "class", span_class_value = "flex-row extra-small-gap align-items-center info-attuned " + /*ctx*/
      (ctx[3].attunement.cls ?? ""));
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, i2);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*ctx*/
      8 && t1_value !== (t1_value = /*localize*/
      ctx2[5](
        /*ctx*/
        ctx2[3].attunement.title
      ) + "")) set_data(t1, t1_value);
      if (dirty & /*ctx*/
      8 && span_class_value !== (span_class_value = "flex-row extra-small-gap align-items-center info-attuned " + /*ctx*/
      (ctx2[3].attunement.cls ?? ""))) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2$a(ctx) {
  let t2;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*concealDetails*/
      ctx2[2]
    ) return create_if_block_3$7;
    return create_else_block_1$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      t2 = text("\n        ");
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, t2, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block_1$2(ctx) {
  let t0_value = (
    /*item*/
    ctx[0].system.price.value + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*item*/
    ctx[0].system.price.denomination + ""
  );
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && t0_value !== (t0_value = /*item*/
      ctx2[0].system.price.value + "")) set_data(t0, t0_value);
      if (dirty & /*item*/
      1 && t2_value !== (t2_value = /*item*/
      ctx2[0].system.price.denomination + "")) set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_if_block_3$7(ctx) {
  let t_value = (
    /*localize*/
    ctx[5]("DND5E.Unidentified.Value") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$d(ctx) {
  let div;
  let span;
  let i2;
  let b2;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].system.uses.value + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*item*/
    ctx[0].system.uses.max + ""
  );
  let t5;
  let t6;
  let horizontallineseparator;
  let current;
  horizontallineseparator = new HorizontalLineSeparator({ props: { borderColor: "faint" } });
  return {
    c() {
      div = element("div");
      span = element("span");
      i2 = element("i");
      b2 = element("b");
      b2.textContent = `${/*localize*/
      ctx[5]("DND5E.Charges")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = text("/");
      t5 = text(t5_value);
      t6 = space();
      create_component(horizontallineseparator.$$.fragment);
      attr(i2, "class", "fas fa-bolt");
      attr(div, "class", "info-card-amount");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, i2);
      append(span, b2);
      append(span, t2);
      append(span, t3);
      append(span, t4);
      append(span, t5);
      insert(target, t6, anchor);
      mount_component(horizontallineseparator, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*item*/
      1) && t3_value !== (t3_value = /*item*/
      ctx2[0].system.uses.value + "")) set_data(t3, t3_value);
      if ((!current || dirty & /*item*/
      1) && t5_value !== (t5_value = /*item*/
      ctx2[0].system.uses.max + "")) set_data(t5, t5_value);
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t6);
      }
      destroy_component(horizontallineseparator, detaching);
    }
  };
}
function create_else_block$i(ctx) {
  let html_tag;
  let raw_value = (
    /*chatData*/
    ctx[1].description.value + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*chatData*/
      2 && raw_value !== (raw_value = /*chatData*/
      ctx2[1].description.value + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block$q(ctx) {
  let html_tag;
  let raw_value = (
    /*chatData*/
    ctx[1].unidentified.description + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*chatData*/
      2 && raw_value !== (raw_value = /*chatData*/
      ctx2[1].unidentified.description + "")) html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_fragment$11(ctx) {
  let div3;
  let p2;
  let t0_value = (
    /*item*/
    (ctx[0].system.identified === false ? coalesce(
      /*item*/
      ctx[0].system.unidentified.name,
      /*localize*/
      ctx[5]("DND5E.Unidentified.Title")
    ) : (
      /*item*/
      ctx[0].name
    )) + ""
  );
  let t0;
  let t1;
  let show_if_1 = (
    /*item*/
    ctx[0].system.properties?.has("amm")
  );
  let t2;
  let show_if = (
    /*item*/
    ctx[0].system.properties?.has("mgc") || /*ctx*/
    ctx[3]?.attunement
  );
  let t3;
  let div0;
  let span0;
  let b0;
  let t6;
  let t7_value = (
    /*item*/
    ctx[0].system.weight.value + ""
  );
  let t7;
  let t8;
  let t9;
  let t10;
  let span1;
  let b1;
  let t13;
  let t14_value = (
    /*item*/
    ctx[0].system.quantity + ""
  );
  let t14;
  let t15;
  let t16;
  let horizontallineseparator;
  let t17;
  let t18;
  let div2;
  let div1;
  let t19;
  let div3_class_value;
  let div3_data_item_id_value;
  let div3_data_item_index_value;
  let current;
  let if_block0 = show_if_1 && create_if_block_7$2(ctx);
  let if_block1 = show_if && create_if_block_4$4(ctx);
  let if_block2 = (
    /*item*/
    ctx[0].system.price.value && create_if_block_2$a(ctx)
  );
  horizontallineseparator = new HorizontalLineSeparator({ props: { borderColor: "faint" } });
  let if_block3 = (
    /*ctx*/
    ctx[3]?.hasUses && create_if_block_1$d(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*concealDetails*/
      ctx2[2]
    ) return create_if_block$q;
    return create_else_block$i;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block4 = current_block_type(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  return {
    c() {
      div3 = element("div");
      p2 = element("p");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      div0 = element("div");
      span0 = element("span");
      b0 = element("b");
      b0.textContent = `${/*localize*/
      ctx[5]("DND5E.Weight")}:`;
      t6 = space();
      t7 = text(t7_value);
      t8 = space();
      t9 = text(
        /*weightUnit*/
        ctx[6]
      );
      t10 = space();
      span1 = element("span");
      b1 = element("b");
      b1.textContent = `${/*localize*/
      ctx[5]("DND5E.Quantity")}:`;
      t13 = space();
      t14 = text(t14_value);
      t15 = space();
      if (if_block2) if_block2.c();
      t16 = space();
      create_component(horizontallineseparator.$$.fragment);
      t17 = space();
      if (if_block3) if_block3.c();
      t18 = space();
      div2 = element("div");
      div1 = element("div");
      if_block4.c();
      t19 = space();
      if (default_slot) default_slot.c();
      attr(p2, "class", "info-card-name");
      attr(span0, "class", "info-weight");
      attr(span1, "class", "info-quantity");
      attr(div0, "class", "info-card-amount");
      attr(div1, "class", "info-card-description");
      attr(div2, "class", "description-wrap");
      attr(div3, "class", div3_class_value = "info-card inventory " + /*item*/
      (ctx[0].attunement?.cls ?? ""));
      attr(div3, "data-item-id", div3_data_item_id_value = /*item*/
      ctx[0]._id);
      attr(div3, "data-item-index", div3_data_item_index_value = /*item*/
      ctx[0]._id);
      toggle_class(
        div3,
        "magic-item",
        /*item*/
        ctx[0].system.properties?.has("mgc")
      );
      toggle_class(
        div3,
        "equipped",
        /*item*/
        ctx[0].system.equipped
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, p2);
      append(p2, t0);
      append(div3, t1);
      if (if_block0) if_block0.m(div3, null);
      append(div3, t2);
      if (if_block1) if_block1.m(div3, null);
      append(div3, t3);
      append(div3, div0);
      append(div0, span0);
      append(span0, b0);
      append(span0, t6);
      append(span0, t7);
      append(span0, t8);
      append(span0, t9);
      append(div0, t10);
      append(div0, span1);
      append(span1, b1);
      append(span1, t13);
      append(span1, t14);
      append(span1, t15);
      if (if_block2) if_block2.m(span1, null);
      append(div3, t16);
      mount_component(horizontallineseparator, div3, null);
      append(div3, t17);
      if (if_block3) if_block3.m(div3, null);
      append(div3, t18);
      append(div3, div2);
      append(div2, div1);
      if_block4.m(div1, null);
      append(div3, t19);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*item*/
      1) && t0_value !== (t0_value = /*item*/
      (ctx2[0].system.identified === false ? coalesce(
        /*item*/
        ctx2[0].system.unidentified.name,
        /*localize*/
        ctx2[5]("DND5E.Unidentified.Title")
      ) : (
        /*item*/
        ctx2[0].name
      )) + "")) set_data(t0, t0_value);
      if (dirty & /*item*/
      1) show_if_1 = /*item*/
      ctx2[0].system.properties?.has("amm");
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & /*item, ctx*/
      9) show_if = /*item*/
      ctx2[0].system.properties?.has("mgc") || /*ctx*/
      ctx2[3]?.attunement;
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*item, ctx*/
          9) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*item*/
      1) && t7_value !== (t7_value = /*item*/
      ctx2[0].system.weight.value + "")) set_data(t7, t7_value);
      if ((!current || dirty & /*item*/
      1) && t14_value !== (t14_value = /*item*/
      ctx2[0].system.quantity + "")) set_data(t14, t14_value);
      if (
        /*item*/
        ctx2[0].system.price.value
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_2$a(ctx2);
          if_block2.c();
          if_block2.m(span1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*ctx*/
        ctx2[3]?.hasUses
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*ctx*/
          8) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$d(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div3, t18);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block4) {
        if_block4.p(ctx2, dirty);
      } else {
        if_block4.d(1);
        if_block4 = current_block_type(ctx2);
        if (if_block4) {
          if_block4.c();
          if_block4.m(div1, null);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*item*/
      1 && div3_class_value !== (div3_class_value = "info-card inventory " + /*item*/
      (ctx2[0].attunement?.cls ?? ""))) {
        attr(div3, "class", div3_class_value);
      }
      if (!current || dirty & /*item*/
      1 && div3_data_item_id_value !== (div3_data_item_id_value = /*item*/
      ctx2[0]._id)) {
        attr(div3, "data-item-id", div3_data_item_id_value);
      }
      if (!current || dirty & /*item*/
      1 && div3_data_item_index_value !== (div3_data_item_index_value = /*item*/
      ctx2[0]._id)) {
        attr(div3, "data-item-index", div3_data_item_index_value);
      }
      if (!current || dirty & /*item, item*/
      1) {
        toggle_class(
          div3,
          "magic-item",
          /*item*/
          ctx2[0].system.properties?.has("mgc")
        );
      }
      if (!current || dirty & /*item, item*/
      1) {
        toggle_class(
          div3,
          "equipped",
          /*item*/
          ctx2[0].system.equipped
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(horizontallineseparator.$$.fragment, local);
      transition_in(if_block3);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(horizontallineseparator.$$.fragment, local);
      transition_out(if_block3);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      destroy_component(horizontallineseparator);
      if (if_block3) if_block3.d();
      if_block4.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  let ctx;
  let concealDetails;
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { item } = $$props;
  let { chatData } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(7, $context = value));
  const localize = FoundryAdapter.localize;
  const weightUnit = FoundryAdapter.getWeightUnit();
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("chatData" in $$props2) $$invalidate(1, chatData = $$props2.chatData);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, item*/
    129) {
      $$invalidate(3, ctx = $context.itemContext?.[item.id]);
    }
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(2, concealDetails = FoundryAdapter.concealDetails(item));
    }
  };
  return [
    item,
    chatData,
    concealDetails,
    ctx,
    context,
    localize,
    weightUnit,
    $context,
    $$scope,
    slots
  ];
}
class InventoryItemCardContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$11, create_fragment$11, safe_not_equal, { item: 0, chatData: 1 });
  }
}
function getItemCardContentTemplate(item) {
  const inventoryTypes = Inventory.getDefaultInventoryTypes();
  const intentoryItems = new Set(inventoryTypes);
  if (intentoryItems.has(item?.type)) {
    return InventoryItemCardContent;
  }
  switch (item?.type) {
    case "spell":
      return SpellbookItemCardContent;
    case "race":
    case "background":
    case "class":
    case "subclass":
    case "feat":
    default:
      return DefaultItemCardContentTemplate;
  }
}
function get_each_context$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i2];
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i2];
  return child_ctx;
}
function create_else_block$h(ctx) {
  let h2;
  return {
    c() {
      h2 = element("h2");
      h2.textContent = " Unable to show item card contents";
    },
    m(target, anchor) {
      insert(target, h2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
    }
  };
}
function create_if_block$p(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*infoContentTemplate*/
    ctx[8] ?? getItemCardContentTemplate(
      /*item*/
      ctx[3]
    )
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        item: (
          /*item*/
          ctx2[3]
        ),
        chatData: (
          /*chatData*/
          ctx2[4]
        ),
        $$slots: { default: [create_default_slot$l] },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*infoContentTemplate, item*/
      264 && switch_value !== (switch_value = /*infoContentTemplate*/
      ctx2[8] ?? getItemCardContentTemplate(
        /*item*/
        ctx2[3]
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*item*/
        8) switch_instance_changes.item = /*item*/
        ctx2[3];
        if (dirty[0] & /*chatData*/
        16) switch_instance_changes.chatData = /*chatData*/
        ctx2[4];
        if (dirty[0] & /*item, itemSummaryCommands, concealDetails, itemProps, specialProps*/
        11784 | dirty[1] & /*$$scope*/
        64) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_3$6(ctx) {
  let horizontallineseparator;
  let t2;
  let div;
  let current;
  horizontallineseparator = new HorizontalLineSeparator({});
  let each_value_1 = ensure_array_like(
    /*specialProps*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i2));
  }
  return {
    c() {
      create_component(horizontallineseparator.$$.fragment);
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "inline-wrapped-elements");
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_PROPERTY_LIST);
      div.inert = /*concealDetails*/
      ctx[13];
    },
    m(target, anchor) {
      mount_component(horizontallineseparator, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*specialProps*/
      1024) {
        each_value_1 = ensure_array_like(
          /*specialProps*/
          ctx2[10]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (!current || dirty[0] & /*concealDetails*/
      8192) {
        div.inert = /*concealDetails*/
        ctx2[13];
      }
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(horizontallineseparator, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1$1(ctx) {
  let span;
  let t_value = (
    /*prop*/
    ctx[32] + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "tag");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*specialProps*/
      1024 && t_value !== (t_value = /*prop*/
      ctx2[32] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2$9(ctx) {
  let horizontallineseparator;
  let t2;
  let div;
  let current;
  horizontallineseparator = new HorizontalLineSeparator({});
  let each_value = ensure_array_like(
    /*itemProps*/
    ctx[9]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$7(get_each_context$7(ctx, each_value, i2));
  }
  return {
    c() {
      create_component(horizontallineseparator.$$.fragment);
      t2 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "inline-wrapped-elements");
      attr(div, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ITEM_PROPERTY_LIST);
      div.inert = /*concealDetails*/
      ctx[13];
    },
    m(target, anchor) {
      mount_component(horizontallineseparator, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*itemProps*/
      512) {
        each_value = ensure_array_like(
          /*itemProps*/
          ctx2[9]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$7(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*concealDetails*/
      8192) {
        div.inert = /*concealDetails*/
        ctx2[13];
      }
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(horizontallineseparator, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$7(ctx) {
  let span;
  let t_value = (
    /*prop*/
    ctx[32] + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "tag");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*itemProps*/
      512 && t_value !== (t_value = /*prop*/
      ctx2[32] + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$c(ctx) {
  let horizontallineseparator;
  let t2;
  let div;
  let itemsummarycommandbuttonlist;
  let current;
  horizontallineseparator = new HorizontalLineSeparator({});
  itemsummarycommandbuttonlist = new ItemSummaryCommandButtonList({ props: { item: (
    /*item*/
    ctx[3]
  ) } });
  return {
    c() {
      create_component(horizontallineseparator.$$.fragment);
      t2 = space();
      div = element("div");
      create_component(itemsummarycommandbuttonlist.$$.fragment);
      attr(div, "class", "inline-wrapped-elements");
    },
    m(target, anchor) {
      mount_component(horizontallineseparator, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      mount_component(itemsummarycommandbuttonlist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const itemsummarycommandbuttonlist_changes = {};
      if (dirty[0] & /*item*/
      8) itemsummarycommandbuttonlist_changes.item = /*item*/
      ctx2[3];
      itemsummarycommandbuttonlist.$set(itemsummarycommandbuttonlist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(horizontallineseparator.$$.fragment, local);
      transition_in(itemsummarycommandbuttonlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontallineseparator.$$.fragment, local);
      transition_out(itemsummarycommandbuttonlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div);
      }
      destroy_component(horizontallineseparator, detaching);
      destroy_component(itemsummarycommandbuttonlist);
    }
  };
}
function create_default_slot$l(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*specialProps*/
    ctx[10].length && create_if_block_3$6(ctx)
  );
  let if_block1 = (
    /*itemProps*/
    ctx[9].length && create_if_block_2$9(ctx)
  );
  let if_block2 = (
    /*itemSummaryCommands*/
    ctx[11].length && create_if_block_1$c(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*specialProps*/
        ctx2[10].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*specialProps*/
          1024) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*itemProps*/
        ctx2[9].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*itemProps*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*itemSummaryCommands*/
        ctx2[11].length
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*itemSummaryCommands*/
          2048) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$c(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block2_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_fragment$10(ctx) {
  let section;
  let div;
  let article0;
  let current_block_type_index;
  let if_block;
  let t0;
  let horizontallineseparator;
  let t1;
  let article1;
  let p0;
  let span;
  let t2;
  let t3;
  let t4_value = (
    /*localize*/
    ctx[15]("TIDY5E.ItemCardsKeyHint") + ""
  );
  let t4;
  let t5;
  let p1;
  let i2;
  let t6;
  let t7_value = (
    /*localize*/
    ctx[15]("TIDY5E.ItemCardsMouseHint") + ""
  );
  let t7;
  let style___card_width = `${cardWidthRem}rem`;
  let style___card_height = `${cardHeightRem}rem`;
  let current;
  const if_block_creators = [create_if_block$p, create_else_block$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!!/*item*/
    ctx2[3] && !!/*chatData*/
    ctx2[4]) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  horizontallineseparator = new HorizontalLineSeparator({});
  return {
    c() {
      section = element("section");
      div = element("div");
      article0 = element("article");
      if_block.c();
      t0 = space();
      create_component(horizontallineseparator.$$.fragment);
      t1 = space();
      article1 = element("article");
      p0 = element("p");
      span = element("span");
      t2 = text(
        /*fixKey*/
        ctx[12]
      );
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      p1 = element("p");
      i2 = element("i");
      t6 = space();
      t7 = text(t7_value);
      attr(article0, "class", "item-info-container-content svelte-9nqrkk");
      attr(span, "class", "key svelte-9nqrkk");
      attr(p0, "class", "svelte-9nqrkk");
      toggle_class(
        p0,
        "frozen",
        /*frozen*/
        ctx[0]
      );
      attr(i2, "class", "fas fa-mouse");
      attr(p1, "class", "svelte-9nqrkk");
      attr(article1, "class", "item-info-card-hints svelte-9nqrkk");
      attr(div, "class", "info-wrap svelte-9nqrkk");
      attr(section, "class", "item-info-container svelte-9nqrkk");
      toggle_class(
        section,
        "open",
        /*open*/
        ctx[2]
      );
      toggle_class(
        section,
        "floating",
        /*$settingStore*/
        ctx[5].itemCardsAreFloating
      );
      set_style(
        section,
        "top",
        /*$settingStore*/
        ctx[5].itemCardsAreFloating ? (
          /*floatingTop*/
          ctx[6]
        ) : void 0
      );
      set_style(
        section,
        "left",
        /*$settingStore*/
        ctx[5].itemCardsAreFloating ? (
          /*floatingLeft*/
          ctx[7]
        ) : void 0
      );
      set_style(section, "--card-width", style___card_width);
      set_style(section, "--card-height", style___card_height);
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div);
      append(div, article0);
      if_blocks[current_block_type_index].m(article0, null);
      append(div, t0);
      mount_component(horizontallineseparator, div, null);
      append(div, t1);
      append(div, article1);
      append(article1, p0);
      append(p0, span);
      append(span, t2);
      append(p0, t3);
      append(p0, t4);
      append(article1, t5);
      append(article1, p1);
      append(p1, i2);
      append(p1, t6);
      append(p1, t7);
      ctx[19](section);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(article0, null);
      }
      if (!current || dirty[0] & /*fixKey*/
      4096) set_data(
        t2,
        /*fixKey*/
        ctx2[12]
      );
      if (!current || dirty[0] & /*frozen*/
      1) {
        toggle_class(
          p0,
          "frozen",
          /*frozen*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*open*/
      4) {
        toggle_class(
          section,
          "open",
          /*open*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*$settingStore*/
      32) {
        toggle_class(
          section,
          "floating",
          /*$settingStore*/
          ctx2[5].itemCardsAreFloating
        );
      }
      if (dirty[0] & /*$settingStore, floatingTop*/
      96) {
        set_style(
          section,
          "top",
          /*$settingStore*/
          ctx2[5].itemCardsAreFloating ? (
            /*floatingTop*/
            ctx2[6]
          ) : void 0
        );
      }
      if (dirty[0] & /*$settingStore, floatingLeft*/
      160) {
        set_style(
          section,
          "left",
          /*$settingStore*/
          ctx2[5].itemCardsAreFloating ? (
            /*floatingLeft*/
            ctx2[7]
          ) : void 0
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(horizontallineseparator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(horizontallineseparator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if_blocks[current_block_type_index].d();
      destroy_component(horizontallineseparator);
      ctx[19](null);
    }
  };
}
const cardWidthRem = 17.5;
const cardHeightRem = 28.75;
const mouseCursorCardGapRem = 1.5;
function getRootFontSizePx() {
  return document.documentElement.style.fontSize !== "" ? parseFloat(document.documentElement.style.fontSize) : parseFloat(getComputedStyle(document.documentElement).fontSize);
}
function getSpecialProperties(item2) {
  const props = [];
  if (item2?.labels?.toHit) {
    props.push(item2.labels.toHit.replace("+ ", "+").replace("- ", "-"));
  }
  if (item2?.labels?.damage && item2.labels?.derivedDamage?.length > 0) {
    props.push(item2.labels.derivedDamage[0].label.replace(" + ", "+").replace(" - ", "-"));
  }
  if (item2?.labels?.save) {
    props.push(item2.labels.save);
  }
  return props;
}
function instance$10($$self, $$props, $$invalidate) {
  let fixKey;
  let concealDetails;
  let delayMs;
  let itemSummaryCommands;
  let specialProps;
  let itemProps;
  let $card;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let frozen = false;
  function detectFixStart(ev) {
    if (frozen) {
      return;
    }
    $$invalidate(0, frozen = ev.key?.toUpperCase() === fixKey);
  }
  function detectFixStop(ev) {
    if (ev.key?.toUpperCase() === fixKey) {
      $$invalidate(0, frozen = false);
    }
  }
  let lastMouseEvent = null;
  let floatingTop = null;
  let floatingLeft = null;
  let sheetBorderRight = 0;
  let sheetBorderBottom = 0;
  let itemCardNode;
  let sheet = null;
  function onMouseMove(args) {
    lastMouseEvent = args;
    if (!$settingStore.itemCardsAreFloating || !open || frozen) {
      return;
    }
    positionFloatingCard();
  }
  function positionFloatingCard() {
    if (!lastMouseEvent) {
      return;
    }
    const cardWidthPx = rootFontSizePx * cardWidthRem;
    const cardHeightPx = rootFontSizePx * cardHeightRem;
    const cardHalfHeightPx = cardHeightPx / 2;
    const mouseCursorCardGapPx = rootFontSizePx * mouseCursorCardGapRem;
    let mousePos = {
      x: lastMouseEvent.clientX,
      y: lastMouseEvent.clientY
    };
    let top = `${mousePos.y - cardHalfHeightPx}px`;
    let left = `${mousePos.x + mouseCursorCardGapPx}px`;
    if (mousePos.x + cardWidthPx > sheetBorderRight) {
      left = `${mousePos.x - cardWidthPx - mouseCursorCardGapPx}px`;
    }
    if (mousePos.y + cardHalfHeightPx > sheetBorderBottom) {
      let diff = sheetBorderBottom - (mousePos.y + cardHalfHeightPx);
      top = `${mousePos.y - cardHalfHeightPx + diff}px`;
    }
    $$invalidate(6, floatingTop = top);
    $$invalidate(7, floatingLeft = left);
  }
  let open = false;
  function listenForBodyEvents(body) {
    body.addEventListener("keydown", detectFixStart);
    body.addEventListener("keyup", detectFixStop);
    body.addEventListener("mousemove", onMouseMove);
  }
  function stopListeningForBodyEvents(body) {
    body.addEventListener("keydown", detectFixStart);
    body.addEventListener("keyup", detectFixStop);
    body.addEventListener("mousemove", onMouseMove);
  }
  let timer;
  let infoContentTemplate;
  async function showCard() {
    if (!$card.item) {
      return;
    }
    $$invalidate(4, chatData = await $card.item.getChatData({ secrets: $card.item.actor?.isOwner }));
    if ($card.item) {
      $$invalidate(8, infoContentTemplate = $card.itemCardContentTemplate);
      $$invalidate(3, item = $card.item);
      if ($settingStore.itemCardsAreFloating) {
        rootFontSizePx = getRootFontSizePx();
        const boundingClientRect = sheet?.getBoundingClientRect();
        if (boundingClientRect) {
          sheetBorderRight = boundingClientRect.right;
          sheetBorderBottom = boundingClientRect.bottom;
        }
        positionFloatingCard();
      }
      $$invalidate(2, open = true);
    }
  }
  const card = getContext(CONSTANTS.SVELTE_CONTEXT.CARD);
  component_subscribe($$self, card, (value) => $$invalidate(18, $card = value));
  let rootFontSizePx = getRootFontSizePx();
  let item;
  let chatData;
  onMount(() => {
    sheet = $card.sheet;
    if (sheet) {
      sheet.addEventListener("mousemove", onMouseMove);
    } else {
      warn("Item Card parent sheet not found. Unable to support floating item card.");
    }
  });
  onDestroy(() => {
    const body = itemCardNode.ownerDocument.body;
    body && stopListeningForBodyEvents(body);
  });
  const localize = FoundryAdapter.localize;
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      itemCardNode = $$value;
      $$invalidate(1, itemCardNode);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$settingStore*/
    32) {
      $$invalidate(12, fixKey = $settingStore.itemCardsFixKey?.toUpperCase());
    }
    if ($$self.$$.dirty[0] & /*item*/
    8) {
      $$invalidate(13, concealDetails = FoundryAdapter.concealDetails(item));
    }
    if ($$self.$$.dirty[0] & /*$settingStore*/
    32) {
      $$invalidate(17, delayMs = $settingStore.itemCardsDelay ?? 0);
    }
    if ($$self.$$.dirty[0] & /*$card, frozen, item, open, timer, delayMs*/
    458765) {
      (async () => {
        if (frozen) {
          return;
        }
        if ($card.item?.id === item?.id && open) {
          return;
        }
        $$invalidate(2, open = false);
        clearTimeout(timer);
        const newItem = $card.item;
        if (!newItem) {
          return;
        }
        $$invalidate(16, timer = setTimeout(() => showCard(), delayMs));
      })();
    }
    if ($$self.$$.dirty[0] & /*itemCardNode, open*/
    6) {
      {
        const body = itemCardNode?.ownerDocument?.body;
        if (body && open) {
          listenForBodyEvents(body);
        } else if (body && !open) {
          stopListeningForBodyEvents(body);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*item*/
    8) {
      $$invalidate(11, itemSummaryCommands = ItemSummaryRuntime.getItemSummaryCommands(item));
    }
    if ($$self.$$.dirty[0] & /*item*/
    8) {
      $$invalidate(10, specialProps = getSpecialProperties(item));
    }
    if ($$self.$$.dirty[0] & /*chatData*/
    16) {
      $$invalidate(9, itemProps = chatData?.properties ?? []);
    }
  };
  return [
    frozen,
    itemCardNode,
    open,
    item,
    chatData,
    $settingStore,
    floatingTop,
    floatingLeft,
    infoContentTemplate,
    itemProps,
    specialProps,
    itemSummaryCommands,
    fixKey,
    concealDetails,
    card,
    localize,
    timer,
    delayMs,
    $card,
    section_binding
  ];
}
class ItemInfoCard extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$10, create_fragment$10, safe_not_equal, {}, null, [-1, -1]);
  }
}
function create_else_block$g(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.rarity",
      value: (
        /*$context*/
        ctx[1].system.rarity
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      blankValue: "",
      $$slots: { default: [create_default_slot$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      2) select_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select_changes.value = /*$context*/
      ctx2[1].system.rarity;
      if (dirty & /*$context*/
      2) select_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      34) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block$o(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[3]("DND5E.Unidentified.Title")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot$k(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.itemRarity
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.itemRarity;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_fragment$$(ctx) {
  let iteminfocard;
  let t0;
  let header;
  let itemprofilepicture;
  let t1;
  let div1;
  let h1;
  let itemidentifiablename;
  let t2;
  let div0;
  let h4;
  let t3_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t3;
  let t4;
  let ul;
  let li0;
  let current_block_type_index;
  let if_block;
  let t5;
  let li1;
  let source;
  let t6;
  let itemheadertoggles;
  let t7;
  let tabs;
  let updating_selectedTabId;
  let t8;
  let section;
  let tabcontents;
  let current;
  iteminfocard = new ItemInfoCard({});
  itemprofilepicture = new ItemProfilePicture({});
  itemidentifiablename = new ItemIdentifiableName({});
  const if_block_creators = [create_if_block$o, create_else_block$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].concealDetails
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable && !/*$context*/
        ctx[1].concealDetails
      )
    }
  });
  itemheadertoggles = new ItemHeaderToggles({});
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(iteminfocard.$$.fragment);
      t0 = space();
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t1 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(itemidentifiablename.$$.fragment);
      t2 = space();
      div0 = element("div");
      h4 = element("h4");
      t3 = text(t3_value);
      t4 = space();
      ul = element("ul");
      li0 = element("li");
      if_block.c();
      t5 = space();
      li1 = element("li");
      create_component(source.$$.fragment);
      t6 = space();
      create_component(itemheadertoggles.$$.fragment);
      t7 = space();
      create_component(tabs.$$.fragment);
      t8 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(div0, "class", "item-subtitle");
      attr(li1, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header container-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      mount_component(iteminfocard, target, anchor);
      insert(target, t0, anchor);
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t1);
      append(header, div1);
      append(div1, h1);
      mount_component(itemidentifiablename, h1, null);
      append(div1, t2);
      append(div1, div0);
      append(div0, h4);
      append(h4, t3);
      append(div1, t4);
      append(div1, ul);
      append(ul, li0);
      if_blocks[current_block_type_index].m(li0, null);
      append(ul, t5);
      append(ul, li1);
      mount_component(source, li1, null);
      append(div1, t6);
      mount_component(itemheadertoggles, div1, null);
      insert(target, t7, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t8, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$context*/
      2) && t3_value !== (t3_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t3, t3_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li0, null);
      }
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable && !/*$context*/
      ctx2[1].concealDetails;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(iteminfocard.$$.fragment, local);
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(itemidentifiablename.$$.fragment, local);
      transition_in(if_block);
      transition_in(source.$$.fragment, local);
      transition_in(itemheadertoggles.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iteminfocard.$$.fragment, local);
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(itemidentifiablename.$$.fragment, local);
      transition_out(if_block);
      transition_out(source.$$.fragment, local);
      transition_out(itemheadertoggles.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(header);
        detach(t7);
        detach(t8);
        detach(section);
      }
      destroy_component(iteminfocard, detaching);
      destroy_component(itemprofilepicture);
      destroy_component(itemidentifiablename);
      if_blocks[current_block_type_index].d();
      destroy_component(source);
      destroy_component(itemheadertoggles);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$$($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class ContainerSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$$, create_fragment$$, safe_not_equal, {});
  }
}
function create_fragment$_(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let textinput0;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let span;
  let t4_value = (
    /*$context*/
    (ctx[1].itemStatus ?? "") + ""
  );
  let t4;
  let t5;
  let ul;
  let li0;
  let t6_value = (
    /*$context*/
    (ctx[1].labels.featType ?? "") + ""
  );
  let t6;
  let t7;
  let li1;
  let textinput1;
  let t8;
  let li2;
  let source;
  let t9;
  let tabs;
  let updating_selectedTabId;
  let t10;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  textinput0 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "name",
      placeholder: (
        /*localize*/
        ctx[3]("DND5E.ItemName")
      ),
      value: (
        /*$context*/
        ctx[1].item.name
      ),
      attributes: {
        "data-tidy-item-name": (
          /*$context*/
          ctx[1].item.name
        )
      },
      disabled: !/*$context*/
      ctx[1].editable,
      title: (
        /*$context*/
        ctx[1].item.name
      )
    }
  });
  textinput1 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.requirements",
      value: (
        /*$context*/
        ctx[1].system.requirements
      ),
      placeholder: (
        /*localize*/
        ctx[3]("DND5E.Requirements")
      ),
      disabled: !/*$context*/
      ctx[1].editable
    }
  });
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable
      )
    }
  });
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(textinput0.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      ul = element("ul");
      li0 = element("li");
      t6 = text(t6_value);
      t7 = space();
      li1 = element("li");
      create_component(textinput1.$$.fragment);
      t8 = space();
      li2 = element("li");
      create_component(source.$$.fragment);
      t9 = space();
      create_component(tabs.$$.fragment);
      t10 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(span, "class", "item-status");
      attr(div0, "class", "item-subtitle");
      attr(li2, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(textinput0, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div0, t3);
      append(div0, span);
      append(span, t4);
      append(div1, t5);
      append(div1, ul);
      append(ul, li0);
      append(li0, t6);
      append(ul, t7);
      append(ul, li1);
      mount_component(textinput1, li1, null);
      append(ul, t8);
      append(ul, li2);
      mount_component(source, li2, null);
      insert(target, t9, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t10, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput0_changes = {};
      if (dirty & /*$context*/
      2) textinput0_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput0_changes.value = /*$context*/
      ctx2[1].item.name;
      if (dirty & /*$context*/
      2) textinput0_changes.attributes = {
        "data-tidy-item-name": (
          /*$context*/
          ctx2[1].item.name
        )
      };
      if (dirty & /*$context*/
      2) textinput0_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$context*/
      2) textinput0_changes.title = /*$context*/
      ctx2[1].item.name;
      textinput0.$set(textinput0_changes);
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      (ctx2[1].itemStatus ?? "") + "")) set_data(t4, t4_value);
      if ((!current || dirty & /*$context*/
      2) && t6_value !== (t6_value = /*$context*/
      (ctx2[1].labels.featType ?? "") + "")) set_data(t6, t6_value);
      const textinput1_changes = {};
      if (dirty & /*$context*/
      2) textinput1_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput1_changes.value = /*$context*/
      ctx2[1].system.requirements;
      if (dirty & /*$context*/
      2) textinput1_changes.disabled = !/*$context*/
      ctx2[1].editable;
      textinput1.$set(textinput1_changes);
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(textinput0.$$.fragment, local);
      transition_in(textinput1.$$.fragment, local);
      transition_in(source.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(textinput0.$$.fragment, local);
      transition_out(textinput1.$$.fragment, local);
      transition_out(source.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t9);
        detach(t10);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(textinput0);
      destroy_component(textinput1);
      destroy_component(source);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$_($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class FeatSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$_, create_fragment$_, safe_not_equal, {});
  }
}
function create_else_block$f(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[2].item
      ),
      field: "system.rarity",
      value: (
        /*$context*/
        ctx[2].system.rarity
      ),
      disabled: !/*$context*/
      ctx[2].editable,
      blankValue: "",
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      4) select_changes.document = /*$context*/
      ctx2[2].item;
      if (dirty & /*$context*/
      4) select_changes.value = /*$context*/
      ctx2[2].system.rarity;
      if (dirty & /*$context*/
      4) select_changes.disabled = !/*$context*/
      ctx2[2].editable;
      if (dirty & /*$$scope, $context*/
      68) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_1$b(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[4]("DND5E.Unidentified.Title")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_1$2(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[2].config.itemRarity
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      4) selectoptions_changes.data = /*$context*/
      ctx2[2].config.itemRarity;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_if_block$n(ctx) {
  let propertytoggle;
  let current;
  propertytoggle = new PropertyToggle({
    props: {
      document: (
        /*$context*/
        ctx[2].item
      ),
      field: "system.identified",
      checked: (
        /*$context*/
        ctx[2].system.identified
      ),
      disabled: !/*$context*/
      ctx[2].editable,
      title: (
        /*$context*/
        ctx[2].system.identified ? (
          /*localize*/
          ctx[4]("DND5E.Identified")
        ) : (
          /*localize*/
          ctx[4]("DND5E.Unidentified.Title")
        )
      ),
      iconClass: "fas fa-magnifying-glass fa-fw",
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(propertytoggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(propertytoggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const propertytoggle_changes = {};
      if (dirty & /*$context*/
      4) propertytoggle_changes.document = /*$context*/
      ctx2[2].item;
      if (dirty & /*$context*/
      4) propertytoggle_changes.checked = /*$context*/
      ctx2[2].system.identified;
      if (dirty & /*$context*/
      4) propertytoggle_changes.disabled = !/*$context*/
      ctx2[2].editable;
      if (dirty & /*$context*/
      4) propertytoggle_changes.title = /*$context*/
      ctx2[2].system.identified ? (
        /*localize*/
        ctx2[4]("DND5E.Identified")
      ) : (
        /*localize*/
        ctx2[4]("DND5E.Unidentified.Title")
      );
      if (dirty & /*$$scope, identifiedLabelWidthCh, $context*/
      70) {
        propertytoggle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      propertytoggle.$set(propertytoggle_changes);
    },
    i(local) {
      if (current) return;
      transition_in(propertytoggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(propertytoggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(propertytoggle, detaching);
    }
  };
}
function create_default_slot$j(ctx) {
  let div;
  let t_value = (
    /*$context*/
    (ctx[2].system.identified ? (
      /*localize*/
      ctx[4]("DND5E.Identified")
    ) : (
      /*localize*/
      ctx[4]("DND5E.Unidentified.Title")
    )) + ""
  );
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      set_style(
        div,
        "width",
        /*identifiedLabelWidthCh*/
        ctx[1] + "ch"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      4 && t_value !== (t_value = /*$context*/
      (ctx2[2].system.identified ? (
        /*localize*/
        ctx2[4]("DND5E.Identified")
      ) : (
        /*localize*/
        ctx2[4]("DND5E.Unidentified.Title")
      )) + "")) set_data(t2, t_value);
      if (dirty & /*identifiedLabelWidthCh*/
      2) {
        set_style(
          div,
          "width",
          /*identifiedLabelWidthCh*/
          ctx2[1] + "ch"
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment$Z(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div2;
  let h1;
  let itemidentifiablename;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[2].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let span;
  let t4_value = (
    /*$context*/
    (ctx[2].itemStatus ?? "") + ""
  );
  let t4;
  let t5;
  let ul;
  let li0;
  let current_block_type_index;
  let if_block0;
  let t6;
  let li1;
  let source;
  let t7;
  let div1;
  let show_if = FoundryAdapter.canIdentify(
    /*$context*/
    ctx[2].item
  );
  let t8;
  let tabs;
  let updating_selectedTabId;
  let t9;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  itemidentifiablename = new ItemIdentifiableName({});
  const if_block_creators = [create_if_block_1$b, create_else_block$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[2].concealDetails
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[2].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[2].editable && !/*$context*/
        ctx[2].concealDetails
      )
    }
  });
  let if_block1 = show_if && create_if_block$n(ctx);
  function tabs_selectedTabId_binding(value) {
    ctx[5](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[2].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[2].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div2 = element("div");
      h1 = element("h1");
      create_component(itemidentifiablename.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      ul = element("ul");
      li0 = element("li");
      if_block0.c();
      t6 = space();
      li1 = element("li");
      create_component(source.$$.fragment);
      t7 = space();
      div1 = element("div");
      if (if_block1) if_block1.c();
      t8 = space();
      create_component(tabs.$$.fragment);
      t9 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(span, "class", "item-status");
      attr(div0, "class", "item-subtitle");
      attr(li1, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "flex-row no-gap");
      attr(div2, "class", "header-details flexrow small-gap");
      attr(div2, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header loot-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div2);
      append(div2, h1);
      mount_component(itemidentifiablename, h1, null);
      append(div2, t1);
      append(div2, div0);
      append(div0, h4);
      append(h4, t2);
      append(div0, t3);
      append(div0, span);
      append(span, t4);
      append(div2, t5);
      append(div2, ul);
      append(ul, li0);
      if_blocks[current_block_type_index].m(li0, null);
      append(ul, t6);
      append(ul, li1);
      mount_component(source, li1, null);
      append(div2, t7);
      append(div2, div1);
      if (if_block1) if_block1.m(div1, null);
      insert(target, t8, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t9, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$context*/
      4) && t2_value !== (t2_value = /*$context*/
      (ctx2[2].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      4) && t4_value !== (t4_value = /*$context*/
      (ctx2[2].itemStatus ?? "") + "")) set_data(t4, t4_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(li0, null);
      }
      const source_changes = {};
      if (dirty & /*$context*/
      4) source_changes.document = /*$context*/
      ctx2[2].item;
      if (dirty & /*$context*/
      4) source_changes.editable = /*$context*/
      ctx2[2].editable && !/*$context*/
      ctx2[2].concealDetails;
      source.$set(source_changes);
      if (dirty & /*$context*/
      4) show_if = FoundryAdapter.canIdentify(
        /*$context*/
        ctx2[2].item
      );
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$n(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const tabs_changes = {};
      if (dirty & /*$context*/
      4) tabs_changes.tabs = /*$context*/
      ctx2[2].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      4) tabcontents_changes.tabs = /*$context*/
      ctx2[2].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(itemidentifiablename.$$.fragment, local);
      transition_in(if_block0);
      transition_in(source.$$.fragment, local);
      transition_in(if_block1);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(itemidentifiablename.$$.fragment, local);
      transition_out(if_block0);
      transition_out(source.$$.fragment, local);
      transition_out(if_block1);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t8);
        detach(t9);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(itemidentifiablename);
      if_blocks[current_block_type_index].d();
      destroy_component(source);
      if (if_block1) if_block1.d();
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$Z($$self, $$props, $$invalidate) {
  let identifiedLabelWidthCh;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(2, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  $$invalidate(1, identifiedLabelWidthCh = Math.max(localize("DND5E.Identified").length, localize("DND5E.Unidentified.Title").length));
  return [
    selectedTabId,
    identifiedLabelWidthCh,
    $context,
    context,
    localize,
    tabs_selectedTabId_binding
  ];
}
class LootSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});
  }
}
function create_fragment$Y(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let textinput;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let span;
  let t4_value = (
    /*$context*/
    (ctx[1].itemStatus ?? "") + ""
  );
  let t4;
  let t5;
  let ul;
  let li0;
  let t6_value = (
    /*$context*/
    (ctx[1].labels.level ?? "") + ""
  );
  let t6;
  let t7;
  let li1;
  let t8_value = (
    /*$context*/
    (ctx[1].labels.school ?? "") + ""
  );
  let t8;
  let t9;
  let li2;
  let source;
  let t10;
  let tabs;
  let updating_selectedTabId;
  let t11;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "name",
      value: (
        /*$context*/
        ctx[1].item.name
      ),
      attributes: {
        "data-tidy-item-name": (
          /*$context*/
          ctx[1].item.name
        )
      },
      placeholder: (
        /*localize*/
        ctx[3]("DND5E.SpellName")
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      title: (
        /*$context*/
        ctx[1].item.name
      )
    }
  });
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable
      )
    }
  });
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(textinput.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      ul = element("ul");
      li0 = element("li");
      t6 = text(t6_value);
      t7 = space();
      li1 = element("li");
      t8 = text(t8_value);
      t9 = space();
      li2 = element("li");
      create_component(source.$$.fragment);
      t10 = space();
      create_component(tabs.$$.fragment);
      t11 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(span, "class", "item-status");
      attr(div0, "class", "item-subtitle");
      attr(li2, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(textinput, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div0, t3);
      append(div0, span);
      append(span, t4);
      append(div1, t5);
      append(div1, ul);
      append(ul, li0);
      append(li0, t6);
      append(ul, t7);
      append(ul, li1);
      append(li1, t8);
      append(ul, t9);
      append(ul, li2);
      mount_component(source, li2, null);
      insert(target, t10, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t11, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].item.name;
      if (dirty & /*$context*/
      2) textinput_changes.attributes = {
        "data-tidy-item-name": (
          /*$context*/
          ctx2[1].item.name
        )
      };
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$context*/
      2) textinput_changes.title = /*$context*/
      ctx2[1].item.name;
      textinput.$set(textinput_changes);
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      (ctx2[1].itemStatus ?? "") + "")) set_data(t4, t4_value);
      if ((!current || dirty & /*$context*/
      2) && t6_value !== (t6_value = /*$context*/
      (ctx2[1].labels.level ?? "") + "")) set_data(t6, t6_value);
      if ((!current || dirty & /*$context*/
      2) && t8_value !== (t8_value = /*$context*/
      (ctx2[1].labels.school ?? "") + "")) set_data(t8, t8_value);
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      transition_in(source.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      transition_out(source.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t10);
        detach(t11);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(textinput);
      destroy_component(source);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$Y($$self, $$props, $$invalidate) {
  let selectedTabId;
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  $$invalidate(0, selectedTabId = getContext(CONSTANTS.SVELTE_CONTEXT.CURRENT_TAB_ID));
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class SpellSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});
  }
}
function create_fragment$X(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let textinput;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let span;
  let t4_value = (
    /*$context*/
    (ctx[1].itemStatus ?? "") + ""
  );
  let t4;
  let t5;
  let ul;
  let li;
  let source;
  let t6;
  let tabs;
  let updating_selectedTabId;
  let t7;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  textinput = new TextInput$1({
    props: {
      field: "name",
      document: (
        /*$context*/
        ctx[1].item
      ),
      value: (
        /*$context*/
        ctx[1].item.name
      ),
      attributes: {
        "data-tidy-item-name": (
          /*$context*/
          ctx[1].item.name
        )
      },
      placeholder: (
        /*localize*/
        ctx[3]("DND5E.SubclassName")
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      title: (
        /*$context*/
        ctx[1].item.name
      )
    }
  });
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable
      )
    }
  });
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(textinput.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      ul = element("ul");
      li = element("li");
      create_component(source.$$.fragment);
      t6 = space();
      create_component(tabs.$$.fragment);
      t7 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(span, "class", "item-status");
      attr(div0, "class", "item-subtitle");
      attr(li, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(textinput, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div0, t3);
      append(div0, span);
      append(span, t4);
      append(div1, t5);
      append(div1, ul);
      append(ul, li);
      mount_component(source, li, null);
      insert(target, t6, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t7, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].item.name;
      if (dirty & /*$context*/
      2) textinput_changes.attributes = {
        "data-tidy-item-name": (
          /*$context*/
          ctx2[1].item.name
        )
      };
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$context*/
      2) textinput_changes.title = /*$context*/
      ctx2[1].item.name;
      textinput.$set(textinput_changes);
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      (ctx2[1].itemStatus ?? "") + "")) set_data(t4, t4_value);
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      transition_in(source.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      transition_out(source.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t6);
        detach(t7);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(textinput);
      destroy_component(source);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class SubclassSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$X, create_fragment$X, safe_not_equal, {});
  }
}
function create_else_block$e(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.rarity",
      value: (
        /*$context*/
        ctx[1].system.rarity
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      blankValue: "",
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      2) select_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select_changes.value = /*$context*/
      ctx2[1].system.rarity;
      if (dirty & /*$context*/
      2) select_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      34) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block$m(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[3]("DND5E.Unidentified.Title")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot$i(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.itemRarity
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.itemRarity;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_fragment$W(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let itemidentifiablename;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let ul;
  let li0;
  let t4_value = (
    /*$context*/
    ctx[1].system.type.label + ""
  );
  let t4;
  let t5;
  let li1;
  let current_block_type_index;
  let if_block;
  let t6;
  let li2;
  let source;
  let t7;
  let itemheadertoggles;
  let t8;
  let tabs;
  let updating_selectedTabId;
  let t9;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  itemidentifiablename = new ItemIdentifiableName({});
  const if_block_creators = [create_if_block$m, create_else_block$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].concealDetails
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable && !/*$context*/
        ctx[1].concealDetails
      )
    }
  });
  itemheadertoggles = new ItemHeaderToggles({});
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(itemidentifiablename.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      t4 = text(t4_value);
      t5 = space();
      li1 = element("li");
      if_block.c();
      t6 = space();
      li2 = element("li");
      create_component(source.$$.fragment);
      t7 = space();
      create_component(itemheadertoggles.$$.fragment);
      t8 = space();
      create_component(tabs.$$.fragment);
      t9 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(div0, "class", "item-subtitle");
      attr(li2, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(itemidentifiablename, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div1, t3);
      append(div1, ul);
      append(ul, li0);
      append(li0, t4);
      append(ul, t5);
      append(ul, li1);
      if_blocks[current_block_type_index].m(li1, null);
      append(ul, t6);
      append(ul, li2);
      mount_component(source, li2, null);
      append(div1, t7);
      mount_component(itemheadertoggles, div1, null);
      insert(target, t8, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t9, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      ctx2[1].system.type.label + "")) set_data(t4, t4_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li1, null);
      }
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable && !/*$context*/
      ctx2[1].concealDetails;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(itemidentifiablename.$$.fragment, local);
      transition_in(if_block);
      transition_in(source.$$.fragment, local);
      transition_in(itemheadertoggles.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(itemidentifiablename.$$.fragment, local);
      transition_out(if_block);
      transition_out(source.$$.fragment, local);
      transition_out(itemheadertoggles.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t8);
        detach(t9);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(itemidentifiablename);
      if_blocks[current_block_type_index].d();
      destroy_component(source);
      destroy_component(itemheadertoggles);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class ToolSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$W, create_fragment$W, safe_not_equal, {});
  }
}
function create_else_block$d(ctx) {
  let select;
  let current;
  select = new Select({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      field: "system.rarity",
      value: (
        /*$context*/
        ctx[1].system.rarity
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      blankValue: "",
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$context*/
      2) select_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) select_changes.value = /*$context*/
      ctx2[1].system.rarity;
      if (dirty & /*$context*/
      2) select_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope, $context*/
      34) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block$l(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[3]("DND5E.Unidentified.Title")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot$h(ctx) {
  let selectoptions;
  let current;
  selectoptions = new SelectOptions({
    props: {
      data: (
        /*$context*/
        ctx[1].config.itemRarity
      ),
      blank: ""
    }
  });
  return {
    c() {
      create_component(selectoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectoptions_changes = {};
      if (dirty & /*$context*/
      2) selectoptions_changes.data = /*$context*/
      ctx2[1].config.itemRarity;
      selectoptions.$set(selectoptions_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectoptions, detaching);
    }
  };
}
function create_fragment$V(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let itemidentifiablename;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let ul;
  let li0;
  let t4_value = (
    /*$context*/
    ctx[1].system.type.label + ""
  );
  let t4;
  let t5;
  let li1;
  let current_block_type_index;
  let if_block;
  let t6;
  let li2;
  let source;
  let t7;
  let itemheadertoggles;
  let t8;
  let tabs;
  let updating_selectedTabId;
  let t9;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  itemidentifiablename = new ItemIdentifiableName({});
  const if_block_creators = [create_if_block$l, create_else_block$d];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].concealDetails
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable && !/*$context*/
        ctx[1].concealDetails
      )
    }
  });
  itemheadertoggles = new ItemHeaderToggles({});
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(itemidentifiablename.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      t4 = text(t4_value);
      t5 = space();
      li1 = element("li");
      if_block.c();
      t6 = space();
      li2 = element("li");
      create_component(source.$$.fragment);
      t7 = space();
      create_component(itemheadertoggles.$$.fragment);
      t8 = space();
      create_component(tabs.$$.fragment);
      t9 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(div0, "class", "item-subtitle");
      attr(li2, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(itemidentifiablename, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div1, t3);
      append(div1, ul);
      append(ul, li0);
      append(li0, t4);
      append(ul, t5);
      append(ul, li1);
      if_blocks[current_block_type_index].m(li1, null);
      append(ul, t6);
      append(ul, li2);
      mount_component(source, li2, null);
      append(div1, t7);
      mount_component(itemheadertoggles, div1, null);
      insert(target, t8, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t9, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      ctx2[1].system.type.label + "")) set_data(t4, t4_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li1, null);
      }
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable && !/*$context*/
      ctx2[1].concealDetails;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(itemidentifiablename.$$.fragment, local);
      transition_in(if_block);
      transition_in(source.$$.fragment, local);
      transition_in(itemheadertoggles.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(itemidentifiablename.$$.fragment, local);
      transition_out(if_block);
      transition_out(source.$$.fragment, local);
      transition_out(itemheadertoggles.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t8);
        detach(t9);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(itemidentifiablename);
      if_blocks[current_block_type_index].d();
      destroy_component(source);
      destroy_component(itemheadertoggles);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$V($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class WeaponSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$V, create_fragment$V, safe_not_equal, {});
  }
}
function create_fragment$U(ctx) {
  let header;
  let itemprofilepicture;
  let t0;
  let div1;
  let h1;
  let textinput;
  let t1;
  let div0;
  let h4;
  let t2_value = (
    /*$context*/
    (ctx[1].itemType ?? "") + ""
  );
  let t2;
  let t3;
  let span;
  let t4_value = (
    /*$context*/
    (ctx[1].itemStatus ?? "") + ""
  );
  let t4;
  let t5;
  let ul;
  let li;
  let source;
  let t6;
  let tabs;
  let updating_selectedTabId;
  let t7;
  let section;
  let tabcontents;
  let current;
  itemprofilepicture = new ItemProfilePicture({});
  textinput = new TextInput$1({
    props: {
      field: "name",
      document: (
        /*$context*/
        ctx[1].item
      ),
      value: (
        /*$context*/
        ctx[1].item.name
      ),
      attributes: {
        "data-tidy-item-name": (
          /*$context*/
          ctx[1].item.name
        )
      },
      placeholder: (
        /*localize*/
        ctx[3]("DND5E.ClassName")
      ),
      disabled: !/*$context*/
      ctx[1].editable,
      title: (
        /*$context*/
        ctx[1].item.name
      )
    }
  });
  source = new Source({
    props: {
      document: (
        /*$context*/
        ctx[1].item
      ),
      keyPath: "system.source",
      editable: (
        /*$context*/
        ctx[1].editable
      )
    }
  });
  function tabs_selectedTabId_binding(value) {
    ctx[4](value);
  }
  let tabs_props = { tabs: (
    /*$context*/
    ctx[1].tabs
  ) };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[1].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      header = element("header");
      create_component(itemprofilepicture.$$.fragment);
      t0 = space();
      div1 = element("div");
      h1 = element("h1");
      create_component(textinput.$$.fragment);
      t1 = space();
      div0 = element("div");
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      ul = element("ul");
      li = element("li");
      create_component(source.$$.fragment);
      t6 = space();
      create_component(tabs.$$.fragment);
      t7 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(h1, "class", "charname");
      attr(h1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h4, "class", "item-type");
      attr(span, "class", "item-status");
      attr(div0, "class", "item-subtitle");
      attr(li, "class", "flex-row");
      attr(ul, "class", "summary flexrow");
      attr(div1, "class", "header-details flexrow small-gap");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(header, "class", "sheet-header flexrow gap");
      attr(section, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      mount_component(itemprofilepicture, header, null);
      append(header, t0);
      append(header, div1);
      append(div1, h1);
      mount_component(textinput, h1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, h4);
      append(h4, t2);
      append(div0, t3);
      append(div0, span);
      append(span, t4);
      append(div1, t5);
      append(div1, ul);
      append(ul, li);
      mount_component(source, li, null);
      insert(target, t6, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t7, anchor);
      insert(target, section, anchor);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].item.name;
      if (dirty & /*$context*/
      2) textinput_changes.attributes = {
        "data-tidy-item-name": (
          /*$context*/
          ctx2[1].item.name
        )
      };
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$context*/
      2) textinput_changes.title = /*$context*/
      ctx2[1].item.name;
      textinput.$set(textinput_changes);
      if ((!current || dirty & /*$context*/
      2) && t2_value !== (t2_value = /*$context*/
      (ctx2[1].itemType ?? "") + "")) set_data(t2, t2_value);
      if ((!current || dirty & /*$context*/
      2) && t4_value !== (t4_value = /*$context*/
      (ctx2[1].itemStatus ?? "") + "")) set_data(t4, t4_value);
      const source_changes = {};
      if (dirty & /*$context*/
      2) source_changes.document = /*$context*/
      ctx2[1].item;
      if (dirty & /*$context*/
      2) source_changes.editable = /*$context*/
      ctx2[1].editable;
      source.$set(source_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      2) tabs_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      2) tabcontents_changes.tabs = /*$context*/
      ctx2[1].tabs;
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(itemprofilepicture.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      transition_in(source.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemprofilepicture.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      transition_out(source.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
        detach(t6);
        detach(t7);
        detach(section);
      }
      destroy_component(itemprofilepicture);
      destroy_component(textinput);
      destroy_component(source);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let selectedTabId;
  const localize = FoundryAdapter.localize;
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  return [selectedTabId, $context, context, localize, tabs_selectedTabId_binding];
}
class RaceSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$U, create_fragment$U, safe_not_equal, {});
  }
}
class ItemSheetRuntime {
  static _content = [];
  static _customTabs = [];
  static _customItemEquipmentTypeGroups = [];
  static async getContent(context) {
    return await CustomContentManager.prepareContentForRender(
      context,
      ItemSheetRuntime._content
    );
  }
  static registerContent(registeredContent) {
    this._content.push(registeredContent);
  }
  static registerTab(tab) {
    ItemSheetRuntime._customTabs.push(tab);
  }
  static getCustomItemTabs(context) {
    return ItemSheetRuntime._customTabs.filter(
      (s2) => s2.enabled === void 0 || s2.enabled(context)
    );
  }
  static sheets = {
    [CONSTANTS.ITEM_TYPE_EQUIPMENT]: {
      Sheet: EquipmentSheet,
      defaultTabs: () => [
        itemSheetTabs.descriptionWithSidebar,
        itemSheetTabs.equipmentDetails,
        itemSheetTabs.effects
      ]
    },
    [CONSTANTS.ITEM_TYPE_BACKGROUND]: {
      Sheet: BackgroundSheet,
      defaultTabs: () => [
        itemSheetTabs.description,
        itemSheetTabs.backgroundDetails,
        itemSheetTabs.advancement
      ]
    },
    [CONSTANTS.ITEM_TYPE_CLASS]: {
      Sheet: ClassSheet,
      defaultTabs: () => [
        itemSheetTabs.description,
        itemSheetTabs.classDetails,
        itemSheetTabs.advancement
      ]
    },
    [CONSTANTS.ITEM_TYPE_CONSUMABLE]: {
      Sheet: ConsumableSheet,
      defaultTabs: () => [
        itemSheetTabs.descriptionWithSidebar,
        itemSheetTabs.consumableDetails,
        itemSheetTabs.effects
      ]
    },
    [CONSTANTS.ITEM_TYPE_CONTAINER]: {
      Sheet: ContainerSheet,
      defaultTabs: () => [
        itemSheetTabs.containerContents,
        itemSheetTabs.descriptionWithSidebar,
        itemSheetTabs.containerDetails
      ]
    },
    [CONSTANTS.ITEM_TYPE_FEAT]: {
      Sheet: FeatSheet,
      defaultTabs: () => [
        itemSheetTabs.descriptionWithSidebar,
        itemSheetTabs.featDetails,
        itemSheetTabs.effects
      ]
    },
    [CONSTANTS.ITEM_TYPE_LOOT]: {
      Sheet: LootSheet,
      defaultTabs: () => [
        itemSheetTabs.descriptionWithSidebar,
        itemSheetTabs.lootDetails
      ]
    },
    [CONSTANTS.ITEM_TYPE_SPELL]: {
      Sheet: SpellSheet,
      defaultTabs: () => [
        itemSheetTabs.descriptionWithSidebar,
        itemSheetTabs.spellDetails,
        itemSheetTabs.effects
      ]
    },
    [CONSTANTS.ITEM_TYPE_SUBCLASS]: {
      Sheet: SubclassSheet,
      defaultTabs: () => [
        itemSheetTabs.description,
        itemSheetTabs.subclassDetails,
        itemSheetTabs.advancement
      ]
    },
    [CONSTANTS.ITEM_TYPE_TOOL]: {
      Sheet: ToolSheet,
      defaultTabs: () => [
        itemSheetTabs.descriptionWithSidebar,
        itemSheetTabs.toolDetails,
        itemSheetTabs.effects
      ]
    },
    [CONSTANTS.ITEM_TYPE_WEAPON]: {
      Sheet: WeaponSheet,
      defaultTabs: () => [
        itemSheetTabs.descriptionWithSidebar,
        itemSheetTabs.weaponDetails,
        itemSheetTabs.effects
      ]
    },
    [CONSTANTS.ITEM_TYPE_RACE]: {
      Sheet: RaceSheet,
      defaultTabs: () => [
        itemSheetTabs.raceDescription,
        itemSheetTabs.raceDetails,
        itemSheetTabs.advancement
      ]
    }
  };
  static registerCustomEquipmentTypeGroup(group) {
    this._customItemEquipmentTypeGroups.push(group);
  }
  static getCustomEquipmentTypeGroups() {
    return [...this._customItemEquipmentTypeGroups];
  }
  static getTabTitle(tabId) {
    try {
      let tabs = [...this._customTabs, ...Object.values(itemSheetTabs)];
      let tabTitle = tabs.find((t2) => t2.id === tabId)?.title;
      if (typeof tabTitle === "function") {
        tabTitle = tabTitle();
      }
      return tabTitle ? FoundryAdapter.localize(tabTitle) : tabId;
    } catch (e2) {
      error("An error occurred while searching for a tab title.", false, e2);
      debug("Tab title error troubleshooting information", { tabId });
    }
  }
}
class ItemConfigApi {
  /**
   * Registers a custom group of equipment types, to be rendered on the item sheet as their own section of options within the Equipment Type input.
   *
   * @param group the group to add
   *
   * @example Registering custom helmets
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.config.item.registerCustomEquipmentTypeGroup({
   *     label: 'Helmet',
   *     types: {
   *       clothhat: 'Clothings Helmet',
   *       lighthat: 'Light Helmet',
   *       mediumhat: 'Medium Helmet',
   *       heavyhat: 'Heavy Helmet',
   *     },
   *   });
   * });
   * ```
   */
  registerCustomEquipmentTypeGroup(group) {
    ItemSheetRuntime.registerCustomEquipmentTypeGroup(group);
  }
}
class ConfigApi {
  /** {@inheritDoc ActionListApi} */
  actionList = new ActionListApi();
  /** {@inheritDoc ActorItemApi} */
  actorItem = new ActorItemApi();
  /** {@inheritDoc ActorPortraitApi} */
  actorPortrait = new ActorPortraitApi();
  /** {@inheritDoc ActorTraitsApi} */
  actorTraits = new ActorTraitsApi();
  /** {@inheritDoc ExhaustionApi} */
  exhaustion = new ExhaustionApi();
  /** {@inheritDoc ItemConfigApi} */
  item = new ItemConfigApi();
  /** {@inheritDoc ItemSummaryApi} */
  itemSummary = new ItemSummaryApi();
  /**{@inheritDoc SpellSchoolApi} */
  spellSchool = new SpellSchoolApi();
}
class HtmlContent extends CustomContentBase {
  injectParams;
  /**
   * The HTML to be injected into the sheet.
   */
  html = "";
  renderScheme = "handlebars";
  activateDefaultSheetListeners = false;
  constructor(props) {
    super();
    const merged = foundry.utils.mergeObject(this, props);
    Object.assign(this, merged);
  }
  onContentReady;
  enabled;
  onRender;
}
function get_each_context$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  child_ctx[19] = i2;
  return child_ctx;
}
function create_each_block$6(ctx) {
  let li;
  let button;
  let t0;
  let button_title_value;
  let button_disabled_value;
  let button_tabindex_value;
  let button_data_tooltip_value;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[16](
        /*i*/
        ctx[19]
      )
    );
  }
  return {
    c() {
      li = element("li");
      button = element("button");
      t0 = text(
        /*i*/
        ctx[19]
      );
      t1 = space();
      attr(button, "type", "button");
      attr(button, "class", "exhaustion-level-option transparent-button svelte-mzljtd");
      attr(button, "title", button_title_value = /*localize*/
      ctx[13](
        /*exhaustionConfig*/
        ctx[4].hints[
          /*i*/
          ctx[19]
        ] ?? ""
      ));
      button.disabled = button_disabled_value = !/*$context*/
      ctx[11].editable || /*isActiveEffectApplied*/
      ctx[5];
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[12].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-tooltip", button_data_tooltip_value = /*isActiveEffectApplied*/
      ctx[5] ? (
        /*localize*/
        ctx[13]("DND5E.ActiveEffectOverrideWarning")
      ) : null);
      toggle_class(
        button,
        "colorized",
        /*i*/
        ctx[19] <= /*level*/
        ctx[2]
      );
      attr(li, "class", "svelte-mzljtd");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, button);
      append(button, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*exhaustionConfig*/
      16 && button_title_value !== (button_title_value = /*localize*/
      ctx[13](
        /*exhaustionConfig*/
        ctx[4].hints[
          /*i*/
          ctx[19]
        ] ?? ""
      ))) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$context, isActiveEffectApplied*/
      2080 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx[11].editable || /*isActiveEffectApplied*/
      ctx[5])) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$settingStore*/
      4096 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx[12].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*isActiveEffectApplied*/
      32 && button_data_tooltip_value !== (button_data_tooltip_value = /*isActiveEffectApplied*/
      ctx[5] ? (
        /*localize*/
        ctx[13]("DND5E.ActiveEffectOverrideWarning")
      ) : null)) {
        attr(button, "data-tooltip", button_data_tooltip_value);
      }
      if (dirty & /*level*/
      4) {
        toggle_class(
          button,
          "colorized",
          /*i*/
          ctx[19] <= /*level*/
          ctx[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$T(ctx) {
  let div3;
  let div1;
  let div0;
  let i2;
  let i_class_value;
  let div0_title_value;
  let t0;
  let ul;
  let div1_class_value;
  let t1;
  let div2;
  let t2;
  let div3_class_value;
  let each_value = ensure_array_like(
    /*iconsWithSeverities*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$6(get_each_context$6(ctx, each_value, i3));
  }
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      i2 = element("i");
      t0 = space();
      ul = element("ul");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t1 = space();
      div2 = element("div");
      t2 = text(
        /*level*/
        ctx[2]
      );
      attr(i2, "class", i_class_value = null_to_empty(
        /*selectedLevel*/
        ctx[7].iconCssClass ?? ""
      ) + " svelte-mzljtd");
      attr(div0, "class", "exhaustion-icon colorized svelte-mzljtd");
      attr(div0, "title", div0_title_value = `${/*localize*/
      ctx[13]("DND5E.Exhaustion")} ${/*localize*/
      ctx[13]("DND5E.AbbreviationLevel")} ${/*level*/
      ctx[2]}, ${/*localize*/
      ctx[13](
        /*selectedHintKey*/
        ctx[8]
      )}`);
      attr(ul, "class", "exhaustion-levels svelte-mzljtd");
      attr(div1, "class", div1_class_value = "exhaustion-wrap " + /*radiusClass*/
      ctx[1] + " svelte-mzljtd");
      attr(div2, "class", "level-display svelte-mzljtd");
      toggle_class(
        div2,
        "colorized",
        /*level*/
        ctx[2] > 0
      );
      attr(div3, "class", div3_class_value = "exhaustion-container " + /*severityClass*/
      ctx[9] + " " + /*cssClass*/
      ctx[0] + " svelte-mzljtd");
      set_style(
        div3,
        "--t5e-exhaustion-expanded-width",
        /*exhaustionExpandedWidth*/
        ctx[10]
      );
      toggle_class(
        div3,
        "only-show-on-hover",
        /*onlyShowOnHover*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div0, i2);
      append(div1, t0);
      append(div1, ul);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(ul, null);
        }
      }
      append(div3, t1);
      append(div3, div2);
      append(div2, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*selectedLevel*/
      128 && i_class_value !== (i_class_value = null_to_empty(
        /*selectedLevel*/
        ctx2[7].iconCssClass ?? ""
      ) + " svelte-mzljtd")) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & /*level, selectedHintKey*/
      260 && div0_title_value !== (div0_title_value = `${/*localize*/
      ctx2[13]("DND5E.Exhaustion")} ${/*localize*/
      ctx2[13]("DND5E.AbbreviationLevel")} ${/*level*/
      ctx2[2]}, ${/*localize*/
      ctx2[13](
        /*selectedHintKey*/
        ctx2[8]
      )}`)) {
        attr(div0, "title", div0_title_value);
      }
      if (dirty & /*localize, exhaustionConfig, $context, isActiveEffectApplied, $settingStore, level, dispatch, iconsWithSeverities*/
      47220) {
        each_value = ensure_array_like(
          /*iconsWithSeverities*/
          ctx2[6]
        );
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block$6(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(ul, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*radiusClass*/
      2 && div1_class_value !== (div1_class_value = "exhaustion-wrap " + /*radiusClass*/
      ctx2[1] + " svelte-mzljtd")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*level*/
      4) set_data(
        t2,
        /*level*/
        ctx2[2]
      );
      if (dirty & /*level*/
      4) {
        toggle_class(
          div2,
          "colorized",
          /*level*/
          ctx2[2] > 0
        );
      }
      if (dirty & /*severityClass, cssClass*/
      513 && div3_class_value !== (div3_class_value = "exhaustion-container " + /*severityClass*/
      ctx2[9] + " " + /*cssClass*/
      ctx2[0] + " svelte-mzljtd")) {
        attr(div3, "class", div3_class_value);
      }
      if (dirty & /*exhaustionExpandedWidth*/
      1024) {
        set_style(
          div3,
          "--t5e-exhaustion-expanded-width",
          /*exhaustionExpandedWidth*/
          ctx2[10]
        );
      }
      if (dirty & /*severityClass, cssClass, onlyShowOnHover*/
      521) {
        toggle_class(
          div3,
          "only-show-on-hover",
          /*onlyShowOnHover*/
          ctx2[3]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
let exhaustionOptionWidthRems = 1.25;
function instance$T($$self, $$props, $$invalidate) {
  let exhaustionExpandedWidth;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(12, $settingStore = $$value));
  let { cssClass = "" } = $$props;
  let { radiusClass } = $$props;
  let { level } = $$props;
  let { onlyShowOnHover = false } = $$props;
  let { exhaustionConfig } = $$props;
  let { isActiveEffectApplied } = $$props;
  let iconsWithSeverities;
  let selectedLevel;
  let selectedHintKey;
  let severityClass;
  const localize = FoundryAdapter.localize;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(11, $context = value));
  const dispatch2 = createEventDispatcher();
  const click_handler = (i2) => dispatch2("levelSelected", { level: i2 });
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
    if ("radiusClass" in $$props2) $$invalidate(1, radiusClass = $$props2.radiusClass);
    if ("level" in $$props2) $$invalidate(2, level = $$props2.level);
    if ("onlyShowOnHover" in $$props2) $$invalidate(3, onlyShowOnHover = $$props2.onlyShowOnHover);
    if ("exhaustionConfig" in $$props2) $$invalidate(4, exhaustionConfig = $$props2.exhaustionConfig);
    if ("isActiveEffectApplied" in $$props2) $$invalidate(5, isActiveEffectApplied = $$props2.isActiveEffectApplied);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*exhaustionConfig*/
    16) {
      {
        $$invalidate(6, iconsWithSeverities = getExhaustionIconsWithSeverity(exhaustionConfig.levels));
      }
    }
    if ($$self.$$.dirty & /*iconsWithSeverities, level, exhaustionConfig*/
    84) {
      {
        $$invalidate(7, selectedLevel = iconsWithSeverities[level] ?? iconsWithSeverities.at(-1));
        $$invalidate(8, selectedHintKey = exhaustionConfig.hints[level] ?? "");
      }
    }
    if ($$self.$$.dirty & /*selectedLevel*/
    128) {
      {
        $$invalidate(9, severityClass = `severity-${selectedLevel?.severity ?? 0}`);
      }
    }
    if ($$self.$$.dirty & /*exhaustionConfig*/
    16) {
      $$invalidate(10, exhaustionExpandedWidth = `${exhaustionOptionWidthRems * (exhaustionConfig.levels + 1) + 2.125}rem`);
    }
  };
  return [
    cssClass,
    radiusClass,
    level,
    onlyShowOnHover,
    exhaustionConfig,
    isActiveEffectApplied,
    iconsWithSeverities,
    selectedLevel,
    selectedHintKey,
    severityClass,
    exhaustionExpandedWidth,
    $context,
    $settingStore,
    localize,
    context,
    dispatch2,
    click_handler
  ];
}
class ExhaustionTracker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$T, create_fragment$T, safe_not_equal, {
      cssClass: 0,
      radiusClass: 1,
      level: 2,
      onlyShowOnHover: 3,
      exhaustionConfig: 4,
      isActiveEffectApplied: 5
    });
  }
}
function create_default_slot$g(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "inspiration-icon fas fa-dice-d20");
      toggle_class(
        i2,
        "animate",
        /*animate*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*animate*/
      16) {
        toggle_class(
          i2,
          "animate",
          /*animate*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_fragment$S(ctx) {
  let div;
  let checkbox;
  let div_class_value;
  let current;
  checkbox = new Checkbox({
    props: {
      checkboxCssClass: "inspiration-toggle",
      labelCssClass: (
        /*inspired*/
        (ctx[0] ? "inspired" : "") + " " + /*radiusClass*/
        ctx[2] + " " + /*$context*/
        (ctx[5].editable ? "pointer" : "")
      ),
      document: (
        /*$context*/
        ctx[5].actor
      ),
      field: "system.attributes.inspiration",
      checked: (
        /*inspired*/
        ctx[0]
      ),
      disabled: !/*$context*/
      ctx[5].editable,
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(checkbox.$$.fragment);
      attr(div, "class", div_class_value = "inspiration inspiration-" + /*inspired*/
      (ctx[0] ? 1 : 0) + " " + /*cssClass*/
      ctx[1] + " svelte-6apbu6");
      attr(
        div,
        "title",
        /*localize*/
        ctx[7]("DND5E.Inspiration")
      );
      toggle_class(
        div,
        "only-show-on-hover",
        /*onlyShowOnHover*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkbox, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkbox_changes = {};
      if (dirty & /*inspired, radiusClass, $context*/
      37) checkbox_changes.labelCssClass = /*inspired*/
      (ctx2[0] ? "inspired" : "") + " " + /*radiusClass*/
      ctx2[2] + " " + /*$context*/
      (ctx2[5].editable ? "pointer" : "");
      if (dirty & /*$context*/
      32) checkbox_changes.document = /*$context*/
      ctx2[5].actor;
      if (dirty & /*inspired*/
      1) checkbox_changes.checked = /*inspired*/
      ctx2[0];
      if (dirty & /*$context*/
      32) checkbox_changes.disabled = !/*$context*/
      ctx2[5].editable;
      if (dirty & /*$$scope, animate*/
      272) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
      if (!current || dirty & /*inspired, cssClass*/
      3 && div_class_value !== (div_class_value = "inspiration inspiration-" + /*inspired*/
      (ctx2[0] ? 1 : 0) + " " + /*cssClass*/
      ctx2[1] + " svelte-6apbu6")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*inspired, cssClass, onlyShowOnHover*/
      11) {
        toggle_class(
          div,
          "only-show-on-hover",
          /*onlyShowOnHover*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(checkbox);
    }
  };
}
function instance$S($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(5, $context = value));
  let { inspired } = $$props;
  let { cssClass = "" } = $$props;
  let { radiusClass } = $$props;
  let { onlyShowOnHover = false } = $$props;
  let { animate = true } = $$props;
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("inspired" in $$props2) $$invalidate(0, inspired = $$props2.inspired);
    if ("cssClass" in $$props2) $$invalidate(1, cssClass = $$props2.cssClass);
    if ("radiusClass" in $$props2) $$invalidate(2, radiusClass = $$props2.radiusClass);
    if ("onlyShowOnHover" in $$props2) $$invalidate(3, onlyShowOnHover = $$props2.onlyShowOnHover);
    if ("animate" in $$props2) $$invalidate(4, animate = $$props2.animate);
  };
  return [
    inspired,
    cssClass,
    radiusClass,
    onlyShowOnHover,
    animate,
    $context,
    context,
    localize
  ];
}
class Inspiration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$S, create_fragment$S, safe_not_equal, {
      inspired: 0,
      cssClass: 1,
      radiusClass: 2,
      onlyShowOnHover: 3,
      animate: 4
    });
  }
}
function create_fragment$R(ctx) {
  let div1;
  let div0;
  let i0;
  let t0;
  let textinput0;
  let t1;
  let button;
  let i1;
  let button_tabindex_value;
  let t2;
  let textinput1;
  let t3;
  let i2;
  let current;
  let mounted;
  let dispose;
  textinput0 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[5].actor
      ),
      field: (
        /*successesField*/
        ctx[2]
      ),
      cssClass: "death-save-result",
      selectOnFocus: true,
      allowDeltaChanges: true,
      placeholder: "0",
      value: (
        /*successes*/
        ctx[0]
      ),
      maxlength: 1,
      title: (
        /*localize*/
        ctx[8]("DND5E.DeathSaveSuccesses")
      ),
      disabled: !/*$context*/
      ctx[5].editable,
      "data-tidy-sheet-part": CONSTANTS.SHEET_PARTS.DEATH_SAVE_SUCCESSES
    }
  });
  textinput1 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[5].actor
      ),
      field: (
        /*failuresField*/
        ctx[3]
      ),
      cssClass: "death-save-result",
      selectOnFocus: true,
      allowDeltaChanges: true,
      placeholder: "0",
      value: (
        /*failures*/
        ctx[1]
      ),
      maxlength: 1,
      disabled: !/*$context*/
      ctx[5].editable,
      "data-tidy-sheet-part": CONSTANTS.SHEET_PARTS.DEATH_SAVE_FAILURES,
      title: (
        /*localize*/
        ctx[8]("DND5E.DeathSaveFailures")
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      i0 = element("i");
      t0 = space();
      create_component(textinput0.$$.fragment);
      t1 = space();
      button = element("button");
      i1 = element("i");
      t2 = space();
      create_component(textinput1.$$.fragment);
      t3 = space();
      i2 = element("i");
      attr(i0, "class", "fas fa-check");
      attr(i1, "class", "fas fa-skull");
      attr(button, "type", "button");
      attr(button, "class", "death-save rollable");
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.DEATH_SAVE_ROLLER);
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[6].useAccessibleKeyboardSupport ? 0 : -1);
      attr(i2, "class", "fas fa-times");
      attr(div0, "class", "death-save-counters svelte-19mjonj");
      toggle_class(div0, "show-backdrop", !/*hasHpOverlay*/
      ctx[4]);
      attr(div1, "class", "death-saves svelte-19mjonj");
      toggle_class(
        div1,
        "rounded",
        /*$context*/
        ctx[5].useRoundedPortraitStyle
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, i0);
      append(div0, t0);
      mount_component(textinput0, div0, null);
      append(div0, t1);
      append(div0, button);
      append(button, i1);
      append(div0, t2);
      mount_component(textinput1, div0, null);
      append(div0, t3);
      append(div0, i2);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const textinput0_changes = {};
      if (dirty & /*$context*/
      32) textinput0_changes.document = /*$context*/
      ctx2[5].actor;
      if (dirty & /*successesField*/
      4) textinput0_changes.field = /*successesField*/
      ctx2[2];
      if (dirty & /*successes*/
      1) textinput0_changes.value = /*successes*/
      ctx2[0];
      if (dirty & /*$context*/
      32) textinput0_changes.disabled = !/*$context*/
      ctx2[5].editable;
      textinput0.$set(textinput0_changes);
      if (!current || dirty & /*$settingStore*/
      64 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[6].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      const textinput1_changes = {};
      if (dirty & /*$context*/
      32) textinput1_changes.document = /*$context*/
      ctx2[5].actor;
      if (dirty & /*failuresField*/
      8) textinput1_changes.field = /*failuresField*/
      ctx2[3];
      if (dirty & /*failures*/
      2) textinput1_changes.value = /*failures*/
      ctx2[1];
      if (dirty & /*$context*/
      32) textinput1_changes.disabled = !/*$context*/
      ctx2[5].editable;
      textinput1.$set(textinput1_changes);
      if (!current || dirty & /*hasHpOverlay*/
      16) {
        toggle_class(div0, "show-backdrop", !/*hasHpOverlay*/
        ctx2[4]);
      }
      if (!current || dirty & /*$context*/
      32) {
        toggle_class(
          div1,
          "rounded",
          /*$context*/
          ctx2[5].useRoundedPortraitStyle
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(textinput0.$$.fragment, local);
      transition_in(textinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput0.$$.fragment, local);
      transition_out(textinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(textinput0);
      destroy_component(textinput1);
      mounted = false;
      dispose();
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(6, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(5, $context = value));
  let { successes } = $$props;
  let { failures } = $$props;
  let { successesField } = $$props;
  let { failuresField } = $$props;
  let { hasHpOverlay } = $$props;
  const localize = FoundryAdapter.localize;
  const dispatcher = createEventDispatcher();
  const click_handler = (event) => dispatcher("rollDeathSave", { mouseEvent: event });
  $$self.$$set = ($$props2) => {
    if ("successes" in $$props2) $$invalidate(0, successes = $$props2.successes);
    if ("failures" in $$props2) $$invalidate(1, failures = $$props2.failures);
    if ("successesField" in $$props2) $$invalidate(2, successesField = $$props2.successesField);
    if ("failuresField" in $$props2) $$invalidate(3, failuresField = $$props2.failuresField);
    if ("hasHpOverlay" in $$props2) $$invalidate(4, hasHpOverlay = $$props2.hasHpOverlay);
  };
  return [
    successes,
    failures,
    successesField,
    failuresField,
    hasHpOverlay,
    $context,
    $settingStore,
    context,
    localize,
    dispatcher,
    click_handler
  ];
}
class DeathSaves extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$R, create_fragment$R, safe_not_equal, {
      successes: 0,
      failures: 1,
      successesField: 2,
      failuresField: 3,
      hasHpOverlay: 4
    });
  }
}
function create_fragment$Q(ctx) {
  let div1;
  let div0;
  let span;
  let i0;
  let t0;
  let button0;
  let i1;
  let button0_disabled_value;
  let button0_tabindex_value;
  let t1;
  let button1;
  let i2;
  let button1_disabled_value;
  let button1_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      i0 = element("i");
      t0 = space();
      button0 = element("button");
      i1 = element("i");
      t1 = space();
      button1 = element("button");
      i2 = element("i");
      attr(i0, "class", "rest-icon fas fa-bed");
      attr(span, "class", "resting-icon svelte-16suh4w");
      attr(
        span,
        "title",
        /*localize*/
        ctx[3]("TIDY5E.RestHint")
      );
      attr(i1, "class", "fas fa-hourglass-half");
      attr(button0, "type", "button");
      attr(button0, "class", "rest icon-button svelte-16suh4w");
      attr(
        button0,
        "title",
        /*localize*/
        ctx[3]("TIDY5E.ShortRest")
      );
      button0.disabled = button0_disabled_value = !/*$context*/
      ctx[0].editable;
      attr(button0, "tabindex", button0_tabindex_value = !/*$settingStore*/
      ctx[1].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
      attr(i2, "class", "fas fa-hourglass-end");
      attr(button1, "type", "button");
      attr(button1, "class", "rest icon-button svelte-16suh4w");
      attr(
        button1,
        "title",
        /*localize*/
        ctx[3]("TIDY5E.LongRest")
      );
      button1.disabled = button1_disabled_value = !/*$context*/
      ctx[0].editable;
      attr(button1, "tabindex", button1_tabindex_value = !/*$settingStore*/
      ctx[1].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div0, "class", "resting svelte-16suh4w");
      attr(div1, "class", "rest-container svelte-16suh4w");
      toggle_class(
        div1,
        "rounded",
        /*$context*/
        ctx[0].useRoundedPortraitStyle
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span);
      append(span, i0);
      append(div0, t0);
      append(div0, button0);
      append(button0, i1);
      append(div0, t1);
      append(div0, button1);
      append(button1, i2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*$context*/
      ctx2[0].editable)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$settingStore*/
      2 && button0_tabindex_value !== (button0_tabindex_value = !/*$settingStore*/
      ctx2[1].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button0, "tabindex", button0_tabindex_value);
      }
      if (dirty & /*$context*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*$context*/
      ctx2[0].editable)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$settingStore*/
      2 && button1_tabindex_value !== (button1_tabindex_value = !/*$settingStore*/
      ctx2[1].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button1, "tabindex", button1_tabindex_value);
      }
      if (dirty & /*$context*/
      1) {
        toggle_class(
          div1,
          "rounded",
          /*$context*/
          ctx2[0].useRoundedPortraitStyle
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = (event) => $context.actor.sheet.onShortRest(event);
  const click_handler_1 = (event) => $context.actor.sheet.onLongRest(event);
  return [$context, $settingStore, context, localize, click_handler, click_handler_1];
}
class Rest extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});
  }
}
function create_fragment$P(ctx) {
  let div;
  let button;
  let t2;
  let button_disabled_value;
  let button_tabindex_value;
  let div_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t2 = text(
        /*hitDice*/
        ctx[2]
      );
      attr(button, "type", "button");
      attr(button, "class", "current-hd config-button transparent-button svelte-qi1nr4");
      button.disabled = button_disabled_value = !/*$context*/
      ctx[0].editable;
      attr(button, "tabindex", button_tabindex_value = !/*$settingStore*/
      ctx[3].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx[3].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div, "class", "portrait-hd svelte-qi1nr4");
      attr(div, "title", div_title_value = /*localize*/
      ctx[5]("DND5E.HitDice") + ": " + /*hitDice*/
      ctx[2] + "/" + /*actorLevel*/
      ctx[1] + " " + /*localize*/
      ctx[5]("DND5E.HitDiceConfig"));
      toggle_class(
        div,
        "rounded",
        /*$context*/
        ctx[0].useRoundedPortraitStyle
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*$context*/
            ctx[0].editable && FoundryAdapter.renderActorHitDiceConfig(
              /*$context*/
              ctx[0].actor
            )
          )) /*$context*/
          (ctx[0].editable && FoundryAdapter.renderActorHitDiceConfig(
            /*$context*/
            ctx[0].actor
          )).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*hitDice*/
      4) set_data(
        t2,
        /*hitDice*/
        ctx[2]
      );
      if (dirty & /*$context*/
      1 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx[0].editable)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$settingStore*/
      8 && button_tabindex_value !== (button_tabindex_value = !/*$settingStore*/
      ctx[3].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx[3].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*hitDice, actorLevel*/
      6 && div_title_value !== (div_title_value = /*localize*/
      ctx[5]("DND5E.HitDice") + ": " + /*hitDice*/
      ctx[2] + "/" + /*actorLevel*/
      ctx[1] + " " + /*localize*/
      ctx[5]("DND5E.HitDiceConfig"))) {
        attr(div, "title", div_title_value);
      }
      if (dirty & /*$context*/
      1) {
        toggle_class(
          div,
          "rounded",
          /*$context*/
          ctx[0].useRoundedPortraitStyle
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  let hitDice;
  let actorLevel;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(3, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, hitDice = $context.system.attributes.hd);
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, actorLevel = $context.system.details.level);
    }
  };
  return [$context, actorLevel, hitDice, $settingStore, context, localize];
}
class HitDice extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$P, create_fragment$P, safe_not_equal, {});
  }
}
function create_fragment$O(ctx) {
  let div;
  let resourcewithbar;
  let current;
  resourcewithbar = new ResourceWithBar({
    props: {
      document: (
        /*actor*/
        ctx[2]
      ),
      value: (
        /*value*/
        ctx[0]
      ),
      valueField: "system.attributes.hp.value",
      valueTitle: (
        /*localize*/
        ctx[7]("DND5E.HitPointsCurrent")
      ),
      valueDisabled: !/*$context*/
      ctx[4].editable,
      max: (
        /*max*/
        ctx[1]
      ),
      maxField: "system.attributes.hp.max",
      maxTitle: (
        /*localize*/
        ctx[7]("DND5E.HitPointsMax")
      ),
      maxDisabled: !/*$context*/
      ctx[4].allowMaxHpOverride || !/*$context*/
      ctx[4].editable || /*$context*/
      ctx[4].lockHpMaxChanges || /*$context*/
      ctx[4].lockSensitiveFields,
      percentage: (
        /*$context*/
        ctx[4].healthPercentage
      ),
      Bar: (
        /*$settingStore*/
        ctx[5].useHpBar ? HpBar : null
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(resourcewithbar.$$.fragment);
      attr(div, "class", "portrait-hp svelte-1etkvgb");
      attr(
        div,
        "title",
        /*localize*/
        ctx[7]("DND5E.HitPoints")
      );
      toggle_class(
        div,
        "incapacitated",
        /*incapacitated*/
        ctx[3]
      );
      toggle_class(
        div,
        "widen-for-rounded-portrait",
        /*$context*/
        ctx[4].useRoundedPortraitStyle
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(resourcewithbar, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const resourcewithbar_changes = {};
      if (dirty & /*actor*/
      4) resourcewithbar_changes.document = /*actor*/
      ctx2[2];
      if (dirty & /*value*/
      1) resourcewithbar_changes.value = /*value*/
      ctx2[0];
      if (dirty & /*$context*/
      16) resourcewithbar_changes.valueDisabled = !/*$context*/
      ctx2[4].editable;
      if (dirty & /*max*/
      2) resourcewithbar_changes.max = /*max*/
      ctx2[1];
      if (dirty & /*$context*/
      16) resourcewithbar_changes.maxDisabled = !/*$context*/
      ctx2[4].allowMaxHpOverride || !/*$context*/
      ctx2[4].editable || /*$context*/
      ctx2[4].lockHpMaxChanges || /*$context*/
      ctx2[4].lockSensitiveFields;
      if (dirty & /*$context*/
      16) resourcewithbar_changes.percentage = /*$context*/
      ctx2[4].healthPercentage;
      if (dirty & /*$settingStore*/
      32) resourcewithbar_changes.Bar = /*$settingStore*/
      ctx2[5].useHpBar ? HpBar : null;
      resourcewithbar.$set(resourcewithbar_changes);
      if (!current || dirty & /*incapacitated*/
      8) {
        toggle_class(
          div,
          "incapacitated",
          /*incapacitated*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*$context*/
      16) {
        toggle_class(
          div,
          "widen-for-rounded-portrait",
          /*$context*/
          ctx2[4].useRoundedPortraitStyle
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(resourcewithbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resourcewithbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(resourcewithbar);
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { value } = $$props;
  let { max } = $$props;
  let { actor } = $$props;
  let { incapacitated } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value2) => $$invalidate(4, $context = value2));
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("max" in $$props2) $$invalidate(1, max = $$props2.max);
    if ("actor" in $$props2) $$invalidate(2, actor = $$props2.actor);
    if ("incapacitated" in $$props2) $$invalidate(3, incapacitated = $$props2.incapacitated);
  };
  return [value, max, actor, incapacitated, $context, $settingStore, context, localize];
}
class CharacterHitPoints extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$O, create_fragment$O, safe_not_equal, {
      value: 0,
      max: 1,
      actor: 2,
      incapacitated: 3
    });
  }
}
function create_if_block$k(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[3]("DND5E.HitPointsConfig")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*click_handler*/
          ctx[4]
        )));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$N(ctx) {
  let div;
  let textinput0;
  let t0;
  let textinput1;
  let t1;
  let current;
  textinput0 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.attributes.hp.temp",
      cssClass: "temphp",
      placeholder: "+" + /*localize*/
      ctx[3]("DND5E.Temp"),
      value: (
        /*$context*/
        ctx[0].hp.temp || null
      ),
      allowDeltaChanges: true,
      maxlength: 5,
      title: (
        /*localize*/
        ctx[3]("DND5E.HitPointsTemp")
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  textinput1 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.attributes.hp.tempmax",
      cssClass: "max-temphp",
      placeholder: "+" + /*localize*/
      ctx[3]("DND5E.Max"),
      value: (
        /*$context*/
        ctx[0].hp.tempmax || null
      ),
      allowDeltaChanges: true,
      maxlength: 5,
      title: (
        /*localize*/
        ctx[3]("DND5E.HitPointsTempMax")
      ),
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  let if_block = (
    /*$context*/
    ctx[0].editable && /*$context*/
    ctx[0].unlocked && create_if_block$k(ctx)
  );
  return {
    c() {
      div = element("div");
      create_component(textinput0.$$.fragment);
      t0 = space();
      create_component(textinput1.$$.fragment);
      t1 = space();
      if (if_block) if_block.c();
      attr(div, "class", "profile-temp svelte-19rf4j3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput0, div, null);
      append(div, t0);
      mount_component(textinput1, div, null);
      append(div, t1);
      if (if_block) if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput0_changes = {};
      if (dirty & /*$context*/
      1) textinput0_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput0_changes.value = /*$context*/
      ctx2[0].hp.temp || null;
      if (dirty & /*$context*/
      1) textinput0_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput0.$set(textinput0_changes);
      const textinput1_changes = {};
      if (dirty & /*$context*/
      1) textinput1_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput1_changes.value = /*$context*/
      ctx2[0].hp.tempmax || null;
      if (dirty & /*$context*/
      1) textinput1_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput1.$set(textinput1_changes);
      if (
        /*$context*/
        ctx2[0].editable && /*$context*/
        ctx2[0].unlocked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$k(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(textinput0.$$.fragment, local);
      transition_in(textinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput0.$$.fragment, local);
      transition_out(textinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput0);
      destroy_component(textinput1);
      if (if_block) if_block.d();
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = () => FoundryAdapter.renderActorHitPointsDialog($context.actor);
  return [$context, $settingStore, context, localize, click_handler];
}
class TempHp extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$N, create_fragment$N, safe_not_equal, {});
  }
}
function create_fragment$M(ctx) {
  let floatingcontextmenu;
  let t2;
  let div1;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let current;
  let mounted;
  let dispose;
  floatingcontextmenu = new FloatingContextMenu_1({
    props: {
      containingElement: (
        /*portraitContainer*/
        ctx[2]
      ),
      targetSelector: "[data-tidy-sheet-part=" + CONSTANTS.SHEET_PARTS.ACTOR_PORTRAIT_CONTAINER + "]",
      options: (
        /*contextMenuOptions*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(floatingcontextmenu.$$.fragment);
      t2 = space();
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      attr(img, "class", "actor-image svelte-v7y9y2");
      if (!src_url_equal(img.src, img_src_value = /*actor*/
      ctx[0].img)) attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*actor*/
      ctx[0].name);
      attr(
        img,
        "title",
        /*localize*/
        ctx[6]("TIDY5E.EditActorImage") + " / " + /*localize*/
        ctx[6]("TIDY5E.ShowActorImage")
      );
      attr(img, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ACTOR_PORTRAIT_IMAGE);
      attr(div0, "class", "actor-image-wrap svelte-v7y9y2");
      set_style(div0, "--overlay-height", "calc(100% - " + /*$context*/
      ctx[3].healthPercentage + "%)");
      attr(div0, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ACTOR_PORTRAIT_HEALTH_OVERLAY);
      toggle_class(
        div0,
        "overlay",
        /*useHpOverlay*/
        ctx[1]
      );
      attr(div1, "class", "portrait svelte-v7y9y2");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ACTOR_PORTRAIT_CONTAINER);
      toggle_class(
        div1,
        "round-portrait",
        /*$context*/
        ctx[3].useRoundedPortraitStyle
      );
    },
    m(target, anchor) {
      mount_component(floatingcontextmenu, target, anchor);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, img);
      ctx[8](div1);
      current = true;
      if (!mounted) {
        dispose = listen(
          div1,
          "mousedown",
          /*onPortraitClick*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const floatingcontextmenu_changes = {};
      if (dirty & /*portraitContainer*/
      4) floatingcontextmenu_changes.containingElement = /*portraitContainer*/
      ctx2[2];
      if (dirty & /*contextMenuOptions*/
      16) floatingcontextmenu_changes.options = /*contextMenuOptions*/
      ctx2[4];
      floatingcontextmenu.$set(floatingcontextmenu_changes);
      if (!current || dirty & /*actor*/
      1 && !src_url_equal(img.src, img_src_value = /*actor*/
      ctx2[0].img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*actor*/
      1 && img_alt_value !== (img_alt_value = /*actor*/
      ctx2[0].name)) {
        attr(img, "alt", img_alt_value);
      }
      if (!current || dirty & /*$context*/
      8) {
        set_style(div0, "--overlay-height", "calc(100% - " + /*$context*/
        ctx2[3].healthPercentage + "%)");
      }
      if (!current || dirty & /*useHpOverlay*/
      2) {
        toggle_class(
          div0,
          "overlay",
          /*useHpOverlay*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$context*/
      8) {
        toggle_class(
          div1,
          "round-portrait",
          /*$context*/
          ctx2[3].useRoundedPortraitStyle
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(floatingcontextmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingcontextmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(div1);
      }
      destroy_component(floatingcontextmenu, detaching);
      ctx[8](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let $context;
  let { actor } = $$props;
  let { useHpOverlay } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  const localize = FoundryAdapter.localize;
  function openPortraitPicker(event) {
    if (!TidyHooks.tidy5eSheetsPreOpenActorPortraitFilePicker($context, event)) {
      return;
    }
    const rect = event.currentTarget.getBoundingClientRect();
    const current = actor.img;
    const fp = new FilePicker({
      type: "image",
      current,
      callback: (path) => {
        actor.update({ img: path });
      },
      top: rect.top + 40,
      left: rect.left + 10
    });
    return fp.browse();
  }
  function onPortraitClick(event) {
    switch (event.button) {
      case CONSTANTS.MOUSE_BUTTON_MAIN:
        openPortraitPicker(event);
        break;
    }
  }
  let portraitContainer;
  let contextMenuOptions = [];
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      portraitContainer = $$value;
      $$invalidate(2, portraitContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2) $$invalidate(0, actor = $$props2.actor);
    if ("useHpOverlay" in $$props2) $$invalidate(1, useHpOverlay = $$props2.useHpOverlay);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, actor, portraitContainer*/
    13) {
      {
        try {
          $$invalidate(4, contextMenuOptions = $context.actorPortraitCommands.map((c2) => ({
            name: c2.label ?? "",
            icon: !isNil(c2.iconClass, "") ? `<i class="${c2.iconClass}"></i>` : "",
            callback: () => c2.execute?.({ actor, context: $context })
          })));
        } catch (e2) {
          error("An error occurred while getting context menu options", false, e2);
          debug("Context menu option error troubleshooting info", {
            portraitContainer,
            commands: $context.actorPortraitCommands
          });
        }
      }
    }
  };
  return [
    actor,
    useHpOverlay,
    portraitContainer,
    $context,
    contextMenuOptions,
    context,
    localize,
    onPortraitClick,
    div1_binding
  ];
}
class ActorPortrait extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$M, create_fragment$M, safe_not_equal, { actor: 0, useHpOverlay: 1 });
  }
}
function create_fragment$L(ctx) {
  let div1;
  let div0;
  let actorportrait;
  let t2;
  let current;
  actorportrait = new ActorPortrait({
    props: {
      actor: (
        /*$context*/
        ctx[1].actor
      ),
      useHpOverlay: (
        /*useHpOverlay*/
        ctx[0]
      )
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(actorportrait.$$.fragment);
      t2 = space();
      if (default_slot) default_slot.c();
      attr(div0, "class", "profile svelte-cixcnb");
      toggle_class(
        div0,
        "round-portrait",
        /*$context*/
        ctx[1].useRoundedPortraitStyle
      );
      attr(div1, "class", "profile-wrap svelte-cixcnb");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(actorportrait, div0, null);
      append(div0, t2);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const actorportrait_changes = {};
      if (dirty & /*$context*/
      2) actorportrait_changes.actor = /*$context*/
      ctx2[1].actor;
      if (dirty & /*useHpOverlay*/
      1) actorportrait_changes.useHpOverlay = /*useHpOverlay*/
      ctx2[0];
      actorportrait.$set(actorportrait_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$context*/
      2) {
        toggle_class(
          div0,
          "round-portrait",
          /*$context*/
          ctx2[1].useRoundedPortraitStyle
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(actorportrait.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(actorportrait.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(actorportrait);
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { useHpOverlay } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  $$self.$$set = ($$props2) => {
    if ("useHpOverlay" in $$props2) $$invalidate(0, useHpOverlay = $$props2.useHpOverlay);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [useHpOverlay, $context, context, $$scope, slots];
}
class ActorProfile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$L, create_fragment$L, safe_not_equal, { useHpOverlay: 0 });
  }
}
function create_fragment$K(ctx) {
  let div1;
  let div0;
  let input;
  let input_data_tooltip_value;
  let div0_class_value;
  let div1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      attr(input, "type", "number");
      attr(input, "placeholder", "0");
      input.disabled = /*isActiveEffectApplied*/
      ctx[4];
      attr(input, "data-tooltip", input_data_tooltip_value = /*isActiveEffectApplied*/
      ctx[4] ? (
        /*localize*/
        ctx[6]("DND5E.ActiveEffectOverrideWarning")
      ) : null);
      attr(input, "class", "svelte-i4751u");
      attr(div0, "class", div0_class_value = "exhaustion-wrap " + /*radiusClass*/
      ctx[2] + " svelte-i4751u");
      attr(div1, "class", div1_class_value = "exhaustion-container " + /*cssClass*/
      ctx[1] + " svelte-i4751u");
      attr(
        div1,
        "title",
        /*localize*/
        ctx[6]("TIDY5E.WorldSettings.Exhaustion.Header")
      );
      set_style(
        div1,
        "--t5e-exhaustion-input-font-size",
        /*inputFontSize*/
        ctx[5]
      );
      toggle_class(
        div1,
        "only-show-on-hover",
        /*onlyShowOnHover*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input);
      set_input_value(
        input,
        /*level*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[8]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[9]
          ),
          listen(input, "focus", focus_handler)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isActiveEffectApplied*/
      16) {
        input.disabled = /*isActiveEffectApplied*/
        ctx2[4];
      }
      if (dirty & /*isActiveEffectApplied*/
      16 && input_data_tooltip_value !== (input_data_tooltip_value = /*isActiveEffectApplied*/
      ctx2[4] ? (
        /*localize*/
        ctx2[6]("DND5E.ActiveEffectOverrideWarning")
      ) : null)) {
        attr(input, "data-tooltip", input_data_tooltip_value);
      }
      if (dirty & /*level*/
      1 && to_number(input.value) !== /*level*/
      ctx2[0]) {
        set_input_value(
          input,
          /*level*/
          ctx2[0]
        );
      }
      if (dirty & /*radiusClass*/
      4 && div0_class_value !== (div0_class_value = "exhaustion-wrap " + /*radiusClass*/
      ctx2[2] + " svelte-i4751u")) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*cssClass*/
      2 && div1_class_value !== (div1_class_value = "exhaustion-container " + /*cssClass*/
      ctx2[1] + " svelte-i4751u")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*inputFontSize*/
      32) {
        set_style(
          div1,
          "--t5e-exhaustion-input-font-size",
          /*inputFontSize*/
          ctx2[5]
        );
      }
      if (dirty & /*cssClass, onlyShowOnHover*/
      10) {
        toggle_class(
          div1,
          "only-show-on-hover",
          /*onlyShowOnHover*/
          ctx2[3]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const focus_handler = (ev) => ev.currentTarget.select();
function instance$K($$self, $$props, $$invalidate) {
  let { cssClass = "" } = $$props;
  let { radiusClass } = $$props;
  let { level } = $$props;
  let { onlyShowOnHover = false } = $$props;
  let { isActiveEffectApplied = false } = $$props;
  const localize = FoundryAdapter.localize;
  const dispatch2 = createEventDispatcher();
  let fontScales = ["1.25rem", "1.125rem", "1rem"];
  let inputFontSize;
  const change_handler = () => dispatch2("levelSelected", { level });
  function input_input_handler() {
    level = to_number(this.value);
    $$invalidate(0, level);
  }
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(1, cssClass = $$props2.cssClass);
    if ("radiusClass" in $$props2) $$invalidate(2, radiusClass = $$props2.radiusClass);
    if ("level" in $$props2) $$invalidate(0, level = $$props2.level);
    if ("onlyShowOnHover" in $$props2) $$invalidate(3, onlyShowOnHover = $$props2.onlyShowOnHover);
    if ("isActiveEffectApplied" in $$props2) $$invalidate(4, isActiveEffectApplied = $$props2.isActiveEffectApplied);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*level*/
    1) {
      {
        $$invalidate(5, inputFontSize = !level || level < 100 ? fontScales[0] : level < 1e3 ? fontScales[1] : fontScales[2]);
      }
    }
  };
  return [
    level,
    cssClass,
    radiusClass,
    onlyShowOnHover,
    isActiveEffectApplied,
    inputFontSize,
    localize,
    dispatch2,
    change_handler,
    input_input_handler
  ];
}
class ExhaustionInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$K, create_fragment$K, safe_not_equal, {
      cssClass: 1,
      radiusClass: 2,
      level: 0,
      onlyShowOnHover: 3,
      isActiveEffectApplied: 4
    });
  }
}
function create_if_block_3$5(ctx) {
  let deathsaves;
  let current;
  deathsaves = new DeathSaves({
    props: {
      successes: (
        /*$context*/
        ctx[0].system.attributes.death.success
      ),
      failures: (
        /*$context*/
        ctx[0].system.attributes.death.failure
      ),
      successesField: "system.attributes.death.success",
      failuresField: "system.attributes.death.failure",
      hasHpOverlay: (
        /*$settingStore*/
        ctx[2].useHpOverlay
      )
    }
  });
  deathsaves.$on(
    "rollDeathSave",
    /*rollDeathSave_handler*/
    ctx[5]
  );
  return {
    c() {
      create_component(deathsaves.$$.fragment);
    },
    m(target, anchor) {
      mount_component(deathsaves, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const deathsaves_changes = {};
      if (dirty & /*$context*/
      1) deathsaves_changes.successes = /*$context*/
      ctx2[0].system.attributes.death.success;
      if (dirty & /*$context*/
      1) deathsaves_changes.failures = /*$context*/
      ctx2[0].system.attributes.death.failure;
      if (dirty & /*$settingStore*/
      4) deathsaves_changes.hasHpOverlay = /*$settingStore*/
      ctx2[2].useHpOverlay;
      deathsaves.$set(deathsaves_changes);
    },
    i(local) {
      if (current) return;
      transition_in(deathsaves.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(deathsaves.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(deathsaves, detaching);
    }
  };
}
function create_if_block_2$8(ctx) {
  let exhaustioninput;
  let current;
  exhaustioninput = new ExhaustionInput({
    props: {
      level: (
        /*$context*/
        ctx[0].system.attributes.exhaustion
      ),
      radiusClass: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle ? "rounded" : "top-left"
      ),
      onlyShowOnHover: (
        /*$settingStore*/
        ctx[2].showExhaustionOnHover || /*$settingStore*/
        ctx[2].hideIfZero && /*$context*/
        ctx[0].system.attributes.exhaustion === 0
      ),
      isActiveEffectApplied: ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx[0].actor,
        "system.attributes.exhaustion"
      )
    }
  });
  exhaustioninput.$on(
    "levelSelected",
    /*onLevelSelected*/
    ctx[4]
  );
  return {
    c() {
      create_component(exhaustioninput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exhaustioninput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exhaustioninput_changes = {};
      if (dirty & /*$context*/
      1) exhaustioninput_changes.level = /*$context*/
      ctx2[0].system.attributes.exhaustion;
      if (dirty & /*$context*/
      1) exhaustioninput_changes.radiusClass = /*$context*/
      ctx2[0].useRoundedPortraitStyle ? "rounded" : "top-left";
      if (dirty & /*$settingStore, $context*/
      5) exhaustioninput_changes.onlyShowOnHover = /*$settingStore*/
      ctx2[2].showExhaustionOnHover || /*$settingStore*/
      ctx2[2].hideIfZero && /*$context*/
      ctx2[0].system.attributes.exhaustion === 0;
      if (dirty & /*$context*/
      1) exhaustioninput_changes.isActiveEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx2[0].actor,
        "system.attributes.exhaustion"
      );
      exhaustioninput.$set(exhaustioninput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(exhaustioninput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exhaustioninput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exhaustioninput, detaching);
    }
  };
}
function create_if_block_1$a(ctx) {
  let exhaustiontracker;
  let current;
  exhaustiontracker = new ExhaustionTracker({
    props: {
      level: (
        /*$context*/
        ctx[0].system.attributes.exhaustion
      ),
      radiusClass: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle ? "rounded" : "top-left"
      ),
      onlyShowOnHover: (
        /*$settingStore*/
        ctx[2].showExhaustionOnHover || /*$settingStore*/
        ctx[2].hideIfZero && /*$context*/
        ctx[0].system.attributes.exhaustion === 0
      ),
      exhaustionConfig: (
        /*$settingStore*/
        ctx[2].exhaustionConfig
      ),
      isActiveEffectApplied: ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx[0].actor,
        "system.attributes.exhaustion"
      )
    }
  });
  exhaustiontracker.$on(
    "levelSelected",
    /*onLevelSelected*/
    ctx[4]
  );
  return {
    c() {
      create_component(exhaustiontracker.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exhaustiontracker, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exhaustiontracker_changes = {};
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.level = /*$context*/
      ctx2[0].system.attributes.exhaustion;
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.radiusClass = /*$context*/
      ctx2[0].useRoundedPortraitStyle ? "rounded" : "top-left";
      if (dirty & /*$settingStore, $context*/
      5) exhaustiontracker_changes.onlyShowOnHover = /*$settingStore*/
      ctx2[2].showExhaustionOnHover || /*$settingStore*/
      ctx2[2].hideIfZero && /*$context*/
      ctx2[0].system.attributes.exhaustion === 0;
      if (dirty & /*$settingStore*/
      4) exhaustiontracker_changes.exhaustionConfig = /*$settingStore*/
      ctx2[2].exhaustionConfig;
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.isActiveEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx2[0].actor,
        "system.attributes.exhaustion"
      );
      exhaustiontracker.$set(exhaustiontracker_changes);
    },
    i(local) {
      if (current) return;
      transition_in(exhaustiontracker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exhaustiontracker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exhaustiontracker, detaching);
    }
  };
}
function create_if_block$j(ctx) {
  let inspiration;
  let current;
  inspiration = new Inspiration({
    props: {
      inspired: (
        /*$context*/
        ctx[0].actor.system.attributes.inspiration
      ),
      radiusClass: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle ? "rounded" : "top-right"
      ),
      onlyShowOnHover: (
        /*$settingStore*/
        ctx[2].showInspirationOnHover || /*$settingStore*/
        ctx[2].hideIfZero && !/*$context*/
        ctx[0].actor.system.attributes.inspiration
      ),
      animate: (
        /*$settingStore*/
        ctx[2].animateInspiration
      )
    }
  });
  return {
    c() {
      create_component(inspiration.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inspiration, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inspiration_changes = {};
      if (dirty & /*$context*/
      1) inspiration_changes.inspired = /*$context*/
      ctx2[0].actor.system.attributes.inspiration;
      if (dirty & /*$context*/
      1) inspiration_changes.radiusClass = /*$context*/
      ctx2[0].useRoundedPortraitStyle ? "rounded" : "top-right";
      if (dirty & /*$settingStore, $context*/
      5) inspiration_changes.onlyShowOnHover = /*$settingStore*/
      ctx2[2].showInspirationOnHover || /*$settingStore*/
      ctx2[2].hideIfZero && !/*$context*/
      ctx2[0].actor.system.attributes.inspiration;
      if (dirty & /*$settingStore*/
      4) inspiration_changes.animate = /*$settingStore*/
      ctx2[2].animateInspiration;
      inspiration.$set(inspiration_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inspiration.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inspiration.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inspiration, detaching);
    }
  };
}
function create_default_slot$f(ctx) {
  let show_if = (
    /*incapacitated*/
    ctx[1] && (!/*$settingStore*/
    ctx[2].hideDeathSavesFromPlayers || FoundryAdapter.userIsGm())
  );
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let t2;
  let characterhitpoints;
  let t3;
  let rest;
  let t4;
  let hitdice;
  let current;
  let if_block0 = show_if && create_if_block_3$5(ctx);
  const if_block_creators = [create_if_block_1$a, create_if_block_2$8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$settingStore*/
      ctx2[2].useExhaustion && /*$settingStore*/
      ctx2[2].exhaustionConfig.type === "specific"
    ) return 0;
    if (
      /*$settingStore*/
      ctx2[2].useExhaustion && /*$settingStore*/
      ctx2[2].exhaustionConfig.type === "open"
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block2 = (
    /*$settingStore*/
    ctx[2].useCharacterInspiration && create_if_block$j(ctx)
  );
  characterhitpoints = new CharacterHitPoints({
    props: {
      value: (
        /*$context*/
        ctx[0].system.attributes.hp.value
      ),
      max: (
        /*$context*/
        ctx[0].system.attributes.hp.max
      ),
      actor: (
        /*$context*/
        ctx[0].actor
      ),
      incapacitated: (
        /*incapacitated*/
        ctx[1]
      )
    }
  });
  rest = new Rest({});
  hitdice = new HitDice({});
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      t2 = space();
      create_component(characterhitpoints.$$.fragment);
      t3 = space();
      create_component(rest.$$.fragment);
      t4 = space();
      create_component(hitdice.$$.fragment);
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, t2, anchor);
      mount_component(characterhitpoints, target, anchor);
      insert(target, t3, anchor);
      mount_component(rest, target, anchor);
      insert(target, t4, anchor);
      mount_component(hitdice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*incapacitated, $settingStore*/
      6) show_if = /*incapacitated*/
      ctx2[1] && (!/*$settingStore*/
      ctx2[2].hideDeathSavesFromPlayers || FoundryAdapter.userIsGm());
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*incapacitated, $settingStore*/
          6) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        } else {
          if_block1 = null;
        }
      }
      if (
        /*$settingStore*/
        ctx2[2].useCharacterInspiration
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$settingStore*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$j(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const characterhitpoints_changes = {};
      if (dirty & /*$context*/
      1) characterhitpoints_changes.value = /*$context*/
      ctx2[0].system.attributes.hp.value;
      if (dirty & /*$context*/
      1) characterhitpoints_changes.max = /*$context*/
      ctx2[0].system.attributes.hp.max;
      if (dirty & /*$context*/
      1) characterhitpoints_changes.actor = /*$context*/
      ctx2[0].actor;
      if (dirty & /*incapacitated*/
      2) characterhitpoints_changes.incapacitated = /*incapacitated*/
      ctx2[1];
      characterhitpoints.$set(characterhitpoints_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(characterhitpoints.$$.fragment, local);
      transition_in(rest.$$.fragment, local);
      transition_in(hitdice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(characterhitpoints.$$.fragment, local);
      transition_out(rest.$$.fragment, local);
      transition_out(hitdice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
      }
      if (if_block0) if_block0.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (if_block2) if_block2.d(detaching);
      destroy_component(characterhitpoints, detaching);
      destroy_component(rest, detaching);
      destroy_component(hitdice, detaching);
    }
  };
}
function create_fragment$J(ctx) {
  let actorprofile;
  let t2;
  let temphp;
  let current;
  actorprofile = new ActorProfile({
    props: {
      useHpOverlay: (
        /*$settingStore*/
        ctx[2].useHpOverlay
      ),
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  temphp = new TempHp({});
  return {
    c() {
      create_component(actorprofile.$$.fragment);
      t2 = space();
      create_component(temphp.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actorprofile, target, anchor);
      insert(target, t2, anchor);
      mount_component(temphp, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const actorprofile_changes = {};
      if (dirty & /*$settingStore*/
      4) actorprofile_changes.useHpOverlay = /*$settingStore*/
      ctx2[2].useHpOverlay;
      if (dirty & /*$$scope, $context, incapacitated, $settingStore*/
      71) {
        actorprofile_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actorprofile.$set(actorprofile_changes);
    },
    i(local) {
      if (current) return;
      transition_in(actorprofile.$$.fragment, local);
      transition_in(temphp.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorprofile.$$.fragment, local);
      transition_out(temphp.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(actorprofile, detaching);
      destroy_component(temphp, detaching);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  let incapacitated;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  async function onLevelSelected(event) {
    await $context.actor.update({
      "system.attributes.exhaustion": event.detail.level
    });
  }
  const rollDeathSave_handler = (event) => $context.actor.rollDeathSave({ event: event.detail.mouseEvent });
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, incapacitated = ($context.actor?.system?.attributes?.hp?.value ?? 0) <= 0 && $context.actor?.system?.attributes?.hp?.max !== 0);
    }
  };
  return [
    $context,
    incapacitated,
    $settingStore,
    context,
    onLevelSelected,
    rollDeathSave_handler
  ];
}
class CharacterProfile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$J, create_fragment$J, safe_not_equal, {});
  }
}
function get_each_context$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_else_block$c(ctx) {
  let t_value = (
    /*warning*/
    ctx[5].message + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*warnings*/
      1 && t_value !== (t_value = /*warning*/
      ctx2[5].message + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$i(ctx) {
  let button;
  let t_value = (
    /*warning*/
    ctx[5].message + ""
  );
  let t2;
  let button_tabindex_value;
  let button_data_target_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "inline-transparent-button svelte-1sgbaws");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-target", button_data_target_value = /*warning*/
      ctx[5].link);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*warnings*/
      1 && t_value !== (t_value = /*warning*/
      ctx2[5].message + "")) set_data(t2, t_value);
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*warnings*/
      1 && button_data_target_value !== (button_data_target_value = /*warning*/
      ctx2[5].link)) {
        attr(button, "data-target", button_data_target_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$5(ctx) {
  let li;
  let t2;
  let li_class_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*warning*/
      ctx2[5].link
    ) return create_if_block$i;
    return create_else_block$c;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      li = element("li");
      if_block.c();
      t2 = space();
      attr(li, "class", li_class_value = "notification " + /*warning*/
      ctx[5].type + " svelte-1sgbaws");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if_block.m(li, null);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(li, t2);
        }
      }
      if (dirty & /*warnings*/
      1 && li_class_value !== (li_class_value = "notification " + /*warning*/
      ctx2[5].type + " svelte-1sgbaws")) {
        attr(li, "class", li_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if_block.d();
    }
  };
}
function create_fragment$I(ctx) {
  let ol;
  let each_value = ensure_array_like(
    /*warnings*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$5(get_each_context$5(ctx, each_value, i2));
  }
  return {
    c() {
      ol = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ol, "class", "warnings svelte-1sgbaws");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*warnings, $settingStore, $context*/
      7) {
        each_value = ensure_array_like(
          /*warnings*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$5(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ol, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$I($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let { warnings } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const click_handler = (ev) => $context.actor.sheet._onWarningLink(ev);
  $$self.$$set = ($$props2) => {
    if ("warnings" in $$props2) $$invalidate(0, warnings = $$props2.warnings);
  };
  return [warnings, $context, $settingStore, context, click_handler];
}
class ActorWarnings extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$I, safe_not_equal, { warnings: 0 });
  }
}
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = (
    /*$context*/
    child_ctx[0].saves.concentration
  );
  child_ctx[4] = constants_0;
  return child_ctx;
}
function create_if_block$h(ctx) {
  let span1;
  let button;
  let dnd5eicon;
  let t0;
  let t1_value = (
    /*save*/
    ctx[4].label + ""
  );
  let t1;
  let t2;
  let span0;
  let t3_value = (
    /*save*/
    ctx[4].sign + ""
  );
  let t3;
  let t4_value = (
    /*save*/
    ctx[4].mod + ""
  );
  let t4;
  let t5;
  let current;
  let mounted;
  let dispose;
  dnd5eicon = new Dnd5eIcon({
    props: {
      src: "systems/dnd5e/icons/svg/statuses/concentrating.svg"
    }
  });
  let if_block = (
    /*$context*/
    ctx[0].unlocked && create_if_block_1$9(ctx)
  );
  return {
    c() {
      span1 = element("span");
      button = element("button");
      create_component(dnd5eicon.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      t2 = text(":\n      ");
      span0 = element("span");
      t3 = text(t3_value);
      t4 = text(t4_value);
      t5 = space();
      if (if_block) if_block.c();
      attr(span0, "class", "special-save-mod");
      attr(button, "type", "button");
      attr(button, "class", "inline-transparent-button flex-row extra-small-gap align-items-center highlight-on-hover svelte-19re4qq");
      attr(span1, "class", "special-save svelte-19re4qq");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, button);
      mount_component(dnd5eicon, button, null);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      append(button, span0);
      append(span0, t3);
      append(span0, t4);
      append(span1, t5);
      if (if_block) if_block.m(span1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*$context*/
      1) && t1_value !== (t1_value = /*save*/
      ctx2[4].label + "")) set_data(t1, t1_value);
      if ((!current || dirty & /*$context*/
      1) && t3_value !== (t3_value = /*save*/
      ctx2[4].sign + "")) set_data(t3, t3_value);
      if ((!current || dirty & /*$context*/
      1) && t4_value !== (t4_value = /*save*/
      ctx2[4].mod + "")) set_data(t4, t4_value);
      if (
        /*$context*/
        ctx2[0].unlocked
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$9(ctx2);
          if_block.c();
          if_block.m(span1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current) return;
      transition_in(dnd5eicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      destroy_component(dnd5eicon);
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$9(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fas fa-cog" style="font-size: var(--icon-size);"></i>`;
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button svelte-19re4qq");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$H(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].saves.concentration && create_if_block$h(get_if_ctx(ctx))
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$context*/
        ctx2[0].saves.concentration
      ) {
        if (if_block) {
          if_block.p(get_if_ctx(ctx2), dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$h(get_if_ctx(ctx2));
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const click_handler = (ev) => $context.actor.rollConcentration({ event: ev });
  const click_handler_1 = () => FoundryAdapter.openActorConcentrationConfig($context.actor);
  return [$context, context, click_handler, click_handler_1];
}
class SpecialSaves extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$H, safe_not_equal, {});
  }
}
function create_else_block$b(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-lock svelte-1ecpux5");
      attr(
        i2,
        "title",
        /*lockTitle*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*lockTitle*/
      2) {
        attr(
          i2,
          "title",
          /*lockTitle*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block$g(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fas fa-lock-open svelte-1ecpux5");
      attr(
        i2,
        "title",
        /*unlockTitle*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*unlockTitle*/
      4) {
        attr(
          i2,
          "title",
          /*unlockTitle*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_fragment$G(ctx) {
  let div;
  let button;
  let button_tabindex_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*allowEdit*/
      ctx2[3]
    ) return create_if_block$g;
    return create_else_block$b;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      if_block.c();
      attr(button, "type", "button");
      attr(button, "class", "lock-button svelte-1ecpux5");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[0].useAccessibleKeyboardSupport ? 0 : -1);
      toggle_class(
        button,
        "editing-enabled",
        /*allowEdit*/
        ctx[3]
      );
      attr(div, "class", "toggle-allow-edit svelte-1ecpux5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty & /*$settingStore*/
      1 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[0].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*allowEdit*/
      8) {
        toggle_class(
          button,
          "editing-enabled",
          /*allowEdit*/
          ctx2[3]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let allowEdit;
  let descriptionVariable;
  let lockHintVariable;
  let unlockHintVariable;
  let unlockTitle;
  let lockTitle;
  let $settingStore;
  let $context;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(0, $settingStore = $$value));
  let { hint = null } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(10, $context = value));
  async function toggleLock() {
    await TidyFlags.allowEdit.set($context.actor, !allowEdit);
  }
  const localize = FoundryAdapter.localize;
  const click_handler = () => toggleLock();
  $$self.$$set = ($$props2) => {
    if ("hint" in $$props2) $$invalidate(6, hint = $$props2.hint);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1024) {
      $$invalidate(3, allowEdit = TidyFlags.allowEdit.get($context.actor));
    }
    if ($$self.$$.dirty & /*hint, $settingStore*/
    65) {
      $$invalidate(7, descriptionVariable = hint ?? ($settingStore.useTotalSheetLock ? localize("TIDY5E.SheetLock.Description") : localize("TIDY5E.SheetEdit.Description")));
    }
    if ($$self.$$.dirty & /*$settingStore*/
    1) {
      $$invalidate(8, lockHintVariable = $settingStore.useTotalSheetLock ? "TIDY5E.SheetLock.Unlock.Hint" : "TIDY5E.SheetEdit.Enable.Hint");
    }
    if ($$self.$$.dirty & /*$settingStore*/
    1) {
      $$invalidate(9, unlockHintVariable = $settingStore.useTotalSheetLock ? "TIDY5E.SheetLock.Lock.Hint" : "TIDY5E.SheetEdit.Disable.Hint");
    }
    if ($$self.$$.dirty & /*unlockHintVariable, descriptionVariable*/
    640) {
      $$invalidate(2, unlockTitle = localize(unlockHintVariable, { description: descriptionVariable }));
    }
    if ($$self.$$.dirty & /*lockHintVariable, descriptionVariable*/
    384) {
      $$invalidate(1, lockTitle = localize(lockHintVariable, { description: descriptionVariable }));
    }
  };
  return [
    $settingStore,
    lockTitle,
    unlockTitle,
    allowEdit,
    context,
    toggleLock,
    hint,
    descriptionVariable,
    lockHintVariable,
    unlockHintVariable,
    $context,
    click_handler
  ];
}
class AllowEditLock extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$G, safe_not_equal, { hint: 6 });
  }
}
function create_if_block_2$7(ctx) {
  let span;
  let t_value = (
    /*$context*/
    ctx[0].movement.primary + ""
  );
  let t2;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "title", span_title_value = /*$context*/
      ctx[0].movement.primary);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && t_value !== (t_value = /*$context*/
      ctx2[0].movement.primary + "")) set_data(t2, t_value);
      if (dirty & /*$context*/
      1 && span_title_value !== (span_title_value = /*$context*/
      ctx2[0].movement.primary)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$8(ctx) {
  let t0;
  let span;
  let t1_value = (
    /*$context*/
    ctx[0].movement.special + ""
  );
  let t1;
  let span_title_value;
  return {
    c() {
      t0 = text("|\n    ");
      span = element("span");
      t1 = text(t1_value);
      attr(span, "title", span_title_value = /*$context*/
      ctx[0].movement.special);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && t1_value !== (t1_value = /*$context*/
      ctx2[0].movement.special + "")) set_data(t1, t1_value);
      if (dirty & /*$context*/
      1 && span_title_value !== (span_title_value = /*$context*/
      ctx2[0].movement.special)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
    }
  };
}
function create_if_block$f(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "configure inline-icon-button svelte-vrhemn");
      attr(
        button,
        "title",
        /*localize*/
        ctx[3]("DND5E.MovementConfig")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      2 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$F(ctx) {
  let section;
  let h4;
  let t1;
  let t2;
  let t3;
  let section_class_value;
  let if_block0 = (
    /*$context*/
    ctx[0].movement.primary && create_if_block_2$7(ctx)
  );
  let if_block1 = (
    /*$context*/
    ctx[0].movement.special && create_if_block_1$8(ctx)
  );
  let if_block2 = (
    /*$context*/
    ctx[0].unlocked && create_if_block$f(ctx)
  );
  return {
    c() {
      section = element("section");
      h4 = element("h4");
      h4.textContent = `${/*localize*/
      ctx[3]("DND5E.Speed")}`;
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      attr(section, "class", section_class_value = "movement flex-row small-gap " + /*$$restProps*/
      (ctx[4].class ?? "") + " svelte-vrhemn");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h4);
      append(section, t1);
      if (if_block0) if_block0.m(section, null);
      append(section, t2);
      if (if_block1) if_block1.m(section, null);
      append(section, t3);
      if (if_block2) if_block2.m(section, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*$context*/
        ctx2[0].movement.primary
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$7(ctx2);
          if_block0.c();
          if_block0.m(section, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$context*/
        ctx2[0].movement.special
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$8(ctx2);
          if_block1.c();
          if_block1.m(section, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$context*/
        ctx2[0].unlocked
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$f(ctx2);
          if_block2.c();
          if_block2.m(section, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & /*$$restProps*/
      16 && section_class_value !== (section_class_value = "movement flex-row small-gap " + /*$$restProps*/
      (ctx2[4].class ?? "") + " svelte-vrhemn")) {
        attr(section, "class", section_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = () => FoundryAdapter.renderActorMovementConfig($context.actor);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$context, $settingStore, context, localize, $$restProps, click_handler];
}
class ActorMovement extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$F, safe_not_equal, {});
  }
}
function create_fragment$E(ctx) {
  let button;
  let h4;
  let t2;
  let button_disabled_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  let button_levels = [
    { type: "button" },
    { class: "transparent-button" },
    { title: (
      /*title*/
      ctx[0]
    ) },
    {
      disabled: button_disabled_value = !/*$context*/
      ctx[4].editable
    },
    {
      tabindex: button_tabindex_value = !/*hideFromTabOrder*/
      ctx[2] ? 0 : -1
    },
    /*attributes*/
    ctx[3]
  ];
  let button_data = {};
  for (let i2 = 0; i2 < button_levels.length; i2 += 1) {
    button_data = assign(button_data, button_levels[i2]);
  }
  return {
    c() {
      button = element("button");
      h4 = element("h4");
      t2 = text(
        /*text*/
        ctx[1]
      );
      attr(h4, "class", "block-title svelte-1hz5i72");
      set_attributes(button, button_data);
      toggle_class(
        button,
        "rollable",
        /*$context*/
        ctx[4].editable
      );
      toggle_class(button, "svelte-1hz5i72", true);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, h4);
      append(h4, t2);
      if (button.autofocus) button.focus();
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*text*/
      2) set_data(
        t2,
        /*text*/
        ctx2[1]
      );
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { class: "transparent-button" },
        dirty & /*title*/
        1 && { title: (
          /*title*/
          ctx2[0]
        ) },
        dirty & /*$context*/
        16 && button_disabled_value !== (button_disabled_value = !/*$context*/
        ctx2[4].editable) && { disabled: button_disabled_value },
        dirty & /*hideFromTabOrder*/
        4 && button_tabindex_value !== (button_tabindex_value = !/*hideFromTabOrder*/
        ctx2[2] ? 0 : -1) && { tabindex: button_tabindex_value },
        dirty & /*attributes*/
        8 && /*attributes*/
        ctx2[3]
      ]));
      toggle_class(
        button,
        "rollable",
        /*$context*/
        ctx2[4].editable
      );
      toggle_class(button, "svelte-1hz5i72", true);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$E($$self, $$props, $$invalidate) {
  let $context;
  let { title = null } = $$props;
  let { text: text2 } = $$props;
  let { hideFromTabOrder = false } = $$props;
  let { attributes = {} } = $$props;
  const dispatcher = createEventDispatcher();
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(4, $context = value));
  const click_handler = (ev) => dispatcher("roll", ev);
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("text" in $$props2) $$invalidate(1, text2 = $$props2.text);
    if ("hideFromTabOrder" in $$props2) $$invalidate(2, hideFromTabOrder = $$props2.hideFromTabOrder);
    if ("attributes" in $$props2) $$invalidate(3, attributes = $$props2.attributes);
  };
  return [
    title,
    text2,
    hideFromTabOrder,
    attributes,
    $context,
    dispatcher,
    context,
    click_handler
  ];
}
class RollableBlockTitle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$E, safe_not_equal, {
      title: 0,
      text: 1,
      hideFromTabOrder: 2,
      attributes: 3
    });
  }
}
function create_fragment$D(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr(div, "class", "block-score svelte-yh7889");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class BlockScore extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$D, safe_not_equal, {});
  }
}
function create_default_slot$e(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[4].actor
      ),
      field: "system.abilities." + /*id*/
      ctx[0] + ".value",
      value: (
        /*ability*/
        ctx[1].value
      ),
      placeholder: "10",
      selectOnFocus: true,
      allowDeltaChanges: true,
      disabled: (
        /*$context*/
        ctx[4].lockSensitiveFields
      ),
      attributes: {
        "data-tidy-sheet-part": CONSTANTS.SHEET_PARTS.ABILITY_SCORE
      }
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      16) textinput_changes.document = /*$context*/
      ctx2[4].actor;
      if (dirty & /*id*/
      1) textinput_changes.field = "system.abilities." + /*id*/
      ctx2[0] + ".value";
      if (dirty & /*ability*/
      2) textinput_changes.value = /*ability*/
      ctx2[1].value;
      if (dirty & /*$context*/
      16) textinput_changes.disabled = /*$context*/
      ctx2[4].lockSensitiveFields;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_1$7(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[4].unlocked
    ) return create_if_block_2$6;
    return create_else_block$a;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block$a(ctx) {
  let span;
  let raw_value = (
    /*ability*/
    ctx[1].icon + ""
  );
  let span_title_value;
  let span_data_tooltip_value;
  return {
    c() {
      span = element("span");
      attr(span, "title", span_title_value = /*ability*/
      ctx[1].hover);
      attr(span, "class", "proficiency-toggle-readonly svelte-t23tby");
      attr(span, "data-tooltip", span_data_tooltip_value = /*activeEffectApplied*/
      ctx[5] ? (
        /*localize*/
        ctx[9]("DND5E.ActiveEffectOverrideWarning")
      ) : null);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & /*ability*/
      2 && raw_value !== (raw_value = /*ability*/
      ctx2[1].icon + "")) span.innerHTML = raw_value;
      if (dirty & /*ability*/
      2 && span_title_value !== (span_title_value = /*ability*/
      ctx2[1].hover)) {
        attr(span, "title", span_title_value);
      }
      if (dirty & /*activeEffectApplied*/
      32 && span_data_tooltip_value !== (span_data_tooltip_value = /*activeEffectApplied*/
      ctx2[5] ? (
        /*localize*/
        ctx2[9]("DND5E.ActiveEffectOverrideWarning")
      ) : null)) {
        attr(span, "data-tooltip", span_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2$6(ctx) {
  let button;
  let raw_value = (
    /*ability*/
    ctx[1].icon + ""
  );
  let button_title_value;
  let button_tabindex_value;
  let button_data_tooltip_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "type", "button");
      attr(button, "title", button_title_value = /*ability*/
      ctx[1].hover);
      attr(button, "class", "proficiency-toggle inline-icon-button svelte-t23tby");
      attr(button, "tabindex", button_tabindex_value = !/*$settingStore*/
      ctx[7].useDefaultSheetAttributeTabbing && /*$settingStore*/
      ctx[7].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ABILITY_SAVE_PROFICIENCY_TOGGLE);
      button.disabled = /*activeEffectApplied*/
      ctx[5];
      attr(button, "data-tooltip", button_data_tooltip_value = /*activeEffectApplied*/
      ctx[5] ? (
        /*localize*/
        ctx[9]("DND5E.ActiveEffectOverrideWarning")
      ) : null);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*ability*/
      2 && raw_value !== (raw_value = /*ability*/
      ctx2[1].icon + "")) button.innerHTML = raw_value;
      if (dirty & /*ability*/
      2 && button_title_value !== (button_title_value = /*ability*/
      ctx2[1].hover)) {
        attr(button, "title", button_title_value);
      }
      if (dirty & /*$settingStore*/
      128 && button_tabindex_value !== (button_tabindex_value = !/*$settingStore*/
      ctx2[7].useDefaultSheetAttributeTabbing && /*$settingStore*/
      ctx2[7].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*activeEffectApplied*/
      32) {
        button.disabled = /*activeEffectApplied*/
        ctx2[5];
      }
      if (dirty & /*activeEffectApplied*/
      32 && button_data_tooltip_value !== (button_data_tooltip_value = /*activeEffectApplied*/
      ctx2[5] ? (
        /*localize*/
        ctx2[9]("DND5E.ActiveEffectOverrideWarning")
      ) : null)) {
        attr(button, "data-tooltip", button_data_tooltip_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$e(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "config-button inline-icon-button svelte-t23tby");
      attr(
        button,
        "title",
        /*localize*/
        ctx[9]("DND5E.AbilityConfigure")
      );
      attr(button, "tabindex", button_tabindex_value = !/*$settingStore*/
      ctx[7].useDefaultSheetAttributeTabbing && /*$settingStore*/
      ctx[7].useAccessibleKeyboardSupport ? 0 : -1);
      attr(button, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ABILITY_CONFIGURATION_CONTROL);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_3*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      128 && button_tabindex_value !== (button_tabindex_value = !/*$settingStore*/
      ctx2[7].useDefaultSheetAttributeTabbing && /*$settingStore*/
      ctx2[7].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$C(ctx) {
  let div1;
  let blocktitle;
  let t0;
  let blockscore;
  let t1;
  let div0;
  let button0;
  let t2_value = formatAsModifier(
    /*ability*/
    ctx[1].mod
  ) + "";
  let t2;
  let button0_tabindex_value;
  let button0_disabled_value;
  let t3;
  let button1;
  let t4_value = formatAsModifier(
    /*ability*/
    ctx[1].save
  ) + "";
  let t4;
  let button1_tabindex_value;
  let button1_disabled_value;
  let t5;
  let t6;
  let t7;
  let span0;
  let t9;
  let span1;
  let current;
  let mounted;
  let dispose;
  blocktitle = new RollableBlockTitle({
    props: {
      title: (
        /*ability*/
        ctx[1].label
      ),
      text: (
        /*abbreviation*/
        ctx[6]
      ),
      hideFromTabOrder: (
        /*$settingStore*/
        ctx[7].useDefaultSheetAttributeTabbing || !/*$settingStore*/
        ctx[7].useAccessibleKeyboardSupport
      ),
      attributes: {
        "data-tidy-sheet-part": CONSTANTS.SHEET_PARTS.ABILITY_ROLLER
      }
    }
  });
  blocktitle.$on(
    "roll",
    /*roll_handler*/
    ctx[10]
  );
  blockscore = new BlockScore({
    props: {
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (
    /*useSavingThrowProficiency*/
    ctx[2] && create_if_block_1$7(ctx)
  );
  let if_block1 = (
    /*useConfigurationOption*/
    ctx[3] && /*$context*/
    ctx[4].editable && /*$context*/
    ctx[4].unlocked && create_if_block$e(ctx)
  );
  return {
    c() {
      div1 = element("div");
      create_component(blocktitle.$$.fragment);
      t0 = space();
      create_component(blockscore.$$.fragment);
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      t2 = text(t2_value);
      t3 = space();
      button1 = element("button");
      t4 = text(t4_value);
      t5 = space();
      if (if_block0) if_block0.c();
      t6 = space();
      if (if_block1) if_block1.c();
      t7 = space();
      span0 = element("span");
      span0.textContent = `${/*localize*/
      ctx[9]("TIDY5E.AbbrMod")}`;
      t9 = space();
      span1 = element("span");
      span1.textContent = `${/*localize*/
      ctx[9]("TIDY5E.AbbrSavingThrow")}`;
      attr(button0, "type", "button");
      attr(button0, "class", "ability-mod transparent-button svelte-t23tby");
      attr(
        button0,
        "title",
        /*localize*/
        ctx[9]("DND5E.AbilityModifier")
      );
      attr(button0, "tabindex", button0_tabindex_value = !/*$settingStore*/
      ctx[7].useDefaultSheetAttributeTabbing && /*$settingStore*/
      ctx[7].useAccessibleKeyboardSupport ? 0 : -1);
      button0.disabled = button0_disabled_value = !/*$context*/
      ctx[4].editable;
      attr(button0, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ABILITY_TEST_ROLLER);
      toggle_class(
        button0,
        "rollable",
        /*$context*/
        ctx[4].editable
      );
      attr(button1, "type", "button");
      attr(button1, "class", "ability-save transparent-button svelte-t23tby");
      attr(
        button1,
        "title",
        /*localize*/
        ctx[9]("DND5E.ActionSave")
      );
      attr(button1, "tabindex", button1_tabindex_value = !/*$settingStore*/
      ctx[7].useDefaultSheetAttributeTabbing && /*$settingStore*/
      ctx[7].useAccessibleKeyboardSupport ? 0 : -1);
      button1.disabled = button1_disabled_value = !/*$context*/
      ctx[4].editable;
      attr(button1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ABILITY_SAVE_ROLLER);
      toggle_class(
        button1,
        "rollable",
        /*$context*/
        ctx[4].editable
      );
      attr(div0, "class", "ability-modifiers svelte-t23tby");
      attr(span0, "class", "mod-label ability-mod-label svelte-t23tby");
      attr(span1, "class", "mod-label save-mod-label svelte-t23tby");
      attr(div1, "class", "wrapper svelte-t23tby");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.ABILITY_SCORE_CONTAINER);
      attr(
        div1,
        "data-ability",
        /*id*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(blocktitle, div1, null);
      append(div1, t0);
      mount_component(blockscore, div1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, button0);
      append(button0, t2);
      append(div0, t3);
      append(div0, button1);
      append(button1, t4);
      append(div0, t5);
      if (if_block0) if_block0.m(div0, null);
      append(div0, t6);
      if (if_block1) if_block1.m(div0, null);
      append(div1, t7);
      append(div1, span0);
      append(div1, t9);
      append(div1, span1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[11]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const blocktitle_changes = {};
      if (dirty & /*ability*/
      2) blocktitle_changes.title = /*ability*/
      ctx2[1].label;
      if (dirty & /*abbreviation*/
      64) blocktitle_changes.text = /*abbreviation*/
      ctx2[6];
      if (dirty & /*$settingStore*/
      128) blocktitle_changes.hideFromTabOrder = /*$settingStore*/
      ctx2[7].useDefaultSheetAttributeTabbing || !/*$settingStore*/
      ctx2[7].useAccessibleKeyboardSupport;
      blocktitle.$set(blocktitle_changes);
      const blockscore_changes = {};
      if (dirty & /*$$scope, $context, id, ability*/
      32787) {
        blockscore_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blockscore.$set(blockscore_changes);
      if ((!current || dirty & /*ability*/
      2) && t2_value !== (t2_value = formatAsModifier(
        /*ability*/
        ctx2[1].mod
      ) + "")) set_data(t2, t2_value);
      if (!current || dirty & /*$settingStore*/
      128 && button0_tabindex_value !== (button0_tabindex_value = !/*$settingStore*/
      ctx2[7].useDefaultSheetAttributeTabbing && /*$settingStore*/
      ctx2[7].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button0, "tabindex", button0_tabindex_value);
      }
      if (!current || dirty & /*$context*/
      16 && button0_disabled_value !== (button0_disabled_value = !/*$context*/
      ctx2[4].editable)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty & /*$context*/
      16) {
        toggle_class(
          button0,
          "rollable",
          /*$context*/
          ctx2[4].editable
        );
      }
      if ((!current || dirty & /*ability*/
      2) && t4_value !== (t4_value = formatAsModifier(
        /*ability*/
        ctx2[1].save
      ) + "")) set_data(t4, t4_value);
      if (!current || dirty & /*$settingStore*/
      128 && button1_tabindex_value !== (button1_tabindex_value = !/*$settingStore*/
      ctx2[7].useDefaultSheetAttributeTabbing && /*$settingStore*/
      ctx2[7].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button1, "tabindex", button1_tabindex_value);
      }
      if (!current || dirty & /*$context*/
      16 && button1_disabled_value !== (button1_disabled_value = !/*$context*/
      ctx2[4].editable)) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty & /*$context*/
      16) {
        toggle_class(
          button1,
          "rollable",
          /*$context*/
          ctx2[4].editable
        );
      }
      if (
        /*useSavingThrowProficiency*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$7(ctx2);
          if_block0.c();
          if_block0.m(div0, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*useConfigurationOption*/
        ctx2[3] && /*$context*/
        ctx2[4].editable && /*$context*/
        ctx2[4].unlocked
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$e(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*id*/
      1) {
        attr(
          div1,
          "data-ability",
          /*id*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(blocktitle.$$.fragment, local);
      transition_in(blockscore.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blocktitle.$$.fragment, local);
      transition_out(blockscore.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(blocktitle);
      destroy_component(blockscore);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let abbreviation;
  let activeEffectApplied;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(7, $settingStore = $$value));
  let { id } = $$props;
  let { ability } = $$props;
  let { useSavingThrowProficiency } = $$props;
  let { useConfigurationOption } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(4, $context = value));
  const localize = FoundryAdapter.localize;
  const roll_handler = (event) => $context.actor.rollAbility(id, { event: event.detail });
  const click_handler = (event) => $context.actor.rollAbilityTest(id, { event });
  const click_handler_1 = (event) => $context.actor.rollAbilitySave(id, { event });
  const click_handler_2 = () => $context.actor.update({
    [`system.abilities.${id}.proficient`]: 1 - parseInt(ability.proficient)
  });
  const click_handler_3 = () => FoundryAdapter.renderActorAbilityConfig($context.actor, id);
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("ability" in $$props2) $$invalidate(1, ability = $$props2.ability);
    if ("useSavingThrowProficiency" in $$props2) $$invalidate(2, useSavingThrowProficiency = $$props2.useSavingThrowProficiency);
    if ("useConfigurationOption" in $$props2) $$invalidate(3, useConfigurationOption = $$props2.useConfigurationOption);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*id*/
    1) {
      $$invalidate(6, abbreviation = CONFIG.DND5E.abilities[id]?.abbreviation ?? id);
    }
    if ($$self.$$.dirty & /*$context, id*/
    17) {
      $$invalidate(5, activeEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField($context.actor, `system.abilities.${id}.proficient`));
    }
  };
  return [
    id,
    ability,
    useSavingThrowProficiency,
    useConfigurationOption,
    $context,
    activeEffectApplied,
    abbreviation,
    $settingStore,
    context,
    localize,
    roll_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class AttributeBlock extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$C, safe_not_equal, {
      id: 0,
      ability: 1,
      useSavingThrowProficiency: 2,
      useConfigurationOption: 3
    });
  }
}
function create_default_slot$d(ctx) {
  let span;
  let t_value = formatAsModifier(
    /*initiative*/
    ctx[0].total
  ) + "";
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*initiative*/
      1 && t_value !== (t_value = formatAsModifier(
        /*initiative*/
        ctx2[0].total
      ) + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block$9(ctx) {
  let span;
  let i2;
  return {
    c() {
      span = element("span");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(span, "class", "config-button invisible svelte-1d4401o");
      attr(
        span,
        "title",
        /*localize*/
        ctx[4]("DND5E.InitiativeConfig")
      );
      attr(span, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, i2);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$d(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "config-button icon-button svelte-1d4401o");
      attr(
        button,
        "title",
        /*localize*/
        ctx[4]("DND5E.InitiativeConfig")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[2].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      4 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[2].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$B(ctx) {
  let div;
  let blocktitle;
  let t0;
  let blockscore;
  let t1;
  let label;
  let span;
  let t3;
  let textinput;
  let label_for_value;
  let t4;
  let current;
  blocktitle = new RollableBlockTitle({
    props: {
      title: (
        /*localize*/
        ctx[4]("DND5E.Initiative")
      ),
      text: (
        /*localize*/
        ctx[4]("TIDY5E.AbbrInitiative")
      )
    }
  });
  blocktitle.$on(
    "roll",
    /*roll_handler*/
    ctx[5]
  );
  blockscore = new BlockScore({
    props: {
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[1].actor
      ),
      field: "system.attributes.init.bonus",
      cssClass: "ini-mod",
      placeholder: "0",
      selectOnFocus: true,
      allowDeltaChanges: true,
      value: (
        /*initiative*/
        ctx[0].bonus
      ),
      disabled: !/*$context*/
      ctx[1].editable || !/*$context*/
      ctx[1].unlocked,
      id: (
        /*$context*/
        ctx[1].appId + "-initiative-mod"
      )
    }
  });
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[1].editable && /*$context*/
      ctx2[1].unlocked
    ) return create_if_block$d;
    return create_else_block$9;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      create_component(blocktitle.$$.fragment);
      t0 = space();
      create_component(blockscore.$$.fragment);
      t1 = space();
      label = element("label");
      span = element("span");
      span.textContent = `${/*localize*/
      ctx[4]("TIDY5E.AbbrMod")}`;
      t3 = space();
      create_component(textinput.$$.fragment);
      t4 = space();
      if_block.c();
      attr(label, "class", "ini-bonus svelte-1d4401o");
      attr(label, "for", label_for_value = /*$context*/
      ctx[1].appId + "-initiative-mod");
      attr(div, "class", "wrapper svelte-1d4401o");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(blocktitle, div, null);
      append(div, t0);
      mount_component(blockscore, div, null);
      append(div, t1);
      append(div, label);
      append(label, span);
      append(label, t3);
      mount_component(textinput, label, null);
      append(div, t4);
      if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const blockscore_changes = {};
      if (dirty & /*$$scope, initiative*/
      129) {
        blockscore_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blockscore.$set(blockscore_changes);
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].actor;
      if (dirty & /*initiative*/
      1) textinput_changes.value = /*initiative*/
      ctx2[0].bonus;
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable || !/*$context*/
      ctx2[1].unlocked;
      if (dirty & /*$context*/
      2) textinput_changes.id = /*$context*/
      ctx2[1].appId + "-initiative-mod";
      textinput.$set(textinput_changes);
      if (!current || dirty & /*$context*/
      2 && label_for_value !== (label_for_value = /*$context*/
      ctx2[1].appId + "-initiative-mod")) {
        attr(label, "for", label_for_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(blocktitle.$$.fragment, local);
      transition_in(blockscore.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blocktitle.$$.fragment, local);
      transition_out(blockscore.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(blocktitle);
      destroy_component(blockscore);
      destroy_component(textinput);
      if_block.d();
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let { initiative } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const localize = FoundryAdapter.localize;
  const roll_handler = (event) => $context.actor.rollInitiativeDialog({ event: event.detail });
  const click_handler = () => FoundryAdapter.renderActorInitiativeConfig($context.actor);
  $$self.$$set = ($$props2) => {
    if ("initiative" in $$props2) $$invalidate(0, initiative = $$props2.initiative);
  };
  return [
    initiative,
    $context,
    $settingStore,
    context,
    localize,
    roll_handler,
    click_handler
  ];
}
class InitiativeBlock extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$B, safe_not_equal, { initiative: 0 });
  }
}
function create_fragment$A(ctx) {
  let div1;
  let div0;
  let t2;
  let div1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<svg version="1.1" x="0px" y="0px" viewBox="0 0 90 100" xml:space="preserve"><path d="M45,100C-2.6,79.3,0,12.6,0,12.6c0-2.2,1.8-4,4.4-4.6l39.1-7.9C44,0,44.5,0,45,0c0.5,0,1,0,1.4,0.1L85.5,8
                  c2.6,0.5,4.4,2.4,4.4,4.6C90,12.6,92.6,79.3,45,100L45,100z" class="svelte-14lgvaq"></path></svg>`;
      t2 = space();
      if (default_slot) default_slot.c();
      attr(div0, "class", "ac-shield svelte-14lgvaq");
      attr(div1, "class", div1_class_value = "ac-display " + /*cssClass*/
      ctx[0] + " svelte-14lgvaq");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t2);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cssClass*/
      1 && div1_class_value !== (div1_class_value = "ac-display " + /*cssClass*/
      ctx2[0] + " svelte-14lgvaq")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { cssClass = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [cssClass, $$scope, slots];
}
class AcShieldBase extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$A, safe_not_equal, { cssClass: 0 });
  }
}
function create_default_slot$c(ctx) {
  let button;
  let t2;
  let button_disabled_value;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(
        /*ac*/
        ctx[0]
      );
      attr(button, "type", "button");
      attr(button, "class", "config-button attribute-value transparent-button svelte-35vblg");
      attr(button, "data-attribution", "attributes.ac");
      attr(button, "data-attribution-caption", "DND5E.ArmorClass");
      attr(button, "data-tooltip-direction", "DOWN");
      button.disabled = button_disabled_value = !/*$context*/
      ctx[3].editable;
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[4].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      ctx[7](button);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button,
            "focus",
            /*focus_handler*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*ac*/
      1) set_data(
        t2,
        /*ac*/
        ctx2[0]
      );
      if (dirty & /*$context*/
      8 && button_disabled_value !== (button_disabled_value = !/*$context*/
      ctx2[3].editable)) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*$settingStore*/
      16 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[4].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$z(ctx) {
  let acshieldbase;
  let current;
  acshieldbase = new AcShieldBase({
    props: {
      cssClass: (
        /*cssClass*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(acshieldbase.$$.fragment);
    },
    m(target, anchor) {
      mount_component(acshieldbase, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const acshieldbase_changes = {};
      if (dirty & /*cssClass*/
      2) acshieldbase_changes.cssClass = /*cssClass*/
      ctx2[1];
      if (dirty & /*$$scope, $context, $settingStore, acShieldButton, ac*/
      541) {
        acshieldbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      acshieldbase.$set(acshieldbase_changes);
    },
    i(local) {
      if (current) return;
      transition_in(acshieldbase.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(acshieldbase.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(acshieldbase, detaching);
    }
  };
}
function instance$z($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(4, $settingStore = $$value));
  let { ac = "0" } = $$props;
  let { cssClass = "" } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(3, $context = value));
  let acShieldButton;
  onMount(() => {
    $context.actor.sheet._applyAttributionTooltips(acShieldButton);
  });
  function focus_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      acShieldButton = $$value;
      $$invalidate(2, acShieldButton);
    });
  }
  const click_handler = () => FoundryAdapter.renderArmorConfig($context.actor);
  $$self.$$set = ($$props2) => {
    if ("ac" in $$props2) $$invalidate(0, ac = $$props2.ac);
    if ("cssClass" in $$props2) $$invalidate(1, cssClass = $$props2.cssClass);
  };
  return [
    ac,
    cssClass,
    acShieldButton,
    $context,
    $settingStore,
    context,
    focus_handler2,
    button_binding,
    click_handler
  ];
}
class AcShield extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$z, safe_not_equal, { ac: 0, cssClass: 1 });
  }
}
function get_each_context$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2][0];
  child_ctx[4] = list[i2][1];
  return child_ctx;
}
function create_each_block$4(ctx) {
  let verticallineseparator;
  let t0;
  let div;
  let attributeblock;
  let t1;
  let current;
  verticallineseparator = new VerticalLineSeparator({});
  attributeblock = new AttributeBlock({
    props: {
      id: (
        /*id*/
        ctx[3]
      ),
      ability: (
        /*ability*/
        ctx[4]
      ),
      useSavingThrowProficiency: true,
      useConfigurationOption: true
    }
  });
  return {
    c() {
      create_component(verticallineseparator.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(attributeblock.$$.fragment);
      t1 = space();
    },
    m(target, anchor) {
      mount_component(verticallineseparator, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(attributeblock, div, null);
      append(div, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const attributeblock_changes = {};
      if (dirty & /*abilities*/
      4) attributeblock_changes.id = /*id*/
      ctx2[3];
      if (dirty & /*abilities*/
      4) attributeblock_changes.ability = /*ability*/
      ctx2[4];
      attributeblock.$set(attributeblock_changes);
    },
    i(local) {
      if (current) return;
      transition_in(verticallineseparator.$$.fragment, local);
      transition_in(attributeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(verticallineseparator.$$.fragment, local);
      transition_out(attributeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
      destroy_component(verticallineseparator, detaching);
      destroy_component(attributeblock);
    }
  };
}
function create_fragment$y(ctx) {
  let section;
  let acshield;
  let t0;
  let verticallineseparator;
  let t1;
  let div;
  let initiativeblock;
  let t2;
  let current;
  acshield = new AcShield({ props: { ac: (
    /*ac*/
    ctx[0].value
  ) } });
  verticallineseparator = new VerticalLineSeparator({});
  initiativeblock = new InitiativeBlock({ props: { initiative: (
    /*init*/
    ctx[1]
  ) } });
  let each_value = ensure_array_like(
    /*abilities*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$4(get_each_context$4(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      section = element("section");
      create_component(acshield.$$.fragment);
      t0 = space();
      create_component(verticallineseparator.$$.fragment);
      t1 = space();
      div = element("div");
      create_component(initiativeblock.$$.fragment);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(section, "class", "actor-stats");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      mount_component(acshield, section, null);
      append(section, t0);
      mount_component(verticallineseparator, section, null);
      append(section, t1);
      append(section, div);
      mount_component(initiativeblock, div, null);
      append(section, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const acshield_changes = {};
      if (dirty & /*ac*/
      1) acshield_changes.ac = /*ac*/
      ctx2[0].value;
      acshield.$set(acshield_changes);
      const initiativeblock_changes = {};
      if (dirty & /*init*/
      2) initiativeblock_changes.initiative = /*init*/
      ctx2[1];
      initiativeblock.$set(initiativeblock_changes);
      if (dirty & /*abilities*/
      4) {
        each_value = ensure_array_like(
          /*abilities*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(section, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(acshield.$$.fragment, local);
      transition_in(verticallineseparator.$$.fragment, local);
      transition_in(initiativeblock.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(acshield.$$.fragment, local);
      transition_out(verticallineseparator.$$.fragment, local);
      transition_out(initiativeblock.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(acshield);
      destroy_component(verticallineseparator);
      destroy_component(initiativeblock);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let { ac } = $$props;
  let { init: init2 } = $$props;
  let { abilities } = $$props;
  $$self.$$set = ($$props2) => {
    if ("ac" in $$props2) $$invalidate(0, ac = $$props2.ac);
    if ("init" in $$props2) $$invalidate(1, init2 = $$props2.init);
    if ("abilities" in $$props2) $$invalidate(2, abilities = $$props2.abilities);
  };
  return [ac, init2, abilities];
}
class ActorHeaderStats extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$y, safe_not_equal, { ac: 0, init: 1, abilities: 2 });
  }
}
function create_left_header_slot(ctx) {
  let h2;
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[5]("TIDY5E.TabSelection.AvailableHeader")}`;
      attr(h2, "class", "minimal");
      attr(h2, "slot", "left-header");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
    }
  };
}
function create_right_header_slot(ctx) {
  let h2;
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[5]("TIDY5E.TabSelection.SelectedHeader")}`;
      attr(h2, "class", "minimal");
      attr(h2, "slot", "right-header");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
    }
  };
}
function create_fragment$x(ctx) {
  let section;
  let selectionlistbox;
  let updating_leftItems;
  let updating_rightItems;
  let t0;
  let p2;
  let span0;
  let t1;
  let span1;
  let t3;
  let div;
  let button0;
  let i1;
  let t4;
  let t5_value = (
    /*localize*/
    ctx[5]("TIDY5E.UseDefault") + ""
  );
  let t5;
  let t6;
  let button1;
  let i2;
  let t7;
  let t8_value = (
    /*localize*/
    ctx[5]("TIDY5E.SaveChanges") + ""
  );
  let t8;
  let t9;
  let button2;
  let i3;
  let t10;
  let t11_value = (
    /*localize*/
    ctx[5]("TIDY5E.ApplyChanges") + ""
  );
  let t11;
  let current;
  let mounted;
  let dispose;
  function selectionlistbox_leftItems_binding(value) {
    ctx[6](value);
  }
  function selectionlistbox_rightItems_binding(value) {
    ctx[7](value);
  }
  let selectionlistbox_props = {
    labelProp: "label",
    valueProp: "id",
    listboxCssClass: "scroll-container",
    class: "flex-1",
    $$slots: {
      "right-header": [create_right_header_slot],
      "left-header": [create_left_header_slot]
    },
    $$scope: { ctx }
  };
  if (
    /*$context*/
    ctx[0].available !== void 0
  ) {
    selectionlistbox_props.leftItems = /*$context*/
    ctx[0].available;
  }
  if (
    /*$context*/
    ctx[0].selected !== void 0
  ) {
    selectionlistbox_props.rightItems = /*$context*/
    ctx[0].selected;
  }
  selectionlistbox = new SelectionListbox({ props: selectionlistbox_props });
  binding_callbacks.push(() => bind(selectionlistbox, "leftItems", selectionlistbox_leftItems_binding));
  binding_callbacks.push(() => bind(selectionlistbox, "rightItems", selectionlistbox_rightItems_binding));
  return {
    c() {
      section = element("section");
      create_component(selectionlistbox.$$.fragment);
      t0 = space();
      p2 = element("p");
      span0 = element("span");
      span0.innerHTML = `<i class="fas fa-info-circle svelte-1pq5yap"></i>`;
      t1 = space();
      span1 = element("span");
      span1.textContent = `${/*localize*/
      ctx[5]("TIDY5E.TabSelection.Explanation")}`;
      t3 = space();
      div = element("div");
      button0 = element("button");
      i1 = element("i");
      t4 = space();
      t5 = text(t5_value);
      t6 = space();
      button1 = element("button");
      i2 = element("i");
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      button2 = element("button");
      i3 = element("i");
      t10 = space();
      t11 = text(t11_value);
      attr(span0, "class", "extra-info-icon-container svelte-1pq5yap");
      attr(p2, "class", "flex-row align-items-center no-gap");
      attr(i1, "class", "fas fa-rotate-right");
      attr(button0, "type", "button");
      attr(button0, "class", "use-default-btn");
      attr(i2, "class", "fas fa-save");
      attr(button1, "type", "submit");
      attr(button1, "class", "save-changes-btn");
      attr(i3, "class", "fas fa-check");
      attr(button2, "type", "button");
      attr(button2, "class", "apply-changes-btn");
      attr(div, "class", "flex-row small-gap");
      attr(section, "class", "tab-selection-container full-height flex-column");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      mount_component(selectionlistbox, section, null);
      append(section, t0);
      append(section, p2);
      append(p2, span0);
      append(p2, t1);
      append(p2, span1);
      append(section, t3);
      append(section, div);
      append(div, button0);
      append(button0, i1);
      append(button0, t4);
      append(button0, t5);
      append(div, t6);
      append(div, button1);
      append(button1, i2);
      append(button1, t7);
      append(button1, t8);
      append(div, t9);
      append(div, button2);
      append(button2, i3);
      append(button2, t10);
      append(button2, t11);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[9]
          ),
          listen(
            button2,
            "click",
            /*click_handler_2*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const selectionlistbox_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        selectionlistbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_leftItems && dirty & /*$context*/
      1) {
        updating_leftItems = true;
        selectionlistbox_changes.leftItems = /*$context*/
        ctx2[0].available;
        add_flush_callback(() => updating_leftItems = false);
      }
      if (!updating_rightItems && dirty & /*$context*/
      1) {
        updating_rightItems = true;
        selectionlistbox_changes.rightItems = /*$context*/
        ctx2[0].selected;
        add_flush_callback(() => updating_rightItems = false);
      }
      selectionlistbox.$set(selectionlistbox_changes);
    },
    i(local) {
      if (current) return;
      transition_in(selectionlistbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectionlistbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(selectionlistbox);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const apply = getContext(CONSTANTS.SVELTE_CONTEXT.APPLY);
  const validate = getContext(CONSTANTS.SVELTE_CONTEXT.VALIDATE);
  const useDefault = getContext(CONSTANTS.SVELTE_CONTEXT.USE_DEFAULT);
  const localize = FoundryAdapter.localize;
  function selectionlistbox_leftItems_binding(value) {
    if ($$self.$$.not_equal($context.available, value)) {
      $context.available = value;
      context.set($context);
    }
  }
  function selectionlistbox_rightItems_binding(value) {
    if ($$self.$$.not_equal($context.selected, value)) {
      $context.selected = value;
      context.set($context);
    }
  }
  const click_handler = (ev) => useDefault();
  const click_handler_1 = (ev) => validate() || ev.preventDefault();
  const click_handler_2 = () => validate() && apply();
  return [
    $context,
    context,
    apply,
    validate,
    useDefault,
    localize,
    selectionlistbox_leftItems_binding,
    selectionlistbox_rightItems_binding,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class TabSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$x, safe_not_equal, {});
  }
}
class TabSelectionFormApplication extends SvelteFormApplicationBase {
  actor;
  context = writable({ available: [], selected: [] });
  registeredTabs;
  constructor(actor, ...args) {
    super(...args);
    this.actor = actor;
    this.registeredTabs = this.getRegisteredTabs(actor);
  }
  getRegisteredTabs(actor) {
    if (actor.type === CONSTANTS.SHEET_TYPE_CHARACTER) {
      return CharacterSheetRuntime.getAllRegisteredTabs();
    } else if (actor.type === CONSTANTS.SHEET_TYPE_NPC) {
      return NpcSheetRuntime.getAllRegisteredTabs();
    } else if (actor.type === CONSTANTS.SHEET_TYPE_VEHICLE) {
      return VehicleSheetRuntime.getAllRegisteredTabs();
    }
    error(
      FoundryAdapter.localize(
        "TIDY5E.TabSelection.UnsupportedDocumentErrorMessage",
        { documentType: this.actor.type }
      )
    );
    return [];
  }
  getDefaultTabIds(actor) {
    if (actor.type === CONSTANTS.SHEET_TYPE_CHARACTER) {
      return SettingsProvider.settings.defaultCharacterSheetTabs.get();
    } else if (actor.type === CONSTANTS.SHEET_TYPE_NPC) {
      return SettingsProvider.settings.defaultNpcSheetTabs.get();
    } else if (actor.type === CONSTANTS.SHEET_TYPE_VEHICLE) {
      return SettingsProvider.settings.defaultVehicleSheetTabs.get();
    }
    error(
      FoundryAdapter.localize(
        "TIDY5E.TabSelection.UnsupportedDocumentErrorMessage",
        { documentType: this.actor.type }
      )
    );
    return [];
  }
  createComponent(node) {
    return new TabSelection({
      target: node,
      context: /* @__PURE__ */ new Map([
        ["context", this.context],
        ["appId", this.appId],
        ["apply", this.apply.bind(this)],
        ["useDefault", this.useDefault.bind(this)],
        ["validate", this.validate.bind(this)]
      ])
    });
  }
  static get defaultOptions() {
    return {
      ...super.defaultOptions,
      height: 550,
      width: 750,
      classes: [...super.defaultOptions.classes, "tab-selection"],
      resizable: false
    };
  }
  get title() {
    return FoundryAdapter.localize("TIDY5E.TabSelection.Title", {
      documentName: this.actor.name
    });
  }
  getData() {
    const selectedTabIds = TidyFlags.selectedTabs.get(this.actor) ?? this.getDefaultTabIds(this.actor);
    let availableTabs = this.registeredTabs.filter((t2) => !selectedTabIds.includes(t2.id)).map((t2) => ({
      id: t2.id,
      label: FoundryAdapter.localize(TabManager.getTabTitle(t2))
    }));
    let selectedTabs = this.registeredTabs.filter((t2) => selectedTabIds.includes(t2.id)).map((t2) => ({
      id: t2.id,
      label: FoundryAdapter.localize(TabManager.getTabTitle(t2))
    })).sort(
      (a2, b2) => selectedTabIds.indexOf(a2.id) - selectedTabIds.indexOf(b2.id)
    );
    return {
      available: availableTabs,
      selected: selectedTabs
    };
  }
  async useDefault() {
    await TidyFlags.selectedTabs.unset(this.actor);
    this.close();
  }
  validate() {
    const context = get_store_value(this.context);
    if (context.selected.length === 0) {
      error(
        FoundryAdapter.localize(
          "TIDY5E.TabSelection.AtLeastOneRequiredErrorMessage"
        ),
        true
      );
      return false;
    }
    return true;
  }
  async save() {
    const context = get_store_value(this.context);
    await TidyFlags.selectedTabs.set(
      this.actor,
      context.selected.map((t2) => t2.id)
    );
  }
  async _updateObject() {
    await this.save();
  }
  refreshContext() {
    this.context.set(this.getData());
  }
  async apply() {
    await this.save();
  }
}
class ApplicationsManager {
  static _themeSettings;
  static _userSettings;
  /**
   * Opens the Theme Settings window as a singleton.
   * @returns the form application for theme settings.
   */
  static openThemeSettings() {
    ApplicationsManager._themeSettings ??= new ThemeSettingsFormApplication();
    const rendered = ApplicationsManager._themeSettings.render(true);
    setTimeout(() => ApplicationsManager._themeSettings.bringToTop(), 150);
    return rendered;
  }
  /**
   * Opens the Sheet Settings window as a singleton.
   * @param initialTab the initial tab to show
   * @returns the form application for sheet settings
   */
  static openUserSettings(initialTab) {
    ApplicationsManager._userSettings ??= new UserSettingsFormApplication(
      CONSTANTS.TAB_USER_SETTINGS_PLAYERS
    );
    if (initialTab) {
      ApplicationsManager._userSettings.initialTabId = initialTab;
    }
    const rendered = ApplicationsManager._userSettings.render(true);
    setTimeout(() => ApplicationsManager._userSettings.bringToTop(), 150);
    return rendered;
  }
}
function create_default_slot_3$1(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("TIDY5E.UserSettings.Menu.label") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$1(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("TIDY5E.ThemeSettings.SheetMenu.buttonLabel") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$c(ctx) {
  let buttonmenucommand;
  let current;
  buttonmenucommand = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-file-invoice",
      disabled: !/*$context*/
      ctx[1].editable,
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand.$on(
    "click",
    /*click_handler_2*/
    ctx[6]
  );
  return {
    c() {
      create_component(buttonmenucommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenucommand, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const buttonmenucommand_changes = {};
      if (dirty & /*$context*/
      2) buttonmenucommand_changes.disabled = !/*$context*/
      ctx2[1].editable;
      if (dirty & /*$$scope*/
      128) {
        buttonmenucommand_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand.$set(buttonmenucommand_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenucommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenucommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenucommand, detaching);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let t_value = (
    /*localize*/
    ctx[2]("TIDY5E.TabSelection.MenuOptionText") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$b(ctx) {
  let themeselectorbuttonmenucommand;
  let t0;
  let buttonmenudivider;
  let t1;
  let buttonmenucommand0;
  let t2;
  let buttonmenucommand1;
  let t3;
  let if_block_anchor;
  let current;
  themeselectorbuttonmenucommand = new ThemeSelectorButtonMenuCommand({});
  buttonmenudivider = new ButtonMenuDivider({});
  buttonmenucommand0 = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-cog",
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand0.$on(
    "click",
    /*click_handler*/
    ctx[4]
  );
  buttonmenucommand1 = new ButtonMenuCommand({
    props: {
      iconClass: "fas fa-palette",
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  buttonmenucommand1.$on(
    "click",
    /*click_handler_1*/
    ctx[5]
  );
  let if_block = (
    /*$context*/
    ctx[1].owner && create_if_block$c(ctx)
  );
  return {
    c() {
      create_component(themeselectorbuttonmenucommand.$$.fragment);
      t0 = space();
      create_component(buttonmenudivider.$$.fragment);
      t1 = space();
      create_component(buttonmenucommand0.$$.fragment);
      t2 = space();
      create_component(buttonmenucommand1.$$.fragment);
      t3 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(themeselectorbuttonmenucommand, target, anchor);
      insert(target, t0, anchor);
      mount_component(buttonmenudivider, target, anchor);
      insert(target, t1, anchor);
      mount_component(buttonmenucommand0, target, anchor);
      insert(target, t2, anchor);
      mount_component(buttonmenucommand1, target, anchor);
      insert(target, t3, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const buttonmenucommand0_changes = {};
      if (dirty & /*$$scope*/
      128) {
        buttonmenucommand0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand0.$set(buttonmenucommand0_changes);
      const buttonmenucommand1_changes = {};
      if (dirty & /*$$scope*/
      128) {
        buttonmenucommand1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenucommand1.$set(buttonmenucommand1_changes);
      if (
        /*$context*/
        ctx2[1].owner
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(themeselectorbuttonmenucommand.$$.fragment, local);
      transition_in(buttonmenudivider.$$.fragment, local);
      transition_in(buttonmenucommand0.$$.fragment, local);
      transition_in(buttonmenucommand1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(themeselectorbuttonmenucommand.$$.fragment, local);
      transition_out(buttonmenudivider.$$.fragment, local);
      transition_out(buttonmenucommand0.$$.fragment, local);
      transition_out(buttonmenucommand1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block_anchor);
      }
      destroy_component(themeselectorbuttonmenucommand, detaching);
      destroy_component(buttonmenudivider, detaching);
      destroy_component(buttonmenucommand0, detaching);
      destroy_component(buttonmenucommand1, detaching);
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$w(ctx) {
  let buttonmenu;
  let current;
  buttonmenu = new ButtonMenu({
    props: {
      position: "bottom",
      anchor: "right",
      ariaLabel: (
        /*localize*/
        ctx[2]("TIDY5E.SheetMenu.label")
      ),
      title: (
        /*localize*/
        ctx[2]("TIDY5E.SheetMenu.label")
      ),
      iconClass: "fas fa-ellipsis-vertical",
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(buttonmenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(buttonmenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const buttonmenu_changes = {};
      if (dirty & /*$$scope, $context, defaultSettingsTab*/
      131) {
        buttonmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      buttonmenu.$set(buttonmenu_changes);
    },
    i(local) {
      if (current) return;
      transition_in(buttonmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonmenu, detaching);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let $context;
  let { defaultSettingsTab = void 0 } = $$props;
  const localize = FoundryAdapter.localize;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  const click_handler = () => ApplicationsManager.openUserSettings(defaultSettingsTab);
  const click_handler_1 = () => ApplicationsManager.openThemeSettings();
  const click_handler_2 = () => new TabSelectionFormApplication($context.actor).render(true);
  $$self.$$set = ($$props2) => {
    if ("defaultSettingsTab" in $$props2) $$invalidate(0, defaultSettingsTab = $$props2.defaultSettingsTab);
  };
  return [
    defaultSettingsTab,
    $context,
    localize,
    context,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class SheetMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$w, safe_not_equal, { defaultSettingsTab: 0 });
  }
}
function create_else_block$8(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(
        /*text*/
        ctx[2]
      );
      attr(span, "class", "creature-type-label truncate svelte-1glyjit");
      attr(
        span,
        "title",
        /*localize*/
        ctx[5]("DND5E.CreatureType")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      4) set_data(
        t2,
        /*text*/
        ctx2[2]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$b(ctx) {
  let button;
  let t2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(
        /*text*/
        ctx[2]
      );
      attr(button, "type", "button");
      attr(button, "class", "configure-creature-type inline-transparent-button highlight-on-hover truncate svelte-1glyjit");
      attr(
        button,
        "title",
        /*localize*/
        ctx[5]("DND5E.CreatureType")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[3].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      4) set_data(
        t2,
        /*text*/
        ctx2[2]
      );
      if (dirty & /*$settingStore*/
      8 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[3].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$v(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].editable && /*$context*/
      (ctx2[0].actor.type === "npc" || /*$context*/
      ctx2[0].system.details?.race?.id)
    ) return create_if_block$b;
    return create_else_block$8;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let text2;
  let configFn;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(3, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = () => configFn($context.actor);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, text2 = coalesce($context.labels.type, localize("DND5E.CreatureType")));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, configFn = $context.actor.type === "character" ? FoundryAdapter.openCharacterActorTypeConfig : FoundryAdapter.openActorTypeConfig);
    }
  };
  return [$context, configFn, text2, $settingStore, context, localize, click_handler];
}
class InlineCreatureType extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$v, safe_not_equal, {});
  }
}
function create_if_block_4$3(ctx) {
  let div;
  let label;
  let t0_value = (
    /*localize*/
    ctx[3]("DND5E.Dimensions") + ""
  );
  let t0;
  let t1;
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      textarea = element("textarea");
      attr(label, "for", "dimensions-edit-" + /*appId*/
      ctx[2]);
      attr(textarea, "id", "dimensions-edit-" + /*appId*/
      ctx[2]);
      attr(textarea, "rows", "4");
      attr(textarea, "cols", "50");
      attr(textarea, "name", "dimensions");
      attr(
        textarea,
        "placeholder",
        /*localize*/
        ctx[3]("DND5E.Dimensions")
      );
      attr(div, "class", "form-field");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(div, t1);
      append(div, textarea);
      set_input_value(
        textarea,
        /*$context*/
        ctx[0].dimensions
      );
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1) {
        set_input_value(
          textarea,
          /*$context*/
          ctx2[0].dimensions
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$4(ctx) {
  let div0;
  let label0;
  let t0_value = (
    /*localize*/
    ctx[3]("TIDY5E.Environment") + ""
  );
  let t0;
  let t1;
  let input0;
  let t2;
  let div1;
  let label1;
  let t3_value = (
    /*localize*/
    ctx[3]("DND5E.Alignment") + ""
  );
  let t3;
  let t4;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      t3 = text(t3_value);
      t4 = space();
      input1 = element("input");
      attr(label0, "for", "environment-edit-" + /*appId*/
      ctx[2]);
      attr(input0, "id", "environment-edit-" + /*appId*/
      ctx[2]);
      attr(input0, "type", "text");
      attr(
        input0,
        "placeholder",
        /*localize*/
        ctx[3]("TIDY5E.Environment")
      );
      attr(div0, "class", "environment form-field");
      attr(label1, "for", "alignment-edit-" + /*appId*/
      ctx[2]);
      attr(input1, "id", "alignment-edit-" + /*appId*/
      ctx[2]);
      attr(input1, "type", "text");
      attr(
        input1,
        "placeholder",
        /*localize*/
        ctx[3]("DND5E.Alignment")
      );
      attr(div1, "class", "form-field");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(
        input0,
        /*$context*/
        ctx[0].environment
      );
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, label1);
      append(label1, t3);
      append(div1, t4);
      append(div1, input1);
      set_input_value(
        input1,
        /*$context*/
        ctx[0].alignment
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[7]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && input0.value !== /*$context*/
      ctx2[0].environment) {
        set_input_value(
          input0,
          /*$context*/
          ctx2[0].environment
        );
      }
      if (dirty & /*$context*/
      1 && input1.value !== /*$context*/
      ctx2[0].alignment) {
        set_input_value(
          input1,
          /*$context*/
          ctx2[0].alignment
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$a(ctx) {
  let t0;
  let div0;
  let label0;
  let t1_value = (
    /*localize*/
    ctx[3]("DND5E.Background") + ""
  );
  let t1;
  let t2;
  let t3;
  let div1;
  let label1;
  let t4_value = (
    /*localize*/
    ctx[3]("DND5E.Alignment") + ""
  );
  let t4;
  let t5;
  let input;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$context*/
    ctx[0].canEditRace && create_if_block_2$5(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].canEditBackground
    ) return create_if_block_1$6;
    return create_else_block$7;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div0 = element("div");
      label0 = element("label");
      t1 = text(t1_value);
      t2 = space();
      if_block1.c();
      t3 = space();
      div1 = element("div");
      label1 = element("label");
      t4 = text(t4_value);
      t5 = space();
      input = element("input");
      attr(label0, "for", "background-edit-" + /*appId*/
      ctx[2]);
      attr(div0, "class", "form-field");
      attr(label1, "for", "pc-alignment-edit-" + /*appId*/
      ctx[2]);
      attr(input, "id", "alignment-edit-" + /*appId*/
      ctx[2]);
      attr(input, "type", "text");
      attr(
        input,
        "placeholder",
        /*localize*/
        ctx[3]("DND5E.Alignment")
      );
      attr(div1, "class", "form-field");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div0, anchor);
      append(div0, label0);
      append(label0, t1);
      append(div0, t2);
      if_block1.m(div0, null);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      append(div1, label1);
      append(label1, t4);
      append(div1, t5);
      append(div1, input);
      set_input_value(
        input,
        /*$context*/
        ctx[0].alignment
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler_2*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].canEditRace
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$5(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div0, null);
        }
      }
      if (dirty & /*$context*/
      1 && input.value !== /*$context*/
      ctx2[0].alignment) {
        set_input_value(
          input,
          /*$context*/
          ctx2[0].alignment
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div0);
        detach(t3);
        detach(div1);
      }
      if (if_block0) if_block0.d(detaching);
      if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$5(ctx) {
  let div;
  let label;
  let t0_value = (
    /*localize*/
    ctx[3]("DND5E.Race") + ""
  );
  let t0;
  let t1;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      attr(label, "for", "race-edit-" + /*appId*/
      ctx[2]);
      attr(input, "id", "race-edit-" + /*appId*/
      ctx[2]);
      attr(input, "type", "text");
      attr(
        input,
        "placeholder",
        /*localize*/
        ctx[3]("DND5E.Race")
      );
      attr(div, "class", "form-field");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(div, t1);
      append(div, input);
      set_input_value(
        input,
        /*$context*/
        ctx[0].race
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && input.value !== /*$context*/
      ctx2[0].race) {
        set_input_value(
          input,
          /*$context*/
          ctx2[0].race
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$7(ctx) {
  let span;
  let t_value = (
    /*$context*/
    ctx[0].background + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && t_value !== (t_value = /*$context*/
      ctx2[0].background + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$6(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "id", "background-edit-" + /*appId*/
      ctx[2]);
      attr(input, "type", "text");
      attr(
        input,
        "placeholder",
        /*localize*/
        ctx[3]("DND5E.Background")
      );
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*$context*/
        ctx[0].background
      );
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler_1*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && input.value !== /*$context*/
      ctx2[0].background) {
        set_input_value(
          input,
          /*$context*/
          ctx2[0].background
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$u(ctx) {
  let section;
  let t0;
  let button;
  let i2;
  let t1;
  let t2_value = (
    /*localize*/
    ctx[3]("Save") + ""
  );
  let t2;
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].isCharacter
    ) return create_if_block$a;
    if (
      /*$context*/
      ctx2[0].isNpc
    ) return create_if_block_3$4;
    if (
      /*$context*/
      ctx2[0].isVehicle
    ) return create_if_block_4$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      section = element("section");
      if (if_block) if_block.c();
      t0 = space();
      button = element("button");
      i2 = element("i");
      t1 = space();
      t2 = text(t2_value);
      attr(i2, "class", "far fa-save");
      attr(button, "type", "submit");
      attr(section, "class", "flex-column");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (if_block) if_block.m(section, null);
      append(section, t0);
      append(section, button);
      append(button, i2);
      append(button, t1);
      append(button, t2);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block) if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(section, t0);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let appId = getContext(CONSTANTS.SVELTE_CONTEXT.APP_ID);
  const localize = FoundryAdapter.localize;
  function input_input_handler() {
    $context.race = this.value;
    context.set($context);
  }
  function input_input_handler_1() {
    $context.background = this.value;
    context.set($context);
  }
  function input_input_handler_2() {
    $context.alignment = this.value;
    context.set($context);
  }
  function input0_input_handler() {
    $context.environment = this.value;
    context.set($context);
  }
  function input1_input_handler() {
    $context.alignment = this.value;
    context.set($context);
  }
  function textarea_input_handler() {
    $context.dimensions = this.value;
    context.set($context);
  }
  return [
    $context,
    context,
    appId,
    localize,
    input_input_handler,
    input_input_handler_1,
    input_input_handler_2,
    input0_input_handler,
    input1_input_handler,
    textarea_input_handler
  ];
}
class ActorOriginSummaryConfig extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$u, safe_not_equal, {});
  }
}
class ActorOriginSummaryConfigFormApplication extends SvelteFormApplicationBase {
  context = writable(null);
  actor;
  actorHook;
  constructor(actor, ...args) {
    super(...args);
    this.actor = actor;
  }
  createComponent(node) {
    this.context.set(this.getData());
    return new ActorOriginSummaryConfig({
      target: node,
      context: /* @__PURE__ */ new Map([
        ["appId", this.appId],
        ["context", this.context]
      ])
    });
  }
  activateListeners(html) {
    this.refreshContextOnActorChanges();
    super.activateListeners(html);
  }
  refreshContextOnActorChanges() {
    if (this.actorHook !== void 0) {
      return;
    }
    this.actorHook = Hooks.on("updateActor", (actor) => {
      if (actor.id === this.actor.id) {
        this.refreshContext();
      }
    });
  }
  getData() {
    return {
      race: this.actor.system.details.race?.name ?? this.actor.system.details.race,
      background: this.actor.system.details.background?.name ?? this.actor.system.details.background,
      environment: this.actor.system.details.environment,
      alignment: this.actor.system.details.alignment,
      dimensions: this.actor.system.traits.dimensions,
      isCharacter: this.actor.type === CONSTANTS.SHEET_TYPE_CHARACTER,
      canEditBackground: !this.actor.system.details.background?.name,
      canEditRace: !this.actor.system.details.race?.name,
      isNpc: this.actor.type === CONSTANTS.SHEET_TYPE_NPC,
      isVehicle: this.actor.type === CONSTANTS.SHEET_TYPE_VEHICLE
    };
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      width: 380,
      height: "auto",
      sheetConfig: false,
      resizable: false
    });
  }
  get title() {
    return FoundryAdapter.localize("TIDY5E.OriginSummaryConfig", {
      actorName: this.actor.name
    });
  }
  refreshContext() {
    this.context.set(this.getData());
  }
  close(options) {
    Hooks.off("updateActor", this.actorHook);
    this.actorHook = void 0;
    super.close(options);
  }
  async save() {
    const context = get_store_value(this.context);
    if (!context) {
      error("Unable to save data due to an error.", true);
      console.error(
        "Unable to save Actor Origin Summary Config because the context is unexpectedly null.",
        this.actor,
        context
      );
      return;
    }
    if (context.isCharacter) {
      const update2 = {
        "system.details.alignment": context.alignment
      };
      if (context.canEditBackground) {
        update2["system.details.background"] = context.background;
      }
      if (context.canEditRace) {
        update2["system.details.race"] = context.race;
      }
      await this.actor.update(update2);
    } else if (context.isNpc) {
      await this.actor.update({
        "system.details.environment": context.environment,
        "system.details.alignment": context.alignment
      });
    } else if (context.isVehicle) {
      await this.actor.update({
        "system.traits.dimensions": context.dimensions
      });
    }
    this.close();
  }
  async _updateObject() {
    await this.save();
  }
}
function create_fragment$t(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      editable: (
        /*$context*/
        ctx[0].editable && !/*$context*/
        ctx[0].lockSensitiveFields
      ),
      spellcheck: false,
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.Name")
      ),
      value: (
        /*$context*/
        ctx[0].actor.name
      ),
      field: "name"
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput_changes.editable = /*$context*/
      ctx2[0].editable && !/*$context*/
      ctx2[0].lockSensitiveFields;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].actor.name;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class ActorName extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$t, safe_not_equal, {});
  }
}
function get_each_context$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  child_ctx[19] = i2;
  return child_ctx;
}
function create_if_block_10(ctx) {
  let actorwarnings;
  let current;
  actorwarnings = new ActorWarnings({
    props: {
      warnings: (
        /*$context*/
        ctx[0].viewableWarnings
      )
    }
  });
  return {
    c() {
      create_component(actorwarnings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actorwarnings, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actorwarnings_changes = {};
      if (dirty & /*$context*/
      1) actorwarnings_changes.warnings = /*$context*/
      ctx2[0].viewableWarnings;
      actorwarnings.$set(actorwarnings_changes);
    },
    i(local) {
      if (current) return;
      transition_in(actorwarnings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorwarnings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actorwarnings, detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let div3;
  let div0;
  let textinput;
  let t0;
  let span0;
  let t2;
  let show_if;
  let current_block_type_index;
  let if_block;
  let t3;
  let div2;
  let div1;
  let span1;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.details.xp.value",
      cssClass: "current-xp",
      value: (
        /*$context*/
        ctx[0].system.details.xp.value
      ),
      placeholder: "0",
      selectOnFocus: true,
      allowDeltaChanges: true,
      maxlength: 7,
      disabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].lockExpChanges
    }
  });
  const if_block_creators = [create_if_block_9, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*$context*/
    1) show_if = null;
    if (show_if == null) show_if = !!/*$context*/
    (ctx2[0].editable && FoundryAdapter.userIsGm());
    if (show_if) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(textinput.$$.fragment);
      t0 = space();
      span0 = element("span");
      span0.textContent = "/";
      t2 = space();
      if_block.c();
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      span1 = element("span");
      attr(span0, "class", "sep");
      attr(div0, "class", "experience flex-row no-gap");
      attr(span1, "class", "xp-bar-current svelte-ffh2t");
      set_style(
        span1,
        "width",
        /*$context*/
        ctx[0].system.details.xp.pct + "%"
      );
      attr(div1, "class", "xp-bar-total svelte-ffh2t");
      attr(div2, "class", "xp-bar");
      attr(div3, "class", "xp-tracker svelte-ffh2t");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(textinput, div0, null);
      append(div0, t0);
      append(div0, span0);
      append(div0, t2);
      if_blocks[current_block_type_index].m(div0, null);
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div1, span1);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.details.xp.value;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].lockExpChanges;
      textinput.$set(textinput_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      if (!current || dirty & /*$context*/
      1) {
        set_style(
          span1,
          "width",
          /*$context*/
          ctx2[0].system.details.xp.pct + "%"
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(textinput);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block_1$1(ctx) {
  let span;
  let t_value = (
    /*$context*/
    ctx[0].system.details.xp.max + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", "max");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*$context*/
      1 && t_value !== (t_value = /*$context*/
      ctx2[0].system.details.xp.max + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_9(ctx) {
  let textinput;
  let current;
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.details.xp.max",
      cssClass: "max-xp max",
      value: (
        /*$context*/
        ctx[0].system.details.xp.max
      ),
      placeholder: "0",
      selectOnFocus: true,
      allowDeltaChanges: true,
      maxlength: 7,
      disabled: !/*$context*/
      ctx[0].editable
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & /*$context*/
      1) textinput_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput_changes.value = /*$context*/
      ctx2[0].system.details.xp.max;
      if (dirty & /*$context*/
      1) textinput_changes.disabled = !/*$context*/
      ctx2[0].editable;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_7$1(ctx) {
  let contenteditableformfield;
  let current;
  contenteditableformfield = new ContentEditableFormField({
    props: {
      element: "span",
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: TidyFlags.playerName.prop,
      value: (
        /*playerName*/
        ctx[7]
      ),
      cssClass: "player-name",
      placeholder: (
        /*localize*/
        ctx[10]("TIDY5E.PlayerName")
      ),
      dataMaxLength: 40,
      editable: (
        /*$context*/
        ctx[0].editable && !/*$context*/
        ctx[0].lockSensitiveFields
      )
    }
  });
  return {
    c() {
      create_component(contenteditableformfield.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contenteditableformfield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const contenteditableformfield_changes = {};
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*playerName*/
      128) contenteditableformfield_changes.value = /*playerName*/
      ctx2[7];
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.editable = /*$context*/
      ctx2[0].editable && !/*$context*/
      ctx2[0].lockSensitiveFields;
      contenteditableformfield.$set(contenteditableformfield_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contenteditableformfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contenteditableformfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contenteditableformfield, detaching);
    }
  };
}
function create_if_block_4$2(ctx) {
  let span;
  let each_value_1 = ensure_array_like(
    /*classAndSubclassSummaries*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  return {
    c() {
      span = element("span");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span, "class", "flex-row extra-small-gap");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(span, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*classAndSubclassSummaries*/
      64) {
        each_value_1 = ensure_array_like(
          /*classAndSubclassSummaries*/
          ctx2[6]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(span, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_6$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "/";
      attr(span, "class", "flex-no-grow");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_5$2(ctx) {
  let span;
  let t_value = (
    /*summary*/
    ctx[17].subclass + ""
  );
  let t2;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "title", span_title_value = /*summary*/
      ctx[17].subclass);
      attr(span, "class", "flex-no-grow");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*classAndSubclassSummaries*/
      64 && t_value !== (t_value = /*summary*/
      ctx2[17].subclass + "")) set_data(t2, t_value);
      if (dirty & /*classAndSubclassSummaries*/
      64 && span_title_value !== (span_title_value = /*summary*/
      ctx2[17].subclass)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_1(ctx) {
  let t0;
  let span1;
  let span0;
  let t1_value = (
    /*summary*/
    ctx[17].class + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*summary*/
    (ctx[17].level ?? "0") + ""
  );
  let t3;
  let span0_title_value;
  let t4;
  let t5;
  let if_block0 = (
    /*i*/
    ctx[19] > 0 && create_if_block_6$1()
  );
  let if_block1 = (
    /*summary*/
    ctx[17].subclass && create_if_block_5$2(ctx)
  );
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      span1 = element("span");
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      if (if_block1) if_block1.c();
      t5 = space();
      attr(span0, "title", span0_title_value = /*summary*/
      ctx[17].class + " " + /*summary*/
      (ctx[17].level ?? "0"));
      attr(span1, "class", "flex-no-grow");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, span1, anchor);
      append(span1, span0);
      append(span0, t1);
      append(span0, t2);
      append(span0, t3);
      append(span1, t4);
      if (if_block1) if_block1.m(span1, null);
      append(span1, t5);
    },
    p(ctx2, dirty) {
      if (dirty & /*classAndSubclassSummaries*/
      64 && t1_value !== (t1_value = /*summary*/
      ctx2[17].class + "")) set_data(t1, t1_value);
      if (dirty & /*classAndSubclassSummaries*/
      64 && t3_value !== (t3_value = /*summary*/
      (ctx2[17].level ?? "0") + "")) set_data(t3, t3_value);
      if (dirty & /*classAndSubclassSummaries*/
      64 && span0_title_value !== (span0_title_value = /*summary*/
      ctx2[17].class + " " + /*summary*/
      (ctx2[17].level ?? "0"))) {
        attr(span0, "title", span0_title_value);
      }
      if (
        /*summary*/
        ctx2[17].subclass
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$2(ctx2);
          if_block1.c();
          if_block1.m(span1, t5);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span1);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d();
    }
  };
}
function create_else_block$6(ctx) {
  let span;
  let t_value = (
    /*currentSize*/
    ctx[2].text + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(
        span,
        "title",
        /*localize*/
        ctx[10]("DND5E.Size")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*currentSize*/
      4 && t_value !== (t_value = /*currentSize*/
      ctx2[2].text + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3$3(ctx) {
  let inlinetextdropdownlist;
  let current;
  inlinetextdropdownlist = new InlineTextDropdownList({
    props: {
      options: (
        /*sizes*/
        ctx[3]
      ),
      selected: (
        /*currentSize*/
        ctx[2]
      ),
      title: (
        /*localize*/
        ctx[10]("DND5E.Size")
      )
    }
  });
  inlinetextdropdownlist.$on(
    "optionClicked",
    /*optionClicked_handler*/
    ctx[11]
  );
  return {
    c() {
      create_component(inlinetextdropdownlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinetextdropdownlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinetextdropdownlist_changes = {};
      if (dirty & /*sizes*/
      8) inlinetextdropdownlist_changes.options = /*sizes*/
      ctx2[3];
      if (dirty & /*currentSize*/
      4) inlinetextdropdownlist_changes.selected = /*currentSize*/
      ctx2[2];
      inlinetextdropdownlist.$set(inlinetextdropdownlist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinetextdropdownlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetextdropdownlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetextdropdownlist, detaching);
    }
  };
}
function create_each_block$3(ctx) {
  let span0;
  let t1;
  let span1;
  let t2_value = (
    /*entry*/
    ctx[14] + ""
  );
  let t2;
  let span1_title_value;
  return {
    c() {
      span0 = element("span");
      span0.textContent = "";
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      attr(span1, "title", span1_title_value = /*entry*/
      ctx[14]);
      attr(span1, "class", "truncate");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      insert(target, t1, anchor);
      insert(target, span1, anchor);
      append(span1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*characterSummaryEntries*/
      32 && t2_value !== (t2_value = /*entry*/
      ctx2[14] + "")) set_data(t2, t2_value);
      if (dirty & /*characterSummaryEntries*/
      32 && span1_title_value !== (span1_title_value = /*entry*/
      ctx2[14])) {
        attr(span1, "title", span1_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t1);
        detach(span1);
      }
    }
  };
}
function create_if_block_2$4(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[10]("TIDY5E.OriginSummaryConfig")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[8].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[12]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      256 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[8].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$5(ctx) {
  let specialsaves;
  let current;
  specialsaves = new SpecialSaves({});
  return {
    c() {
      create_component(specialsaves.$$.fragment);
    },
    m(target, anchor) {
      mount_component(specialsaves, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(specialsaves.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(specialsaves.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(specialsaves, detaching);
    }
  };
}
function create_if_block$9(ctx) {
  let alloweditlock;
  let current;
  alloweditlock = new AllowEditLock({
    props: {
      hint: (
        /*$settingStore*/
        ctx[8].permanentlyUnlockCharacterSheetForGm && FoundryAdapter.userIsGm() ? (
          /*localize*/
          ctx[10]("TIDY5E.Settings.PermanentlyUnlockCharacterSheetForGM.title")
        ) : null
      )
    }
  });
  return {
    c() {
      create_component(alloweditlock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(alloweditlock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const alloweditlock_changes = {};
      if (dirty & /*$settingStore*/
      256) alloweditlock_changes.hint = /*$settingStore*/
      ctx2[8].permanentlyUnlockCharacterSheetForGm && FoundryAdapter.userIsGm() ? (
        /*localize*/
        ctx2[10]("TIDY5E.Settings.PermanentlyUnlockCharacterSheetForGM.title")
      ) : null;
      alloweditlock.$set(alloweditlock_changes);
    },
    i(local) {
      if (current) return;
      transition_in(alloweditlock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(alloweditlock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(alloweditlock, detaching);
    }
  };
}
function create_tab_end_slot$2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].editable && create_if_block$9(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].editable
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$s(ctx) {
  let iteminfocard;
  let t0;
  let t1;
  let header;
  let div0;
  let characterprofile;
  let t2;
  let div5;
  let div3;
  let div1;
  let actorname;
  let t3;
  let div2;
  let t4;
  let h2;
  let t5_value = (
    /*localize*/
    ctx[10]("DND5E.AbbreviationLevel") + ""
  );
  let t5;
  let t6;
  let t7_value = (
    /*$context*/
    ctx[0].system.details.level + ""
  );
  let t7;
  let t8;
  let sheetmenu;
  let t9;
  let section0;
  let t10;
  let t11;
  let section1;
  let span1;
  let current_block_type_index;
  let if_block4;
  let t12;
  let span0;
  let t14;
  let inlinecreaturetype;
  let t15;
  let t16;
  let span2;
  let b2;
  let t17_value = (
    /*localize*/
    ctx[10]("DND5E.Proficiency") + ""
  );
  let t17;
  let t18;
  let t19_value = (
    /*$context*/
    ctx[0].labels.proficiency + ""
  );
  let t19;
  let t20;
  let t21;
  let div4;
  let actormovement;
  let t22;
  let t23;
  let horizontallineseparator;
  let t24;
  let actorheaderstats;
  let t25;
  let tabs;
  let updating_selectedTabId;
  let t26;
  let section2;
  let tabcontents;
  let current;
  iteminfocard = new ItemInfoCard({});
  let if_block0 = (
    /*$context*/
    ctx[0].viewableWarnings.length && create_if_block_10(ctx)
  );
  characterprofile = new CharacterProfile({});
  actorname = new ActorName({});
  let if_block1 = !/*$context*/
  ctx[0].disableExperience && create_if_block_8(ctx);
  sheetmenu = new SheetMenu({
    props: {
      defaultSettingsTab: CONSTANTS.TAB_USER_SETTINGS_PLAYERS
    }
  });
  let if_block2 = (
    /*$settingStore*/
    ctx[8].showPlayerName && create_if_block_7$1(ctx)
  );
  let if_block3 = (
    /*$context*/
    ctx[0].owner && /*$settingStore*/
    ctx[8].showClassList && create_if_block_4$2(ctx)
  );
  const if_block_creators = [create_if_block_3$3, create_else_block$6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].editable
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  inlinecreaturetype = new InlineCreatureType({});
  let each_value = ensure_array_like(
    /*characterSummaryEntries*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$3(get_each_context$3(ctx, each_value, i2));
  }
  let if_block5 = (
    /*$context*/
    ctx[0].unlocked && create_if_block_2$4(ctx)
  );
  actormovement = new ActorMovement({});
  let if_block6 = (
    /*$context*/
    ctx[0].hasSpecialSaves && create_if_block_1$5()
  );
  horizontallineseparator = new HorizontalLineSeparator({ props: { borderColor: "light" } });
  actorheaderstats = new ActorHeaderStats({
    props: {
      abilities: (
        /*abilities*/
        ctx[4]
      ),
      ac: (
        /*$context*/
        ctx[0].system.attributes.ac
      ),
      init: (
        /*$context*/
        ctx[0].system.attributes.init
      )
    }
  });
  function tabs_selectedTabId_binding(value) {
    ctx[13](value);
  }
  let tabs_props = {
    tabs: (
      /*$context*/
      ctx[0].tabs
    ),
    $$slots: { "tab-end": [create_tab_end_slot$2] },
    $$scope: { ctx }
  };
  if (
    /*selectedTabId*/
    ctx[1] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[1];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[0].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(iteminfocard.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      header = element("header");
      div0 = element("div");
      create_component(characterprofile.$$.fragment);
      t2 = space();
      div5 = element("div");
      div3 = element("div");
      div1 = element("div");
      create_component(actorname.$$.fragment);
      t3 = space();
      div2 = element("div");
      if (if_block1) if_block1.c();
      t4 = space();
      h2 = element("h2");
      t5 = text(t5_value);
      t6 = space();
      t7 = text(t7_value);
      t8 = space();
      create_component(sheetmenu.$$.fragment);
      t9 = space();
      section0 = element("section");
      if (if_block2) if_block2.c();
      t10 = space();
      if (if_block3) if_block3.c();
      t11 = space();
      section1 = element("section");
      span1 = element("span");
      if_block4.c();
      t12 = space();
      span0 = element("span");
      span0.textContent = "";
      t14 = space();
      create_component(inlinecreaturetype.$$.fragment);
      t15 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t16 = space();
      span2 = element("span");
      b2 = element("b");
      t17 = text(t17_value);
      t18 = text(": ");
      t19 = text(t19_value);
      t20 = space();
      if (if_block5) if_block5.c();
      t21 = space();
      div4 = element("div");
      create_component(actormovement.$$.fragment);
      t22 = space();
      if (if_block6) if_block6.c();
      t23 = space();
      create_component(horizontallineseparator.$$.fragment);
      t24 = space();
      create_component(actorheaderstats.$$.fragment);
      t25 = space();
      create_component(tabs.$$.fragment);
      t26 = space();
      section2 = element("section");
      create_component(tabcontents.$$.fragment);
      attr(div0, "class", "flex-0");
      attr(div1, "class", "actor-name");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(h2, "class", "level svelte-ffh2t");
      attr(div2, "class", "flex-row extra-small-gap align-items-stretch");
      attr(div3, "class", "flex-row justify-content-space-between align-items-center small-gap");
      attr(div3, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(section0, "class", "class-list svelte-ffh2t");
      attr(span1, "class", "origin-points svelte-ffh2t");
      attr(span2, "class", "flex-row align-items-center extra-small-gap");
      attr(section1, "class", "origin-summary svelte-ffh2t");
      attr(div4, "role", "presentation");
      attr(div4, "class", "flex-row extra-small-gap justify-content-space-between");
      attr(div5, "class", "flex-grow-1");
      attr(header, "class", "tidy5e-sheet-header flex-row svelte-ffh2t");
      attr(section2, "class", "tidy-sheet-body");
    },
    m(target, anchor) {
      mount_component(iteminfocard, target, anchor);
      insert(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, header, anchor);
      append(header, div0);
      mount_component(characterprofile, div0, null);
      append(header, t2);
      append(header, div5);
      append(div5, div3);
      append(div3, div1);
      mount_component(actorname, div1, null);
      append(div3, t3);
      append(div3, div2);
      if (if_block1) if_block1.m(div2, null);
      append(div2, t4);
      append(div2, h2);
      append(h2, t5);
      append(h2, t6);
      append(h2, t7);
      append(div2, t8);
      mount_component(sheetmenu, div2, null);
      append(div5, t9);
      append(div5, section0);
      if (if_block2) if_block2.m(section0, null);
      append(section0, t10);
      if (if_block3) if_block3.m(section0, null);
      append(div5, t11);
      append(div5, section1);
      append(section1, span1);
      if_blocks[current_block_type_index].m(span1, null);
      append(span1, t12);
      append(span1, span0);
      append(span1, t14);
      mount_component(inlinecreaturetype, span1, null);
      append(span1, t15);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(span1, null);
        }
      }
      append(section1, t16);
      append(section1, span2);
      append(span2, b2);
      append(b2, t17);
      append(b2, t18);
      append(b2, t19);
      append(span2, t20);
      if (if_block5) if_block5.m(span2, null);
      append(div5, t21);
      append(div5, div4);
      mount_component(actormovement, div4, null);
      append(div4, t22);
      if (if_block6) if_block6.m(div4, null);
      append(div5, t23);
      mount_component(horizontallineseparator, div5, null);
      append(div5, t24);
      mount_component(actorheaderstats, div5, null);
      insert(target, t25, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t26, anchor);
      insert(target, section2, anchor);
      mount_component(tabcontents, section2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$context*/
        ctx2[0].viewableWarnings.length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*$context*/
      ctx2[0].disableExperience) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*$context*/
      1) && t7_value !== (t7_value = /*$context*/
      ctx2[0].system.details.level + "")) set_data(t7, t7_value);
      if (
        /*$settingStore*/
        ctx2[8].showPlayerName
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$settingStore*/
          256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_7$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(section0, t10);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].owner && /*$settingStore*/
        ctx2[8].showClassList
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_4$2(ctx2);
          if_block3.c();
          if_block3.m(section0, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block4 = if_blocks[current_block_type_index];
        if (!if_block4) {
          if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block4.c();
        } else {
          if_block4.p(ctx2, dirty);
        }
        transition_in(if_block4, 1);
        if_block4.m(span1, t12);
      }
      if (dirty & /*characterSummaryEntries*/
      32) {
        each_value = ensure_array_like(
          /*characterSummaryEntries*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(span1, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if ((!current || dirty & /*$context*/
      1) && t19_value !== (t19_value = /*$context*/
      ctx2[0].labels.proficiency + "")) set_data(t19, t19_value);
      if (
        /*$context*/
        ctx2[0].unlocked
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_2$4(ctx2);
          if_block5.c();
          if_block5.m(span2, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (
        /*$context*/
        ctx2[0].hasSpecialSaves
      ) {
        if (if_block6) {
          if (dirty & /*$context*/
          1) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_1$5();
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div4, null);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      const actorheaderstats_changes = {};
      if (dirty & /*abilities*/
      16) actorheaderstats_changes.abilities = /*abilities*/
      ctx2[4];
      if (dirty & /*$context*/
      1) actorheaderstats_changes.ac = /*$context*/
      ctx2[0].system.attributes.ac;
      if (dirty & /*$context*/
      1) actorheaderstats_changes.init = /*$context*/
      ctx2[0].system.attributes.init;
      actorheaderstats.$set(actorheaderstats_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      1) tabs_changes.tabs = /*$context*/
      ctx2[0].tabs;
      if (dirty & /*$$scope, $settingStore, $context*/
      1048833) {
        tabs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      2) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[1];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      1) tabcontents_changes.tabs = /*$context*/
      ctx2[0].tabs;
      if (dirty & /*selectedTabId*/
      2) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[1];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(iteminfocard.$$.fragment, local);
      transition_in(if_block0);
      transition_in(characterprofile.$$.fragment, local);
      transition_in(actorname.$$.fragment, local);
      transition_in(if_block1);
      transition_in(sheetmenu.$$.fragment, local);
      transition_in(if_block2);
      transition_in(if_block4);
      transition_in(inlinecreaturetype.$$.fragment, local);
      transition_in(actormovement.$$.fragment, local);
      transition_in(if_block6);
      transition_in(horizontallineseparator.$$.fragment, local);
      transition_in(actorheaderstats.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iteminfocard.$$.fragment, local);
      transition_out(if_block0);
      transition_out(characterprofile.$$.fragment, local);
      transition_out(actorname.$$.fragment, local);
      transition_out(if_block1);
      transition_out(sheetmenu.$$.fragment, local);
      transition_out(if_block2);
      transition_out(if_block4);
      transition_out(inlinecreaturetype.$$.fragment, local);
      transition_out(actormovement.$$.fragment, local);
      transition_out(if_block6);
      transition_out(horizontallineseparator.$$.fragment, local);
      transition_out(actorheaderstats.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(header);
        detach(t25);
        detach(t26);
        detach(section2);
      }
      destroy_component(iteminfocard, detaching);
      if (if_block0) if_block0.d(detaching);
      destroy_component(characterprofile);
      destroy_component(actorname);
      if (if_block1) if_block1.d();
      destroy_component(sheetmenu);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      if_blocks[current_block_type_index].d();
      destroy_component(inlinecreaturetype);
      destroy_each(each_blocks, detaching);
      if (if_block5) if_block5.d();
      destroy_component(actormovement);
      if (if_block6) if_block6.d();
      destroy_component(horizontallineseparator);
      destroy_component(actorheaderstats);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let playerName;
  let classAndSubclassSummaries;
  let characterSummaryEntries;
  let abilities;
  let sizes;
  let currentSize;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(8, $settingStore = $$value));
  let selectedTabId;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const optionClicked_handler = (event) => $context.actor.update({ "system.traits.size": event.detail.value });
  const click_handler = () => new ActorOriginSummaryConfigFormApplication($context.actor).render(true);
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(1, selectedTabId);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(7, playerName = TidyFlags.playerName.get($context.actor) ?? "");
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(6, classAndSubclassSummaries = Array.from(FoundryAdapter.getClassAndSubclassSummaries($context.actor).values()));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(5, characterSummaryEntries = FoundryAdapter.getActorCharacterSummaryEntries($context));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(4, abilities = Object.entries($context.abilities));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(3, sizes = Object.entries($context.config.actorSizes).map(([abbreviation, size]) => ({ value: abbreviation, text: size.label })));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, currentSize = {
        value: $context.system.traits.size,
        text: $context.config.actorSizes[$context.system.traits.size]?.label
      });
    }
  };
  return [
    $context,
    selectedTabId,
    currentSize,
    sizes,
    abilities,
    characterSummaryEntries,
    classAndSubclassSummaries,
    playerName,
    $settingStore,
    context,
    localize,
    optionClicked_handler,
    click_handler,
    tabs_selectedTabId_binding
  ];
}
class CharacterSheetFull extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$s, safe_not_equal, {});
  }
}
function create_fragment$r(ctx) {
  let header;
  let div1;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let h1;
  let t1_value = (
    /*$context*/
    ctx[1].actor.name + ""
  );
  let t1;
  return {
    c() {
      header = element("header");
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      h1 = element("h1");
      t1 = text(t1_value);
      if (!src_url_equal(img.src, img_src_value = /*$context*/
      ctx[1].actor.img)) attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*$context*/
      ctx[1].actor.name);
      attr(img, "data-edit", "img");
      attr(img, "class", "svelte-bozrbz");
      attr(div0, "class", "portrait svelte-bozrbz");
      toggle_class(
        div0,
        "rounded",
        /*rounded*/
        ctx[0]
      );
      attr(div1, "class", "profile svelte-bozrbz");
      attr(header, "class", "svelte-bozrbz");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      append(header, div1);
      append(div1, div0);
      append(div0, img);
      append(header, t0);
      append(header, h1);
      append(h1, t1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      2 && !src_url_equal(img.src, img_src_value = /*$context*/
      ctx2[1].actor.img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*$context*/
      2 && img_alt_value !== (img_alt_value = /*$context*/
      ctx2[1].actor.name)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*rounded*/
      1) {
        toggle_class(
          div0,
          "rounded",
          /*rounded*/
          ctx2[0]
        );
      }
      if (dirty & /*$context*/
      2 && t1_value !== (t1_value = /*$context*/
      ctx2[1].actor.name + "")) set_data(t1, t1_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(header);
      }
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let $context;
  let { rounded } = $$props;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  $$self.$$set = ($$props2) => {
    if ("rounded" in $$props2) $$invalidate(0, rounded = $$props2.rounded);
  };
  return [rounded, $context, context];
}
class LimitedHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$r, safe_not_equal, { rounded: 0 });
  }
}
function create_default_slot$a(ctx) {
  let article0;
  let div0;
  let t1;
  let sheeteditor0;
  let t2;
  let article1;
  let div1;
  let t6;
  let sheeteditor1;
  let current;
  let mounted;
  let dispose;
  sheeteditor0 = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].system.details.appearance
      ),
      target: "system.details.appearance",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  sheeteditor1 = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].biographyHTML
      ),
      target: "system.details.biography.value",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article0 = element("article");
      div0 = element("div");
      div0.textContent = `${/*localize*/
      ctx[2]("DND5E.Appearance")}`;
      t1 = space();
      create_component(sheeteditor0.$$.fragment);
      t2 = space();
      article1 = element("article");
      div1 = element("div");
      div1.textContent = `${/*localize*/
      ctx[2]("DND5E.Background")}/${/*localize*/
      ctx[2]("DND5E.Biography")}`;
      t6 = space();
      create_component(sheeteditor1.$$.fragment);
      attr(div0, "class", "section-titles biopage");
      attr(article0, "class", "appearance-notes svelte-1duz0dy");
      attr(div1, "class", "section-titles");
      attr(article1, "class", "biography-notes svelte-1duz0dy");
    },
    m(target, anchor) {
      insert(target, article0, anchor);
      append(article0, div0);
      append(article0, t1);
      mount_component(sheeteditor0, article0, null);
      insert(target, t2, anchor);
      insert(target, article1, anchor);
      append(article1, div1);
      append(article1, t6);
      mount_component(sheeteditor1, article1, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(
            /*$context*/
            ctx[0].activateEditors(article0)
          ),
          action_destroyer(
            /*$context*/
            ctx[0].activateEditors(article1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor0_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor0_changes.content = /*$context*/
      ctx2[0].system.details.appearance;
      if (dirty & /*$context*/
      1) sheeteditor0_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor0.$set(sheeteditor0_changes);
      const sheeteditor1_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor1_changes.content = /*$context*/
      ctx2[0].biographyHTML;
      if (dirty & /*$context*/
      1) sheeteditor1_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor1.$set(sheeteditor1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor0.$$.fragment, local);
      transition_in(sheeteditor1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor0.$$.fragment, local);
      transition_out(sheeteditor1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article0);
        detach(t2);
        detach(article1);
      }
      destroy_component(sheeteditor0);
      destroy_component(sheeteditor1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$q(ctx) {
  let div1;
  let limitedheader;
  let t2;
  let section;
  let div0;
  let rerenderafterformsubmission;
  let current;
  limitedheader = new LimitedHeader({
    props: {
      rounded: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle
      )
    }
  });
  rerenderafterformsubmission = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.biography.value
      ),
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(limitedheader.$$.fragment);
      t2 = space();
      section = element("section");
      div0 = element("div");
      create_component(rerenderafterformsubmission.$$.fragment);
      attr(div0, "class", "note-entries svelte-1duz0dy");
      attr(section, "class", "tidy-sheet-body svelte-1duz0dy");
      attr(div1, "class", "limited-character svelte-1duz0dy");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(limitedheader, div1, null);
      append(div1, t2);
      append(div1, section);
      append(section, div0);
      mount_component(rerenderafterformsubmission, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const limitedheader_changes = {};
      if (dirty & /*$context*/
      1) limitedheader_changes.rounded = /*$context*/
      ctx2[0].useRoundedPortraitStyle;
      limitedheader.$set(limitedheader_changes);
      const rerenderafterformsubmission_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.biography.value;
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission.$set(rerenderafterformsubmission_changes);
    },
    i(local) {
      if (current) return;
      transition_in(limitedheader.$$.fragment, local);
      transition_in(rerenderafterformsubmission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(limitedheader.$$.fragment, local);
      transition_out(rerenderafterformsubmission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(limitedheader);
      destroy_component(rerenderafterformsubmission);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class CharacterSheetLimited extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$q, safe_not_equal, {});
  }
}
function create_else_block$5(ctx) {
  let charactersheetfull;
  let current;
  charactersheetfull = new CharacterSheetFull({});
  return {
    c() {
      create_component(charactersheetfull.$$.fragment);
    },
    m(target, anchor) {
      mount_component(charactersheetfull, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(charactersheetfull.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(charactersheetfull.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(charactersheetfull, detaching);
    }
  };
}
function create_if_block$8(ctx) {
  let charactersheetlimited;
  let current;
  charactersheetlimited = new CharacterSheetLimited({});
  return {
    c() {
      create_component(charactersheetlimited.$$.fragment);
    },
    m(target, anchor) {
      mount_component(charactersheetlimited, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(charactersheetlimited.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(charactersheetlimited.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(charactersheetlimited, detaching);
    }
  };
}
function create_fragment$p(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$8, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].showLimitedSheet
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  return [$context, context];
}
class CharacterSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$p, safe_not_equal, {});
  }
}
function initTidy5eContextMenu(sheet, html, contextMenuSelector = "[data-context-menu]") {
  FoundryAdapter.createContextMenu(html, contextMenuSelector, [], {
    onOpen: onItemContext.bind(sheet)
  });
}
function onItemContext(element2) {
  const contextMenuType = element2.getAttribute("data-context-menu");
  const app = this;
  if (contextMenuType === CONSTANTS.CONTEXT_MENU_TYPE_EFFECTS) {
    const effectId = element2.getAttribute("data-effect-id") ?? "";
    const parentId = element2.getAttribute("data-parent-id") ?? "";
    const effect = FoundryAdapter.getEffect({
      document: app.document,
      effectId,
      parentId
    });
    if (!effect) {
      return;
    }
    ui.context.menuItems = getActiveEffectContextOptions(effect, app);
    TidyHooks.dnd5eGetActiveEffectContextOptions(effect, ui.context.menuItems);
  } else if (contextMenuType === CONSTANTS.CONTEXT_MENU_TYPE_ITEMS) {
    const uuid = element2.getAttribute("data-context-menu-document-uuid");
    const item = fromUuidSync(uuid);
    if (!item) return;
    ui.context.menuItems = getItemContextOptions(item);
    TidyHooks.dnd5eGetItemContextOptions(item, ui.context.menuItems);
  } else {
    warn(
      `Unable to show context menu. The menu type ${contextMenuType} is not supported. Put a [data-context-menu] attribute on the target entity and implement the handler where this warning appears.`
    );
  }
}
function getActiveEffectContextOptions(effect, app) {
  const effectParent = effect.parent;
  const actor = effectParent.actor ?? effectParent;
  if (!effectParent?.isOwner || !SettingsProvider.settings.useContextMenu.get()) {
    return [];
  }
  if (actor.type === CONSTANTS.SHEET_TYPE_CHARACTER && !FoundryAdapter.allowCharacterEffectsManagement(actor)) {
    return [];
  }
  const isConcentrationEffect = FoundryAdapter.isConcentrationEffect(
    effect,
    app
  );
  const isFav = FoundryAdapter.isEffectFavorited(effect, actor);
  const favoriteIcon = "fa-bookmark";
  let tidy5eKgarContextOptions = [
    {
      name: "DND5E.ContextMenuActionEdit",
      icon: "<i class='fas fas fa-pencil-alt fa-fw'></i>",
      callback: () => effect.sheet.render(true)
    },
    {
      name: "DND5E.ContextMenuActionDuplicate",
      icon: "<i class='fas fa-copy fa-fw'></i>",
      callback: () => effect.clone(
        {
          name: FoundryAdapter.localize("DOCUMENT.CopyOf", {
            name: effect.name
          })
        },
        { save: true }
      ),
      condition: () => canEditEffect(effect)
    },
    {
      name: "DND5E.ContextMenuActionDelete",
      icon: `<i class="fas fa-trash fa-fw t5e-warning-color"></i>`,
      callback: () => effect.deleteDialog(),
      condition: () => canEditEffect(effect) && !isConcentrationEffect
    },
    {
      name: effect.disabled ? "DND5E.ContextMenuActionEnable" : "DND5E.ContextMenuActionDisable",
      icon: effect.disabled ? "<i class='fas fa-check fa-fw'></i>" : "<i class='fas fa-times fa-fw'></i>",
      callback: () => effect.update({ disabled: !effect.disabled }),
      condition: () => effect.isOwner && !isConcentrationEffect,
      group: "state"
    },
    {
      name: "DND5E.ConcentrationBreak",
      icon: '<dnd5e-icon src="systems/dnd5e/icons/svg/break-concentration.svg"></dnd5e-icon>',
      condition: () => isConcentrationEffect,
      callback: () => app.document.endConcentration(effect),
      group: "state"
    },
    {
      name: isFav ? "TIDY5E.RemoveFavorite" : "TIDY5E.AddFavorite",
      icon: isFav ? `<i class='fas ${favoriteIcon} fa-fw' style='color: var(--t5e-warning-accent-color)'></i>` : `<i class='fas ${favoriteIcon} fa-fw inactive'></i>`,
      condition: () => "favorites" in actor.system,
      callback: () => {
        if (!effect) {
          warn(`tidy5e-context-menu | Effect Not Found.`);
          return;
        }
        FoundryAdapter.toggleFavoriteEffect(effect);
      },
      group: "state"
    }
  ];
  return tidy5eKgarContextOptions;
}
function canEditEffect(effect) {
  const actor = effect.actor ? effect.actor : effect.parent;
  return FoundryAdapter.isActorSheetUnlocked(actor);
}
function getItemContextOptions(item) {
  if (!item?.isOwner || !SettingsProvider.settings.useContextMenu.get()) {
    return [];
  }
  const itemParent = item.actor ? item.actor : item.parent;
  const itemParentIsActor = itemParent?.documentName === CONSTANTS.DOCUMENT_NAME_ACTOR;
  const isUnlocked = !itemParentIsActor || FoundryAdapter.isActorSheetUnlocked(itemParent);
  let options = [];
  let isActive = false;
  if (item.type === "spell") {
    const prep = item.system.preparation || {};
    const isAlways = prep.mode === CONSTANTS.SPELL_PREPARATION_MODE_ALWAYS;
    const isPrepared = !!prep.prepared;
    isActive = isPrepared;
    if (isAlways) CONFIG.DND5E.spellPreparationModes.always.label;
    else if (isPrepared)
      CONFIG.DND5E.spellPreparationModes.prepared.label;
    else FoundryAdapter.localize("DND5E.SpellUnprepared");
    item.system.level >= 1;
  } else {
    isActive = !!item.system.equipped;
    FoundryAdapter.localize(
      isActive ? "DND5E.Equipped" : "DND5E.Unequipped"
    );
    "equipped" in item.system;
    item.system.level >= 1;
  }
  if (!!item.system.attunement && !FoundryAdapter.concealDetails(item)) {
    options.push({
      name: item.system.attuned ? "TIDY5E.ContextMenuActionUnattune" : "TIDY5E.ContextMenuActionAttune",
      icon: item.system.attuned ? "<i class='fas fa-sun fa-fw' style='color: var(--t5e-warning-accent-color);'></i>" : "<i class='fas fa-sun fa-fw'></i>",
      callback: () => item.update({
        "system.attuned": !item.system.attuned
      })
    });
  }
  if (item.system.recharge?.value) {
    options.push({
      name: item.system.recharge.charged ? "DND5E.ContextMenuActionExpendCharge" : "DND5E.ContextMenuActionCharge",
      icon: '<i class="fa-solid fa-bolt"></i>',
      callback: () => item.update({
        "system.recharge.charged": !item.system.recharge?.charged
      }),
      condition: () => item.isOwner,
      group: "state"
    });
  }
  if ("equipped" in item.system) {
    const isEquipped = item.system.equipped;
    options.push({
      name: isEquipped ? "TIDY5E.ContextMenuActionUnequip" : "TIDY5E.ContextMenuActionEquip",
      icon: isEquipped ? "<i class='fas fa-user-alt fa-fw' style='color: var(--t5e-warning-accent-color);'></i> " : "<i class='fas fa-user-alt fa-fw'></i> ",
      callback: () => item.update({ "system.equipped": !isEquipped })
    });
  }
  if ("preparation" in item.system) {
    if (FoundryAdapter.canPrepareSpell(item)) {
      const isPrepared = item.system?.preparation?.prepared === true;
      options.push({
        name: isActive ? "TIDY5E.ContextMenuActionUnprepare" : "TIDY5E.ContextMenuActionPrepare",
        icon: isActive ? "<i class='fas fa-book fa-fw'></i>" : "<i class='fas fa-book fa-fw'></i>",
        callback: () => item.update({ "system.preparation.prepared": !isPrepared })
      });
    }
  }
  if (item.system.identified === false && FoundryAdapter.canIdentify(item)) {
    options.push({
      name: "DND5E.Identify",
      icon: "<i class='fas fa-magnifying-glass fa-fw'></i>",
      callback: () => item.update({ "system.identified": true })
    });
  }
  const isCharacter = itemParentIsActor && itemParent.type === CONSTANTS.SHEET_TYPE_CHARACTER;
  if (isCharacter) {
    let isFav = FoundryAdapter.isItemFavorited(item);
    const favoriteIcon = "fa-bookmark";
    options.push({
      name: isFav ? "TIDY5E.RemoveFavorite" : "TIDY5E.AddFavorite",
      icon: isFav ? `<i class='fas ${favoriteIcon} fa-fw' style='color: var(--t5e-warning-accent-color)'></i>` : `<i class='fas ${favoriteIcon} fa-fw inactive'></i>`,
      callback: () => {
        if (!item) {
          warn(`tidy5e-context-menu | Item Not Found`);
          return;
        }
        FoundryAdapter.toggleFavoriteItem(item);
      }
    });
  }
  if (item.type === "spell") {
    options.push({
      name: "TIDY5E.ContextMenuActionEdit",
      icon: "<i class='fas fa-pencil-alt fa-fw'></i>",
      callback: () => item.sheet.render(true)
    });
    if (isUnlocked) {
      options.push({
        name: "DND5E.ContextMenuActionDuplicate",
        icon: "<i class='fas fa-copy fa-fw'></i>",
        condition: () => !["race", "background", "class", "subclass"].includes(item.type),
        callback: () => item.clone(
          {
            name: FoundryAdapter.localize("DOCUMENT.CopyOf", {
              name: item.name
            })
          },
          { save: true }
        )
      });
      options.push({
        name: "TIDY5E.ContextMenuActionDelete",
        icon: "<i class='fas fa-trash fa-fw' style='color: var(--t5e-warning-accent-color);'></i>",
        callback: () => FoundryAdapter.onActorItemDelete(itemParent, item)
      });
    }
  } else {
    options.push({
      name: "DND5E.ContextMenuActionEdit",
      icon: "<i class='fas fa-pencil-alt fa-fw'></i>",
      callback: () => item.sheet.render(true)
    });
    if (isUnlocked) {
      options.push({
        name: "DND5E.ContextMenuActionDuplicate",
        icon: "<i class='fas fa-copy fa-fw'></i>",
        condition: () => !["race", "background", "class", "subclass"].includes(item.type),
        callback: () => item.clone(
          {
            name: FoundryAdapter.localize("DOCUMENT.CopyOf", {
              name: item.name
            })
          },
          { save: true }
        )
      });
      options.push({
        name: "DND5E.ContextMenuActionDelete",
        icon: "<i class='fas fa-trash fa-fw' style='color: var(--t5e-warning-accent-color);'></i>",
        callback: () => {
          return itemParent ? FoundryAdapter.onActorItemDelete(itemParent, item) : item.deleteDialog();
        }
      });
    }
  }
  if (itemParentIsActor && actorUsesActionFeature(itemParent)) {
    const active2 = isItemInActionList(item);
    options.push({
      name: active2 ? "TIDY5E.Actions.SetOverrideFalse" : "TIDY5E.Actions.SetOverrideTrue",
      icon: active2 ? '<i class="fas fa-fist-raised" style="color: var(--t5e-warning-accent-color)"></i>' : '<i class="fas fa-fist-raised"></i>',
      callback: () => {
        TidyFlags.actionFilterOverride.set(item, !isItemInActionList(item));
      }
    });
    const overridden = TidyFlags.actionFilterOverride.get(item) !== void 0;
    if (overridden) {
      options.push({
        name: "TIDY5E.Actions.ResetActionDefault",
        icon: '<i class="fas fa-fist-raised" style="color: var(--t5e-warning-accent-color)"></i>',
        callback: () => {
          TidyFlags.actionFilterOverride.unset(item);
        }
      });
    }
  }
  return options;
}
function applyTitleToWindow(title, element2) {
  if (!element2) {
    return;
  }
  let windowTitle = element2.querySelector(".window-title");
  if (windowTitle?.hasChildNodes()) {
    windowTitle = windowTitle.childNodes[0];
  }
  if (!windowTitle) {
    return;
  }
  if (windowTitle.textContent !== title) {
    windowTitle.textContent = title;
  }
}
function applyThemeDataAttributeToWindow(themeId, element2) {
  if (!element2) {
    return;
  }
  const themes = getThemes();
  const theme = themes[themeId];
  if (theme) {
    debug(`Applying theme type ${theme.type} to window`);
    element2.setAttribute("data-tidy-theme-type", theme.type);
  }
}
function applySheetAttributesToWindow(documentName, type, themeId, element2) {
  element2?.setAttribute("data-sheet-module", "tidy5e-sheet");
  element2?.setAttribute("data-document-name", documentName);
  element2?.setAttribute("data-document-type", type);
  applyThemeDataAttributeToWindow(themeId, element2);
}
async function maintainCustomContentInputFocus(app, asyncRender) {
  let focus = app.element.find(":focus");
  focus = focus.length ? focus[0] : null;
  await asyncRender();
  if (focus && focus.name) {
    const input = app.form?.[focus.name];
    if (input && input.focus instanceof Function) input.focus();
  }
}
function blurUntabbableButtonsOnClick(element2) {
  element2.off("click.tidy-keyboard-accessibility", '[tabindex="-1"]').on("click.tidy-keyboard-accessibility", '[tabindex="-1"]', (ev) => {
    ev.currentTarget?.blur();
  });
}
const delay = (ms) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};
function wrapCustomHtmlForRendering(html, renderScheme, id, activateDefaultSheetListeners) {
  const renderingAttribute = renderScheme === "handlebars" ? ` ${CONSTANTS.HTML_DYNAMIC_RENDERING_ATTRIBUTE}` : "";
  const coreListenersTag = activateDefaultSheetListeners ? ` class="${CONSTANTS.CLASS_TIDY_USE_CORE_LISTENERS}"` : "";
  const groupId = getCustomContentGroupIdAttributeAndValue(id);
  return `<div style="display: contents;"${renderingAttribute}${coreListenersTag} ${groupId}>${html}</div>`;
}
function getCustomContentGroupIdAttributeAndValue(id) {
  return `data-tidy-custom-content-group-id="${id}"`;
}
function getCustomContentGroupIdSelector(id) {
  return `[${getCustomContentGroupIdAttributeAndValue(id)}]`;
}
class CustomContentRenderer {
  static async render(params) {
    const {
      app,
      tabs,
      element: element2,
      data,
      isFullRender,
      superActivateListeners,
      customContent
    } = params;
    if (!element2?.get(0)) {
      debug("Element not available when it normally should be", params);
      return;
    }
    element2.get(0).querySelectorAll(CONSTANTS.HTML_DYNAMIC_RENDERING_ATTRIBUTE_SELECTOR).forEach((el) => el.remove());
    const sheetEl = element2.get(0);
    await CustomContentRenderer._renderTabs(
      tabs,
      sheetEl,
      isFullRender,
      app,
      data,
      params
    );
    for (let c2 of customContent) {
      try {
        CustomContentRenderer._renderContent(
          sheetEl,
          c2,
          app,
          data,
          isFullRender,
          superActivateListeners
        );
      } catch (e2) {
        error("Unable to render custom content", false, e2);
        debug("Custom content render failure context", {
          content: c2,
          app,
          data,
          isFullRender
        });
      }
    }
  }
  static _renderTabs(tabs, sheetEl, isFullRender, app, data, args) {
    const promises = tabs.map(async (tab) => {
      try {
        let tabEl = sheetEl.querySelector(
          `[data-tab-contents-for="${tab.id}"]`
        );
        if (!tabEl) {
          await delay(0);
          tabEl = sheetEl.querySelector(
            `[data-tab-contents-for="${tab.id}"]`
          );
        }
        if (!tabEl) {
          debug("Unable to find custom tab content container for render");
          return;
        }
        if (tab.content.type === "html" && (isFullRender || tab.content.renderScheme === "handlebars")) {
          tabEl.innerHTML = tab.content.html;
        }
        if (tab.onRender) {
          tab.onRender({
            app,
            data,
            element: sheetEl,
            tabContentsElement: tabEl,
            isFullRender
          });
        }
      } catch (e2) {
        error("Failed to render custom content due to an error", false, e2);
        debug("Custom content error debug details", {
          error: e2,
          erroredTab: tab,
          args
        });
      }
    });
    return Promise.all(promises);
  }
  static _renderContent(sheetEl, customContent, app, data, isFullRender, superActivateListeners) {
    const groupId = foundry.utils.randomID();
    let contentHtml = "";
    try {
      contentHtml = typeof customContent.content.html === "function" ? customContent.content.html(data) : customContent.content.html;
    } catch (e2) {
      error("Failed to render custom HTML", false, { e: e2, customContent });
    }
    const wrappedContent = wrapCustomHtmlForRendering(
      contentHtml,
      customContent.content.renderScheme,
      groupId,
      customContent.activateDefaultSheetListeners
    );
    if (customContent.onContentReady) {
      customContent.onContentReady({
        app,
        data,
        element: sheetEl,
        isFullRender,
        content: wrappedContent
      });
    }
    if (!isNil(customContent.position)) {
      const targetElements = Array.from(
        sheetEl.querySelectorAll(customContent.selector)
      );
      if (!targetElements.length) {
        debug("No target elements were found for injecting custom content", {
          content: customContent
        });
      }
      targetElements.forEach((el) => {
        el.insertAdjacentHTML(
          customContent.position,
          wrappedContent
        );
      });
      if (customContent.activateDefaultSheetListeners) {
        const groupSelector = getCustomContentGroupIdSelector(groupId);
        sheetEl.querySelectorAll(groupSelector).forEach((el) => superActivateListeners(el));
      }
    }
    if (customContent.onRender) {
      customContent.onRender({
        app,
        data,
        element: sheetEl,
        isFullRender
      });
    }
  }
  static wireCompatibilityEventListeners(html, superActivateListeners, sheet) {
    html.find("input[name], textarea[name], select[name]").off("change.compatiblity-event-listeners").on("change.compatiblity-event-listeners", function() {
      if (!this.closest(CONSTANTS.CLASS_SELECTOR_TIDY_USE_CORE_LISTENERS)) {
        sheet.submit();
      }
    });
    html.find(CONSTANTS.CLASS_SELECTOR_TIDY_USE_CORE_LISTENERS).each((_, el) => {
      superActivateListeners.call(sheet, $(el));
    });
  }
}
class SessionStorageManager {
  static _createKey(keyParams) {
    return `user-${keyParams.userId}|document-${keyParams.documentId}|${keyParams.feature}`;
  }
  static storeMap(keyParams, map) {
    try {
      const serializedMap = JSON.stringify(Array.from(map.entries()));
      sessionStorage.setItem(
        SessionStorageManager._createKey(keyParams),
        serializedMap
      );
    } catch (e2) {
      error(
        "An error occurred while storing cached data in session storage",
        false,
        e2
      );
      debug("Troubleshooting information", { keyParams, map });
    }
  }
  static getMap(keyParams) {
    try {
      const data = sessionStorage.getItem(
        SessionStorageManager._createKey(keyParams)
      );
      return data ? new Map(JSON.parse(data)) : void 0;
    } catch (e2) {
      error(
        "An error occurred while fetching cached data in session storage",
        false,
        e2
      );
      debug("Troubleshooting information", { keyParams });
    }
  }
}
class ItemTableToggleCacheService {
  _keyParams;
  itemTableToggles;
  constructor(params) {
    this._keyParams = {
      ...params,
      feature: "item-table-toggles"
    };
    this.itemTableToggles = this.itemTableToggles = SessionStorageManager.getMap(this._keyParams) ?? /* @__PURE__ */ new Map();
  }
  onItemTableToggle(location, expanded) {
    debug("Toggled Item Table", { location, expanded });
    this.itemTableToggles.set(location, expanded);
    SessionStorageManager.storeMap(this._keyParams, this.itemTableToggles);
  }
}
class AsyncMutex {
  _mutex;
  constructor() {
    this._mutex = Promise.resolve();
  }
  /**
   * Perform an action with guaranteed mutual exclusion.
   * @param action the action to take
   * @returns a promise representing the entirety of the operation
   */
  lock(action) {
    let currentMutex = this._mutex;
    this._mutex = new Promise(async (resolve) => {
      try {
        await currentMutex;
        await action();
      } finally {
        resolve();
      }
    });
    return this._mutex;
  }
}
class SheetPreferencesRuntime {
  static _store = writable();
  static init() {
    this._store.set(SheetPreferencesService.get());
    Hooks.on("updateUser", (user) => {
      if (game.user === user) {
        this._store.set(SheetPreferencesService.get());
      }
    });
  }
  static getStore() {
    return this._store;
  }
}
class Tidy5eBaseActorSheet {
  static applyCommonContext(context) {
    if ([CONSTANTS.SHEET_TYPE_CHARACTER, CONSTANTS.SHEET_TYPE_NPC].includes(
      context.actor.type
    )) {
      const attrConcentration = context.actor.system.attributes.concentration;
      if (context.actor.statuses.has(CONFIG.specialStatusEffects.CONCENTRATING) || FoundryAdapter.isActorSheetUnlocked(context.actor) && attrConcentration) {
        (context.saves ??= {}).concentration = {
          isConcentration: true,
          label: game.i18n.localize("DND5E.Concentration"),
          abbr: game.i18n.localize("DND5E.Concentration"),
          mod: Math.abs(attrConcentration.save),
          sign: context.actor.system.attributes.concentration.save < 0 ? "-" : "+"
        };
      }
    }
    context.hasSpecialSaves = Object.keys(context.saves ?? {}).length > 0;
    Tidy5eBaseActorSheet.applyDamageModifications(context);
  }
  static applyDamageModifications(context) {
    try {
      const dm = context.actor.system.traits?.dm;
      if (dm) {
        const rollData = context.actor.getRollData({ deterministic: true });
        const mods = Object.entries(dm.amount).map(([key, value]) => {
          const total = dnd5e.utils.simplifyBonus(value, rollData);
          if (!total) return null;
          const mod = {
            label: `${CONFIG.DND5E.damageTypes[key]?.label ?? key} ${dnd5e.utils.formatNumber(total, { signDisplay: "always" })}`,
            consequence: total > 0 ? "detriment" : "benefit"
          };
          const icons = mod.icons = [];
          if (dm.bypasses.size && CONFIG.DND5E.damageTypes[key]?.isPhysical)
            icons.push(...dm.bypasses);
          return mod;
        }).filter((f2) => f2);
        context.traits.traits.dm = mods;
      }
    } catch (e2) {
      error(
        "An error occurred while preparing Damage Modification data",
        false,
        e2
      );
      debug("Damage Modification error troubleshooting info", { context });
    }
  }
}
class CharacterSheetSections {
  static buildFeaturesSections(races, backgrounds, classes, feats, options) {
    const customFeats = feats.filter((f2) => TidyFlags.section.get(f2));
    feats = feats.filter((f2) => !TidyFlags.section.get(f2));
    const features = {
      race: {
        label: CONFIG.Item.typeLabels.race,
        items: races,
        hasActions: false,
        dataset: { type: CONSTANTS.ITEM_TYPE_RACE },
        showRequirementsColumn: true,
        canCreate: true,
        key: CONSTANTS.CHARACTER_FEAT_SECTION_RACE,
        show: true,
        ...options
      },
      background: {
        label: CONFIG.Item.typeLabels.background,
        items: backgrounds,
        hasActions: false,
        dataset: { type: CONSTANTS.ITEM_TYPE_BACKGROUND },
        showRequirementsColumn: true,
        canCreate: true,
        key: CONSTANTS.CHARACTER_FEAT_SECTION_BACKGROUND,
        show: true,
        ...options
      },
      classes: {
        label: `${CONFIG.Item.typeLabels.class}Pl`,
        items: classes,
        hasActions: false,
        dataset: { type: CONSTANTS.ITEM_TYPE_CLASS },
        isClass: true,
        showLevelColumn: true,
        canCreate: true,
        key: CONSTANTS.CHARACTER_FEAT_SECTION_CLASSES,
        show: true,
        ...options
      },
      active: {
        label: "DND5E.FeatureActive",
        items: feats.filter((feat) => feat.system.activation?.type),
        hasActions: true,
        dataset: {
          type: CONSTANTS.ITEM_TYPE_FEAT,
          "system.activation.type": CONSTANTS.ACTIVATION_COST_ACTION
        },
        showRequirementsColumn: true,
        showUsagesColumn: true,
        showUsesColumn: true,
        canCreate: true,
        key: CONSTANTS.CHARACTER_FEAT_SECTION_ACTIVE,
        show: true,
        ...options
      },
      passive: {
        label: "DND5E.FeaturePassive",
        items: feats.filter((feat) => !feat.system.activation?.type),
        hasActions: false,
        dataset: { type: CONSTANTS.ITEM_TYPE_FEAT },
        showRequirementsColumn: true,
        canCreate: true,
        key: CONSTANTS.CHARACTER_FEAT_SECTION_PASSIVE,
        show: true,
        ...options
      }
    };
    customFeats.forEach(
      (f2) => CharacterSheetSections.applyCharacterFeatureToSection(
        features,
        f2,
        options
      )
    );
    return features;
  }
  static applyCharacterFeatureToSection(features, feat, customSectionOptions) {
    const customSectionName = TidyFlags.section.get(feat);
    if (!customSectionName) {
      return;
    }
    const customSection = features[customSectionName] ??= {
      label: customSectionName,
      items: [],
      hasActions: true,
      dataset: {
        [TidyFlags.section.prop]: customSectionName
      },
      isClass: false,
      canCreate: true,
      showUsesColumn: true,
      showUsagesColumn: true,
      showRequirementsColumn: true,
      key: customSectionName,
      custom: {
        section: customSectionName,
        creationItemTypes: [CONSTANTS.ITEM_TYPE_FEAT]
      },
      show: true,
      ...customSectionOptions
    };
    customSection.items.push(feat);
  }
  static partitionItem(item, partitions, inventory) {
    if (item.type === CONSTANTS.ITEM_TYPE_SPELL) {
      partitions.spells.push(item);
    } else if (item.type === CONSTANTS.ITEM_TYPE_FEAT) {
      partitions.feats.push(item);
    } else if (item.type === CONSTANTS.ITEM_TYPE_RACE) {
      partitions.races.push(item);
    } else if (item.type === CONSTANTS.ITEM_TYPE_BACKGROUND) {
      partitions.backgrounds.push(item);
    } else if (item.type === CONSTANTS.ITEM_TYPE_CLASS) {
      partitions.classes.push(item);
    } else if (item.type === CONSTANTS.ITEM_TYPE_SUBCLASS) {
      partitions.subclasses.push(item);
    } else if (Object.keys(inventory).includes(item.type)) {
      partitions.items.push(item);
    }
  }
  // TODO: Figure out how to handle effects with section names that collide with items
  static mergeDuplicateFavoriteSections(sections) {
    let sectionsMap = {};
    for (let section of sections) {
      if (section.type === CONSTANTS.TAB_CHARACTER_EFFECTS) {
        continue;
      }
      const mappedSection = sectionsMap[section.key];
      if (!mappedSection) {
        sectionsMap[section.key] = section;
        continue;
      }
      const incomingItems = CharacterSheetSections.getItemsFromFavoriteSection(section);
      if (mappedSection.type !== CONSTANTS.CHARACTER_FAVORITE_SECTION_GENERIC) {
        const mappedItems = CharacterSheetSections.getItemsFromFavoriteSection(mappedSection);
        sectionsMap[section.key] = CharacterSheetSections.createGenericFavoriteSection(section.key, [
          ...incomingItems,
          ...mappedItems
        ]);
        continue;
      }
      mappedSection.items.push(...incomingItems);
    }
    return Object.values(sectionsMap);
  }
  static getItemsFromFavoriteSection(section) {
    return section.type === CONSTANTS.TAB_CHARACTER_SPELLBOOK ? section.spells : section.items;
  }
  static createGenericFavoriteSection(key, items) {
    return {
      canCreate: false,
      dataset: [],
      items,
      key,
      label: FoundryAdapter.localize(key),
      custom: {
        creationItemTypes: [],
        section: key
      },
      isExternal: false,
      show: true,
      type: "generic"
    };
  }
}
function BaseSheetCustomSectionMixin(itemsFn, Base) {
  return class extends Base {
    async _onSortItem(event, itemData) {
      const sourceSection = foundry.utils.getProperty(
        itemData,
        TidyFlags.section.prop
      );
      const targetSection = event.target?.closest('[data-tidy-section-key][data-custom-section="true"]')?.getAttribute("data-tidy-section-key");
      const isMovedToNewSection = !isNil(targetSection?.trim(), "") && sourceSection !== targetSection;
      const isMovedToDefaultSection = !isNil(sourceSection?.trim(), "") && isNil(targetSection?.trim(), "");
      const initialSortResult = await super._onSortItem(event, itemData);
      const item = itemsFn(this.object).get(itemData._id);
      return isMovedToNewSection ? TidyFlags.section.set(item, targetSection) : isMovedToDefaultSection ? TidyFlags.section.unset(item) : initialSortResult;
    }
  };
}
class ConditionsAndEffects {
  static async getConditionsAndEffects(actor, object, effectSections) {
    const conditionIds = /* @__PURE__ */ new Set();
    const conditions = Object.entries(CONFIG.DND5E.conditionTypes).reduce((arr, [k, c2]) => {
      if (c2.pseudo) return arr;
      const { label: name, icon, reference } = c2;
      const id = dnd5e.utils.staticID(`dnd5e${k}`);
      conditionIds.add(id);
      const existing = actor.effects.get(id);
      const { disabled, img } = existing ?? {};
      arr.push({
        name,
        reference,
        id: k,
        icon: img ?? icon,
        disabled: existing ? disabled : true
      });
      return arr;
    }, []);
    for (const category of Object.values(effectSections)) {
      category.effects = await category.effects.reduce(
        async (arr, effect) => {
          effect.updateDuration();
          if (conditionIds.has(effect.id) && !effect.duration.remaining)
            return arr;
          const { id, name, img, disabled, duration } = effect;
          let source = await effect.getSource() ?? actor;
          if (source instanceof dnd5e.documents.ActiveEffect5e && source.target !== object) {
            source = source.target;
          }
          arr = await arr;
          arr.push({
            id,
            name,
            img,
            disabled,
            duration,
            source,
            parentId: effect.target === effect.parent ? null : effect.parent.id,
            durationParts: duration.remaining ? duration.label.split(", ") : [],
            hasTooltip: source instanceof dnd5e.documents.Item5e
          });
          return arr;
        },
        []
      );
    }
    return {
      conditions,
      effects: effectSections
    };
  }
}
class Tidy5eCharacterSheet extends BaseSheetCustomSectionMixin(
  (object) => object.items,
  dnd5e.applications.actor.ActorSheet5eCharacter
) {
  context = writable();
  stats = writable({
    lastSubmissionTime: null
  });
  card = writable();
  currentTabId;
  searchFilters = /* @__PURE__ */ new Map();
  expandedItems = /* @__PURE__ */ new Map();
  expandedItemData = /* @__PURE__ */ new Map();
  inlineContainerToggleService = new InlineContainerToggleService();
  itemTableTogglesCache;
  itemFilterService;
  subscriptionsService;
  messageBus = writable();
  /**
   * The cached concentration information for the character.
   * @type {{items: Set<Item5e>, effects: Set<ActiveEffect5e>}}
   * @internal
   */
  _concentration = {
    items: /* @__PURE__ */ new Set(),
    effects: /* @__PURE__ */ new Set()
  };
  constructor(...args) {
    super(...args);
    this.subscriptionsService = new StoreSubscriptionsService();
    this.itemTableTogglesCache = new ItemTableToggleCacheService({
      userId: game.user.id,
      documentId: this.actor.id
    });
    this.itemFilterService = new ItemFilterService({}, this.actor);
    this.currentTabId = SettingsProvider.settings.initialCharacterSheetTab.get();
  }
  get template() {
    return FoundryAdapter.getTemplate("empty-form-template.hbs");
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      classes: [
        "tidy5e-sheet",
        "sheet",
        "actor",
        CONSTANTS.SHEET_TYPE_CHARACTER
      ],
      width: 740,
      height: 810,
      scrollY: ["[data-tidy-track-scroll-y]", ".scroll-container"]
    });
  }
  component;
  activateListeners(html) {
    let first = true;
    this.subscriptionsService.registerSubscriptions(
      this.itemFilterService.filterData$.subscribe(() => {
        if (first) return;
        this.render();
      }),
      settingStore.subscribe((s2) => {
        if (first) return;
        applyThemeDataAttributeToWindow(s2.colorScheme, this.element.get(0));
        this.render();
      }),
      this.messageBus.subscribe((m2) => {
        debug("Message bus message received", {
          app: this,
          actor: this.actor,
          message: m2
        });
      }),
      SheetPreferencesRuntime.getStore().subscribe(() => {
        if (first) return;
        this.render();
      })
    );
    first = false;
    const node = html.get(0);
    this.card.set({ sheet: node, item: null, itemCardContentTemplate: null });
    this.component = new CharacterSheet({
      target: node,
      context: /* @__PURE__ */ new Map([
        [CONSTANTS.SVELTE_CONTEXT.APP_ID, this.appId],
        [CONSTANTS.SVELTE_CONTEXT.CONTEXT, this.context],
        [CONSTANTS.SVELTE_CONTEXT.MESSAGE_BUS, this.messageBus],
        [CONSTANTS.SVELTE_CONTEXT.STATS, this.stats],
        [CONSTANTS.SVELTE_CONTEXT.CARD, this.card],
        [CONSTANTS.SVELTE_CONTEXT.CURRENT_TAB_ID, this.currentTabId],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_TAB_SELECTED,
          this.onTabSelected.bind(this)
        ],
        [CONSTANTS.SVELTE_CONTEXT.SEARCH_FILTERS, new Map(this.searchFilters)],
        [
          CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE,
          this.inlineContainerToggleService
        ],
        [CONSTANTS.SVELTE_CONTEXT.ITEM_FILTER_SERVICE, this.itemFilterService],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_FILTER,
          this.itemFilterService.onFilter.bind(this.itemFilterService)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_FILTER_CLEAR_ALL,
          this.itemFilterService.onFilterClearAll.bind(this.itemFilterService)
        ],
        [CONSTANTS.SVELTE_CONTEXT.ON_SEARCH, this.onSearch.bind(this)],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TOGGLED,
          this.onItemToggled.bind(this)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ITEM_TABLE_TOGGLES,
          new Map(this.itemTableTogglesCache.itemTableToggles)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TABLE_TOGGLE,
          this.itemTableTogglesCache.onItemTableToggle.bind(
            this.itemTableTogglesCache
          )
        ],
        [CONSTANTS.SVELTE_CONTEXT.LOCATION, ""],
        [CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEMS, new Map(this.expandedItems)],
        [
          CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEM_DATA,
          new Map(this.expandedItemData)
        ]
      ])
    });
    initTidy5eContextMenu(this, html);
  }
  async getData(options = {}) {
    this._concentration = this.actor.concentration;
    const defaultDocumentContext = await super.getData(this.options);
    Tidy5eBaseActorSheet.applyCommonContext(defaultDocumentContext);
    const characterPreferences = SheetPreferencesService.getByType(
      this.actor.type
    );
    const attributesSortMode = characterPreferences.tabs?.[CONSTANTS.TAB_CHARACTER_ATTRIBUTES]?.sort ?? "m";
    const inventorySortMode = characterPreferences.tabs?.[CONSTANTS.TAB_CHARACTER_INVENTORY]?.sort ?? "m";
    const spellbookSortMode = characterPreferences.tabs?.[CONSTANTS.TAB_CHARACTER_SPELLBOOK]?.sort ?? "m";
    const featureSortMode = characterPreferences.tabs?.[CONSTANTS.TAB_CHARACTER_FEATURES]?.sort ?? "m";
    const actionListSortMode = characterPreferences.tabs?.[CONSTANTS.TAB_ACTOR_ACTIONS]?.sort ?? "m";
    const unlocked = FoundryAdapter.isActorSheetUnlocked(this.actor) && defaultDocumentContext.editable;
    const tidyResources = defaultDocumentContext.resources.map(
      (r2) => ({
        name: r2.name,
        label: r2.label,
        labelName: `system.resources.${r2.name}.label`,
        placeholder: r2.placeholder,
        value: r2.value,
        valueName: `system.resources.${r2.name}.value`,
        max: r2.max,
        maxName: `system.resources.${r2.name}.max`,
        sr: r2.sr,
        srName: `system.resources.${r2.name}.sr`,
        lr: r2.lr,
        lrName: `system.resources.${r2.name}.lr`,
        cssClasses: [],
        dataSet: {}
      })
    );
    TidyHooks.tidy5eSheetsPrepareResources(tidyResources, this.actor);
    let maxPreparedSpellsTotal = 0;
    try {
      const formula = TidyFlags.maxPreparedSpells.get(this.actor) ?? "";
      if (formula?.trim() !== "") {
        const roll = await Roll.create(
          formula,
          this.actor.getRollData()
        ).evaluate();
        maxPreparedSpellsTotal = roll.total;
      }
    } catch (e2) {
      error("Unable to calculate max prepared spells", false, e2);
    }
    let utilities = {
      [CONSTANTS.TAB_CHARACTER_ATTRIBUTES]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_CHARACTER_ATTRIBUTES,
                "sort",
                "m"
              );
            },
            visible: attributesSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeManual"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_CHARACTER_ATTRIBUTES,
                "sort",
                "a"
              );
            },
            visible: attributesSortMode === "m"
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_CHARACTER_ATTRIBUTES,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_CHARACTER_ATTRIBUTES,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                // Provide a way to build the necessary config, perhaps within the application constructor. We've got all the info we need in order to perform the operation.
                sections: context2.favorites,
                tabId: CONSTANTS.TAB_CHARACTER_ATTRIBUTES,
                tabTitle: CharacterSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_CHARACTER_ATTRIBUTES
                )
              }).render(true);
            }
          }
        ]
      },
      [CONSTANTS.TAB_CHARACTER_INVENTORY]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_CHARACTER_INVENTORY,
                "sort",
                "m"
              );
            },
            visible: inventorySortMode === "a"
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeManual"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_CHARACTER_INVENTORY,
                "sort",
                "a"
              );
            },
            visible: inventorySortMode === "m"
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Commands.HideContainerPanel"
            ),
            iconClass: `fas fa-boxes-stacked fa-fw`,
            execute: () => {
              TidyFlags.showContainerPanel.unset(this.actor);
            },
            visible: !!TidyFlags.showContainerPanel.get(this.actor)
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Commands.ShowContainerPanel"
            ),
            iconClass: `fas fa-box fa-fw`,
            execute: () => {
              TidyFlags.showContainerPanel.set(this.actor, true);
            },
            visible: !TidyFlags.showContainerPanel.get(this.actor)
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_CHARACTER_INVENTORY,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_CHARACTER_INVENTORY,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.ListLayout"),
            iconClass: "fas fa-th-list fa-fw toggle-list",
            visible: !TidyFlags.inventoryGrid.get(this.actor),
            execute: () => {
              TidyFlags.inventoryGrid.set(this.actor);
            }
          },
          {
            title: FoundryAdapter.localize("TIDY5E.GridLayout"),
            iconClass: "fas fa-th-large fa-fw toggle-grid",
            visible: !!TidyFlags.inventoryGrid.get(this.actor),
            execute: () => {
              TidyFlags.inventoryGrid.unset(this.actor);
            }
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.inventory,
                tabId: CONSTANTS.TAB_CHARACTER_INVENTORY,
                tabTitle: CharacterSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_CHARACTER_INVENTORY
                )
              }).render(true);
            }
          }
        ]
      },
      [CONSTANTS.TAB_CHARACTER_SPELLBOOK]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_CHARACTER_SPELLBOOK,
                "sort",
                "m"
              );
            },
            visible: spellbookSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeManual"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_CHARACTER_SPELLBOOK,
                "sort",
                "a"
              );
            },
            visible: spellbookSortMode === "m"
          },
          {
            title: "Spell Pips",
            iconClass: "fa-regular fa-circle-dot fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypePreference(
                this.actor.type,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PREFERENCE,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_VALUE_MAX
              );
            },
            visible: (characterPreferences?.spellSlotTrackerMode ?? CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS) === CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS
          },
          {
            title: "Spell Value/Max",
            iconClass: "fa-regular fa-square fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypePreference(
                this.actor.type,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PREFERENCE,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS
              );
            },
            visible: characterPreferences?.spellSlotTrackerMode === CONSTANTS.SPELL_SLOT_TRACKER_MODE_VALUE_MAX
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_CHARACTER_SPELLBOOK,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_CHARACTER_SPELLBOOK,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.ListLayout"),
            iconClass: "fas fa-th-list fa-fw toggle-list",
            visible: !TidyFlags.spellbookGrid.get(this.actor),
            execute: () => {
              TidyFlags.spellbookGrid.set(this.actor);
            }
          },
          {
            title: FoundryAdapter.localize("TIDY5E.GridLayout"),
            iconClass: "fas fa-th-large fa-fw toggle-grid",
            visible: !!TidyFlags.spellbookGrid.get(this.actor),
            execute: () => {
              TidyFlags.spellbookGrid.unset(this.actor);
            }
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.spellbook,
                tabId: CONSTANTS.TAB_CHARACTER_SPELLBOOK,
                tabTitle: CharacterSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_CHARACTER_SPELLBOOK
                )
              }).render(true);
            }
          }
        ]
      },
      [CONSTANTS.TAB_CHARACTER_FEATURES]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_CHARACTER_FEATURES,
                "sort",
                "m"
              );
            },
            visible: featureSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeManual"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_CHARACTER_FEATURES,
                "sort",
                "a"
              );
            },
            visible: featureSortMode === "m"
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_CHARACTER_FEATURES,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_CHARACTER_FEATURES,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.features,
                tabId: CONSTANTS.TAB_CHARACTER_FEATURES,
                tabTitle: CharacterSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_CHARACTER_FEATURES
                )
              }).render(true);
            }
          }
        ]
      },
      [CONSTANTS.TAB_ACTOR_ACTIONS]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_ACTOR_ACTIONS,
                "sort",
                "m"
              );
            },
            visible: actionListSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("TIDY5E.SortMode.ActionListDefault"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_ACTOR_ACTIONS,
                "sort",
                "a"
              );
            },
            visible: actionListSortMode === "m"
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.actions,
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                tabTitle: CharacterSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_ACTOR_ACTIONS
                )
              }).render(true);
            }
          }
        ]
      }
    };
    let { conditions, effects: enhancedEffectSections } = await ConditionsAndEffects.getConditionsAndEffects(
      this.actor,
      this.object,
      defaultDocumentContext.effects
    );
    const context = {
      ...defaultDocumentContext,
      activateEditors: (node, options2) => FoundryAdapter.activateEditors(node, this, options2?.bindSecrets),
      actions: await getActorActionSections(this.actor),
      actorClassesToImages: getActorClassesToImages(this.actor),
      actorPortraitCommands: ActorPortraitRuntime.getEnabledPortraitMenuCommands(this.actor),
      allowEffectsManagement: FoundryAdapter.allowCharacterEffectsManagement(
        this.actor
      ),
      allowMaxHpOverride: SettingsProvider.settings.allowHpMaxOverride.get() && (!SettingsProvider.settings.lockHpMaxChanges.get() || FoundryAdapter.userIsGm()),
      appearanceEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.appearance,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      appId: this.appId,
      biographyEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.biography.value,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      bondEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.bond,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      conditions,
      containerPanelItems: await Inventory.getContainerPanelItems(
        defaultDocumentContext.items
      ),
      customActorTraits: CustomActorTraitsRuntime.getEnabledTraits(
        defaultDocumentContext
      ),
      customContent: await CharacterSheetRuntime.getContent(
        defaultDocumentContext
      ),
      editable: defaultDocumentContext.editable,
      effects: enhancedEffectSections,
      filterData: this.itemFilterService.getDocumentItemFilterData(),
      filterPins: ItemFilterRuntime.defaultFilterPins[this.actor.type],
      flawEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.flaw,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      healthPercentage: getPercentage(
        this.actor?.system?.attributes?.hp?.value,
        this.actor?.system?.attributes?.hp?.max
      ),
      idealEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.ideal,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      lockExpChanges: FoundryAdapter.shouldLockExpChanges(),
      lockHpMaxChanges: FoundryAdapter.shouldLockHpMaxChanges(),
      lockItemQuantity: FoundryAdapter.shouldLockItemQuantity(),
      lockLevelSelector: FoundryAdapter.shouldLockLevelSelector(),
      lockMoneyChanges: FoundryAdapter.shouldLockMoneyChanges(),
      lockSensitiveFields: !unlocked && SettingsProvider.settings.useTotalSheetLock.get() || !defaultDocumentContext.editable,
      maxPreparedSpellsTotal,
      notes1EnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes1.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      notes2EnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes2.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      notes3EnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes3.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      notes4EnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes4.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      notesEnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      originalContext: defaultDocumentContext,
      owner: this.actor.isOwner,
      showContainerPanel: TidyFlags.showContainerPanel.get(this.actor) === true && Array.from(defaultDocumentContext.items).some(
        (i2) => i2.type === CONSTANTS.ITEM_TYPE_CONTAINER
      ),
      showLimitedSheet: FoundryAdapter.showLimitedSheet(this.actor),
      spellCalculations: calculateSpellAttackAndDc(this.actor),
      spellSlotTrackerMode: characterPreferences.spellSlotTrackerMode ?? CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS,
      tabs: [],
      tidyResources,
      traitEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.trait,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      unlocked,
      useActionsFeature: actorUsesActionFeature(this.actor),
      useClassicControls: SettingsProvider.settings.useClassicControlsForCharacter.get(),
      useRoundedPortraitStyle: [
        CONSTANTS.CIRCULAR_PORTRAIT_OPTION_ALL,
        CONSTANTS.CIRCULAR_PORTRAIT_OPTION_CHARACTER
      ].includes(SettingsProvider.settings.useCircularPortraitStyle.get()),
      utilities,
      viewableWarnings: defaultDocumentContext.warnings?.filter(
        (w2) => !isNil(w2.message?.trim(), "")
      ) ?? []
    };
    for (const panelItem of context.containerPanelItems) {
      const ctx = context.itemContext[panelItem.container.id];
      ctx.containerContents = await Container.getContainerContents(
        panelItem.container
      );
    }
    let tabs = await CharacterSheetRuntime.getTabs(context);
    const selectedTabs = TidyFlags.selectedTabs.get(context.actor);
    if (selectedTabs?.length) {
      tabs = tabs.filter((t2) => selectedTabs?.includes(t2.id)).sort(
        (a2, b2) => selectedTabs.indexOf(a2.id) - selectedTabs.indexOf(b2.id)
      );
    } else {
      const defaultTabs = SettingsProvider.settings.defaultCharacterSheetTabs.get();
      tabs = tabs.filter((t2) => defaultTabs?.includes(t2.id)).sort((a2, b2) => defaultTabs.indexOf(a2.id) - defaultTabs.indexOf(b2.id));
    }
    context.tabs = tabs;
    TidyHooks.tidy5eSheetsPreConfigureSections(
      this,
      this.element.get(0),
      context
    );
    let effectsSection = {
      canCreate: false,
      dataset: {},
      effects: [],
      key: "tidy.effects",
      label: "DND5E.Effects",
      show: true
    };
    const favoriteEffects = this.actor.system.favorites.filter((f2) => f2.type === "effect");
    for (const favoriteEffect of favoriteEffects) {
      const effect = fromUuidSync(favoriteEffect.id, { relative: this.actor });
      if (!effect) {
        continue;
      }
      const data = await effect.getFavoriteData();
      if (data.suppressed) {
        data.subtitle = game.i18n.localize("DND5E.Suppressed");
      }
      effectsSection.effects.push({
        effectId: effect.id,
        effect,
        id: favoriteEffect.id,
        img: data.img,
        sort: favoriteEffect.sort,
        subtitle: data.subtitle,
        suppressed: data.suppressed,
        title: data.title,
        toggle: { applicable: true, value: data.toggle }
      });
    }
    context.favorites = CharacterSheetSections.mergeDuplicateFavoriteSections(
      context.favorites
    );
    if (effectsSection.effects.length) {
      context.favorites.push({
        ...effectsSection,
        type: CONSTANTS.TAB_CHARACTER_EFFECTS
      });
    }
    debug("Character Sheet context data", context);
    return context;
  }
  _prepareItems(context) {
    const inventory = Inventory.getDefaultInventorySections();
    const favoriteInventory = Inventory.getDefaultInventorySections({
      canCreate: false
    });
    const favoritesIdMap = this._getFavoritesIdMap();
    let {
      items,
      spells,
      feats,
      races,
      backgrounds,
      classes,
      subclasses,
      favorites
    } = Array.from(this.actor.items).reduce(
      (obj, item) => {
        const { quantity } = item.system;
        const ctx = context.itemContext[item.id] ??= {};
        ctx.isStack = Number.isNumeric(quantity) && quantity !== 1;
        ctx.attunement = FoundryAdapter.getAttunementContext(item);
        ctx.hasUses = item.hasLimitedUses;
        ctx.hasTarget = item.hasAreaTarget || item.hasIndividualTarget;
        ctx.concealDetails = !game.user.isGM && item.system.identified === false;
        const [originId] = item.getFlag("dnd5e", "advancementOrigin")?.split(".") ?? [];
        const group = this.actor.items.get(originId);
        switch (group?.type) {
          case "race":
            ctx.group = "race";
            break;
          case "background":
            ctx.group = "background";
            break;
          case "class":
            ctx.group = group.identifier;
            break;
          case "subclass":
            ctx.group = group.class?.identifier ?? "other";
            break;
          default:
            ctx.group = "other";
        }
        this._prepareItem(item, ctx);
        const isWithinContainer = this.actor.items.has(item.system.container);
        if (!isWithinContainer) {
          CharacterSheetSections.partitionItem(item, obj, inventory);
        }
        const favoritedItem = favoritesIdMap.get(
          item.getRelativeUUID(this.actor)
        );
        if (favoritedItem?.type === "item") {
          ctx.favoriteId = favoritedItem.id;
          CharacterSheetSections.partitionItem(
            item,
            obj.favorites,
            favoriteInventory
          );
        }
        return obj;
      },
      {
        items: [],
        spells: [],
        feats: [],
        races: [],
        backgrounds: [],
        classes: [],
        subclasses: [],
        favorites: {
          items: [],
          spells: [],
          feats: [],
          races: [],
          backgrounds: [],
          classes: [],
          subclasses: []
        }
      }
    );
    const inventoryTypes = Inventory.getDefaultInventoryTypes();
    for (let item of items) {
      const ctx = context.itemContext[item.id] ??= {};
      ctx.totalWeight = item.system.totalWeight?.toNearest(0.1);
      Inventory.applyInventoryItemToSection(inventory, item, inventoryTypes, {
        canCreate: true
      });
    }
    for (let item of favorites.items) {
      const ctx = context.itemContext[item.id] ??= {};
      ctx.totalWeight = item.system.totalWeight?.toNearest(0.1);
      Inventory.applyInventoryItemToSection(
        favoriteInventory,
        item,
        inventoryTypes,
        {
          canCreate: false
        }
      );
    }
    const nPrepared = spells.filter((spell) => {
      const prep = spell.system.preparation;
      return spell.system.level > 0 && prep.mode === "prepared" && prep.prepared;
    }).length;
    const spellbook = SheetSections.prepareTidySpellbook(
      context,
      spells,
      {
        canCreate: true
      },
      this
    );
    const favoriteSpellbook = SheetSections.prepareTidySpellbook(
      context,
      favorites.spells,
      {
        canCreate: false
      },
      this
    );
    classes = SheetSections.prepareClassItems(
      context,
      classes,
      subclasses,
      this.actor
    );
    for (const subclass of subclasses) {
      feats.push(subclass);
      const message = game.i18n.format("DND5E.SubclassMismatchWarn", {
        name: subclass.name,
        class: subclass.system.classIdentifier
      });
      context.warnings.push({ message, type: "warning" });
    }
    favorites.classes = SheetSections.prepareClassItems(
      context,
      favorites.classes,
      favorites.subclasses,
      this.actor
    );
    for (const subclass of favorites.subclasses) {
      favorites.feats.push(subclass);
    }
    const features = CharacterSheetSections.buildFeaturesSections(
      races,
      backgrounds,
      classes,
      feats,
      {
        canCreate: true
      }
    );
    const favoriteFeatures = CharacterSheetSections.buildFeaturesSections(
      favorites.races,
      favorites.backgrounds,
      favorites.classes,
      favorites.feats,
      { canCreate: false }
    );
    context.inventory = Object.values(inventory);
    context.spellbook = spellbook;
    context.features = Object.values(features);
    context.favorites = [
      ...Object.values(favoriteInventory).filter((i2) => i2.items.length).map((i2) => ({
        ...i2,
        type: CONSTANTS.TAB_CHARACTER_INVENTORY
      })),
      ...Object.values(favoriteFeatures).filter((i2) => i2.items.length).map((i2) => ({
        ...i2,
        type: CONSTANTS.TAB_CHARACTER_FEATURES
      })),
      ...favoriteSpellbook.filter((s2) => s2.spells.length).map((s2) => ({
        ...s2,
        type: CONSTANTS.TAB_CHARACTER_SPELLBOOK
      }))
    ];
    context.preparedSpells = nPrepared;
  }
  _getFavoritesIdMap() {
    return this.actor.system.favorites.reduce(
      (map, f2) => {
        map.set(f2.id, f2);
        return map;
      },
      /* @__PURE__ */ new Map()
    );
  }
  /**
   * A helper method to establish the displayed preparation state for an item.
   * @param {Item5e} item     Item being prepared for display.
   * @param {object} context  Context data for display.
   * @protected
   */
  _prepareItem(item, context) {
    if (item.type === CONSTANTS.ITEM_TYPE_SPELL) {
      const prep = item.system.preparation || {};
      const isAlways = prep.mode === "always";
      const isPrepared = !!prep.prepared;
      context.toggleClass = isPrepared ? "active" : "";
      if (isAlways) {
        context.toggleClass = "fixed";
        context.toggleTitle = CONFIG.DND5E.spellPreparationModes.always.label;
      } else if (isPrepared) {
        context.toggleTitle = CONFIG.DND5E.spellPreparationModes.prepared.label;
      } else {
        context.toggleTitle = game.i18n.localize("DND5E.SpellUnprepared");
      }
      if (this._concentration.items.has(item)) {
        context.concentration = true;
      }
    } else {
      const isActive = !!item.system.equipped;
      context.toggleClass = isActive ? "active" : "";
      context.toggleTitle = game.i18n.localize(
        isActive ? "DND5E.Equipped" : "DND5E.Unequipped"
      );
      context.canToggle = "equipped" in item.system;
    }
  }
  async setExpandedItemData() {
    this.expandedItemData.clear();
    for (const id of this.expandedItems.keys()) {
      const item = this.actor.items.get(id);
      if (item) {
        this.expandedItemData.set(
          id,
          await item.getChatData({ secrets: this.actor.isOwner })
        );
      }
    }
  }
  onToggleAbilityProficiency(event) {
    return this._onToggleAbilityProficiency(event);
  }
  onShortRest(event) {
    return this._onShortRest(event);
  }
  onLongRest(event) {
    return this._onLongRest(event);
  }
  async _onDropSingleItem(itemData) {
    if (itemData.type === CONSTANTS.ITEM_TYPE_SPELL && this.currentTabId === CONSTANTS.TAB_CHARACTER_INVENTORY) {
      const options = {};
      if (SettingsProvider.settings.includeFlagsInSpellScrollCreation.get()) {
        options.flags = itemData.flags;
      }
      const scroll = await dnd5e.documents.Item5e.createScrollFromSpell(
        itemData,
        options
      );
      return scroll.toObject();
    }
    return super._onDropSingleItem(itemData);
  }
  close(options = {}) {
    this._destroySvelteComponent();
    this.subscriptionsService.unsubscribeAll();
    return super.close(options);
  }
  submit() {
    super.submit();
  }
  async _onSubmit(...args) {
    await super._onSubmit(...args);
    this.stats.update((stats) => {
      stats.lastSubmissionTime = /* @__PURE__ */ new Date();
      return stats;
    });
  }
  _renderMutex = new AsyncMutex();
  async _render(force, options = {}) {
    if (typeof options !== "object") {
      options = {};
    }
    await this._renderMutex.lock(async () => {
      await this._renderSheet(force, options);
    });
  }
  async _renderSheet(force, options = {}) {
    await this.setExpandedItemData();
    const data = await this.getData();
    SheetSections.accountForExternalSections(
      ["actions", "favorites", "inventory", "spellbook", "features"],
      data
    );
    this.context.set(data);
    if (force) {
      const { width, height } = SheetPreferencesService.getByType(this.actor.type) ?? {};
      this.position = {
        ...this.position,
        width: width ?? this.position.width,
        height: height ?? this.position.height
      };
      this._saveScrollPositions(this.element);
      this._destroySvelteComponent();
      await super._render(force, options);
      applySheetAttributesToWindow(
        this.actor.documentName,
        this.actor.type,
        SettingsProvider.settings.colorScheme.get(),
        this.element.get(0)
      );
      await this.renderCustomContent({ data, isFullRender: true });
      TidyHooks.tidy5eSheetsRenderActorSheet(
        this,
        this.element.get(0),
        data,
        true
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
      blurUntabbableButtonsOnClick(this.element);
      return;
    }
    await maintainCustomContentInputFocus(this, async () => {
      applyTitleToWindow(this.title, this.element.get(0));
      await this.renderCustomContent({ data, isFullRender: false });
      TidyHooks.tidy5eSheetsRenderActorSheet(
        this,
        this.element.get(0),
        data,
        false
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
    });
  }
  async renderCustomContent(args) {
    await CustomContentRenderer.render({
      app: this,
      customContent: args.data.customContent,
      data: args.data,
      element: this.element,
      isFullRender: args.isFullRender,
      superActivateListeners: super.activateListeners,
      tabs: args.data.tabs
    });
  }
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    return FoundryAdapter.removeConfigureSettingsButtonWhenLockedForNonGm(
      buttons
    );
  }
  _destroySvelteComponent() {
    this.component?.$destroy();
    this.component = void 0;
  }
  _saveScrollPositions(html) {
    if (html.length && this.component) {
      const save = super._saveScrollPositions(html);
      debug("Saved scroll positions", this._scrollPositions);
      return save;
    }
  }
  _disableFields(...args) {
    debug("Ignoring call to disable fields. Delegating to Tidy Sheets...");
  }
  _onResize(event) {
    super._onResize(event);
    const { width, height } = this.position;
    SheetPreferencesService.setDocumentTypePreference(
      this.actor.type,
      "width",
      width
    );
    SheetPreferencesService.setDocumentTypePreference(
      this.actor.type,
      "height",
      height
    );
  }
  async _onDrop(event) {
    if (!event.target.closest("[data-tidy-favorites]"))
      return super._onDrop(event);
    const dragData = event.dataTransfer?.getData("text/plain");
    if (!dragData) return super._onDrop(event);
    let data;
    try {
      data = JSON.parse(dragData);
    } catch (e2) {
      console.error(e2);
      return;
    }
    let type = "item";
    let id = (await fromUuid(data.uuid)).getRelativeUUID(this.actor);
    return this._onDropFavorite(event, { type, id });
  }
  /* -------------------------------------------- */
  /* Favorites
  /* -------------------------------------------- */
  /**
   * Handle an owned item or effect being dropped in the favorites area.
   * @param {PointerEvent} event         The triggering event.
   * @param {ActorFavorites5e} favorite  The favorite that was dropped.
   * @returns {Promise<Actor5e>|void}
   * @protected
   */
  async _onDropFavorite(event, favorite) {
    if (this.actor.system.hasFavorite(favorite.id))
      return await this._onSortFavorites(event, favorite.id);
    return await this.actor.system.addFavorite(favorite);
  }
  /**
   * Handle re-ordering the favorites list.
   * @param {DragEvent} event  The drop event.
   * @param {string} srcId     The identifier of the dropped favorite.
   * @returns {Promise<Actor5e>|void}
   * @protected
   */
  async _onSortFavorites(event, srcId) {
    const targetId = event.target?.closest("[data-favorite-id]")?.getAttribute("data-favorite-id");
    if (!targetId) return;
    let source;
    let target;
    if (srcId === targetId) return;
    const siblings = this.actor.system.favorites.filter(
      (f2) => {
        if (f2.id === targetId) target = f2;
        else if (f2.id === srcId) source = f2;
        return f2.id !== srcId;
      }
    );
    const updates = SortingHelpers.performIntegerSort(source, {
      target,
      siblings
    });
    const favorites = this.actor.system.favorites.reduce(
      (map, f2) => map.set(f2.id, { ...f2 }),
      /* @__PURE__ */ new Map()
    );
    for (const { target: target2, update: update2 } of updates) {
      const favorite = favorites.get(target2.id);
      foundry.utils.mergeObject(favorite, update2);
    }
    return await this.actor.update({
      "system.favorites": Array.from(favorites.values())
    });
  }
  /* -------------------------------------------- */
  /* SheetTabCacheable
  /* -------------------------------------------- */
  onTabSelected(tabId) {
    this.currentTabId = tabId;
  }
  /* -------------------------------------------- */
  /* SheetExpandedItemsCacheable
  /* -------------------------------------------- */
  onItemToggled(itemId, isVisible, location) {
    const locationSet = this.expandedItems.get(itemId) ?? this.expandedItems.set(itemId, /* @__PURE__ */ new Set()).get(itemId);
    if (isVisible) {
      locationSet?.add(location);
    } else {
      locationSet?.delete(location);
    }
    debug("Item Toggled", {
      expandedItems: this.expandedItems
    });
  }
  /* -------------------------------------------- */
  /* SearchFilterCacheable
  /* -------------------------------------------- */
  onSearch(location, text2) {
    debug("Searched", {
      location,
      text: text2
    });
    this.searchFilters.set(location, text2);
  }
}
function getActorClassesToImages(actor) {
  let actorClassesToImages = {};
  for (let item of actor.items) {
    if (item.type == CONSTANTS.ITEM_TYPE_CLASS) {
      let className = item.name.toLowerCase();
      let classImg = item.img;
      actorClassesToImages[className] = classImg;
    }
  }
  return actorClassesToImages;
}
function create_fragment$o(ctx) {
  let div;
  let resourcewithbar;
  let current;
  resourcewithbar = new ResourceWithBar({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      value: (
        /*$context*/
        ctx[0].system.attributes.hp.value
      ),
      valueField: "system.attributes.hp.value",
      valueTitle: (
        /*localize*/
        ctx[3]("DND5E.HitPointsCurrent")
      ),
      valueDisabled: !/*$context*/
      ctx[0].editable,
      max: (
        /*$context*/
        ctx[0].system.attributes.hp.max
      ),
      maxField: "system.attributes.hp.max",
      maxTitle: (
        /*localize*/
        ctx[3]("DND5E.HitPointsMax")
      ),
      maxDisabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].system.details.level || /*$context*/
      ctx[0].lockHpMaxChanges || /*$context*/
      ctx[0].lockSensitiveFields,
      percentage: (
        /*$context*/
        ctx[0].healthPercentage
      ),
      Bar: (
        /*$settingStore*/
        ctx[1].useHpBarNpc ? HpBar : null
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(resourcewithbar.$$.fragment);
      attr(div, "class", "portrait-hp svelte-l1hffv");
      attr(
        div,
        "title",
        /*localize*/
        ctx[3]("DND5E.HitPoints")
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(resourcewithbar, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const resourcewithbar_changes = {};
      if (dirty & /*$context*/
      1) resourcewithbar_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.value = /*$context*/
      ctx2[0].system.attributes.hp.value;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.valueDisabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.max = /*$context*/
      ctx2[0].system.attributes.hp.max;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.maxDisabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].system.details.level || /*$context*/
      ctx2[0].lockHpMaxChanges || /*$context*/
      ctx2[0].lockSensitiveFields;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.percentage = /*$context*/
      ctx2[0].healthPercentage;
      if (dirty & /*$settingStore*/
      2) resourcewithbar_changes.Bar = /*$settingStore*/
      ctx2[1].useHpBarNpc ? HpBar : null;
      resourcewithbar.$set(resourcewithbar_changes);
    },
    i(local) {
      if (current) return;
      transition_in(resourcewithbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resourcewithbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(resourcewithbar);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, $settingStore, context, localize];
}
class NpcHitPoints extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$o, safe_not_equal, {});
  }
}
function create_fragment$n(ctx) {
  let div1;
  let div0;
  let span;
  let t0;
  let button0;
  let i1;
  let button0_disabled_value;
  let button0_tabindex_value;
  let t1;
  let button1;
  let i2;
  let button1_disabled_value;
  let button1_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      span.innerHTML = `<i class="rest-icon fas fa-bed"></i>`;
      t0 = space();
      button0 = element("button");
      i1 = element("i");
      t1 = space();
      button1 = element("button");
      i2 = element("i");
      attr(span, "class", "resting-icon svelte-1tber6c");
      attr(i1, "class", "fas fa-hourglass-half");
      attr(button0, "type", "button");
      attr(button0, "class", "rest short-rest inline-icon-button svelte-1tber6c");
      attr(
        button0,
        "title",
        /*localize*/
        ctx[3]("TIDY5E.ShortRest")
      );
      button0.disabled = button0_disabled_value = !/*$context*/
      ctx[0].editable;
      attr(button0, "tabindex", button0_tabindex_value = !/*$settingStore*/
      ctx[1].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
      attr(i2, "class", "fas fa-hourglass-end");
      attr(button1, "type", "button");
      attr(button1, "class", "rest long-rest inline-icon-button svelte-1tber6c");
      attr(
        button1,
        "title",
        /*localize*/
        ctx[3]("TIDY5E.LongRest")
      );
      button1.disabled = button1_disabled_value = !/*$context*/
      ctx[0].editable;
      attr(button1, "tabindex", button1_tabindex_value = !/*$settingStore*/
      ctx[1].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx[1].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div0, "class", "resting svelte-1tber6c");
      attr(div1, "class", "rest-container svelte-1tber6c");
      attr(
        div1,
        "title",
        /*localize*/
        ctx[3]("TIDY5E.RestHint")
      );
      toggle_class(
        div1,
        "has-rounded-portrait",
        /*$context*/
        ctx[0].useRoundedPortraitStyle
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span);
      append(div0, t0);
      append(div0, button0);
      append(button0, i1);
      append(div0, t1);
      append(div0, button1);
      append(button1, i2);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*$context*/
      ctx2[0].editable)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*$settingStore*/
      2 && button0_tabindex_value !== (button0_tabindex_value = !/*$settingStore*/
      ctx2[1].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button0, "tabindex", button0_tabindex_value);
      }
      if (dirty & /*$context*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*$context*/
      ctx2[0].editable)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & /*$settingStore*/
      2 && button1_tabindex_value !== (button1_tabindex_value = !/*$settingStore*/
      ctx2[1].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx2[1].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button1, "tabindex", button1_tabindex_value);
      }
      if (dirty & /*$context*/
      1) {
        toggle_class(
          div1,
          "has-rounded-portrait",
          /*$context*/
          ctx2[0].useRoundedPortraitStyle
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const click_handler = (ev) => $context.shortRest(ev);
  const click_handler_1 = (ev) => $context.longRest(ev);
  return [$context, $settingStore, context, localize, click_handler, click_handler_1];
}
class NpcRest extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$n, safe_not_equal, {});
  }
}
function create_fragment$m(ctx) {
  let div;
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-dice-six");
      attr(button, "type", "button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[4]("DND5E.HitDiceRoll") + "/" + /*localize*/
        ctx[4]("TIDY5E.HitDiceRollAverage")
      );
      attr(button, "class", "roll-hp-formula highlight-on-hover svelte-ykxlql");
      attr(button, "tabindex", button_tabindex_value = !/*$settingStore*/
      ctx[0].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx[0].useAccessibleKeyboardSupport ? 0 : -1);
      attr(div, "class", "portrait-hp-formula health svelte-ykxlql");
      attr(
        div,
        "title",
        /*localize*/
        ctx[4]("DND5E.HPFormula")
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*rollNpcHp*/
            ctx[2]
          ),
          listen(
            button,
            "contextmenu",
            /*calcAverageHitDie*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$settingStore*/
      1 && button_tabindex_value !== (button_tabindex_value = !/*$settingStore*/
      ctx2[0].useDefaultSheetHpTabbing && /*$settingStore*/
      ctx2[0].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(0, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(5, $context = value));
  async function rollNpcHp(event) {
    event.preventDefault();
    const formula = $context.actor.system.attributes.hp.formula;
    if (!formula) return;
    const roll_hp = await FoundryAdapter.roll(formula, void 0, { async: true });
    const hp = roll_hp.total;
    FoundryAdapter.playDiceSound();
    $context.actor.update({
      "system.attributes.hp.value": hp,
      "system.attributes.hp.max": hp
    });
  }
  function calcAverageHitDie(event) {
    event.preventDefault();
    let formula = $context.actor.system.attributes.hp.formula;
    debug(`tidy5e-npc | activateListeners | formula: ${formula}`);
    const average = FoundryAdapter.calculateAverageFromFormula(formula);
    $context.actor.update({
      ["system.attributes.hp.value"]: average,
      ["system.attributes.hp.max"]: average
    });
  }
  const localize = FoundryAdapter.localize;
  return [$settingStore, context, rollNpcHp, calcAverageHitDie, localize];
}
class NpcHealthFormulaRoller extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$m, safe_not_equal, {});
  }
}
function create_if_block_3$2(ctx) {
  let deathsaves;
  let current;
  deathsaves = new DeathSaves({
    props: {
      successes: (
        /*$context*/
        ctx[0].system.attributes.death.success
      ),
      failures: (
        /*$context*/
        ctx[0].system.attributes.death.failure
      ),
      successesField: "system.attributes.death.success",
      failuresField: "system.attributes.death.failure",
      hasHpOverlay: (
        /*$settingStore*/
        ctx[2].useHpOverlayNpc
      )
    }
  });
  deathsaves.$on(
    "rollDeathSave",
    /*rollDeathSave_handler*/
    ctx[5]
  );
  return {
    c() {
      create_component(deathsaves.$$.fragment);
    },
    m(target, anchor) {
      mount_component(deathsaves, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const deathsaves_changes = {};
      if (dirty & /*$context*/
      1) deathsaves_changes.successes = /*$context*/
      ctx2[0].system.attributes.death.success;
      if (dirty & /*$context*/
      1) deathsaves_changes.failures = /*$context*/
      ctx2[0].system.attributes.death.failure;
      if (dirty & /*$settingStore*/
      4) deathsaves_changes.hasHpOverlay = /*$settingStore*/
      ctx2[2].useHpOverlayNpc;
      deathsaves.$set(deathsaves_changes);
    },
    i(local) {
      if (current) return;
      transition_in(deathsaves.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(deathsaves.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(deathsaves, detaching);
    }
  };
}
function create_if_block_2$3(ctx) {
  let exhaustioninput;
  let current;
  exhaustioninput = new ExhaustionInput({
    props: {
      level: (
        /*$context*/
        ctx[0].system.attributes.exhaustion
      ),
      radiusClass: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle ? "rounded" : "top-left"
      ),
      isActiveEffectApplied: ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx[0].actor,
        "system.attributes.exhaustion"
      )
    }
  });
  exhaustioninput.$on(
    "levelSelected",
    /*onLevelSelected*/
    ctx[4]
  );
  return {
    c() {
      create_component(exhaustioninput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exhaustioninput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exhaustioninput_changes = {};
      if (dirty & /*$context*/
      1) exhaustioninput_changes.level = /*$context*/
      ctx2[0].system.attributes.exhaustion;
      if (dirty & /*$context*/
      1) exhaustioninput_changes.radiusClass = /*$context*/
      ctx2[0].useRoundedPortraitStyle ? "rounded" : "top-left";
      if (dirty & /*$context*/
      1) exhaustioninput_changes.isActiveEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx2[0].actor,
        "system.attributes.exhaustion"
      );
      exhaustioninput.$set(exhaustioninput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(exhaustioninput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exhaustioninput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exhaustioninput, detaching);
    }
  };
}
function create_if_block_1$4(ctx) {
  let exhaustiontracker;
  let current;
  exhaustiontracker = new ExhaustionTracker({
    props: {
      level: (
        /*$context*/
        ctx[0].system.attributes.exhaustion
      ),
      radiusClass: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle ? "rounded" : "top-left"
      ),
      exhaustionConfig: (
        /*$settingStore*/
        ctx[2].exhaustionConfig
      ),
      isActiveEffectApplied: ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx[0].actor,
        "system.attributes.exhaustion"
      )
    }
  });
  exhaustiontracker.$on(
    "levelSelected",
    /*onLevelSelected*/
    ctx[4]
  );
  return {
    c() {
      create_component(exhaustiontracker.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exhaustiontracker, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exhaustiontracker_changes = {};
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.level = /*$context*/
      ctx2[0].system.attributes.exhaustion;
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.radiusClass = /*$context*/
      ctx2[0].useRoundedPortraitStyle ? "rounded" : "top-left";
      if (dirty & /*$settingStore*/
      4) exhaustiontracker_changes.exhaustionConfig = /*$settingStore*/
      ctx2[2].exhaustionConfig;
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.isActiveEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx2[0].actor,
        "system.attributes.exhaustion"
      );
      exhaustiontracker.$set(exhaustiontracker_changes);
    },
    i(local) {
      if (current) return;
      transition_in(exhaustiontracker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exhaustiontracker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exhaustiontracker, detaching);
    }
  };
}
function create_if_block$7(ctx) {
  let npchealthformularoller;
  let current;
  npchealthformularoller = new NpcHealthFormulaRoller({});
  return {
    c() {
      create_component(npchealthformularoller.$$.fragment);
    },
    m(target, anchor) {
      mount_component(npchealthformularoller, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(npchealthformularoller.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(npchealthformularoller.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(npchealthformularoller, detaching);
    }
  };
}
function create_default_slot$9(ctx) {
  let show_if = (
    /*incapacitated*/
    ctx[1] && (!/*$settingStore*/
    ctx[2].hideDeathSavesFromPlayers || FoundryAdapter.userIsGm())
  );
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let npchitpoints;
  let t2;
  let npcrest;
  let t3;
  let if_block2_anchor;
  let current;
  let if_block0 = show_if && create_if_block_3$2(ctx);
  const if_block_creators = [create_if_block_1$4, create_if_block_2$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$settingStore*/
      ctx2[2].useExhaustion && /*$settingStore*/
      ctx2[2].exhaustionConfig.type === "specific"
    ) return 0;
    if (
      /*$settingStore*/
      ctx2[2].useExhaustion && /*$settingStore*/
      ctx2[2].exhaustionConfig.type === "open"
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  npchitpoints = new NpcHitPoints({});
  npcrest = new NpcRest({});
  let if_block2 = !/*$context*/
  ctx[0].system.details.level && create_if_block$7();
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      create_component(npchitpoints.$$.fragment);
      t2 = space();
      create_component(npcrest.$$.fragment);
      t3 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, t1, anchor);
      mount_component(npchitpoints, target, anchor);
      insert(target, t2, anchor);
      mount_component(npcrest, target, anchor);
      insert(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*incapacitated, $settingStore*/
      6) show_if = /*incapacitated*/
      ctx2[1] && (!/*$settingStore*/
      ctx2[2].hideDeathSavesFromPlayers || FoundryAdapter.userIsGm());
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*incapacitated, $settingStore*/
          6) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        } else {
          if_block1 = null;
        }
      }
      if (!/*$context*/
      ctx2[0].system.details.level) {
        if (if_block2) {
          if (dirty & /*$context*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$7();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(npchitpoints.$$.fragment, local);
      transition_in(npcrest.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(npchitpoints.$$.fragment, local);
      transition_out(npcrest.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block2_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      destroy_component(npchitpoints, detaching);
      destroy_component(npcrest, detaching);
      if (if_block2) if_block2.d(detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let actorprofile;
  let t2;
  let temphp;
  let current;
  actorprofile = new ActorProfile({
    props: {
      useHpOverlay: (
        /*$settingStore*/
        ctx[2].useHpOverlayNpc
      ),
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  temphp = new TempHp({});
  return {
    c() {
      create_component(actorprofile.$$.fragment);
      t2 = space();
      create_component(temphp.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actorprofile, target, anchor);
      insert(target, t2, anchor);
      mount_component(temphp, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const actorprofile_changes = {};
      if (dirty & /*$settingStore*/
      4) actorprofile_changes.useHpOverlay = /*$settingStore*/
      ctx2[2].useHpOverlayNpc;
      if (dirty & /*$$scope, $context, $settingStore, incapacitated*/
      71) {
        actorprofile_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actorprofile.$set(actorprofile_changes);
    },
    i(local) {
      if (current) return;
      transition_in(actorprofile.$$.fragment, local);
      transition_in(temphp.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorprofile.$$.fragment, local);
      transition_out(temphp.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(actorprofile, detaching);
      destroy_component(temphp, detaching);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let incapacitated;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(2, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  async function onLevelSelected(event) {
    await $context.actor.update({
      "system.attributes.exhaustion": event.detail.level
    });
  }
  const rollDeathSave_handler = (event) => $context.actor.rollDeathSave({ event: event.detail.mouseEvent });
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(1, incapacitated = ($context.actor?.system?.attributes?.hp?.value ?? 0) <= 0 && $context.actor?.system?.attributes?.hp?.max !== 0);
    }
  };
  return [
    $context,
    incapacitated,
    $settingStore,
    context,
    onLevelSelected,
    rollDeathSave_handler
  ];
}
class NpcProfile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$l, safe_not_equal, {});
  }
}
function create_fragment$k(ctx) {
  let div;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr(div, "class", div_class_value = "delimited-truncated-content " + /*cssClass*/
      ctx[0] + " svelte-crs614");
      attr(
        div,
        "style",
        /*dynamicStyles*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*contentWithGridStyles*/
          ctx[2].call(null, div)
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cssClass*/
      1 && div_class_value !== (div_class_value = "delimited-truncated-content " + /*cssClass*/
      ctx2[0] + " svelte-crs614")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*dynamicStyles*/
      2) {
        attr(
          div,
          "style",
          /*dynamicStyles*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { delimiter = "<span>&#8226;</span>" } = $$props;
  let { cssClass = null } = $$props;
  let dynamicStyles = "";
  function contentWithGridStyles(node) {
    const childrenEntries = Array.from(node.children).entries();
    for (let [index, el] of childrenEntries) {
      var div = document.createElement("div");
      div.innerHTML = delimiter;
      if (index > 0 && div.firstChild) {
        node.insertBefore(div.firstChild, el);
      }
    }
    const nodesLength = node.children.length;
    if (nodesLength) {
      let columns = [];
      for (let i2 = 0; i2 < nodesLength; i2++) {
        const target = node.children[i2];
        const isContentNode = i2 % 2 === 0;
        if (isContentNode) {
          target.classList.add("truncate");
        }
        const column = isContentNode ? "minmax(auto, min-content)" : "min-content";
        columns.push(column);
      }
      $$invalidate(1, dynamicStyles = "grid-template-columns: " + columns.join(" "));
    }
  }
  $$self.$$set = ($$props2) => {
    if ("delimiter" in $$props2) $$invalidate(3, delimiter = $$props2.delimiter);
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [cssClass, dynamicStyles, contentWithGridStyles, delimiter, $$scope, slots];
}
class DelimitedTruncatedContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$k, safe_not_equal, { delimiter: 3, cssClass: 0 });
  }
}
function create_else_block$4(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(
        /*text*/
        ctx[4]
      );
      attr(span, "class", "source-label truncate svelte-5gbao");
      attr(
        span,
        "title",
        /*text*/
        ctx[4]
      );
      toggle_class(
        span,
        "placeholder",
        /*usePlaceholder*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      16) set_data(
        t2,
        /*text*/
        ctx2[4]
      );
      if (dirty & /*text*/
      16) {
        attr(
          span,
          "title",
          /*text*/
          ctx2[4]
        );
      }
      if (dirty & /*usePlaceholder*/
      8) {
        toggle_class(
          span,
          "placeholder",
          /*usePlaceholder*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$6(ctx) {
  let button;
  let t2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t2 = text(
        /*text*/
        ctx[4]
      );
      attr(button, "type", "button");
      attr(button, "class", "configure-source inline-transparent-button highlight-on-hover truncate svelte-5gbao");
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
      toggle_class(
        button,
        "placeholder",
        /*usePlaceholder*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      16) set_data(
        t2,
        /*text*/
        ctx2[4]
      );
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
      if (dirty & /*usePlaceholder*/
      8) {
        toggle_class(
          button,
          "placeholder",
          /*usePlaceholder*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$j(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*editable*/
      ctx2[2]
    ) return create_if_block$6;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let source;
  let text2;
  let usePlaceholder;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let { document: document2 } = $$props;
  let { keyPath } = $$props;
  let { editable } = $$props;
  const click_handler = () => FoundryAdapter.renderSourceConfig(document2, keyPath);
  $$self.$$set = ($$props2) => {
    if ("document" in $$props2) $$invalidate(0, document2 = $$props2.document);
    if ("keyPath" in $$props2) $$invalidate(1, keyPath = $$props2.keyPath);
    if ("editable" in $$props2) $$invalidate(2, editable = $$props2.editable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*document, keyPath*/
    3) {
      $$invalidate(6, source = FoundryAdapter.getProperty(document2, keyPath));
    }
    if ($$self.$$.dirty & /*source*/
    64) {
      $$invalidate(4, text2 = !isNil(source?.label, "") ? source.label : "Source");
    }
    if ($$self.$$.dirty & /*source*/
    64) {
      $$invalidate(3, usePlaceholder = isNil(source?.label, ""));
    }
  };
  return [
    document2,
    keyPath,
    editable,
    usePlaceholder,
    text2,
    $settingStore,
    source,
    click_handler
  ];
}
class InlineSource extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$j, safe_not_equal, { document: 0, keyPath: 1, editable: 2 });
  }
}
function create_if_block_7(ctx) {
  let iteminfocard;
  let current;
  iteminfocard = new ItemInfoCard({});
  return {
    c() {
      create_component(iteminfocard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iteminfocard, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(iteminfocard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iteminfocard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iteminfocard, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let actorwarnings;
  let current;
  actorwarnings = new ActorWarnings({
    props: {
      warnings: (
        /*$context*/
        ctx[0].viewableWarnings
      )
    }
  });
  return {
    c() {
      create_component(actorwarnings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actorwarnings, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actorwarnings_changes = {};
      if (dirty & /*$context*/
      1) actorwarnings_changes.warnings = /*$context*/
      ctx2[0].viewableWarnings;
      actorwarnings.$set(actorwarnings_changes);
    },
    i(local) {
      if (current) return;
      transition_in(actorwarnings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorwarnings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actorwarnings, detaching);
    }
  };
}
function create_if_block_5$1(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "link-state fas fa-unlink svelte-ryh5u5");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.TokenUnlinked")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block_4$1(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "link-state fas fa-link svelte-ryh5u5");
      attr(
        i2,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.TokenLinked")
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_else_block$3(ctx) {
  let span;
  let t_value = (
    /*currentSize*/
    ctx[3].text + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(
        span,
        "title",
        /*localize*/
        ctx[7]("DND5E.Size")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*currentSize*/
      8 && t_value !== (t_value = /*currentSize*/
      ctx2[3].text + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3$1(ctx) {
  let inlinetextdropdownlist;
  let current;
  inlinetextdropdownlist = new InlineTextDropdownList({
    props: {
      options: (
        /*sizes*/
        ctx[4]
      ),
      selected: (
        /*currentSize*/
        ctx[3]
      ),
      title: (
        /*localize*/
        ctx[7]("DND5E.Size")
      )
    }
  });
  inlinetextdropdownlist.$on(
    "optionClicked",
    /*optionClicked_handler*/
    ctx[8]
  );
  return {
    c() {
      create_component(inlinetextdropdownlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinetextdropdownlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinetextdropdownlist_changes = {};
      if (dirty & /*sizes*/
      16) inlinetextdropdownlist_changes.options = /*sizes*/
      ctx2[4];
      if (dirty & /*currentSize*/
      8) inlinetextdropdownlist_changes.selected = /*currentSize*/
      ctx2[3];
      inlinetextdropdownlist.$set(inlinetextdropdownlist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinetextdropdownlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetextdropdownlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetextdropdownlist, detaching);
    }
  };
}
function create_default_slot$8(ctx) {
  let span1;
  let inlinecreaturetype;
  let t0;
  let span0;
  let i2;
  let span0_title_value;
  let t1;
  let span2;
  let t2_value = (
    /*$context*/
    ctx[0].system.details.alignment + ""
  );
  let t2;
  let span2_title_value;
  let t3;
  let inlinesource;
  let current;
  inlinecreaturetype = new InlineCreatureType({});
  inlinesource = new InlineSource({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      keyPath: "system.details.source",
      editable: (
        /*$context*/
        ctx[0].unlocked
      )
    }
  });
  return {
    c() {
      span1 = element("span");
      create_component(inlinecreaturetype.$$.fragment);
      t0 = space();
      span0 = element("span");
      i2 = element("i");
      t1 = space();
      span2 = element("span");
      t2 = text(t2_value);
      t3 = space();
      create_component(inlinesource.$$.fragment);
      attr(i2, "class", "fas fa-tree");
      attr(span0, "class", "environment");
      attr(span0, "title", span0_title_value = /*localize*/
      ctx[7]("TIDY5E.EnvironmentTooltip", {
        environment: (
          /*$context*/
          ctx[0].system.details.environment
        )
      }));
      attr(span1, "class", "flex-row extra-small-gap align-items-center");
      attr(span2, "class", "origin-summary-text");
      attr(span2, "title", span2_title_value = /*$context*/
      ctx[0].system.details.alignment);
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      mount_component(inlinecreaturetype, span1, null);
      append(span1, t0);
      append(span1, span0);
      append(span0, i2);
      insert(target, t1, anchor);
      insert(target, span2, anchor);
      append(span2, t2);
      insert(target, t3, anchor);
      mount_component(inlinesource, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$context*/
      1 && span0_title_value !== (span0_title_value = /*localize*/
      ctx2[7]("TIDY5E.EnvironmentTooltip", {
        environment: (
          /*$context*/
          ctx2[0].system.details.environment
        )
      }))) {
        attr(span0, "title", span0_title_value);
      }
      if ((!current || dirty & /*$context*/
      1) && t2_value !== (t2_value = /*$context*/
      ctx2[0].system.details.alignment + "")) set_data(t2, t2_value);
      if (!current || dirty & /*$context*/
      1 && span2_title_value !== (span2_title_value = /*$context*/
      ctx2[0].system.details.alignment)) {
        attr(span2, "title", span2_title_value);
      }
      const inlinesource_changes = {};
      if (dirty & /*$context*/
      1) inlinesource_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) inlinesource_changes.editable = /*$context*/
      ctx2[0].unlocked;
      inlinesource.$set(inlinesource_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinecreaturetype.$$.fragment, local);
      transition_in(inlinesource.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecreaturetype.$$.fragment, local);
      transition_out(inlinesource.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
        detach(t1);
        detach(span2);
        detach(t3);
      }
      destroy_component(inlinecreaturetype);
      destroy_component(inlinesource, detaching);
    }
  };
}
function create_key_block$1(ctx) {
  let delimitedtruncatedcontent;
  let current;
  delimitedtruncatedcontent = new DelimitedTruncatedContent({
    props: {
      cssClass: "flex-grow-1",
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(delimitedtruncatedcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(delimitedtruncatedcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const delimitedtruncatedcontent_changes = {};
      if (dirty & /*$$scope, $context*/
      2049) {
        delimitedtruncatedcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      delimitedtruncatedcontent.$set(delimitedtruncatedcontent_changes);
    },
    i(local) {
      if (current) return;
      transition_in(delimitedtruncatedcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(delimitedtruncatedcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(delimitedtruncatedcontent, detaching);
    }
  };
}
function create_if_block_2$2(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "origin-summary-tidy inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[7]("TIDY5E.OriginSummaryConfig")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[5].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      32 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[5].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$3(ctx) {
  let specialsaves;
  let current;
  specialsaves = new SpecialSaves({});
  return {
    c() {
      create_component(specialsaves.$$.fragment);
    },
    m(target, anchor) {
      mount_component(specialsaves, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(specialsaves.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(specialsaves.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(specialsaves, detaching);
    }
  };
}
function create_if_block$5(ctx) {
  let alloweditlock;
  let current;
  alloweditlock = new AllowEditLock({
    props: {
      hint: (
        /*$settingStore*/
        ctx[5].permanentlyUnlockNpcSheetForGm && FoundryAdapter.userIsGm() ? (
          /*localize*/
          ctx[7]("TIDY5E.Settings.PermanentlyUnlockNPCSheetForGM.title")
        ) : null
      )
    }
  });
  return {
    c() {
      create_component(alloweditlock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(alloweditlock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const alloweditlock_changes = {};
      if (dirty & /*$settingStore*/
      32) alloweditlock_changes.hint = /*$settingStore*/
      ctx2[5].permanentlyUnlockNpcSheetForGm && FoundryAdapter.userIsGm() ? (
        /*localize*/
        ctx2[7]("TIDY5E.Settings.PermanentlyUnlockNPCSheetForGM.title")
      ) : null;
      alloweditlock.$set(alloweditlock_changes);
    },
    i(local) {
      if (current) return;
      transition_in(alloweditlock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(alloweditlock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(alloweditlock, detaching);
    }
  };
}
function create_tab_end_slot$1(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].editable && create_if_block$5(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].editable
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let t0;
  let div11;
  let t1;
  let header;
  let div0;
  let npcprofile;
  let t2;
  let div10;
  let div5;
  let t3;
  let div1;
  let actorname;
  let t4;
  let div4;
  let div2;
  let span0;
  let t5_value = (
    /*$context*/
    ctx[0].system.details.xp.value + ""
  );
  let t5;
  let t6;
  let t7;
  let div3;
  let t8_value = (
    /*localize*/
    ctx[7]("DND5E.AbbreviationCR") + ""
  );
  let t8;
  let t9;
  let contenteditableformfield;
  let t10;
  let sheetmenu;
  let t11;
  let horizontallineseparator0;
  let t12;
  let div8;
  let div6;
  let current_block_type_index;
  let if_block3;
  let t13;
  let span1;
  let t15;
  let previous_key = (
    /*$context*/
    ctx[0].lockSensitiveFields
  );
  let t16;
  let div7;
  let b2;
  let t17_value = (
    /*localize*/
    ctx[7]("DND5E.Proficiency") + ""
  );
  let t17;
  let t18;
  let t19_value = formatAsModifier(
    /*$context*/
    ctx[0].system.attributes.prof
  ) + "";
  let t19;
  let t20;
  let t21;
  let horizontallineseparator1;
  let t22;
  let div9;
  let actormovement;
  let t23;
  let t24;
  let horizontallineseparator2;
  let t25;
  let actorheaderstats;
  let t26;
  let tabs;
  let updating_selectedTabId;
  let t27;
  let section;
  let tabcontents;
  let div11_class_value;
  let current;
  let if_block0 = (
    /*$settingStore*/
    ctx[5].itemCardsForNpcs && create_if_block_7()
  );
  let if_block1 = (
    /*$context*/
    ctx[0].viewableWarnings.length && create_if_block_6(ctx)
  );
  npcprofile = new NpcProfile({});
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].tokenState === "linked"
    ) return create_if_block_4$1;
    if (
      /*$context*/
      ctx2[0].tokenState === "unlinked"
    ) return create_if_block_5$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block2 = current_block_type && current_block_type(ctx);
  actorname = new ActorName({});
  contenteditableformfield = new ContentEditableFormField({
    props: {
      element: "span",
      editable: !/*$context*/
      ctx[0].lockSensitiveFields,
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.details.cr",
      placeholder: "0",
      dataMaxLength: 4,
      value: (
        /*$context*/
        ctx[0].labels.cr
      ),
      saveAs: "number",
      selectOnFocus: true
    }
  });
  sheetmenu = new SheetMenu({
    props: {
      defaultSettingsTab: CONSTANTS.TAB_USER_SETTINGS_NPCS
    }
  });
  horizontallineseparator0 = new HorizontalLineSeparator({ props: { borderColor: "light" } });
  const if_block_creators = [create_if_block_3$1, create_else_block$3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].editable
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let key_block = create_key_block$1(ctx);
  let if_block4 = (
    /*$context*/
    ctx[0].unlocked && create_if_block_2$2(ctx)
  );
  horizontallineseparator1 = new HorizontalLineSeparator({ props: { borderColor: "light" } });
  actormovement = new ActorMovement({ props: { class: "flex-1" } });
  let if_block5 = (
    /*$context*/
    ctx[0].hasSpecialSaves && create_if_block_1$3()
  );
  horizontallineseparator2 = new HorizontalLineSeparator({ props: { borderColor: "light" } });
  actorheaderstats = new ActorHeaderStats({
    props: {
      abilities: (
        /*abilities*/
        ctx[2]
      ),
      ac: (
        /*$context*/
        ctx[0].system.attributes.ac
      ),
      init: (
        /*$context*/
        ctx[0].system.attributes.init
      )
    }
  });
  function tabs_selectedTabId_binding(value) {
    ctx[10](value);
  }
  let tabs_props = {
    tabs: (
      /*$context*/
      ctx[0].tabs
    ),
    $$slots: { "tab-end": [create_tab_end_slot$1] },
    $$scope: { ctx }
  };
  if (
    /*selectedTabId*/
    ctx[1] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[1];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[0].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      div11 = element("div");
      if (if_block1) if_block1.c();
      t1 = space();
      header = element("header");
      div0 = element("div");
      create_component(npcprofile.$$.fragment);
      t2 = space();
      div10 = element("div");
      div5 = element("div");
      if (if_block2) if_block2.c();
      t3 = space();
      div1 = element("div");
      create_component(actorname.$$.fragment);
      t4 = space();
      div4 = element("div");
      div2 = element("div");
      span0 = element("span");
      t5 = text(t5_value);
      t6 = text(" XP");
      t7 = space();
      div3 = element("div");
      t8 = text(t8_value);
      t9 = space();
      create_component(contenteditableformfield.$$.fragment);
      t10 = space();
      create_component(sheetmenu.$$.fragment);
      t11 = space();
      create_component(horizontallineseparator0.$$.fragment);
      t12 = space();
      div8 = element("div");
      div6 = element("div");
      if_block3.c();
      t13 = space();
      span1 = element("span");
      span1.textContent = "";
      t15 = space();
      key_block.c();
      t16 = space();
      div7 = element("div");
      b2 = element("b");
      t17 = text(t17_value);
      t18 = text(": ");
      t19 = text(t19_value);
      t20 = space();
      if (if_block4) if_block4.c();
      t21 = space();
      create_component(horizontallineseparator1.$$.fragment);
      t22 = space();
      div9 = element("div");
      create_component(actormovement.$$.fragment);
      t23 = space();
      if (if_block5) if_block5.c();
      t24 = space();
      create_component(horizontallineseparator2.$$.fragment);
      t25 = space();
      create_component(actorheaderstats.$$.fragment);
      t26 = space();
      create_component(tabs.$$.fragment);
      t27 = space();
      section = element("section");
      create_component(tabcontents.$$.fragment);
      attr(div0, "class", "flex-0");
      attr(div1, "class", "actor-name");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(div2, "class", "xp svelte-ryh5u5");
      attr(div3, "class", "level svelte-ryh5u5");
      attr(div4, "class", "level-information svelte-ryh5u5");
      attr(div5, "class", "actor-name-row flex-row justify-content-space-between align-items-center small-gap svelte-ryh5u5");
      attr(div5, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(div6, "class", "flex-row extra-small-gap");
      attr(b2, "class", "proficiency svelte-ryh5u5");
      attr(div7, "class", "flex-row align-items-center extra-small-gap");
      attr(div8, "class", "origin-summary svelte-ryh5u5");
      attr(div9, "class", "flex-row extra-small-gap justify-content-space-between");
      attr(div10, "class", "flex-grow-1");
      attr(header, "class", "svelte-ryh5u5");
      attr(section, "class", "tidy-sheet-body");
      attr(div11, "class", div11_class_value = "token-link-wrapper " + /*$context*/
      ctx[0].tokenState + " svelte-ryh5u5");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div11, anchor);
      if (if_block1) if_block1.m(div11, null);
      append(div11, t1);
      append(div11, header);
      append(header, div0);
      mount_component(npcprofile, div0, null);
      append(header, t2);
      append(header, div10);
      append(div10, div5);
      if (if_block2) if_block2.m(div5, null);
      append(div5, t3);
      append(div5, div1);
      mount_component(actorname, div1, null);
      append(div5, t4);
      append(div5, div4);
      append(div4, div2);
      append(div2, span0);
      append(span0, t5);
      append(span0, t6);
      append(div4, t7);
      append(div4, div3);
      append(div3, t8);
      append(div3, t9);
      mount_component(contenteditableformfield, div3, null);
      append(div4, t10);
      mount_component(sheetmenu, div4, null);
      append(div10, t11);
      mount_component(horizontallineseparator0, div10, null);
      append(div10, t12);
      append(div10, div8);
      append(div8, div6);
      if_blocks[current_block_type_index].m(div6, null);
      append(div6, t13);
      append(div6, span1);
      append(div6, t15);
      key_block.m(div6, null);
      append(div8, t16);
      append(div8, div7);
      append(div7, b2);
      append(b2, t17);
      append(b2, t18);
      append(b2, t19);
      append(div7, t20);
      if (if_block4) if_block4.m(div7, null);
      append(div10, t21);
      mount_component(horizontallineseparator1, div10, null);
      append(div10, t22);
      append(div10, div9);
      mount_component(actormovement, div9, null);
      append(div9, t23);
      if (if_block5) if_block5.m(div9, null);
      append(div10, t24);
      mount_component(horizontallineseparator2, div10, null);
      append(div10, t25);
      mount_component(actorheaderstats, div10, null);
      append(div11, t26);
      mount_component(tabs, div11, null);
      append(div11, t27);
      append(div11, section);
      mount_component(tabcontents, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$settingStore*/
        ctx2[5].itemCardsForNpcs
      ) {
        if (if_block0) {
          if (dirty & /*$settingStore*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].viewableWarnings.length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div11, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if (if_block2) if_block2.d(1);
        if_block2 = current_block_type && current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div5, t3);
        }
      }
      if ((!current || dirty & /*$context*/
      1) && t5_value !== (t5_value = /*$context*/
      ctx2[0].system.details.xp.value + "")) set_data(t5, t5_value);
      const contenteditableformfield_changes = {};
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.editable = !/*$context*/
      ctx2[0].lockSensitiveFields;
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.value = /*$context*/
      ctx2[0].labels.cr;
      contenteditableformfield.$set(contenteditableformfield_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block3 = if_blocks[current_block_type_index];
        if (!if_block3) {
          if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block3.c();
        } else {
          if_block3.p(ctx2, dirty);
        }
        transition_in(if_block3, 1);
        if_block3.m(div6, t13);
      }
      if (dirty & /*$context*/
      1 && safe_not_equal(previous_key, previous_key = /*$context*/
      ctx2[0].lockSensitiveFields)) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div6, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if ((!current || dirty & /*$context*/
      1) && t19_value !== (t19_value = formatAsModifier(
        /*$context*/
        ctx2[0].system.attributes.prof
      ) + "")) set_data(t19, t19_value);
      if (
        /*$context*/
        ctx2[0].unlocked
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_2$2(ctx2);
          if_block4.c();
          if_block4.m(div7, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*$context*/
        ctx2[0].hasSpecialSaves
      ) {
        if (if_block5) {
          if (dirty & /*$context*/
          1) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1$3();
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div9, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      const actorheaderstats_changes = {};
      if (dirty & /*abilities*/
      4) actorheaderstats_changes.abilities = /*abilities*/
      ctx2[2];
      if (dirty & /*$context*/
      1) actorheaderstats_changes.ac = /*$context*/
      ctx2[0].system.attributes.ac;
      if (dirty & /*$context*/
      1) actorheaderstats_changes.init = /*$context*/
      ctx2[0].system.attributes.init;
      actorheaderstats.$set(actorheaderstats_changes);
      const tabs_changes = {};
      if (dirty & /*$context*/
      1) tabs_changes.tabs = /*$context*/
      ctx2[0].tabs;
      if (dirty & /*$$scope, $settingStore, $context*/
      2081) {
        tabs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      2) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[1];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      1) tabcontents_changes.tabs = /*$context*/
      ctx2[0].tabs;
      if (dirty & /*selectedTabId*/
      2) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[1];
      tabcontents.$set(tabcontents_changes);
      if (!current || dirty & /*$context*/
      1 && div11_class_value !== (div11_class_value = "token-link-wrapper " + /*$context*/
      ctx2[0].tokenState + " svelte-ryh5u5")) {
        attr(div11, "class", div11_class_value);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(npcprofile.$$.fragment, local);
      transition_in(actorname.$$.fragment, local);
      transition_in(contenteditableformfield.$$.fragment, local);
      transition_in(sheetmenu.$$.fragment, local);
      transition_in(horizontallineseparator0.$$.fragment, local);
      transition_in(if_block3);
      transition_in(key_block);
      transition_in(horizontallineseparator1.$$.fragment, local);
      transition_in(actormovement.$$.fragment, local);
      transition_in(if_block5);
      transition_in(horizontallineseparator2.$$.fragment, local);
      transition_in(actorheaderstats.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(npcprofile.$$.fragment, local);
      transition_out(actorname.$$.fragment, local);
      transition_out(contenteditableformfield.$$.fragment, local);
      transition_out(sheetmenu.$$.fragment, local);
      transition_out(horizontallineseparator0.$$.fragment, local);
      transition_out(if_block3);
      transition_out(key_block);
      transition_out(horizontallineseparator1.$$.fragment, local);
      transition_out(actormovement.$$.fragment, local);
      transition_out(if_block5);
      transition_out(horizontallineseparator2.$$.fragment, local);
      transition_out(actorheaderstats.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div11);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d();
      destroy_component(npcprofile);
      if (if_block2) {
        if_block2.d();
      }
      destroy_component(actorname);
      destroy_component(contenteditableformfield);
      destroy_component(sheetmenu);
      destroy_component(horizontallineseparator0);
      if_blocks[current_block_type_index].d();
      key_block.d(detaching);
      if (if_block4) if_block4.d();
      destroy_component(horizontallineseparator1);
      destroy_component(actormovement);
      if (if_block5) if_block5.d();
      destroy_component(horizontallineseparator2);
      destroy_component(actorheaderstats);
      destroy_component(tabs);
      destroy_component(tabcontents);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let sizes;
  let currentSize;
  let abilities;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(5, $settingStore = $$value));
  let selectedTabId;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  const optionClicked_handler = (event) => $context.actor.update({ "system.traits.size": event.detail.value });
  const click_handler = () => new ActorOriginSummaryConfigFormApplication($context.actor).render(true);
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(1, selectedTabId);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(4, sizes = Object.entries($context.config.actorSizes).map(([abbreviation, size]) => ({ value: abbreviation, text: size.label })));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(3, currentSize = {
        value: $context.system.traits.size,
        text: $context.config.actorSizes[$context.system.traits.size]?.label
      });
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, abilities = Object.entries($context.abilities));
    }
  };
  return [
    $context,
    selectedTabId,
    abilities,
    currentSize,
    sizes,
    $settingStore,
    context,
    localize,
    optionClicked_handler,
    click_handler,
    tabs_selectedTabId_binding
  ];
}
class NpcSheetFull extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$i, safe_not_equal, {});
  }
}
function create_default_slot$7(ctx) {
  let article0;
  let div0;
  let t1;
  let sheeteditor0;
  let t2;
  let article1;
  let div1;
  let t6;
  let sheeteditor1;
  let current;
  let mounted;
  let dispose;
  sheeteditor0 = new SheetEditor({
    props: {
      content: TidyFlags.appearance.get(
        /*$context*/
        ctx[0].actor
      ) ?? "",
      target: TidyFlags.appearance.prop,
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  sheeteditor1 = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].biographyHTML
      ),
      target: "system.details.biography.value",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article0 = element("article");
      div0 = element("div");
      div0.textContent = `${/*localize*/
      ctx[2]("DND5E.Appearance")}`;
      t1 = space();
      create_component(sheeteditor0.$$.fragment);
      t2 = space();
      article1 = element("article");
      div1 = element("div");
      div1.textContent = `${/*localize*/
      ctx[2]("DND5E.Background")}/${/*localize*/
      ctx[2]("DND5E.Biography")}`;
      t6 = space();
      create_component(sheeteditor1.$$.fragment);
      attr(div0, "class", "section-titles biopage");
      attr(article0, "class", "appearance-notes svelte-1mpy67c");
      attr(div1, "class", "section-titles");
      attr(article1, "class", "biography-notes svelte-1mpy67c");
    },
    m(target, anchor) {
      insert(target, article0, anchor);
      append(article0, div0);
      append(article0, t1);
      mount_component(sheeteditor0, article0, null);
      insert(target, t2, anchor);
      insert(target, article1, anchor);
      append(article1, div1);
      append(article1, t6);
      mount_component(sheeteditor1, article1, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(
            /*$context*/
            ctx[0].activateEditors(article0)
          ),
          action_destroyer(
            /*$context*/
            ctx[0].activateEditors(article1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor0_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor0_changes.content = TidyFlags.appearance.get(
        /*$context*/
        ctx2[0].actor
      ) ?? "";
      if (dirty & /*$context*/
      1) sheeteditor0_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor0.$set(sheeteditor0_changes);
      const sheeteditor1_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor1_changes.content = /*$context*/
      ctx2[0].biographyHTML;
      if (dirty & /*$context*/
      1) sheeteditor1_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor1.$set(sheeteditor1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor0.$$.fragment, local);
      transition_in(sheeteditor1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor0.$$.fragment, local);
      transition_out(sheeteditor1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article0);
        detach(t2);
        detach(article1);
      }
      destroy_component(sheeteditor0);
      destroy_component(sheeteditor1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$h(ctx) {
  let div1;
  let limitedheader;
  let t2;
  let section;
  let div0;
  let rerenderafterformsubmission;
  let current;
  limitedheader = new LimitedHeader({
    props: {
      rounded: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle
      )
    }
  });
  rerenderafterformsubmission = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.biography.value
      ),
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(limitedheader.$$.fragment);
      t2 = space();
      section = element("section");
      div0 = element("div");
      create_component(rerenderafterformsubmission.$$.fragment);
      attr(div0, "class", "note-entries svelte-1mpy67c");
      attr(section, "class", "tidy-sheet-body svelte-1mpy67c");
      attr(div1, "class", "limited-npc svelte-1mpy67c");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(limitedheader, div1, null);
      append(div1, t2);
      append(div1, section);
      append(section, div0);
      mount_component(rerenderafterformsubmission, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const limitedheader_changes = {};
      if (dirty & /*$context*/
      1) limitedheader_changes.rounded = /*$context*/
      ctx2[0].useRoundedPortraitStyle;
      limitedheader.$set(limitedheader_changes);
      const rerenderafterformsubmission_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.biography.value;
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission.$set(rerenderafterformsubmission_changes);
    },
    i(local) {
      if (current) return;
      transition_in(limitedheader.$$.fragment, local);
      transition_in(rerenderafterformsubmission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(limitedheader.$$.fragment, local);
      transition_out(rerenderafterformsubmission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(limitedheader);
      destroy_component(rerenderafterformsubmission);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class NpcSheetLimited extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$h, safe_not_equal, {});
  }
}
function create_else_block$2(ctx) {
  let npcsheetfull;
  let current;
  npcsheetfull = new NpcSheetFull({});
  return {
    c() {
      create_component(npcsheetfull.$$.fragment);
    },
    m(target, anchor) {
      mount_component(npcsheetfull, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(npcsheetfull.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(npcsheetfull.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(npcsheetfull, detaching);
    }
  };
}
function create_if_block$4(ctx) {
  let npcsheetlimited;
  let current;
  npcsheetlimited = new NpcSheetLimited({});
  return {
    c() {
      create_component(npcsheetlimited.$$.fragment);
    },
    m(target, anchor) {
      mount_component(npcsheetlimited, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(npcsheetlimited.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(npcsheetlimited.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(npcsheetlimited, detaching);
    }
  };
}
function create_fragment$g(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$4, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].showLimitedSheet
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  return [$context, context];
}
class NpcSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$g, safe_not_equal, {});
  }
}
class NpcSheetSections {
  static get abilitiesItemTypes() {
    return [
      CONSTANTS.ITEM_TYPE_WEAPON,
      CONSTANTS.ITEM_TYPE_EQUIPMENT,
      CONSTANTS.ITEM_TYPE_TOOL,
      CONSTANTS.ITEM_TYPE_CONTAINER,
      CONSTANTS.ITEM_TYPE_LOOT,
      CONSTANTS.ITEM_TYPE_FEAT
    ];
  }
  static applyAbilityToSection(abilities, feat, customSectionOptions) {
    const customSectionName = TidyFlags.section.get(feat);
    if (!customSectionName) {
      return;
    }
    const customSection = abilities[customSectionName] ??= {
      label: customSectionName,
      items: [],
      hasActions: true,
      key: customSectionName,
      dataset: {
        [TidyFlags.section.prop]: customSectionName
      },
      canCreate: true,
      custom: {
        section: customSectionName,
        creationItemTypes: NpcSheetSections.abilitiesItemTypes
      },
      show: true,
      ...customSectionOptions
    };
    customSection.items.push(feat);
  }
}
class Tidy5eNpcSheet extends BaseSheetCustomSectionMixin(
  (object) => object.items,
  dnd5e.applications.actor.ActorSheet5eNPC
) {
  context = writable();
  stats = writable({
    lastSubmissionTime: null
  });
  card = writable();
  currentTabId;
  searchFilters = /* @__PURE__ */ new Map();
  expandedItems = /* @__PURE__ */ new Map();
  expandedItemData = /* @__PURE__ */ new Map();
  inlineContainerToggleService = new InlineContainerToggleService();
  itemTableTogglesCache;
  itemFilterService;
  subscriptionsService;
  messageBus = writable();
  /**
   * The cached concentration information for the character.
   * @type {{items: Set<Item5e>, effects: Set<ActiveEffect5e>}}
   * @internal
   */
  _concentration = {
    items: /* @__PURE__ */ new Set(),
    effects: /* @__PURE__ */ new Set()
  };
  constructor(...args) {
    super(...args);
    this.subscriptionsService = new StoreSubscriptionsService();
    this.itemTableTogglesCache = new ItemTableToggleCacheService({
      userId: game.user.id,
      documentId: this.actor.id
    });
    this.itemFilterService = new ItemFilterService({}, this.actor);
    this.currentTabId = SettingsProvider.settings.initialNpcSheetTab.get();
  }
  get template() {
    return FoundryAdapter.getTemplate("empty-form-template.hbs");
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      classes: ["tidy5e-sheet", "sheet", "actor", CONSTANTS.SHEET_TYPE_NPC],
      width: 740,
      height: 810,
      scrollY: ["[data-tidy-track-scroll-y]", ".scroll-container"]
    });
  }
  component;
  activateListeners(html) {
    let first = true;
    this.subscriptionsService.registerSubscriptions(
      this.itemFilterService.filterData$.subscribe(() => {
        if (first) return;
        this.render();
      }),
      settingStore.subscribe((s2) => {
        if (first) return;
        applyThemeDataAttributeToWindow(s2.colorScheme, this.element.get(0));
        this.render();
      }),
      this.messageBus.subscribe((m2) => {
        debug("Message bus message received", {
          app: this,
          actor: this.actor,
          message: m2
        });
      }),
      SheetPreferencesRuntime.getStore().subscribe(() => {
        if (first) return;
        this.render();
      })
    );
    first = false;
    const node = html.get(0);
    this.card.set({ sheet: node, item: null, itemCardContentTemplate: null });
    this.component = new NpcSheet({
      target: node,
      context: /* @__PURE__ */ new Map([
        [CONSTANTS.SVELTE_CONTEXT.APP_ID, this.appId],
        [CONSTANTS.SVELTE_CONTEXT.CONTEXT, this.context],
        [CONSTANTS.SVELTE_CONTEXT.MESSAGE_BUS, this.messageBus],
        [CONSTANTS.SVELTE_CONTEXT.STATS, this.stats],
        [CONSTANTS.SVELTE_CONTEXT.CARD, this.card],
        [CONSTANTS.SVELTE_CONTEXT.CURRENT_TAB_ID, this.currentTabId],
        [
          CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE,
          this.inlineContainerToggleService
        ],
        [CONSTANTS.SVELTE_CONTEXT.ITEM_FILTER_SERVICE, this.itemFilterService],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_TAB_SELECTED,
          this.onTabSelected.bind(this)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TOGGLED,
          this.onItemToggled.bind(this)
        ],
        [CONSTANTS.SVELTE_CONTEXT.SEARCH_FILTERS, new Map(this.searchFilters)],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_FILTER,
          this.itemFilterService.onFilter.bind(this.itemFilterService)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_FILTER_CLEAR_ALL,
          this.itemFilterService.onFilterClearAll.bind(this.itemFilterService)
        ],
        [CONSTANTS.SVELTE_CONTEXT.ON_SEARCH, this.onSearch.bind(this)],
        [CONSTANTS.SVELTE_CONTEXT.LOCATION, ""],
        [CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEMS, new Map(this.expandedItems)],
        [
          CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEM_DATA,
          new Map(this.expandedItemData)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ITEM_TABLE_TOGGLES,
          new Map(this.itemTableTogglesCache.itemTableToggles)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TABLE_TOGGLE,
          this.itemTableTogglesCache.onItemTableToggle.bind(
            this.itemTableTogglesCache
          )
        ]
      ])
    });
    initTidy5eContextMenu(this, html);
  }
  async getData(options = {}) {
    this._concentration = this.actor.concentration;
    const defaultDocumentContext = await super.getData(this.options);
    Tidy5eBaseActorSheet.applyCommonContext(defaultDocumentContext);
    const npcPreferences = SheetPreferencesService.getByType(this.actor.type);
    const abilitiesSortMode = npcPreferences.tabs?.[CONSTANTS.TAB_NPC_ABILITIES]?.sort ?? "m";
    const spellbookSortMode = npcPreferences.tabs?.[CONSTANTS.TAB_NPC_SPELLBOOK]?.sort ?? "m";
    const actionListSortMode = npcPreferences.tabs?.[CONSTANTS.TAB_ACTOR_ACTIONS]?.sort ?? "m";
    const inventorySortMode = npcPreferences.tabs?.[CONSTANTS.TAB_NPC_INVENTORY]?.sort ?? "m";
    const unlocked = FoundryAdapter.isActorSheetUnlocked(this.actor) && defaultDocumentContext.editable;
    const lockSensitiveFields = !unlocked && SettingsProvider.settings.useTotalSheetLock.get() || !defaultDocumentContext.editable;
    let maxPreparedSpellsTotal = 0;
    try {
      const formula = TidyFlags.maxPreparedSpells.get(this.actor) ?? "";
      if (formula?.trim() !== "") {
        const roll = await Roll.create(
          formula,
          this.actor.getRollData()
        ).evaluate();
        maxPreparedSpellsTotal = roll.total;
      }
    } catch (e2) {
      error("Unable to calculate max prepared spells", false, e2);
    }
    const showLegendaryToolbarFlagValue = TidyFlags.showLegendaryToolbar.get(
      this.actor
    );
    const res = this.actor.system.resources;
    const showLegendaryToolbar = showLegendaryToolbarFlagValue === true || showLegendaryToolbarFlagValue === void 0 && ((res.legact?.max ?? 0) > 0 || (res.legres?.max ?? 0) > 0 || res.lair?.value === true || res.lair?.initiative !== null);
    let utilities = {
      [CONSTANTS.TAB_NPC_ABILITIES]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Commands.ShowLegendaryToolbar"
            ),
            iconClass: "ra ra-player",
            execute: async () => {
              await TidyFlags.showLegendaryToolbar.set(this.actor, true);
            },
            visible: !showLegendaryToolbar
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Commands.HideLegendaryToolbar"
            ),
            iconClass: "ra ra-monster-skull",
            execute: async () => {
              await TidyFlags.showLegendaryToolbar.set(this.actor, false);
            },
            visible: showLegendaryToolbar
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_NPC_ABILITIES,
                "sort",
                "m"
              );
            },
            visible: abilitiesSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeManual"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_NPC_ABILITIES,
                "sort",
                "a"
              );
            },
            visible: abilitiesSortMode === "m"
          },
          {
            title: "Spell Pips",
            iconClass: "fa-regular fa-circle-dot fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypePreference(
                this.actor.type,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PREFERENCE,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_VALUE_MAX
              );
            },
            visible: !SettingsProvider.settings.showSpellbookTabNpc.get() && (npcPreferences?.spellSlotTrackerMode ?? CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS) === CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS
          },
          {
            title: "Spell Value/Max",
            iconClass: "fa-regular fa-square fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypePreference(
                this.actor.type,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PREFERENCE,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS
              );
            },
            visible: !SettingsProvider.settings.showSpellbookTabNpc.get() && npcPreferences?.spellSlotTrackerMode === CONSTANTS.SPELL_SLOT_TRACKER_MODE_VALUE_MAX
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_NPC_ABILITIES,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_NPC_ABILITIES,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.features,
                tabId: CONSTANTS.TAB_NPC_ABILITIES,
                tabTitle: NpcSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_NPC_ABILITIES
                )
              }).render(true);
            }
          }
        ]
      },
      [CONSTANTS.TAB_NPC_SPELLBOOK]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_NPC_SPELLBOOK,
                "sort",
                "m"
              );
            },
            visible: spellbookSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeManual"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_NPC_SPELLBOOK,
                "sort",
                "a"
              );
            },
            visible: spellbookSortMode === "m"
          },
          {
            title: "Spell Pips",
            iconClass: "fa-regular fa-circle-dot fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypePreference(
                this.actor.type,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PREFERENCE,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_VALUE_MAX
              );
            },
            visible: (npcPreferences?.spellSlotTrackerMode ?? CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS) === CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS
          },
          {
            title: "Spell Value/Max",
            iconClass: "fa-regular fa-square fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypePreference(
                this.actor.type,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PREFERENCE,
                CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS
              );
            },
            visible: npcPreferences?.spellSlotTrackerMode === CONSTANTS.SPELL_SLOT_TRACKER_MODE_VALUE_MAX
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_NPC_SPELLBOOK,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_NPC_SPELLBOOK,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.ListLayout"),
            iconClass: "fas fa-th-list fa-fw toggle-list",
            visible: !TidyFlags.spellbookGrid.get(this.actor),
            execute: () => {
              TidyFlags.spellbookGrid.set(this.actor);
            }
          },
          {
            title: FoundryAdapter.localize("TIDY5E.GridLayout"),
            iconClass: "fas fa-th-large fa-fw toggle-grid",
            visible: !!TidyFlags.spellbookGrid.get(this.actor),
            execute: () => {
              TidyFlags.spellbookGrid.unset(this.actor);
            }
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.spellbook,
                tabId: CONSTANTS.TAB_NPC_SPELLBOOK,
                tabTitle: NpcSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_NPC_SPELLBOOK
                )
              }).render(true);
            }
          }
        ]
      },
      [CONSTANTS.TAB_ACTOR_ACTIONS]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_ACTOR_ACTIONS,
                "sort",
                "m"
              );
            },
            visible: actionListSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("TIDY5E.SortMode.ActionListDefault"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_ACTOR_ACTIONS,
                "sort",
                "a"
              );
            },
            visible: actionListSortMode === "m"
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.actions,
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                tabTitle: NpcSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_ACTOR_ACTIONS
                )
              }).render(true);
            }
          }
        ]
      },
      [CONSTANTS.TAB_NPC_INVENTORY]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_NPC_INVENTORY,
                "sort",
                "m"
              );
            },
            visible: inventorySortMode === "a"
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeManual"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_NPC_INVENTORY,
                "sort",
                "a"
              );
            },
            visible: inventorySortMode === "m"
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Commands.HideContainerPanel"
            ),
            iconClass: `fas fa-boxes-stacked fa-fw`,
            execute: () => {
              TidyFlags.showContainerPanel.unset(this.actor);
            },
            visible: !!TidyFlags.showContainerPanel.get(this.actor)
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Commands.ShowContainerPanel"
            ),
            iconClass: `fas fa-box fa-fw`,
            execute: () => {
              TidyFlags.showContainerPanel.set(this.actor, true);
            },
            visible: !TidyFlags.showContainerPanel.get(this.actor)
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_NPC_INVENTORY,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_NPC_INVENTORY,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.ListLayout"),
            iconClass: "fas fa-th-list fa-fw toggle-list",
            visible: !TidyFlags.inventoryGrid.get(this.actor),
            execute: () => {
              TidyFlags.inventoryGrid.set(this.actor);
            }
          },
          {
            title: FoundryAdapter.localize("TIDY5E.GridLayout"),
            iconClass: "fas fa-th-large fa-fw toggle-grid",
            visible: !!TidyFlags.inventoryGrid.get(this.actor),
            execute: () => {
              TidyFlags.inventoryGrid.unset(this.actor);
            }
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.inventory,
                tabId: CONSTANTS.TAB_NPC_INVENTORY,
                tabTitle: NpcSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_NPC_INVENTORY
                )
              }).render(true);
            }
          }
        ]
      }
    };
    let { conditions, effects: enhancedEffectSections } = await ConditionsAndEffects.getConditionsAndEffects(
      this.actor,
      this.object,
      defaultDocumentContext.effects
    );
    const context = {
      ...defaultDocumentContext,
      actions: await getActorActionSections(this.actor),
      activateEditors: (node, options2) => FoundryAdapter.activateEditors(node, this, options2?.bindSecrets),
      actorPortraitCommands: ActorPortraitRuntime.getEnabledPortraitMenuCommands(this.actor),
      allowEffectsManagement: true,
      appearanceEnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.appearance.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      appId: this.appId,
      biographyEnrichedHtml: await FoundryAdapter.enrichHtml(
        FoundryAdapter.getProperty(
          this.actor,
          `system.details.biography.value`
        ) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      bondEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.bond,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      conditions,
      containerPanelItems: await Inventory.getContainerPanelItems(
        defaultDocumentContext.items
      ),
      customActorTraits: CustomActorTraitsRuntime.getEnabledTraits(
        defaultDocumentContext
      ),
      customContent: await NpcSheetRuntime.getContent(defaultDocumentContext),
      useClassicControls: SettingsProvider.settings.useClassicControlsForNpc.get(),
      effects: enhancedEffectSections,
      editable: defaultDocumentContext.editable,
      encumbrance: this.actor.system.attributes.encumbrance,
      filterData: this.itemFilterService.getDocumentItemFilterData(),
      filterPins: ItemFilterRuntime.defaultFilterPins[this.actor.type],
      flawEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.flaw,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      hideEmptySpellbook: lockSensitiveFields && defaultDocumentContext.spellbook.length === 0,
      healthPercentage: getPercentage(
        this.actor?.system?.attributes?.hp?.value,
        this.actor?.system?.attributes?.hp?.max
      ),
      showSpellbookTab: SettingsProvider.settings.showSpellbookTabNpc.get(),
      idealEnrichedHtml: await FoundryAdapter.enrichHtml(
        this.actor.system.details.ideal,
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      showContainerPanel: TidyFlags.showContainerPanel.get(this.actor) === true && Array.from(defaultDocumentContext.items).some(
        (i2) => i2.type === CONSTANTS.ITEM_TYPE_CONTAINER
      ),
      showLegendaryToolbar,
      lockSensitiveFields,
      longRest: this._onLongRest.bind(this),
      lockExpChanges: FoundryAdapter.shouldLockExpChanges(),
      lockHpMaxChanges: FoundryAdapter.shouldLockHpMaxChanges(),
      lockItemQuantity: FoundryAdapter.shouldLockItemQuantity(),
      lockLevelSelector: FoundryAdapter.shouldLockLevelSelector(),
      lockMoneyChanges: FoundryAdapter.shouldLockMoneyChanges(),
      maxPreparedSpellsTotal,
      notes1EnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes1.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      notes2EnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes2.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      notes3EnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes3.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      notes4EnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes4.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      notesEnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.notes.members.value.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      owner: this.actor.isOwner,
      preparedSpells: FoundryAdapter.countPreparedSpells(
        defaultDocumentContext.items
      ),
      shortRest: this._onShortRest.bind(this),
      showLimitedSheet: FoundryAdapter.showLimitedSheet(this.actor),
      spellCalculations: calculateSpellAttackAndDc(this.actor),
      spellSlotTrackerMode: npcPreferences.spellSlotTrackerMode ?? CONSTANTS.SPELL_SLOT_TRACKER_MODE_PIPS,
      tabs: [],
      tokenState: this.#getTokenState(),
      traitEnrichedHtml: await FoundryAdapter.enrichHtml(
        TidyFlags.trait.get(this.actor) ?? "",
        {
          secrets: this.actor.isOwner,
          rollData: defaultDocumentContext.rollData,
          async: true,
          relativeTo: this.actor
        }
      ),
      unlocked,
      useActionsFeature: actorUsesActionFeature(this.actor),
      useRoundedPortraitStyle: [
        CONSTANTS.CIRCULAR_PORTRAIT_OPTION_ALL,
        CONSTANTS.CIRCULAR_PORTRAIT_OPTION_NPCVEHICLE
      ].includes(SettingsProvider.settings.useCircularPortraitStyle.get()),
      utilities,
      viewableWarnings: defaultDocumentContext.warnings?.filter(
        (w2) => !isNil(w2.message?.trim(), "")
      ) ?? []
    };
    for (const panelItem of context.containerPanelItems) {
      const ctx = context.itemContext[panelItem.container.id];
      ctx.containerContents = await Container.getContainerContents(
        panelItem.container
      );
    }
    let tabs = await NpcSheetRuntime.getTabs(context);
    const selectedTabs = TidyFlags.selectedTabs.get(context.actor);
    if (selectedTabs?.length) {
      tabs = tabs.filter((t2) => selectedTabs?.includes(t2.id)).sort(
        (a2, b2) => selectedTabs.indexOf(a2.id) - selectedTabs.indexOf(b2.id)
      );
    } else {
      const defaultTabs = SettingsProvider.settings.defaultNpcSheetTabs.get();
      tabs = tabs.filter((t2) => defaultTabs?.includes(t2.id)).sort((a2, b2) => defaultTabs.indexOf(a2.id) - defaultTabs.indexOf(b2.id));
    }
    context.tabs = tabs;
    TidyHooks.tidy5eSheetsPreConfigureSections(
      this,
      this.element.get(0),
      context
    );
    debug("NPC Sheet context data", context);
    return context;
  }
  _prepareItems(context) {
    const features = {
      [CONSTANTS.NPC_ABILITY_SECTION_WEAPONS]: {
        label: game.i18n.localize("DND5E.AttackPl"),
        items: [],
        hasActions: true,
        dataset: {
          type: CONSTANTS.ITEM_TYPE_WEAPON,
          "system.weaponType": "natural"
        },
        canCreate: true,
        key: "weapons",
        show: true
      },
      [CONSTANTS.NPC_ABILITY_SECTION_ACTIONS]: {
        label: game.i18n.localize("DND5E.ActionPl"),
        items: [],
        hasActions: true,
        dataset: {
          type: CONSTANTS.ITEM_TYPE_FEAT,
          "system.activation.type": "action"
        },
        canCreate: true,
        key: "actions",
        show: true
      },
      [CONSTANTS.NPC_ABILITY_SECTION_PASSIVE]: {
        label: game.i18n.localize("DND5E.Features"),
        items: [],
        dataset: { type: CONSTANTS.ITEM_TYPE_FEAT },
        canCreate: true,
        key: "passive",
        show: true
      },
      [CONSTANTS.NPC_ABILITY_SECTION_EQUIPMENT]: {
        label: game.i18n.localize("DND5E.Inventory"),
        items: [],
        dataset: { type: CONSTANTS.ITEM_TYPE_LOOT },
        canCreate: true,
        key: "equipment",
        show: true
      },
      [CONSTANTS.NPC_ABILITY_SECTION_CLASSES]: {
        label: `${CONFIG.Item.typeLabels.class}Pl`,
        items: [],
        dataset: { type: CONSTANTS.ITEM_TYPE_CLASS },
        canCreate: true,
        key: "classes",
        show: true,
        isClass: true
      }
    };
    let { spells, classes, subclasses, other } = context.items.reduce(
      (features2, item) => {
        const { quantity, uses, target } = item.system;
        const ctx = context.itemContext[item.id] ??= {};
        ctx.attunement = FoundryAdapter.getAttunementContext(item);
        ctx.isStack = Number.isNumeric(quantity) && quantity !== 1;
        ctx.hasUses = uses && uses.max > 0;
        ctx.hasTarget = !!target && !["none", ""].includes(target.type);
        ctx.canToggle = "equipped" in item.system;
        ctx.totalWeight = item.system.totalWeight?.toNearest(0.1);
        if (item.type === CONSTANTS.ITEM_TYPE_SPELL) {
          if (this._concentration.items.has(item)) {
            ctx.concentration = true;
          }
          features2.spells.push(item);
        } else if (item.type === CONSTANTS.ITEM_TYPE_CLASS) {
          features2.classes.push(item);
        } else if (item.type === CONSTANTS.ITEM_TYPE_SUBCLASS) {
          features2.subclasses.push(item);
        } else {
          features2.other.push(item);
        }
        return features2;
      },
      { spells: [], subclasses: [], classes: [], other: [] }
    );
    classes = SheetSections.prepareClassItems(
      context,
      classes,
      subclasses,
      this.actor
    );
    for (const subclass of subclasses) {
      const message = game.i18n.format("DND5E.SubclassMismatchWarn", {
        name: subclass.name,
        class: subclass.system.classIdentifier
      });
      context.warnings.push({ message, type: "warning" });
    }
    other = [...other, ...subclasses];
    features.classes.items = classes;
    const inventoryTypesArray = Inventory.getDefaultInventoryTypes();
    const inventoryTypes = new Set(inventoryTypesArray);
    const inventory = Inventory.getDefaultInventorySections();
    for (let item of other) {
      if (inventoryTypes.has(item.type)) {
        Inventory.applyInventoryItemToSection(
          inventory,
          item,
          inventoryTypesArray,
          {
            canCreate: true
          }
        );
      }
      if (TidyFlags.section.get(item)) {
        NpcSheetSections.applyAbilityToSection(features, item, {
          canCreate: true
        });
      } else if (item.type === CONSTANTS.ITEM_TYPE_WEAPON)
        features.weapons.items.push(item);
      else if ([
        CONSTANTS.ITEM_TYPE_BACKGROUND,
        CONSTANTS.ITEM_TYPE_CLASS,
        CONSTANTS.ITEM_TYPE_FEAT,
        CONSTANTS.ITEM_TYPE_RACE,
        CONSTANTS.ITEM_TYPE_SUBCLASS
      ].includes(item.type)) {
        if (item.system.activation?.type) {
          features.actions.items.push(item);
        } else {
          features.passive.items.push(item);
        }
      } else features.equipment.items.push(item);
    }
    const spellbook = SheetSections.prepareTidySpellbook(
      context,
      spells,
      {
        canCreate: true
      },
      this
    );
    context.features = Object.values(features);
    context.spellbook = spellbook;
    context.inventory = Object.values(inventory);
  }
  async setExpandedItemData() {
    this.expandedItemData.clear();
    for (const id of this.expandedItems.keys()) {
      const item = this.actor.items.get(id);
      if (item) {
        this.expandedItemData.set(
          id,
          await item.getChatData({ secrets: this.actor.isOwner })
        );
      }
    }
  }
  onToggleAbilityProficiency(event) {
    return this._onToggleAbilityProficiency(event);
  }
  #getTokenState() {
    const { token } = this;
    const showNpcActorLinkMarker = SettingsProvider.settings.showNpcActorLinkMarker.get();
    if (!token) {
      return null;
    }
    if (token.actorLink && showNpcActorLinkMarker == "both") {
      return "linked";
    }
    if (!token.actorLink && (showNpcActorLinkMarker == "unlinked" || showNpcActorLinkMarker == "both")) {
      return "unlinked";
    }
    return null;
  }
  async _onDropSingleItem(itemData) {
    if (itemData.type === CONSTANTS.ITEM_TYPE_SPELL && this.currentTabId === CONSTANTS.TAB_NPC_INVENTORY) {
      const options = {};
      if (SettingsProvider.settings.includeFlagsInSpellScrollCreation.get()) {
        options.flags = itemData.flags;
      }
      const scroll = await dnd5e.documents.Item5e.createScrollFromSpell(
        itemData,
        options
      );
      return scroll.toObject();
    }
    return super._onDropSingleItem(itemData);
  }
  _renderMutex = new AsyncMutex();
  async _render(force, options = {}) {
    if (typeof options !== "object") {
      options = {};
    }
    await this._renderMutex.lock(async () => {
      await this._renderSheet(force, options);
    });
  }
  async _renderSheet(force, options = {}) {
    await this.setExpandedItemData();
    const data = await this.getData();
    SheetSections.accountForExternalSections(["features", "spellbook"], data);
    this.context.set(data);
    if (force) {
      const { width, height } = SheetPreferencesService.getByType(this.actor.type) ?? {};
      this.position = {
        ...this.position,
        width: width ?? this.position.width,
        height: height ?? this.position.height
      };
      this._saveScrollPositions(this.element);
      this._destroySvelteComponent();
      await super._render(force, options);
      applySheetAttributesToWindow(
        this.actor.documentName,
        this.actor.type,
        SettingsProvider.settings.colorScheme.get(),
        this.element.get(0)
      );
      await this.renderCustomContent({ data, isFullRender: true });
      TidyHooks.tidy5eSheetsRenderActorSheet(
        this,
        this.element.get(0),
        data,
        true
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
      blurUntabbableButtonsOnClick(this.element);
      return;
    }
    await maintainCustomContentInputFocus(this, async () => {
      applyTitleToWindow(this.title, this.element.get(0));
      await this.renderCustomContent({ data, isFullRender: false });
      TidyHooks.tidy5eSheetsRenderActorSheet(
        this,
        this.element.get(0),
        data,
        false
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
    });
  }
  async renderCustomContent(args) {
    await CustomContentRenderer.render({
      app: this,
      customContent: args.data.customContent,
      data: args.data,
      element: this.element,
      isFullRender: args.isFullRender,
      superActivateListeners: super.activateListeners,
      tabs: args.data.tabs
    });
  }
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    return FoundryAdapter.removeConfigureSettingsButtonWhenLockedForNonGm(
      buttons
    );
  }
  _destroySvelteComponent() {
    this.component?.$destroy();
    this.component = void 0;
  }
  _saveScrollPositions(html) {
    if (html.length && this.component) {
      const save = super._saveScrollPositions(html);
      debug("Saved scroll positions", this._scrollPositions);
      return save;
    }
  }
  /**
   * Take a short rest, calling the relevant function on the Actor instance.
   * @param {Event} event             The triggering click event.
   * @returns {Promise<RestResult>}  Result of the rest action.
   */
  async _onShortRest(event) {
    event.preventDefault();
    await this._onSubmit(event);
    return this.actor.shortRest({
      chat: SettingsProvider.settings.showNpcRestInChat.get()
    });
  }
  /**
   * Take a long rest, calling the relevant function on the Actor instance
   * @param {Event} event   The triggering click event
   * @private
   */
  async _onLongRest(event) {
    event.preventDefault();
    await this._onSubmit(event);
    return this.actor.longRest({
      chat: SettingsProvider.settings.showNpcRestInChat.get()
    });
  }
  async _onSubmit(...args) {
    await super._onSubmit(...args);
    this.stats.update((stats) => {
      stats.lastSubmissionTime = /* @__PURE__ */ new Date();
      return stats;
    });
  }
  close(options = {}) {
    this._destroySvelteComponent();
    this.subscriptionsService.unsubscribeAll();
    return super.close(options);
  }
  _disableFields(...args) {
    debug("Ignoring call to disable fields. Delegating to Tidy Sheets...");
  }
  _onResize(event) {
    super._onResize(event);
    const { width, height } = this.position;
    SheetPreferencesService.setDocumentTypePreference(
      this.actor.type,
      "width",
      width
    );
    SheetPreferencesService.setDocumentTypePreference(
      this.actor.type,
      "height",
      height
    );
  }
  /* -------------------------------------------- */
  /* SheetTabCacheable
  /* -------------------------------------------- */
  onTabSelected(tabId) {
    this.currentTabId = tabId;
  }
  /* -------------------------------------------- */
  /* SheetExpandedItemsCacheable
  /* -------------------------------------------- */
  onItemToggled(itemId, isVisible, location) {
    const locationSet = this.expandedItems.get(itemId) ?? this.expandedItems.set(itemId, /* @__PURE__ */ new Set()).get(itemId);
    if (isVisible) {
      locationSet?.add(location);
    } else {
      locationSet?.delete(location);
    }
    debug("Item Toggled", {
      expandedItems: this.expandedItems
    });
  }
  /* -------------------------------------------- */
  /* SearchFilterCacheable
  /* -------------------------------------------- */
  onSearch(location, text2) {
    debug("Searched", {
      location,
      text: text2
    });
    this.searchFilters.set(location, text2);
  }
}
function create_fragment$f(ctx) {
  let div;
  let resourcewithbar;
  let current;
  resourcewithbar = new ResourceWithBar({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      value: (
        /*$context*/
        ctx[0].system.attributes.hp.value
      ),
      valueField: "system.attributes.hp.value",
      valueTitle: (
        /*localize*/
        ctx[3]("DND5E.HitPointsCurrent")
      ),
      valueDisabled: !/*$context*/
      ctx[0].editable,
      max: (
        /*$context*/
        ctx[0].system.attributes.hp.max
      ),
      maxField: "system.attributes.hp.max",
      maxTitle: (
        /*localize*/
        ctx[3]("DND5E.HitPointsMax")
      ),
      maxDisabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].lockHpMaxChanges || /*$context*/
      ctx[0].lockSensitiveFields,
      percentage: (
        /*$context*/
        ctx[0].healthPercentage
      ),
      Bar: (
        /*$settingStore*/
        ctx[1].useHpBarVehicle ? HpBar : null
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(resourcewithbar.$$.fragment);
      attr(div, "class", "portrait-hp svelte-1tj6d6i");
      attr(
        div,
        "title",
        /*localize*/
        ctx[3]("DND5E.HitPoints")
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(resourcewithbar, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const resourcewithbar_changes = {};
      if (dirty & /*$context*/
      1) resourcewithbar_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.value = /*$context*/
      ctx2[0].system.attributes.hp.value;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.valueDisabled = !/*$context*/
      ctx2[0].editable;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.max = /*$context*/
      ctx2[0].system.attributes.hp.max;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.maxDisabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].lockHpMaxChanges || /*$context*/
      ctx2[0].lockSensitiveFields;
      if (dirty & /*$context*/
      1) resourcewithbar_changes.percentage = /*$context*/
      ctx2[0].healthPercentage;
      if (dirty & /*$settingStore*/
      2) resourcewithbar_changes.Bar = /*$settingStore*/
      ctx2[1].useHpBarVehicle ? HpBar : null;
      resourcewithbar.$set(resourcewithbar_changes);
    },
    i(local) {
      if (current) return;
      transition_in(resourcewithbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resourcewithbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(resourcewithbar);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, $settingStore, context, localize];
}
class VehicleHitPoints extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$f, safe_not_equal, {});
  }
}
function create_fragment$e(ctx) {
  let div;
  let textinput0;
  let t2;
  let textinput1;
  let current;
  textinput0 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.attributes.hp.dt",
      cssClass: "damage-threshold",
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.Threshold")
      ),
      value: (
        /*$context*/
        ctx[0].system.attributes.hp.dt || null
      ),
      allowDeltaChanges: true,
      maxlength: 5,
      title: (
        /*localize*/
        ctx[2]("DND5E.DamageThreshold")
      ),
      disabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].lockSensitiveFields
    }
  });
  textinput1 = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.attributes.hp.mt",
      cssClass: "mishap-threshold",
      placeholder: (
        /*localize*/
        ctx[2]("DND5E.VehicleMishap")
      ),
      value: (
        /*$context*/
        ctx[0].system.attributes.hp.mt || null
      ),
      allowDeltaChanges: true,
      maxlength: 5,
      title: (
        /*localize*/
        ctx[2]("DND5E.VehicleMishapThreshold")
      ),
      disabled: !/*$context*/
      ctx[0].editable || /*$context*/
      ctx[0].lockSensitiveFields
    }
  });
  return {
    c() {
      div = element("div");
      create_component(textinput0.$$.fragment);
      t2 = space();
      create_component(textinput1.$$.fragment);
      attr(div, "class", "profile-thresholds svelte-1gso283");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(textinput0, div, null);
      append(div, t2);
      mount_component(textinput1, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput0_changes = {};
      if (dirty & /*$context*/
      1) textinput0_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput0_changes.value = /*$context*/
      ctx2[0].system.attributes.hp.dt || null;
      if (dirty & /*$context*/
      1) textinput0_changes.disabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].lockSensitiveFields;
      textinput0.$set(textinput0_changes);
      const textinput1_changes = {};
      if (dirty & /*$context*/
      1) textinput1_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) textinput1_changes.value = /*$context*/
      ctx2[0].system.attributes.hp.mt || null;
      if (dirty & /*$context*/
      1) textinput1_changes.disabled = !/*$context*/
      ctx2[0].editable || /*$context*/
      ctx2[0].lockSensitiveFields;
      textinput1.$set(textinput1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(textinput0.$$.fragment, local);
      transition_in(textinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput0.$$.fragment, local);
      transition_out(textinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(textinput0);
      destroy_component(textinput1);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class VehicleDamageAndMishapThresholds extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$e, safe_not_equal, {});
  }
}
function create_default_slot$6(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "motion-icon fas fa-sailboat");
      toggle_class(
        i2,
        "animate",
        /*animate*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*animate*/
      8) {
        toggle_class(
          i2,
          "animate",
          /*animate*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_fragment$d(ctx) {
  let div;
  let checkbox;
  let div_class_value;
  let div_title_value;
  let current;
  checkbox = new Checkbox({
    props: {
      checkboxCssClass: "motion-toggle",
      labelCssClass: (
        /*motion*/
        (ctx[0] ? "motion" : "") + " " + /*radiusClass*/
        ctx[2]
      ),
      document: (
        /*$context*/
        ctx[4].actor
      ),
      field: TidyFlags.motion.prop,
      checked: (
        /*motion*/
        ctx[0]
      ),
      disabled: !/*$context*/
      ctx[4].editable,
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(checkbox.$$.fragment);
      attr(div, "class", div_class_value = "motion " + /*cssClass*/
      ctx[1] + " svelte-1jcz2f");
      attr(div, "title", div_title_value = /*localize*/
      ctx[6](
        /*motion*/
        ctx[0] ? "TIDY5E.VehicleInMotion" : "TIDY5E.VehicleMotionless"
      ));
      toggle_class(
        div,
        "is-in-motion",
        /*motion*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkbox, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkbox_changes = {};
      if (dirty & /*motion, radiusClass*/
      5) checkbox_changes.labelCssClass = /*motion*/
      (ctx2[0] ? "motion" : "") + " " + /*radiusClass*/
      ctx2[2];
      if (dirty & /*$context*/
      16) checkbox_changes.document = /*$context*/
      ctx2[4].actor;
      if (dirty & /*motion*/
      1) checkbox_changes.checked = /*motion*/
      ctx2[0];
      if (dirty & /*$context*/
      16) checkbox_changes.disabled = !/*$context*/
      ctx2[4].editable;
      if (dirty & /*$$scope, animate*/
      136) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
      if (!current || dirty & /*cssClass*/
      2 && div_class_value !== (div_class_value = "motion " + /*cssClass*/
      ctx2[1] + " svelte-1jcz2f")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*motion*/
      1 && div_title_value !== (div_title_value = /*localize*/
      ctx2[6](
        /*motion*/
        ctx2[0] ? "TIDY5E.VehicleInMotion" : "TIDY5E.VehicleMotionless"
      ))) {
        attr(div, "title", div_title_value);
      }
      if (!current || dirty & /*cssClass, motion*/
      3) {
        toggle_class(
          div,
          "is-in-motion",
          /*motion*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(checkbox);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(4, $context = value));
  let { motion } = $$props;
  let { cssClass = "" } = $$props;
  let { radiusClass } = $$props;
  let { animate = true } = $$props;
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("motion" in $$props2) $$invalidate(0, motion = $$props2.motion);
    if ("cssClass" in $$props2) $$invalidate(1, cssClass = $$props2.cssClass);
    if ("radiusClass" in $$props2) $$invalidate(2, radiusClass = $$props2.radiusClass);
    if ("animate" in $$props2) $$invalidate(3, animate = $$props2.animate);
  };
  return [motion, cssClass, radiusClass, animate, $context, context, localize];
}
class VehicleMovement extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$d, safe_not_equal, {
      motion: 0,
      cssClass: 1,
      radiusClass: 2,
      animate: 3
    });
  }
}
function create_if_block_2$1(ctx) {
  let exhaustioninput;
  let current;
  exhaustioninput = new ExhaustionInput({
    props: {
      level: TidyFlags.exhaustion.get(
        /*$context*/
        ctx[0].actor
      ) ?? 0,
      radiusClass: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle ? "rounded" : "top-left"
      ),
      isActiveEffectApplied: ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx[0].actor,
        TidyFlags.exhaustion.prop
      )
    }
  });
  exhaustioninput.$on(
    "levelSelected",
    /*onLevelSelected*/
    ctx[3]
  );
  return {
    c() {
      create_component(exhaustioninput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exhaustioninput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exhaustioninput_changes = {};
      if (dirty & /*$context*/
      1) exhaustioninput_changes.level = TidyFlags.exhaustion.get(
        /*$context*/
        ctx2[0].actor
      ) ?? 0;
      if (dirty & /*$context*/
      1) exhaustioninput_changes.radiusClass = /*$context*/
      ctx2[0].useRoundedPortraitStyle ? "rounded" : "top-left";
      if (dirty & /*$context*/
      1) exhaustioninput_changes.isActiveEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx2[0].actor,
        TidyFlags.exhaustion.prop
      );
      exhaustioninput.$set(exhaustioninput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(exhaustioninput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exhaustioninput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exhaustioninput, detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let exhaustiontracker;
  let current;
  exhaustiontracker = new ExhaustionTracker({
    props: {
      level: TidyFlags.exhaustion.get(
        /*$context*/
        ctx[0].actor
      ) ?? 0,
      radiusClass: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle ? "rounded" : "top-left"
      ),
      exhaustionConfig: (
        /*$settingStore*/
        ctx[1].vehicleExhaustionConfig
      ),
      isActiveEffectApplied: ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx[0].actor,
        TidyFlags.exhaustion.prop
      )
    }
  });
  exhaustiontracker.$on(
    "levelSelected",
    /*onLevelSelected*/
    ctx[3]
  );
  return {
    c() {
      create_component(exhaustiontracker.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exhaustiontracker, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exhaustiontracker_changes = {};
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.level = TidyFlags.exhaustion.get(
        /*$context*/
        ctx2[0].actor
      ) ?? 0;
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.radiusClass = /*$context*/
      ctx2[0].useRoundedPortraitStyle ? "rounded" : "top-left";
      if (dirty & /*$settingStore*/
      2) exhaustiontracker_changes.exhaustionConfig = /*$settingStore*/
      ctx2[1].vehicleExhaustionConfig;
      if (dirty & /*$context*/
      1) exhaustiontracker_changes.isActiveEffectApplied = ActiveEffectsHelper.isActiveEffectAppliedToField(
        /*$context*/
        ctx2[0].actor,
        TidyFlags.exhaustion.prop
      );
      exhaustiontracker.$set(exhaustiontracker_changes);
    },
    i(local) {
      if (current) return;
      transition_in(exhaustiontracker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exhaustiontracker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exhaustiontracker, detaching);
    }
  };
}
function create_if_block$3(ctx) {
  let vehiclemovement;
  let current;
  vehiclemovement = new VehicleMovement({
    props: {
      motion: TidyFlags.motion.get(
        /*$context*/
        ctx[0].actor
      ) === true,
      radiusClass: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle ? "rounded" : "top-right"
      ),
      animate: true
    }
  });
  return {
    c() {
      create_component(vehiclemovement.$$.fragment);
    },
    m(target, anchor) {
      mount_component(vehiclemovement, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const vehiclemovement_changes = {};
      if (dirty & /*$context*/
      1) vehiclemovement_changes.motion = TidyFlags.motion.get(
        /*$context*/
        ctx2[0].actor
      ) === true;
      if (dirty & /*$context*/
      1) vehiclemovement_changes.radiusClass = /*$context*/
      ctx2[0].useRoundedPortraitStyle ? "rounded" : "top-right";
      vehiclemovement.$set(vehiclemovement_changes);
    },
    i(local) {
      if (current) return;
      transition_in(vehiclemovement.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(vehiclemovement.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(vehiclemovement, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let vehiclehitpoints;
  let current;
  const if_block_creators = [create_if_block_1$2, create_if_block_2$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$settingStore*/
      ctx2[1].useExhaustion && /*$settingStore*/
      ctx2[1].vehicleExhaustionConfig.type === "specific"
    ) return 0;
    if (
      /*$settingStore*/
      ctx2[1].useExhaustion && /*$settingStore*/
      ctx2[1].vehicleExhaustionConfig.type === "open"
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*$settingStore*/
    ctx[1].useVehicleMotion && create_if_block$3(ctx)
  );
  vehiclehitpoints = new VehicleHitPoints({});
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      create_component(vehiclehitpoints.$$.fragment);
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(vehiclehitpoints, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*$settingStore*/
        ctx2[1].useVehicleMotion
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$settingStore*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(vehiclehitpoints.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(vehiclehitpoints.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (if_block1) if_block1.d(detaching);
      destroy_component(vehiclehitpoints, detaching);
    }
  };
}
function create_fragment$c(ctx) {
  let actorprofile;
  let t2;
  let vehicledamageandmishapthresholds;
  let current;
  actorprofile = new ActorProfile({
    props: {
      useHpOverlay: (
        /*$settingStore*/
        ctx[1].useHpOverlayVehicle
      ),
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  vehicledamageandmishapthresholds = new VehicleDamageAndMishapThresholds({});
  return {
    c() {
      create_component(actorprofile.$$.fragment);
      t2 = space();
      create_component(vehicledamageandmishapthresholds.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actorprofile, target, anchor);
      insert(target, t2, anchor);
      mount_component(vehicledamageandmishapthresholds, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const actorprofile_changes = {};
      if (dirty & /*$settingStore*/
      2) actorprofile_changes.useHpOverlay = /*$settingStore*/
      ctx2[1].useHpOverlayVehicle;
      if (dirty & /*$$scope, $context, $settingStore*/
      19) {
        actorprofile_changes.$$scope = { dirty, ctx: ctx2 };
      }
      actorprofile.$set(actorprofile_changes);
    },
    i(local) {
      if (current) return;
      transition_in(actorprofile.$$.fragment, local);
      transition_in(vehicledamageandmishapthresholds.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorprofile.$$.fragment, local);
      transition_out(vehicledamageandmishapthresholds.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(actorprofile, detaching);
      destroy_component(vehicledamageandmishapthresholds, detaching);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(1, $settingStore = $$value));
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  function onLevelSelected(event) {
    TidyFlags.setFlag($context.actor, "exhaustion", event.detail.level);
  }
  return [$context, $settingStore, context, onLevelSelected];
}
class VehicleProfile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$c, safe_not_equal, {});
  }
}
function create_default_slot$4(ctx) {
  let numberinput;
  let t2;
  let textinput;
  let current;
  numberinput = new NumberInput({
    props: {
      document: (
        /*$context*/
        ctx[1].actor
      ),
      field: "system.attributes.ac.flat",
      value: (
        /*$context*/
        ctx[1].actor.system.attributes.ac.flat
      ),
      step: "1",
      min: "0",
      placeholder: "",
      title: (
        /*localize*/
        ctx[3]("DND5E.ArmorClass")
      ),
      cssClass: "armor-class-flat",
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[1].editable || /*$context*/
      ctx[1].lockSensitiveFields
    }
  });
  textinput = new TextInput$1({
    props: {
      document: (
        /*$context*/
        ctx[1].actor
      ),
      field: "system.attributes.ac.motionless",
      value: (
        /*$context*/
        ctx[1].system.attributes.ac.motionless
      ),
      placeholder: "",
      title: (
        /*localize*/
        ctx[3]("DND5E.ArmorClassMotionless")
      ),
      cssClass: "armor-class-motionless",
      selectOnFocus: true,
      disabled: !/*$context*/
      ctx[1].editable || /*$context*/
      ctx[1].lockSensitiveFields
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
      t2 = space();
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      insert(target, t2, anchor);
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & /*$context*/
      2) numberinput_changes.document = /*$context*/
      ctx2[1].actor;
      if (dirty & /*$context*/
      2) numberinput_changes.value = /*$context*/
      ctx2[1].actor.system.attributes.ac.flat;
      if (dirty & /*$context*/
      2) numberinput_changes.disabled = !/*$context*/
      ctx2[1].editable || /*$context*/
      ctx2[1].lockSensitiveFields;
      numberinput.$set(numberinput_changes);
      const textinput_changes = {};
      if (dirty & /*$context*/
      2) textinput_changes.document = /*$context*/
      ctx2[1].actor;
      if (dirty & /*$context*/
      2) textinput_changes.value = /*$context*/
      ctx2[1].system.attributes.ac.motionless;
      if (dirty & /*$context*/
      2) textinput_changes.disabled = !/*$context*/
      ctx2[1].editable || /*$context*/
      ctx2[1].lockSensitiveFields;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current) return;
      transition_in(numberinput.$$.fragment, local);
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(numberinput, detaching);
      destroy_component(textinput, detaching);
    }
  };
}
function create_fragment$b(ctx) {
  let div;
  let acshieldbase;
  let current;
  acshieldbase = new AcShieldBase({
    props: {
      cssClass: (
        /*cssClass*/
        ctx[0] + " vehicle-ac-shield"
      ),
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(acshieldbase.$$.fragment);
      attr(div, "class", "vehicle-armor-class-wrapper svelte-1xh55vz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(acshieldbase, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const acshieldbase_changes = {};
      if (dirty & /*cssClass*/
      1) acshieldbase_changes.cssClass = /*cssClass*/
      ctx2[0] + " vehicle-ac-shield";
      if (dirty & /*$$scope, $context*/
      18) {
        acshieldbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      acshieldbase.$set(acshieldbase_changes);
    },
    i(local) {
      if (current) return;
      transition_in(acshieldbase.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(acshieldbase.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(acshieldbase);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(1, $context = value));
  let { cssClass = "" } = $$props;
  const localize = FoundryAdapter.localize;
  $$self.$$set = ($$props2) => {
    if ("cssClass" in $$props2) $$invalidate(0, cssClass = $$props2.cssClass);
  };
  return [cssClass, $context, context, localize];
}
class AcShieldVehicle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$b, safe_not_equal, { cssClass: 0 });
  }
}
function get_each_context$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2][0];
  child_ctx[15] = list[i2][1];
  return child_ctx;
}
function create_if_block_5(ctx) {
  let iteminfocard;
  let current;
  iteminfocard = new ItemInfoCard({});
  return {
    c() {
      create_component(iteminfocard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iteminfocard, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(iteminfocard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iteminfocard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iteminfocard, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let actorwarnings;
  let current;
  actorwarnings = new ActorWarnings({
    props: {
      warnings: (
        /*$context*/
        ctx[0].viewableWarnings
      )
    }
  });
  return {
    c() {
      create_component(actorwarnings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actorwarnings, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actorwarnings_changes = {};
      if (dirty & /*$context*/
      1) actorwarnings_changes.warnings = /*$context*/
      ctx2[0].viewableWarnings;
      actorwarnings.$set(actorwarnings_changes);
    },
    i(local) {
      if (current) return;
      transition_in(actorwarnings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorwarnings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actorwarnings, detaching);
    }
  };
}
function create_else_block_1(ctx) {
  let span;
  let t_value = (
    /*currentSize*/
    ctx[2].text + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(
        span,
        "title",
        /*localize*/
        ctx[9]("DND5E.Size")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*currentSize*/
      4 && t_value !== (t_value = /*currentSize*/
      ctx2[2].text + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3(ctx) {
  let inlinetextdropdownlist;
  let current;
  inlinetextdropdownlist = new InlineTextDropdownList({
    props: {
      options: (
        /*sizes*/
        ctx[6]
      ),
      selected: (
        /*currentSize*/
        ctx[2]
      ),
      title: (
        /*localize*/
        ctx[9]("DND5E.Size")
      )
    }
  });
  inlinetextdropdownlist.$on(
    "optionClicked",
    /*optionClicked_handler*/
    ctx[10]
  );
  return {
    c() {
      create_component(inlinetextdropdownlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinetextdropdownlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinetextdropdownlist_changes = {};
      if (dirty & /*sizes*/
      64) inlinetextdropdownlist_changes.options = /*sizes*/
      ctx2[6];
      if (dirty & /*currentSize*/
      4) inlinetextdropdownlist_changes.selected = /*currentSize*/
      ctx2[2];
      inlinetextdropdownlist.$set(inlinetextdropdownlist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinetextdropdownlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetextdropdownlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetextdropdownlist, detaching);
    }
  };
}
function create_else_block$1(ctx) {
  let span;
  let t_value = (
    /*currentVehicleType*/
    ctx[3].text + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(
        span,
        "title",
        /*localize*/
        ctx[9]("DND5E.VehicleType")
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*currentVehicleType*/
      8 && t_value !== (t_value = /*currentVehicleType*/
      ctx2[3].text + "")) set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let inlinetextdropdownlist;
  let current;
  inlinetextdropdownlist = new InlineTextDropdownList({
    props: {
      options: (
        /*vehicleTypes*/
        ctx[5]
      ),
      selected: (
        /*currentVehicleType*/
        ctx[3]
      ),
      title: (
        /*localize*/
        ctx[9]("DND5E.VehicleType")
      )
    }
  });
  inlinetextdropdownlist.$on(
    "optionClicked",
    /*optionClicked_handler_1*/
    ctx[11]
  );
  return {
    c() {
      create_component(inlinetextdropdownlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinetextdropdownlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinetextdropdownlist_changes = {};
      if (dirty & /*vehicleTypes*/
      32) inlinetextdropdownlist_changes.options = /*vehicleTypes*/
      ctx2[5];
      if (dirty & /*currentVehicleType*/
      8) inlinetextdropdownlist_changes.selected = /*currentVehicleType*/
      ctx2[3];
      inlinetextdropdownlist.$set(inlinetextdropdownlist_changes);
    },
    i(local) {
      if (current) return;
      transition_in(inlinetextdropdownlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetextdropdownlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetextdropdownlist, detaching);
    }
  };
}
function create_default_slot$3(ctx) {
  let contenteditableformfield;
  let t2;
  let inlinesource;
  let current;
  contenteditableformfield = new ContentEditableFormField({
    props: {
      element: "span",
      document: (
        /*$context*/
        ctx[0].actor
      ),
      field: "system.traits.dimensions",
      value: (
        /*$context*/
        ctx[0].system.traits.dimensions
      ),
      title: (
        /*$context*/
        ctx[0].system.traits.dimensions
      ),
      editable: (
        /*$context*/
        ctx[0].editable && !/*$context*/
        ctx[0].lockSensitiveFields
      ),
      placeholder: (
        /*localize*/
        ctx[9]("DND5E.Dimensions")
      ),
      selectOnFocus: true
    }
  });
  inlinesource = new InlineSource({
    props: {
      document: (
        /*$context*/
        ctx[0].actor
      ),
      keyPath: "system.details.source",
      editable: (
        /*$context*/
        ctx[0].unlocked
      )
    }
  });
  return {
    c() {
      create_component(contenteditableformfield.$$.fragment);
      t2 = space();
      create_component(inlinesource.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contenteditableformfield, target, anchor);
      insert(target, t2, anchor);
      mount_component(inlinesource, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const contenteditableformfield_changes = {};
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.value = /*$context*/
      ctx2[0].system.traits.dimensions;
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.title = /*$context*/
      ctx2[0].system.traits.dimensions;
      if (dirty & /*$context*/
      1) contenteditableformfield_changes.editable = /*$context*/
      ctx2[0].editable && !/*$context*/
      ctx2[0].lockSensitiveFields;
      contenteditableformfield.$set(contenteditableformfield_changes);
      const inlinesource_changes = {};
      if (dirty & /*$context*/
      1) inlinesource_changes.document = /*$context*/
      ctx2[0].actor;
      if (dirty & /*$context*/
      1) inlinesource_changes.editable = /*$context*/
      ctx2[0].unlocked;
      inlinesource.$set(inlinesource_changes);
    },
    i(local) {
      if (current) return;
      transition_in(contenteditableformfield.$$.fragment, local);
      transition_in(inlinesource.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contenteditableformfield.$$.fragment, local);
      transition_out(inlinesource.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(contenteditableformfield, detaching);
      destroy_component(inlinesource, detaching);
    }
  };
}
function create_key_block(ctx) {
  let delimitedtruncatedcontent;
  let current;
  delimitedtruncatedcontent = new DelimitedTruncatedContent({
    props: {
      cssClass: "flex-1",
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(delimitedtruncatedcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(delimitedtruncatedcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const delimitedtruncatedcontent_changes = {};
      if (dirty & /*$$scope, $context*/
      262145) {
        delimitedtruncatedcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      delimitedtruncatedcontent.$set(delimitedtruncatedcontent_changes);
    },
    i(local) {
      if (current) return;
      transition_in(delimitedtruncatedcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(delimitedtruncatedcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(delimitedtruncatedcontent, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let button;
  let i2;
  let button_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fas fa-cog");
      attr(button, "type", "button");
      attr(button, "class", "origin-summary-tidy inline-icon-button");
      attr(
        button,
        "title",
        /*localize*/
        ctx[9]("TIDY5E.OriginSummaryConfig")
      );
      attr(button, "tabindex", button_tabindex_value = /*$settingStore*/
      ctx[7].useAccessibleKeyboardSupport ? 0 : -1);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[12]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settingStore*/
      128 && button_tabindex_value !== (button_tabindex_value = /*$settingStore*/
      ctx2[7].useAccessibleKeyboardSupport ? 0 : -1)) {
        attr(button, "tabindex", button_tabindex_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$2(ctx) {
  let verticallineseparator;
  let t0;
  let div;
  let attributeblock;
  let t1;
  let current;
  verticallineseparator = new VerticalLineSeparator({});
  attributeblock = new AttributeBlock({
    props: {
      id: (
        /*id*/
        ctx[14]
      ),
      ability: (
        /*ability*/
        ctx[15]
      ),
      useConfigurationOption: false,
      useSavingThrowProficiency: false
    }
  });
  return {
    c() {
      create_component(verticallineseparator.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(attributeblock.$$.fragment);
      t1 = space();
    },
    m(target, anchor) {
      mount_component(verticallineseparator, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(attributeblock, div, null);
      append(div, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const attributeblock_changes = {};
      if (dirty & /*abilities*/
      16) attributeblock_changes.id = /*id*/
      ctx2[14];
      if (dirty & /*abilities*/
      16) attributeblock_changes.ability = /*ability*/
      ctx2[15];
      attributeblock.$set(attributeblock_changes);
    },
    i(local) {
      if (current) return;
      transition_in(verticallineseparator.$$.fragment, local);
      transition_in(attributeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(verticallineseparator.$$.fragment, local);
      transition_out(attributeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
      destroy_component(verticallineseparator, detaching);
      destroy_component(attributeblock);
    }
  };
}
function create_if_block$2(ctx) {
  let alloweditlock;
  let current;
  alloweditlock = new AllowEditLock({
    props: {
      hint: (
        /*$settingStore*/
        ctx[7].permanentlyUnlockVehicleSheetForGm && FoundryAdapter.userIsGm() ? (
          /*localize*/
          ctx[9]("TIDY5E.Settings.PermanentlyUnlockVehicleSheetForGM.title")
        ) : null
      )
    }
  });
  return {
    c() {
      create_component(alloweditlock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(alloweditlock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const alloweditlock_changes = {};
      if (dirty & /*$settingStore*/
      128) alloweditlock_changes.hint = /*$settingStore*/
      ctx2[7].permanentlyUnlockVehicleSheetForGm && FoundryAdapter.userIsGm() ? (
        /*localize*/
        ctx2[9]("TIDY5E.Settings.PermanentlyUnlockVehicleSheetForGM.title")
      ) : null;
      alloweditlock.$set(alloweditlock_changes);
    },
    i(local) {
      if (current) return;
      transition_in(alloweditlock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(alloweditlock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(alloweditlock, detaching);
    }
  };
}
function create_tab_end_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$context*/
    ctx[0].editable && create_if_block$2(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$context*/
        ctx2[0].editable
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_fragment$a(ctx) {
  let t0;
  let t1;
  let header;
  let div0;
  let vehicleprofile;
  let t2;
  let div7;
  let div2;
  let div1;
  let actorname;
  let t3;
  let sheetmenu;
  let t4;
  let horizontallineseparator0;
  let t5;
  let div6;
  let div3;
  let current_block_type_index;
  let if_block2;
  let t6;
  let span0;
  let t8;
  let div4;
  let current_block_type_index_1;
  let if_block3;
  let t9;
  let span1;
  let t11;
  let previous_key = (
    /*$context*/
    ctx[0].lockSensitiveFields
  );
  let t12;
  let div5;
  let t13;
  let horizontallineseparator1;
  let t14;
  let actormovement;
  let t15;
  let horizontallineseparator2;
  let t16;
  let section0;
  let acshieldvehicle;
  let t17;
  let t18;
  let tabs;
  let updating_selectedTabId;
  let t19;
  let section1;
  let tabcontents;
  let current;
  let if_block0 = (
    /*$settingStore*/
    ctx[7].itemCardsForNpcs && create_if_block_5()
  );
  let if_block1 = (
    /*$context*/
    ctx[0].viewableWarnings.length && create_if_block_4(ctx)
  );
  vehicleprofile = new VehicleProfile({});
  actorname = new ActorName({});
  sheetmenu = new SheetMenu({
    props: {
      defaultSettingsTab: CONSTANTS.TAB_USER_SETTINGS_VEHICLES
    }
  });
  horizontallineseparator0 = new HorizontalLineSeparator({ props: { borderColor: "light" } });
  const if_block_creators = [create_if_block_3, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].editable
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block_2, create_else_block$1];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].editable
    ) return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx);
  if_block3 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  let key_block = create_key_block(ctx);
  let if_block4 = (
    /*$context*/
    ctx[0].editable && !/*$context*/
    ctx[0].lockSensitiveFields && create_if_block_1$1(ctx)
  );
  horizontallineseparator1 = new HorizontalLineSeparator({ props: { borderColor: "light" } });
  actormovement = new ActorMovement({});
  horizontallineseparator2 = new HorizontalLineSeparator({ props: { borderColor: "light" } });
  acshieldvehicle = new AcShieldVehicle({});
  let each_value = ensure_array_like(
    /*abilities*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$2(get_each_context$2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  function tabs_selectedTabId_binding(value) {
    ctx[13](value);
  }
  let tabs_props = {
    tabs: (
      /*$context*/
      ctx[0].tabs
    ),
    $$slots: { "tab-end": [create_tab_end_slot] },
    $$scope: { ctx }
  };
  if (
    /*selectedTabId*/
    ctx[1] !== void 0
  ) {
    tabs_props.selectedTabId = /*selectedTabId*/
    ctx[1];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind(tabs, "selectedTabId", tabs_selectedTabId_binding));
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*$context*/
        ctx[0].tabs
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      header = element("header");
      div0 = element("div");
      create_component(vehicleprofile.$$.fragment);
      t2 = space();
      div7 = element("div");
      div2 = element("div");
      div1 = element("div");
      create_component(actorname.$$.fragment);
      t3 = space();
      create_component(sheetmenu.$$.fragment);
      t4 = space();
      create_component(horizontallineseparator0.$$.fragment);
      t5 = space();
      div6 = element("div");
      div3 = element("div");
      if_block2.c();
      t6 = space();
      span0 = element("span");
      span0.textContent = "";
      t8 = space();
      div4 = element("div");
      if_block3.c();
      t9 = space();
      span1 = element("span");
      span1.textContent = "";
      t11 = space();
      key_block.c();
      t12 = space();
      div5 = element("div");
      if (if_block4) if_block4.c();
      t13 = space();
      create_component(horizontallineseparator1.$$.fragment);
      t14 = space();
      create_component(actormovement.$$.fragment);
      t15 = space();
      create_component(horizontallineseparator2.$$.fragment);
      t16 = space();
      section0 = element("section");
      create_component(acshieldvehicle.$$.fragment);
      t17 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t18 = space();
      create_component(tabs.$$.fragment);
      t19 = space();
      section1 = element("section");
      create_component(tabcontents.$$.fragment);
      attr(div0, "class", "flex-0");
      attr(div1, "class", "actor-name");
      attr(div1, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_CONTAINER);
      attr(div2, "class", "actor-name-row flex-row justify-content-space-between align-items-center small-gap svelte-lqhlrq");
      attr(div2, "data-tidy-sheet-part", CONSTANTS.SHEET_PARTS.NAME_HEADER_ROW);
      attr(div3, "class", "flex-row extra-small-gap");
      attr(div4, "class", "flex-row extra-small-gap");
      attr(div5, "class", "flex-row align-items-center extra-small-gap");
      attr(div6, "class", "origin-summary svelte-lqhlrq");
      attr(section0, "class", "actor-stats");
      attr(div7, "class", "flex-grow-1");
      attr(header, "class", "svelte-lqhlrq");
      attr(section1, "class", "tidy-sheet-body svelte-lqhlrq");
    },
    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, header, anchor);
      append(header, div0);
      mount_component(vehicleprofile, div0, null);
      append(header, t2);
      append(header, div7);
      append(div7, div2);
      append(div2, div1);
      mount_component(actorname, div1, null);
      append(div2, t3);
      mount_component(sheetmenu, div2, null);
      append(div7, t4);
      mount_component(horizontallineseparator0, div7, null);
      append(div7, t5);
      append(div7, div6);
      append(div6, div3);
      if_blocks[current_block_type_index].m(div3, null);
      append(div6, t6);
      append(div6, span0);
      append(div6, t8);
      append(div6, div4);
      if_blocks_1[current_block_type_index_1].m(div4, null);
      append(div6, t9);
      append(div6, span1);
      append(div6, t11);
      key_block.m(div6, null);
      append(div6, t12);
      append(div6, div5);
      if (if_block4) if_block4.m(div5, null);
      append(div7, t13);
      mount_component(horizontallineseparator1, div7, null);
      append(div7, t14);
      mount_component(actormovement, div7, null);
      append(div7, t15);
      mount_component(horizontallineseparator2, div7, null);
      append(div7, t16);
      append(div7, section0);
      mount_component(acshieldvehicle, section0, null);
      append(section0, t17);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section0, null);
        }
      }
      insert(target, t18, anchor);
      mount_component(tabs, target, anchor);
      insert(target, t19, anchor);
      insert(target, section1, anchor);
      mount_component(tabcontents, section1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$settingStore*/
        ctx2[7].itemCardsForNpcs
      ) {
        if (if_block0) {
          if (dirty & /*$settingStore*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$context*/
        ctx2[0].viewableWarnings.length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$context*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div3, null);
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block3 = if_blocks_1[current_block_type_index_1];
        if (!if_block3) {
          if_block3 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block3.c();
        } else {
          if_block3.p(ctx2, dirty);
        }
        transition_in(if_block3, 1);
        if_block3.m(div4, null);
      }
      if (dirty & /*$context*/
      1 && safe_not_equal(previous_key, previous_key = /*$context*/
      ctx2[0].lockSensitiveFields)) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div6, t12);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (
        /*$context*/
        ctx2[0].editable && !/*$context*/
        ctx2[0].lockSensitiveFields
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_1$1(ctx2);
          if_block4.c();
          if_block4.m(div5, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (dirty & /*abilities*/
      16) {
        each_value = ensure_array_like(
          /*abilities*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(section0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const tabs_changes = {};
      if (dirty & /*$context*/
      1) tabs_changes.tabs = /*$context*/
      ctx2[0].tabs;
      if (dirty & /*$$scope, $settingStore, $context*/
      262273) {
        tabs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      2) {
        updating_selectedTabId = true;
        tabs_changes.selectedTabId = /*selectedTabId*/
        ctx2[1];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs.$set(tabs_changes);
      const tabcontents_changes = {};
      if (dirty & /*$context*/
      1) tabcontents_changes.tabs = /*$context*/
      ctx2[0].tabs;
      if (dirty & /*selectedTabId*/
      2) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[1];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(vehicleprofile.$$.fragment, local);
      transition_in(actorname.$$.fragment, local);
      transition_in(sheetmenu.$$.fragment, local);
      transition_in(horizontallineseparator0.$$.fragment, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(key_block);
      transition_in(horizontallineseparator1.$$.fragment, local);
      transition_in(actormovement.$$.fragment, local);
      transition_in(horizontallineseparator2.$$.fragment, local);
      transition_in(acshieldvehicle.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(tabs.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(vehicleprofile.$$.fragment, local);
      transition_out(actorname.$$.fragment, local);
      transition_out(sheetmenu.$$.fragment, local);
      transition_out(horizontallineseparator0.$$.fragment, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(key_block);
      transition_out(horizontallineseparator1.$$.fragment, local);
      transition_out(actormovement.$$.fragment, local);
      transition_out(horizontallineseparator2.$$.fragment, local);
      transition_out(acshieldvehicle.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(tabs.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(header);
        detach(t18);
        detach(t19);
        detach(section1);
      }
      if (if_block0) if_block0.d(detaching);
      if (if_block1) if_block1.d(detaching);
      destroy_component(vehicleprofile);
      destroy_component(actorname);
      destroy_component(sheetmenu);
      destroy_component(horizontallineseparator0);
      if_blocks[current_block_type_index].d();
      if_blocks_1[current_block_type_index_1].d();
      key_block.d(detaching);
      if (if_block4) if_block4.d();
      destroy_component(horizontallineseparator1);
      destroy_component(actormovement);
      destroy_component(horizontallineseparator2);
      destroy_component(acshieldvehicle);
      destroy_each(each_blocks, detaching);
      destroy_component(tabs, detaching);
      destroy_component(tabcontents);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let sizes;
  let vehicleTypes;
  let abilities;
  let $context;
  let $settingStore;
  component_subscribe($$self, settingStore, ($$value) => $$invalidate(7, $settingStore = $$value));
  let selectedTabId;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let currentSize;
  let currentVehicleType;
  const localize = FoundryAdapter.localize;
  const optionClicked_handler = (event) => $context.actor.update({ "system.traits.size": event.detail.value });
  const optionClicked_handler_1 = (event) => $context.actor.update({ "system.vehicleType": event.detail.value });
  const click_handler = () => new ActorOriginSummaryConfigFormApplication($context.actor).render(true);
  function tabs_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(1, selectedTabId);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(6, sizes = Object.entries($context.config.actorSizes).map(([key, size]) => ({ value: key, text: size.label })));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(2, currentSize = {
        value: $context.system.traits.size,
        text: $context.config.actorSizes[$context.system.traits.size]?.label
      });
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(5, vehicleTypes = Object.entries($context.config.vehicleTypes).map(([key, label]) => ({ value: key, text: label })));
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(3, currentVehicleType = {
        value: $context.system.vehicleType,
        text: $context.config.vehicleTypes[$context.system.vehicleType]
      });
    }
    if ($$self.$$.dirty & /*$context*/
    1) {
      $$invalidate(4, abilities = Object.entries($context.abilities));
    }
  };
  return [
    $context,
    selectedTabId,
    currentSize,
    currentVehicleType,
    abilities,
    vehicleTypes,
    sizes,
    $settingStore,
    context,
    localize,
    optionClicked_handler,
    optionClicked_handler_1,
    click_handler,
    tabs_selectedTabId_binding
  ];
}
class VehicleSheetFull extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$a, safe_not_equal, {});
  }
}
function create_default_slot$2(ctx) {
  let article;
  let div;
  let t1;
  let sheeteditor;
  let current;
  let mounted;
  let dispose;
  sheeteditor = new SheetEditor({
    props: {
      content: (
        /*$context*/
        ctx[0].biographyHTML
      ),
      target: "system.details.biography.value",
      editable: (
        /*$context*/
        ctx[0].editable
      )
    }
  });
  return {
    c() {
      article = element("article");
      div = element("div");
      div.textContent = `${/*localize*/
      ctx[2]("DND5E.Description")}`;
      t1 = space();
      create_component(sheeteditor.$$.fragment);
      attr(div, "class", "section-titles");
      attr(article, "class", "biography-notes");
    },
    m(target, anchor) {
      insert(target, article, anchor);
      append(article, div);
      append(article, t1);
      mount_component(sheeteditor, article, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*$context*/
          ctx[0].activateEditors(article)
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sheeteditor_changes = {};
      if (dirty & /*$context*/
      1) sheeteditor_changes.content = /*$context*/
      ctx2[0].biographyHTML;
      if (dirty & /*$context*/
      1) sheeteditor_changes.editable = /*$context*/
      ctx2[0].editable;
      sheeteditor.$set(sheeteditor_changes);
    },
    i(local) {
      if (current) return;
      transition_in(sheeteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sheeteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(article);
      }
      destroy_component(sheeteditor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$9(ctx) {
  let div1;
  let limitedheader;
  let t2;
  let section;
  let div0;
  let rerenderafterformsubmission;
  let current;
  limitedheader = new LimitedHeader({
    props: {
      rounded: (
        /*$context*/
        ctx[0].useRoundedPortraitStyle
      )
    }
  });
  rerenderafterformsubmission = new RerenderAfterFormSubmission({
    props: {
      andOnValueChange: (
        /*$context*/
        ctx[0].system.details.biography.value
      ),
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(limitedheader.$$.fragment);
      t2 = space();
      section = element("section");
      div0 = element("div");
      create_component(rerenderafterformsubmission.$$.fragment);
      attr(div0, "class", "note-entries svelte-lyk7nb");
      attr(section, "class", "tidy-sheet-body svelte-lyk7nb");
      attr(div1, "class", "limited-vehicle svelte-lyk7nb");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(limitedheader, div1, null);
      append(div1, t2);
      append(div1, section);
      append(section, div0);
      mount_component(rerenderafterformsubmission, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const limitedheader_changes = {};
      if (dirty & /*$context*/
      1) limitedheader_changes.rounded = /*$context*/
      ctx2[0].useRoundedPortraitStyle;
      limitedheader.$set(limitedheader_changes);
      const rerenderafterformsubmission_changes = {};
      if (dirty & /*$context*/
      1) rerenderafterformsubmission_changes.andOnValueChange = /*$context*/
      ctx2[0].system.details.biography.value;
      if (dirty & /*$$scope, $context*/
      9) {
        rerenderafterformsubmission_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rerenderafterformsubmission.$set(rerenderafterformsubmission_changes);
    },
    i(local) {
      if (current) return;
      transition_in(limitedheader.$$.fragment, local);
      transition_in(rerenderafterformsubmission.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(limitedheader.$$.fragment, local);
      transition_out(rerenderafterformsubmission.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(limitedheader);
      destroy_component(rerenderafterformsubmission);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  const localize = FoundryAdapter.localize;
  return [$context, context, localize];
}
class VehicleSheetLimited extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$9, safe_not_equal, {});
  }
}
function create_else_block(ctx) {
  let vehiclesheetfull;
  let current;
  vehiclesheetfull = new VehicleSheetFull({});
  return {
    c() {
      create_component(vehiclesheetfull.$$.fragment);
    },
    m(target, anchor) {
      mount_component(vehiclesheetfull, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(vehiclesheetfull.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(vehiclesheetfull.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(vehiclesheetfull, detaching);
    }
  };
}
function create_if_block$1(ctx) {
  let vehiclesheetlimited;
  let current;
  vehiclesheetlimited = new VehicleSheetLimited({});
  return {
    c() {
      create_component(vehiclesheetlimited.$$.fragment);
    },
    m(target, anchor) {
      mount_component(vehiclesheetlimited, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(vehiclesheetlimited.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(vehiclesheetlimited.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(vehiclesheetlimited, detaching);
    }
  };
}
function create_fragment$8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$context*/
      ctx2[0].showLimitedSheet
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  return [$context, context];
}
class VehicleSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
  }
}
function getInheritedClassByName(obj, className) {
  let proto = obj.__proto__;
  for (let i2 = 0; i2 < 42; i2++) {
    if (proto.constructor.name === className) {
      return proto;
    }
    proto = proto.__proto__;
  }
  return false;
}
function getBaseActorSheet5e(obj) {
  return getInheritedClassByName(obj, CONSTANTS.CLASS_ACTOR_SHEET_5E);
}
class Tidy5eVehicleSheet extends dnd5e.applications.actor.ActorSheet5eVehicle {
  context = writable();
  stats = writable({
    lastSubmissionTime: null
  });
  card = writable();
  currentTabId;
  expandedItems = /* @__PURE__ */ new Map();
  expandedItemData = /* @__PURE__ */ new Map();
  inlineContainerToggleService = new InlineContainerToggleService();
  itemTableTogglesCache;
  subscriptionsService;
  itemFilterService;
  messageBus = writable();
  constructor(...args) {
    super(...args);
    this.subscriptionsService = new StoreSubscriptionsService();
    this.itemTableTogglesCache = new ItemTableToggleCacheService({
      userId: game.user.id,
      documentId: this.actor.id
    });
    this.itemFilterService = new ItemFilterService({}, this.actor);
    this.currentTabId = SettingsProvider.settings.initialVehicleSheetTab.get();
  }
  get template() {
    return FoundryAdapter.getTemplate("empty-form-template.hbs");
  }
  static get defaultOptions() {
    const { width, height } = SheetPreferencesService.getByType(CONSTANTS.SHEET_TYPE_VEHICLE) ?? {};
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      classes: ["tidy5e-sheet", "sheet", "actor", CONSTANTS.SHEET_TYPE_VEHICLE],
      width: width ?? 740,
      height: height ?? 810,
      scrollY: ["[data-tidy-track-scroll-y]", ".scroll-container"]
    });
  }
  component;
  activateListeners(html) {
    let first = true;
    this.subscriptionsService.registerSubscriptions(
      this.itemFilterService.filterData$.subscribe(() => {
        if (first) return;
        this.render();
      }),
      settingStore.subscribe((s2) => {
        if (first) return;
        applyThemeDataAttributeToWindow(s2.colorScheme, this.element.get(0));
        this.render();
      }),
      this.messageBus.subscribe((m2) => {
        debug("Message bus message received", {
          app: this,
          actor: this.actor,
          message: m2
        });
      }),
      SheetPreferencesRuntime.getStore().subscribe(() => {
        if (first) return;
        this.render();
      })
    );
    first = false;
    const node = html.get(0);
    this.card.set({ sheet: node, item: null, itemCardContentTemplate: null });
    this.component = new VehicleSheet({
      target: node,
      context: /* @__PURE__ */ new Map([
        [CONSTANTS.SVELTE_CONTEXT.APP_ID, this.appId],
        [CONSTANTS.SVELTE_CONTEXT.CONTEXT, this.context],
        [CONSTANTS.SVELTE_CONTEXT.MESSAGE_BUS, this.messageBus],
        [CONSTANTS.SVELTE_CONTEXT.STATS, this.stats],
        [CONSTANTS.SVELTE_CONTEXT.CARD, this.card],
        [CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE, this.inlineContainerToggleService],
        [CONSTANTS.SVELTE_CONTEXT.ITEM_FILTER_SERVICE, this.itemFilterService],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_FILTER,
          this.itemFilterService.onFilter.bind(this.itemFilterService)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_FILTER_CLEAR_ALL,
          this.itemFilterService.onFilterClearAll.bind(this.itemFilterService)
        ],
        [CONSTANTS.SVELTE_CONTEXT.CURRENT_TAB_ID, this.currentTabId],
        [CONSTANTS.SVELTE_CONTEXT.ON_TAB_SELECTED, this.onTabSelected.bind(this)],
        [CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TOGGLED, this.onItemToggled.bind(this)],
        [CONSTANTS.SVELTE_CONTEXT.LOCATION, ""],
        [CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEMS, new Map(this.expandedItems)],
        [CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEM_DATA, new Map(this.expandedItemData)],
        [
          CONSTANTS.SVELTE_CONTEXT.ITEM_TABLE_TOGGLES,
          new Map(this.itemTableTogglesCache.itemTableToggles)
        ],
        [
          CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TABLE_TOGGLE,
          this.itemTableTogglesCache.onItemTableToggle.bind(
            this.itemTableTogglesCache
          )
        ]
      ])
    });
    initTidy5eContextMenu(this, html);
  }
  async getData(options = {}) {
    const defaultDocumentContext = await super.getData(this.options);
    Tidy5eBaseActorSheet.applyCommonContext(defaultDocumentContext);
    const unlocked = FoundryAdapter.isActorSheetUnlocked(this.actor) && defaultDocumentContext.editable;
    const vehiclePreferences = SheetPreferencesService.getByType(
      this.actor.type
    );
    const actionListSortMode = vehiclePreferences.tabs?.[CONSTANTS.TAB_ACTOR_ACTIONS]?.sort ?? "m";
    const utilities = {
      [CONSTANTS.TAB_ACTOR_ACTIONS]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_ACTOR_ACTIONS,
                "sort",
                "m"
              );
            },
            visible: actionListSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("TIDY5E.SortMode.ActionListDefault"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.actor.type,
                CONSTANTS.TAB_ACTOR_ACTIONS,
                "sort",
                "a"
              );
            },
            visible: actionListSortMode === "m"
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.ExpandAll"),
            iconClass: "fas fa-angles-down",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                message: CONSTANTS.MESSAGE_BUS_EXPAND_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize("TIDY5E.Commands.CollapseAll"),
            iconClass: "fas fa-angles-up",
            execute: () => (
              // TODO: Use app.messageBus
              this.messageBus.set({
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                message: CONSTANTS.MESSAGE_BUS_COLLAPSE_ALL
              })
            )
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.actor,
                sections: context2.actions,
                tabId: CONSTANTS.TAB_ACTOR_ACTIONS,
                tabTitle: VehicleSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_ACTOR_ACTIONS
                )
              }).render(true);
            }
          }
        ]
      }
    };
    const context = {
      ...defaultDocumentContext,
      actions: await getActorActionSections(this.actor),
      activateEditors: (node, options2) => FoundryAdapter.activateEditors(node, this, options2?.bindSecrets),
      actorPortraitCommands: ActorPortraitRuntime.getEnabledPortraitMenuCommands(this.actor),
      allowEffectsManagement: true,
      appId: this.appId,
      customActorTraits: CustomActorTraitsRuntime.getEnabledTraits(
        defaultDocumentContext
      ),
      customContent: await VehicleSheetRuntime.getContent(
        defaultDocumentContext
      ),
      filterData: this.itemFilterService.getDocumentItemFilterData(),
      filterPins: ItemFilterRuntime.defaultFilterPins[this.actor.type],
      useClassicControls: SettingsProvider.settings.useClassicControlsForVehicle.get(),
      editable: defaultDocumentContext.editable,
      healthPercentage: getPercentage(
        this.actor?.system?.attributes?.hp?.value,
        this.actor?.system?.attributes?.hp?.max
      ),
      lockExpChanges: FoundryAdapter.shouldLockExpChanges(),
      lockHpMaxChanges: FoundryAdapter.shouldLockHpMaxChanges(),
      lockItemQuantity: FoundryAdapter.shouldLockItemQuantity(),
      lockLevelSelector: FoundryAdapter.shouldLockLevelSelector(),
      lockMoneyChanges: FoundryAdapter.shouldLockMoneyChanges(),
      lockSensitiveFields: !unlocked && SettingsProvider.settings.useTotalSheetLock.get() || !defaultDocumentContext.editable,
      owner: this.actor.isOwner,
      showLimitedSheet: FoundryAdapter.showLimitedSheet(this.actor),
      tabs: [],
      unlocked,
      useActionsFeature: actorUsesActionFeature(this.actor),
      useRoundedPortraitStyle: [
        CONSTANTS.CIRCULAR_PORTRAIT_OPTION_ALL,
        CONSTANTS.CIRCULAR_PORTRAIT_OPTION_NPCVEHICLE
      ].includes(SettingsProvider.settings.useCircularPortraitStyle.get()),
      utilities,
      viewableWarnings: defaultDocumentContext.warnings?.filter(
        (w2) => !isNil(w2.message?.trim(), "")
      ) ?? []
    };
    for (const item of context.items) {
      const ctx = context.itemContext[item.id];
      if (item.type === CONSTANTS.ITEM_TYPE_CONTAINER) {
        ctx.containerContents = await Container.getContainerContents(item);
      }
    }
    let tabs = await VehicleSheetRuntime.getTabs(context);
    const selectedTabs = TidyFlags.selectedTabs.get(context.actor);
    if (selectedTabs?.length) {
      tabs = tabs.filter((t2) => selectedTabs?.includes(t2.id)).sort(
        (a2, b2) => selectedTabs.indexOf(a2.id) - selectedTabs.indexOf(b2.id)
      );
    } else {
      const defaultTabs = SettingsProvider.settings.defaultVehicleSheetTabs.get();
      tabs = tabs.filter((t2) => defaultTabs?.includes(t2.id)).sort((a2, b2) => defaultTabs.indexOf(a2.id) - defaultTabs.indexOf(b2.id));
    }
    context.tabs = tabs;
    debug("Vehicle Sheet context data", context);
    return context;
  }
  _prepareItems(context) {
    const cargoColumns = [
      {
        label: game.i18n.localize("DND5E.Quantity"),
        css: "item-qty",
        property: "quantity",
        editable: "Number"
      }
    ];
    const equipmentColumns = [
      {
        label: game.i18n.localize("DND5E.Quantity"),
        css: "item-qty",
        property: "system.quantity",
        editable: "Number"
      },
      {
        label: game.i18n.localize("DND5E.AC"),
        css: "item-ac",
        property: "system.armor.value"
      },
      {
        label: game.i18n.localize("DND5E.HP"),
        css: "item-hp",
        property: "system.hp.value",
        maxProperty: "system.hp.max",
        editable: "Number"
      },
      {
        label: game.i18n.localize("DND5E.Threshold"),
        css: "item-threshold",
        property: "threshold"
      }
    ];
    const features = {
      actions: {
        label: game.i18n.localize("DND5E.ActionPl"),
        items: [],
        hasActions: true,
        crewable: true,
        key: "actions",
        dataset: { type: "feat", "system.activation.type": "crew" },
        columns: [
          {
            label: game.i18n.localize("DND5E.Cover"),
            css: "item-cover",
            property: "cover"
          }
        ],
        show: true
      },
      equipment: {
        label: game.i18n.localize(CONFIG.Item.typeLabels.equipment),
        items: [],
        crewable: true,
        dataset: { type: "equipment", "system.type.value": "vehicle" },
        columns: equipmentColumns,
        key: "equipment",
        show: true
      },
      passive: {
        label: game.i18n.localize("DND5E.Features"),
        items: [],
        dataset: { type: "feat" },
        key: "passive",
        show: true
      },
      reactions: {
        label: game.i18n.localize("DND5E.ReactionPl"),
        items: [],
        dataset: { type: "feat", "system.activation.type": "reaction" },
        key: "reactions",
        show: true
      },
      weapons: {
        label: game.i18n.localize(`${CONFIG.Item.typeLabels.weapon}Pl`),
        items: [],
        crewable: true,
        dataset: { type: "weapon", "system.weaponType": "siege" },
        columns: equipmentColumns,
        key: "weapons",
        show: true
      }
    };
    context.items.forEach((item) => {
      const { uses } = item.system;
      const ctx = context.itemContext[item.id] ??= {};
      ctx.canToggle = false;
      ctx.hasUses = uses && uses.max > 0;
    });
    const cargo = {
      crew: {
        label: game.i18n.localize("DND5E.VehicleCrew"),
        items: context.actor.system.cargo.crew,
        css: "cargo-row crew",
        editableName: true,
        dataset: { type: "crew" },
        columns: cargoColumns,
        key: "crew",
        show: true
      },
      passengers: {
        label: game.i18n.localize("DND5E.VehiclePassengers"),
        items: context.actor.system.cargo.passengers,
        css: "cargo-row passengers",
        editableName: true,
        dataset: { type: "passengers" },
        columns: cargoColumns,
        key: "passengers",
        show: true
      },
      cargo: {
        label: game.i18n.localize("DND5E.VehicleCargo"),
        items: [],
        dataset: { type: "loot" },
        columns: [
          {
            label: game.i18n.localize("DND5E.Quantity"),
            css: "item-qty",
            property: "system.quantity",
            editable: "Number"
          },
          {
            label: game.i18n.localize("DND5E.Price"),
            css: "item-price",
            property: "system.price.value",
            editable: "Number"
          },
          {
            label: game.i18n.localize("DND5E.Weight"),
            css: "item-weight",
            property: "system.weight.value",
            editable: "Number"
          }
        ],
        key: "cargo",
        show: true
      }
    };
    const baseUnits = CONFIG.DND5E.encumbrance.baseUnits[this.actor.type] ?? CONFIG.DND5E.encumbrance.baseUnits.default;
    const units = game.settings.get("dnd5e", "metricWeightUnits") ? baseUnits.metric : baseUnits.imperial;
    let totalWeight = 0;
    for (const item of context.items) {
      const ctx = context.itemContext[item.id] ??= {};
      this._prepareCrewedItem(item, ctx);
      const isCargo = item.flags.dnd5e?.vehicleCargo === true;
      if (isCargo) {
        totalWeight += item.system.totalWeightin?.(units) ?? 0;
        cargo.cargo.items.push(item);
        continue;
      }
      switch (item.type) {
        case "weapon":
          features.weapons.items.push(item);
          break;
        case "equipment":
          features.equipment.items.push(item);
          break;
        case "feat":
          const act = item.system.activation;
          if (!act.type || act.type === "none")
            features.passive.items.push(item);
          else if (act.type === "reaction") features.reactions.items.push(item);
          else features.actions.items.push(item);
          break;
        default:
          totalWeight += item.system.totalWeightIn?.(units) ?? 0;
          cargo.cargo.items.push(item);
      }
    }
    context.features = Object.values(features);
    context.cargo = Object.values(cargo);
    context.encumbrance = this._computeEncumbrance(totalWeight, context);
  }
  /**
   * Prepare items that are mounted to a vehicle and require one or more crew to operate.
   * @param {object} item     Copy of the item data being prepared for display.
   * @param {object} context  Display context for the item.
   * @protected
   */
  _prepareCrewedItem(item, context) {
    const isCrewed = item.system.crewed;
    context.toggleClass = isCrewed ? "active" : "";
    context.toggleTitle = game.i18n.localize(
      `DND5E.${isCrewed ? "Crewed" : "Uncrewed"}`
    );
    if (item.type === "feat" && item.system.activation.type === "crew") {
      context.cover = game.i18n.localize(
        `DND5E.${item.system.cover ? "CoverTotal" : "None"}`
      );
      if (item.system.cover === 0.5) context.cover = "";
      else if (item.system.cover === 0.75) context.cover = "";
      else if (item.system.cover === null) context.cover = "";
    }
    if (item.type === "equipment" || item.type === "weapon") {
      context.threshold = item.system.hp.dt ? item.system.hp.dt : "";
    }
  }
  /**
   * Compute the total weight of the vehicle's cargo.
   * @param {number} totalWeight    The cumulative item weight from inventory items
   * @param {object} actorData      The data object for the Actor being rendered
   * @returns {{max: number, value: number, pct: number}}
   * @private
   */
  _computeEncumbrance(totalWeight, actorData) {
    const totalCoins = Object.values(
      // TODO: Use dnd5e types ... one day ...
      actorData.system.currency
    ).reduce((acc, denom) => acc + denom, 0);
    const currencyPerWeight = game.settings.get("dnd5e", "metricWeightUnits") ? CONFIG.DND5E.encumbrance.currencyPerWeight.metric : CONFIG.DND5E.encumbrance.currencyPerWeight.imperial;
    totalWeight += totalCoins / currencyPerWeight;
    const max = actorData.system.attributes.capacity.cargo;
    const pct = Math.clamp(totalWeight * 100 / max, 0, 100);
    return { value: totalWeight.toNearest(0.1), max, pct };
  }
  async setExpandedItemData() {
    this.expandedItemData.clear();
    for (const id of this.expandedItems.keys()) {
      const item = this.actor.items.get(id);
      if (item) {
        this.expandedItemData.set(
          id,
          await item.getChatData({ secrets: this.actor.isOwner })
        );
      }
    }
  }
  _renderMutex = new AsyncMutex();
  async _render(force, options = {}) {
    if (typeof options !== "object") {
      options = {};
    }
    await this._renderMutex.lock(async () => {
      await this._renderSheet(force, options);
    });
  }
  async _renderSheet(force, options = {}) {
    await this.setExpandedItemData();
    const data = await this.getData();
    SheetSections.accountForExternalSections(["features"], data);
    this.context.set(data);
    if (force) {
      const { width, height } = SheetPreferencesService.getByType(CONSTANTS.SHEET_TYPE_VEHICLE) ?? {};
      this.position = {
        ...this.position,
        width: width ?? this.position.width,
        height: height ?? this.position.height
      };
      this._saveScrollPositions(this.element);
      this._destroySvelteComponent();
      await super._render(force, options);
      applySheetAttributesToWindow(
        this.actor.documentName,
        this.actor.type,
        SettingsProvider.settings.colorScheme.get(),
        this.element.get(0)
      );
      await this.renderCustomContent({ data, isFullRender: true });
      TidyHooks.tidy5eSheetsRenderActorSheet(
        this,
        this.element.get(0),
        data,
        true
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
      blurUntabbableButtonsOnClick(this.element);
      return;
    }
    await maintainCustomContentInputFocus(this, async () => {
      applyTitleToWindow(this.title, this.element.get(0));
      await this.renderCustomContent({ data, isFullRender: false });
      TidyHooks.tidy5eSheetsRenderActorSheet(
        this,
        this.element.get(0),
        data,
        false
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
    });
  }
  async renderCustomContent(args) {
    await CustomContentRenderer.render({
      app: this,
      customContent: args.data.customContent,
      data: args.data,
      element: this.element,
      isFullRender: args.isFullRender,
      superActivateListeners: super.activateListeners,
      tabs: args.data.tabs
    });
  }
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    return FoundryAdapter.removeConfigureSettingsButtonWhenLockedForNonGm(
      buttons
    );
  }
  _destroySvelteComponent() {
    this.component?.$destroy();
    this.component = void 0;
  }
  _saveScrollPositions(html) {
    if (html.length && this.component) {
      const save = super._saveScrollPositions(html);
      debug("Saved scroll positions", this._scrollPositions);
      return save;
    }
  }
  async _onDropSingleItem(itemData) {
    const cargoTypes = [
      "weapon",
      "equipment",
      "consumable",
      "tool",
      "loot",
      "container"
    ];
    const isCargo = cargoTypes.includes(itemData.type) && this.currentTabId === CONSTANTS.TAB_VEHICLE_CARGO_AND_CREW;
    foundry.utils.setProperty(itemData, "flags.dnd5e.vehicleCargo", isCargo);
    if (itemData.type === "spell") {
      const options = {};
      if (SettingsProvider.settings.includeFlagsInSpellScrollCreation.get()) {
        options.flags = itemData.flags;
      }
      const scroll = await dnd5e.documents.Item5e.createScrollFromSpell(
        itemData,
        options
      );
      return scroll.toObject();
    }
    if (itemData.type === "consumable") {
      return super._onDropSingleItem(itemData);
    }
    const baseActor5eClass = getBaseActorSheet5e(this);
    if (baseActor5eClass) {
      return baseActor5eClass._onDropSingleItem.call(this, itemData);
    }
  }
  close(options = {}) {
    this._destroySvelteComponent();
    this.subscriptionsService.unsubscribeAll();
    return super.close(options);
  }
  async _onSubmit(...args) {
    await super._onSubmit(...args);
    this.stats.update((stats) => {
      stats.lastSubmissionTime = /* @__PURE__ */ new Date();
      return stats;
    });
  }
  _disableFields(...args) {
    debug("Ignoring call to disable fields. Delegating to Tidy Sheets...");
  }
  _onResize(event) {
    super._onResize(event);
    const { width, height } = this.position;
    SheetPreferencesService.setDocumentTypePreference(
      CONSTANTS.SHEET_TYPE_VEHICLE,
      "width",
      width
    );
    SheetPreferencesService.setDocumentTypePreference(
      CONSTANTS.SHEET_TYPE_VEHICLE,
      "height",
      height
    );
  }
  /* -------------------------------------------- */
  /* SheetTabCacheable
  /* -------------------------------------------- */
  onTabSelected(tabId) {
    this.currentTabId = tabId;
  }
  /* -------------------------------------------- */
  /* SheetExpandedItemsCacheable
  /* -------------------------------------------- */
  onItemToggled(itemId, isVisible, location) {
    const locationSet = this.expandedItems.get(itemId) ?? this.expandedItems.set(itemId, /* @__PURE__ */ new Set()).get(itemId);
    if (isVisible) {
      locationSet?.add(location);
    } else {
      locationSet?.delete(location);
    }
    debug("Item Toggled", {
      expandedItems: this.expandedItems
    });
  }
  /* -------------------------------------------- */
  /* SearchFilterCacheable
  /* -------------------------------------------- */
  onSearch(location, text2) {
    debug("Searched", {
      location,
      text: text2
    });
    this.searchFilters.set(location, text2);
  }
}
function create_fragment$7(ctx) {
  let h2;
  let t1;
  let p2;
  let t2;
  let code;
  let t3_value = (
    /*$context*/
    ctx[0].item.type + ""
  );
  let t3;
  let t4;
  let a2;
  let t6;
  return {
    c() {
      h2 = element("h2");
      h2.textContent = "Item Type Not Found";
      t1 = space();
      p2 = element("p");
      t2 = text("The item type ");
      code = element("code");
      t3 = text(t3_value);
      t4 = text(" does not have a sheet in Tidy\n  5e Sheets. Please request any item type sheets in an issue on the\n  ");
      a2 = element("a");
      a2.textContent = "Tidy 5e github repository";
      t6 = text(".");
      attr(a2, "target", "_blank");
      attr(a2, "href", "https://github.com/kgar/foundry-vtt-tidy-5e-sheets/issues");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, t1, anchor);
      insert(target, p2, anchor);
      append(p2, t2);
      append(p2, code);
      append(code, t3);
      append(p2, t4);
      append(p2, a2);
      append(p2, t6);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$context*/
      1 && t3_value !== (t3_value = /*$context*/
      ctx2[0].item.type + "")) set_data(t3, t3_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t1);
        detach(p2);
      }
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let $context;
  let context = getContext(CONSTANTS.SVELTE_CONTEXT.CONTEXT);
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  return [$context, context];
}
class TypeNotFoundSheet extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
  }
}
class Tidy5eKgarItemSheet extends dnd5e.applications.item.ItemSheet5e {
  context = writable();
  stats = writable({
    lastSubmissionTime: null
  });
  currentTabId = void 0;
  subscriptionsService;
  constructor(item, ...args) {
    super(item, ...args);
    this.subscriptionsService = new StoreSubscriptionsService();
  }
  get template() {
    return FoundryAdapter.getTemplate("empty-form-template-for-items.hbs");
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      classes: ["tidy5e-sheet", "sheet", "item"]
    });
  }
  component;
  activateListeners(html) {
    let first = true;
    this.subscriptionsService.registerSubscriptions(
      settingStore.subscribe((s2) => {
        if (first) return;
        applyThemeDataAttributeToWindow(s2.colorScheme, this.element.get(0));
        this.render();
      })
    );
    first = false;
    const node = html.get(0);
    const context = /* @__PURE__ */ new Map([
      [CONSTANTS.SVELTE_CONTEXT.APP_ID, this.appId],
      [CONSTANTS.SVELTE_CONTEXT.CONTEXT, this.context],
      [CONSTANTS.SVELTE_CONTEXT.STATS, this.stats],
      [CONSTANTS.SVELTE_CONTEXT.CURRENT_TAB_ID, this.currentTabId],
      [CONSTANTS.SVELTE_CONTEXT.ON_TAB_SELECTED, this.onTabSelected.bind(this)]
    ]);
    const sheetComponent = ItemSheetRuntime.sheets[this.item.type];
    this.component = sheetComponent ? new sheetComponent.Sheet({
      target: node,
      context
    }) : new TypeNotFoundSheet({
      target: node,
      context
    });
    const contextOptions = this._getAdvancementContextMenuOptions();
    TidyHooks.dnd5eGetItemAdvancementContext(html, contextOptions);
    if (contextOptions)
      FoundryAdapter.createContextMenu(
        html,
        ".advancement-item",
        contextOptions
      );
  }
  async getData(options = {}) {
    const defaultDocumentContext = await super.getData(this.options);
    const itemDescriptions = [];
    itemDescriptions.push({
      content: defaultDocumentContext.enriched.description,
      field: "system.description.value",
      label: FoundryAdapter.localize("DND5E.Description")
    });
    if (defaultDocumentContext.isIdentifiable && FoundryAdapter.userIsGm()) {
      itemDescriptions.push({
        content: defaultDocumentContext.enriched.unidentified,
        field: "system.unidentified.description",
        label: FoundryAdapter.localize("DND5E.DescriptionUnidentified")
      });
    }
    itemDescriptions.push({
      content: defaultDocumentContext.enriched.chat,
      field: "system.description.chat",
      label: FoundryAdapter.localize("DND5E.DescriptionChat")
    });
    const eligibleCustomTabs = ItemSheetRuntime.getCustomItemTabs(
      defaultDocumentContext
    );
    const customTabs = await TabManager.prepareTabsForRender(
      defaultDocumentContext,
      eligibleCustomTabs
    );
    const tabs = ItemSheetRuntime.sheets[this.item.type]?.defaultTabs() ?? [];
    tabs.push(...customTabs);
    const context = {
      ...defaultDocumentContext,
      appId: this.appId,
      activateEditors: (node, options2) => FoundryAdapter.activateEditors(node, this, options2?.bindSecrets),
      customContent: await ItemSheetRuntime.getContent(defaultDocumentContext),
      customEquipmentTypeGroups: ItemSheetRuntime.getCustomEquipmentTypeGroups(),
      itemOverrides: new Set(this._getItemOverrides()),
      healthPercentage: getPercentage(
        this.item?.system?.hp?.value,
        this.item?.system?.hp?.max
      ),
      identifiedName: FoundryAdapter.getIdentifiedName(this.item),
      itemDescriptions,
      lockItemQuantity: FoundryAdapter.shouldLockItemQuantity(),
      originalContext: defaultDocumentContext,
      tabs,
      toggleAdvancementLock: this.toggleAdvancementLock.bind(this),
      viewableWarnings: defaultDocumentContext.warnings?.filter(
        (w2) => !isNil(w2.message?.trim(), "")
      ) ?? []
    };
    debug(`${this.item?.type ?? "Unknown Item Type"} context data`, context);
    return context;
  }
  _renderMutex = new AsyncMutex();
  async _render(force, options = {}) {
    if (typeof options !== "object") {
      options = {};
    }
    await this._renderMutex.lock(async () => {
      await this._renderSheet(force, options);
    });
  }
  async _renderSheet(force, options = {}) {
    const data = await this.getData();
    this.context.set(data);
    if (force) {
      const width = SheetPreferencesService.getByType(this.item.type)?.width;
      this.position = {
        ...this.position,
        width: width ?? this.position.width
      };
      this.component?.$destroy();
      await super._render(force, options);
      applySheetAttributesToWindow(
        this.item.documentName,
        this.item.type,
        SettingsProvider.settings.colorScheme.get(),
        this.element.get(0)
      );
      await this.renderCustomContent({ data, isFullRender: true });
      TidyHooks.tidy5eSheetsRenderItemSheet(
        this,
        this.element.get(0),
        data,
        true
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
      return;
    }
    await maintainCustomContentInputFocus(this, async () => {
      applyTitleToWindow(this.title, this.element.get(0));
      await this.renderCustomContent({ data, isFullRender: false });
      TidyHooks.tidy5eSheetsRenderItemSheet(
        this,
        this.element.get(0),
        data,
        false
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
    });
  }
  async renderCustomContent(args) {
    await CustomContentRenderer.render({
      app: this,
      customContent: args.data.customContent,
      data: args.data,
      element: this.element,
      isFullRender: args.isFullRender,
      superActivateListeners: super.activateListeners,
      tabs: args.data.tabs
    });
  }
  async _onSubmit(...args) {
    await super._onSubmit(...args);
    setTimeout(() => {
      this.stats.update((stats) => {
        stats.lastSubmissionTime = /* @__PURE__ */ new Date();
        return stats;
      });
    });
  }
  close(...args) {
    try {
      this._saveViewState();
    } catch (e2) {
      debug(
        `Unable to save view state for ${Tidy5eKgarItemSheet.name}. Ignoring.`
      );
    } finally {
      this.component?.$destroy();
      this.subscriptionsService.unsubscribeAll();
      return super.close(...args);
    }
  }
  async _onDropSingleItem(...args) {
    return super._onDropSingleItem(...args);
  }
  async toggleAdvancementLock() {
    this.advancementConfigurationMode = !this.advancementConfigurationMode;
    this.context.set(await this.getData());
  }
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    return FoundryAdapter.removeConfigureSettingsButtonWhenLockedForNonGm(
      buttons
    );
  }
  _disableFields(...args) {
    debug("Ignoring call to disable fields. Delegating to Tidy Sheets...");
  }
  _onResize(event) {
    super._onResize(event);
    const { width } = this.position;
    SheetPreferencesService.setDocumentTypePreference(
      this.item.type,
      "width",
      width
    );
  }
  /* -------------------------------------------- */
  /* SheetTabCacheable
  /* -------------------------------------------- */
  onTabSelected(tabId) {
    this.currentTabId = tabId;
    const tabs = get_store_value(this.context)?.tabs ?? [];
    setTimeout(() => {
      this._handleAutoHeightTabs(tabs);
    });
  }
  _handleAutoHeightTabs(tabs) {
    const currentTabSettings = tabs.find((t2) => t2.id === this.currentTabId);
    if (currentTabSettings?.autoHeight) {
      this._saveScrollPositions(this.element);
      this.setPosition({ height: "auto" });
    }
  }
}
class Tidy5eKgarContainerSheet extends BaseSheetCustomSectionMixin(
  (object) => object.system.contents,
  dnd5e.applications.item.ContainerSheet
) {
  context = writable();
  stats = writable({
    lastSubmissionTime: null
  });
  currentTabId = void 0;
  searchFilters = /* @__PURE__ */ new Map();
  expandedItems = /* @__PURE__ */ new Map();
  expandedItemData = /* @__PURE__ */ new Map();
  inlineContainerToggleService = new InlineContainerToggleService();
  card = writable();
  itemFilterService;
  subscriptionsService;
  messageBus = writable();
  constructor(...args) {
    super(...args);
    this.subscriptionsService = new StoreSubscriptionsService();
    this.itemFilterService = new ItemFilterService({}, this.item);
  }
  get template() {
    return FoundryAdapter.getTemplate("empty-form-template-for-items.hbs");
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      classes: ["tidy5e-sheet", "sheet", "item", "container"]
    });
  }
  component;
  activateListeners(html) {
    let first = true;
    this.subscriptionsService.registerSubscriptions(
      this.itemFilterService.filterData$.subscribe(() => {
        if (first) return;
        this.render();
      }),
      settingStore.subscribe((s2) => {
        if (first) return;
        applyThemeDataAttributeToWindow(s2.colorScheme, this.element.get(0));
        this.render();
      }),
      this.messageBus.subscribe((m2) => {
        debug("Message bus message received", {
          app: this,
          actor: this.actor,
          message: m2
        });
      })
    );
    first = false;
    const node = html.get(0);
    this.card.set({ sheet: node, item: null, itemCardContentTemplate: null });
    const context = /* @__PURE__ */ new Map([
      [CONSTANTS.SVELTE_CONTEXT.APP_ID, this.appId],
      [CONSTANTS.SVELTE_CONTEXT.CARD, this.card],
      [CONSTANTS.SVELTE_CONTEXT.CONTEXT, this.context],
      [CONSTANTS.SVELTE_CONTEXT.CURRENT_TAB_ID, this.currentTabId],
      [CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEMS, new Map(this.expandedItems)],
      [
        CONSTANTS.SVELTE_CONTEXT.EXPANDED_ITEM_DATA,
        new Map(this.expandedItemData)
      ],
      [CONSTANTS.SVELTE_CONTEXT.MESSAGE_BUS, this.messageBus],
      [
        CONSTANTS.SVELTE_CONTEXT.INLINE_CONTAINER_TOGGLE_SERVICE,
        this.inlineContainerToggleService
      ],
      [
        CONSTANTS.SVELTE_CONTEXT.ON_FILTER,
        this.itemFilterService.onFilter.bind(this.itemFilterService)
      ],
      [
        CONSTANTS.SVELTE_CONTEXT.ON_FILTER_CLEAR_ALL,
        this.itemFilterService.onFilterClearAll.bind(this.itemFilterService)
      ],
      [CONSTANTS.SVELTE_CONTEXT.ON_ITEM_TOGGLED, this.onItemToggled.bind(this)],
      [CONSTANTS.SVELTE_CONTEXT.ON_SEARCH, this.onSearch.bind(this)],
      [CONSTANTS.SVELTE_CONTEXT.ON_TAB_SELECTED, this.onTabSelected.bind(this)],
      [CONSTANTS.SVELTE_CONTEXT.SEARCH_FILTERS, new Map(this.searchFilters)],
      [CONSTANTS.SVELTE_CONTEXT.STATS, this.stats]
    ]);
    this.component = new ContainerSheet({
      target: node,
      context
    });
    initTidy5eContextMenu(this, html);
  }
  async getData(options = {}) {
    const defaultDocumentContext = await super.getData(this.options);
    this.item.actor?.system?.favorites?.forEach((f2) => {
      const item = fromUuidSync(f2.id, { relative: this.item.actor });
      if (!item) {
        return;
      }
      const ctx = defaultDocumentContext.itemContext[item.id];
      if (ctx) {
        ctx.favoriteId = f2.id;
      }
    });
    const itemDescriptions = [];
    itemDescriptions.push({
      content: defaultDocumentContext.enriched.description,
      field: "system.description.value",
      label: FoundryAdapter.localize("DND5E.Description")
    });
    if (defaultDocumentContext.isIdentifiable && FoundryAdapter.userIsGm()) {
      itemDescriptions.push({
        content: defaultDocumentContext.enriched.unidentified,
        field: "system.unidentified.description",
        label: FoundryAdapter.localize("DND5E.DescriptionUnidentified")
      });
    }
    itemDescriptions.push({
      content: defaultDocumentContext.enriched.chat,
      field: "system.description.chat",
      label: FoundryAdapter.localize("DND5E.DescriptionChat")
    });
    const eligibleCustomTabs = ItemSheetRuntime.getCustomItemTabs(
      defaultDocumentContext
    );
    const customTabs = await TabManager.prepareTabsForRender(
      defaultDocumentContext,
      eligibleCustomTabs
    );
    const tabs = ItemSheetRuntime.sheets[this.item.type]?.defaultTabs() ?? [];
    tabs.push(...customTabs);
    const containerPreferences = SheetPreferencesService.getByType(
      this.item.type
    );
    const contentsSortMode = containerPreferences.tabs?.[CONSTANTS.TAB_CONTAINER_CONTENTS]?.sort ?? "m";
    let utilities = {
      [CONSTANTS.TAB_CONTAINER_CONTENTS]: {
        utilityToolbarCommands: [
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeAlpha"),
            iconClass: "fa-solid fa-arrow-down-a-z fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.item.type,
                CONSTANTS.TAB_CONTAINER_CONTENTS,
                "sort",
                "m"
              );
              this.render();
            },
            visible: contentsSortMode === "a"
          },
          {
            title: FoundryAdapter.localize("SIDEBAR.SortModeManual"),
            iconClass: "fa-solid fa-arrow-down-short-wide fa-fw",
            execute: async () => {
              await SheetPreferencesService.setDocumentTypeTabPreference(
                this.item.type,
                CONSTANTS.TAB_CONTAINER_CONTENTS,
                "sort",
                "a"
              );
              this.render();
            },
            visible: contentsSortMode === "m"
          },
          {
            title: FoundryAdapter.localize(
              "TIDY5E.Utilities.ConfigureSections"
            ),
            iconClass: "fas fa-cog",
            execute: ({ context: context2 }) => {
              new DocumentTabSectionConfigApplication({
                document: context2.item,
                // Provide a way to build the necessary config, perhaps within the application constructor. We've got all the info we need in order to perform the operation.
                sections: context2.containerContents.contents,
                tabId: CONSTANTS.TAB_CONTAINER_CONTENTS,
                tabTitle: ItemSheetRuntime.getTabTitle(
                  CONSTANTS.TAB_CONTAINER_CONTENTS
                )
              }).render(true);
            }
          }
        ]
      }
    };
    const context = {
      ...defaultDocumentContext,
      appId: this.appId,
      activateEditors: (node, options2) => FoundryAdapter.activateEditors(node, this, options2?.bindSecrets),
      containerContents: await Container.getContainerContents(this.item),
      customContent: await ItemSheetRuntime.getContent(defaultDocumentContext),
      filterData: this.itemFilterService.getDocumentItemFilterData(),
      filterPins: ItemFilterRuntime.defaultFilterPins[this.item.type],
      identifiedName: FoundryAdapter.getIdentifiedName(this.item),
      itemDescriptions,
      itemOverrides: new Set(this._getItemOverrides()),
      lockItemQuantity: FoundryAdapter.shouldLockItemQuantity(),
      originalContext: defaultDocumentContext,
      tabs,
      utilities,
      viewableWarnings: defaultDocumentContext.warnings?.filter(
        (w2) => !isNil(w2.message?.trim(), "")
      ) ?? []
    };
    const contents = await this.item.system.contents;
    for (const item of contents) {
      if (item.type === CONSTANTS.ITEM_TYPE_CONTAINER) {
        const ctx = context.itemContext[item.id];
        ctx.containerContents = await Container.getContainerContents(item);
      }
    }
    TidyHooks.tidy5eSheetsPreConfigureSections(
      this,
      this.element.get(0),
      context
    );
    debug(`Container Sheet context data`, context);
    return context;
  }
  async setExpandedItemData() {
    this.expandedItemData.clear();
    const contents = await this.item.system.contents;
    for (const id of this.expandedItems.keys()) {
      const item = contents.get(id);
      if (item) {
        this.expandedItemData.set(
          id,
          await item.getChatData({ secrets: this.item.isOwner })
        );
      }
    }
  }
  _renderMutex = new AsyncMutex();
  async _render(force, options = {}) {
    if (typeof options !== "object") {
      options = {};
    }
    await this._renderMutex.lock(async () => {
      await this._renderSheet(force, options);
    });
  }
  async _renderSheet(force, options = {}) {
    await this.setExpandedItemData();
    const data = await this.getData();
    this.context.set(data);
    if (force) {
      this.component?.$destroy();
      await super._render(force, options);
      applySheetAttributesToWindow(
        this.item.documentName,
        this.item.type,
        SettingsProvider.settings.colorScheme.get(),
        this.element.get(0)
      );
      await this.renderCustomContent({ data, isFullRender: true });
      TidyHooks.tidy5eSheetsRenderItemSheet(
        this,
        this.element.get(0),
        data,
        true
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
      return;
    }
    maintainCustomContentInputFocus(this, async () => {
      applyTitleToWindow(this.title, this.element.get(0));
      await this.renderCustomContent({ data, isFullRender: false });
      TidyHooks.tidy5eSheetsRenderItemSheet(
        this,
        this.element.get(0),
        data,
        false
      );
      CustomContentRenderer.wireCompatibilityEventListeners(
        this.element,
        super.activateListeners,
        this
      );
    });
  }
  async renderCustomContent(args) {
    await CustomContentRenderer.render({
      app: this,
      customContent: args.data.customContent,
      data: args.data,
      element: this.element,
      isFullRender: args.isFullRender,
      superActivateListeners: super.activateListeners,
      tabs: args.data.tabs
    });
  }
  async _onSubmit(...args) {
    await super._onSubmit(...args);
    setTimeout(() => {
      this.stats.update((stats) => {
        stats.lastSubmissionTime = /* @__PURE__ */ new Date();
        return stats;
      });
    });
  }
  close(...args) {
    try {
      this._saveViewState();
    } catch (e2) {
      debug(
        `Unable to save view state for ${Tidy5eKgarContainerSheet.name}. Ignoring.`
      );
    } finally {
      this.component?.$destroy();
      this.subscriptionsService.unsubscribeAll();
      return super.close(...args);
    }
  }
  async _onDropSingleItem(...args) {
    return super._onDropSingleItem(...args);
  }
  _getHeaderButtons() {
    const buttons = super._getHeaderButtons();
    return FoundryAdapter.removeConfigureSettingsButtonWhenLockedForNonGm(
      buttons
    );
  }
  _disableFields(...args) {
    debug("Ignoring call to disable fields. Delegating to Tidy Sheets...");
  }
  /* -------------------------------------------- */
  /* SheetTabCacheable
  /* -------------------------------------------- */
  onTabSelected(tabId) {
    this.currentTabId = tabId;
    const tabs = get_store_value(this.context)?.tabs ?? [];
    setTimeout(() => {
      this._handleAutoHeightTabs(tabs);
    });
  }
  _handleAutoHeightTabs(tabs) {
    const currentTabSettings = tabs.find((t2) => t2.id === this.currentTabId);
    if (currentTabSettings?.autoHeight) {
      this._saveScrollPositions(this.element);
      this.setPosition({ height: "auto" });
    }
  }
  /* -------------------------------------------- */
  /* SheetExpandedItemsCacheable
  /* -------------------------------------------- */
  onItemToggled(itemId, isVisible, location) {
    const locationSet = this.expandedItems.get(itemId) ?? this.expandedItems.set(itemId, /* @__PURE__ */ new Set()).get(itemId);
    if (isVisible) {
      locationSet?.add(location);
    } else {
      locationSet?.delete(location);
    }
    debug("Item Toggled", {
      expandedItems: this.expandedItems
    });
  }
  /* -------------------------------------------- */
  /* SearchFilterCacheable
  /* -------------------------------------------- */
  onSearch(location, text2) {
    debug("Searched", {
      location,
      text: text2
    });
    this.searchFilters.set(location, text2);
  }
}
class Tidy5eSheetsApi {
  static _instance;
  constructor() {
  }
  /**
   * Gets an instance of the Tidy 5e Sheets API
   * @returns instance of the Tidy 5e Sheets API
   * @internal
   */
  static _getApi() {
    Tidy5eSheetsApi._instance ??= new Tidy5eSheetsApi();
    return this._instance;
  }
  /** {@inheritDoc ActionListApi} */
  /** @deprecated api.actionList API has been moved to api.config.actionList */
  get actionList() {
    warn("api.actionList API has been moved to api.config.actionList");
    return this.config.actionList;
  }
  /** {@inheritDoc ActorItemApi} */
  /** @deprecated api.actorItem API has been moved to api.config.actorItem */
  get actorItem() {
    warn("api.actorItem API has been moved to api.config.actorItem");
    return this.config.actorItem;
  }
  /** {@inheritDoc ActorPortraitApi} */
  /** @deprecated api.actorPortrait API has been moved to api.config.actorPortrait */
  get actorPortrait() {
    warn("api.actorPortrait API has been moved to api.config.actorPortrait");
    return this.config.actorPortrait;
  }
  /** {@inheritDoc ConfigApi} */
  config = new ConfigApi();
  /**
   * Constants for a variety of uses.
   *
   * @remarks
   * When APIs call for specific IDs or selectors related to Tidy 5e Sheets,
   * using the related constant when available will insulate against breakage
   * when Tidy has internal changes.
   */
  constants = ApiConstants;
  /**
   * Creates a selector which allows for locating a part of a given sheet.
   * @param sheetPart a part of the sheet as found in `api.constants.SHEET_PARTS`
   * @returns an HTML selector valid for use with JavaScript query selectors
   */
  getSheetPartSelector(sheetPart) {
    return `[${CONSTANTS.SHEET_PART_ATTRIBUTE}="${sheetPart}"]`;
  }
  /** {@inheritDoc ExhaustionApi} */
  /** @deprecated api.exhaustion API has been moved to api.config.exhaustion */
  get exhaustion() {
    warn("api.exhaustion API has been moved to api.config.exhaustion");
    return this.config.exhaustion;
  }
  /**
   * Determines whether the provided sheet is a Tidy 5e Character sheet.
   * @param app an actor sheet
   * @returns boolean indicating if the sheet is a Tidy 5e Character sheet
   */
  isTidy5eCharacterSheet(app) {
    return Tidy5eCharacterSheet.name === app?.constructor?.name;
  }
  /**
   * Determines whether the provided sheet is a Tidy 5e Container sheet.
   * @param app a container sheet
   * @returns boolean indicating if the sheet is a Tidy 5e Container sheet
   */
  isTidy5eContainerSheet(app) {
    return Tidy5eKgarContainerSheet.name === app?.constructor?.name;
  }
  /**
   * Determines whether the provided sheet is a Tidy 5e Item sheet.
   * @param app an item sheet
   * @returns boolean indicating if the sheet is a Tidy 5e Item sheet
   */
  isTidy5eItemSheet(app) {
    return Tidy5eKgarItemSheet.name === app?.constructor?.name;
  }
  /**
   * Determines whether the provided sheet is a Tidy 5e NPC sheet.
   * @param app an actor sheet
   * @returns boolean indicating if the sheet is a Tidy 5e NPC sheet
   */
  isTidy5eNpcSheet(app) {
    return Tidy5eNpcSheet.name === app?.constructor?.name;
  }
  /**
   * Determines whether the provided sheet is any Tidy 5e sheet.
   * @param app an actor sheet
   * @returns boolean indicating if the sheet is any Tidy 5e sheet
   */
  isTidy5eSheet(app) {
    return [
      Tidy5eCharacterSheet.name,
      Tidy5eNpcSheet.name,
      Tidy5eVehicleSheet.name,
      Tidy5eKgarItemSheet.name,
      Tidy5eKgarContainerSheet.name
    ].includes(app?.constructor?.name);
  }
  /**
   * Determines whether the provided sheet is a Tidy 5e Vehicle sheet.
   * @param app an actor sheet
   * @returns boolean indicating if the sheet is a Tidy 5e Vehicle sheet
   */
  isTidy5eVehicleSheet(app) {
    return Tidy5eVehicleSheet.name === app.constructor.name;
  }
  /**{@inheritDoc ItemSummaryApi} */
  /** @deprecated api.itemSummary API has been moved to api.config.actorPortrait */
  get itemSummary() {
    warn("api.itemSummary API has been moved to api.config.actorPortrait");
    return this.config.itemSummary;
  }
  /**
   * Various models can be used for API calls.
   */
  models = {
    HandlebarsTab,
    HtmlTab,
    SvelteTab,
    HandlebarsContent,
    HtmlContent
  };
  /**
   * Adds a tab to the available sheet tabs for all actor types that Tidy 5e supports.
   * @param {SupportedTab} tab the information necessary to render a tab
   * @param {object} [options] sheet registration options
   * @param {string} [options.layout] an optional sheet layout or layouts (default: 'all')
   * @param {string} [options.overrideExisting] if a tab with this ID already exists, override it
   * @returns void
   */
  registerActorTab(tab, options) {
    this.registerCharacterTab(tab, options);
    this.registerNpcTab(tab, options);
    this.registerVehicleTab(tab, options);
  }
  /**
   * Adds a tab to the available Character sheet tabs.
   * @param {SupportedTab} tab the information necessary to render a tab
   * @param {object} [options] sheet registration options
   * @param {string} [options.layout] an optional sheet layout or layouts (default: 'all')
   * @param {string} [options.overrideExisting] if a tab with this ID already exists, override it
   * @returns void
   *
   * @example Registering a handlebars-based character sheet tab
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.registerCharacterTab(
   *     new api.models.HandlebarsTab({
   *       title: 'My Tab',
   *       path: '/modules/my-module-id/templates/my-handlebars-template.hbs',
   *       tabId: 'my-module-id-registered-character-tab',
   *       getData: async (data) => {
   *         data['my-message'] = 'Hello, world! ';
   *         return new Promise((resolve) => {
   *           resolve(data);
   *         });
   *       },
   *       onRender(params) {
   *         const myTab = $(params.tabContentsElement);
   *         myTab.find('.my-control').click(_myHandler.bind(params.app));
   *       },
   *     })
   *   );
   * });
   * ```
   *
   * @example Overriding an existing sheet tab
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.registerCharacterTab(
   *     new api.models.HandlebarsTab({
   *       title: 'The New Inventory Tab',
   *       path: '/modules/my-module-id/templates/my-handlebars-template.hbs',
   *       tabId: api.constants.TAB_ID_CHARACTER_INVENTORY,
   *       getData: async (data) => {
   *         data['my-message'] = 'Hello, world! ';
   *         return new Promise((resolve) => {
   *           resolve(data);
   *         });
   *       },
   *       onRender(params) {
   *         const myTab = $(params.tabContentsElement);
   *         myTab.find('.my-control').click(_myHandler.bind(params.app));
   *       },
   *     }),
   *     {
   *       overrideExisting: true,
   *     }
   *   );
   * });
   * ```
   *
   * @remarks
   * A tab ID is always required (see {@link TabId}).
   */
  registerCharacterTab(tab, options) {
    if (!TabManager.validateTab(tab)) {
      return;
    }
    const registeredTab = TabManager.mapCustomTabToRegisteredTab(
      tab,
      options?.layout
    );
    if (!registeredTab) {
      warn("Unable to register tab. Tab type not supported");
      return;
    }
    CharacterSheetRuntime.registerTab(registeredTab, options);
  }
  /**
   * Adds custom content to all actor sheets at `position` relative to `selector`.
   *
   * @param content the information necessary to render custom content
   * @param options custom content registration options
   * @returns void
   *
   * @example registering an icon next to the actor sheet name
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.registerActorContent(
   *     new api.models.HtmlContent({
   *       html: `<a title="Example Button" class="my-custom-icon"><i class="fas fa-user"></i></a>`,
   *       injectParams: {
   *         selector: api.getSheetPartSelector(
   *           api.constants.SHEET_PARTS.NAME_CONTAINER
   *         ),
   *         position: "beforebegin",
   *       },
   *       onContentReady: (params) => {
   *         console.log("content ready to render", params);
   *         console.log("my content", params.content);
   *       },
   *       onRender: (params) => {
   *         params.element
   *           .querySelector(".my-custom-icon")
   *           .addEventListener("click", () => alert("Clicked custom actor icon"));
   *       },
   *     })
   *   );
   * });
   * ```
   */
  registerActorContent(content, options) {
    const registeredContent = CustomContentManager.mapToRegisteredContent(
      content,
      options?.layout
    );
    if (!registeredContent) {
      warn("Unable to register content. Content type not supported.");
      return;
    }
    CharacterSheetRuntime.registerContent(registeredContent);
    NpcSheetRuntime.registerContent(registeredContent);
    VehicleSheetRuntime.registerContent(registeredContent);
  }
  /**
   * Adds custom content to player character sheets at `position` relative to `selector`.
   *
   * @param content the information necessary to render custom content
   * @param options custom content registration options
   * @returns void
   *
   * @example registering an icon next to the character sheet name
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.registerCharacterContent(
   *     new api.models.HtmlContent({
   *       html: `<a title="Example Button" class="my-custom-icon"><i class="fas fa-user"></i></a>`,
   *       injectParams: {
   *         selector: api.getSheetPartSelector(
   *           api.constants.SHEET_PARTS.NAME_CONTAINER
   *         ),
   *         position: "beforebegin",
   *       },
   *       onContentReady: (params) => {
   *         console.log("content ready to render", params);
   *         console.log("my content", params.content);
   *       },
   *       onRender: (params) => {
   *         params.element
   *           .querySelector(".my-custom-icon")
   *           .addEventListener("click", () => alert("Clicked custom PC icon"));
   *       },
   *     })
   *   );
   * });
   * ```
   */
  registerCharacterContent(content, options) {
    const registeredContent = CustomContentManager.mapToRegisteredContent(
      content,
      options?.layout
    );
    if (!registeredContent) {
      warn("Unable to register content. Content type not supported.");
      return;
    }
    CharacterSheetRuntime.registerContent(registeredContent);
  }
  /**
   * Adds custom content to item sheets at `position` relative to `selector`.
   *
   * @param content the information necessary to render custom content
   * @param options custom content registration options
   * @returns void
   *
   * @example registering an icon next to the item sheet name
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.registerItemContent(
   *     new api.models.HtmlContent({
   *       html: `<a title="Example Button" class="my-custom-icon"><i class="fas fa-flask"></i></a>`,
   *       injectParams: {
   *         selector: api.getSheetPartSelector(
   *           api.constants.SHEET_PARTS.NAME_CONTAINER
   *         ),
   *         position: "beforebegin",
   *       },
   *       onContentReady: (params) => {
   *         console.log("content ready to render", params);
   *         console.log("my content", params.content);
   *       },
   *       onRender: (params) => {
   *         params.element
   *           .querySelector(".my-custom-icon")
   *           .addEventListener("click", () => alert("Clicked custom item icon"));
   *       },
   *     })
   *   );
   * });
   * ```
   */
  registerItemContent(content, options) {
    const registeredContent = CustomContentManager.mapToRegisteredContent(
      content,
      options?.layout
    );
    if (!registeredContent) {
      warn("Unable to register content. Content type not supported.");
      return;
    }
    ItemSheetRuntime.registerContent(registeredContent);
  }
  /**
   * Adds custom content to NPC sheets at `position` relative to `selector`.
   *
   * @param content the information necessary to render custom content
   * @param options custom content registration options
   * @returns void
   *
   * @example registering an icon next to the NPC sheet name
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.registerNpcContent(
   *     new api.models.HtmlContent({
   *       html: `<a title="Example Button" class="my-custom-icon"><i class="fas fa-user"></i></a>`,
   *       injectParams: {
   *         selector: api.getSheetPartSelector(
   *           api.constants.SHEET_PARTS.NAME_CONTAINER
   *         ),
   *         position: "beforebegin",
   *       },
   *       onContentReady: (params) => {
   *         console.log("content ready to render", params);
   *         console.log("my content", params.content);
   *       },
   *       onRender: (params) => {
   *         params.element
   *           .querySelector(".my-custom-icon")
   *           .addEventListener("click", () => alert("Clicked custom NPC icon"));
   *       },
   *     })
   *   );
   * });
   * ```
   */
  registerNpcContent(content, options) {
    const registeredContent = CustomContentManager.mapToRegisteredContent(
      content,
      options?.layout
    );
    if (!registeredContent) {
      warn("Unable to register content. Content type not supported.");
      return;
    }
    NpcSheetRuntime.registerContent(registeredContent);
  }
  /**
   * Adds custom content to vehicle sheets at `position` relative to `selector`.
   *
   * @param content the information necessary to render custom content
   * @param options custom content registration options
   * @returns void
   *
   * @example registering an icon next to the vehicle sheet name
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.registerVehicleContent(
   *     new api.models.HtmlContent({
   *       html: `<a title="Example Button" class="my-custom-icon"><i class="fas fa-user"></i></a>`,
   *       injectParams: {
   *         selector: api.getSheetPartSelector(
   *           api.constants.SHEET_PARTS.NAME_CONTAINER
   *         ),
   *         position: "beforebegin",
   *       },
   *       onContentReady: (params) => {
   *         console.log("content ready to render", params);
   *         console.log("my content", params.content);
   *       },
   *       onRender: (params) => {
   *         params.element
   *           .querySelector(".my-custom-icon")
   *           .addEventListener("click", () => alert("Clicked Vehicle custom icon"));
   *       },
   *     })
   *   );
   * });
   * ```
   */
  registerVehicleContent(content, options) {
    const registeredContent = CustomContentManager.mapToRegisteredContent(
      content,
      options?.layout
    );
    if (!registeredContent) {
      warn("Unable to register content. Content type not supported.");
      return;
    }
    VehicleSheetRuntime.registerContent(registeredContent);
  }
  /**
   * Adds a tab to all relevant item sheets.
   * @see {@link CustomTabBase} for options related to all tabs.
   * @param tab the custom tab settings to use when incorporating this tab.
   * @example Register an item tab for spell items only, adding some custom data to the Item Sheet Context object before rendering my handlebars template
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.registerItemTab(
   *     new api.models.HandlebarsTab({
   *       title: 'My Item Tab',
   *       tabId: 'my-module-id-my-item-tab',
   *       path: '/modules/my-module-id/my-item-tab.hbs',
   *       enabled: (data) => data.item.type === 'spell',
   *       getData: (data) => {
   *         data['my-extra-data'] = 'Hello, world! ';
   *         return data;
   *       },
   *       onRender(params) {
   *         const myTab = $(params.tabContentsElement);
   *         myTab.find('.my-control').click(_myHandler.bind(params.app));
   *       },
   *     }));
   * });
   * ```
   *
   * @example Register an item tab with autoHeight, similar to how Details item tabs work.
   * ```js
   * Hooks.once("tidy5e-sheet.ready", (api) => {
   *   api.registerItemTab(
   *     new api.models.HtmlTab({
   *       title: "My Item Tab",
   *       tabId: "my-module-id-my-item-tab",
   *       html: "<h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h1>LOREM! IPSUM! FIREBALLLLLL!!</h1><h2></h2>",
   *     }),
   *     { autoHeight: true } //  With Auto Height set to `true`, the item window will stretch as tall as it can to match the content height when this tab is viewed.
   *   );
   * });
   * ```
   *
   * @remarks
   * A tab ID is always required (see {@link TabId}).
   */
  registerItemTab(tab, options) {
    if (!TabManager.validateTab(tab)) {
      return;
    }
    const registeredTab = TabManager.mapCustomTabToRegisteredTab(tab);
    if (!registeredTab) {
      warn("Unable to register tab. Tab type not supported");
      return;
    }
    if (options?.autoHeight) {
      registeredTab.autoHeight = options.autoHeight;
    }
    ItemSheetRuntime.registerTab(registeredTab);
  }
  /**
   * Adds a tab to the available NPC sheet tabs.
   * @param {SupportedTab} tab the information necessary to render a tab
   * @param {object} [options] sheet registration options
   * @param {string} [options.layout] an optional sheet layout or layouts (default: 'all')
   * @param {string} [options.overrideExisting] if a tab with this ID already exists, override it
   * @returns void
   * @example Registering a handlebars-based NPC sheet tab
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.registerNpcTab(
   *     new api.models.HandlebarsTab({
   *       title: 'My Tab',
   *       path: '/modules/my-module-id/templates/my-handlebars-template.hbs',
   *       tabId: 'my-module-id-registered-npc-tab',
   *       getData: async (data) => {
   *         data['my-message'] = 'Hello, world! ';
   *         return new Promise((resolve) => {
   *           resolve(data);
   *         });
   *       },
   *       onRender(params) {
   *         const myTab = $(params.tabContentsElement);
   *         myTab.find('.my-control').click(_myHandler.bind(params.app));
   *       },
   *     })
   *   );
   * });
   * ```
   *
   * @remarks
   * A tab ID is always required (see {@link TabId}).
   */
  registerNpcTab(tab, options) {
    if (!TabManager.validateTab(tab)) {
      return;
    }
    const registeredTab = TabManager.mapCustomTabToRegisteredTab(
      tab,
      options?.layout
    );
    if (!registeredTab) {
      warn("Unable to register tab. Tab type not supported");
      return;
    }
    NpcSheetRuntime.registerTab(registeredTab);
  }
  /**
   * Adds a tab to the available Vehicle sheet tabs.
   * @param {SupportedTab} tab the information necessary to render a tab
   * @param {object} [options] sheet registration options
   * @param {string} [options.layout] an optional sheet layout or layouts (default: 'all')
   * @param {string} [options.overrideExisting] if a tab with this ID already exists, override it
   * @returns void
   * @example Registering a handlebars-based vehicle sheet tab
   * ```js
   * Hooks.once('tidy5e-sheet.ready', (api) => {
   *   api.registerVehicleTab(
   *     new api.models.HandlebarsTab({
   *       title: 'My Tab',
   *       path: '/modules/my-module-id/templates/my-handlebars-template.hbs',
   *       tabId: 'my-module-id-registered-vehicle-tab',
   *       getData: async (data) => {
   *         data['my-message'] = 'Hello, world! ';
   *         return new Promise((resolve) => {
   *           resolve(data);
   *         });
   *       },
   *       onRender(params) {
   *         const myTab = $(params.tabContentsElement);
   *         myTab.find('.my-control').click(_myHandler.bind(params.app));
   *       },
   *     })
   *   );
   * });
   * ```
   *
   * @remarks
   * A tab ID is always required (see {@link TabId}).
   */
  registerVehicleTab(tab, options) {
    if (!TabManager.validateTab(tab)) {
      return;
    }
    const registeredTab = TabManager.mapCustomTabToRegisteredTab(
      tab,
      options?.layout
    );
    if (!registeredTab) {
      warn("Unable to register tab. Tab type not supported");
      return;
    }
    VehicleSheetRuntime.registerTab(registeredTab);
  }
  /**
   * Wraps the provided HTML so that Tidy will remove the content when handling document changes.
   * @param html any HTML string that needs to be re-rendered in the style of Foundry Handlebars (usually, this is any time the target document or its embedded documents change).
   * @returns the original HTML with a transparent element wrapped around which indicates to Tidy that this should be removed and re-rendered.
   *
   * @remarks
   * The intended use of this function is to accompany the use of the `tidy5e-sheet.renderActorSheet` or `tidy5e-sheet.renderItemSheet` hook.
   * Any content injected through those hooks needs to be wrapped in this way so that the old version
   * of the HTML can be removed before adding it back in.
   * Handlebars refreshes content in this way, but for Tidy purposes, the module needs to know when an arbitrary
   * segment of HTML is meant to be removed. This function provides that information to Tidy for your HTML.
   *
   * @example Injecting dynamic HTML through Tidy actor sheet render hook
   * ```js
   * Hooks.on('tidy5e-sheet.renderActorSheet', (app, element, data) => {
   *   const api = game.modules.get('tidy5e-sheet').api;
   *   const actorEmoji = data.actor.system.currency.pp > 0 ? '' : '';
   *   let iconHtml = api.useHandlebarsRendering(`<h1>${actorEmoji}</h1>`);
   *   //  This HTML looks like `<div style="display: contents;" data-tidy-render-scheme="handlebars"><h1></h1></div>`
   *   // if the actor doesn't have at least 1 platinum.
   *   // Tidy will remove this each time the sheet would normally re-render, and it will add it back.
   *   // When the actor have more than 0 platinum, stonks will rise.
   *
   *   let actorNameElement = element.querySelector(`[data-tidy-field="name"]`);
   *   actorNameElement?.insertAdjacentHTML('afterend', iconHtml);
   * });
   * ```
   */
  useHandlebarsRendering(html) {
    return `<div style="display: contents;" ${CONSTANTS.HTML_DYNAMIC_RENDERING_ATTRIBUTE}>${html}</div>`;
  }
}
const tidyFlagIdeal = "ideal";
const tidyFlagBond = "bond";
const tidyFlagFlaw = "flaw";
async function migrateBondsIdealsFlawsToSystem({
  npc,
  clearFlagData,
  overwrite
}) {
  if (!npc) {
    return;
  }
  try {
    let updates = {};
    let systemBond = (npc.system.details.bond ?? "").trim();
    if (systemBond === "" || overwrite) {
      updates["system.details.bond"] = TidyFlags.tryGetFlag(npc, tidyFlagBond) ?? "";
    }
    let systemIdeal = (npc.system.details.ideal ?? "").trim();
    if (systemIdeal === "" || overwrite) {
      updates["system.details.ideal"] = TidyFlags.tryGetFlag(npc, tidyFlagIdeal) ?? "";
    }
    let systemFlaw = (npc.system.details.flaw ?? "").trim();
    if (systemFlaw === "" || overwrite) {
      updates["system.details.flaw"] = TidyFlags.tryGetFlag(npc, tidyFlagFlaw) ?? "";
    }
    if (Object.keys(updates).length > 0) {
      await npc.update(updates);
    }
    if (clearFlagData) {
      await TidyFlags.unsetFlag(npc, tidyFlagIdeal);
      await TidyFlags.unsetFlag(npc, tidyFlagBond);
      await TidyFlags.unsetFlag(npc, tidyFlagFlaw);
    }
  } catch (e2) {
    error("An error occurred while migrating an NPC's bonds, ideals, and flaws", false, {
      error: e2,
      actor: npc,
      clearFlagData,
      overwrite
    });
    error(
      FoundryAdapter.localize(
        "TIDY5E.Settings.Migrations.migrationErrorMessage"
      ),
      true
    );
  }
}
function create_fragment$6(ctx) {
  let section;
  let h2;
  let t1;
  let h3;
  let t3;
  let div;
  let label0;
  let input0;
  let t4;
  let t5_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.OptionOverwrite.Text") + ""
  );
  let t5;
  let t6;
  let label1;
  let input1;
  let t7;
  let t8_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Text") + ""
  );
  let t8;
  let t9;
  let footer;
  let button0;
  let t10_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.MigrateCompendia.Title") + ""
  );
  let t10;
  let t11;
  let button1;
  let t12_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.ButtonMigration.Text") + ""
  );
  let t12;
  let mounted;
  let dispose;
  return {
    c() {
      section = element("section");
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.BondsIdealsFlawsToSystem.sectionTitle")}`;
      t1 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.OptionsHeader")}`;
      t3 = space();
      div = element("div");
      label0 = element("label");
      input0 = element("input");
      t4 = space();
      t5 = text(t5_value);
      t6 = space();
      label1 = element("label");
      input1 = element("input");
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      footer = element("footer");
      button0 = element("button");
      t10 = text(t10_value);
      t11 = space();
      button1 = element("button");
      t12 = text(t12_value);
      attr(input0, "type", "checkbox");
      input0.disabled = /*migrating*/
      ctx[0];
      attr(label0, "class", "green-checkbox");
      attr(
        label0,
        "data-tooltip",
        /*localize*/
        ctx[3]("TIDY5E.Settings.Migrations.OptionOverwrite.Tooltip")
      );
      attr(input1, "type", "checkbox");
      input1.disabled = /*migrating*/
      ctx[0];
      attr(label1, "class", "green-checkbox");
      attr(
        label1,
        "data-tooltip",
        /*localize*/
        ctx[3]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Tooltip")
      );
      attr(div, "class", "options grid-auto-columns svelte-1fnhfkf");
      attr(button0, "type", "button");
      button0.disabled = /*migrating*/
      ctx[0];
      attr(button1, "type", "button");
      button1.disabled = /*migrating*/
      ctx[0];
      attr(footer, "class", "flex-row extra-small-gap svelte-1fnhfkf");
      attr(section, "class", "svelte-1fnhfkf");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h2);
      append(section, t1);
      append(section, h3);
      append(section, t3);
      append(section, div);
      append(div, label0);
      append(label0, input0);
      input0.checked = /*overwrite*/
      ctx[2];
      append(label0, t4);
      append(label0, t5);
      append(div, t6);
      append(div, label1);
      append(label1, input1);
      input1.checked = /*deleteFlags*/
      ctx[1];
      append(label1, t7);
      append(label1, t8);
      append(section, t9);
      append(section, footer);
      append(footer, button0);
      append(button0, t10);
      append(footer, t11);
      append(footer, button1);
      append(button1, t12);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[7]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*migrating*/
      1) {
        input0.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*overwrite*/
      4) {
        input0.checked = /*overwrite*/
        ctx2[2];
      }
      if (dirty & /*migrating*/
      1) {
        input1.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*deleteFlags*/
      2) {
        input1.checked = /*deleteFlags*/
        ctx2[1];
      }
      if (dirty & /*migrating*/
      1) {
        button0.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*migrating*/
      1) {
        button1.disabled = /*migrating*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let migrating = false;
  let deleteFlags = false;
  let overwrite = false;
  const localize = FoundryAdapter.localize;
  async function migrate() {
    const actorsToMigrate = Array.from(game.actors).filter((a2) => a2.isOwner && a2.type === CONSTANTS.SHEET_TYPE_NPC);
    new MigrationSelectionApplication({
      onConfirm: async (selected) => {
        $$invalidate(0, migrating = true);
        ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationBeginningMessage"));
        for (let choice of selected) {
          await migrateBondsIdealsFlawsToSystem({
            npc: choice,
            clearFlagData: deleteFlags,
            overwrite
          });
        }
        ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationCompleteMessage"));
        resetOptions();
        $$invalidate(0, migrating = false);
      },
      columns: [
        {
          cellWidth: "primary",
          field: {
            type: "simple",
            propPath: "name",
            onClick: (target) => target.sheet.render(true)
          },
          name: localize("TIDY5E.Settings.Migrations.Selection.ToMigrate")
        }
      ],
      documents: actorsToMigrate,
      title: FoundryAdapter.localize("TIDY5E.Settings.Migrations.BondsIdealsFlawsToSystem.selectionDialogTitle")
    }).render(true);
  }
  async function migrateCompendia() {
    const compendiaForMigrating = Array.from(game.packs.values()).filter((c2) => !c2.locked && c2.documentName === "Actor").map((c2) => ({
      label: c2.metadata.label,
      type: c2.metadata.type,
      id: c2.metadata.id,
      size: c2.index.size
    }));
    new MigrationSelectionApplication({
      onConfirm: async (selected) => {
        ui.notifications.info(localize(`TIDY5E.Settings.Migrations.migrationBeginningMessage`));
        for (const compendium of selected) {
          debug(`Migrating compendium "${compendium.label}"...`);
          try {
            const actors = await game.packs.get(compendium.id).getDocuments();
            for (const actor of actors) {
              if (actor.type !== CONSTANTS.SHEET_TYPE_NPC) {
                continue;
              }
              await migrateBondsIdealsFlawsToSystem({
                npc: actor,
                overwrite,
                clearFlagData: deleteFlags
              });
            }
            debug(`Compendium "${compendium.label}" migration successful.`);
          } catch (e2) {
            error(localize("TIDY5E.Settings.Migrations.migrationErrorMessage"), true);
            error(`Error while migrating compendium "${compendium.label}"`, false, e2);
          }
        }
        ui.notifications.info(localize(`TIDY5E.Settings.Migrations.migrationCompleteMessage`));
      },
      columns: [
        {
          cellWidth: "primary",
          field: {
            type: "simple",
            propPath: "label",
            onClick: (target) => game.packs.get(target.id).render(true)
          },
          name: localize("TIDY5E.Settings.Migrations.MigrateCompendia.CompendiumLabel")
        },
        {
          cellWidth: "5rem",
          field: {
            type: "contextual",
            getText: (c2) => localize(`DOCUMENT.${c2.type}`)
          },
          name: localize("Type")
        },
        {
          cellWidth: "10rem",
          field: { type: "simple", propPath: "size" },
          name: localize("TIDY5E.Settings.Migrations.MigrateCompendia.TotalEntriesLabel")
        }
      ],
      documents: compendiaForMigrating,
      title: localize("TIDY5E.Settings.Migrations.MigrateCompendia.SelectionDialogTitle")
    }).render(true);
  }
  function resetOptions() {
    $$invalidate(1, deleteFlags = false);
    $$invalidate(2, overwrite = false);
  }
  function input0_change_handler() {
    overwrite = this.checked;
    $$invalidate(2, overwrite);
  }
  function input1_change_handler() {
    deleteFlags = this.checked;
    $$invalidate(1, deleteFlags);
  }
  const click_handler = (ev) => migrateCompendia();
  const click_handler_1 = (ev) => migrate();
  return [
    migrating,
    deleteFlags,
    overwrite,
    localize,
    migrate,
    migrateCompendia,
    input0_change_handler,
    input1_change_handler,
    click_handler,
    click_handler_1
  ];
}
class BondsIdealsFlawsToSystemMigration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
  }
}
const tidyFlagParentClass = "parentClass";
async function migrateSpellClassToSourceClass({
  item,
  clearFlagData,
  overwrite
}) {
  if (!item) {
    return;
  }
  try {
    let updates = {};
    let sourceClass = (item.system.sourceClass ?? "").trim();
    if (sourceClass === "" || overwrite) {
      updates["system.sourceClass"] = TidyFlags.tryGetFlag(item, tidyFlagParentClass) ?? "";
    }
    if (Object.keys(updates).length > 0) {
      await item.update(updates);
    }
    if (clearFlagData) {
      await TidyFlags.unsetFlag(item, tidyFlagParentClass);
    }
  } catch (e2) {
    error("An error occurred while migrating an item's parent class", false, {
      error: e2,
      item,
      clearFlagData,
      overwrite
    });
    error(
      FoundryAdapter.localize(
        "TIDY5E.Settings.Migrations.migrationErrorMessage"
      ),
      true
    );
  }
}
function create_fragment$5(ctx) {
  let section;
  let h2;
  let t1;
  let h3;
  let t3;
  let div;
  let label0;
  let input0;
  let t4;
  let t5_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.OptionOverwrite.Text") + ""
  );
  let t5;
  let t6;
  let label1;
  let input1;
  let t7;
  let t8_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Text") + ""
  );
  let t8;
  let t9;
  let footer;
  let button0;
  let t10_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.MigrateCompendia.Title") + ""
  );
  let t10;
  let t11;
  let button1;
  let t12_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.ButtonMigration.Text") + ""
  );
  let t12;
  let mounted;
  let dispose;
  return {
    c() {
      section = element("section");
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.SpellClassToSourceClass.sectionTitle")}`;
      t1 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.OptionsHeader")}`;
      t3 = space();
      div = element("div");
      label0 = element("label");
      input0 = element("input");
      t4 = space();
      t5 = text(t5_value);
      t6 = space();
      label1 = element("label");
      input1 = element("input");
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      footer = element("footer");
      button0 = element("button");
      t10 = text(t10_value);
      t11 = space();
      button1 = element("button");
      t12 = text(t12_value);
      attr(input0, "type", "checkbox");
      input0.disabled = /*migrating*/
      ctx[0];
      attr(label0, "class", "green-checkbox");
      attr(
        label0,
        "data-tooltip",
        /*localize*/
        ctx[3]("TIDY5E.Settings.Migrations.OptionOverwrite.Tooltip")
      );
      attr(input1, "type", "checkbox");
      input1.disabled = /*migrating*/
      ctx[0];
      attr(label1, "class", "green-checkbox");
      attr(
        label1,
        "data-tooltip",
        /*localize*/
        ctx[3]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Tooltip")
      );
      attr(div, "class", "options grid-auto-columns svelte-1fnhfkf");
      attr(button0, "type", "button");
      button0.disabled = /*migrating*/
      ctx[0];
      attr(button1, "type", "button");
      button1.disabled = /*migrating*/
      ctx[0];
      attr(footer, "class", "flex-row extra-small-gap svelte-1fnhfkf");
      attr(section, "class", "svelte-1fnhfkf");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h2);
      append(section, t1);
      append(section, h3);
      append(section, t3);
      append(section, div);
      append(div, label0);
      append(label0, input0);
      input0.checked = /*overwrite*/
      ctx[2];
      append(label0, t4);
      append(label0, t5);
      append(div, t6);
      append(div, label1);
      append(label1, input1);
      input1.checked = /*deleteFlags*/
      ctx[1];
      append(label1, t7);
      append(label1, t8);
      append(section, t9);
      append(section, footer);
      append(footer, button0);
      append(button0, t10);
      append(footer, t11);
      append(footer, button1);
      append(button1, t12);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "change",
            /*input0_change_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[7]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*migrating*/
      1) {
        input0.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*overwrite*/
      4) {
        input0.checked = /*overwrite*/
        ctx2[2];
      }
      if (dirty & /*migrating*/
      1) {
        input1.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*deleteFlags*/
      2) {
        input1.checked = /*deleteFlags*/
        ctx2[1];
      }
      if (dirty & /*migrating*/
      1) {
        button0.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*migrating*/
      1) {
        button1.disabled = /*migrating*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let migrating = false;
  let deleteFlags = false;
  let overwrite = false;
  const localize = FoundryAdapter.localize;
  async function migrate() {
    const actorItemsToMigrate = Array.from(game.actors).filter((a2) => a2.isOwner).map((a2) => ({ actor: a2, unlinked: false })).flatMap((value) => Array.from(value.actor.items).filter((item) => item.type === CONSTANTS.ITEM_TYPE_SPELL).map((item) => ({ item, unlinked: value.unlinked })));
    const worldItemsToMigrate = Array.from(game.items).map((item) => ({ item, unlinked: true }));
    const itemsToMigrate = [...actorItemsToMigrate, ...worldItemsToMigrate];
    new MigrationSelectionApplication({
      onConfirm: async (selected) => {
        $$invalidate(0, migrating = true);
        ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationBeginningMessage"));
        for (let choice of selected) {
          await migrateSpellClassToSourceClass({
            item: choice.item,
            clearFlagData: deleteFlags,
            overwrite
          });
        }
        ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationCompleteMessage"));
        resetOptions();
        $$invalidate(0, migrating = false);
      },
      columns: [
        {
          cellWidth: "primary",
          field: {
            type: "simple",
            propPath: "item.name",
            onClick: (target) => target.item.sheet.render(true)
          },
          name: localize("TIDY5E.Settings.Migrations.Selection.ToMigrate")
        },
        {
          cellWidth: "10rem",
          field: {
            type: "simple",
            propPath: `item.parent.name`,
            onClick: (target) => target.item.parent?.sheet?.render(true)
          },
          name: localize("TIDY5E.Settings.Migrations.Parent")
        },
        {
          cellWidth: "10rem",
          name: "",
          field: {
            type: "contextual",
            getText: ({ unlinked }) => unlinked ? FoundryAdapter.localize("TIDY5E.TokenUnlinked") : FoundryAdapter.localize("DOCUMENT.Actor")
          }
        }
      ],
      documents: itemsToMigrate,
      title: FoundryAdapter.localize("TIDY5E.Settings.Migrations.SpellClassToSourceClass.selectionDialogTitle")
    }).render(true);
  }
  async function migrateCompendia() {
    const compendiaForMigrating = Array.from(game.packs.values()).filter((c2) => !c2.locked && c2.documentName === "Item").map((c2) => ({
      label: c2.metadata.label,
      type: c2.metadata.type,
      id: c2.metadata.id,
      size: c2.index.size
    }));
    new MigrationSelectionApplication({
      onConfirm: async (selected) => {
        ui.notifications.info(localize(`TIDY5E.Settings.Migrations.migrationBeginningMessage`));
        for (const compendium of selected) {
          debug(`Migrating compendium "${compendium.label}"...`);
          try {
            const items = await game.packs.get(compendium.id).getDocuments();
            for (const item of items) {
              if (item.type !== CONSTANTS.ITEM_TYPE_SPELL) {
                continue;
              }
              await migrateSpellClassToSourceClass({
                item,
                overwrite,
                clearFlagData: deleteFlags
              });
            }
            debug(`Compendium "${compendium.label}" migration successful.`);
          } catch (e2) {
            error(localize("TIDY5E.Settings.Migrations.migrationErrorMessage"), true);
            error(`Error while migrating compendium "${compendium.label}"`, false, e2);
          }
        }
        ui.notifications.info(localize(`TIDY5E.Settings.Migrations.migrationCompleteMessage`));
      },
      columns: [
        {
          cellWidth: "primary",
          field: {
            type: "simple",
            propPath: "label",
            onClick: (target) => game.packs.get(target.id).render(true)
          },
          name: localize("TIDY5E.Settings.Migrations.MigrateCompendia.CompendiumLabel")
        },
        {
          cellWidth: "5rem",
          field: {
            type: "contextual",
            getText: (c2) => localize(`DOCUMENT.${c2.type}`)
          },
          name: localize("Type")
        },
        {
          cellWidth: "10rem",
          field: { type: "simple", propPath: "size" },
          name: localize("TIDY5E.Settings.Migrations.MigrateCompendia.TotalEntriesLabel")
        }
      ],
      documents: compendiaForMigrating,
      title: localize("TIDY5E.Settings.Migrations.MigrateCompendia.SelectionDialogTitle")
    }).render(true);
  }
  function resetOptions() {
    $$invalidate(1, deleteFlags = false);
    $$invalidate(2, overwrite = false);
  }
  function input0_change_handler() {
    overwrite = this.checked;
    $$invalidate(2, overwrite);
  }
  function input1_change_handler() {
    deleteFlags = this.checked;
    $$invalidate(1, deleteFlags);
  }
  const click_handler = (ev) => migrateCompendia();
  const click_handler_1 = (ev) => migrate();
  return [
    migrating,
    deleteFlags,
    overwrite,
    localize,
    migrate,
    migrateCompendia,
    input0_change_handler,
    input1_change_handler,
    click_handler,
    click_handler_1
  ];
}
class SpellClassToSourceClassMigration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
  }
}
const exhaustionFlag = "exhaustion";
async function migrateNpcExhaustionToSystem({
  npc,
  clearFlagData
}) {
  const tidyExhaustion = TidyFlags.tryGetFlag(
    npc,
    exhaustionFlag
  );
  if (tidyExhaustion === null || tidyExhaustion === void 0) {
    return;
  }
  await npc.update({
    "system.attributes.exhaustion": tidyExhaustion
  });
  if (clearFlagData) {
    TidyFlags.unsetFlag(npc, exhaustionFlag);
  }
}
function create_fragment$4(ctx) {
  let section;
  let h2;
  let t1;
  let p2;
  let t3;
  let h3;
  let t5;
  let div;
  let label;
  let input;
  let t6;
  let t7_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Text") + ""
  );
  let t7;
  let t8;
  let button;
  let t9_value = (
    /*localize*/
    ctx[3]("TIDY5E.Settings.Migrations.ButtonMigration.Text") + ""
  );
  let t9;
  let mounted;
  let dispose;
  return {
    c() {
      section = element("section");
      h2 = element("h2");
      h2.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.NpcExhaustion.sectionTitle")}`;
      t1 = space();
      p2 = element("p");
      p2.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.UnlinkedExplanation")}`;
      t3 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[3]("TIDY5E.Settings.Migrations.OptionsHeader")}`;
      t5 = space();
      div = element("div");
      label = element("label");
      input = element("input");
      t6 = space();
      t7 = text(t7_value);
      t8 = space();
      button = element("button");
      t9 = text(t9_value);
      attr(input, "type", "checkbox");
      input.disabled = /*migrating*/
      ctx[0];
      attr(label, "class", "green-checkbox");
      attr(
        label,
        "data-tooltip",
        /*localize*/
        ctx[3]("TIDY5E.Settings.Migrations.OptionDeleteFlags.Tooltip")
      );
      attr(div, "class", "options grid-auto-columns svelte-f3txbi");
      attr(button, "type", "button");
      button.disabled = /*migrating*/
      ctx[0];
      attr(button, "class", "svelte-f3txbi");
      attr(section, "class", "svelte-f3txbi");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, h2);
      append(section, t1);
      append(section, p2);
      append(section, t3);
      append(section, h3);
      append(section, t5);
      append(section, div);
      append(div, label);
      append(label, input);
      input.checked = /*deleteFlags*/
      ctx[1];
      append(label, t6);
      append(label, t7);
      append(section, t8);
      append(section, button);
      append(button, t9);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[4]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*migrating*/
      1) {
        input.disabled = /*migrating*/
        ctx2[0];
      }
      if (dirty & /*deleteFlags*/
      2) {
        input.checked = /*deleteFlags*/
        ctx2[1];
      }
      if (dirty & /*migrating*/
      1) {
        button.disabled = /*migrating*/
        ctx2[0];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let migrating = false;
  let deleteFlags = false;
  async function migrate() {
    try {
      const actorsToMigrate = Array.from(game.actors).filter((a2) => a2.type === CONSTANTS.SHEET_TYPE_NPC && a2.isOwner).map((a2) => ({ actor: a2, unlinked: false }));
      const tokenActors = Array.from(canvas?.scene?.tokens ?? []).filter((t2) => t2.actor?.type === CONSTANTS.SHEET_TYPE_NPC && !t2.actor.prototypeToken?.actorLink && t2.actor.isOwner).map((t2) => ({ actor: t2.actor, unlinked: true }));
      actorsToMigrate.push(...tokenActors);
      new MigrationSelectionApplication(
        {
          onConfirm: async (selected) => {
            $$invalidate(0, migrating = true);
            ui.notifications.info(localize("TIDY5E.Settings.Migrations.migrationBeginningMessage"));
            migrateActors(selected.map((s2) => s2.actor));
          },
          columns: [
            {
              cellWidth: "primary",
              field: {
                type: "simple",
                propPath: "actor.name",
                onClick: (target) => target.actor.sheet.render(true)
              },
              name: localize("TIDY5E.Settings.Migrations.Selection.ToMigrate")
            },
            {
              cellWidth: "5rem",
              field: {
                type: "simple",
                propPath: `actor.flags.${CONSTANTS.MODULE_ID}.exhaustion`
              },
              name: localize("DND5E.Exhaustion")
            },
            {
              cellWidth: "10rem",
              name: "",
              field: {
                type: "contextual",
                getText: ({ unlinked }) => unlinked ? FoundryAdapter.localize("TIDY5E.TokenUnlinked") : FoundryAdapter.localize("DOCUMENT.Actor")
              }
            }
          ],
          documents: actorsToMigrate,
          title: FoundryAdapter.localize("TIDY5E.Settings.Migrations.NpcExhaustion.selectionDialogTitle")
        },
        () => {
          $$invalidate(0, migrating = false);
        }
      ).render(true);
    } catch (e2) {
      error("An error occurred while preparing a bulk migration", false, e2);
    }
  }
  async function migrateActors(actors) {
    try {
      for (let actorToMigrate of actors) {
        await migrateActor(actorToMigrate);
      }
    } finally {
      $$invalidate(0, migrating = false);
      ui.notifications.info(FoundryAdapter.localize("TIDY5E.Settings.Migrations.migrationCompleteMessage"));
      resetOptions();
    }
  }
  function resetOptions() {
    $$invalidate(1, deleteFlags = false);
  }
  async function migrateActor(actor) {
    try {
      debug(`Migrating actor ${actor?.name}...`);
      migrateNpcExhaustionToSystem({ npc: actor, clearFlagData: deleteFlags });
      debug(`Actor ${actor?.name} migration successful!`);
    } catch (e2) {
      error(`An error occurred while migrating NPC exhaustion data for ${actor?.name}`, false, e2);
      ui.notifications.error(FoundryAdapter.localize("TIDY5E.Settings.Migrations.migrationErrorMessage"), { permanent: true });
    }
  }
  const localize = FoundryAdapter.localize;
  function input_change_handler() {
    deleteFlags = this.checked;
    $$invalidate(1, deleteFlags);
  }
  const click_handler = (ev) => migrate();
  return [migrating, deleteFlags, migrate, localize, input_change_handler, click_handler];
}
class NpcExhaustionToSystemMigration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
  }
}
function create_default_slot$1(ctx) {
  let t_value = (
    /*localize*/
    ctx[1]("TIDY5E.ReminderToBackUp") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$3(ctx) {
  let div2;
  let div1;
  let tabs_1;
  let updating_selectedTabId;
  let t0;
  let div0;
  let t1;
  let notice;
  let t2;
  let tabcontents;
  let current;
  function tabs_1_selectedTabId_binding(value) {
    ctx[3](value);
  }
  let tabs_1_props = {
    tabs: (
      /*tabs*/
      ctx[2]
    ),
    orientation: "vertical"
  };
  if (
    /*selectedTabId*/
    ctx[0] !== void 0
  ) {
    tabs_1_props.selectedTabId = /*selectedTabId*/
    ctx[0];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind(tabs_1, "selectedTabId", tabs_1_selectedTabId_binding));
  notice = new Notice({
    props: {
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  tabcontents = new TabContents({
    props: {
      tabs: (
        /*tabs*/
        ctx[2]
      ),
      selectedTabId: (
        /*selectedTabId*/
        ctx[0]
      ),
      cssClass: "tidy-sheet-body"
    }
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      create_component(tabs_1.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = space();
      create_component(notice.$$.fragment);
      t2 = space();
      create_component(tabcontents.$$.fragment);
      attr(div0, "role", "presentation");
      attr(div0, "class", "remaining-vertical-space svelte-1b575i");
      attr(div1, "role", "presentation");
      attr(div1, "class", "vertical-tab-container flex-column no-gap svelte-1b575i");
      attr(div2, "class", "bulk-migrations-container svelte-1b575i");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      mount_component(tabs_1, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div1, t1);
      mount_component(notice, div1, null);
      append(div2, t2);
      mount_component(tabcontents, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tabs_1_changes = {};
      if (!updating_selectedTabId && dirty & /*selectedTabId*/
      1) {
        updating_selectedTabId = true;
        tabs_1_changes.selectedTabId = /*selectedTabId*/
        ctx2[0];
        add_flush_callback(() => updating_selectedTabId = false);
      }
      tabs_1.$set(tabs_1_changes);
      const notice_changes = {};
      if (dirty & /*$$scope*/
      16) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
      const tabcontents_changes = {};
      if (dirty & /*selectedTabId*/
      1) tabcontents_changes.selectedTabId = /*selectedTabId*/
      ctx2[0];
      tabcontents.$set(tabcontents_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(notice.$$.fragment, local);
      transition_in(tabcontents.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(notice.$$.fragment, local);
      transition_out(tabcontents.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(tabs_1);
      destroy_component(notice);
      destroy_component(tabcontents);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { selectedTabId = CONSTANTS.TAB_MIGRATIONS_SPELL_CLASS_TO_SOURCE_CLASS } = $$props;
  const localize = FoundryAdapter.localize;
  const tabs = [
    {
      id: CONSTANTS.TAB_MIGRATIONS_NPC_EXHAUSTION,
      title: "TIDY5E.Settings.Migrations.NpcExhaustion.sectionTitle",
      content: {
        component: NpcExhaustionToSystemMigration,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_MIGRATIONS_SPELL_CLASS_TO_SOURCE_CLASS,
      title: "TIDY5E.Settings.Migrations.SpellClassToSourceClass.sectionTitle",
      content: {
        component: SpellClassToSourceClassMigration,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_MIGRATIONS_BONDS_IDEALS_FLAWS_TO_SYSTEM,
      title: "TIDY5E.Settings.Migrations.BondsIdealsFlawsToSystem.sectionTitle",
      content: {
        component: BondsIdealsFlawsToSystemMigration,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_MIGRATIONS_FAVORITES_TO_SYSTEM,
      title: "TIDY5E.Settings.Migrations.FavoritesToSystem.sectionTitle",
      content: {
        component: FavoritesToSystemMigration,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_MIGRATIONS_CCSS_TO_TIDY,
      title: "TIDY5E.Settings.Migrations.CcssToTidy.sectionTitle",
      content: {
        component: CcssToTidyMigration,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_MIGRATIONS_NPC_DEATH,
      title: "TIDY5E.Settings.Migrations.NpcDeathSaves.sectionTitle",
      content: {
        component: NpcDeathSavesMigration,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_MIGRATIONS_CHARACTER_BIOGRAPHY,
      title: "TIDY5E.Settings.Migrations.CharacterBiography.sectionTitle",
      content: {
        component: CharacterBiographyMigration,
        type: "svelte"
      }
    },
    {
      id: CONSTANTS.TAB_MIGRATIONS_V1_ONBOARDING,
      title: "TIDY5E.Settings.Migrations.v1.sectionTitle",
      content: {
        component: V1OnboardingMigration,
        type: "svelte"
      }
    }
  ];
  function tabs_1_selectedTabId_binding(value) {
    selectedTabId = value;
    $$invalidate(0, selectedTabId);
  }
  $$self.$$set = ($$props2) => {
    if ("selectedTabId" in $$props2) $$invalidate(0, selectedTabId = $$props2.selectedTabId);
  };
  return [selectedTabId, localize, tabs, tabs_1_selectedTabId_binding];
}
class BulkMigrations extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { selectedTabId: 0 });
  }
}
class BulkMigrationsApplication extends SvelteFormApplicationBase {
  _selectedTabId;
  constructor(selectedTabId) {
    super();
    this._selectedTabId = selectedTabId;
  }
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      title: FoundryAdapter.localize("TIDY5E.Settings.Migrations.dialogTitle"),
      width: 650,
      height: 500,
      id: "tidy-5e-sheets-bulk-migrations",
      popOut: true
    });
  }
  createComponent(node) {
    return new BulkMigrations({
      target: node,
      context: /* @__PURE__ */ new Map([["confirm", this.confirm]]),
      props: {
        selectedTabId: this._selectedTabId
      }
    });
  }
  confirm(onYes) {
    const dlg = new Dialog({
      title: FoundryAdapter.localize(
        "TIDY5E.Settings.Migrations.migrateConfirmTitle"
      ),
      content: `
        <p>${FoundryAdapter.localize(
        "TIDY5E.Settings.Migrations.migrateConfirmMessage1"
      )}</p>
        <p><em>${FoundryAdapter.localize(
        "TIDY5E.Settings.Migrations.migrateConfirmMessage2",
        { boldStart: "<strong>", boldEnd: "</strong>" }
      )}</em></p>
      `,
      buttons: {
        yes: {
          icon: '<i class="fas fa-right-left"></i>',
          label: FoundryAdapter.localize(
            "TIDY5E.Settings.Migrations.migrateConfirmButtonYes"
          ),
          callback: () => {
            onYes();
          }
        },
        cancel: {
          icon: '<i class="fas fa-times"></i>',
          label: FoundryAdapter.localize(
            "TIDY5E.Settings.Migrations.migrateConfirmButtonNo"
          )
        }
      },
      default: "yes",
      close: () => {
      }
    });
    dlg.render(true);
  }
}
function create_fragment$2(ctx) {
  let div;
  let a2;
  let img;
  let img_src_value;
  let t0;
  let p0;
  let raw0_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.About.MaintainerParagraph", {
      urlStart: '<a href="https://github.com/kgar" target="_blank">',
      urlEnd: "</a>"
    }) + ""
  );
  let t1;
  let p1;
  let raw1_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.About.GithubParagraph", {
      urlStart: '<a href="https://github.com/kgar/foundry-vtt-tidy-5e-sheets/issues" target="_blank">',
      urlEnd: "</a>"
    }) + ""
  );
  let t2;
  let h3;
  let t4;
  let p2;
  let raw2_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.About.DiscordParagraph", {
      urlStart: '<a href="https://discord.gg/kdqbcWJrYU" target="_blank">',
      urlEnd: "</a>"
    }) + ""
  );
  let t5;
  let p3;
  let raw3_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.About.LocalizationParagraph", {
      urlStart: '<a href="https://hosted.weblate.org/projects/foundry-vtt-tidy-5e-sheets/" target="_blank">',
      urlEnd: "</a>"
    }) + ""
  );
  let t6;
  let p4;
  let t8;
  let ul;
  let li0;
  let raw4_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.About.BuyMeACoffeeLink", {
      urlStart: '<a href="https://www.buymeacoffee.com/kgar" target="_blank">',
      urlEnd: "</a>"
    }) + ""
  );
  let t9;
  let li1;
  let raw5_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.About.KoFiLink", {
      urlStart: '<a href="https://ko-fi.com/iamkgar" target="_blank">',
      urlEnd: "</a>"
    }) + ""
  );
  let t10;
  let li2;
  let raw6_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.About.PatreonLink", {
      urlStart: '<a href="https://www.patreon.com/iamkgar" target="_blank">',
      urlEnd: "</a>"
    }) + ""
  );
  return {
    c() {
      div = element("div");
      a2 = element("a");
      img = element("img");
      t0 = space();
      p0 = element("p");
      t1 = space();
      p1 = element("p");
      t2 = space();
      h3 = element("h3");
      h3.textContent = `${/*localize*/
      ctx[0]("TIDY5E.Settings.About.FinancialSupportHeader")}`;
      t4 = space();
      p2 = element("p");
      t5 = space();
      p3 = element("p");
      t6 = space();
      p4 = element("p");
      p4.textContent = `${/*localize*/
      ctx[0]("TIDY5E.Settings.About.FinancialSupportParagraph")}`;
      t8 = space();
      ul = element("ul");
      li0 = element("li");
      t9 = space();
      li1 = element("li");
      t10 = space();
      li2 = element("li");
      attr(img, "class", "logo svelte-1nrgzlj");
      if (!src_url_equal(img.src, img_src_value = "../modules/tidy5e-sheet/images/tidy-5e-logo.svg")) attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*localize*/
        ctx[0]("TIDY5E.Settings.About.logoAltText")
      );
      attr(a2, "href", "https://foundryvtt.com/packages/tidy5e-sheet/");
      attr(a2, "target", "_blank");
      attr(p0, "class", "banner-text");
      attr(div, "class", "tidy-info-banner svelte-1nrgzlj");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a2);
      append(a2, img);
      append(div, t0);
      append(div, p0);
      p0.innerHTML = raw0_value;
      insert(target, t1, anchor);
      insert(target, p1, anchor);
      p1.innerHTML = raw1_value;
      insert(target, t2, anchor);
      insert(target, h3, anchor);
      insert(target, t4, anchor);
      insert(target, p2, anchor);
      p2.innerHTML = raw2_value;
      insert(target, t5, anchor);
      insert(target, p3, anchor);
      p3.innerHTML = raw3_value;
      insert(target, t6, anchor);
      insert(target, p4, anchor);
      insert(target, t8, anchor);
      insert(target, ul, anchor);
      append(ul, li0);
      li0.innerHTML = raw4_value;
      append(ul, t9);
      append(ul, li1);
      li1.innerHTML = raw5_value;
      append(ul, t10);
      append(ul, li2);
      li2.innerHTML = raw6_value;
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t1);
        detach(p1);
        detach(t2);
        detach(h3);
        detach(t4);
        detach(p2);
        detach(t5);
        detach(p3);
        detach(t6);
        detach(p4);
        detach(t8);
        detach(ul);
      }
    }
  };
}
function instance$2($$self) {
  const localize = FoundryAdapter.localize;
  return [localize];
}
class About extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {});
  }
}
class AboutApplication extends SvelteFormApplicationBase {
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      width: 450,
      height: "auto",
      sheetConfig: false,
      id: "tidy-5e-sheets-about-window",
      popOut: true
    });
  }
  get title() {
    return FoundryAdapter.localize("TIDY5E.Settings.About.dialogTitle");
  }
  createComponent(node) {
    return new About({
      target: node
    });
  }
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = list;
  child_ctx[14] = i2;
  const constants_0 = getRandomId();
  child_ctx[12] = constants_0;
  return child_ctx;
}
function create_default_slot_5(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(
        input,
        "title",
        /*localize*/
        ctx[4]("TIDY5E.Settings.Migrations.Selection.SelectAllNoneTooltip")
      );
      attr(input, "class", "svelte-ehntvq");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*allSelected*/
      ctx[3];
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[8]
          ),
          listen(
            input,
            "click",
            /*click_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*allSelected*/
      8) {
        input.checked = /*allSelected*/
        ctx2[3];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_4(ctx) {
  let t_value = (
    /*localize*/
    ctx[4]("Sheet") + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3(ctx) {
  let tidytableheadercell0;
  let t2;
  let tidytableheadercell1;
  let current;
  tidytableheadercell0 = new TidyTableHeaderCell({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  tidytableheadercell1 = new TidyTableHeaderCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheadercell0.$$.fragment);
      t2 = space();
      create_component(tidytableheadercell1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheadercell0, target, anchor);
      insert(target, t2, anchor);
      mount_component(tidytableheadercell1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheadercell0_changes = {};
      if (dirty & /*$$scope, allSelected*/
      32776) {
        tidytableheadercell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell0.$set(tidytableheadercell0_changes);
      const tidytableheadercell1_changes = {};
      if (dirty & /*$$scope*/
      32768) {
        tidytableheadercell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheadercell1.$set(tidytableheadercell1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheadercell0.$$.fragment, local);
      transition_in(tidytableheadercell1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheadercell0.$$.fragment, local);
      transition_out(tidytableheadercell1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(tidytableheadercell0, detaching);
      destroy_component(tidytableheadercell1, detaching);
    }
  };
}
function create_header_slot(ctx) {
  let tidytableheaderrow;
  let current;
  tidytableheaderrow = new TidyTableHeaderRow({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytableheaderrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytableheaderrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytableheaderrow_changes = {};
      if (dirty & /*$$scope, allSelected*/
      32776) {
        tidytableheaderrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytableheaderrow.$set(tidytableheaderrow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytableheaderrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytableheaderrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytableheaderrow, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let input;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[7].call(
      input,
      /*each_value*/
      ctx[13],
      /*option_index*/
      ctx[14]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(
        input,
        "id",
        /*checkboxId*/
        ctx[12]
      );
      attr(input, "class", "svelte-ehntvq");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = /*option*/
      ctx[11].selected;
      if (!mounted) {
        dispose = listen(input, "change", input_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options*/
      1) {
        input.checked = /*option*/
        ctx[11].selected;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1(ctx) {
  let label;
  let t_value = (
    /*option*/
    ctx[11].label + ""
  );
  let t2;
  return {
    c() {
      label = element("label");
      t2 = text(t_value);
      attr(
        label,
        "for",
        /*checkboxId*/
        ctx[12]
      );
      attr(label, "class", "svelte-ehntvq");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      1 && t_value !== (t_value = /*option*/
      ctx2[11].label + "")) set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
    }
  };
}
function create_default_slot(ctx) {
  let tidytablecell0;
  let t0;
  let tidytablecell1;
  let t1;
  let current;
  tidytablecell0 = new TidyTableCell({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  tidytablecell1 = new TidyTableCell({
    props: {
      primary: true,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytablecell0.$$.fragment);
      t0 = space();
      create_component(tidytablecell1.$$.fragment);
      t1 = space();
    },
    m(target, anchor) {
      mount_component(tidytablecell0, target, anchor);
      insert(target, t0, anchor);
      mount_component(tidytablecell1, target, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytablecell0_changes = {};
      if (dirty & /*$$scope, options*/
      32769) {
        tidytablecell0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell0.$set(tidytablecell0_changes);
      const tidytablecell1_changes = {};
      if (dirty & /*$$scope, options*/
      32769) {
        tidytablecell1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablecell1.$set(tidytablecell1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytablecell0.$$.fragment, local);
      transition_in(tidytablecell1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytablecell0.$$.fragment, local);
      transition_out(tidytablecell1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(tidytablecell0, detaching);
      destroy_component(tidytablecell1, detaching);
    }
  };
}
function create_each_block$1(ctx) {
  let tidytablerow;
  let current;
  tidytablerow = new TidyTableRow({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tidytablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tidytablerow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tidytablerow_changes = {};
      if (dirty & /*$$scope, options*/
      32769) {
        tidytablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytablerow.$set(tidytablerow_changes);
    },
    i(local) {
      if (current) return;
      transition_in(tidytablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tidytablerow, detaching);
    }
  };
}
function create_body_slot(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*getRandomId, options*/
      1) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[0]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let div2;
  let div0;
  let t1;
  let div1;
  let tidytable;
  let div;
  let t2;
  let footer;
  let p2;
  let t3_value = (
    /*localize*/
    ctx[4]("TIDY5E.Settings.Migrations.Selection.TotalSelectedLabel", { total: (
      /*totalSelected*/
      ctx[2]
    ) }) + ""
  );
  let t3;
  let t4;
  let button;
  let current;
  let mounted;
  let dispose;
  tidytable = new TidyTable({
    props: {
      key: "default-sheet-preferences",
      toggleable: false,
      $$slots: {
        body: [create_body_slot],
        header: [create_header_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = `${/*localize*/
      ctx[4]("TIDY5E.Settings.SheetPreferences.explanation")}`;
      t1 = space();
      div1 = element("div");
      div = element("div");
      create_component(tidytable.$$.fragment);
      t2 = space();
      footer = element("footer");
      p2 = element("p");
      t3 = text(t3_value);
      t4 = space();
      button = element("button");
      button.textContent = `${/*localize*/
      ctx[4]("TIDY5E.ButtonConfirm.Text")}`;
      attr(div0, "class", "p");
      set_style(div, "display", "contents");
      set_style(
        div,
        "--grid-template-columns",
        /*gridTemplateColumns*/
        ctx[5]
      );
      attr(div1, "class", "scroll-container svelte-ehntvq");
      attr(button, "type", "button");
      attr(footer, "class", "svelte-ehntvq");
      attr(div2, "class", "sheet-preferences-container svelte-ehntvq");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, div);
      mount_component(tidytable, div, null);
      append(div2, t2);
      append(div2, footer);
      append(footer, p2);
      append(p2, t3);
      append(footer, t4);
      append(footer, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const tidytable_changes = {};
      if (dirty & /*$$scope, options, allSelected*/
      32777) {
        tidytable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tidytable.$set(tidytable_changes);
      if ((!current || dirty & /*totalSelected*/
      4) && t3_value !== (t3_value = /*localize*/
      ctx2[4]("TIDY5E.Settings.Migrations.Selection.TotalSelectedLabel", { total: (
        /*totalSelected*/
        ctx2[2]
      ) }) + "")) set_data(t3, t3_value);
    },
    i(local) {
      if (current) return;
      transition_in(tidytable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tidytable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(tidytable);
      mounted = false;
      dispose();
    }
  };
}
function getRandomId() {
  return foundry.utils.randomID();
}
function instance$1($$self, $$props, $$invalidate) {
  let totalSelected;
  let allSelected;
  let { options } = $$props;
  let { onConfirm } = $$props;
  const localize = FoundryAdapter.localize;
  const gridTemplateColumns = `
    /* Select */ 2.5rem 
    /* Label */ 1fr`;
  function toggleAll() {
    const targetState = !allSelected;
    options.forEach((o2) => o2.selected = targetState);
  }
  function input_change_handler(each_value, option_index) {
    each_value[option_index].selected = this.checked;
    $$invalidate(0, options);
  }
  function input_change_handler_1() {
    allSelected = this.checked;
    $$invalidate(3, allSelected), $$invalidate(2, totalSelected), $$invalidate(0, options);
  }
  const click_handler = () => toggleAll();
  const click_handler_1 = () => onConfirm(options);
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2) $$invalidate(0, options = $$props2.options);
    if ("onConfirm" in $$props2) $$invalidate(1, onConfirm = $$props2.onConfirm);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*options*/
    1) {
      $$invalidate(2, totalSelected = options.filter((t2) => t2.selected).length);
    }
    if ($$self.$$.dirty & /*totalSelected, options*/
    5) {
      $$invalidate(3, allSelected = totalSelected >= options.length);
    }
  };
  return [
    options,
    onConfirm,
    totalSelected,
    allSelected,
    localize,
    gridTemplateColumns,
    toggleAll,
    input_change_handler,
    input_change_handler_1,
    click_handler,
    click_handler_1
  ];
}
class ApplyTidySheetPreferences extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { options: 0, onConfirm: 1 });
  }
}
const supportedSheetClasses = [
  Tidy5eCharacterSheet.name,
  Tidy5eNpcSheet.name,
  Tidy5eVehicleSheet.name,
  Tidy5eKgarItemSheet.name,
  Tidy5eKgarContainerSheet.name
];
class ApplyTidySheetPreferencesApplication extends SvelteFormApplicationBase {
  static get defaultOptions() {
    return FoundryAdapter.mergeObject(super.defaultOptions, {
      width: 650,
      height: 500,
      id: "tidy-5e-sheet-preferences",
      popOut: true,
      title: FoundryAdapter.localize("TIDY5E.Settings.SheetPreferences.name")
    });
  }
  createComponent(node) {
    return new ApplyTidySheetPreferences({
      target: node,
      props: {
        options: this.getTidySheetPreferenceOptions(),
        onConfirm: this._onConfirm.bind(this)
      }
    });
  }
  getTidySheetPreferenceOptions() {
    const sheetClassOptions = [];
    const setting = game.settings.get("core", "sheetClasses");
    for (const { documentName, hasTypeData } of Object.values(
      foundry.documents
    )) {
      if (!hasTypeData) {
        continue;
      }
      const subTypes = game.documentTypes[documentName].filter(
        (t2) => t2 !== CONST.BASE_DOCUMENT_TYPE
      );
      if (!subTypes.length) {
        continue;
      }
      for (let subType of subTypes) {
        const { defaultClasses } = DocumentSheetConfig.getSheetClassesForSubType(documentName, subType);
        const tidySheetClass = Object.keys(defaultClasses).find(
          (c2) => supportedSheetClasses.includes(c2.split(".").at(-1) ?? "Not Found")
        );
        if (!tidySheetClass) {
          continue;
        }
        const typeLabel = FoundryAdapter.localize(
          CONFIG[documentName].typeLabels?.[subType]
        );
        const isDefault = tidySheetClass === foundry.utils.getProperty(setting, `${documentName}.${subType}`);
        sheetClassOptions.push({
          label: typeLabel,
          documentName,
          subType,
          sheetClassIdentifier: tidySheetClass,
          selected: isDefault
        });
      }
    }
    return sheetClassOptions;
  }
  async _onConfirm(options) {
    try {
      let sheetSettings = this.getSheetClassesSetting();
      options.forEach((o2) => {
        const compositeSettingKey = `${o2.documentName}.${o2.subType}`;
        if (o2.selected) {
          debug(
            `Tidy Sheet ${o2.sheetClassIdentifier} selected; ensuring it is set in settings.`
          );
          sheetSettings = foundry.utils.mergeObject(sheetSettings, {
            [compositeSettingKey]: o2.sheetClassIdentifier
          });
          return;
        }
        debug(
          `Tidy Sheet ${o2.sheetClassIdentifier} unselected; checking setting.`
        );
        const currentSetting = foundry.utils.getProperty(
          sheetSettings,
          compositeSettingKey
        );
        if (currentSetting !== o2.sheetClassIdentifier) {
          debug(
            `Tidy Sheet ${o2.sheetClassIdentifier} not currently configured and is unselected; ignoring.`
          );
          return;
        }
        debug(
          `Tidy Sheet ${o2.sheetClassIdentifier} currently configured and is unselected; removing setting.`
        );
        delete sheetSettings[o2.documentName][o2.subType];
        if (Object.keys(sheetSettings[o2.documentName]).length === 0) {
          debug(
            `${o2.documentName} is now empty. Pruning property from settings.`
          );
          delete sheetSettings[o2.documentName];
        }
      });
      await game.settings.set("core", "sheetClasses", sheetSettings);
      debug("New sheetClasses settings", { sheetClasses: sheetSettings });
      this.close();
      Dialog.confirm({
        title: FoundryAdapter.localize("SETTINGS.ReloadPromptTitle"),
        content: FoundryAdapter.localize("SETTINGS.ReloadPromptBody"),
        yes: () => foundry.utils.debouncedReload(),
        no: () => {
        },
        defaultYes: true
      });
    } catch (e2) {
      error(FoundryAdapter.localize("TIDY5E.GenericErrorNotification"), true, {
        error: e2
      });
    }
  }
  getSheetClassesSetting() {
    return game.settings.get("core", "sheetClasses");
  }
}
function getCurrentSettings() {
  const keys = Object.keys(
    SettingsProvider.settings
  );
  return keys.reduce((obj, key) => {
    obj[key] = SettingsProvider.settings[key].get();
    return obj;
  }, {});
}
let settingStore;
function createSettings() {
  const isV12OrNewer = FoundryAdapter.isFoundryV12OrHigher();
  return {
    menus: {
      worldSettings: {
        options: {
          name: `TIDY5E.WorldSettings.Menu.name`,
          label: "TIDY5E.WorldSettings.Menu.label",
          hint: `TIDY5E.WorldSettings.Menu.hint`,
          icon: "fa-solid fa-globe",
          type: WorldSettingsFormApplication,
          restricted: true
        }
      },
      userMenu: {
        options: {
          name: `TIDY5E.UserSettings.Menu.name`,
          label: "TIDY5E.UserSettings.Menu.label",
          hint: `TIDY5E.UserSettings.Menu.hint`,
          icon: "fa-solid fa-user-gear",
          type: UserSettingsFormApplication,
          restricted: false
        }
      },
      theme: {
        options: {
          name: `TIDY5E.ThemeSettings.SheetMenu.name`,
          label: "TIDY5E.ThemeSettings.SheetMenu.buttonLabel",
          hint: `TIDY5E.ThemeSettings.SheetMenu.hint`,
          icon: "fa-solid fa-palette",
          type: ThemeSettingsFormApplication,
          restricted: false
        }
      },
      resetAllSettings: {
        options: {
          name: `TIDY5E.Settings.Reset.name`,
          hint: `TIDY5E.Settings.Reset.hint`,
          icon: "fa-solid fa-database",
          type: ResetSettingsDialog,
          restricted: true
        }
      },
      migrations: {
        options: {
          name: `TIDY5E.Settings.Migrations.name`,
          label: "TIDY5E.Settings.Migrations.buttonLabel",
          hint: `TIDY5E.Settings.Migrations.hint`,
          icon: "fa-solid fa-right-left",
          type: BulkMigrationsApplication,
          restricted: true
        }
      },
      applyTidySheetPreferences: {
        options: {
          name: `TIDY5E.Settings.SheetPreferences.name`,
          label: "TIDY5E.Settings.SheetPreferences.buttonLabel",
          hint: `TIDY5E.Settings.SheetPreferences.hint`,
          icon: "fa-solid fa-file-pen",
          type: ApplyTidySheetPreferencesApplication,
          restricted: true
        }
      },
      about: {
        options: {
          name: `TIDY5E.Settings.About.name`,
          label: "TIDY5E.Settings.About.buttonLabel",
          hint: `TIDY5E.Settings.About.hint`,
          icon: "fa-solid fa-question",
          type: AboutApplication,
          restricted: false
        }
      }
    },
    settings: {
      migrationsConfirmationTally: {
        options: {
          name: "Migrations Confirmation Tally",
          hint: 'Developer Only: This field tells the developer when was the last time the GM indicated "Do Not Show Again" for a migration notification. This is so Tidy does not notify of migrations until a new migration has become available. A migration tick counter increments each release where a migration has become available.',
          scope: "world",
          config: false,
          type: Number,
          default: 0
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "migrationsConfirmationTally"
          );
        }
      },
      defaultTheme: {
        options: {
          name: "TIDY5E.Settings.DefaultTheme.name",
          hint: "TIDY5E.Settings.DefaultTheme.hint",
          scope: "world",
          config: true,
          type: isV12OrNewer ? new foundry.data.fields.StringField({
            required: true,
            blank: false,
            initial: CONSTANTS.THEME_ID_DEFAULT_LIGHT,
            choices: () => getCoreThemes(false)
          }) : String,
          choices: isV12OrNewer ? void 0 : () => getCoreThemes(false),
          default: isV12OrNewer ? void 0 : CONSTANTS.THEME_ID_DEFAULT_LIGHT,
          onChange: (data) => {
            const theme = getThemeOrDefault(data);
            const colorScheme = SettingsProvider.settings.colorScheme.get();
            if (theme && colorScheme === CONSTANTS.THEME_ID_DEFAULT) {
              applyTheme(theme);
            }
          }
        },
        get() {
          return FoundryAdapter.getTidySetting("defaultTheme");
        }
      },
      // Color Theme
      colorScheme: {
        options: {
          name: "TIDY5E.Settings.SheetTheme.name",
          hint: "TIDY5E.Settings.SheetTheme.hint",
          scope: "client",
          config: true,
          type: isV12OrNewer ? new foundry.data.fields.StringField({
            required: true,
            blank: false,
            initial: CONSTANTS.THEME_ID_DEFAULT,
            choices: () => getCoreThemes(true)
          }) : String,
          choices: isV12OrNewer ? void 0 : () => getCoreThemes(true),
          default: isV12OrNewer ? void 0 : CONSTANTS.THEME_ID_DEFAULT,
          onChange: (data, colorPickerEnabledOverride = null) => {
            const theme = getThemeOrDefault(data);
            applyTheme(theme, colorPickerEnabledOverride);
          }
        },
        get() {
          return FoundryAdapter.getTidySetting("colorScheme");
        }
      },
      // Context Menu
      useContextMenu: {
        options: {
          name: "TIDY5E.Settings.UseContextMenu.name",
          hint: "TIDY5E.Settings.UseContextMenu.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useContextMenu");
        }
      },
      // Player Character Settings
      initialCharacterSheetTab: {
        options: {
          name: "TIDY5E.Settings.InitialSheetTab.name",
          hint: "TIDY5E.Settings.InitialSheetTab.hint",
          scope: "world",
          config: false,
          type: String,
          choices: () => TabManager.getTabsAsConfigOptions(
            CharacterSheetRuntime.getAllRegisteredTabs()
          ),
          default: CONSTANTS.TAB_CHARACTER_ATTRIBUTES
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "initialCharacterSheetTab"
          );
        }
      },
      defaultCharacterSheetTabs: {
        options: {
          name: "TIDY5E.Settings.DefaultSheetTabs.name",
          hint: "TIDY5E.Settings.DefaultSheetTabs.hint",
          scope: "world",
          config: false,
          type: Array,
          default: [
            CONSTANTS.TAB_CHARACTER_ATTRIBUTES,
            CONSTANTS.TAB_CHARACTER_INVENTORY,
            CONSTANTS.TAB_CHARACTER_SPELLBOOK,
            CONSTANTS.TAB_CHARACTER_FEATURES,
            CONSTANTS.TAB_CHARACTER_EFFECTS,
            CONSTANTS.TAB_CHARACTER_BIOGRAPHY,
            CONSTANTS.TAB_CHARACTER_JOURNAL
          ]
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "defaultCharacterSheetTabs"
          );
        }
      },
      useClassicControlsForCharacter: {
        options: {
          name: "TIDY5E.Settings.UseClassicControls.name",
          hint: "TIDY5E.Settings.UseClassicControls.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useClassicControlsForCharacter"
          );
        }
      },
      showIconsNextToTheItemName: {
        options: {
          name: "TIDY5E.Settings.ShowIconsNextToTheItemName.name",
          hint: "TIDY5E.Settings.ShowIconsNextToTheItemName.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "showIconsNextToTheItemName"
          );
        }
      },
      // Item Info Cards
      itemCardsForAllItems: {
        options: {
          name: "TIDY5E.Settings.ItemCardsForAllItems.name",
          hint: "TIDY5E.Settings.ItemCardsForAllItems.hint",
          scope: "client",
          config: true,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("itemCardsForAllItems");
        }
      },
      itemCardsForNpcs: {
        options: {
          name: "TIDY5E.Settings.ItemCardsForNPCs.name",
          hint: "TIDY5E.Settings.ItemCardsForNPCs.hint",
          scope: "world",
          config: true,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("itemCardsForNpcs");
        }
      },
      itemCardsAreFloating: {
        options: {
          name: "TIDY5E.Settings.ItemCardsAreFloating.name",
          hint: "TIDY5E.Settings.ItemCardsAreFloating.hint",
          scope: "client",
          config: true,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("itemCardsAreFloating");
        }
      },
      itemCardsDelay: {
        options: {
          name: "TIDY5E.Settings.ItemCardsDelay.name",
          hint: "TIDY5E.Settings.ItemCardsDelay.hint",
          scope: "client",
          config: true,
          default: 300,
          type: Number
        },
        get() {
          return FoundryAdapter.getTidySetting("itemCardsDelay");
        }
      },
      useAccessibleKeyboardSupport: {
        options: {
          name: "TIDY5E.Settings.UseAccessibleKeyboardSupport.name",
          hint: "TIDY5E.Settings.UseAccessibleKeyboardSupport.hint",
          scope: "world",
          config: true,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useAccessibleKeyboardSupport"
          );
        }
      },
      useDefaultSheetAttributeTabbing: {
        options: {
          name: "TIDY5E.Settings.UseDefaultSheetAttributeTabbing.name",
          hint: "TIDY5E.Settings.UseDefaultSheetAttributeTabbing.hint",
          scope: "client",
          config: true,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useDefaultSheetAttributeTabbing"
          );
        }
      },
      useDefaultSheetHpTabbing: {
        options: {
          name: "TIDY5E.Settings.UseDefaultSheetHpTabbing.name",
          hint: "TIDY5E.Settings.UseDefaultSheetHpTabbing.hint",
          scope: "client",
          config: true,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useDefaultSheetHpTabbing"
          );
        }
      },
      itemCardsFixKey: {
        options: {
          name: "TIDY5E.Settings.ItemCardsFixKey.name",
          hint: "TIDY5E.Settings.ItemCardsFixKey.hint",
          scope: "world",
          config: false,
          default: "x",
          type: String
        },
        get() {
          return FoundryAdapter.getTidySetting("itemCardsFixKey");
        }
      },
      //Show trait labels
      showTraitLabels: {
        options: {
          name: "TIDY5E.Settings.ShowTraitLabels.name",
          hint: "TIDY5E.Settings.ShowTraitLabels.hint",
          scope: "world",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("showTraitLabels");
        }
      },
      showClassList: {
        options: {
          name: "TIDY5E.Settings.ShowClassList.name",
          hint: "TIDY5E.Settings.ShowClassList.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("showClassList");
        }
      },
      animateInspiration: {
        options: {
          name: "TIDY5E.Settings.InspirationAnimation.name",
          hint: "TIDY5E.Settings.InspirationAnimation.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("animateInspiration");
        }
      },
      hideIfZero: {
        options: {
          name: "TIDY5E.Settings.HideIfZero.name",
          hint: "TIDY5E.Settings.HideIfZero.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("hideIfZero");
        }
      },
      showInspirationOnHover: {
        options: {
          name: "TIDY5E.Settings.ShowInspirationOnHover.name",
          hint: "TIDY5E.Settings.ShowInspirationOnHover.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "showInspirationOnHover"
          );
        }
      },
      showExhaustionOnHover: {
        options: {
          name: "TIDY5E.Settings.ShowExhaustionOnHover.name",
          hint: "TIDY5E.Settings.ShowExhaustionOnHover.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "showExhaustionOnHover"
          );
        }
      },
      useHpBar: {
        options: {
          name: "TIDY5E.Settings.UseHpBar.name",
          hint: "TIDY5E.Settings.UseHpBar.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useHpBar");
        }
      },
      useHpOverlay: {
        options: {
          name: "TIDY5E.Settings.UseHpOverlay.name",
          hint: "TIDY5E.Settings.UseHpOverlay.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useHpOverlay");
        }
      },
      toggleEmptyCharacterSkills: {
        options: {
          name: "TIDY5E.Settings.ToggleEmptyCharacterSkills.name",
          hint: "TIDY5E.Settings.ToggleEmptyCharacterSkills.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "toggleEmptyCharacterSkills"
          );
        }
      },
      toggleEmptyCharacterTraits: {
        options: {
          name: "TIDY5E.Settings.ToggleEmptyCharacterTraits.name",
          hint: "TIDY5E.Settings.ToggleEmptyCharacterTraits.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "toggleEmptyCharacterTraits"
          );
        }
      },
      moveTraitsBelowCharacterResources: {
        options: {
          name: "TIDY5E.Settings.MoveTraitsBelowResources.name",
          hint: "TIDY5E.Settings.MoveTraitsBelowResources.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "moveTraitsBelowCharacterResources"
          );
        }
      },
      showEquippedAmmoOnly: {
        options: {
          name: "TIDY5E.Settings.ShowEquippedAmmoOnly.name",
          hint: "TIDY5E.Settings.ShowEquippedAmmoOnly.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("showEquippedAmmoOnly");
        }
      },
      initialNpcSheetTab: {
        options: {
          name: "TIDY5E.Settings.InitialSheetTab.name",
          hint: "TIDY5E.Settings.InitialSheetTab.hint",
          scope: "world",
          config: false,
          type: String,
          choices: () => TabManager.getTabsAsConfigOptions(
            NpcSheetRuntime.getAllRegisteredTabs()
          ),
          default: CONSTANTS.TAB_NPC_ABILITIES
        },
        get() {
          return FoundryAdapter.getTidySetting("initialNpcSheetTab");
        }
      },
      defaultNpcSheetTabs: {
        options: {
          name: "TIDY5E.Settings.DefaultSheetTabs.name",
          hint: "TIDY5E.Settings.DefaultSheetTabs.hint",
          scope: "world",
          config: false,
          type: Array,
          default: [
            CONSTANTS.TAB_NPC_ABILITIES,
            CONSTANTS.TAB_NPC_SPELLBOOK,
            CONSTANTS.TAB_NPC_EFFECTS,
            CONSTANTS.TAB_NPC_BIOGRAPHY,
            CONSTANTS.TAB_NPC_JOURNAL
          ]
        },
        get() {
          return FoundryAdapter.getTidySetting("defaultNpcSheetTabs");
        }
      },
      useClassicControlsForNpc: {
        options: {
          name: "TIDY5E.Settings.UseClassicControls.name",
          hint: "TIDY5E.Settings.UseClassicControls.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useClassicControlsForNpc"
          );
        }
      },
      moveTraitsBelowNpcResources: {
        options: {
          name: "TIDY5E.Settings.MoveTraitsBelowResources.name",
          hint: "TIDY5E.Settings.MoveTraitsBelowResources.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "moveTraitsBelowNpcResources"
          );
        }
      },
      useHpBarNpc: {
        options: {
          name: "TIDY5E.Settings.UseHpBar.name",
          hint: "TIDY5E.Settings.UseHpBar.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useHpBarNpc");
        }
      },
      useHpOverlayNpc: {
        options: {
          name: "TIDY5E.Settings.UseHpOverlay.name",
          hint: "TIDY5E.Settings.UseHpOverlay.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useHpOverlayNpc");
        }
      },
      alwaysShowNpcTraits: {
        options: {
          name: "TIDY5E.Settings.AlwaysShowTraits.name",
          hint: "TIDY5E.Settings.AlwaysShowTraits.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("alwaysShowNpcTraits");
        }
      },
      alwaysShowNpcSkills: {
        options: {
          name: "TIDY5E.Settings.AlwaysShowSkills.name",
          hint: "TIDY5E.Settings.AlwaysShowSkills.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("alwaysShowNpcSkills");
        }
      },
      showSpellbookTabNpc: {
        options: {
          name: "TIDY5E.Settings.ShowNPCSpellbookTab.name",
          hint: "TIDY5E.Settings.ShowNPCSpellbookTab.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("showSpellbookTabNpc");
        }
      },
      initialVehicleSheetTab: {
        options: {
          name: "TIDY5E.Settings.InitialSheetTab.name",
          hint: "TIDY5E.Settings.InitialSheetTab.hint",
          scope: "world",
          config: false,
          type: String,
          choices: () => TabManager.getTabsAsConfigOptions(
            VehicleSheetRuntime.getAllRegisteredTabs()
          ),
          default: CONSTANTS.TAB_VEHICLE_ATTRIBUTES
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "initialVehicleSheetTab"
          );
        }
      },
      defaultVehicleSheetTabs: {
        options: {
          name: "TIDY5E.Settings.DefaultSheetTabs.name",
          hint: "TIDY5E.Settings.DefaultSheetTabs.hint",
          scope: "world",
          config: false,
          type: Array,
          default: [
            CONSTANTS.TAB_VEHICLE_ATTRIBUTES,
            CONSTANTS.TAB_VEHICLE_CARGO_AND_CREW,
            CONSTANTS.TAB_VEHICLE_EFFECTS,
            CONSTANTS.TAB_VEHICLE_DESCRIPTION
          ]
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "defaultVehicleSheetTabs"
          );
        }
      },
      useClassicControlsForVehicle: {
        options: {
          name: "TIDY5E.Settings.UseClassicControls.name",
          hint: "TIDY5E.Settings.UseClassicControls.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useClassicControlsForVehicle"
          );
        }
      },
      useHpBarVehicle: {
        options: {
          name: "TIDY5E.Settings.UseHpBar.name",
          hint: "TIDY5E.Settings.UseHpBar.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useHpBarVehicle");
        }
      },
      useHpOverlayVehicle: {
        options: {
          name: "TIDY5E.Settings.UseHpOverlay.name",
          hint: "TIDY5E.Settings.UseHpOverlay.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useHpOverlayVehicle");
        }
      },
      showPlayerName: {
        options: {
          name: "TIDY5E.Settings.ShowPlayerName.name",
          hint: "TIDY5E.Settings.ShowPlayerName.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("showPlayerName");
        }
      },
      // Expanded Sheet
      showExpandedLimitedView: {
        options: {
          name: "TIDY5E.Settings.ShowExpandedLimitedView.name",
          hint: "TIDY5E.Settings.ShowExpandedLimitedView.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "showExpandedLimitedView"
          );
        }
      },
      useCircularPortraitStyle: {
        options: {
          name: "TIDY5E.Settings.UseCircularPortraitStyle.name",
          hint: "TIDY5E.Settings.UseCircularPortraitStyle.hint",
          scope: "world",
          config: false,
          type: String,
          choices: {
            [CONSTANTS.CIRCULAR_PORTRAIT_OPTION_NONE]: "TIDY5E.Settings.UseCircularPortraitStyle.none",
            [CONSTANTS.CIRCULAR_PORTRAIT_OPTION_CHARACTER]: "TIDY5E.Settings.UseCircularPortraitStyle.pc",
            [CONSTANTS.CIRCULAR_PORTRAIT_OPTION_NPCVEHICLE]: "TIDY5E.Settings.UseCircularPortraitStyle.npc",
            [CONSTANTS.CIRCULAR_PORTRAIT_OPTION_ALL]: "TIDY5E.Settings.UseCircularPortraitStyle.all"
          },
          default: CONSTANTS.CIRCULAR_PORTRAIT_OPTION_ALL
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useCircularPortraitStyle"
          );
        }
      },
      useTotalSheetLock: {
        options: {
          name: "TIDY5E.Settings.UseTotalSheetLock.name",
          hint: "TIDY5E.Settings.UseTotalSheetLock.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useTotalSheetLock");
        }
      },
      permanentlyUnlockCharacterSheetForGm: {
        options: {
          name: "TIDY5E.Settings.PermanentlyUnlockCharacterSheetForGM.name",
          hint: "TIDY5E.Settings.PermanentlyUnlockCharacterSheetForGM.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "permanentlyUnlockCharacterSheetForGm"
          );
        }
      },
      limitEffectsManagementToGm: {
        options: {
          name: "TIDY5E.Settings.LimitEffectsManagementToGM.name",
          hint: "TIDY5E.Settings.LimitEffectsManagementToGM.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "limitEffectsManagementToGm"
          );
        }
      },
      hideDeathSavesFromPlayers: {
        options: {
          name: "TIDY5E.Settings.HideDeathSavesFromPlayers.name",
          hint: "TIDY5E.Settings.HideDeathSavesFromPlayers.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "hideDeathSavesFromPlayers"
          );
        }
      },
      useCharacterEncumbranceBar: {
        options: {
          name: "TIDY5E.Settings.UseCharacterEncumbranceBar.name",
          hint: "TIDY5E.Settings.UseCharacterEncumbranceBar.hint",
          scope: "world",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useCharacterEncumbranceBar"
          );
        }
      },
      useNpcEncumbranceBar: {
        options: {
          name: "TIDY5E.Settings.UseNPCEncumbranceBar.name",
          hint: "TIDY5E.Settings.UseNPCEncumbranceBar.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useNpcEncumbranceBar");
        }
      },
      useVehicleEncumbranceBar: {
        options: {
          name: "TIDY5E.Settings.UseVehicleEncumbranceBar.name",
          hint: "TIDY5E.Settings.UseVehicleEncumbranceBar.hint",
          scope: "world",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useVehicleEncumbranceBar"
          );
        }
      },
      useExhaustion: {
        options: {
          name: "TIDY5E.Settings.UseExhaustion.name",
          hint: "TIDY5E.Settings.UseExhaustion.hint",
          scope: "world",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useExhaustion");
        }
      },
      useCharacterInspiration: {
        options: {
          name: "TIDY5E.Settings.UseInspiration.name",
          hint: "TIDY5E.Settings.UseInspiration.hint",
          scope: "world",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useCharacterInspiration"
          );
        }
      },
      useVehicleMotion: {
        options: {
          name: "TIDY5E.Settings.UseVehicleMotion.name",
          hint: "TIDY5E.Settings.UseVehicleMotion.hint",
          scope: "world",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("useVehicleMotion");
        }
      },
      showNpcRestInChat: {
        options: {
          name: "TIDY5E.Settings.ShowNPCRestInChat.name",
          hint: "TIDY5E.Settings.ShowNPCRestInChat.hint",
          scope: "world",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("showNpcRestInChat");
        }
      },
      showNpcActorLinkMarker: {
        options: {
          name: "TIDY5E.Settings.ShowNPCActorLinkMarker.name",
          hint: "TIDY5E.Settings.ShowNPCActorLinkMarker.hint",
          scope: "world",
          config: false,
          type: String,
          choices: {
            default: "TIDY5E.Settings.ShowNPCActorLinkMarker.default",
            unlinked: "TIDY5E.Settings.ShowNPCActorLinkMarker.unlinked",
            both: "TIDY5E.Settings.ShowNPCActorLinkMarker.both"
          },
          default: "default"
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "showNpcActorLinkMarker"
          );
        }
      },
      showActiveEffectsMarker: {
        options: {
          name: "TIDY5E.Settings.ShowActiveEffectsMarker.name",
          hint: "TIDY5E.Settings.ShowActiveEffectsMarker.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "showActiveEffectsMarker"
          );
        }
      },
      permanentlyUnlockNpcSheetForGm: {
        options: {
          name: "TIDY5E.Settings.PermanentlyUnlockNPCSheetForGM.name",
          hint: "TIDY5E.Settings.PermanentlyUnlockNPCSheetForGM.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "permanentlyUnlockNpcSheetForGm"
          );
        }
      },
      permanentlyUnlockVehicleSheetForGm: {
        options: {
          name: "TIDY5E.Settings.PermanentlyUnlockVehicleSheetForGM.name",
          hint: "TIDY5E.Settings.PermanentlyUnlockVehicleSheetForGM.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "permanentlyUnlockVehicleSheetForGm"
          );
        }
      },
      lockMoneyChanges: {
        options: {
          name: "TIDY5E.Settings.LockMoneyChanges.name",
          hint: "TIDY5E.Settings.LockMoneyChanges.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("lockMoneyChanges");
        }
      },
      lockExpChanges: {
        options: {
          name: "TIDY5E.Settings.LockExpChanges.name",
          hint: "TIDY5E.Settings.LockExpChanges.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("lockExpChanges");
        }
      },
      lockHpMaxChanges: {
        options: {
          name: "TIDY5E.Settings.LockHpMaxChanges.name",
          hint: "TIDY5E.Settings.LockHpMaxChanges.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("lockHpMaxChanges");
        }
      },
      lockLevelSelector: {
        options: {
          name: "TIDY5E.Settings.LockLevelSelector.name",
          hint: "TIDY5E.Settings.LockLevelSelector.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("lockLevelSelector");
        }
      },
      lockConfigureSheet: {
        options: {
          name: "TIDY5E.Settings.LockConfigureSheet.name",
          hint: "TIDY5E.Settings.LockConfigureSheet.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("lockConfigureSheet");
        }
      },
      lockItemQuantity: {
        options: {
          name: "TIDY5E.Settings.LockItemQuantity.name",
          hint: "TIDY5E.Settings.LockItemQuantity.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("lockItemQuantity");
        }
      },
      allowCantripsToBePrepared: {
        options: {
          name: "TIDY5E.Settings.AllowCantripsToBePrepared.name",
          hint: "TIDY5E.Settings.AllowCantripsToBePrepared.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "allowCantripsToBePrepared"
          );
        }
      },
      useMulticlassSpellbookFilter: {
        options: {
          name: "TIDY5E.Settings.UseMulticlassSpellbookFilter.name",
          hint: "TIDY5E.Settings.UseMulticlassSpellbookFilter.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useMulticlassSpellbookFilter"
          );
        }
      },
      useSpellClassFilterIcons: {
        options: {
          name: "TIDY5E.Settings.UseSpellClassIcons.name",
          hint: "TIDY5E.Settings.UseSpellClassIcons.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useSpellClassFilterIcons"
          );
        }
      },
      allowHpMaxOverride: {
        options: {
          name: "TIDY5E.Settings.AllowHpMaxOverride.name",
          hint: "TIDY5E.Settings.AllowHpMaxOverride.hint",
          scope: "world",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("allowHpMaxOverride");
        }
      },
      actionListLimitActionsToCantrips: {
        options: {
          name: "TIDY5E.Settings.ActionListLimitActionsToCantrips.name",
          hint: "TIDY5E.Settings.ActionListLimitActionsToCantrips.hint",
          scope: "client",
          config: false,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "actionListLimitActionsToCantrips"
          );
        }
      },
      actionListIncludeMinuteLongSpellsAsActions: {
        options: {
          name: "TIDY5E.Settings.ActionListIncludeMinuteLongSpellsAsActions.name",
          hint: "TIDY5E.Settings.ActionListIncludeMinuteLongSpellsAsActions.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "actionListIncludeMinuteLongSpellsAsActions"
          );
        }
      },
      actionListIncludeSpellsWithActiveEffects: {
        options: {
          name: "TIDY5E.Settings.ActionListIncludeSpellsWithActiveEffects.name",
          hint: "TIDY5E.Settings.ActionListIncludeSpellsWithActiveEffects.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "actionListIncludeSpellsWithActiveEffects"
          );
        }
      },
      actionListIncludeConsumables: {
        options: {
          name: "TIDY5E.Settings.ActionListIncludeConsumables.name",
          hint: "TIDY5E.Settings.ActionListIncludeConsumables.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "actionListIncludeConsumables"
          );
        }
      },
      actionListScaleCantripDamage: {
        options: {
          name: "TIDY5E.Settings.ActionListScaleCantripDamage.name",
          hint: "TIDY5E.Settings.ActionListScaleCantripDamage.hint",
          scope: "client",
          config: false,
          default: true,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "actionListScaleCantripDamage"
          );
        }
      },
      exhaustionConfig: {
        options: {
          name: "TIDY5E.WorldSettings.Exhaustion.name",
          hint: "TIDY5E.WorldSettings.Exhaustion.hint",
          scope: "world",
          config: false,
          default: getStandardExhaustionConfig(),
          type: Object
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "exhaustionConfig"
          );
        }
      },
      vehicleExhaustionConfig: {
        options: {
          name: "TIDY5E.WorldSettings.VehicleExhaustion.name",
          hint: "TIDY5E.WorldSettings.VehicleExhaustion.hint",
          scope: "world",
          config: false,
          default: getStandardVehicleExhaustionConfig(),
          type: Object
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "vehicleExhaustionConfig"
          );
        }
      },
      itemIdentificationPermission: {
        options: {
          name: "TIDY5E.WorldSettings.ItemIdentificationPermission.name",
          hint: "TIDY5E.WorldSettings.ItemIdentificationPermission.hint",
          scope: "world",
          type: String,
          default: CONSTANTS.SHEET_SETTINGS_OPTION_GM_AND_OWNERS,
          config: false,
          choices: {
            [CONSTANTS.SHEET_SETTINGS_OPTION_GM_AND_OWNERS]: "TIDY5E.WorldSettings.ItemIdentificationPermission.options.GmAndOwners",
            [CONSTANTS.SHEET_SETTINGS_OPTION_GM_ONLY]: "TIDY5E.WorldSettings.ItemIdentificationPermission.options.GmOnly"
          }
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "itemIdentificationPermission"
          );
        }
      },
      includeFlagsInSpellScrollCreation: {
        options: {
          name: "TIDY5E.WorldSettings.IncludeFlagsInSpellScrollCreation.name",
          hint: "TIDY5E.WorldSettings.IncludeFlagsInSpellScrollCreation.hint",
          scope: "world",
          type: Boolean,
          default: false,
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "includeFlagsInSpellScrollCreation"
          );
        }
      },
      colorPickerEnabled: {
        options: {
          name: "TIDY5E.Settings.ColorPickerEnabled.name",
          hint: "TIDY5E.Settings.ColorPickerEnabled.hint",
          scope: "client",
          type: Boolean,
          default: false,
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerEnabled");
        }
      },
      colorPickerPrimaryAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerPrimaryAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-primary-accent-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerPrimaryAccent"
          );
        },
        representsCssVariable: "--t5e-primary-accent-color"
      },
      colorPickerHpBar: {
        options: {
          name: "TIDY5E.Settings.ColorPickerHpBar.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-hp-bar-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerHpBar");
        },
        representsCssVariable: "--t5e-hp-bar-color"
      },
      colorPickerEquipped: {
        options: {
          name: "TIDY5E.Settings.ColorPickerEquipped.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-equipped-background"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerEquipped");
        },
        representsCssVariable: "--t5e-equipped-background"
      },
      colorPickerEquippedOutline: {
        options: {
          name: "TIDY5E.Settings.ColorPickerEquippedOutline.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-equipped-item-grid-tile-outline-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerEquippedOutline"
          );
        },
        representsCssVariable: "--t5e-equipped-item-grid-tile-outline-color"
      },
      colorPickerEquippedAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerEquippedAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-equipped-item-grid-tile-accent-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerEquippedAccent"
          );
        },
        representsCssVariable: "--t5e-equipped-item-grid-tile-accent-color"
      },
      colorPickerPrepared: {
        options: {
          name: "TIDY5E.Settings.ColorPickerPrepared.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-prepared-background"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerPrepared");
        },
        representsCssVariable: "--t5e-prepared-background"
      },
      colorPickerPreparedOutline: {
        options: {
          name: "TIDY5E.Settings.ColorPickerPreparedOutline.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-prepared-item-grid-tile-outline-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerPreparedOutline"
          );
        },
        representsCssVariable: "--t5e-prepared-item-grid-tile-outline-color"
      },
      colorPickerPreparedAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerPreparedAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-prepared-item-grid-tile-accent-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerPreparedAccent"
          );
        },
        representsCssVariable: "--t5e-prepared-item-grid-tile-accent-color"
      },
      colorPickerPact: {
        options: {
          name: "TIDY5E.Settings.ColorPickerPact.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-pact-background"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerPact");
        },
        representsCssVariable: "--t5e-pact-background"
      },
      colorPickerPactOutline: {
        options: {
          name: "TIDY5E.Settings.ColorPickerPactOutline.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-pact-outline-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerPactOutline"
          );
        },
        representsCssVariable: "--t5e-pact-outline-color"
      },
      colorPickerPactAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerPactAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-pact-accent-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerPactAccent");
        },
        representsCssVariable: "--t5e-pact-accent-color"
      },
      colorPickerAtWill: {
        options: {
          name: "TIDY5E.Settings.ColorPickerAtWill.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-atwill-background"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerAtWill");
        },
        representsCssVariable: "--t5e-atwill-background"
      },
      colorPickerAtWillOutline: {
        options: {
          name: "TIDY5E.Settings.ColorPickerAtWillOutline.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-atwill-outline-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerAtWillOutline"
          );
        },
        representsCssVariable: "--t5e-atwill-outline-color"
      },
      colorPickerAtWillAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerAtWillAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-atwill-accent-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerAtWillAccent"
          );
        },
        representsCssVariable: "--t5e-atwill-accent-color"
      },
      colorPickerRitualOnly: {
        options: {
          name: "TIDY5E.Settings.ColorPickerRitualOnly.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-ritual-only-background"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerRitualOnly");
        },
        representsCssVariable: "--t5e-ritual-only-background"
      },
      colorPickerRitualOnlyOutline: {
        options: {
          name: "TIDY5E.Settings.ColorPickerRitualOnlyOutline.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-ritual-only-outline-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerRitualOnlyOutline"
          );
        },
        representsCssVariable: "--t5e-ritual-only-outline-color"
      },
      colorPickerRitualOnlyAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerRitualOnlyAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-ritual-only-accent-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerRitualOnlyAccent"
          );
        },
        representsCssVariable: "--t5e-ritual-only-accent-color"
      },
      colorPickerInnate: {
        options: {
          name: "TIDY5E.Settings.ColorPickerInnate.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-innate-background"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting("colorPickerInnate");
        },
        representsCssVariable: "--t5e-innate-background"
      },
      colorPickerInnateOutline: {
        options: {
          name: "TIDY5E.Settings.ColorPickerInnateOutline.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-innate-outline"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerInnateOutline"
          );
        },
        representsCssVariable: "--t5e-innate-outline"
      },
      colorPickerInnateAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerInnateAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-innate-accent"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerInnateAccent"
          );
        },
        representsCssVariable: "--t5e-innate-accent"
      },
      colorPickerAlwaysPrepared: {
        options: {
          name: "TIDY5E.Settings.ColorPickerAlwaysPrepared.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-alwaysprepared-background"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerAlwaysPrepared"
          );
        },
        representsCssVariable: "--t5e-alwaysprepared-background"
      },
      colorPickerAlwaysPreparedOutline: {
        options: {
          name: "TIDY5E.Settings.ColorPickerAlwaysPreparedOutline.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-alwaysprepared-outline-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerAlwaysPreparedOutline"
          );
        },
        representsCssVariable: "--t5e-alwaysprepared-outline-color"
      },
      colorPickerAlwaysPreparedAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerAlwaysPreparedAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-alwaysprepared-accent-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerAlwaysPreparedAccent"
          );
        },
        representsCssVariable: "--t5e-alwaysprepared-accent-color"
      },
      colorPickerScrollbarThumb: {
        options: {
          name: "TIDY5E.Settings.ColorPickerScrollbarThumb.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-scrollbar-thumb-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerScrollbarThumb"
          );
        },
        representsCssVariable: "--t5e-scrollbar-thumb-color"
      },
      colorPickerScrollbarTrack: {
        options: {
          name: "TIDY5E.Settings.ColorPickerScrollbarTrack.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-scrollbar-track-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerScrollbarTrack"
          );
        },
        representsCssVariable: "--t5e-scrollbar-track-color"
      },
      colorPickerMagicAccent: {
        options: {
          name: "TIDY5E.Settings.ColorPickerMagicAccent.name",
          scope: "client",
          type: String,
          default: defaultLightTheme.variables["--t5e-magic-accent-color"],
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "colorPickerMagicAccent"
          );
        },
        representsCssVariable: "--t5e-magic-accent-color"
      },
      // Icons
      useTidySpellSchoolIcons: {
        options: {
          name: "TIDY5E.Settings.UseTidySpellSchoolIcons.name",
          hint: "TIDY5E.Settings.UseTidySpellSchoolIcons.hint",
          scope: "world",
          type: Boolean,
          default: true,
          config: false
        },
        get() {
          return FoundryAdapter.getTidySetting(
            "useTidySpellSchoolIcons"
          );
        }
      },
      debug: {
        options: {
          name: `TIDY5E.Settings.Debug.name`,
          hint: `TIDY5E.Settings.Debug.hint`,
          scope: "client",
          config: true,
          default: false,
          type: Boolean
        },
        get() {
          return FoundryAdapter.getTidySetting("debug");
        }
      }
    }
  };
}
let SettingsProvider;
function initSettings() {
  SettingsProvider = createSettings();
  for (let menu of Object.entries(SettingsProvider.menus)) {
    FoundryAdapter.registerTidyMenu(menu[0], menu[1].options);
  }
  const debouncedSettingStoreRefresh = FoundryAdapter.debounce(() => {
    settingStore.set(getCurrentSettings());
  }, 100);
  for (let setting of Object.entries(SettingsProvider.settings)) {
    const options = {
      ...setting[1].options,
      onChange: (...args) => {
        debouncedSettingStoreRefresh();
        setting[1].options.onChange?.(...args);
      }
    };
    FoundryAdapter.registerTidySetting(setting[0], options);
  }
  SettingsProvider.settings.colorScheme.options.onChange(
    SettingsProvider.settings.colorScheme.get()
  );
  settingStore = writable(getCurrentSettings());
  Hooks.on("closeSettingsConfig", () => {
    settingStore.set(getCurrentSettings());
  });
}
const FoundryAdapter = {
  isFoundryV12OrHigher() {
    return foundry.utils.isNewerVersion(game.version, 12);
  },
  deepClone(obj) {
    return foundry.utils.deepClone(obj);
  },
  userIsGm() {
    return game.user.isGM;
  },
  getTidySetting(settingName) {
    return game.settings.get(CONSTANTS.MODULE_ID, settingName);
  },
  async setTidySetting(key, value) {
    await game.settings.set(CONSTANTS.MODULE_ID, key, value);
  },
  registerTidySetting(key, data) {
    game.settings.register(CONSTANTS.MODULE_ID, key, data);
  },
  registerTidyMenu(key, data) {
    game.settings.registerMenu(CONSTANTS.MODULE_ID, key, data);
  },
  getGameSetting(namespace, settingName) {
    return game.settings.get(namespace, settingName);
  },
  async setGameSetting(namespace, key, value) {
    await game.settings.set(namespace, key, value);
  },
  onActor5eSheetRender(func2) {
    Hooks.on("renderActorSheet", (...args) => {
      func2(args);
    });
  },
  onGetActiveEffectContextOptions(func2) {
    Hooks.on("dnd5e.getActiveEffectContextOptions", func2);
  },
  getTemplate(templateName) {
    return `modules/${CONSTANTS.MODULE_ID}/templates/${templateName}`;
  },
  localize(value, options) {
    if (options) {
      return game.i18n.format(value, options);
    }
    return game.i18n.localize(value);
  },
  // TODO: Extract a dedicated ActiveEffectManager or the like
  addEffect(effectType, owner) {
    const isActor = owner instanceof Actor;
    const effectData = {
      label: isActor ? game.i18n.localize("DND5E.EffectNew") : owner.name,
      icon: isActor ? "icons/svg/aura.svg" : owner.img,
      origin: owner.uuid,
      "duration.rounds": effectType === "temporary" ? 1 : void 0,
      disabled: effectType === "inactive"
    };
    if (!TidyHooks.tidy5eSheetsPreCreateActiveEffect(
      owner,
      effectData,
      game.user.id
    )) {
      return;
    }
    return owner.createEmbeddedDocuments("ActiveEffect", [effectData]);
  },
  canPrepareSpell(item) {
    return item.system.preparation?.mode !== CONSTANTS.SPELL_PREPARATION_MODE_ATWILL && item.system.preparation?.mode !== CONSTANTS.SPELL_PREPARATION_MODE_INNATE && item.system.preparation?.mode !== CONSTANTS.SPELL_PREPARATION_MODE_ALWAYS && item.system.preparation?.mode !== CONSTANTS.SPELL_PREPARATION_MODE_PACT && (item.system.level !== 0 || SettingsProvider.settings.allowCantripsToBePrepared.get());
  },
  /**
   *
   * @param content           - the editor content to include
   * @param targetDataField   - the data field to update when this editor is saved
   * @param editable          - whether the editor should allow editing
   * @returns
   */
  createEditorHtml(content, targetDataField, editable) {
    return HandlebarsHelpers.editor(content, {
      hash: {
        target: targetDataField,
        button: true,
        engine: "prosemirror",
        collaborate: false,
        editable
      }
    });
  },
  createOpenEditorHtml(content, targetDataField, textEditorOptions) {
    return HandlebarsHelpers.editor(content, {
      hash: {
        target: targetDataField,
        button: false,
        engine: "prosemirror",
        collaborate: false,
        editable: true,
        ...textEditorOptions
      }
    });
  },
  mergeObject(original, ...args) {
    return foundry.utils.mergeObject(original, ...args);
  },
  expandObject(data) {
    return foundry.utils.expandObject(data);
  },
  isEmpty(obj) {
    return foundry.utils.isEmpty(obj);
  },
  getClassIdentifier(item) {
    return item.system.identifier || item.name.slugify({ strict: true });
  },
  getClassAndSubclassSummaries(actor) {
    return actor.items.reduce(
      (map, item) => {
        if (item.type === "class") {
          const identifier = FoundryAdapter.getClassIdentifier(item);
          const data = map.get(identifier) ?? {};
          data.class = item.name;
          data.level = item.system.levels?.toString();
          map.set(identifier, data);
        }
        if (item.type === "subclass" && item.system.classIdentifier !== void 0) {
          const data = map.get(item.system.classIdentifier) ?? {};
          data.subclass = item.name;
          if (item.system.classIdentifier !== void 0) {
            map.set(item.system.classIdentifier, data);
          }
        }
        return map;
      },
      /* @__PURE__ */ new Map()
    );
  },
  getActorCharacterSummaryEntries(actorContext) {
    const entries = [];
    if (actorContext.system.details.race?.name) {
      entries.push(actorContext.system.details.race.name);
    } else if (actorContext.system.details.race) {
      entries.push(actorContext.system.details.race);
    }
    if (actorContext.system.details.background?.name) {
      entries.push(actorContext.system.details.background.name);
    } else if (actorContext.system.details.background) {
      entries.push(actorContext.system.details.background);
    }
    if (actorContext.system.details.alignment) {
      entries.push(actorContext.system.details.alignment);
    }
    return entries;
  },
  getCurrentLang() {
    return game.i18n.lang;
  },
  editOnMiddleClick(event, entityWithSheet) {
    if (event.button !== CONSTANTS.MOUSE_BUTTON_AUXILIARY) {
      return;
    }
    event.preventDefault();
    if (!entityWithSheet.sheet.isEditable) {
      return;
    }
    entityWithSheet.sheet.render(true);
  },
  createItem({ type, ...data }, actor) {
    if (type === "class" && actor.system.details.level + 1 > CONFIG.DND5E.maxLevel) {
      const err = game.i18n.format("DND5E.MaxCharacterLevelExceededWarn", {
        max: CONFIG.DND5E.maxLevel
      });
      ui.notifications.error(err);
      return null;
    }
    const itemData = foundry.utils.mergeObject(
      {
        name: FoundryAdapter.localize("DND5E.ItemNew", {
          type: FoundryAdapter.localize(CONFIG.Item.typeLabels[type])
        }),
        type
      },
      foundry.utils.expandObject({ ...data })
    );
    if (!TidyHooks.tidy5eSheetsPreCreateItem(actor, itemData, game.user.id)) {
      return;
    }
    return actor.createEmbeddedDocuments("Item", [itemData]);
  },
  async onLevelChange(event, item, actor) {
    event.preventDefault();
    const target = event.currentTarget;
    if (!target?.value === void 0) {
      return;
    }
    const delta = Number(event.currentTarget.value);
    const classId = item.id;
    if (!delta || !classId) {
      return;
    }
    const classItem = actor.items.get(classId);
    if (!game.settings.get("dnd5e", "disableAdvancements")) {
      const manager = dnd5e.applications.advancement.AdvancementManager.forLevelChange(
        actor,
        classId,
        delta
      );
      if (manager.steps.length) {
        if (delta > 0) return manager.render(true);
        try {
          const shouldRemoveAdvancements = await dnd5e.applications.advancement.AdvancementConfirmationDialog.forLevelDown(
            classItem
          );
          if (shouldRemoveAdvancements) return manager.render(true);
        } catch (err) {
          return;
        }
      }
    }
    return classItem.update({
      "system.levels": classItem.system.levels + delta
    });
  },
  getSpellAbbreviationMap() {
    const map = /* @__PURE__ */ new Map();
    Object.values(CONFIG.DND5E.spellComponents).forEach(
      (x2) => map.set(x2.abbr, x2.label)
    );
    Object.values(CONFIG.DND5E.spellTags).forEach(
      (x2) => map.set(x2.abbr, x2.label)
    );
    return map;
  },
  getProperty(obj, path) {
    return foundry.utils.getProperty(obj, path);
  },
  getInventoryRowClasses(item, ctx, extras) {
    const itemClasses = [];
    if (item?.system?.properties?.has("mgc")) {
      itemClasses.push("magic-item");
    }
    if (ctx?.attunement?.cls && !FoundryAdapter.concealDetails(item)) {
      itemClasses.push(ctx.attunement.cls);
    }
    if (item?.system?.equipped) {
      itemClasses.push("equipped");
    }
    if (extras?.length) {
      itemClasses.push(...extras);
    }
    return itemClasses.join(" ");
  },
  getSpellRowClasses(spell) {
    const classes = [];
    if (spell.system.preparation.mode === CONSTANTS.SPELL_PREPARATION_MODE_PREPARED && (spell.system.level > 0 || SettingsProvider.settings.allowCantripsToBePrepared.get())) {
      classes.push("preparable");
    }
    if (spell.system.preparation.prepared) {
      classes.push("prepared");
    }
    if (spell.system.preparation.mode === CONSTANTS.SPELL_PREPARATION_MODE_ALWAYS) {
      classes.push("always-prepared");
    }
    if (spell.system.preparation.mode === CONSTANTS.SPELL_PREPARATION_MODE_PACT) {
      classes.push("pact");
    }
    if (spell.system.preparation.mode === CONSTANTS.SPELL_PREPARATION_MODE_ATWILL) {
      classes.push("at-will");
    }
    if (spell.system.preparation.mode === CONSTANTS.SPELL_PREPARATION_MODE_RITUAL) {
      classes.push("ritual-only");
    }
    if (spell.system.preparation.mode === CONSTANTS.SPELL_PREPARATION_MODE_INNATE) {
      classes.push("innate");
    }
    return classes.join(" ");
  },
  getSpellAttackModAndTooltip(context) {
    let actor = context.actor;
    let formula = Roll.replaceFormulaData(
      actor.system.bonuses.rsak.attack,
      actor.getRollData(),
      { missing: 0, warn: false }
    );
    let prof = actor.system.attributes.prof ?? 0;
    let spellAbility = context.system.attributes.spellcasting;
    let abilityMod = (spellAbility != "" ? actor.system.abilities[spellAbility].mod : 0) ?? 0;
    let spellAttackMod = prof + abilityMod;
    let spellAttackText = spellAttackMod > 0 ? "+" + spellAttackMod : spellAttackMod;
    let spellAttackTextTooltip = `${prof} (prof.)+${abilityMod} (${spellAbility})`;
    return {
      mod: spellAttackText,
      bonus: formula,
      modTooltip: spellAttackTextTooltip
    };
  },
  cycleProficiency(actor, key, currentValue, systemFieldName, reverse = false) {
    if (currentValue === null || currentValue === void 0) {
      return Promise.resolve(void 0);
    }
    const levels = [0, 1, 0.5, 2];
    const idx = levels.indexOf(currentValue);
    const next = idx + (reverse ? 3 : 1);
    return actor.update({
      [`system.${systemFieldName}.${key}.value`]: levels[next % levels.length]
    });
  },
  getSpellImageUrl(context, spell) {
    if (!SettingsProvider.settings.useSpellClassFilterIcons.get()) {
      return spell.img;
    }
    const sourceClass = spell.system.sourceClass;
    const classImage = sourceClass && "actorClassesToImages" in context ? context.actorClassesToImages[sourceClass] : void 0;
    return classImage ?? spell.img;
  },
  searchItems(searchCriteria, items) {
    return new Set(
      items.filter((item) => FoundryAdapter.searchItem(item, searchCriteria)).map((item) => item.id)
    );
  },
  searchItem(item, searchCriteria) {
    return searchCriteria.trim() === "" || item.system.identified === false && item.system.unidentified?.name?.toLowerCase().includes(searchCriteria.toLowerCase()) || item.system.identified !== false && item.name.toLowerCase().includes(searchCriteria.toLowerCase());
  },
  searchEffects(searchCriteria, effects) {
    return new Set(
      effects.filter(
        (effect) => searchCriteria.trim() === "" || effect.name.toLowerCase().includes(searchCriteria.toLowerCase())
      ).map((effect) => effect.id)
    );
  },
  getFilteredActionItems(searchCriteria, items) {
    return items.filter(
      (x2) => searchCriteria.trim() === "" || x2.item?.name?.toLowerCase().includes(searchCriteria.toLowerCase())
    );
  },
  getAllClassesDropdownOptions(spellClassFilterAdditionalClassesText = "") {
    const allClasses = Object.entries(
      CONSTANTS.DND5E_CLASSES
    ).map((x2) => ({
      value: x2[0],
      text: x2[1]
    }));
    if (spellClassFilterAdditionalClassesText?.trim() !== "") {
      const additionalClasses = spellClassFilterAdditionalClassesText.split(",").reduce((arr, x2) => {
        const pieces = x2.split("|");
        if (pieces.length !== 2) {
          return arr;
        }
        arr.push({
          value: pieces[0],
          text: pieces[1]
        });
        return arr;
      }, []);
      allClasses.push(...additionalClasses);
    }
    allClasses.sort((a2, b2) => a2.text.localeCompare(b2.text));
    return allClasses;
  },
  parseAdditionalClassesDropDownItems(spellClassFilterAdditionalClassesText) {
    return spellClassFilterAdditionalClassesText.split(",").reduce((arr, x2) => {
      const pieces = x2.split("|");
      if (pieces.length !== 2) {
        return arr;
      }
      arr.push({
        value: pieces[0],
        text: pieces[1]
      });
      return arr;
    }, []);
  },
  removeConfigureSettingsButtonWhenLockedForNonGm(buttons) {
    if (FoundryAdapter.shouldLockConfigureSheet()) {
      const configureSheetButtonIndex = buttons.findIndex(
        (b2) => b2.class.includes("configure-sheet")
      );
      if (configureSheetButtonIndex >= 0) {
        buttons.splice(configureSheetButtonIndex, 1);
      }
    }
    return buttons;
  },
  getNewCargo() {
    return { name: "", quantity: 1 };
  },
  getWeightUnit() {
    return FoundryAdapter.localize(
      `DND5E.Abbreviation${game.settings.get("dnd5e", "metricWeightUnits") ? "Kg" : "Lbs"}`
    );
  },
  isActiveEffectContextFavorited(context, actor) {
    if (!actor) {
      return false;
    }
    const effect = FoundryAdapter.getEffect({
      document: actor,
      effectId: context.id,
      parentId: context.parentId
    });
    return FoundryAdapter.isEffectFavorited(effect, actor);
  },
  getEffectActor(effect) {
    return (
      // Item-Owned
      effect.parent?.actor ?? // Actor-Owned
      effect.parent
    );
  },
  isEffectFavorited(effect, actor) {
    if (actor?.documentName === CONSTANTS.DOCUMENT_NAME_ACTOR && "favorites" in actor.system) {
      const relativeUuid = effect.getRelativeUUID(actor);
      return actor.system.favorites.some((f2) => f2.id === relativeUuid);
    }
  },
  async toggleFavoriteEffect(effect) {
    const actor = FoundryAdapter.getEffectActor(effect);
    if (!actor || !actor.system?.addFavorite) {
      return;
    }
    const favorited = FoundryAdapter.isEffectFavorited(effect, actor);
    if (favorited) {
      await actor.system.removeFavorite(effect.getRelativeUUID(actor));
    } else {
      await actor.system.addFavorite({
        type: "effect",
        id: effect.getRelativeUUID(actor)
      });
    }
  },
  isItemFavorited(document2) {
    const actor = document2.actor;
    if (actor && "favorites" in actor.system) {
      const relativeUuid = document2.getRelativeUUID(actor);
      return actor.system.hasFavorite(relativeUuid);
    }
    return false;
  },
  async toggleFavoriteItem(document2) {
    const actor = document2.actor;
    if (!actor || !actor.system?.addFavorite) {
      return;
    }
    const favorited = FoundryAdapter.isItemFavorited(document2);
    if (favorited) {
      await actor.system.removeFavorite(document2.getRelativeUUID(actor));
    } else {
      await actor.system.addFavorite({
        type: "item",
        id: document2.getRelativeUUID(actor)
      });
    }
  },
  isActorSheetUnlocked(actor) {
    return actor.isOwner && TidyFlags.allowEdit.get(actor) || FoundryAdapter.userIsGm() && SettingsProvider.settings.permanentlyUnlockCharacterSheetForGm.get() && actor.type === CONSTANTS.SHEET_TYPE_CHARACTER || FoundryAdapter.userIsGm() && SettingsProvider.settings.permanentlyUnlockNpcSheetForGm.get() && actor.type === CONSTANTS.SHEET_TYPE_NPC || FoundryAdapter.userIsGm() && SettingsProvider.settings.permanentlyUnlockVehicleSheetForGm.get() && actor.type === CONSTANTS.SHEET_TYPE_VEHICLE;
  },
  allowCharacterEffectsManagement(actor) {
    return SettingsProvider.settings.limitEffectsManagementToGm.get() && FoundryAdapter.userIsGm() || !SettingsProvider.settings.limitEffectsManagementToGm.get() && actor.isOwner;
  },
  shouldLockMoneyChanges() {
    return !FoundryAdapter.userIsGm() && SettingsProvider.settings.lockMoneyChanges.get();
  },
  shouldLockExpChanges() {
    return !FoundryAdapter.userIsGm() && SettingsProvider.settings.lockExpChanges.get();
  },
  shouldLockHpMaxChanges() {
    return !FoundryAdapter.userIsGm() && SettingsProvider.settings.lockHpMaxChanges.get();
  },
  shouldLockLevelSelector() {
    return !FoundryAdapter.userIsGm() && SettingsProvider.settings.lockLevelSelector.get();
  },
  shouldLockConfigureSheet() {
    return !FoundryAdapter.userIsGm() && SettingsProvider.settings.lockConfigureSheet.get();
  },
  shouldLockItemQuantity() {
    return !FoundryAdapter.userIsGm() && SettingsProvider.settings.lockItemQuantity.get();
  },
  showLimitedSheet(actor) {
    const showLimitedSheet = !FoundryAdapter.userIsGm() && actor.limited;
    if (actor.type === CONSTANTS.SHEET_TYPE_CHARACTER) {
      return showLimitedSheet && !SettingsProvider.settings.showExpandedLimitedView.get();
    }
    return showLimitedSheet;
  },
  flattenObject(obj) {
    return foundry.utils.flattenObject(obj || {});
  },
  getGameItem(id) {
    return game.items.get(id);
  },
  getGameActor(id) {
    return game.actors.get(id);
  },
  getModule(moduleId2) {
    return game.modules.get(moduleId2);
  },
  debounce(callback, delay2) {
    return foundry.utils.debounce(callback, delay2);
  },
  roll(formula, rollData, rollFnOptions = {}) {
    return new Roll(formula, rollData).roll(rollFnOptions);
  },
  async rollNpcHitDie(actor, flavor, denomination, options = {}) {
    const rollConfig = FoundryAdapter.mergeObject(
      {
        formula: `max(0, 1${denomination} + @abilities.con.mod)`,
        data: actor.getRollData(),
        chatMessage: true,
        messageData: {
          speaker: ChatMessage.getSpeaker({ actor }),
          flavor,
          title: `${flavor}: ${actor.name}`,
          rollMode: FoundryAdapter.getGameSetting("core", "rollMode"),
          "flags.dnd5e.roll": { type: "hitDie" }
        }
      },
      options
    );
    if (TidyHooks.dnd5ePreRollHitDie(actor, rollConfig, denomination) === false) {
      return;
    }
    const roll = await FoundryAdapter.roll(
      rollConfig.formula,
      rollConfig.data,
      {
        async: true
      }
    );
    if (rollConfig.chatMessage) roll.toMessage(rollConfig.messageData);
    const hp = actor.system.attributes.hp;
    const dhp = Math.min(hp.max + (hp.tempmax ?? 0) - hp.value, roll.total);
    const updates = {
      actor: { "system.attributes.hp.value": hp.value + dhp }
      //   class: {"system.hitDiceUsed": cls.system.hitDiceUsed + 1}
    };
    if (TidyHooks.dnd5eRollHitDie(actor, roll, updates) === false) return roll;
    const updateOptions = {
      dhp: (updates.actor?.["system.attributes.hp.value"] ?? hp.value) - hp.value
    };
    if (!FoundryAdapter.isEmpty(updates.actor)) {
      await actor.update(updates.actor, updateOptions);
    }
    return roll;
  },
  openActorTypeConfig(actor) {
    return new dnd5e.applications.actor.ActorTypeConfig(actor).render(true);
  },
  openCharacterActorTypeConfig(actor) {
    if (actor.system.details.race?.id) {
      return new dnd5e.applications.actor.ActorTypeConfig(
        actor.system.details.race,
        { keyPath: "system.type" }
      ).render(true);
    }
    warn(
      "Unable to open actor type config for player character because they do not have a race."
    );
  },
  playDiceSound() {
    return AudioHelper.play({ src: CONFIG.sounds.dice });
  },
  calculateAverageFromFormula(formula) {
    let r2 = new Roll(formula);
    let term = r2.terms;
    debug(`tidy5e-npc | activateListeners | term: ${term}`);
    let averageString = "";
    for (let i2 = 0; i2 < term.length; i2++) {
      let type = term[i2].constructor.name;
      switch (type) {
        case "Die": {
          averageString += Math.floor(
            (term[i2].faces * term[i2].number + term[i2].number) / 2
          );
          break;
        }
        case "OperatorTerm": {
          averageString += term[i2].operator;
          break;
        }
        case "NumericTerm": {
          averageString += term[i2].number;
          break;
        }
      }
    }
    debug(`tidy5e-npc | activateListeners | averageString: ${averageString}`);
    let average = 0;
    averageString = averageString.replace(/\s/g, "").match(/[+\-]?([0-9\.\s]+)/g) ?? [];
    while (averageString.length) {
      average += parseFloat(averageString.shift());
    }
    debug(`tidy5e-npc | activateListeners | average: ${average}`);
    return average;
  },
  enrichHtml(value, options) {
    return TextEditor.enrichHTML(value, options);
  },
  createContextMenu(...args) {
    return new FloatingContextMenu(...args);
  },
  createAdvancementSelectionDialog(item) {
    return game.dnd5e.applications.advancement.AdvancementSelection.createDialog(
      item
    );
  },
  deleteAdvancement(advancementItemId, item) {
    if (item.isEmbedded && !game.settings.get("dnd5e", "disableAdvancements")) {
      let manager = dnd5e.applications.advancement.AdvancementManager.forDeletedAdvancement(
        item.actor,
        item.id,
        advancementItemId
      );
      if (manager.steps.length) return manager.render(true);
    }
    return item.deleteAdvancement(advancementItemId);
  },
  modifyAdvancementChoices(advancementLevel, item) {
    let manager = dnd5e.applications.advancement.AdvancementManager.forModifyChoices(
      item.actor,
      item.id,
      Number(advancementLevel)
    );
    if (manager.steps.length) {
      manager.render(true);
    }
  },
  editAdvancement(advancementItemId, item) {
    const advancement = item.advancement.byId[advancementItemId];
    return new advancement.constructor.metadata.apps.config(advancement).render(
      true
    );
  },
  async renderSheetFromUuid(uuid) {
    (await fromUuid(uuid))?.sheet?.render(true);
  },
  renderImagePopout(...args) {
    return new ImagePopout(...args).render(true);
  },
  browseFilePicker(...args) {
    return new FilePicker(...args).browse();
  },
  renderArmorConfig(actor) {
    return new dnd5e.applications.actor.ActorArmorConfig(actor).render(true);
  },
  renderActorInitiativeConfig(actor) {
    return new dnd5e.applications.actor.ActorInitiativeConfig(actor).render(
      true
    );
  },
  renderActorAbilityConfig(actor, abbreviation) {
    return new dnd5e.applications.actor.ActorAbilityConfig(
      actor,
      null,
      abbreviation
    ).render(true);
  },
  renderActorMovementConfig(actor) {
    return new dnd5e.applications.actor.ActorMovementConfig(actor).render(true);
  },
  renderActorHitPointsDialog(actor) {
    return new dnd5e.applications.actor.ActorHitPointsConfig(actor).render(
      true
    );
  },
  renderActorHitDiceConfig(actor) {
    return new dnd5e.applications.actor.ActorHitDiceConfig(actor).render(true);
  },
  dialogConfirm(...args) {
    return Dialog.confirm(...args);
  },
  renderActorSheetFlags(actor) {
    return new dnd5e.applications.actor.ActorSheetFlags(actor).render(true);
  },
  renderToolSelector(actor) {
    return new dnd5e.applications.actor.ToolSelector(actor, "tool").render(
      true
    );
  },
  renderActorSensesConfig(actor) {
    return new dnd5e.applications.actor.ActorSensesConfig(actor).render(true);
  },
  renderTraitsSelector(actor, trait) {
    return new dnd5e.applications.actor.TraitSelector(actor, trait).render(
      true
    );
  },
  renderProficiencyConfig(actor, property, key) {
    return new dnd5e.applications.actor.ProficiencyConfig(actor, {
      property,
      key
    }).render(true);
  },
  renderItemTypeConfig(item) {
    return new dnd5e.applications.actor.ActorTypeConfig(item, {
      keyPath: "system.type"
    }).render(true);
  },
  renderItemMovementConfig(item) {
    return new dnd5e.applications.actor.ActorMovementConfig(item, {
      keyPath: "system.movement"
    }).render(true);
  },
  renderItemSensesConfig(item) {
    return new dnd5e.applications.actor.ActorSensesConfig(item, {
      keyPath: "system.senses"
    }).render(true);
  },
  renderSourceConfig(document2, keyPath) {
    return new dnd5e.applications.SourceConfig(document2, {
      keyPath
    }).render(true);
  },
  async onActorItemDelete(actor, item) {
    if (!game.settings.get("dnd5e", "disableAdvancements")) {
      const manager = dnd5e.applications.advancement.AdvancementManager.forDeletedItem(
        actor,
        item.id
      );
      if (manager.steps.length) {
        try {
          const shouldRemoveAdvancements = await dnd5e.applications.advancement.AdvancementConfirmationDialog.forDelete(
            item
          );
          if (shouldRemoveAdvancements) {
            return manager.render(true);
          }
          return item.delete({ shouldRemoveAdvancements });
        } catch (err) {
          return;
        }
      }
    }
    return item.deleteDialog();
  },
  getActivationTypeLabel(activationType) {
    return activationType === "other" ? FoundryAdapter.localize("DND5E.ActionOther") : game.dnd5e.config.abilityActivationTypes[activationType];
  },
  lookupDamageType(type) {
    return game.dnd5e.config.damageTypes[type]?.label;
  },
  lookupHealingType(type) {
    return game.dnd5e.config.healingTypes[type];
  },
  lookupAbility(abbr) {
    return game.dnd5e.config.abilities[abbr];
  },
  actorTryUseItem(item, config = {}, options = {}) {
    const suppressItemUse = TidyHooks.tidy5eSheetsActorPreUseItem(item, config, options) === false;
    if (suppressItemUse) {
      return;
    }
    item.use(config, options);
  },
  onActorItemButtonContextMenu(item, options) {
    TidyHooks.tidy5eSheetsActorItemUseContextMenu(item, options);
  },
  /**
   * Fires appropriate hooks related to tab selection and reports whether tab selection was cancelled.
   * @param app the associated sheets
   * @param newTabId the new tab ID to select
   * @returns `true` to indicate proceeding with tab change; `false` to halt tab change
   */
  onTabSelecting(app, newTabId) {
    const canProceed = TidyHooks.tidy5eSheetsPreSelectTab(
      app,
      app.element.get(0),
      {
        currentTab: app.currentTabId,
        newTab: newTabId
      }
    );
    if (!canProceed) {
      return false;
    }
    setTimeout(() => {
      TidyHooks.tidy5eSheetsSelectTab(app, app.element.get(0), newTabId);
    });
    return true;
  },
  getAbilitiesAsDropdownOptions(abilities) {
    try {
      return Object.entries(abilities).map(([key, { label }]) => ({
        value: key,
        text: label
      }));
    } catch (e2) {
      error(
        "An error occurred while mapping abilities as dropdown items",
        false,
        e2
      );
      debug("Dropdown mapping error troubleshooting info", { abilities });
      return [];
    }
  },
  countPreparedSpells(items) {
    return items.filter(
      (item) => item.type === CONSTANTS.ITEM_TYPE_SPELL && item.system.level > 0 && item.system.preparation.mode === CONSTANTS.SPELL_PREPARATION_MODE_PREPARED && item.system.preparation.prepared
    ).length;
  },
  concealDetails(item) {
    return !game.user.isGM && item?.system?.identified === false;
  },
  getIdentifiedName(item) {
    if (!FoundryAdapter.userIsGm() || item?.system?.identified !== false) {
      return item.name;
    }
    try {
      return FoundryAdapter.localize("TIDY5E.GMOnly.Message", {
        message: item.toJSON().name
      });
    } catch (e2) {
      error(
        "An error occurred while getting the identified name of this item for the GM",
        false,
        e2
      );
      return "";
    }
  },
  async toggleCondition(document2, condition) {
    const existing = document2.effects.get(
      dnd5e.utils.staticID(`dnd5e${condition.id}`)
    );
    if (existing) {
      return existing.delete();
    }
    const effect = await ActiveEffect.implementation.fromStatusEffect(
      condition.id
    );
    return ActiveEffect.implementation.create(effect, {
      parent: document2,
      keepId: true
    });
  },
  getEffect({
    document: document2,
    effectId,
    parentId
  }) {
    let effect = document2.effects?.get(effectId);
    if (effect) {
      return effect;
    }
    const parentDocument = document2.items.get(parentId);
    effect = parentDocument?.effects?.get(effectId);
    return effect ?? FoundryAdapter.tryGetLegacyTransferredEffect(parentDocument, effectId);
  },
  /** Last-ditch effort to find an effect by ID in a given document. */
  tryGetLegacyTransferredEffect(document2, effectId) {
    return document2?.allApplicableEffects?.().find((e2) => e2.id === effectId);
  },
  canUseItem(item) {
    return !(!item.actor || !item.actor.isOwner || item.actor.pack);
  },
  useClassicControls(document2) {
    return document2.type === CONSTANTS.SHEET_TYPE_CHARACTER && SettingsProvider.settings.useClassicControlsForCharacter.get() || document2.type === CONSTANTS.SHEET_TYPE_NPC && SettingsProvider.settings.useClassicControlsForNpc.get() || document2.type === CONSTANTS.SHEET_TYPE_VEHICLE && SettingsProvider.settings.useClassicControlsForVehicle.get() || // Temporary stopgap: When we don't recognize a supported document for Classic Controls options, fall back to the character user setting
    SettingsProvider.settings.useClassicControlsForCharacter.get();
  },
  attunementContextApplicable: {
    icon: "fa-sun",
    cls: "not-attuned",
    title: "ERROR: This should be replaced with valid attunement type text"
  },
  attunementContextAttune: {
    icon: "fa-sun",
    cls: "attuned",
    title: "DND5E.AttunementAttuned"
  },
  getAttunementContext(item) {
    return !!item.system.attunement && !item.system.attuned ? {
      ...FoundryAdapter.attunementContextApplicable,
      title: CONFIG.DND5E.attunementTypes[item.system.attunement]
    } : !!item.system.attunement && item.system.attuned ? FoundryAdapter.attunementContextAttune : void 0;
  },
  async identifyAllItemsForContainer(container, items) {
    const updates = items.map((i2) => ({
      _id: i2.id,
      "system.identified": true
    }));
    await Item.updateDocuments(updates, {
      parent: container.actor,
      pack: container.pack
    });
  },
  async markAllItemsAsUnidentifiedForContainer(container, items) {
    const updates = items.map((i2) => ({
      _id: i2.id,
      "system.identified": false
    }));
    await Item.updateDocuments(updates, {
      parent: container.actor,
      pack: container.pack
    });
  },
  canIdentify(item) {
    return FoundryAdapter.userIsGm() || SettingsProvider.settings.itemIdentificationPermission.get() === CONSTANTS.SHEET_SETTINGS_OPTION_GM_AND_OWNERS && item.isOwner;
  },
  getJqueryWrappedElement(el) {
    return $(el);
  },
  onAmmoChange(item, ammoId) {
    const ammo = item.actor?.items.find((i2) => i2.id === ammoId);
    item.update({
      system: {
        consume: {
          amount: !ammo ? null : !!item.system.consume?.amount ? item.system.consume.amount : 1,
          target: !ammo ? "" : ammo.id,
          type: !ammo ? "" : ammo.system.type.value
        }
      }
    });
  },
  openSpellSlotsConfig(actor) {
    new dnd5e.applications.actor.ActorSpellSlotsConfig(actor).render(true);
  },
  openSummonConfig(item) {
    new dnd5e.applications.item.SummoningConfig(item).render(true);
  },
  openDamageModificationConfig(actor) {
    new dnd5e.applications.actor.DamageModificationConfig(actor).render(true);
  },
  openActorConcentrationConfig(actor) {
    new dnd5e.applications.actor.ActorConcentrationConfig(actor).render(true);
  },
  openStartingEquipmentConfig(item) {
    new dnd5e.applications.item.StartingEquipmentConfig(item).render(true);
  },
  isConcentrationEffect(effect, app) {
    return app.document instanceof dnd5e.documents.Actor5e && app._concentration?.effects.has(effect);
  },
  activateEditors(node, sheet, bindSecrets = true) {
    try {
      const nodes = node.matches(
        CONSTANTS.TEXT_EDITOR_ACTIVATION_ELEMENT_SELECTOR
      ) ? [node] : Array.from(
        node.querySelectorAll(
          CONSTANTS.TEXT_EDITOR_ACTIVATION_ELEMENT_SELECTOR
        )
      );
      for (let editorDiv of nodes) {
        sheet._activateEditor(editorDiv);
      }
      if (bindSecrets) {
        sheet._secrets.forEach((s2) => s2.bind(node));
      }
    } catch (e2) {
      error("An error occurred while activating text editors", false, e2);
      debug("Text editor error trobuleshooting info", { node, sheet });
    }
  },
  async openEnchantmentConfig(item) {
    return new dnd5e.applications.item.EnchantmentConfig(item).render(true);
  },
  async renderFromUuid(uuid, force = true) {
    const doc = await fromUuid(uuid);
    return doc?.sheet?.render(force);
  },
  async removeEnchantment(enchantmentUuid, app) {
    const enchantment = fromUuidSync(enchantmentUuid);
    if (!enchantment) return;
    await enchantment.delete();
    await app.render();
  }
};
function initRuntime() {
  ItemFilterRuntime.init();
  SheetPreferencesRuntime.init();
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  const constants_0 = (
    /*migrationsConfirmedTally*/
    child_ctx[2] < /*migration*/
    child_ctx[6].migrationTallyVersion
  );
  child_ctx[7] = constants_0;
  return child_ctx;
}
function create_if_block_1(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "new-icon fas fa-star svelte-3ahmis");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
      attr(hr, "class", "svelte-3ahmis");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(hr);
      }
    }
  };
}
function create_each_block(ctx) {
  let li;
  let t0;
  let button;
  let span;
  let t2;
  let t3;
  let mounted;
  let dispose;
  let if_block0 = (
    /*isNew*/
    ctx[7] && create_if_block_1()
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[4](
        /*migration*/
        ctx[6]
      )
    );
  }
  let if_block1 = (
    /*isNew*/
    ctx[7] && create_if_block()
  );
  return {
    c() {
      li = element("li");
      if (if_block0) if_block0.c();
      t0 = space();
      button = element("button");
      span = element("span");
      span.textContent = `${/*migration*/
      ctx[6].label}`;
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      attr(button, "type", "button");
      attr(button, "class", "inline-transparent-button highlight-on-hover");
      attr(li, "class", "flex-row small-gap");
      toggle_class(
        li,
        "new",
        /*isNew*/
        ctx[7]
      );
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block0) if_block0.m(li, null);
      append(li, t0);
      append(li, button);
      append(button, span);
      append(li, t2);
      if (if_block1) if_block1.m(li, null);
      append(li, t3);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div1;
  let p2;
  let html_tag;
  let raw_value = (
    /*localize*/
    ctx[0]("TIDY5E.Settings.Migrations.Notification.Explanation", { boldStart: "<b>", boldEnd: "</b>" }) + ""
  );
  let t0;
  let i2;
  let t1;
  let ul;
  let t2;
  let div0;
  let button;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*migrations*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block(get_each_context(ctx, each_value, i3));
  }
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      html_tag = new HtmlTag(false);
      t0 = space();
      i2 = element("i");
      t1 = space();
      ul = element("ul");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t2 = space();
      div0 = element("div");
      button = element("button");
      button.textContent = `${/*localize*/
      ctx[0]("TIDY5E.Settings.Migrations.Notification.Button.DoNotShowAgain")}`;
      html_tag.a = t0;
      attr(
        i2,
        "data-tooltip",
        /*localize*/
        ctx[0]("TIDY5E.Settings.Migrations.Notification.Explanation2")
      );
      attr(i2, "class", "fas fa-question-circle");
      attr(p2, "class", "svelte-3ahmis");
      attr(ul, "class", "svelte-3ahmis");
      attr(button, "type", "button");
      attr(div0, "class", "button-bar flex-row no-gap svelte-3ahmis");
      attr(div1, "class", "flex-column");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      html_tag.m(raw_value, p2);
      append(p2, t0);
      append(p2, i2);
      append(div1, t1);
      append(div1, ul);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(ul, null);
        }
      }
      append(div1, t2);
      append(div1, div0);
      append(div0, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*migrationsConfirmedTally, migrations*/
      12) {
        each_value = ensure_array_like(
          /*migrations*/
          ctx2[3]
        );
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(ul, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self) {
  const localize = FoundryAdapter.localize;
  const confirm = getContext("confirm");
  const migrationsConfirmedTally = SettingsProvider.settings.migrationsConfirmationTally.get();
  const migrations = [
    {
      label: localize("TIDY5E.Settings.Migrations.NpcExhaustion.sectionTitle"),
      migrationTallyVersion: 6,
      onClick: () => new BulkMigrationsApplication(CONSTANTS.TAB_MIGRATIONS_NPC_EXHAUSTION).render(true)
    },
    {
      label: localize("TIDY5E.Settings.Migrations.SpellClassToSourceClass.sectionTitle"),
      migrationTallyVersion: 5,
      onClick: () => new BulkMigrationsApplication(CONSTANTS.TAB_MIGRATIONS_SPELL_CLASS_TO_SOURCE_CLASS).render(true)
    },
    {
      label: localize("TIDY5E.Settings.Migrations.BondsIdealsFlawsToSystem.sectionTitle"),
      migrationTallyVersion: 5,
      onClick: () => new BulkMigrationsApplication(CONSTANTS.TAB_MIGRATIONS_BONDS_IDEALS_FLAWS_TO_SYSTEM).render(true)
    },
    {
      label: localize("TIDY5E.Settings.Migrations.FavoritesToSystem.sectionTitle"),
      migrationTallyVersion: 4,
      onClick: () => new BulkMigrationsApplication(CONSTANTS.TAB_MIGRATIONS_FAVORITES_TO_SYSTEM).render(true)
    },
    {
      label: localize("TIDY5E.Settings.Migrations.CcssToTidy.sectionTitle"),
      migrationTallyVersion: 3,
      onClick: () => new BulkMigrationsApplication(CONSTANTS.TAB_MIGRATIONS_CCSS_TO_TIDY).render(true)
    },
    {
      label: localize("TIDY5E.Settings.Migrations.NpcDeathSaves.sectionTitle"),
      migrationTallyVersion: 2,
      onClick: () => new BulkMigrationsApplication(CONSTANTS.TAB_MIGRATIONS_NPC_DEATH).render(true)
    },
    {
      label: localize("TIDY5E.Settings.Migrations.CharacterBiography.sectionTitle"),
      migrationTallyVersion: 1,
      onClick: () => new BulkMigrationsApplication(CONSTANTS.TAB_MIGRATIONS_CHARACTER_BIOGRAPHY).render(true)
    }
  ];
  const click_handler = (migration) => migration.onClick();
  const click_handler_1 = () => confirm();
  return [
    localize,
    confirm,
    migrationsConfirmedTally,
    migrations,
    click_handler,
    click_handler_1
  ];
}
class MigrationNotification extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}
const MigrationTally = 6;
class MigrationNotificationFormApplication extends SvelteFormApplicationBase {
  static get defaultOptions() {
    return {
      ...super.defaultOptions,
      height: "auto",
      width: 400,
      classes: [...super.defaultOptions.classes, "migration-notifications"],
      resizable: true
    };
  }
  get title() {
    return FoundryAdapter.localize(
      "TIDY5E.Settings.Migrations.Notification.Title"
    );
  }
  createComponent(node) {
    return new MigrationNotification({
      target: node,
      context: /* @__PURE__ */ new Map([["confirm", this.confirm.bind(this)]])
    });
  }
  confirm() {
    FoundryAdapter.setTidySetting(
      "migrationsConfirmationTally",
      MigrationTally
    );
    this.close();
    ui.notifications.info(
      FoundryAdapter.localize(
        "TIDY5E.Settings.Migrations.Notification.DoNotShowAgain.ConfirmMessage"
      ),
      { permanent: true }
    );
  }
}
class PopoutModuleIntegration {
  get moduleId() {
    return "popout";
  }
  init() {
    this.setCorrectContextMenuPosition();
  }
  setCorrectContextMenuPosition() {
    Hooks.on(
      "tidy5e-sheet.prepareFloatingContextMenuPosition",
      (info) => {
        const appNode = info.target.closest("[data-appId]");
        const appIdAttribute = appNode?.getAttribute("data-appId");
        const appId = parseInt(appIdAttribute ?? "");
        const isPoppedOut = PopoutModule.singleton.poppedOut.has(appId);
        if (!isPoppedOut) {
          return;
        }
        const poppedOutBody = PopoutModule.singleton.poppedOut.get(appId).window.document.body;
        info.insertTarget = poppedOutBody;
        poppedOutBody.addEventListener(
          "click",
          () => {
            ui.context?.close();
            poppedOutBody.querySelectorAll("[data-context-menu]").forEach((el) => el.classList.remove("context"));
          },
          { once: true }
        );
      }
    );
  }
}
class CustomCharacterSheetsModuleIntegration {
  get moduleId() {
    return "custom-character-sheet-sections";
  }
  init(api) {
    Hooks.on(
      "custom-character-sheet-sections.preCustomSectionGetData",
      (data) => {
        return !api.isTidy5eSheet(data.actor.sheet);
      }
    );
  }
}
const moduleIntegrations = [
  new PopoutModuleIntegration(),
  new CustomCharacterSheetsModuleIntegration()
  // Add other module integrations here
];
function setupModuleIntegrations(api) {
  moduleIntegrations.forEach((m2) => {
    try {
      if (game.modules.get(m2.moduleId)?.active) {
        m2.init(api);
      }
    } catch (e2) {
      error(`Module integration failed for ${m2.moduleId}`, false, e2);
    }
  });
}
Hooks.once("init", () => {
  DocumentSheetConfig.registerSheet(
    Actor,
    CONSTANTS.DND5E_SYSTEM_ID,
    Tidy5eCharacterSheet,
    {
      types: [CONSTANTS.SHEET_TYPE_CHARACTER],
      label: "TIDY5E.Tidy5eSheet"
    }
  );
  DocumentSheetConfig.registerSheet(
    Actor,
    CONSTANTS.DND5E_SYSTEM_ID,
    Tidy5eNpcSheet,
    {
      types: [CONSTANTS.SHEET_TYPE_NPC],
      label: "TIDY5E.Tidy5eNPC"
    }
  );
  DocumentSheetConfig.registerSheet(
    Actor,
    CONSTANTS.DND5E_SYSTEM_ID,
    Tidy5eVehicleSheet,
    {
      types: [CONSTANTS.SHEET_TYPE_VEHICLE],
      label: "TIDY5E.Tidy5eVehicle"
    }
  );
  DocumentSheetConfig.registerSheet(
    Item,
    CONSTANTS.DND5E_SYSTEM_ID,
    Tidy5eKgarItemSheet,
    {
      types: [
        CONSTANTS.ITEM_TYPE_BACKGROUND,
        CONSTANTS.ITEM_TYPE_CLASS,
        CONSTANTS.ITEM_TYPE_CONSUMABLE,
        CONSTANTS.ITEM_TYPE_EQUIPMENT,
        CONSTANTS.ITEM_TYPE_FEAT,
        CONSTANTS.ITEM_TYPE_LOOT,
        CONSTANTS.ITEM_TYPE_RACE,
        CONSTANTS.ITEM_TYPE_SPELL,
        CONSTANTS.ITEM_TYPE_SUBCLASS,
        CONSTANTS.ITEM_TYPE_TOOL,
        CONSTANTS.ITEM_TYPE_WEAPON
      ],
      label: "TIDY5E.Tidy5eItemSheet"
    }
  );
  DocumentSheetConfig.registerSheet(
    Item,
    CONSTANTS.DND5E_SYSTEM_ID,
    Tidy5eKgarContainerSheet,
    {
      types: [CONSTANTS.SHEET_TYPE_CONTAINER],
      label: "TIDY5E.Tidy5eContainerSheet"
    }
  );
  initSettings();
  initRuntime();
});
Hooks.once("ready", async () => {
  const tidy5eModule = FoundryAdapter.getModule(CONSTANTS.MODULE_ID);
  const api = Tidy5eSheetsApi._getApi();
  tidy5eModule.api = api;
  TidyHooks.tidy5eSheetsReady(api);
  setupModuleIntegrations(api);
  if (FoundryAdapter.userIsGm() && SettingsProvider.settings.migrationsConfirmationTally.get() < MigrationTally) {
    new MigrationNotificationFormApplication().render(true);
  }
});
//# sourceMappingURL=main.js.map
