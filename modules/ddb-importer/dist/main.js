/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 2449:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ DDBMuncher)
});

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/PatreonHelper.js
var PatreonHelper = __webpack_require__(8636);
// EXTERNAL MODULE: ./src/muncher/items.js
var items = __webpack_require__(8638);
// EXTERNAL MODULE: ./src/muncher/spells.js + 1 modules
var spells = __webpack_require__(6502);
// EXTERNAL MODULE: ./src/parser/race/DDBRace.js
var DDBRace = __webpack_require__(1434);
// EXTERNAL MODULE: ./src/lib/DDBItemImporter.js
var DDBItemImporter = __webpack_require__(6968);
// EXTERNAL MODULE: ./src/lib/DDBReferenceLinker.js
var DDBReferenceLinker = __webpack_require__(7162);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
;// CONCATENATED MODULE: ./src/parser/race/DDBRaceTrait.js








class DDBRaceTrait {

  _generateDataStub() {
    this.data = {
      _id: foundry.utils.randomID(),
      name: "A Racial Trait",
      type: "feat",
      system: utils/* default.getTemplate */.Z.getTemplate("feat"),
      flags: {
        ddbimporter: {
          type: "race",
        },
        obsidian: {
          source: {
            type: "race"
          },
        },
      },
      img: null,
    };
  }

  constructor(trait, ddbRaceData) {
    logger/* default.debug */.Z.debug(`Trait build for ${trait.fullName} started [${ddbRaceData.raceName}]`);
    this.trait = trait;
    this.race = ddbRaceData;
    this.fullName = this.race.fullName;
    this.isLegacy = this.race.isLegacy;
    this.baseRaceName = this.race.baseRaceName;
    this.groupName = DDBRace/* default.getGroupName */.Z.getGroupName(this.race.groupIds, this.baseRaceName);
    this.isSubRace = this.race.isSubRace || this.groupName !== this.raceName;
    this._generateDataStub();
    this._compendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("traits");

    this.name = utils/* default.nameString */.Z.nameString((this.trait.fullName ?? this.trait.name));
    this.data.name = `${this.name}`;
    this.data.system.description.value += `${this.trait.description}\n\n`;

    this.data.flags.ddbimporter = {
      type: "race",
      entityRaceId: this.trait.entityRaceId,
      version: CONFIG.DDBI.version,
      sourceId: this.trait.sources.length > 0 ? [0].sourceId : -1, // is homebrew
      baseName: this.name,
      spellListIds: this.trait.spellListIds,
      definitionKey: this.trait.definitionKey,
      race: this.baseName,
      baseRaceName: this.baseRaceName,
      baseRaceId: this.race.baseRaceId,
      subRaceShortName: this.race.subRaceShortName,
      fullRaceName: this.race.fullName,
      isSubRace: this.isSubRace,
      groupIds: this.race.groupIds,
      groupName: this.groupName,
    };

    if (this.trait.moreDetailsUrl) {
      this.data.flags.ddbimporter['moreDetailsUrl'] = this.trait.moreDetailsUrl;
    }

    this.data.system.source = DDBHelper/* default.parseSource */.Z.parseSource(this.trait);

    if (this.baseRaceName) this.data.system.requirements = this.baseRaceName;
    const legacyName = game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    if (legacyName && this.isLegacy) {
      this.data.name += " (Legacy)";
      logger/* default.debug */.Z.debug(`Trait name ${this.data.name} is legacy`);
    }

    this.data.system.requirements = this.raceName;
    this.data.system.type = {
      value: "race",
    };

    this.data.system.description.value = (0,DDBReferenceLinker/* parseTags */.RN)(this.data.system.description.value);
  }

}


// EXTERNAL MODULE: ./src/lib/DDBCompendiumFolders.js
var DDBCompendiumFolders = __webpack_require__(819);
;// CONCATENATED MODULE: ./src/muncher/races/races.js






const NO_TRAITS = [
  "Speed",
  "Ability Score Increase",
  "Ability Score Increases",
  "Size",
  "Feat",
  "Languages",
  "Extra Language",
  "Age",
  "Alignment",
  "Creature Type",
  "Darkvision",
  "Keen Senses",
  "Natural Athlete",
  "Necrotic Resistance",
  "Skills",
  "Skill Versatility",
];

async function getRaces(data) {
  logger/* default.debug */.Z.debug("get races started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let results = [];
  let races = [];
  let racialFeatures = [];

  const traitCompendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z("traits");
  await traitCompendiumFolders.loadCompendium("traits");

  const excludeLegacy = game.settings.get("ddb-importer", "munching-policy-exclude-legacy");
  const filteredRaces = data.filter((race) => !excludeLegacy || (excludeLegacy && !race.isLegacy));

  for (const race of filteredRaces) {
    logger/* default.debug */.Z.debug(`${race.fullName} features parsing started...`);
    const groupName = DDBRace/* default.getGroupName */.Z.getGroupName(race.groupIds, race.baseRaceName);
    // await traitCompendiumFolders.getRacialBaseFolder("trait", groupName);
    for (const trait of race.racialTraits) {
      logger/* default.debug */.Z.debug(`${trait.definition.name} trait starting...`);
      if (!trait.definition.hideInSheet && !NO_TRAITS.includes(trait.definition.name)) {
        const ddbTrait = new DDBRaceTrait(trait.definition, race);
        racialFeatures.push(ddbTrait.data);
        results.push({ race: race.fullName, trait: trait.definition.name });
        await traitCompendiumFolders.createSubTraitFolders(groupName, race.fullName);
      }
    }
  }

  const raceCompendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z("races");
  await raceCompendiumFolders.loadCompendium("races");
  const traitOptions = { chrisPremades: true, matchFlags: ["entityRaceId"], useCompendiumFolders: true };

  const traitHelper = await DDBItemImporter/* default.buildHandler */.Z.buildHandler("traits", racialFeatures, updateBool, traitOptions);
  const compendiumRacialTraits = await DDBRace/* default.getRacialTraitsLookup */.Z.getRacialTraitsLookup(traitHelper.documents);

  for (const race of filteredRaces) {
    logger/* default.debug */.Z.debug(`${race.fullName} race parsing started...`);
    const ddbRace = new DDBRace/* default */.Z(null, race, compendiumRacialTraits, true);
    await ddbRace.build();
    await raceCompendiumFolders.getRacialBaseFolder("race", ddbRace.groupName);
    races.push(ddbRace.data);
  }

  logger/* default.debug */.Z.debug("Pre-fiddled races", foundry.utils.duplicate(races));
  const raceOptions = { matchFlags: ["entityRaceId"], useCompendiumFolders: true };
  await DDBItemImporter/* default.buildHandler */.Z.buildHandler("races", races, updateBool, raceOptions);

  return results;
}

// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/DDBCampaigns.js
var DDBCampaigns = __webpack_require__(9771);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
// EXTERNAL MODULE: ./src/hooks/ready/checkCompendiums.js
var checkCompendiums = __webpack_require__(9187);
;// CONCATENATED MODULE: ./src/muncher/races.js
// Main module class










function getRaceData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/races`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `races-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getRaces(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseRaces() {

  const racesCompData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Races");
  await (0,checkCompendiums/* createDDBCompendium */.v)(racesCompData);

  const traitCompData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Racial Traits");
  await (0,checkCompendiums/* createDDBCompendium */.v)(traitCompData);

  const results = await getRaceData();

  // FileHelper.download(JSON.stringify(results), `races-icon.json`, "application/json");

  return results;
}



// EXTERNAL MODULE: ./src/muncher/feats/feats.js
var feats = __webpack_require__(267);
;// CONCATENATED MODULE: ./src/muncher/feats.js
// Main module class










function getFeatData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/feats`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `feats-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => (0,feats/* getFeats */.S)(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseFeats() {
  const featsCompData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Feats");
  await (0,checkCompendiums/* createDDBCompendium */.v)(featsCompData);

  const results = await getFeatData();

  return results;
}



// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/lib/DDBTable.js + 2 modules
var DDBTable = __webpack_require__(5366);
;// CONCATENATED MODULE: ./src/muncher/classes/shared.js










const CLASS_TEMPLATE = {
  "name": "",
  "type": "feat",
  "system": {
    "description": {
      "value": "",
      "chat": "",
    },
    "source": "",
  },
  "sort": 2600000,
  "flags": {
    "ddbimporter": {
      "type": "class",
    },
    "obsidian": {
      "source": {
        "type": "class",
        "text": ""
      }
    },
  },
  "img": null
};

const shared_NO_TRAITS = [
  "Speed",
  "Size",
  "Feat",
  "Languages",
  "Hit Points",
  "Proficiencies",
];

const FEATURE_DUP = (/* unused pure expression or super */ null && ([
  "Ability Score Increase",
  "Ability Score Improvement",
  "Expertise",
  "Fighting Style",
  "Land's Stride",
  "Otherworldly Patron",
  "Pact Magic",
  "Potent Spellcasting",
  "Timeless Body",
  "Unarmored Defense",
  "Circle Spells",
  "Divine Strike",
  "Evasion",
  "Channel Divinity",
  "Expanded Spell List",
  "Oath Spells",
  "Psionic Power",
  "Psychic Blades",
  "Spellcasting",
  "Primal Companion",
  "Domain Spells",
  "Bonus Cantrip",
  "Bonus Cantrips",
  "Bonus Proficiencies",
  "Bonus Proficiency",
  "Extra Attack",
  "Tool Proficiency",
]));

async function buildBase(data) {
  let result = foundry.utils.duplicate(CLASS_TEMPLATE);
  const updateExisting = game.settings.get("ddb-importer", "munching-policy-update-existing");

  result.name = data.name;
  const tableDescription = await (0,DDBTable/* generateTable */.p)(data.name, data.description, updateExisting);
  result.system.description.value += `${tableDescription}\n\n`;

  result.flags.ddbimporter = {
    id: data.id,
    data: data,
    version: CONFIG.DDBI.version,
  };

  if (data.moreDetailsUrl) {
    result.flags.ddbimporter['moreDetailsUrl'] = data.moreDetailsUrl;
  }

  result.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data);

  return result;
}

async function generateFeatureAdvancements(klass, compendiumClassFeatures, ignoreIds = []) {
  logger/* default.debug */.Z.debug(`Parsing ${klass.name} features for advancement`);
  const compendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("features");

  let advancements = [];
  klass.classFeatures
    .filter((feature) => !ignoreIds.includes(feature.id))
    .forEach((feature) => {
      const featureMatch = compendiumClassFeatures.find((match) => {
        const matchName = foundry.utils.hasProperty(match, "flags.ddbimporter.featureName")
          ? foundry.utils.getProperty(match, "flags.ddbimporter.featureName").trim().toLowerCase()
          : match.name.trim().toLowerCase();
        return feature.name.trim().toLowerCase() == matchName
          && foundry.utils.hasProperty(match, "flags.ddbimporter")
          && (match.flags.ddbimporter.class == klass.name
            || match.flags.ddbimporter.parentClassId == klass.id
            || match.flags.ddbimporter.classId == klass.id);
      });

      if (featureMatch) {
        const levelAdvancement = advancements.findIndex((advancement) => advancement.level === feature.requiredLevel);

        if (levelAdvancement == -1) {
          const advancement = {
            _id: foundry.utils.randomID(),
            type: "ItemGrant",
            configuration: {
              items: [
                `Compendium.${compendiumLabel}.${featureMatch._id}`
              ]
            },
            value: {},
            level: feature.requiredLevel,
            title: "Features",
            icon: "",
            classRestriction: ""
          };
          advancements.push(advancement);
        } else {
          advancements[levelAdvancement].configuration.items.push(`Compendium.${compendiumLabel}.${featureMatch._id}`);
        }
      }
    });

  return advancements;
}

async function buildClassFeatures(klass, compendiumClassFeatures, ignoreIds = []) {
  logger/* default.debug */.Z.debug(`Parsing ${klass.name} features`);
  let description = "<h1>Class Features</h1>\n\n";
  let classFeatures = [];

  const compendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("features");

  klass.classFeatures.forEach((feature) => {
    const classFeaturesAdded = classFeatures.some((f) => f === feature.name);

    // sort by level?
    if (!classFeaturesAdded && !ignoreIds.includes(feature.id)) {
      const featureMatch = compendiumClassFeatures.find((match) => {
        const matchName = foundry.utils.hasProperty(match, "flags.ddbimporter.featureName")
          ? foundry.utils.getProperty(match, "flags.ddbimporter.featureName").trim().toLowerCase()
          : match.name.trim().toLowerCase();
        return feature.name.trim().toLowerCase() == matchName
          && foundry.utils.hasProperty(match, "flags.ddbimporter")
          && (match.flags.ddbimporter.class == klass.name
            || match.flags.ddbimporter.parentClassId == klass.id
            || match.flags.ddbimporter.classId == klass.id);
      });
      const title = (featureMatch)
        ? `<p><b>@Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}</b></p>`
        : `<p><b>${feature.name}</b></p>`;

      // eslint-disable-next-line require-atomic-updates
      description += `${title}\n${feature.description}\n\n`;
      classFeatures.push(feature.name);
    }
  });

  return description;
}

async function getClassFeature(feature, klass, subClassName = "", className = undefined) {
  logger/* default.debug */.Z.debug("Class feature build started");

  let result = await buildBase(feature);
  result.flags.obsidian.source.text = klass.name;

  result.name = feature.name;
  result.flags.ddbimporter['featureId'] = feature.id;
  result.flags.ddbimporter['featureName'] = feature.name;
  result.flags.ddbimporter['requiredLevel'] = feature.requiredLevel;
  result.flags.ddbimporter['prerequisite'] = feature.prerequisite;
  result.flags.ddbimporter['class'] = className ?? klass.name;
  result.flags.ddbimporter['classId'] = klass.id;
  result.flags.ddbimporter['subClass'] = subClassName;
  result.flags.ddbimporter['parentClassId'] = klass.parentClassId;
  const requiredLevel = feature.requiredLevel ? ` ${feature.requiredLevel}` : "";
  result.system.requirements = `${klass.name}${requiredLevel}`;

  result.system.description.value = (0,DDBReferenceLinker/* parseTags */.RN)(result.system.description.value);

  result.system.type = {
    value: "class",
  };

  return result;
}

async function getClassImages(klass, result) {
  let avatarUrl;
  let largeAvatarUrl;
  let portraitAvatarUrl;

  const targetDirectory = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
  const useDeepPaths = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "use-deep-file-paths");
  const name = klass.fullName ?? klass.name;

  if (klass.portraitAvatarUrl) {
    const imageNamePrefix = useDeepPaths ? "" : "class-portrait";
    const pathPostfix = useDeepPaths ? `/class/portrait` : "";
    const downloadOptions = { type: "class-portrait", name, targetDirectory, imageNamePrefix, pathPostfix };
    portraitAvatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(klass.portraitAvatarUrl, downloadOptions);
    result.img = portraitAvatarUrl;
    result.flags.ddbimporter['portraitAvatarUrl'] = klass.portraitAvatarUrl;
  }

  if (klass.avatarUrl) {
    const imageNamePrefix = useDeepPaths ? "" : "class-avatar";
    const pathPostfix = useDeepPaths ? `/class/avatar` : "";
    const downloadOptions = { type: "class-avatar", name, targetDirectory, imageNamePrefix, pathPostfix };
    avatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(klass.avatarUrl, downloadOptions);
    result.flags.ddbimporter['avatarUrl'] = klass.avatarUrl;
    if (!result.img) {
      result.img = avatarUrl;
    }
  }

  if (klass.largeAvatarUrl) {
    const imageNamePrefix = useDeepPaths ? "" : "class-large";
    const pathPostfix = useDeepPaths ? `/class/large` : "";
    const downloadOptions = { type: "class-large", name, targetDirectory, imageNamePrefix, pathPostfix };
    largeAvatarUrl = await FileHelper/* default.getImagePath */.Z.getImagePath(klass.largeAvatarUrl, downloadOptions);
    // eslint-disable-next-line require-atomic-updates
    result.flags.ddbimporter['largeAvatarUrl'] = klass.largeAvatarUrl;
    if (!result.img) {
      // eslint-disable-next-line require-atomic-updates
      result.img = largeAvatarUrl;
    }
  }

  if (avatarUrl || largeAvatarUrl) {
    const image = (avatarUrl)
      ? `<img class="ddb-class-image" src="${avatarUrl}">\n\n`
      : `<img class="ddb-class-image" src="${largeAvatarUrl}">\n\n`;

    foundry.utils.setProperty(result, "flags.ddbimporter.image", image);
  } else {
    foundry.utils.setProperty(result, "flags.ddbimporter.image", "");
  }

}

async function buildBaseClass(klass) {
  let result = await buildBase(klass);
  logger/* default.debug */.Z.debug(`Parsing ${klass.name}`);
  result.flags.obsidian.source.text = klass.name;
  result.type = "class";
  result.system.identifier = utils/* default.referenceNameString */.Z.referenceNameString(klass.name).toLowerCase();
  result.system.advancement = [];

  await getClassImages(klass, result);
  // eslint-disable-next-line require-atomic-updates
  result.system.description.value += foundry.utils.getProperty(result, "flags.ddbimporter.image");

  result.flags.ddbimporter['parentClassId'] = klass.parentClassId;
  result.flags.ddbimporter['class'] = klass.name;
  result.flags.ddbimporter['hitDice'] = klass.hitDice;
  result.flags.ddbimporter['spellCastingAbilityId'] = klass.spellCastingAbilityId;
  result.flags.ddbimporter['canCastSpells'] = klass.canCastSpells;

  // setup data
  result.system.levels = 1;
  result.system.hitDice = `d${klass.hitDice}`;

  let spellcasting = {};
  if (klass.canCastSpells) {
    const spellProgression = dictionary/* default.spell.progression.find */.Z.spell.progression.find((cls) => cls.name == klass.name);
    const spellCastingAbility = klass.spellCastingAbilityId
      ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((a) => a.id == klass.spellCastingAbilityId).value
      : null;
    if (spellProgression) {
      spellcasting = {
        progression: spellProgression.value,
        ability: spellCastingAbility,
      };
    }
  }
  // eslint-disable-next-line require-atomic-updates
  result.system.spellcasting = spellcasting;

  // this can be used with the add class response
  // const classSkillSubType = `choose-a-${klass.name.toLowerCase()}-skill`;
  // const skillCount = .filter((mod) => mod.subType === classSkillSubType && mod.type === "proficiency"));

  const proficiencyOption = klass.classFeatures.find((feature) =>
    feature.name === "Proficiencies"
    && feature.requiredLevel === 1
  );

  const dom = utils/* default.htmlToDocumentFragment */.Z.htmlToDocumentFragment(proficiencyOption.description);

  // Choose any three
  // Skills: Choose two from Arcana, Animal Handling, Insight, Medicine, Nature, Perception, Religion, and Survival
  const skillText = dom.textContent.toLowerCase().split("skills:").pop().split("\n")[0].split("The")[0].split(".")[0].trim();
  const allSkillRegex = /Skills: Choose any (\w+)(.*)($|\.$|\w+:)/im;
  const allMatch = dom.textContent.match(allSkillRegex);
  const skillRegex = /choose (\w+)(?:\sskills)* from (.*)($|The|\.$|\w+:)/im;
  const skillMatch = skillText.match(skillRegex);

  if (allMatch) {
    const skills = dictionary/* default.character.skills.map */.Z.character.skills.map((skill) => skill.name);
    const numberSkills = dictionary/* default.numbers.find */.Z.numbers.find((num) => allMatch[1].toLowerCase() === num.natural);
    // eslint-disable-next-line require-atomic-updates
    result.system.skills = {
      number: numberSkills ? numberSkills.num : 2,
      choices: skills,
      value: [],
    };
  } else if (skillMatch) {
    const skillNames = skillMatch[2].replace('and', ',').split(',').map((skill) => skill.trim());
    const skills = skillNames.filter((name) => dictionary/* default.character.skills.some */.Z.character.skills.some((skill) => skill.label.toLowerCase() === name.toLowerCase()))
      .map((name) => {
        const dictSkill = dictionary/* default.character.skills.find */.Z.character.skills.find((skill) => skill.label.toLowerCase() === name.toLowerCase());
        return dictSkill.name;
      });
    const numberSkills = dictionary/* default.numbers.find */.Z.numbers.find((num) => skillMatch[1].toLowerCase() === num.natural);
    // eslint-disable-next-line require-atomic-updates
    result.system.skills = {
      number: numberSkills ? numberSkills.num : 2,
      choices: skills,
      value: [],
    };
  }

  // get class saves
  const savingText = dom.textContent.toLowerCase().split("saving throws:").pop().split("\n")[0].split("The")[0].split(".")[0].split("skills:")[0].trim();
  const saveRegex = /(.*)(?:$|The|\.$|\w+:)/im;
  const saveMatch = savingText.match(saveRegex);

  if (saveMatch) {
    const saveNames = saveMatch[1].replace('and', ',').split(',').map((ab) => ab.trim());
    const saves = saveNames
      .filter((name) => dictionary/* default.character.abilities.some */.Z.character.abilities.some((ab) => ab.long.toLowerCase() === name.toLowerCase()))
      .map((name) => {
        const dictAbility = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ab) => ab.long.toLowerCase() === name.toLowerCase());
        return dictAbility.value;
      });
    // eslint-disable-next-line require-atomic-updates
    result.system.saves = saves;
  }

  // "moreDetailsUrl": "/characters/classes/rogue",

  if (klass.equipmentDescription) {
    // eslint-disable-next-line require-atomic-updates
    result.system.description.value += `<p><b>Starting Equipment</b></p>\n${klass.equipmentDescription}\n\n`;
  }

  if (klass.wealthDice) {
    const diceString = klass.wealthDice.diceString;
    const diceMultiplier = klass.wealthDice.diceMultiplier;
    result.system.wealth = diceMultiplier && diceString
      ? `${diceString}*${diceMultiplier}`
      : "";
  }

  return result;
}

;// CONCATENATED MODULE: ./src/muncher/classes/classes.js









function getHPAdvancement(klass, character) {
  // const value = "value": {
  //   "1": "max",
  //   "2": "avg"
  // },
  const value = {};
  if (klass) {
    const rolledHP = foundry.utils.getProperty(character, "flags.ddbimporter.rolledHP") ?? false;
    const startingClass = foundry.utils.getProperty(klass, "flags.ddbimporter.isStartingClass") === true;
    const useMaxHP = game.settings.get("ddb-importer", "character-update-policy-use-hp-max-for-rolled-hp");
    if (rolledHP && !useMaxHP) {
      const baseHP = foundry.utils.getProperty(character, "flags.ddbimporter.baseHitPoints");
      const totalLevels = foundry.utils.getProperty(character, "flags.ddbimporter.dndbeyond.totalLevels");
      const hpPerLevel = Math.floor(baseHP / totalLevels);
      const leftOvers = Math.floor(baseHP % totalLevels);

      for (let i = 1; i <= klass.system.levels; i++) {
        value[`${i}`] = i === 1 && startingClass ? (hpPerLevel + leftOvers) : hpPerLevel;
      }
    } else {
      for (let i = 1; i <= klass.system.levels; i++) {
        value[`${i}`] = i === 1 && startingClass ? "max" : "avg";
      }
    };
  }
  return {
    _id: foundry.utils.randomID(),
    type: "HitPoints",
    configuration: {},
    value,
    title: "",
    icon: "",
    classRestriction: "",
  };
}

async function addSRDAdvancements(advancements, klass) {
  for (const packId of settings/* default.FOUNDRY_COMPENDIUM_MAP.classes */.Z.FOUNDRY_COMPENDIUM_MAP.classes) {
    const pack = CompendiumHelper/* default.getCompendium */.Z.getCompendium(packId, false);
    if (!pack) continue;
    await pack.getIndex();
    const klassMatch = pack.index.find((k) => k.name === klass.name && k.type === "class");
    if (!klassMatch) continue;
    const srdKlass = await pack.getDocument(klassMatch._id);
    const scaleAdvancements = srdKlass.system.advancement.filter((srdA) =>
      srdA.type === "ScaleValue"
      && !advancements.some((ddbA) => ddbA.configuration.identifier === srdA.configuration.identifier)
    ).map((advancement) => {
      return advancement.toObject();
    });
    advancements.push(...scaleAdvancements);
    return advancements;
  }

  return advancements;
}

async function _getSRDEquipment(klass) {
  for (const packId of settings/* default.FOUNDRY_COMPENDIUM_MAP.classes */.Z.FOUNDRY_COMPENDIUM_MAP.classes) {
    const pack = CompendiumHelper/* default.getCompendium */.Z.getCompendium(packId, false);
    if (!pack) continue;
    await pack.getIndex();
    const klassMatch = pack.index.find((k) => k.name === klass.name && k.type === "class");
    if (!klassMatch) continue;
    const srdKlass = await pack.getDocument(klassMatch._id);
    return foundry.utils.duplicate(srdKlass.system.startingEquipment);
  }
  return [];
}

async function buildClass(klass, compendiumClassFeatures) {
  let result = await buildBaseClass(klass);
  result.system.description.value += await buildClassFeatures(klass, compendiumClassFeatures);
  result.system.description.value = (0,DDBReferenceLinker/* parseTags */.RN)(result.system.description.value);
  result.system.advancement.push(getHPAdvancement(), ...(await generateFeatureAdvancements(klass, compendiumClassFeatures)));
  result.system.advancement = await addSRDAdvancements(result.system.advancement, result);
  result.system.startingEquipment = await _getSRDEquipment(result);
  return result;
}

async function getClasses(data) {
  let results = [];
  logger/* default.debug */.Z.debug("get clases started", { data });
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let klasses = [];
  let classFeatures = [];

  const compendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z("features");
  DDBMuncher.munchNote(`Checking compendium folders..`, true);
  await compendiumFolders.loadCompendium("features");
  DDBMuncher.munchNote("", true);

  for (const klass of data) {
    logger/* default.debug */.Z.debug(`${klass.name} feature parsing started...`, { klass });
    for (const feature of klass.classFeatures.sort((a, b) => a.requiredLevel - b.requiredLevel)) {
      const existingFeature = classFeatures.some((f) =>
        f.flags.ddbimporter.featureName === feature.name
        && f.flags.ddbimporter.classId === klass.id
      );
      logger/* default.debug */.Z.debug(`${feature.name} class feature starting...`, { existingFeature, feature });
      if (!shared_NO_TRAITS.includes(feature.name) && !existingFeature) {
        const parsedFeature = await getClassFeature(feature, klass);
        classFeatures.push(parsedFeature);
        results.push({ class: klass.name, subClass: "", feature: feature.name });
      }
    }
  }

  const featureHandlerOptions = {
    chrisPremades: true,
    deleteBeforeUpdate: false,
    removeSRDDuplicates: false,
    filterDuplicates: false,
    matchFlags: ["featureId"],
    useCompendiumFolders: true,
  };

  logger/* default.debug */.Z.debug(`Creating class features`, {
    classFeatures,
    featureHandlerOptions,
    updateBool
  });
  const featureHandler = await DDBItemImporter/* default.buildHandler */.Z.buildHandler("features", classFeatures, updateBool, featureHandlerOptions);
  const firstPassFeatures = await featureHandler.compendiumIndex.filter((i) =>
    featureHandler.documents.some((orig) => i.name === orig.name)
  );
  let compendiumClassFeatures = [];

  for (const f of firstPassFeatures) {
    const feature = await featureHandler.compendium.getDocument(f._id);
    compendiumClassFeatures.push(feature.toJSON());
  }

  for (const klass of data) {
    logger/* default.debug */.Z.debug(`${klass.name} class parsing started...`);
    const builtClass = await buildClass(klass, compendiumClassFeatures);
    klasses.push(builtClass);
  }

  logger/* default.debug */.Z.debug("Class build finished", klasses);
  await DDBItemImporter/* default.buildHandler */.Z.buildHandler("classes", klasses, updateBool, { useCompendiumFolders: true });

  return results;
}

;// CONCATENATED MODULE: ./src/muncher/classes/subclasses.js







// import { buildClassFeatures } from "../../parser/classes/index.js";

async function buildSubClassBase(klass, subClass) {
  delete klass['_id'];
  await getClassImages(subClass, klass);

  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['parentClassId'] = subClass.parentClassId;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['spellCastingAbilityId'] = subClass.spellCastingAbilityId;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['canCastSpells'] = subClass.canCastSpells;
  // eslint-disable-next-line require-atomic-updates
  klass.flags.ddbimporter['moreDetailsUrl'] = subClass.moreDetailsUrl;

  const image = foundry.utils.getProperty(klass, "flags.ddbimporter.image");
  if (image && image !== "") {
    const imageMatch = /$<img class="ddb-class-image"(.*)$/;
    klass.system.description.value.replace(imageMatch, image);
  }

  klass.system.classIdentifier = utils/* default.referenceNameString */.Z.referenceNameString(klass.name).toLowerCase();
  klass.system.identifier = utils/* default.referenceNameString */.Z.referenceNameString(subClass.name).toLowerCase();
  klass.type = "subclass";
  klass.name = subClass.name;

  // eslint-disable-next-line require-atomic-updates
  klass.system.description.value += `<h3>${subClass.name}</h3>\n${subClass.description}\n\n`;

  // spell caster now?
  // if canCastSpells but now canCastSpells then set to third
  if (klass.system.spellcasting === "" && subClass.canCastSpells) {
    // eslint-disable-next-line require-atomic-updates
    klass.system.spellcasting = "third";
  }

  return klass;

}

async function buildSubClass(klass, subclass, compendiumSubClassFeatures) {
  let baseClass = await buildBaseClass(klass.flags.ddbimporter.data);
  let result = await buildSubClassBase(baseClass, subclass);
  const ignoreIds = klass.flags.ddbimporter.data.classFeatures.map((f) => f.id);
  result.system.description.value += await buildClassFeatures(subclass, compendiumSubClassFeatures, ignoreIds);
  result.system.description.value = (0,DDBReferenceLinker/* parseTags */.RN)(result.system.description.value);
  result.system.advancement.push(...(await generateFeatureAdvancements(subclass, compendiumSubClassFeatures, ignoreIds)));
  return result;
}

async function getSubClasses(subClassData, klassData) {
  if (!klassData || !subClassData) {
    return [];
  }
  logger/* default.debug */.Z.debug("get subclasses started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  const classHandler = new DDBItemImporter/* default */.Z("class", [], { deleteBeforeUpdate: false });
  await classHandler.init();
  const classDocs = await classHandler.compendium.getDocuments();

  let subClasses = [];
  let classFeatures = [];
  let results = [];

  const featureCompendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z("features");
  DDBMuncher.munchNote(`Checking compendium folders..`, true);
  await featureCompendiumFolders.loadCompendium("features");
  const subClassCompendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z("subclasses");
  await subClassCompendiumFolders.loadCompendium("subclasses");
  DDBMuncher.munchNote("", true);


  for (const subClass of subClassData) {
    const classMatch = CONFIG.DDB.classConfigurations.find((k) => k.id === subClass.parentClassId);
    await featureCompendiumFolders.createSubClassFeatureFolder(subClass.name, classMatch.name);
    logger/* default.debug */.Z.debug(`${subClass.name} feature parsing started...`, { subClass, classMatch });
    const filteredFeatures = subClass.classFeatures
      .filter((feature) =>
        !klassData.classFeatures.some((f) =>
          feature.id === f.id
        )
      );
    for (const feature of filteredFeatures) {
      const existingFeature = classFeatures.some((f) =>
        f.name === feature.name
        && f.flags.ddbimporter.classId === subClass.id
      );
      logger/* default.debug */.Z.debug(`${feature.name} subclass feature starting...`, { existingFeature, feature });
      if (!shared_NO_TRAITS.includes(feature.name.trim()) && !existingFeature) {
        const parsedFeature = await getClassFeature(feature, subClass, subClass.name, classMatch.name);
        classFeatures.push(parsedFeature);
        results.push({ class: classMatch.name, subClass: subClass.name, feature: feature.name });
      }
    }
  }

  const featureHandlerOptions = {
    chrisPremades: true,
    removeSRDDuplicates: false,
    filterDuplicates: false,
    deleteBeforeUpdate: false,
    matchFlags: ["featureId"],
    useCompendiumFolders: true,
    indexFilter: {
      fields: [
        "name",
        "flags.ddbimporter.classId",
        "flags.ddbimporter.class",
        "flags.ddbimporter.featureName",
        "flags.ddbimporter.subClass",
        "flags.ddbimporter.parentClassId"
      ],
    },
  };

  logger/* default.debug */.Z.debug(`Creating ${klassData.name} subclass features`, {
    classFeatures,
    featureHandlerOptions,
    updateBool
  });
  const featureHandler = await DDBItemImporter/* default.buildHandler */.Z.buildHandler("features", classFeatures, updateBool, featureHandlerOptions);
  await featureHandler.buildIndex(featureHandlerOptions.indexFilter);

  const firstPassFeatures = await featureHandler.compendiumIndex.filter((i) =>
    featureHandler.documents.some((orig) => i.name === orig.name)
  );
  let compendiumClassFeatures = [];

  for (const f of firstPassFeatures) {
    const feature = await featureHandler.compendium.getDocument(f._id);
    compendiumClassFeatures.push(feature.toJSON());
  }

  logger/* default.debug */.Z.debug("Features fetched for classes", compendiumClassFeatures);

  for (const subClass of subClassData) {
    const classMatch = classDocs.find((i) => foundry.utils.getProperty(i, "flags.ddbimporter.id") == subClass.parentClassId);
    const builtClass = await buildSubClass(classMatch, subClass, compendiumClassFeatures);
    subClasses.push(builtClass);
  }

  logger/* default.debug */.Z.debug("Subclass build finished", subClasses);
  const subClassOptions = { deleteBeforeUpdate: false, matchFlags: ["id"], useCompendiumFolders: true };
  await DDBItemImporter/* default.buildHandler */.Z.buildHandler("subclasses", subClasses, updateBool, subClassOptions);

  return results;
}

;// CONCATENATED MODULE: ./src/muncher/classes/options.js





async function getClassOptions(data, className) {
  logger/* default.debug */.Z.debug("get options started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");
  let results = [];

  let classFeatures = [];
  const classMatch = CONFIG.DDB.classConfigurations.find((k) => k.name === className);

  const klass = {
    name: className,
    id: classMatch.id,
  };

  for (const feature of data) {
    const existingFeature = classFeatures.some((f) => f.name === feature.name);
    logger/* default.debug */.Z.debug(`${feature.name} feature starting...`);
    if (!shared_NO_TRAITS.includes(feature.name.trim()) && !existingFeature) {
      const parsedFeature = await getClassFeature(feature, klass);
      foundry.utils.setProperty(parsedFeature, "flags.ddbimporter.optionalFeature", true);
      classFeatures.push(parsedFeature);
      results.push({ class: className, subClass: "", feature: feature.name });
    }
  }

  const options = {
    chrisPremades: true,
    deleteBeforeUpdate: false,
    removeSRDDuplicates: false,
    filterDuplicates: false,
    matchFlags: ["featureId"],
  };
  await DDBItemImporter/* default.buildHandler */.Z.buildHandler("features", classFeatures, updateBool, options);

  return results;
}

;// CONCATENATED MODULE: ./src/muncher/classes.js
// Main module class













function getSubClassesData(className) {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/subclass`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `subclass-${className}-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => resolve(data.data))
      .catch((error) => reject(error));
  });
}

function getClassOptionsData(className) {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/v5/classes/options`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `subclass-${className}-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => resolve(data.data))
      .catch((error) => reject(error));
  });
}

function getClassesData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/classes`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `classes-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => resolve(data.data))
      .catch((error) => reject(error));
  });
}

async function parseClasses() {

  const classesCompData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Classes");
  await (0,checkCompendiums/* createDDBCompendium */.v)(classesCompData);

  const subClassCompData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Subclasses");
  await (0,checkCompendiums/* createDDBCompendium */.v)(subClassCompData);

  const classFeaturesCompData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Class Features");
  await (0,checkCompendiums/* createDDBCompendium */.v)(classFeaturesCompData);

  const classData = await getClassesData();
  const classesResults = await getClasses(classData);

  const classNames = CONFIG.DDB.classConfigurations
    .filter((c) => !c.name.includes("archived") && !c.name.includes("(UA)"))
    .map((c) => c.name);

  const subClassResults = [];
  for (const className of classNames) {
    const klass = classData.find((c) => c.name === className);
    const subClassData = await getSubClassesData(className);
    if (!klass || (subClassData && utils/* default.isArray */.Z.isArray(subClassData) && subClassData.length > 0)) {
      const subClassResult = await getSubClasses(subClassData, klass);
      subClassResults.push(...subClassResult);
    }
  }

  const classOptionsResults = [];
  for (const className of classNames) {
    const classOptionsData = await getClassOptionsData(className);
    const classOptionsResult = await getClassOptions(classOptionsData, className);
    classOptionsResults.push(...classOptionsResult);
  }

  const results = classesResults.concat(
    subClassResults.flat(),
    classOptionsResults.flat()
    // [],
  );

  // FileHelper.download(JSON.stringify(results), `classes-icon.json`, "application/json");
  return results;
}



;// CONCATENATED MODULE: ./src/muncher/frames.js
// Main module class








async function getFrameData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  const body = {
    cobalt: cobaltCookie,
    betaKey: betaKey,
  };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/frames`, {
      method: "POST",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          DDBMuncher.munchNote(`API Failure: ${data.message}`);
          reject(data.message);
        }
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `frames-raw.json`, "application/json");
        }
        return data;
      })
      .then((data) => {
        DDBMuncher.munchNote(`Retrieved ${data.data.length} frames, starting parse...`, true, false);
        logger/* default.info */.Z.info(`Retrieved ${data.data.length} frames`);
        resolve(data.data);
      })
      .catch((error) => reject(error));
  });
}

async function parseFrames() {
  const frames = await getFrameData();
  logger/* default.debug */.Z.debug("Importing frames", frames);
  const targetDirectory = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "frame-image-upload-directory").replace(/^\/|\/$/g, "");
  const useDeepPaths = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "use-deep-file-paths");
  const imageNamePrefix = useDeepPaths ? "" : "frames";

  DDBMuncher.munchNote(`Fetching DDB Frames`);
  frames.forEach(async (frame) => {
    const options = { type: "frame", name: `DDB ${frame.name}`, download: true, targetDirectory, pathPostfix: "", imageNamePrefix };
    await FileHelper/* default.getImagePath */.Z.getImagePath(frame.frameAvatarUrl, options);
  });

  DDBMuncher.munchNote("");

  return frames.length;
}

;// CONCATENATED MODULE: ./src/lib/base64Check.js


function occurrences(string, subString, allowOverlapping) {
  string += "";
  subString += "";
  if (subString.length <= 0) return (string.length + 1);

  let n = 0,
    pos = 0,
    step = allowOverlapping ? 1 : subString.length;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    pos = string.indexOf(subString, pos);
    if (pos >= 0) {
      ++n;
      pos += step;
    } else break;
  }
  return n;
}

function checkBase64(string) {
  let count = occurrences(JSON.stringify(string), "base64");

  return count > 0;
}

function checkScenes() {
  let fixedScenes = [];
  let badScenes = [];
  game.scenes.forEach((scene) => {
    if (checkBase64(scene.thumb)) {
      logger/* default.warn */.Z.warn(`Scene ${scene.name} has base 64 thumb data - fixing!`);
      scene.createThumbnail().then((data) => {
        scene.update({ thumb: data.thumb }, { diff: false });
        ui.notifications.info(`Regenerated thumbnail image for ${scene.name} background image`);
      });
      fixedScenes.push(scene.name);
    }
    if (checkBase64(scene.img)) {
      logger/* default.warn */.Z.warn(`Scene ${scene.name} has base 64 Image data!`);
      ui.notifications.warn(`${scene.name} has a base64 encoded scene image - please fix`);
      badScenes.push(scene.name);
    } else if (checkBase64(scene) && !checkBase64(scene.thumb)) {
      logger/* default.warn */.Z.warn(`Scene ${scene.name} has unknown location base 64 data!`);
      logger/* default.warn */.Z.warn(scene);
      badScenes.push(scene.name);
    }
  });
  if (badScenes.length > 0) logger/* default.warn */.Z.warn("Please fix the following scenes with base64 data:", badScenes);
  return {
    fixedScenes,
    badScenes,
  };
}

function base64Check() {
  return checkScenes();
}

// EXTERNAL MODULE: ./src/muncher/adventure.js
var adventure = __webpack_require__(9441);
// EXTERNAL MODULE: ./src/parser/DDBMonsterFactory.js
var DDBMonsterFactory = __webpack_require__(4029);
;// CONCATENATED MODULE: ./src/muncher/adventure/AdventureMunchHelpers.js










class AdventureMunchHelpers {

  /**
   * Find an entity by the import key.
   * @param  {string} type - Entity type to search for
   * @param  {string} id - Entity Id
   * @returns {object} - Entity Object Data
   */
  static findEntityByImportId(type, id) {
    return game.data[type].find((item) => item._id === id);
  }

  /**
   * Async replace for all matching patterns
   *
   * @param  {string} str - Original string to replace values in
   * @param  {string} regex - regex for matching
   * @param  {function} asyncFn - async function to run on each match
   * @returns {string}
   */
  static async replaceAsync(str, regex, asyncFn) {
    const promises = [];
    str.replace(regex, (match, ...args) => {
      const promise = asyncFn(match, ...args);
      promises.push(promise);
    });
    const data = await Promise.all(promises);
    return str.replace(regex, () => data.shift());
  }

  /**
   * Returns the difference between object 1 and 2
   * @param  {object} obj1
   * @param  {object} obj2
   * @returns {object}
   */
  static diff(obj1, obj2) {
    let result = {};
    for (const key in obj1) {
      if (obj2[key] != obj1[key]) result[key] = obj2[key];
      // eslint-disable-next-line valid-typeof
      if (typeof obj2[key] == 'array' && typeof obj1[key] == 'array')
        result[key] = this.diff(obj1[key], obj2[key]);
      if (typeof obj2[key] == 'object' && typeof obj1[key] == 'object')
        result[key] = this.diff(obj1[key], obj2[key]);
    }
    return result;
  }

  /**
   * Replaces matchAll as it's not yet available in Electron App
   * @param   {string} regex  RegEx to use
   * @param   {string} string String to match on
   * @returns {Array}
   */
  static reMatchAll(regexp, string) {
    const matches = string.match(new RegExp(regexp, "gm"));
    if (matches) {
      let start = 0;
      return matches.map((group0) => {
        const match = group0.match(regexp);
        match.index = string.indexOf(group0, start);
        start = match.index;
        return match;
      });
    }
    return matches;
  }

  static async loadMissingDocuments(type, docIds) {
    return new Promise((resolve) => {
      if (docIds && docIds.length > 0) {
        switch (type) {
          case "item":
            logger/* default.debug */.Z.debug(`Importing missing ${type}s from DDB`, docIds);
            AdventureMunch._progressNote(`Importing ${docIds.length} missing ${type}s from DDB`);
            resolve((0,items/* parseItems */.S)(docIds, false));
            break;
          case "monster": {
            try {
              const tier = PatreonHelper/* default.getPatreonTier */.Z.getPatreonTier();
              const tiers = PatreonHelper/* default.calculateAccessMatrix */.Z.calculateAccessMatrix(tier);
              if (tiers.all) {
                logger/* default.debug */.Z.debug(`Importing missing ${type}s from DDB`, docIds);
                AdventureMunch._progressNote(`Importing ${docIds.length} missing ${type}s from DDB`);
                const monsterFactory = new DDBMonsterFactory/* default */.Z({ munchNote: DDBMuncher.munchNote });
                resolve(monsterFactory.processIntoCompendium(docIds));
              } else {
                logger/* default.warn */.Z.warn(`Unable to import missing ${type}s from DDB - link to patreon or use your own proxy`, docIds);
                ui.notifications.warn(`Unable to import missing ${type}s from DDB - link to patreon or use your own proxy`, { permanent: true });
                resolve([]);
              }
            } catch (err) {
              if (err instanceof SyntaxError) {
                ui.notifications.error("Error fetching monsters, likely cause outdated ddb-proxy", { permanent: true });
              } else {
                throw err;
              }
            }
            break;
          }
          case "spell":
            logger/* default.debug */.Z.debug(`Importing missing ${type}s from DDB`);
            AdventureMunch._progressNote(`Missing spells detected, importing from DDB`);
            // we actually want all spells, because monsters don't just use spells from a single source
            resolve((0,spells/* parseSpells */.Z)(null, false));
            break;
          // no default
        }
      } else {
        resolve([]);
      }
    });
  }

  static async getCompendiumIndex(type) {
    return new Promise((resolve) => {
      const compendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType(type);
      const fields = (type === "monster")
        ? ["flags.ddbimporter.id"]
        : ["flags.ddbimporter.definitionId"];

      const compendiumIndex = compendium.getIndex({ fields: fields });
      resolve(compendiumIndex);
    });
  }

  static async checkForMissingDocuments(type, ids) {
    const index = await AdventureMunchHelpers.getCompendiumIndex(type);
    // console.warn(`${type} index`, index);

    return new Promise((resolve) => {
      const missingIds = ids.filter((id) => {
        switch (type) {
          case "monster":
            return !index.some((i) => i.flags?.ddbimporter?.id && String(i.flags.ddbimporter.id) == String(id));
          case "spell":
          case "item":
            return !index.some((i) => i.flags?.ddbimporter?.definitionId && String(i.flags.ddbimporter.definitionId) == String(id));
          default:
            return false;
        }
      });
      logger/* default.debug */.Z.debug(`${type} missing ids`, missingIds);
      const missingDocuments = AdventureMunchHelpers.loadMissingDocuments(type, missingIds);
      logger/* default.debug */.Z.debug(`${type} missing`, missingDocuments);
      resolve(missingDocuments);
    });
  }

  /**
   * Get documents for ids from compendium
   * @param {string} type compendium type
   * @param {Array} ids array of ddb ids
   * @param {boolean} temporary create the items in the world?
   * @returns {Promise<Array>} array of world actors
   */
  static async getDocuments(type, ids, overrides = {}, temporary = false) {
    const compendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType(type);
    const index = await AdventureMunchHelpers.getCompendiumIndex(type);
    const ddbIds = ids.map((num) => {
      return String(num);
    });

    return new Promise((resolve) => {
      const documents = index
        .filter((idx) => {
          switch (type) {
            case "monster":
              return ddbIds.includes(String(foundry.utils.getProperty(idx, "flags.ddbimporter.id")));
            case "spell":
            case "item":
              return ddbIds.includes(String(foundry.utils.getProperty(idx, "flags.ddbimporter.definitionId")));
            default:
              return false;
          }
        })
        .map((i) => {
          switch (type) {
            case "monster":
              return game.actors.importFromCompendium(compendium, i._id, overrides, { temporary, keepId: true, keepEmbeddedIds: true });
            case "spell":
            case "item":
              return game.items.importFromCompendium(compendium, i._id, overrides, { temporary, keepId: true, keepEmbeddedIds: true });
            default:
              // this should never happen
              return undefined;
          }

        });
      logger/* default.debug */.Z.debug(`${type} documents loaded`, documents);
      resolve(documents);
    });
  }


  static async linkExistingActorTokens(tokens) {
    const monsterIndex = await AdventureMunchHelpers.getCompendiumIndex("monster");

    const newTokens = tokens.map((token) => {
      const monsterHit = monsterIndex.find((monster) =>
        monster.flags?.ddbimporter?.id && token.flags.ddbActorFlags?.id
        && monster.flags.ddbimporter.id === token.flags.ddbActorFlags.id);
      if (monsterHit) {
        token.flags.compendiumActorId = monsterHit._id;
      }
      return token;
    });

    return newTokens;
  }

  // check the document for version data and for update info to see if we can replace it
  static extractDocumentVersionData(newDoc, existingDoc) {
    const ddbIVersion = game.modules.get(settings/* default.MODULE_ID */.Z.MODULE_ID).version;
    if (!existingDoc) existingDoc = {};
    // do we have versioned metadata?
    foundry.utils.setProperty(newDoc, "flags.ddb.versions.importer", {});
    if (newDoc?.flags?.ddb?.versions?.ddbMetaData?.lastUpdate) {
      // check old data, it might not exist
      const oldDDBMetaDataVersions = existingDoc.flags?.ddb?.versions?.ddbMetaData?.lastUpdate
        ? existingDoc.flags.ddb.versions.ddbMetaData
        : {
          lastUpdate: "0.0.1",
          drawings: "0.0.1",
          notes: "0.0.1",
          tokens: "0.0.1",
          walls: "0.0.1",
          lights: "0.0.1",
          foundry: "0.8.9",
        };
      const oldDDBImporterVersion = existingDoc?.flags?.ddb?.versions?.ddbImporter
        ? existingDoc.flags.ddb.versions.ddbImporter
        : "2.0.1";
      const oldAdventureMuncherVersion = existingDoc?.flags?.ddb?.versions?.adventureMuncher
        ? existingDoc.flags.ddb.versions.adventureMuncher
        : "0.3.0";
      const oldVersions = { ddbImporter: oldDDBImporterVersion, ddbMetaData: oldDDBMetaDataVersions, adventureMuncher: oldAdventureMuncherVersion };

      const documentVersions = newDoc.flags.ddb.versions;
      const documentFoundryVersion = documentVersions["ddbMetaData"]["foundry"] !== undefined ? documentVersions["ddbMetaData"]["foundry"] : "0.8.9";
      const importerVersionChanged = foundry.utils.isNewerVersion(ddbIVersion, oldVersions["ddbImporter"]);
      const metaVersionChanged = foundry.utils.isNewerVersion(documentVersions["ddbMetaData"]["lastUpdate"], oldVersions["ddbMetaData"]["lastUpdate"]);
      const muncherVersionChanged = foundry.utils.isNewerVersion(documentVersions["adventureMuncher"], oldVersions["adventureMuncher"]);
      const foundryVersionNewer = foundry.utils.isNewerVersion(documentFoundryVersion, game.version);

      let versionUpdates = {};

      if (metaVersionChanged || muncherVersionChanged || foundryVersionNewer) {
        versionUpdates.importerVersionChanged = importerVersionChanged;
        versionUpdates.metaVersionChanged = metaVersionChanged;
        versionUpdates.muncherVersionChanged = muncherVersionChanged;
        versionUpdates.foundryVersionNewer = foundryVersionNewer;
        versionUpdates.drawingVersionChanged = foundry.utils.isNewerVersion(documentVersions["ddbMetaData"]["drawings"], oldVersions["ddbMetaData"]["drawings"]);
        versionUpdates.noteVersionChanged = foundry.utils.isNewerVersion(documentVersions["ddbMetaData"]["notes"], oldVersions["ddbMetaData"]["notes"]);
        versionUpdates.tokenVersionChanged = foundry.utils.isNewerVersion(documentVersions["ddbMetaData"]["tokens"], oldVersions["ddbMetaData"]["tokens"]);
        versionUpdates.wallVersionChanged = foundry.utils.isNewerVersion(documentVersions["ddbMetaData"]["walls"], oldVersions["ddbMetaData"]["walls"]);
        versionUpdates.lightVersionChanged = foundry.utils.isNewerVersion(documentVersions["ddbMetaData"]["lights"], oldVersions["ddbMetaData"]["lights"]);
      }
      foundry.utils.setProperty(newDoc, "flags.ddb.versions.ddbImporter", ddbIVersion);
      foundry.utils.setProperty(newDoc, "flags.ddb.versions.importer", versionUpdates);
      foundry.utils.setProperty(newDoc, "flags.ddb.oldVersions", oldVersions);
    }
    return newDoc;
  }

  static getImportType(type) {
    const typeName = type[0].toUpperCase() + type.slice(1);
    let importType = typeName;

    switch (type) {
      case "journal":
        importType = "JournalEntry";
        break;
      case "table":
        importType = "RollTable";
        break;
      default:
        importType = typeName;
        break;
    }

    return importType;
  }

  /**
   * Does the folder exist in the zip archive?
   * @param {String} folder folder name
   * @param {Zip} zip
   * @returns {Boolean}
   */
  static folderExists(folder, zip) {
    const files = Object.values(zip.files).filter((file) => {
      return file.dir && file.name.toLowerCase().includes(folder);
    });

    return files.length > 0;
  }

  /**
   * Get the files in the zip archive at the specified path
   * @param {String} folder a folder path to start from
   * @param {Zip} zip
   * @returns {Array} list of files in zip
   */
  static getFiles(folder, zip) {
    const files = Object.values(zip.files).filter((file) => {
      return !file.dir && file.name.split('.').pop() === 'json' && file.name.includes(`${folder}/`);
    });

    return files;
  }


}

// EXTERNAL MODULE: ./src/lib/DirectoryPicker.js
var DirectoryPicker = __webpack_require__(4222);
;// CONCATENATED MODULE: ./src/muncher/adventure/AdventureMunch.js











class AdventureMunch extends FormApplication {

  static COMPENDIUM_MAP = {
    "spells": "spells",
    "magicitems": "items",
    "weapons": "items",
    "armor": "items",
    "adventuring-gear": "items",
    "monsters": "monsters",
    "vehicles": "vehicles",
  };

  static DDB_MAP = {
    "spells": "spells",
    "magicitems": "magic-items",
    "weapons": "equipment",
    "armor": "equipment",
    "adventuring-gear": "equipment",
    "monsters": "monsters",
    "vehicles": "vehicles",
  };


  /** @override */
  constructor(object = {}, options = {}) {
    super(object, options);
    this._itemsToRevisit = [];
    const importPathData = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-import-path");
    this._importPathData = DirectoryPicker/* DirectoryPicker.parse */.B.parse(importPathData);
    this.adventure = null;
    this.folders = null;
    this.raw = {
      scene: [],
      journal: [],
      actor: [],
      item: [],
      table: [],
      playlist: [],
      macro: [],
      folder: [],
    };
    this.temporary = {
      scenes: [],
      journals: [],
      actors: [],
      items: [],
      tables: [],
      playlists: [],
      macros: [],
      folders: [],
    };
    this.remove = {
      folderIds: new Set(),
    };
    this.zip = null;
    this.allMonsters = false;
    this.journalWorldActors = false;
    this.importFilename = null;
    this.importToAdventureCompendium = false;
    this.lookups = {
      folders: {},
      compendiumFolders: {},
      import: {},
      actors: {},
      sceneTokens: {},
      adventureConfig: {},
    };

    this.addToCompendiums = false;
    this.compendiums = {
      journal: null,
      table: null,
    };
    this._compendiumItemsToRevisit = [];
  }

  /** @override */
  static get defaultOptions() {
    this.pattern = /(@[a-z]*)(\[)([a-z0-9]*|[a-z0-9.]*)(\])(\{)(.*?)(\})/gim;
    this.altpattern
      = /((data-entity)=\\?["']?([a-zA-Z]*)\\?["']?|(data-pack)=\\?["']?([[\S.]*)\\?["']?) data-id=\\?["']?([a-zA-Z0-9]*)\\?["']?.*?>(.*?)<\/a>/gim;

    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "ddb-adventure-import",
      classes: ["ddb-adventure-import"],
      title: "Adventure Munch",
      template: "modules/ddb-importer/handlebars/adventure/import.hbs",
      width: 350,
    });
  }

  findCompendiumEntityByImportId(type, id) {
    return this.compendiums[type].index.find((item) => item._id === id);
  }

  replaceUUIDSForCompendium(text) {
    const journalRegex = /@UUID\[JournalEntry/g;
    text = text.replaceAll(journalRegex, `@UUID[Compendium.${this.compendiums.journal.metadata.id}.JournalEntry`);
    const tableRegex = /@UUID\[RollTable/g;
    text = text.replaceAll(tableRegex, `@UUID[Compendium.${this.compendiums.table.metadata.id}.RollTable`);
    return text;
  }

  /**
   * @param  {String} path
   * @param  {Boolean} misc Miscellaneous import type/location?
   * @returns {Object} An object detailing various file path
   */
  getImportFilePaths(path, misc) {
    const useWebP = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "use-webp") && !path.endsWith("svg") && !path.endsWith("pdf");
    const adventurePath = this.adventure.name.replace(/[^a-z0-9]/gi, "_");
    const targetPath = path.replace(/[\\/][^\\/]+$/, "");
    const baseFilename = path.replace(/^.*[\\/]/, "").replace(/\?(.*)/, "");
    const filename
      = useWebP && !baseFilename.endsWith(".webp")
        ? `${FileHelper/* default.removeFileExtension */.Z.removeFileExtension(baseFilename)}.webp`
        : baseFilename;
    const baseUploadPath = misc
      ? game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-misc-path")
      : game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-upload-path");
    const parsedBaseUploadPath = DirectoryPicker/* DirectoryPicker.parse */.B.parse(baseUploadPath);
    const uploadPath = misc
      ? `${parsedBaseUploadPath.current}/${targetPath}`
      : `${parsedBaseUploadPath.current}/${adventurePath}/${targetPath}`;
    const fullUploadPath = misc
      ? `${baseUploadPath}/${targetPath}`
      : `${baseUploadPath}/${adventurePath}/${targetPath}`;
    const pathKey = `${fullUploadPath}/${filename}`;
    const returnFilePath = misc ? `${targetPath}/${filename}` : `${adventurePath}/${targetPath}/${filename}`;
    return {
      pathKey,
      adventurePath,
      targetPath,
      filename,
      baseUploadPath,
      parsedBaseUploadPath,
      uploadPath,
      returnFilePath,
      baseFilename,
      fullUploadPath,
      forcingWebp: useWebP && baseFilename !== filename,
    };
  }

  /**
   * Import a non-image file
   * @param {String} path
   * @param {Blob} content
   * @param {String} mimeType
   * @param {Boolean} misc Miscellaneous import type/location?
   * @returns {Promise<String>} file path
   */
  async importRawFile(path, content, mimeType, misc) {
    try {
      if (path[0] === "*") {
        // this file was flagged as core data, just replace name.
        return path.replace(/\*/g, "");
      } else if (path.startsWith("icons/") || path.startsWith("systems/dnd5e/icons/") || path.startsWith("ddb://")) {
        // these are core icons, ignore
        // or are ddb:// paths that will be replaced by muncher
        return path;
      } else {
        const paths = this.getImportFilePaths(path, misc);

        if (paths.fullUploadPath && !CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(paths.fullUploadPath)) {
          logger/* default.debug */.Z.debug(`Checking dir path ${paths.uploadPath}`, paths);
          await DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(paths.parsedBaseUploadPath, `${paths.uploadPath}`);
          await FileHelper/* default.generateCurrentFiles */.Z.generateCurrentFiles(paths.fullUploadPath);
          CONFIG.DDBI.KNOWN.CHECKED_DIRS.add(paths.fullUploadPath);
        }

        if (!CONFIG.DDBI.KNOWN.FILES.has(paths.pathKey)) {
          logger/* default.debug */.Z.debug(`Importing raw file from ${path}`, paths);
          const fileData = new File([content], paths.filename, { type: mimeType });
          const targetPath = (await DirectoryPicker/* DirectoryPicker.uploadToPath */.B.uploadToPath(paths.fullUploadPath, fileData))?.path;
          CONFIG.DDBI.KNOWN.FILES.add(paths.pathKey);
          CONFIG.DDBI.KNOWN.LOOKUPS.set(`${paths.pathKey}`, targetPath);
        } else {
          logger/* default.debug */.Z.debug(`File already imported ${path}`);
        }

        return `${CONFIG.DDBI.KNOWN.LOOKUPS.get(paths.pathKey)}`;
      }
    } catch (err) {
      logger/* default.error */.Z.error(`Error importing image file ${path} : ${err.message}`, { err });
    }

    return path;
  }

  /**
   * Imports binary file, by extracting from zip file and uploading to path.
   *
   * @param  {String} path - Path to image within zip file
   * @returns {Promise<String>} - Path to file within VTT
   */
  async importImage(path, misc = false) {
    try {
      if (path[0] === "*") {
        // this file was flagged as core data, just replace name.
        return path.replace(/\*/g, "");
      } else if (path.startsWith("icons/") || path.startsWith("systems/dnd5e/icons/") || path.startsWith("ddb://")) {
        // these are core icons, ignore
        // or are ddb:// paths that will be replaced by muncher
        return path;
      } else {
        const paths = this.getImportFilePaths(path, misc);

        if (paths.fullUploadPath && !CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(paths.fullUploadPath)) {
          logger/* default.debug */.Z.debug(`Checking dir path ${paths.uploadPath}`, paths);
          await DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(paths.parsedBaseUploadPath, `${paths.uploadPath}`);
          await FileHelper/* default.generateCurrentFiles */.Z.generateCurrentFiles(paths.fullUploadPath);
          CONFIG.DDBI.KNOWN.CHECKED_DIRS.add(paths.fullUploadPath);
        }

        if (!CONFIG.DDBI.KNOWN.FILES.has(paths.pathKey)) {
          logger/* default.debug */.Z.debug(`Importing image from ${path}`, paths);
          const img = await this.zip.file(path).async("blob");
          const targetPath = await FileHelper/* default.uploadImage */.Z.uploadImage(img, paths.fullUploadPath, paths.filename, paths.forcingWebp);
          CONFIG.DDBI.KNOWN.FILES.add(paths.pathKey);
          CONFIG.DDBI.KNOWN.LOOKUPS.set(paths.pathKey, targetPath);
        } else {
          logger/* default.debug */.Z.debug(`File already imported ${path}`);
        }
        const returnKey = `${paths.fullUploadPath}/${paths.filename}`;

        return `${CONFIG.DDBI.KNOWN.LOOKUPS.get(returnKey)}`;
      }
    } catch (err) {
      logger/* default.error */.Z.error(`Error importing image file ${path} : ${err.message}`, { err });
    }

    return path;
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async getData() {
    let data;
    let files = [];

    try {
      const verifiedDirectory = await DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(this._importPathData);
      if (verifiedDirectory) {
        const options = {
          bucket: this._importPathData.bucket,
          extensions: [".fvttadv", ".FVTTADV", ".zip"],
          wildcard: false,
        };
        data = await DirectoryPicker/* DirectoryPicker.browseFiles */.B.browseFiles(this._importPathData.activeSource, this._importPathData.current, options);
        files = data.files.map((file) => {
          const filename = decodeURIComponent(file).replace(/^.*[\\/]/, "");

          return { path: decodeURIComponent(file), name: filename };
        });
      }
    } catch (err) {
      logger/* default.error */.Z.error(err);
      logger/* default.warn */.Z.warn(
        `Unable to verify import path, this may be due to permissions on the server. You may be able to ignore this message.`
      );
    }

    return {
      data,
      allScenes: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-policy-all-scenes"),
      allMonsters: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-policy-all-actors-into-world"),
      journalWorldActors: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-policy-journal-world-actors"),
      addToCompendiums: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-policy-add-to-compendiums"),
      files,
      cssClass: "ddb-importer-window",
    };
  }

  async importFolder(folders, folderList) {
    // console.warn("Creating Folders", {
    //   folders,
    //   folderList,
    // });
    await utils/* default.asyncForEach */.Z.asyncForEach(folders, async (f) => {
      const folderData = f;

      const existingFolder = game.folders.find((folder) =>
        folder._id === folderData._id && folder.type === folderData.type
      );

      if (existingFolder) {
        if (!this.temporary.folders.some((f) => f._id === existingFolder._id)) {
          this.temporary.folders.push(existingFolder);
        }
        logger/* default.debug */.Z.debug(`Found existing folder ${existingFolder._id} with data:`, folderData, existingFolder);
        // eslint-disable-next-line require-atomic-updates
        // this.lookups.folders[folderData.flags.importid] = existingFolder._id;
      } else {
        if (folderData.parent) folderData.folder = folderData.parent;
        // eslint-disable-next-line require-atomic-updates
        const newFolder = await Folder.create(folderData, { keepId: true });
        this.temporary.folders.push(newFolder);
        if (this.importToAdventureCompendium) this.remove.folderIds.add(newFolder._id);
        logger/* default.debug */.Z.debug(`Created new folder ${newFolder._id} with data:`, folderData, newFolder);
      }

      let childFolders = folderList.filter((folder) => {
        return folder.parent === folderData._id;
      });

      if (childFolders.length > 0) {
        logger/* default.debug */.Z.debug(`Creating subfolders for ${folderData._id} (${folderData.type})`, childFolders);
        await this.importFolder(childFolders, folderList);
      }
    });
  }

  async importCompendiumFolder(folders, folderList) {
    await utils/* default.asyncForEach */.Z.asyncForEach(folders, async (f) => {
      let folderData = f;
      const supportedFolders = ["JournalEntry", "RollTable"];
      if (supportedFolders.includes(folderData.type)) {
        const pack = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType(folderData.type);
        let newFolder = pack.folders.find((folder) =>
          (folder._id === folderData._id || folder.flags.importid === folderData._id)
          && folder.type === folderData.type
        );

        if (!newFolder) {
          if (folderData.parent === null) {
            folderData.parent = this.lookups.folders[folderData.type];
          } else {
            folderData.parent = this.lookups.folders[folderData.parent];
          }

          // eslint-disable-next-line require-atomic-updates
          newFolder = await Folder.create(folderData, { keepId: true, pack: pack.metadata.id });
          logger/* default.debug */.Z.debug(`Created new compendium folder ${newFolder._id} with data:`, folderData, newFolder);
        }

        // eslint-disable-next-line require-atomic-updates
        this.lookups.folders[folderData.flags.importid] = newFolder._id;

        let childFolders = folderList.filter((folder) => {
          return folder.parent === folderData._id;
        });

        if (childFolders.length > 0) {
          await this.importCompendiumFolder(childFolders, folderList);
        }

      }
    });
  }

  /**
   * Create missing folder structures in the world
   */
  async _createFolders() {
    this.lookups.folders = {};
    this.lookups.compendiumFolders = {};

    // the folder list could be out of order, we need to create all folders with parent null first
    const firstLevelFolders = this.folders.filter((folder) => folder.parent === null);
    await this.importFolder(firstLevelFolders, this.folders);
    if (this.addToCompendiums) {
      await this.importCompendiumFolder(firstLevelFolders, this.folders);
    }
  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    html.find(".world-button").on("click", this._importAdventure.bind(this));
    html.find(".compendium-button").on("click", this._importAdventure.bind(this));
  }

  /**
   * Checks for any missing data from DDB in the compendiums, spells, items, monsters that have been referenced by the
   * adventure and imports them using DDB Importer.
   */
  async _checkForMissingData() {
    if (this.adventure.required?.spells && this.adventure.required.spells.length > 0) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - spells required`, this.adventure.required.spells);
      AdventureMunch._progressNote(`Checking for missing spells from DDB`);
      await AdventureMunchHelpers.checkForMissingDocuments("spell", this.adventure.required.spells);
    }
    if (this.adventure.required?.items && this.adventure.required.items.length > 0) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - items required`, this.adventure.required.items);
      AdventureMunch._progressNote(`Checking for missing items from DDB`);
      await AdventureMunchHelpers.checkForMissingDocuments("item", this.adventure.required.items);
    }
    if (this.adventure.required?.monsters && this.adventure.required.monsters.length > 0) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - monsters required`, this.adventure.required.monsters);
      AdventureMunch._progressNote(`Checking for missing monsters from DDB`);
      await AdventureMunchHelpers.checkForMissingDocuments("monster", this.adventure.required.monsters);
    }
    if (parseFloat(this.adventure.version) < 4.1 && this.allMonsters) {
      ui.notifications.warn(`Unable to add all monsters from this adventure, please re-munch adventure with Adventure Muncher v1.0.9 or higher`);
    } else if (parseFloat(this.adventure.version) >= 4.1 && this.allMonsters && this.adventure.required?.monsterData
      && this.adventure.required?.monsterData?.length > 0
    ) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - Importing Remaining Actors`);
      AdventureMunch._progressNote(`Checking for missing world actors (${this.adventure.required.monsterData}) from compendium...`);
      await this.importRemainingActors(this.adventure.required.monsterData);
    }
    logger/* default.debug */.Z.debug("Missing data check complete");
  }

  /**
   * Work through the different types in the adventure and import them
   * @returns {Promise<>}
   */
  async _importFiles() {
    if (AdventureMunchHelpers.folderExists("scene", this.zip)) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - Loading scenes`);
      await this._checkForDataUpdates("scene");
    }
    if (AdventureMunchHelpers.folderExists("actor", this.zip)) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - Loading actors`);
      await this._importFile("actor");
    }
    if (AdventureMunchHelpers.folderExists("item", this.zip)) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - Loading item`);
      await this._importFile("item");
    }
    if (AdventureMunchHelpers.folderExists("journal", this.zip)) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - Loading journal`);
      await this._importFile("journal");
    }
    if (AdventureMunchHelpers.folderExists("table", this.zip)) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - Loading table`);
      await this._importFile("table");
    }
    if (AdventureMunchHelpers.folderExists("playlist", this.zip)) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - Loading playlist`);
      await this._importFile("playlist");
    }
    if (AdventureMunchHelpers.folderExists("macro", this.zip)) {
      logger/* default.debug */.Z.debug(`${this.adventure.name} - Loading macro`);
      await this._importFile("macro");
    }
  }

  _renderCompleteDialog() {
    new Dialog(
      {
        title: `Successful Import of ${this.adventure.name}`,
        content: { adventure: this.adventure },
        buttons: { two: { label: "OK" } },
      },
      {
        classes: ["dialog", "adventure-import-export"],
        template: "modules/ddb-importer/handlebars/adventure/import-complete.hbs",
      }
    ).render(true);
  }

  /**
   * Search temporary items and return a match
   *
   * @param  {String} uuid - Item id or uuid
   * @returns {Object} - Document
   */
  fetchTemporaryItem(uuid) {
    const id = uuid.split(".").pop();
    for (const [key, itemArray] of Object.entries(this.temporary)) {
      logger/* default.debug */.Z.debug(`Checking temporary ${key} for ${uuid}`, itemArray);
      const match = itemArray.find((i) => i._id === id);
      if (match) {
        logger/* default.debug */.Z.debug(`Found ${key} match for ${uuid}`, match);
        return match;
      }
    }
    return undefined;
  }

  /**
   * Get the world actor, or actor that represents the world actor for adventure compendium build
   *
   * @param  {String} actorId - Actor Id
   * @returns {Object} - Actor
   */
  _getWorldActor(actorId) {
    return this.importToAdventureCompendium
      ? this.temporary.actors.find((a) => a._id === actorId)
      : game.actors.get(actorId);
  }

  static async _getTokenUpdateData(worldActor, sceneToken) {
    const items = [];
    const ddbItems = sceneToken.flags.ddbItems ?? [];
    for (const item of ddbItems) {
      if (item.customItem) {
        items.push(item.data);
      } else {
        const ddbId = foundry.utils.getProperty(item, "ddbId");
        if (Number.isInteger(ddbId)) {
          // fetch ddbItem
          const compendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType(item.type);
          const itemRef = compendium.index.find((i) => i.name === item.name && i.type === item.type);
          if (itemRef) {
            const compendiumItem = await compendium.getDocument(itemRef._id);
            const jsonItem = compendiumItem.toObject();
            delete jsonItem._id;
            items.push(jsonItem);
          } else {
            logger/* default.error */.Z.error(`Unable to find compendium item ${item.name}`, { item, sceneToken });
          }
        } else {
          // fetch actor item here
          const actorItem = worldActor.items.find((i) => i.name === item.name && i.type === item.type);
          if (actorItem) {
            const jsonItem = actorItem.toObject();
            delete jsonItem._id;
            items.push(jsonItem);
          } else {
            logger/* default.error */.Z.error(`Unable to find monster feature/item ${item.name}`, { item, sceneToken, worldActor });
          }
        }
      }
    }

    const tokenStub = { };

    if (foundry.utils.hasProperty(sceneToken, "actorData")) {
      const data = foundry.utils.deepClone(sceneToken.actorData);
      if (data.data) {
        foundry.utils.setProperty(tokenStub, "delta.system", foundry.utils.deepClone(data.data));
        if (data.name) foundry.utils.setProperty(tokenStub, "delta.name", foundry.utils.deepClone(data.name));
      } else {
        foundry.utils.setProperty(tokenStub, "delta", foundry.utils.deepClone(sceneToken.actorData));
      }
      delete sceneToken.actorData;
    }

    if (items.length > 0) {
      foundry.utils.setProperty(tokenStub, "delta.items", items);
    }
    if (sceneToken.flags.ddbImages?.keepToken)
      foundry.utils.setProperty(tokenStub, "texture.src", sceneToken.flags.ddbImages.tokenImage);
    if (sceneToken.flags.ddbImages?.keepAvatar)
      foundry.utils.setProperty(tokenStub, "delta.img", sceneToken.flags.ddbImages.avatarImage);

    const updateData = foundry.utils.mergeObject(tokenStub, sceneToken);
    if (updateData.name !== worldActor.name && !foundry.utils.hasProperty(updateData, "delta.name")) {
      foundry.utils.setProperty(updateData, "delta.name", updateData.name);
    }

    const tokenData = await worldActor.getTokenDocument(updateData);

    logger/* default.debug */.Z.debug(`${sceneToken.name} token data for id ${sceneToken.actorId}`, tokenData);
    return tokenData.toObject();
  }

  async _getSceneTokensV11(scene, tokens) {
    const tokenResults = [];
    const deadTokens = [];

    for (const token of tokens) {
      if (token.actorId && !token.actorLink) {
        const sceneToken = scene.flags.ddb.tokens.find((t) => t._id === foundry.utils.getProperty(token, "flags.ddbActorFlags.tokenLinkId"));
        delete sceneToken.scale;
        const worldActor = this._getWorldActor(token.actorId);
        if (worldActor) {
          const updateData = await AdventureMunch._getTokenUpdateData(worldActor, sceneToken);
          tokenResults.push(updateData);
        } else {
          deadTokens.push(token._id);
        }
      } else {
        deadTokens.push(token);
      }
    }

    if (deadTokens.length > 0) {
      logger/* default.warn */.Z.warn(`Removing ${scene.name} tokens with no world actors`, deadTokens);
    }

    return tokenResults;
  }

  async _revisitScene(document) {
    let updatedData = {};
    const scene = foundry.utils.duplicate(document);
    // this is a scene we need to update links to all items
    logger/* default.info */.Z.info(`Updating ${scene.name}, ${scene.tokens.length} tokens`);

    if (!this.importToAdventureCompendium) {
      // In 0.8.x the thumbs don't seem to be generated.
      // This code would embed the thumbnail.
      // Consider writing this out.
      if (!document.thumb) {
        const thumbData = await document.createThumbnail();
        updatedData["thumb"] = thumbData.thumb;
      }
      await document.update(updatedData);
    }
  }

  /**
   * Some items need linking up or tweaking post import.
   * @returns {Promise<>}
   */
  async _revisitItems() {
    try {
      if (this._itemsToRevisit.length > 0) {
        let totalCount = this._itemsToRevisit.length;
        let currentCount = 0;

        await utils/* default.asyncForEach */.Z.asyncForEach(this._itemsToRevisit, async (itemUuid) => {
          const toTimer = setTimeout(() => {
            logger/* default.warn */.Z.warn(`Reference update timed out.`);
            this._renderCompleteDialog();
            this.close();
          }, 180000);
          try {
            const document = this.importToAdventureCompendium
              ? this.fetchTemporaryItem(itemUuid)
              : await fromUuid(itemUuid);
            // let rawData;
            switch (document.documentName) {
              case "Scene": {
                await this._revisitScene(document);
                break;
              }
              // no default
            }
          } catch (err) {
            logger/* default.warn */.Z.warn(`Error updating references for object ${itemUuid}`, err);
          }
          currentCount += 1;
          AdventureMunch._updateProgress(totalCount, currentCount, "References");
          clearTimeout(toTimer);
        });
      }
    } catch (err) {
      // eslint-disable-next-line no-undef
      logger/* default.warn */.Z.warn(`Error during reference update for object ${item}`, err);
    }
    logger/* default.info */.Z.info("Revisit data complete");
  }

  async _loadZip() {
    const form = document.querySelector(`form[class="ddb-importer-window"]`);
    if (form.data.files.length) {
      this.importFilename = form.data.files[0].name;
      this.zip = await FileHelper/* default.readBlobFromFile */.Z.readBlobFromFile(form.data.files[0]).then(JSZip.loadAsync);
    } else {
      const selectedFile = document.querySelector(`[name="import-file"]`).value;
      this.importFilename = selectedFile;
      this.zip = await fetch(`/${selectedFile}`)
        .then((response) => {
          if (response.status === 200 || response.status === 0) {
            return Promise.resolve(response.blob());
          } else {
            return Promise.reject(new Error(response.statusText));
          }
        })
        .then(JSZip.loadAsync);
    }
  }

  async _importAdventureToWorld() {
    await this._importFiles();
    await this._revisitItems();
  }

  async _importAdventureToCompendium() {
    try {
      const adventureData = await this._createAdventure();
      logger/* default.debug */.Z.debug("adventureData to add to compendium", adventureData);
      await this._importAdventureCompendium(adventureData);
    } catch (err) {
      logger/* default.error */.Z.error("Error importing to compendium", err);
      throw err;
    } finally {
      const folderIds = [...this.remove.folderIds];
      if (folderIds.length > 0) {
        logger/* default.debug */.Z.debug("Removing folders", folderIds);
        const results = await Folder.deleteDocuments(folderIds);
        logger/* default.debug */.Z.debug("Delete results", results);
      }
    }

  }

  _unpackZip() {
    for (const key of Object.keys(this.raw)) {
      this.raw[key] = AdventureMunchHelpers.getFiles(key, this.zip);
    }
  }

  async _chooseScenes() {
    const dataFiles = this.raw["scene"];

    logger/* default.info */.Z.info(`Selecting Scenes for ${this.adventure.name} - (${dataFiles.length} possible scenes for import)`);

    let fileData = [];

    await utils/* default.asyncForEach */.Z.asyncForEach(dataFiles, async (file) => {
      const raw = await this.zip.file(file.name).async("text");
      const json = JSON.parse(raw);
      const existingScene = await game.scenes.find((item) => item.id === json._id);
      const scene = AdventureMunchHelpers.extractDocumentVersionData(json, existingScene);
      fileData.push(scene);
    });

    return new Promise((resolve) => {
      new Dialog(
        {
          title: "Choose Scenes to Import",
          content: {
            fileData: fileData,
            cssClass: "import-data-selection",
          },
          buttons: {
            selection: {
              label: "Selected",
              callback: async () => {
                const formData = $(".import-data-selection").serializeArray();
                const scenes = [];
                for (let i = 0; i < formData.length; i++) {
                  const key = formData[i].name;
                  scenes.push(this.raw.scene.find((s) => s.name.includes(key)));
                }
                logger/* default.debug */.Z.debug("scenes to import", scenes);
                this.raw.scene = scenes;
                resolve(this);
              },
            },
            all: {
              label: "All",
              callback: async () => {
                resolve(this);
              },
            },
          },
          default: "all",
          close: async () => {
            resolve(this);
          },
        },
        {
          width: 700,
          classes: ["dialog", "adventure-import-selection"],
          template: "modules/ddb-importer/handlebars/adventure/choose-scenes.hbs",
        }
      ).render(true);
    });

  }

  async _importAdventure(event) {
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    const a = event.currentTarget;
    const action = a.dataset.button;

    if (action === "world" || action === "compendium") {
      try {
        $(".import-progress").toggleClass("import-hidden");
        $(".ddb-overlay").toggleClass("import-invalid");

        this.allScenes = document.querySelector(`[name="all-scenes"]`).checked;
        game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-policy-all-scenes", this.allScenes);
        this.allMonsters = document.querySelector(`[name="all-monsters"]`).checked;
        game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-policy-all-actors-into-world", this.allMonsters);
        this.journalWorldActors = document.querySelector(`[name="journal-world-actors"]`).checked;
        game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-policy-journal-world-actors", this.journalWorldActors);
        this.addToCompendiums = document.querySelector(`[name="add-to-compendiums"]`).checked;
        game.settings.set(settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-policy-add-to-compendiums", this.addToCompendiums);

        if (this.addToCompendiums) {
          const compData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Journals");
          await (0,checkCompendiums/* createDDBCompendium */.v)(compData);
          for (const key of Object.keys(this.compendiums)) {
            this.compendiums[key] = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType(key);
            await this.compendiums[key].getIndex();
          }
        }

        await this._loadZip();
        this._unpackZip();

        this.adventure = JSON.parse(await this.zip.file("adventure.json").async("text"));
        logger/* default.debug */.Z.debug("Loaded adventure data", { adventure: this.adventure });
        try {
          this.folders = JSON.parse(await this.zip.file("folders.json").async("text"));
          logger/* default.debug */.Z.debug("Adventure folders", { folders: this.folders });
        } catch (err) {
          logger/* default.warn */.Z.warn(`Folder structure file not found.`);
        }

        if (this.adventure.system !== game.data.system.id) {
          ui.notifications.error(
            `Invalid system for Adventure ${this.adventure.name}.  Expects ${this.adventure.system}`,
            { permanent: true }
          );
          throw new Error(`Invalid system for Adventure ${this.adventure.name}.  Expects ${this.adventure.system}`);
        }

        if (parseFloat(this.adventure.version) < 4.0) {
          ui.notifications.error(
            `This Adventure (${this.adventure.name}) was generated for v9.  Please regenerate your config file for Adventure Muncher.`,
            { permanent: true }
          );
          throw new Error(
            `This Adventure (${this.adventure.name}) was generated for v9.  Please regenerate your config file for Adventure Muncher.`
          );
        }

        if (action === "compendium") this.importToAdventureCompendium = true;

        await this._createFolders();
        if (!this.allScenes) await this._chooseScenes();
        await this._checkForMissingData();
        this.lookups.adventureConfig = await (0,adventure/* generateAdventureConfig */.k)(true);

        if (action === "world") await this._importAdventureToWorld();
        else if (action === "compendium") {
          const compData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Adventures");
          await (0,checkCompendiums/* createDDBCompendium */.v)(compData);
          await this._importAdventureToCompendium();
        }

        $(".ddb-overlay").toggleClass("import-invalid");

        this._renderCompleteDialog();

        this.close();
      } catch (err) {
        $(".ddb-overlay").toggleClass("import-invalid");
        ui.notifications.error(`There was an error importing ${this.importFilename}`);
        logger/* default.error */.Z.error(`Error importing file ${this.importFilename}`, err);
        logger/* default.error */.Z.error(err);
        logger/* default.error */.Z.error(err.stack);
        this.close();
      } finally {
        // eslint-disable-next-line require-atomic-updates
        this.lookups = {};
      }
    }
  }

  /**
   * Import actors from compendium into world
   * @param {Array<Objects>} neededActors array of needed actors
   * @returns {Promise<Array>} array of world actors
   */
  async ensureWorldActors(neededActors) {
    logger/* default.debug */.Z.debug("Trying to import actors from compendium", neededActors);
    const monsterCompendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("monster", false);
    const results = [];
    await utils/* default.asyncForEach */.Z.asyncForEach(neededActors, async (actor) => {
      let worldActor = this._getWorldActor(actor.actorId);
      if (!worldActor) {
        logger/* default.info */.Z.info(`Importing actor ${actor.name} with DDB ID ${actor.ddbId} from ${monsterCompendium.metadata.name} with compendium id ${actor.compendiumId}`);
        try {
          const options = { keepId: true, keepEmbeddedIds: true, temporary: this.importToAdventureCompendium };
          worldActor = await game.actors.importFromCompendium(monsterCompendium, actor.compendiumId, { _id: actor.actorId, folder: actor.folderId }, options);
        } catch (err) {
          logger/* default.error */.Z.error(err);
          logger/* default.warn */.Z.warn(`Unable to import actor ${actor.name} with id ${actor.compendiumId} from DDB Compendium`);
          logger/* default.debug */.Z.debug(`Failed on: game.actors.importFromCompendium(monsterCompendium, "${actor.compendiumId}", { _id: "${actor.actorId}", folder: "${actor.folderId}" }, { keepId: true });`);
        }
      }
      if (worldActor) results.push(worldActor);
      if (this.importToAdventureCompendium && !this.temporary.actors.some((a) => a._id === actor.actorId)) {
        this.temporary.actors.push(worldActor);
      }
    });
    logger/* default.debug */.Z.debug("Actors transferred from compendium to world.", results);
    return results;
  }

  static async linkDDBActors(tokens) {
    const linkedExistingTokens = await AdventureMunchHelpers.linkExistingActorTokens(tokens);
    const newTokens = linkedExistingTokens
      .filter((token) => token.flags.ddbActorFlags?.id && token.flags.compendiumActorId);

    return Promise.all(newTokens);
  }

  /**
   * Import actors, matching up import ids and actor ids for scene token linking
   * @param {object} data array of actor data objects
   * @param {boolean} temporary create the items in the world?
   * @returns {Promise<Array>} array of world actors
   */
  async importRemainingActors(data) {
    const results = [];
    const monsterCompendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("monster", false);
    const monsterIndex = await AdventureMunchHelpers.getCompendiumIndex("monster");

    logger/* default.debug */.Z.debug("Checking for the following actors in world", data);
    await utils/* default.asyncForEach */.Z.asyncForEach(data, async (actorData) => {
      logger/* default.debug */.Z.debug(`Checking for ${actorData.ddbId}`, actorData);
      let worldActor = this._getWorldActor(actorData.actorId);

      if (worldActor) {
        logger/* default.debug */.Z.debug(`Actor found for ${actorData.actorId}, with name ${worldActor.name}`);
      } else {
        const monsterHit = monsterIndex.find((monster) =>
          monster.flags?.ddbimporter?.id && monster.flags.ddbimporter.id == actorData.ddbId
        );
        if (monsterHit) {
          logger/* default.info */.Z.info(`Importing actor ${monsterHit.name} with DDB ID ${actorData.ddbId} from ${monsterCompendium.metadata.name} with compendium id ${monsterHit._id} (temporary? ${this.importToAdventureCompendium})`);
          try {
            const actorOverride = { _id: actorData.actorId, folder: actorData.folderId };
            const options = { keepId: true, keepEmbeddedIds: true, temporary: this.importToAdventureCompendium };
            // eslint-disable-next-line require-atomic-updates
            worldActor = await game.actors.importFromCompendium(monsterCompendium, monsterHit._id, actorOverride, options);
          } catch (err) {
            logger/* default.error */.Z.error(err);
            logger/* default.warn */.Z.warn(`Unable to import actor ${monsterHit.name} with id ${monsterHit._id} from DDB Compendium`);
            logger/* default.debug */.Z.debug(`Failed on: game.actors.importFromCompendium(monsterCompendium, "${monsterHit._id}", { _id: "${actorData.actorId}", folder: "${actorData.folderId}" }, { keepId: true });`);
          }
        } else {
          logger/* default.error */.Z.error("Actor not found in compendium", actorData);
        }
      }
      if (worldActor) results.push(worldActor);
      if (worldActor && this.importToAdventureCompendium && !this.temporary.actors.some((a) => worldActor.flags.ddbimporter.id == a.flags.ddbimporter.id)) {
        this.temporary.actors.push(worldActor);
      }
    });
    return results;
  }

  /**
   * Generates actors for tokens on a scene
   * @param {object} scene the scene to generate actors for
   * @returns {Promise<Array>} array of world actors
   */
  async generateTokenActors(scene) {
    logger/* default.debug */.Z.debug(`Token Actor generation for ${scene.name} starting`);
    const tokens = await AdventureMunch.linkDDBActors(scene.tokens);
    const neededActors = tokens
      .map((token) => {
        return {
          name: token.name,
          ddbId: token.flags.ddbActorFlags.id,
          actorId: token.actorId,
          compendiumId: token.flags.compendiumActorId,
          folderId: token.flags.actorFolderId
        };
      })
      .filter((obj, pos, arr) => {
        // we only need to create 1 actor per actorId
        return arr.map((mapObj) => mapObj["actorId"]).indexOf(obj["actorId"]) === pos;
      });

    const results = await this.ensureWorldActors(neededActors);
    logger/* default.debug */.Z.debug(`Token Actor generation for ${scene.name} complete`, results);
    return results;
  }

  async _loadDocumentAssets(data, importType) {

    data.flags.importid = data._id;

    if (data.background?.src) {
      // eslint-disable-next-line require-atomic-updates
      data.background.src = await this.importImage(data.background.src);
    } else if (data.img) {
      // eslint-disable-next-line require-atomic-updates
      data.img = await this.importImage(data.img);
    }
    if (data.thumb) {
      // eslint-disable-next-line require-atomic-updates
      data.thumb = await this.importImage(data.thumb);
    }
    if (data?.token?.img) {
      // eslint-disable-next-line require-atomic-updates
      data = await this._importTokenImage("token", data, { img: true, texture: false });
    }
    if (data.toke?.texture?.src) {
      // eslint-disable-next-line require-atomic-updates
      data = await this._importTokenImage("token", data);
    }
    if (data?.prototypeToken?.img) {
      // eslint-disable-next-line require-atomic-updates
      data = await this._importTokenImage("prototypeToken", data, { img: true, texture: false });
    }
    if (data.prototypeToken?.texture?.src) {
      // eslint-disable-next-line require-atomic-updates
      data = await this._importTokenImage("prototypeToken", data);
    }

    if (data?.items?.length) {
      await utils/* default.asyncForEach */.Z.asyncForEach(data.items, async (item) => {
        if (item.img) {
          // eslint-disable-next-line require-atomic-updates
          item.img = await this.importImage(item.img);
        }
      });
    }

    if (data?.pages?.length) {
      await utils/* default.asyncForEach */.Z.asyncForEach(data.pages, async (page) => {
        if (page.src) {
          // eslint-disable-next-line require-atomic-updates
          page.src = await this.importImage(page.src);
        }
      });
    }

    if (importType === "Scene") {
      if (data.tokens) {
        await this.generateTokenActors(data);
      }
      if (data.flags["perfect-vision"] && Array.isArray(data.flags["perfect-vision"])) {
        data.flags["perfect-vision"] = {};
      }
    } else if (importType === "Playlist") {
      await utils/* default.asyncForEach */.Z.asyncForEach(data.sounds, async (sound) => {
        if (sound.path) {
          // eslint-disable-next-line require-atomic-updates
          sound.path = await this.importImage(sound.path);
        }
      });
    } else if (importType === "RollTable") {
      await utils/* default.asyncForEach */.Z.asyncForEach(data.results, async (result) => {
        if (result.img) {
          // eslint-disable-next-line require-atomic-updates
          result.img = await this.importImage(result.img);
        }
        if (result.resultId) {
          data.flags.ddb.needRevisit = true;
        }
        logger/* default.debug */.Z.debug(`Updating DDB links for ${data.name}`);
        // eslint-disable-next-line require-atomic-updates
        data.text = this.foundryCompendiumReplace(data.text);
      });
    } else if (importType === "JournalEntry" && data.pages) {
      await utils/* default.asyncForEach */.Z.asyncForEach(data.pages, async (page) => {
        if (page.text.content) {
          const journalImages = AdventureMunchHelpers.reMatchAll(
            /(src|href)="(?!http(?:s*):\/\/)([\w0-9\-._~%!$&'()*+,;=:@/]*)"/,
            page.text.content
          );
          if (journalImages) {
            logger/* default.debug */.Z.debug(`Updating Image links for ${page.name}`);
            await utils/* default.asyncForEach */.Z.asyncForEach(journalImages, async (result) => {
              const path = await this.importImage(result[2]);
              page.text.content = page.text.content.replace(result[0], `${result[1]}="${path}"`);
            });
          }
          logger/* default.debug */.Z.debug(`Updating DDB links for ${page.name}`);
          page.text.content = this.foundryCompendiumReplace(page.text.content);
        }
      });
    }

    return data;

  }


  async _createAdventure() {
    logger/* default.debug */.Z.debug("Packing up adventure");
    if (this.allMonsters) await this.importRemainingActors(this.adventure.required.monsterData, true);
    const itemData = await AdventureMunchHelpers.getDocuments("items", (this.adventure.required.items ?? []), {}, true);
    const spellData = await AdventureMunchHelpers.getDocuments("spells", (this.adventure.required.spells ?? []), {}, true);

    logger/* default.debug */.Z.debug("Writing out Journals");
    await this._importFile("journal");
    logger/* default.debug */.Z.debug("Cartographer is working on Scenes");
    await this._importFile("scene");
    logger/* default.debug */.Z.debug("Performing some table calculations");
    await this._importFile("table");
    // await this._importFile("Macro", [], true);
    // await this._importFile("Card", [], true);
    // await this._importFile("Playlist", [], true);
    // await this._importFile("Combat", [], true);
    // await this._importFile("Actor", [], true);
    // await this._importFile("Item", [], true);

    const ddbSource = CONFIG.DDB.sources.find((source) => source.description === this.adventure.name);
    const image = ddbSource?.avatarURL
      ? ddbSource.avatarURL
      : await this.importImage("assets/images/cover.jpg");

    await this._revisitItems();

    const data = {
      img: image,
      name: this.adventure.name,
      description: this.adventure.description,
      folders: this.temporary.folders.map((doc) => doc.toObject()),
      combats: [],
      items: itemData.concat(spellData).map((doc) => doc.toObject()),
      actors: this.temporary.actors.map((doc) => doc.toObject()),
      journal: this.temporary.journals.map((doc) => doc.toObject()),
      scenes: this.temporary.scenes.map((doc) => doc.toObject()),
      tables: this.temporary.tables.map((doc) => doc.toObject()),
      macros: [],
      cards: [],
      playlists: [],

      flags: {
        ddbimporter: {
          isDDBAdventure: true,
          adventure: {
            required: this.adventure.required,
            revisitUuids: this._itemsToRevisit,
          },
        },
        core: { sheetClass: "ddb-importer.DDBAdventureImporter" },
      },
    };

    return data;
  }


  async _importAdventureCompendium(adventureData) {
    try {
      const pack = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("adventure");
      const existingAdventure = pack.index.find((i) => i.name === adventureData.name);

      let adventure;
      if (existingAdventure) {
        logger/* default.debug */.Z.debug("Deleting existing adventure", existingAdventure._id);
        adventureData._id = existingAdventure._id;
        const loadedAdventure = await pack.getDocument(existingAdventure._id);
        adventure = await loadedAdventure.update(adventureData, { diff: false, recursive: false });
        ui.notifications.info(game.i18n.format("ADVENTURE.UpdateSuccess", { name: adventureData.name }));
      } else {
        adventure = await Adventure.createDocuments([adventureData], {
          pack: pack.metadata.id,
          keepId: true,
          keepEmbeddedIds: true
        });
        ui.notifications.info(game.i18n.format("ADVENTURE.CreateSuccess", { name: adventureData.name }));

      }

      // console.warn("Adventure!", {
      //   pack,
      //   item: adventureData,
      //   adventure,
      //   temp: this.temporary,
      //   thisAdventure: this.adventure,
      // });
      return adventure;
    } catch (err) {
      logger/* default.error */.Z.error("error building adventure", { err, this: this });
      throw err;
    }
  }

  // import a scene file
  async _importRenderedSceneFile(data, overwriteEntity) {
    if (!AdventureMunchHelpers.findEntityByImportId("scenes", data._id) || overwriteEntity || this.importToAdventureCompendium) {
      await utils/* default.asyncForEach */.Z.asyncForEach(data.tokens, async (token) => {
        foundry.utils.setProperty(token, "flags.ddbActorFlags.tokenLinkId", token._id);
        // eslint-disable-next-line require-atomic-updates
        if (token.img) token.img = await this.importImage(token.img);
        if (token.prototypeToken?.texture?.src) {
          // eslint-disable-next-line require-atomic-updates
          token.prototypeToken.texture.src = await this.importImage(token.prototypeToken.texture.src);
        }
      });

      await utils/* default.asyncForEach */.Z.asyncForEach(data.sounds, async (sound) => {
        // eslint-disable-next-line require-atomic-updates
        sound.path = await this.importImage(sound.path);
      });

      await utils/* default.asyncForEach */.Z.asyncForEach(data.notes, async (note) => {
        // eslint-disable-next-line require-atomic-updates
        if (note.icon) note.icon = await this.importImage(note.icon, true);
        // eslint-disable-next-line require-atomic-updates
        if (note.texture?.src) note.texture.src = await this.importImage(note.texture.src, true);
      });

      await utils/* default.asyncForEach */.Z.asyncForEach(data.tiles, async (tile) => {
        // eslint-disable-next-line require-atomic-updates
        if (tile.img) tile.img = await this.importImage(tile.img);
        // eslint-disable-next-line require-atomic-updates
        if (tile.texture?.src) tile.texture.src = await this.importImage(tile.texture.src);
      });

      for (const wall of data.walls) {
        if (wall.door !== 0 && !wall.doorSound && wall.doorSound !== "") {
          wall.doorSound = "woodBasic";
        }
      }

      if (overwriteEntity) await Scene.deleteDocuments([data._id]);
      const options = { keepId: true, keepEmbeddedIds: true, temporary: false };
      logger/* default.debug */.Z.debug(`Creating Scene ${data.name}`, foundry.utils.deepClone(data));
      const tokens = foundry.utils.deepClone(data.tokens);
      data.tokens = [];
      const scene = await Scene.create(data, options);
      logger/* default.debug */.Z.debug(`Created Scene ${data.name}`, scene);
      const tokenUpdates = await this._getSceneTokensV11(scene, tokens);
      logger/* default.debug */.Z.debug(`Token Updates for ${data.name}`, tokenUpdates);
      const sceneTokens = await scene.createEmbeddedDocuments("Token", tokenUpdates, { keepId: false });
      logger/* default.debug */.Z.debug(`Token update response for ${data.name}`, sceneTokens);
      this._itemsToRevisit.push(`Scene.${scene.id}`);
      if (this.importToAdventureCompendium) {
        this.temporary.scenes.push(scene);
        scene.delete();
      }
    }
  }

  // eslint-disable-next-line complexity
  async _importRenderedFile(typeName, data, needRevisit, overwriteIds) {
    const overwriteEntity = overwriteIds.includes(data._id);
    const options = { keepId: true, keepEmbeddedIds: true, temporary: this.importToAdventureCompendium };
    switch (typeName) {
      case "Scene": {
        await this._importRenderedSceneFile(data, overwriteEntity);
        break;
      }
      case "Actor":
        if (!AdventureMunchHelpers.findEntityByImportId("actors", data._id)) {
          let actor = await Actor.create(data, options);
          await actor.update({ [`prototypeToken.actorId`]: actor.id });
          if (needRevisit) this._itemsToRevisit.push(`Actor.${actor.id}`);
          if (this.importToAdventureCompendium) this.temporary.actors.push(actor);
        }
        break;
      case "Item":
        if (!AdventureMunchHelpers.findEntityByImportId("items", data._id)) {
          let item = await Item.create(data, options);
          if (needRevisit) this._itemsToRevisit.push(`Item.${item.id}`);
          if (this.importToAdventureCompendium) this.temporary.items.push(item);
        }
        break;
      case "JournalEntry":
        if (!AdventureMunchHelpers.findEntityByImportId("journal", data._id)) {
          let journal = await JournalEntry.create(data, options);
          if (needRevisit) this._itemsToRevisit.push(`JournalEntry.${journal.id}`);
          if (this.importToAdventureCompendium) this.temporary.journals.push(journal);
        }
        if (this.addToCompendiums && !this.findCompendiumEntityByImportId("journal", data._id)) {
          const cOptions = foundry.utils.mergeObject(options, { temporary: false, pack: this.compendiums.journal.metadata.id });
          data.pages.forEach((page) => {
            if (page.type == "text") {
              page.text.content = this.replaceUUIDSForCompendium(page.text.content);
            }
          });
          let cJournal = await JournalEntry.create(data, cOptions);
          this._compendiumItemsToRevisit.push(cJournal);
        }
        break;
      case "RollTable":
        if (!AdventureMunchHelpers.findEntityByImportId("tables", data._id)) {
          let rolltable = await RollTable.create(data, options);
          if (needRevisit) this._itemsToRevisit.push(`RollTable.${rolltable.id}`);
          if (this.importToAdventureCompendium) this.temporary.tables.push(rolltable);
        }
        if (this.addToCompendiums && !this.findCompendiumEntityByImportId("table", data._id)) {
          const cOptions = foundry.utils.mergeObject(options, { temporary: false, pack: this.compendiums.table.metadata.id });
          let cTable = await RollTable.create(data, cOptions);
          this._compendiumItemsToRevisit.push(cTable);
        }
        break;
      case "Playlist":
        if (!AdventureMunchHelpers.findEntityByImportId("playlists", data._id)) {
          data.name = `${this.adventure.name}.${data.name}`;
          let playlist = await Playlist.create(data, options);
          if (this.importToAdventureCompendium) this.temporary.playlists.push(playlist);
        }
        break;
      case "Macro":
        if (!AdventureMunchHelpers.findEntityByImportId("macros", data._id)) {
          let macro = await Macro.create(data, options);
          if (needRevisit) this._itemsToRevisit.push(`Macro.${macro.id}`);
          if (this.importToAdventureCompendium) this.temporary.macros.push(macro);
        }
        break;
      // no default
    }
  }

  async _checkForDataUpdates(type) {
    const importType = AdventureMunchHelpers.getImportType(type);
    const dataFiles = this.raw[type];

    logger/* default.info */.Z.info(`Checking ${this.adventure.name} - ${importType} (${dataFiles.length} for updates)`);

    let fileData = [];
    let hasVersions = false;

    await utils/* default.asyncForEach */.Z.asyncForEach(dataFiles, async (file) => {
      const raw = await this.zip.file(file.name).async("text");
      const json = JSON.parse(raw);
      if (!hasVersions && json?.flags?.ddb?.versions) {
        hasVersions = true;
      }
      switch (importType) {
        case "Scene": {
          const existingScene = await game.scenes.find((item) => item.id === json._id);
          const scene = AdventureMunchHelpers.extractDocumentVersionData(json, existingScene);
          const sceneVersions = scene.flags?.ddb?.versions?.importer;
          if (existingScene) {
            if (
              sceneVersions
              && (sceneVersions.metaVersionChanged
                || sceneVersions.muncherVersionChanged
                || sceneVersions.foundryVersionNewer)
            ) {
              fileData.push(scene);
            }
          } else if (sceneVersions && sceneVersions.foundryVersionNewer) {
            fileData.push(scene);
          }
          break;
        }
        // no default
      }
    });

    logger/* default.debug */.Z.debug("Scene update choices", fileData);

    return new Promise((resolve) => {
      if (hasVersions && fileData.length > 0) {
        new Dialog(
          {
            title: `${importType} updates`,
            content: {
              dataType: type,
              dataTypeDisplay: importType,
              fileData,
              cssClass: "import-data-updates",
            },
            buttons: {
              confirm: {
                label: "Confirm",
                callback: async () => {
                  const formData = $(".import-data-updates").serializeArray();
                  let ids = [];
                  let dataType = "";
                  for (let i = 0; i < formData.length; i++) {
                    const key = formData[i].name;
                    if (key.startsWith("new_")) {
                      ids.push(key.substr(4));
                    } else if (key === "type") {
                      dataType = formData[i].value;
                    }
                  }
                  resolve(this._importFile(dataType, { overwriteIds: ids }));
                },
              },
            },
            default: "confirm",
            close: async () => {
              resolve(this._importFile(type));
            },
          },
          {
            width: 700,
            classes: ["dialog", "adventure-import-updates"],
            template: "modules/ddb-importer/handlebars/adventure/import-updates.hbs",
          }
        ).render(true);
      } else {
        resolve(this._importFile(type));
      }
    });
  }

  async _importTokenImage(tokenType, data, { img = false, texture = true } = {}) {
    if (data[tokenType]?.randomImg) {
      const imgFilepaths = data[tokenType].img.split("/");
      const imgFilename = imgFilepaths.reverse()[0];
      const imgFilepath = data[tokenType].img.replace(imgFilename, "");

      const filesToUpload = Object.values(this.zip.files).filter((file) => {
        return !file.dir && file.name.includes(imgFilepath);
      });

      let adventurePath = this.adventure.name.replace(/[^a-z0-9]/gi, "_");

      if (img) {
        const imgPath = `${this._importPathData.current}/${adventurePath}/${data[tokenType].img}`;
        data[tokenType].img = imgPath;
      }
      if (texture) {
        const imgPath = `${this._importPathData.current}/${adventurePath}/${data[tokenType].texture.src}`;
        data[tokenType].texture.src = imgPath;
      }

      if (filesToUpload.length > 0) {
        let currentCount = 1;

        await utils/* default.asyncForEach */.Z.asyncForEach(filesToUpload, async (file) => {
          await this.importImage(file.name);
          currentCount += 1;
          AdventureMunch._updateProgress(filesToUpload.length, currentCount, "Token Image");
        });
      }
    } else {

      if (img) {
        // eslint-disable-next-line require-atomic-updates
        data[tokenType].img = await this.importImage(data[tokenType].img);
      }
      if (texture) {
        // eslint-disable-next-line require-atomic-updates
        data[tokenType].texture.src = await this.importImage(data[tokenType].texture.src);
      }
    }

    return data;
  }

  async _importFile(type, { overwriteIds = [] } = {}) {
    let totalCount = 0;
    let currentCount = 0;

    logger/* default.info */.Z.info(`IDs to overwrite of type ${type}: ${JSON.stringify(overwriteIds)}`);

    const importType = AdventureMunchHelpers.getImportType(type);
    const dataFiles = this.raw[type];

    logger/* default.info */.Z.info(`Importing ${this.adventure.name} - ${importType} (${dataFiles.length} items)`);

    totalCount = dataFiles.length;

    // eslint-disable-next-line complexity
    await utils/* default.asyncForEach */.Z.asyncForEach(dataFiles, async (file) => {
      const rawData = await this.zip.file(file.name).async("text");
      let data = JSON.parse(rawData);
      let needRevisit = false;

      // let pattern = /(\@[a-z]*)(\[)([a-z0-9]*|[a-z0-9\.]*)(\])/gmi
      if (rawData.match(this.pattern) || rawData.match(this.altpattern)) needRevisit = true;

      // eslint-disable-next-line require-atomic-updates
      data = await this._loadDocumentAssets(data, importType);

      if (data.flags.ddb.needRevisit) needRevisit = true;

      foundry.utils.setProperty(data.flags, "ddbimporter.version", CONFIG.DDBI.version);

      // if (importType !== "Playlist" && importType !== "Compendium") {
      //   if (this.lookups.folders[data.folder]) {
      //     logger.debug(
      //       `Adding data to subfolder importkey = ${data.folder}, folder = ${
      //         this.lookups.folders[data.folder]
      //       }`
      //     );
      //     data.folder = this.lookups.folders[data.folder];
      //   } else {
      //     logger.debug(
      //       `Adding data to subfolder importkey = ${data.folder}, folder = ${this.lookups.folders["null"]}`
      //     );
      //     if (this.adventure?.options?.folders) {
      //       data.folder = this.lookups.folders["null"];
      //     } else {
      //       data.folder = this.lookups.folders[importType];
      //     }
      //   }
      // }

      await this._importRenderedFile(importType, data, needRevisit, overwriteIds);

      currentCount += 1;
      AdventureMunch._updateProgress(totalCount, currentCount, importType);
    });
  }

  /**
   * Replaced ddb links with compendium or world links
   * @param {Document} doc HTML document to act on
   * @param {Object} options provide journalWorldActors and actorData if linking to world actors
   * @returns {Document} HTML document with modified links
   */
  replaceLookupLinks(doc) {
    const lookups = this.lookups.adventureConfig.lookups;
    const actorData = this.adventure.required?.monsterData ?? [];

    for (const lookupKey in AdventureMunch.COMPENDIUM_MAP) {
      const compendiumLinks = doc.querySelectorAll(`a[href*="ddb://${lookupKey}/"]`);
      const lookupRegExp = new RegExp(`ddb://${lookupKey}/([0-9]*)`);
      compendiumLinks.forEach((node) => {
        const lookupMatch = node.outerHTML.match(lookupRegExp);
        const lookupValue = lookups[AdventureMunch.COMPENDIUM_MAP[lookupKey]];
        if (lookupValue) {
          const worldActorLink = this.journalWorldActors && ["monsters"].includes(lookupKey);
          const lookupEntry = worldActorLink
            ? actorData.find((a) => a.ddbId === parseInt(lookupMatch[1]))
            : lookupValue.find((e) => e.id == lookupMatch[1]);

          if (lookupEntry) {
            const pageLink = lookupEntry.pageId ? `.JournalEntryPage.${lookupEntry.pageId}` : "";
            const linkStub = lookupEntry.headerLink ? `#${lookupEntry.headerLink}` : "";
            const linkType = worldActorLink ? "UUID" : "Compendium";
            const linkBody = worldActorLink
              ? `Actor.${lookupEntry.actorId}`
              : `${lookupEntry.compendium}.${lookupEntry._id}${pageLink}${linkStub}`;
            doc.body.innerHTML = doc.body.innerHTML.replace(node.outerHTML, `@${linkType}[${linkBody}]{${node.textContent}}`);
          } else {
            logger/* default.warn */.Z.warn(`NO Lookup Compendium Entry for ${node.outerHTML}, using key "${lookupKey}"`, {
              lookups,
              actorData,
              lookupRegExp,
              lookupKey,
            });
          }
        }
      });
    }

    return doc;
  }

  /**
   * Replaced ddb links with compendium or world links, or links back to DDB
   * @param {Document} doc HTML document to act on
   * @param {Object} options provide journalWorldActors and actorData if linking to world actors
   * @returns {Document} HTML document with modified links
   */
  foundryCompendiumReplace(text) {
    // replace the ddb:// entries with known compendium look ups if we have them
    // ddb://spells
    // ddb://magicitems || weapons || adventuring-gear || armor
    // ddb://monsters

    let doc = this.replaceLookupLinks(utils/* default.htmlToDoc */.Z.htmlToDoc(text));

    // vehicles - if not imported, link to DDB
    const compendiumLinks = doc.querySelectorAll("a[href*=\"ddb://vehicles/\"]");
    const lookupRegExp = /ddb:\/\/vehicles\/([0-9]*)/g;
    compendiumLinks.forEach((node) => {
      const target = node.outerHTML;
      const lookupMatch = node.outerHTML.match(lookupRegExp);
      const lookupValue = this.lookups.adventureConfig.lookups["vehicles"];
      if (lookupMatch) {
        const lookupEntry = lookupValue.find((e) => e.id == lookupMatch[1]);
        if (lookupEntry) {
          node.setAttribute("href", `https://www.dndbeyond.com${lookupEntry.url}`);
          doc.body.innerHTML = doc.body.innerHTML.replace(target, node.outerHTML);
        } else {
          logger/* default.warn */.Z.warn(`NO Vehicle Lookup Entry for ${node.outerHTML}`);
        }
      } else {
        logger/* default.warn */.Z.warn(`NO Vehicle Lookup Match for ${node.outerHTML}`);
      }
    });

    // final replace in case of failure
    // there is a chance that the adventure references items or monsters we don't have access to
    // in this case attempt to link to DDB instead of compendium doc
    for (const lookupKey in AdventureMunch.COMPENDIUM_MAP) {
      const compendiumLinks = doc.querySelectorAll(`a[href*="ddb://${lookupKey}/"]`);
      // logger.debug(`final replace for missing ${lookupKey} references`, compendiumLinks);

      compendiumLinks.forEach((node) => {
        const target = node.outerHTML;
        const ddbStub = AdventureMunch.DDB_MAP[lookupKey];
        const ddbNameGuess = node.textContent.toLowerCase().replace(" ", "-").replace(/[^0-9a-z-]/gi, '');
        logger/* default.warn */.Z.warn(`No Compendium Entry for ${node.outerHTML} attempting to guess a link to DDB`);

        node.setAttribute("href", `https://www.dndbeyond.com/${ddbStub}/${ddbNameGuess}`);
        doc.body.innerHTML = doc.body.innerHTML.replace(target, node.outerHTML);
      });
    }

    doc.body.innerHTML = (0,DDBReferenceLinker/* parseTags */.RN)(doc.body.innerHTML);

    return doc.body.innerHTML;
  }

  static _updateProgress(total, count, type) {
    const localizedType = `ddb-importer.label.${type}`;
    $(".import-progress-bar")
      .width(`${Math.trunc((count / total) * 100)}%`)
      .html(
        `<span>${game.i18n.localize("ddb-importer.label.Working")} (${game.i18n.localize(localizedType)})...</span>`
      );
  }

  static _progressNote(note) {
    $(".import-progress-bar").html(`<span>${game.i18n.localize("ddb-importer.label.Working")} (${note})...</span>`);
  }
}

// EXTERNAL MODULE: ./src/lib/Iconizer.js
var Iconizer = __webpack_require__(306);
;// CONCATENATED MODULE: ./src/muncher/adventure/PageFinder.js


class PageFinder {

  generateContentLinks() {
    for (const page of this.journal.pages.filter((p) => p.type === "text")) {
      const dom = utils/* default.htmlToDocumentFragment */.Z.htmlToDocumentFragment(page.text.content);
      const chunkElements = dom.querySelectorAll("[data-content-chunk-id]");
      const chunkIds = new Set();
      chunkElements.forEach((chunk) => {
        chunkIds.add(chunk.dataset["contentChunkId"]);
      });
      this.contentChunkIds[page._id] = chunkIds;

      const idElements = dom.querySelectorAll("[id]");
      const elementIds = new Set();
      idElements.forEach((chunk) => {
        elementIds.add(chunk.id);
      });
      this.elementIds[page._id] = elementIds;
    }
  }

  constructor(journal) {
    this.journal = journal;
    this.contentChunkIds = {};
    this.elementIds = {};
    this.generateContentLinks();
  }


  // returns page Id if content chunk id known in contents
  getPageIdForContentChunkId(chunkId) {
    for (const [key, value] of Object.entries(this.contentChunkIds)) {
      if (value.has(chunkId)) return key;
    }
    return undefined;
  }

  // returns page Id if element id known in contents
  getPageIdForElementId(elementId) {
    for (const [key, value] of Object.entries(this.elementIds)) {
      if (value.has(elementId)) return key;
      // if (value.has(elementId.replace(/^0+/, ""))) return key;
    }
    return undefined;
  }

}

;// CONCATENATED MODULE: ./src/muncher/adventure/ThirdPartyMunch.js










const MR_PRIMATES_THIRD_PARTY_REPO = "MrPrimate/ddb-third-party-scenes";
const RAW_BASE_URL = `https://raw.githubusercontent.com/${MR_PRIMATES_THIRD_PARTY_REPO}`;
const RAW_MODULES_URL = `${RAW_BASE_URL}/main/modules.json`;

class ThirdPartyMunch extends FormApplication {
  /** @override */
  constructor(object = {}, options = {}) {
    super(object, options);
    this._itemsToRevisit = [];
    this._adventure = {};
    this._scenePackage = {};
    this._packageName = "";
    this._description = "";
    this._pageFinders = {};
    this.adventureMunch = new AdventureMunch();
  }

  /** @override */
  static get defaultOptions() {
    this.pattern = /(@[a-z]*)(\[)([a-z0-9]*|[a-z0-9.]*)(\])(\{)(.*?)(\})/gmi;
    this.altpattern = /((data-entity)=\\?["']?([a-zA-Z]*)\\?["']?|(data-pack)=\\?["']?([[\S.]*)\\?["']?) data-id=\\?["']?([a-zA-Z0-9]*)\\?["']?.*?>(.*?)<\/a>/gmi;

    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "ddb-adventure-import",
      classes: ["ddb-adventure-import"],
      title: "Third Party Munch",
      template: "modules/ddb-importer/handlebars/adventure/import-third.hbs",
      width: 400,
      height: "auto",
    });
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async getData() {
    let data;
    let packages = [];

    try {
      data = await $.getJSON(RAW_MODULES_URL);
      this._defaultRepoData = data;
      for (const [key, value] of Object.entries(data.packages)) {
        logger/* default.debug */.Z.debug(`${key}: ${value}`);
        packages.push(value);
      }
      const partialScenes = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "third-party-scenes-partial");
      packages = packages
        .filter((p) => p.released || partialScenes)
        .sort((a, b) => a.name.localeCompare(b.last_nom));
      logger/* default.debug */.Z.debug("_defaultRepoData", this._defaultRepoData);
    } catch (err) {
      logger/* default.error */.Z.error(err);
      logger/* default.warn */.Z.warn(`Unable to generate package list.`);
    }

    return {
      data,
      packages,
      cssClass: "ddb-importer-third-party-window"
    };

  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    html.find(".dialog-button").on("click", this._dialogButton.bind(this));
    html.find("#select-package").on("change", this._selectPackage.bind(this, null, html));
  }

  async _selectPackage(event, html) {
    const packageSelectionElement = html.find("#select-package");

    // get selected campaign from html selection
    const packageSelection = packageSelectionElement[0].selectedOptions[0]
      ? packageSelectionElement[0].selectedOptions[0].value
      : undefined;

    const moduleMessage = html.find("#ddb-message");

    if (packageSelection) {
      const missingModules = [this._defaultRepoData.packages[packageSelection].module].filter((module) => {
        return !game.modules.get(module)?.active;
      });

      this._packageName = packageSelectionElement[0].selectedOptions[0].text;
      this._description = this._defaultRepoData.packages[packageSelection].description;


      let message = "";
      if (missingModules.length > 0) {
        const missingModulesString = missingModules.join(", ");
        message += `<p>You need to install the modules: ${missingModulesString}</p>`;
      }

      const missingBooks = this._defaultRepoData.packages[packageSelection].books.filter((book) => {
        const matchingJournals = game.journal.some((j) => j.flags.ddb?.bookCode === book);
        if (matchingJournals) {
          logger/* default.info */.Z.info(`Found journals for ${book}`);
          return false;
        } else {
          logger/* default.warn */.Z.warn(`Missing journals for ${book}`);
          return true;
        }
      });

      if (missingBooks.length > 0) {
        const bookString = missingBooks.map((bookCode) => DDBHelper/* default.getBookName */.Z.getBookName(bookCode)).join(", ");
        message += `<p>You need to use Adventure Muncher to load the following books first: ${bookString}</p>`;
      }

      if (this._description && this.description !== "") {
        message += `<p><b>Details</b>: ${this._description}</p>`;
      }

      if (message !== "") {
        moduleMessage[0].innerHTML = message;
        $(".ddb-message").removeClass("import-hidden");
      }

      if (missingBooks.length === 0 && missingModules.length === 0) {
        $(".dialog-button").prop('disabled', false);
      }

    } else {
      moduleMessage[0].innerHTML = "";
      $(".ddb-message").addClass("import-hidden");
    }
    $('#ddb-adventure-import').css("height", "auto");
  }

  async _createFolders(adventure, folders) {
    if (folders) {
      CONFIG.DDBI.ADVENTURE.TEMPORARY.folders["null"] = null;
      CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = null;

      // the folder list could be out of order, we need to create all folders with parent null first
      const firstLevelFolders = folders.filter((folder) => folder.parent === null);
      await this.adventureMunch.importFolder(firstLevelFolders, adventure, folders);
    }
  }

  async _checkForMissingData(adventure, folders) {
    await this._createFolders(adventure, folders);

    if (adventure.required?.spells && adventure.required.spells.length > 0) {
      logger/* default.debug */.Z.debug(`${adventure.name} - spells required`, adventure.required.spells);
      ThirdPartyMunch._progressNote(`Checking for missing spells from DDB`);
      await AdventureMunchHelpers.checkForMissingDocuments("spell", adventure.required.spells);
    }
    if (adventure.required?.items && adventure.required.items.length > 0) {
      logger/* default.debug */.Z.debug(`${adventure.name} - items required`, adventure.required.items);
      ThirdPartyMunch._progressNote(`Checking for missing items from DDB`);
      await AdventureMunchHelpers.checkForMissingDocuments("item", adventure.required.items);
    }
    if (adventure.required?.monsters && adventure.required.monsters.length > 0) {
      logger/* default.debug */.Z.debug(`${adventure.name} - monsters required`, adventure.required.monsters);
      ThirdPartyMunch._progressNote(`Checking for missing monsters from DDB`);
      await AdventureMunchHelpers.checkForMissingDocuments("monster", adventure.required.monsters);
    }
  }

  static _renderCompleteDialog(title, adventure) {
    new Dialog(
      {
        title: title,
        content: { adventure },
        buttons: { two: { label: "OK" } },
      },
      {
        classes: ["dialog", "adventure-import-export"],
        template: "modules/ddb-importer/handlebars/adventure/import-complete.hbs",
      }
    ).render(true);
  }

  static async _fixupScenes(scenes) {
    try {
      if (scenes.length > 0) {
        let totalCount = scenes.length;
        let currentCount = 0;

        await utils/* default.asyncForEach */.Z.asyncForEach(scenes, async (obj) => {
          try {
            let updatedData = {};
            switch (obj.documentName) {
              case "Scene": {
                // In 0.8.x the thumbs don't seem to be auto generated anymore
                // This code would embed the thumbnail.
                // Remove once/if resolved
                if (!obj.thumb) {
                  const thumbData = await obj.createThumbnail();
                  updatedData["thumb"] = thumbData.thumb;
                }
                await obj.update(updatedData);
                break;
              }
              // no default
            }
          } catch (err) {
            logger/* default.warn */.Z.warn(`Error updating references for scene ${obj}`, err);
          }
          currentCount += 1;
          ThirdPartyMunch._updateProgress(totalCount, currentCount, "References");
        });
      }
    } catch (err) {
      // eslint-disable-next-line no-undef
      logger/* default.warn */.Z.warn(`Error during reference update for object ${item}`, err);
    }
  }

  static async _createFolder(label, type) {
    const folderData = {
      "name": label,
      "type": type,
      "parent": null,
      "sorting": "m",
    };
    const newFolder = await Folder.create(folderData);
    logger/* default.debug */.Z.debug(`Created new folder ${newFolder._id} with data:`, folderData, newFolder);
    return newFolder;
  }

  static async _findFolder(label, type) {
    const folder = game.folders.find((f) =>
      f.type === type
      && f.parentFolder === undefined
      && f.name === label
    );

    return folder ? folder : ThirdPartyMunch._createFolder(label, type);
  }

  static _generateMockAdventure(scene) {
    const monsters = scene.flags?.ddbimporter?.export?.actors && scene.flags?.ddb?.tokens
      ? scene.flags.ddb.tokens
        .filter((token) => token.flags?.ddbActorFlags?.id)
        .map((token) => token.flags.ddbActorFlags.id)
      : [];
    return {
      id: foundry.utils.randomID(),
      name: DDBHelper/* default.getBookName */.Z.getBookName(scene.flags.ddb.bookCode),
      description: "",
      system: "dnd5e",
      modules: [],
      version: "2.5",
      options: {
        folders: true
      },
      folderColour: "FF0000",
      required: {
        monsters,
      }
    };
  }

  static _generateActorId(token) {
    if (!foundry.utils.hasProperty(token, "flags.ddbActorFlags.id")) logger/* default.warn */.Z.warn("Token does not link to DDB Actor", token);
    const ddbId = token.flags.ddbActorFlags?.id;
    const folderId = token.flags.actorFolderId;
    const key = `${ddbId}-${folderId}`;
    if (CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key]) {
      return CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key];
    } else {
      const existingActor = game.actors.find((actor) =>
        foundry.utils.hasProperty(actor, "flags.ddbimporter.id")
        && actor.folder?.id == folderId && actor.flags.ddbimporter.id == ddbId
      );
      const actorId = existingActor ? existingActor.id : foundry.utils.randomID();
      CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key] = actorId;
      return actorId;
    }
  }

  static async _linkSceneTokens(scene) {
    logger/* default.info */.Z.info(`Linking ${scene.name}, ${scene.tokens.length} tokens`);
    const tokens = await Promise.all(scene.tokens.map(async (token) => {
      if (token.actorId) {
        const worldActor = game.actors.get(token.actorId);
        if (worldActor) {
          // we merge the override data provided by the token to the actor to get
          // world specific things like img paths and scales etc
          const sceneToken = scene.flags.ddb.tokens.find((t) => t._id === token._id);
          delete sceneToken.scale;

          const newToken = await AdventureMunch._getTokenUpdateData(worldActor, sceneToken);
          return newToken;
        }
      }
      return token;
    }));
    return tokens;
  }

  async _linkSceneNotes(scene, adventure) {
    const journalNotes = game.journal.filter((journal) => journal?.flags?.ddb?.bookCode === scene.flags.ddb.bookCode);
    this.adventureMunch.adventure = foundry.utils.deepClone(adventure);

    const noJournalPinNotes = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "third-party-scenes-notes-merged");

    const notes = await Promise.all([scene]
      .filter((scene) => scene.flags?.ddb?.notes)
      .map((scene) => scene.flags.ddb.notes)
      .flat()
      .map(async (note) => {
        const noteJournal = noJournalPinNotes
          ? journalNotes.find((journal) => journal.flags.ddb.cobaltId == note.flags.ddb.parentId)
          : journalNotes.find((journal) => {
            const contentChunkIdMatch = note.flags.ddb.contentChunkId
              ? journal.flags.ddb && note.flags.ddb
                && journal.flags.ddb.contentChunkId == note.flags.ddb.contentChunkId
              : false;

            const noContentChunk = !note.flags.ddb.contentChunkId
              && note.flags.ddb.originalLink && note.flags.ddb.ddbId && note.flags.ddb.parentId
              && note.flags.ddb.slug && note.flags.ddb.linkName;
            const originMatch = noContentChunk
              ? journal.flags.ddb.slug == note.flags.ddb.slug
                && journal.flags.ddb.ddbId == note.flags.ddbId
                && journal.flags.ddb.parentId == note.flags.ddb.parentId
                && journal.flags.ddb.cobaltId == note.flags.ddb.cobaltId
                && journal.flags.ddb.originalLink == note.flags.ddb.originalLink
                && journal.flags.ddb.linkName == note.flags.ddb.linkName
              : false;
            const journalNameMatch = !contentChunkIdMatch && !originMatch
              ? journal.name.trim() == note.label.trim() // ||
              //  journal.pages.some((page) => page.name.trim() === note.label.trim())
              : false;
            return contentChunkIdMatch || originMatch || journalNameMatch;

          });

        if (noteJournal) {
          logger/* default.info */.Z.info(`Found note "${note.label}" matched to Journal with ID "${noteJournal.id}" (${noteJournal.name})`);
          note.flags.ddb.journalId = noteJournal.id;
          // eslint-disable-next-line require-atomic-updates
          note.icon = await Iconizer/* default.generateIcon */.Z.generateIcon(this.adventureMunch, note.label);
          if (noJournalPinNotes) {
            note.flags.ddb.labelName = `${note.label}`;
            note.flags.ddb.slugLink = note.label.replace(/[^\w\d]+/g, "").replace(/^([a-zA-Z]?)0+/, "$1");
            note.flags.anchor = {
              slug: note.flags.ddb.slugLink
            };
            note.text = note.label;

            if (!this._pageFinders[noteJournal._id]) {
              this._pageFinders[noteJournal._id] = new PageFinder(noteJournal);
            }
            const contentChunkIdPageId = foundry.utils.hasProperty(note, "flags.ddb.contentChunkId")
              ? this._pageFinders[noteJournal._id].getPageIdForContentChunkId(note.flags.ddb.contentChunkId)
              : undefined;
            const slugLinkPageId = foundry.utils.hasProperty(note, "flags.ddb.slugLink")
              ? this._pageFinders[noteJournal._id].getPageIdForElementId(note.flags.ddb.slugLink)
              : undefined;

            // console.warn("MATCHES", { slugLinkPageId, contentChunkIdPageId, noteFlags: note.flags.ddb });
            // console.warn("PageIds", noteJournal.pages.map((p) => {return {id: p._id, flags: p.flags.ddb}}));
            const journalPage = noteJournal.pages.find((page) =>
              foundry.utils.hasProperty(page, "flags.ddb")
              && page.flags.ddb.parentId == note.flags.ddb.parentId
              && (page.flags.ddb.slug == note.flags.ddb.slug
              || page.flags.ddb.slug.replace(/^([a-zA-Z]?)0+/, "$1") == note.flags.ddb.slug
              || page.flags.ddb.slug.startsWith(note.flags.ddb.slug)
              || note.flags.ddb.slug.startsWith(page.flags.ddb.slug))
              && (page._id === contentChunkIdPageId || page._id === slugLinkPageId)
            );

            if (journalPage) {
              note.pageId = journalPage._id;
            }
          }
        }
        return note;
      }));

    const positionedNotes = [];
    notes.forEach((note) => {
      if (note.flags?.ddb?.journalId) {
        note.positions.forEach((position) => {
          logger/* default.info */.Z.info(`Matching ${note.label} to position ${position.x}/${position.y}`);
          const noteId = foundry.utils.randomID();
          const n = {
            "_id": noteId,
            "flags": {
              "ddb": note.flags.ddb,
              "importid": noteId,
              "anchor": note.flags.anchor ?? {},
            },
            "entryId": note.flags.ddb.journalId,
            "x": position.x,
            "y": position.y,
            "icon": note.icon, // "assets/icons/1.svg",
            "iconSize": note.iconSize ? note.iconSize : 40,
            "iconTint": "",
            "text": note.text ? note.text : "",
            "fontFamily": note.fontFamily ? note.fontFamily : "Signika",
            "fontSize": note.fontSize ? note.fontSize : 48,
            "textAnchor": 1,
            "textColor": note.textColor ? note.textColor : "",
            "pageId": note.pageId ? note.pageId : undefined,
          };
          positionedNotes.push(n);
        });
      }
    });

    return positionedNotes;
  }

  async _getAdjustedScenes() {
    const adjustedScenes = this._scenePackage.scenes
      .filter((scene) => scene.flags?.ddbimporter?.export?.actors && scene.flags?.ddb?.tokens);

    await utils/* default.asyncForEach */.Z.asyncForEach(adjustedScenes, async(scene) => {
      logger/* default.debug */.Z.debug(`Adjusting scene ${scene.name}`);
      const mockAdventure = ThirdPartyMunch._generateMockAdventure(scene);
      if (scene.flags?.ddbimporter?.export?.actors && scene.flags?.ddb?.tokens) {
        await this._checkForMissingData(mockAdventure, []);
        const bookName = DDBHelper/* default.getBookName */.Z.getBookName(scene.flags.ddb.bookCode);
        const actorFolder = await ThirdPartyMunch._findFolder(bookName, "Actor");
        scene.tokens = scene.flags.ddb.tokens.map((token) => {
          token.flags.actorFolderId = actorFolder.id;
          token.actorId = ThirdPartyMunch._generateActorId(token);
          if (foundry.utils.hasProperty(token, "actorData")) {
            foundry.utils.setProperty(token, "delta", foundry.utils.deepClone(token.actorData));
            delete token.actorData;
          }
          return token;
        });

      }
      // eslint-disable-next-line require-atomic-updates
      scene.notes = await this._linkSceneNotes(scene, mockAdventure);
      logger/* default.debug */.Z.debug(`Finished scene adjustment for ${scene.name}`);
    });

    return adjustedScenes;
  }

  async _getScene(scene) {
    const compendiumId = scene.flags.ddbimporter.export.compendium;
    const compendium = game.packs.get(compendiumId);
    const folderName = this._scenePackage.folder ? this._scenePackage.folder : compendium.metadata.label;
    const folder = await ThirdPartyMunch._findFolder(folderName, "Scene");
    const compendiumScene = compendium.index.find((s) => s.name === scene.name);

    const existingScene = game.scenes.find((s) =>
      s.name === scene.name
      && (s.folder?.id === folder.id || s.folder?.ancestors?.some((f) => f.id === folder.id))
    );

    logger/* default.debug */.Z.debug("Third Party Scene Processing", {
      existingScene,
      scene,
      folder,
      folderName,
      compendiumScene
    });

    // if scene already exists, update
    if (existingScene) {
      logger/* default.info */.Z.info(`Updating ${scene.name}`);
      logger/* default.debug */.Z.debug(`${scene.name}update data`, { scene, existingScene });
      await existingScene.update(scene);
      return existingScene;
    } else {
      scene.folder = folder.id;
      const worldScene = await game.scenes.importFromCompendium(compendium, compendiumScene._id, scene, { keepId: true });
      logger/* default.info */.Z.info(`Scene: ${scene.name} folder:`, folder);
      logger/* default.debug */.Z.debug("worldScene:", worldScene);
      return worldScene;
    }
  }

  async _updateScenes(scenes) {
    logger/* default.debug */.Z.debug("Processing scenes!", scenes);
    const filteredScenes = scenes
      .filter((scene) => scene.flags?.ddbimporter?.export?.compendium)
      // does the scene match a compendium scene
      .filter(async (scene) => {
        const compendium = game.packs.get(scene.flags.ddbimporter.export.compendium);
        const compendiumScene = compendium.index.find((s) => s.name === scene.name);
        if (compendiumScene) return true;
        else return false;
      });

    const processedScenes = [];

    await utils/* default.asyncForEach */.Z.asyncForEach(filteredScenes, async(scene) => {
      logger/* default.debug */.Z.debug(`Processing scene ${scene.name} with DDB Updates`);
      const tokenUpdates = foundry.utils.duplicate(scene.tokens);
      logger/* default.debug */.Z.debug("tokenUpdates", tokenUpdates);
      scene.tokens = [];
      const worldScene = await this._getScene(scene);

      logger/* default.debug */.Z.debug("World scene to add tokens to", worldScene);
      const existingTokens = tokenUpdates.filter((t) => worldScene.tokens.some((wT) => t._id === wT._id));
      logger/* default.debug */.Z.debug("existingTokens", existingTokens);
      await worldScene.updateEmbeddedDocuments("Token", existingTokens, { keepId: true, keepEmbeddedIds: true });
      const newTokens = tokenUpdates.filter((t) => !worldScene.tokens.some((wT) => t._id === wT._id));
      logger/* default.debug */.Z.debug("newTokens", newTokens);
      await worldScene.createEmbeddedDocuments("Token", newTokens, { keepId: true, keepEmbeddedIds: true });

      logger/* default.debug */.Z.debug(`Finished scene DDB update ${scene.name}`);
    });
    return processedScenes;
  }

  async _dialogButton(event) {
    event.preventDefault();
    event.stopPropagation();
    const a = event.currentTarget;
    const action = a.dataset.button;
    const packageName = this._packageName;

    if (action === "import") {
      $(".import-progress").toggleClass("import-hidden");
      $(".ddb-overlay").toggleClass("import-invalid");
      const selectedPackage = $("#select-package").val();
      const packageURL = `${RAW_BASE_URL}/main/${selectedPackage}/module.json`;

      this._scenePackage = await fetch(packageURL)
        .then((response) => {
          if (response.status === 200 || response.status === 0) {
            return Promise.resolve(response.json());
          } else {
            return Promise.reject(new Error(response.statusText));
          }
        });

      // check for valid json object?

      logger/* default.debug */.Z.debug("_scenePackage", this._scenePackage);

      CONFIG.DDBI.ADVENTURE.TEMPORARY = {
        folders: {},
        import: {},
        actors: {},
        sceneTokens: {},
        mockActors: {},
      };

      this.folderNames = this._scenePackage.folder
        ? [this._scenePackage.folder]
        : [...new Set(this._scenePackage.scenes
          .filter((scene) => scene.flags?.ddbimporter?.export?.compendium)
          .map((scene) => {
            const compendiumId = scene.flags.ddbimporter.export.compendium;
            const compendium = game.packs.get(compendiumId);
            return compendium.metadata.label;
          }))];

      // We need to check for potential Scene Folders and Create if missing
      const compendiumLabels = this.folderNames
        .map((label) => {
          return ThirdPartyMunch._findFolder(label, "Scene");
        });

      await Promise.all(compendiumLabels);

      const adventureLabels = [...new Set(this._scenePackage.scenes
        .filter((scene) => scene.flags?.ddb?.bookCode)
        .map((scene) => {
          return DDBHelper/* default.getBookName */.Z.getBookName(scene.flags.ddb.bookCode);
        }))]
        .map((label) => {
          return ThirdPartyMunch._findFolder(label, "Actor");
        });
      await Promise.all(adventureLabels);

      logger/* default.debug */.Z.debug("Competed folder creation");

      // import any missing monsters into the compendium
      // add tokens to scene
      // add notes to scene
      const adjustedScenes = await this._getAdjustedScenes(this._scenePackage.scenes);

      logger/* default.debug */.Z.debug("adjustedScenes", foundry.utils.duplicate(adjustedScenes));

      logger/* default.debug */.Z.debug("About to generate Token Actors");
      // load token actors into world
      await utils/* default.asyncForEach */.Z.asyncForEach(adjustedScenes, async(scene) => {
        logger/* default.debug */.Z.debug(`Generating scene actors for ${scene.name}`);
        await this.adventureMunch.generateTokenActors(scene);
        logger/* default.debug */.Z.debug(`Finished scene actors for ${scene.name}`);
      });

      // link tokens on scene to imported actors
      const tokenAdjustedScenes = await Promise.all(adjustedScenes
        .map(async (scene) => {
          logger/* default.debug */.Z.debug(`Generating scene tokens for ${scene.name}`);
          const newScene = foundry.utils.duplicate(scene);
          newScene.tokens = await ThirdPartyMunch._linkSceneTokens(scene);
          return newScene;
        })
      );

      logger/* default.debug */.Z.debug("tokenAdjustedScenes", tokenAdjustedScenes);

      CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = await (0,adventure/* generateAdventureConfig */.k)(true);
      logger/* default.debug */.Z.debug("Lookups loaded", CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups.lookups);

      const scenes = await this._updateScenes(tokenAdjustedScenes);
      // logger.debug("finalScenes", scenes);

      const toTimer = setTimeout(() => {
        logger/* default.warn */.Z.warn(`Reference update timed out.`);
        ThirdPartyMunch._renderCompleteDialog(`Un-Successful Import of ${packageName}`, { name: packageName });
        this.close();
      }, 120000);

      // clearup remaining scene things
      await ThirdPartyMunch._fixupScenes(scenes);
      clearTimeout(toTimer);

      $(".ddb-overlay").toggleClass("import-invalid");

      ThirdPartyMunch._renderCompleteDialog(`Successful Import of ${packageName}`, { name: packageName });

      // eslint-disable-next-line require-atomic-updates
      CONFIG.DDBI.ADVENTURE.TEMPORARY = {};
      this.close();
    }
  }

  static _updateProgress(total, count, type) {
    const localizedType = `ddb-importer.label.${type}`;
    $(".import-progress-bar")
      .width(`${Math.trunc((count / total) * 100)}%`)
      .html(`<span>${game.i18n.localize("ddb-importer.label.Working")} (${game.i18n.localize(localizedType)})...</span>`);
  }

  static _progressNote(note) {
    $(".import-progress-bar")
      .html(`<span>${game.i18n.localize("ddb-importer.label.Working")} (${note})...</span>`);
  }
}

// EXTERNAL MODULE: ./src/lib/MuncherSettings.js
var MuncherSettings = __webpack_require__(6886);
// EXTERNAL MODULE: ./src/effects/DDBMacros.js
var DDBMacros = __webpack_require__(6516);
// EXTERNAL MODULE: ./src/muncher/tools.js
var tools = __webpack_require__(8089);
// EXTERNAL MODULE: ./src/parser/character/bio.js
var bio = __webpack_require__(2331);
// EXTERNAL MODULE: ./src/parser/features/DDBFeature.js
var DDBFeature = __webpack_require__(4074);
;// CONCATENATED MODULE: ./src/muncher/backgrounds/backgrounds.js


// import { parseTags } from "../../lib/DDBReferenceLinker.js";




// const BACKGROUND_TEMPLATE = {
//   "name": "",
//   "type": "background",
//   "system": {
//     "description": {
//       "value": "",
//       "chat": "",
//     },
//     "type": {
//       "value": "background",
//     },
//     "source": "",
//   },
//   "sort": 2600000,
//   "flags": {
//     "ddbimporter": {},
//     "obsidian": {
//       "source": {
//         "type": "background"
//       }
//     },
//   },
//   "img": "icons/skills/trades/academics-book-study-purple.webp",
// };

// async function buildBase(data) {
//   let result = foundry.utils.duplicate(BACKGROUND_TEMPLATE);
//   const bgData = generateBackground(data);
//   result.name = data.name;
//   result.system.description.value += `${bgData.description}\n\n`;

//   result.flags.ddbimporter = {
//     featId: data.id,
//     version: CONFIG.DDBI.version,
//   };

//   result.system.source = DDBHelper.parseSource(data);
//   result.system.description.value = parseTags(result.system.description.value);
//   result.system.description.value = await generateTable(result.name, result.system.description.value, true, "background");

//   return result;
// }


async function buildBackground(backgroundData) {
  let featDefinition = (0,bio/* generateBackground */.E)(backgroundData);

  const source = DDBHelper/* default.parseSource */.Z.parseSource(featDefinition);
  const ddbFeature = new DDBFeature/* default */.Z({
    ddbData: null,
    ddbDefinition: featDefinition,
    rawCharacter: null,
    type: "background",
    source,
    noMods: true,
  });

  ddbFeature.build();
  logger/* default.debug */.Z.debug(`DDBFeatures.getFeaturesFromDefinition: ${ddbFeature.ddbDefinition.name}`, {
    ddbFeature,
    featDefinition,
  });

  await ddbFeature.generateAdvancements();
  const featIds = foundry.utils.getProperty(backgroundData, "featList.featIds") ?? [];
  await ddbFeature.buildBackgroundFeatAdvancements(featIds);

  return ddbFeature.data;

}


async function getBackgrounds(data) {
  logger/* default.debug */.Z.debug("get backgrounds started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let backgrounds = [];

  for (const background of data) {
    logger/* default.debug */.Z.debug(`${background.name} background parsing started...`);
    const parsedBackground = await buildBackground(background);
    backgrounds.push(parsedBackground);
  }

  const itemHandler = await DDBItemImporter/* default.buildHandler */.Z.buildHandler("backgrounds", backgrounds, updateBool, { chrisPremades: true });
  return itemHandler.documents;
}

;// CONCATENATED MODULE: ./src/muncher/backgrounds.js
// Main module class










function getBackgroundData() {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/backgrounds`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `backgrounds-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => getBackgrounds(data.data))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function parseBackgrounds() {

  const backgroundsCompData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Backgrounds");
  await (0,checkCompendiums/* createDDBCompendium */.v)(backgroundsCompData);

  const results = await getBackgroundData();

  return results;
}

// EXTERNAL MODULE: ./src/muncher/vehicles.js + 10 modules
var vehicles = __webpack_require__(1187);
// EXTERNAL MODULE: ./src/apps/DDBSources.js
var DDBSources = __webpack_require__(5982);
// EXTERNAL MODULE: ./src/muncher/prices.js
var prices = __webpack_require__(3466);
;// CONCATENATED MODULE: ./src/apps/DDBMuncher.js
// Main module class

























class DDBMuncher extends Application {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-monsters";
    options.template = "modules/ddb-importer/handlebars/munch.hbs";
    options.resizable = false;
    options.height = "auto";
    options.width = 800;
    options.title = "MrPrimate's Muncher";
    options.classes = ["ddb-muncher", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "div", initial: "settings" }];
    return options;
  }

  /**
   * Display information when Munching
   * @param {*} note
   * @param {*} nameField
   * @param {*} monsterNote
   */
  static munchNote(note, nameField = false, monsterNote = false) {
    if (nameField) {
      $("#munching-task-name").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    } else if (monsterNote) {
      $("#munching-task-monster").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    } else {
      $("#munching-task-notes").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    }
  }

  static munchMonsters() {
    DDBMuncher.munchNote(`Downloading monsters...`, true);
    $('button[id^="munch-"]').prop('disabled', true);
    $('button[id^="adventure-config-start"]').prop('disabled', true);
    DDBMuncher.parseCritters();
  }

  static munchVehicles() {
    DDBMuncher.munchNote(`Downloading vehicles...`, true);
    $('button[id^="munch-"]').prop('disabled', true);
    $('button[id^="adventure-config-start"]').prop('disabled', true);
    DDBMuncher.parseTransports();
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#munch-monsters-start").click(async () => {
      DDBMuncher.munchMonsters();
    });
    html.find("#munch-vehicles-start").click(async () => {
      DDBMuncher.munchVehicles();
    });
    html.find("#munch-source-select").click(async () => {
      new DDBSources/* default */.Z().render(true);
    });

    html.find("#munch-spells-start").click(async () => {
      DDBMuncher.munchNote(`Downloading spells...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseSpells();
    });
    html.find("#munch-items-start").click(async () => {
      DDBMuncher.munchNote(`Downloading items...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseItems();
    });
    html.find("#munch-races-start").click(async () => {
      DDBMuncher.munchNote(`Downloading races...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseRaces();
    });
    html.find("#munch-feats-start").click(async () => {
      DDBMuncher.munchNote(`Downloading feats...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseFeats();
    });
    html.find("#munch-backgrounds-start").click(async () => {
      DDBMuncher.munchNote(`Downloading backgrounds...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseBackgrounds();
    });
    html.find("#munch-classes-start").click(async () => {
      DDBMuncher.munchNote(`Downloading classes...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseClasses();
    });
    html.find("#munch-frames-start").click(async () => {
      DDBMuncher.munchNote(`Downloading frames...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.parseFrames();
    });
    html.find("#munch-adventure-config-start").click(async () => {
      DDBMuncher.munchNote(`Generating config file...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.generateAdventureConfig();
    });
    html.find("#munch-adventure-import-start").click(async () => {
      new AdventureMunch().render(true);
    });
    html.find("#munch-adventure-third-party-start").click(async () => {
      new ThirdPartyMunch().render(true);
    });
    html.find("#munch-migrate-compendium-monster").click(async () => {
      DDBMuncher.munchNote(`Migrating monster compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("monsters");
    });
    html.find("#munch-migrate-compendium-spell").click(async () => {
      DDBMuncher.munchNote(`Migrating spell compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("spells");
    });
    html.find("#munch-migrate-compendium-item").click(async () => {
      DDBMuncher.munchNote(`Migrating item compendium...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.migrateCompendiumFolders("items");
    });
    html.find("#munch-fix-base64").click(async () => {
      DDBMuncher.munchNote(`Checking Scenes for base64 data...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.base64Check();
    });
    html.find("#munch-world-monster-update").click(async () => {
      DDBMuncher.munchNote(`Updating world actors...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.updateWorldMonsters();
    });
    html.find("#munch-reset-images").click(async () => {
      DDBMuncher.munchNote(`Resetting images...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.resetCompendiumActorImages();
    });
    html.find("#munch-xanthar-price").click(async () => {
      DDBMuncher.munchNote(`Updating item prices...`, true);
      $('button[id^="munch-"]').prop('disabled', true);
      DDBMuncher.addItemPrices();
    });

    // watch the change of the import-policy-selector checkboxes
    $(html)
      .find(
        [
          '.munching-generic-config input[type="checkbox"]',
          '.munching-spell-config input[type="checkbox"]',
          '.munching-item-config input[type="checkbox"]',
          '.munching-monster-config input[type="checkbox"]',
          '.munching-monster-world-update-config input[type="checkbox"]',
        ].join(",")
      )
      .on("change", (event) => {
        MuncherSettings/* default.updateMuncherSettings */.Z.updateMuncherSettings(html, event, this);
      });


    html.find("#monster-munch-filter").on("keyup", (event) => {
      event.preventDefault();
      if (event.key !== "Enter") return; // Use `.key` instead.
      DDBMuncher.munchMonsters();
    });

    // compendium style migrations
    html.find("#compendium-folder-style-monster").on("change", async () => {
      const style = html.find("#compendium-folder-style-monster");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "TYPE";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-monster", importStyle);
    });
    html.find("#compendium-folder-style-spell").on("change", async () => {
      const style = html.find("#compendium-folder-style-spell");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "SCHOOL";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-spell", importStyle);
    });
    html.find("#compendium-folder-style-item").on("change", async () => {
      const style = html.find("#compendium-folder-style-item");
      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : "TYPE";
      game.settings.set("ddb-importer", "munching-selection-compendium-folders-item", importStyle);
    });

    this.close();
  }

  static enableButtons() {
    const cobalt = (0,Secrets/* getCobalt */.HF)() != "";
    const tier = PatreonHelper/* default.getPatreonTier */.Z.getPatreonTier();
    const tiers = PatreonHelper/* default.calculateAccessMatrix */.Z.calculateAccessMatrix(tier);

    if (cobalt) {
      $('button[id^="munch-spells-start"]').prop('disabled', false);
      $('button[id^="munch-items-start"]').prop('disabled', false);
      $('button[id^="munch-adventure-config-start"]').prop('disabled', false);
      $('button[id^="munch-adventure-import-start"]').prop('disabled', false);
      $('button[id^="munch-adventure-third-party-start"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-monster"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-spell"]').prop('disabled', false);
      $('button[id^="munch-migrate-compendium-item"]').prop('disabled', false);
      $('button[id^="munch-fix-base64"]').prop('disabled', false);
      $('button[id^="munch-reset-images"]').prop('disabled', false);
      $('button[id^="munch-xanthar-price"]').prop('disabled', false);

      if (tiers.all) {
        $('button[id^="munch-monsters-start"]').prop('disabled', false);
        $('button[id^="munch-source-select"]').prop('disabled', false);
      }
      if (tiers.supporter) {
        $('button[id^="munch-races-start"]').prop('disabled', false);
        $('button[id^="munch-feats-start"]').prop('disabled', false);
        $('button[id^="munch-frames-start"]').prop('disabled', false);
        $('button[id^="munch-classes-start"]').prop('disabled', false);
        $('button[id^="munch-backgrounds-start"]').prop('disabled', false);
      }
      if (tiers.experimentalMid) {
        $('button[id^="munch-vehicles-start"]').prop('disabled', false);
      }
    }
  }

  static async parseCritters() {
    try {
      logger/* default.info */.Z.info("Munching monsters!");
      // await DDBMuncher.generateCompendiumFolders("monsters");
      await (0,DDBReferenceLinker/* importCacheLoad */.uB)();
      const monsterFactory = new DDBMonsterFactory/* default */.Z({ munchNote: DDBMuncher.munchNote });
      const result = await monsterFactory.processIntoCompendium();
      await DDBMuncher.cleanupCompendiumFolders("monsters");
      DDBMuncher.munchNote(`Finished importing ${result} monsters!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseTransports() {
    try {
      logger/* default.info */.Z.info("Munching vehicles!");
      const result = await (0,vehicles/* parseTransports */.b)();
      DDBMuncher.munchNote(`Finished importing ${result} vehicles!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseSpells() {
    try {
      logger/* default.info */.Z.info("Munching spells!");
      if (game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-add-spell-effects")) {
        await DDBMacros/* default.createWorldMacros */.Z.createWorldMacros("spells");
      }
      await (0,DDBReferenceLinker/* importCacheLoad */.uB)();
      await (0,spells/* parseSpells */.Z)();
      await DDBMuncher.cleanupCompendiumFolders("spells");
      DDBMuncher.munchNote(`Finished importing spells!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async cleanupCompendiumFolders(type) {
    const compendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z(type);
    DDBMuncher.munchNote(`Cleaning compendium folders...`, true);
    await compendiumFolders.loadCompendium(type);
    await compendiumFolders.removeUnusedFolders();
    DDBMuncher.munchNote(`Cleaning compendium folders complete`, true);
  }

  static async generateCompendiumFolders(type) {
    const compendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z(type);
    DDBMuncher.munchNote(`Checking compendium folders..`, true);
    await compendiumFolders.loadCompendium(type);
    DDBMuncher.munchNote("", true);
  }

  static async parseItems() {
    try {
      logger/* default.info */.Z.info("Munching items!");
      // await DDBMuncher.generateCompendiumFolders("items");
      await (0,DDBReferenceLinker/* importCacheLoad */.uB)();
      await (0,items/* parseItems */.S)();
      await DDBMuncher.cleanupCompendiumFolders("items");
      DDBMuncher.munchNote(`Finished importing items!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseRaces() {
    try {
      logger/* default.info */.Z.info("Munching races!");
      await (0,DDBReferenceLinker/* importCacheLoad */.uB)();
      const result = await parseRaces();
      DDBMuncher.munchNote(`Finished importing ${result.length} races and features!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseFeats() {
    try {
      logger/* default.info */.Z.info("Munching feats!");
      await (0,DDBReferenceLinker/* importCacheLoad */.uB)();
      const result = await parseFeats();
      DDBMuncher.munchNote(`Finished importing ${result.length} feats!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseBackgrounds() {
    try {
      logger/* default.info */.Z.info("Munching backgrounds!");
      await (0,DDBReferenceLinker/* importCacheLoad */.uB)();
      const result = await parseBackgrounds();
      DDBMuncher.munchNote(`Finished importing ${result.length} backgrounds!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseClasses() {
    try {
      logger/* default.info */.Z.info("Munching classes!");
      await (0,DDBReferenceLinker/* importCacheLoad */.uB)();
      const result = await parseClasses();
      DDBMuncher.munchNote(`Finished importing ${result.length} classes and features!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async parseFrames() {
    try {
      logger/* default.info */.Z.info("Munching frames!");
      const result = await parseFrames();
      DDBMuncher.munchNote(`Finished importing ${result.length} frames!`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async generateAdventureConfig() {
    try {
      logger/* default.info */.Z.info("Generating adventure config!");
      await (0,adventure/* downloadAdventureConfig */.T)();
      DDBMuncher.munchNote(`Downloading config file`, true);
      DDBMuncher.munchNote("");
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async updateWorldMonsters() {
    try {
      logger/* default.info */.Z.info("Updating world monsters!");
      await (0,tools/* updateWorldMonsters */.BU)();
      DDBMuncher.enableButtons();
    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
    }
  }

  static async migrateCompendiumFolders(type) {
    logger/* default.info */.Z.info(`Migrating ${type} compendium`);
    const compendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z(type);
    await compendiumFolders.loadCompendium(type);
    await compendiumFolders.migrateExistingCompendium();
    DDBMuncher.munchNote(`Migrating complete.`, true);
    DDBMuncher.enableButtons();
  }

  static async base64Check() {
    logger/* default.info */.Z.info("Checking base64 in scenes");
    const results = base64Check();
    let notifyString = `Check complete.`;
    if (results.fixedScenes.length === 0 && results.badScenes.length === 0) {
      notifyString += " No problems found.";
    } else {
      if (results.fixedScenes.length > 0) notifyString += ` Fixing ${results.fixedScenes.length} scenes (wait untill uploads complete).`;
      if (results.badScenes.length > 0) notifyString += ` Found ${results.badScenes.length} scenes that I couldn't fix.`;
    }
    DDBMuncher.munchNote(notifyString, true);
    DDBMuncher.enableButtons();
  }

  static async resetCompendiumActorImages() {
    logger/* default.info */.Z.info("Resetting compendium actor images");
    const results = await (0,tools/* resetCompendiumActorImages */.mk)();
    const notifyString = `Reset ${results.length} compendium actors.`;
    DDBMuncher.munchNote(notifyString, true);
    DDBMuncher.enableButtons();
  }

  static async addItemPrices() {
    logger/* default.info */.Z.info("Checking to see if items need prices...");
    const results = await (0,prices/* updateItemPrices */.L)();
    const notifyString = `Added ${results.length} prices to items.`;
    DDBMuncher.munchNote(notifyString, true);
    DDBMuncher.enableButtons();
  }

  async getData() { // eslint-disable-line class-methods-use-this
    const resultData = MuncherSettings/* default.getMuncherSettings */.Z.getMuncherSettings();
    await (0,DDBReferenceLinker/* importCacheLoad */.uB)();
    return resultData;
  }
}


/***/ }),

/***/ 5982:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBSources)
/* harmony export */ });
/* harmony import */ var _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2449);


class DDBSources extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-sources";
    options.template = "modules/ddb-importer/handlebars/sources.hbs";
    options.width = 500;
    return options;
  }

  static getSourcesLookups(selected) {
    const selections = CONFIG.DDB.sources
      .filter((source) => source.isReleased && source.sourceCategoryId !== 9 && source.sourceCategoryId !== 3)
      .map((source) => {
        const details = {
          id: source.id,
          acronym: source.name,
          label: source.description,
          selected: selected.includes(source.id),
        };
        return details;
      });

    return selections;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "Monster Muncher Sauce Selection";
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find("#toggle-sources").click(async (event) => {
      event.preventDefault();
      if ($('.munching-sources input:checked').length && $('.munching-sources input').not(':checked').length) {
        $('.munching-sources input').prop('checked', false);
      } else {
        $('.munching-sources input').each(function() {
          // eslint-disable-next-line no-invalid-this
          $(this).prop('checked', !$(this).prop('checked'));
        });
      }
    });
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const existingSelection = game.settings.get("ddb-importer", "munching-policy-muncher-sources").flat();
    const sources = DDBSources.getSourcesLookups(existingSelection);

    return {
      sources: sources.sort((a, b) => {
        return (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0);
      }),
    };
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async _updateObject(event, formData) {
    event.preventDefault();
    let sources = [];
    for (const [key, value] of Object.entries(formData)) {
      if (value) sources.push(parseInt(key));
    }
    await game.settings.set("ddb-importer", "munching-policy-muncher-sources", sources);
    // eslint-disable-next-line no-use-before-define
    new _DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z().render(true);
  }
}


/***/ }),

/***/ 37:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const DICTIONARY = {
  types: {
    full: ["weapon", "equipment", "consumable", "tool", "loot", "class", "subclass", "background", "spell", "feat", "container"],
    equipment: ["equipment", "consumable", "tool", "loot", "container"],
    inventory: ["equipment", "consumable", "tool", "loot", "container", "weapon"],
    monster: ["equipment", "consumable", "tool", "loot", "container", "weapon", "feat"],
  },
  currency: {
    cp: "copper",
    sp: "silver",
    ep: "electrum",
    gp: "gold",
    pp: "platinum",
  },
  sizes: [
    { name: "Tiny", value: "tiny", size: 0.5 },
    { name: "Small", value: "sm", size: 0.8 },
    { name: "Medium", value: "med", size: 1 },
    { name: "Large", value: "lg", size: 2 },
    { name: "Huge", value: "huge", size: 3 },
    { name: "Gargantuan", value: "grg", size: 4 },
  ],
  numbers: [
    { num: 1, natural: "a" },
    { num: 1, natural: "a new" },
    { num: 1, natural: "one" },
    { num: 2, natural: "two" },
    { num: 3, natural: "three" },
    { num: 4, natural: "four" },
    { num: 5, natural: "five" },
    { num: 6, natural: "six" },
    { num: 7, natural: "seven" },
    { num: 8, natural: "eight" },
    { num: 9, natural: "nine" },
    { num: 10, natural: "ten" },
    { num: 11, natural: "eleven" },
    { num: 12, natural: "twelve" },
    { num: 13, natural: "thirteen" },
    { num: 14, natural: "fourteen" },
    { num: 15, natural: "fifteen" },
    { num: 16, natural: "sixteen" },
    { num: 17, natural: "seventeen" },
    { num: 18, natural: "eighteen" },
    { num: 19, natural: "nineteen" },
    { num: 20, natural: "twenty" },
  ],
  magicitems: {
    rechargeUnits: [
      { id: 1, value: "r4" },
      { id: "ShortRest", value: "r4" },
      { id: 2, value: "r5" },
      { id: "LongRest", value: "r5" },
      { id: "Long", value: "r5" },
      { id: "long", value: "r5" },
      { id: "Dawn", value: "r2" },
      { id: "dawn", value: "r2" },
      { id: "Day", value: "r2" },
      { id: "day", value: "r2" },
      { id: "daily", value: "r1" },
      { id: "DawnRest", value: "r2" },
      { id: "Dusk", value: "r3" },
      { id: "dusk", value: "r3" },
      { id: "DuskRest", value: "r3" },
      { id: "Sunset", value: "r3" },
      { id: "Consumable", value: "" },
      { id: "Other", value: "" },
      { id: "Daily", value: "r1" },
      { id: "sr", value: "r4" },
      { id: "lr", value: "r5" },
      { id: "", value: "" },
      { id: null, value: "" },
      { id: 3, value: "r2" },
      { id: 4, value: "" },
    ],
    nums: [
      { id: "once", value: 1 },
      { id: "twice", value: 2 },
      { id: "thrice", value: 3 },
      { id: "one", value: 1 },
      { id: "two", value: 2 },
      { id: "three", value: 3 },
    ],
  },
  resets: [
    { id: 1, value: "sr" },
    { id: "ShortRest", value: "sr" },
    { id: "Short", value: "sr" },
    { id: "short", value: "sr" },
    { id: 2, value: "lr" },
    { id: "LongRest", value: "lr" },
    { id: "Long", value: "lr" },
    { id: "long", value: "lr" },
    { id: "Day", value: "day" },
    { id: "day", value: "day" },
    { id: "Dawn", value: "dawn" },
    { id: "dusk", value: "dusk" },
    { id: "Consumable", value: "charges" },
    { id: "Other", value: "charges" },
    { id: "", value: "" },
    { id: null, value: "" },
    { id: 3, value: "day" },
    { id: 4, value: "charges" },
  ],
  // CONFIG.Canvas.visionModes
  senseMapDefault: {
    blindsight: "basic",
    darkvision: "darkvision",
    // tremorsense: "tremorsense",
    truesight: "basic",
    unknown: "basic",
  },
  senseMapVision5e: {
    blindsight: "blindsight",
    darkvision: "darkvision",
    tremorsense: "tremorsense",
    truesight: "truesight",
    unknown: "basic"
  },
  senseMap: () => {
    if (game.modules.get("vision-5e")?.active) return DICTIONARY.senseMapVision5e;
    return DICTIONARY.senseMapDefault;
  },
  // CONFIG.Canvas.detectionModes
  detectionMap: {
    blindsight: "senseAll",
    truesight: "seeAll",
    tremorsense: "feelTremor",
  },
  conditions: [
    { label: "Blinded", foundry: "blinded", ddbId: 1, levelId: null, ddbType: 1 },
    { label: "Charmed", foundry: "charmed", ddbId: 2, levelId: null, ddbType: 1 },
    { label: "Deafened", foundry: "deafened", ddbId: 3, levelId: null, ddbType: 1 },
    { label: "Exhaustion", foundry: "exhaustion", ddbId: null, levelId: null, ddbType: null },
    { label: "Exhaustion 1", foundry: "exhaustion", ddbId: 4, levelId: 1, ddbType: 2 },
    { label: "Exhaustion 2", foundry: "exhaustion", ddbId: 4, levelId: 2, ddbType: 2 },
    { label: "Exhaustion 3", foundry: "exhaustion", ddbId: 4, levelId: 3, ddbType: 2 },
    { label: "Exhaustion 4", foundry: "exhaustion", ddbId: 4, levelId: 4, ddbType: 2 },
    { label: "Exhaustion 5", foundry: "exhaustion", ddbId: 4, levelId: 5, ddbType: 2 },
    { label: "Exhaustion 6", foundry: "exhaustion", ddbId: 4, levelId: 6, ddbType: 2 },
    { label: "Frightened", foundry: "frightened", ddbId: 5, levelId: null, ddbType: 1 },
    { label: "Grappled", foundry: "grappled", ddbId: 6, levelId: null, ddbType: 1 },
    { label: "Incapacitated", foundry: "incapacitated", ddbId: 7, levelId: null, ddbType: 1 },
    { label: "Invisible", foundry: "invisible", ddbId: 8, levelId: null, ddbType: 1 },
    { label: "Paralyzed", foundry: "paralyzed", ddbId: 9, levelId: null, ddbType: 1 },
    { label: "Petrified", foundry: "petrified", ddbId: 10, levelId: null, ddbType: 1 },
    { label: "Poisoned", foundry: "poisoned", ddbId: 11, levelId: null, ddbType: 1 },
    { label: "Prone", foundry: "prone", ddbId: 12, levelId: null, ddbType: 1 },
    { label: "Restrained", foundry: "restrained", ddbId: 13, levelId: null, ddbType: 1 },
    { label: "Stunned", foundry: "stunned", ddbId: 14, levelId: null, ddbType: 1 },
    { label: "Unconscious", foundry: "unconscious", ddbId: 15, levelId: null, ddbType: 1 },
    { label: "Diseased", foundry: "diseased", ddbId: null, levelId: null, ddbType: null },
    { label: "Disease", foundry: "diseased", ddbId: null, levelId: null, ddbType: null },
  ],
  character: {
    class: [
      { name: "Artificer", multiclassSkill: 0 },
      { name: "Bard", multiclassSkill: 1 },
      { name: "Barbarian", multiclassSkill: 0 },
      { name: "Blood Hunter", multiclassSkill: 0 },
      { name: "Blood Hunter (archived)", multiclassSkill: 0 },
      { name: "Cleric", multiclassSkill: 0 },
      { name: "Druid", multiclassSkill: 0 },
      { name: "Fighter", multiclassSkill: 0 },
      { name: "Hunter", multiclassSkill: 0 },
      { name: "Paladin", multiclassSkill: 0 },
      { name: "Ranger", multiclassSkill: 1 },
      { name: "Rogue", multiclassSkill: 1 },
      { name: "Sorcerer", multiclassSkill: 0 },
      { name: "Warlock", multiclassSkill: 0 },
      { name: "Wizard", multiclassSkill: 0 },
      { name: "Monk", multiclassSkill: 0 },
    ],
    abilities: [
      { id: 1, value: "str", long: "strength" },
      { id: 2, value: "dex", long: "dexterity" },
      { id: 3, value: "con", long: "constitution" },
      { id: 4, value: "int", long: "intelligence" },
      { id: 5, value: "wis", long: "wisdom" },
      { id: 6, value: "cha", long: "charisma" },
    ],
    skills: [
      { name: "acr", label: "Acrobatics", ability: "dex", subType: "acrobatics", valueId: 3 },
      { name: "ani", label: "Animal Handling", ability: "wis", subType: "animal-handling", valueId: 11 },
      { name: "arc", label: "Arcana", ability: "int", subType: "arcana", valueId: 6 },
      { name: "ath", label: "Athletics", ability: "str", subType: "athletics", valueId: 2 },
      { name: "dec", label: "Deception", ability: "cha", subType: "deception", valueId: 16 },
      { name: "his", label: "History", ability: "int", subType: "history", valueId: 7 },
      { name: "ins", label: "Insight", ability: "wis", subType: "insight", valueId: 12 },
      { name: "itm", label: "Intimidation", ability: "cha", subType: "intimidation", valueId: 17 },
      { name: "inv", label: "Investigation", ability: "int", subType: "investigation", valueId: 8 },
      { name: "med", label: "Medicine", ability: "wis", subType: "medicine", valueId: 13 },
      { name: "nat", label: "Nature", ability: "int", subType: "nature", valueId: 9 },
      { name: "prc", label: "Perception", ability: "wis", subType: "perception", valueId: 14 },
      { name: "prf", label: "Performance", ability: "cha", subType: "performance", valueId: 18 },
      { name: "per", label: "Persuasion", ability: "cha", subType: "persuasion", valueId: 19 },
      { name: "rel", label: "Religion", ability: "int", subType: "religion", valueId: 10 },
      { name: "slt", label: "Sleight of Hand", ability: "dex", subType: "sleight-of-hand", valueId: 4 },
      { name: "ste", label: "Stealth", ability: "dex", subType: "stealth", valueId: 5 },
      { name: "sur", label: "Survival", ability: "wis", subType: "survival", valueId: 15 },
    ],
    customSkillProficiencies: [
      // typeId:26
      // value not: 1, half 2, prof: 3, expertise 4
      { value: 1, proficient: 0 },
      { value: 2, proficient: 0.5 },
      { value: 3, proficient: 1 },
      { value: 4, proficient: 2 },
    ],
    alignments: [
      { id: 1, name: "Lawful Good", value: "lg" },
      { id: 2, name: "Neutral Good", value: "ng" },
      { id: 3, name: "Chaotic Good", value: "cg" },
      { id: 4, name: "Lawful Neutral", value: "ln" },
      { id: 5, name: "True Neutral", value: "tn" },
      { id: 6, name: "Chaotic Neutral", value: "cn" },
      { id: 7, name: "Lawful Evil", value: "le" },
      { id: 8, name: "Neutral Evil", value: "ne" },
      { id: 9, name: "Chaotic Evil", value: "ce" },
    ],
    actorSizes: [
      { id: 2, name: "Tiny", value: "tiny" },
      { id: 3, name: "Small", value: "sm" },
      { id: 4, name: "Medium", value: "med" },
      { id: 5, name: "Large", value: "lg" },
      { id: 6, name: "Huge", value: "huge" },
      { id: 7, name: "Gargantuan", value: "grg" },
      // { id: 10, entityTypeId: 127108918, name: "Medium or Small", weightType: 2 },
    ],
    senses: [
      { id: 1, name: "Blindsight" },
      { id: 2, name: "Darkvision" },
      { id: 3, name: "Tremorsense" },
    ],
    speeds: [
      { id: 1, type: "walk", innate: "walking" },
      { id: 2, type: "burrow", innate: "burrowing" },
      { id: 3, type: "climb", innate: "climbing" },
      { id: 4, type: "fly", innate: "flying" },
      { id: 5, type: "swim", innate: "swimming" },
    ],
    languages: [
      { name: "Common", value: "common", type: "standard" },
      { name: "Aarakocra", value: "aarakocra", advancement: "exotic" },
      { name: "Abyssal", value: "abyssal", advancement: "exotic" },
      { name: "Aquan", value: "aquan", advancement: "exotic:primordial" },
      { name: "Auran", value: "auran", advancement: "exotic:primordial" },
      { name: "Celestial", value: "celestial", advancement: "exotic" },
      { name: "Deep Speech", value: "deep", advancement: "exotic" },
      { name: "Draconic", value: "draconic", advancement: "exotic" },
      { name: "Druidic", value: "druidic", advancement: null },
      { name: "Dwarvish", value: "dwarvish", advancement: "standard" },
      { name: "Elvish", value: "elvish", advancement: "standard" },
      { name: "Giant", value: "giant", advancement: "standard" },
      { name: "Gith", value: "gith", advancement: "exotic" },
      { name: "Gnomish", value: "gnomish", advancement: "standard" },
      { name: "Goblin", value: "goblin", advancement: "standard" },
      { name: "Gnoll", value: "gnoll", advancement: "exotic" },
      { name: "Halfling", value: "halfling", advancement: "standard" },
      { name: "Ignan", value: "ignan", advancement: "exotic:primordial" },
      { name: "Infernal", value: "infernal", advancement: "exotic" },
      { name: "Orc", value: "orc", advancement: "standard" },
      { name: "Primordial", value: "primordial", advancement: "exotic" },
      { name: "Terran", value: "terran", advancement: "exotic:primordial" },
      { name: "Sylvan", value: "sylvan", advancement: "exotic" },
      { name: "Thieves' Cant", value: "cant", advancement: null },
      { name: "Thieves Cant", value: "cant", advancement: null },
      { name: "Undercommon", value: "undercommon", advancement: "exotic" },
    ],
    armorTypes: [
      { name: "Clothing", value: "clothing" },
      { name: "Light Armor", value: "light" },
      { name: "Medium Armor", value: "medium" },
      { name: "Heavy Armor", value: "heavy" },
      { name: "Magical Bonus", value: "bonus" },
      { name: "Natural Armor", value: "natural" },
      { name: "Shield", value: "shield" },
    ],
    damageAdjustments: [
      { id: 1, type: 1, kind: "resistance", name: "Bludgeoning", foundryValues: { value: ["bludgeoning"], bypass: [] } },
      { id: 2, type: 1, kind: "resistance", name: "Piercing", foundryValues: { value: ["piercing"], bypass: [] } },
      { id: 3, type: 1, kind: "resistance", name: "Slashing", foundryValues: { value: ["slashing"], bypass: [] } },
      { id: 4, type: 1, kind: "resistance", name: "Lightning", foundryValues: { value: ["lightning"], bypass: [] } },
      { id: 5, type: 1, kind: "resistance", name: "Thunder", foundryValues: { value: ["thunder"], bypass: [] } },
      { id: 6, type: 1, kind: "resistance", name: "Poison", foundryValues: { value: ["poison"], bypass: [] } },
      { id: 7, type: 1, kind: "resistance", name: "Cold", foundryValues: { value: ["cold"], bypass: [] } },
      { id: 8, type: 1, kind: "resistance", name: "Radiant", foundryValues: { value: ["radiant"], bypass: [] } },
      { id: 9, type: 1, kind: "resistance", name: "Fire", foundryValues: { value: ["fire"], bypass: [] } },
      { id: 10, type: 1, kind: "resistance", name: "Necrotic", foundryValues: { value: ["necrotic"], bypass: [] } },
      { id: 11, type: 1, kind: "resistance", name: "Acid", foundryValues: { value: ["acid"], bypass: [] } },
      { id: 12, type: 1, kind: "resistance", name: "Psychic", foundryValues: { value: ["psychic"], bypass: [] } },
      { id: 13, type: 1, kind: "resistance", name: "Physical (Magical)", foundryValues: { value: ["bludgeoning", "piercing", "slashing"], bypass: ["mgc"] } },
      { id: 14, type: 1, kind: "resistance", name: "Physical (Silvered)", foundryValues: { value: ["bludgeoning", "piercing", "slashing"], bypass: ["mgc", "sil"] } },
      { id: 15, type: 1, kind: "resistance", name: "Physical (Adamantine)", foundryValues: { value: ["bludgeoning", "piercing", "slashing"], bypass: ["mgc", "ada"] } },
      { id: 16, type: 1, kind: "resistance", name: "Piercing and Slashing from Nonmagical Attacks that aren't Adamantine", foundryValues: { value: ["piercing", "slashing"], bypass: ["mgc", "ada"] } },
      { id: 17, type: 2, kind: "immunity", name: "Bludgeoning", foundryValues: { value: ["bludgeoning"], bypass: [] } },
      { id: 18, type: 2, kind: "immunity", name: "Piercing", foundryValues: { value: ["piercing"], bypass: [] } },
      { id: 19, type: 2, kind: "immunity", name: "Slashing", foundryValues: { value: ["slashing"], bypass: [] } },
      { id: 20, type: 2, kind: "immunity", name: "Lightning", foundryValues: { value: ["lightning"], bypass: [] } },
      { id: 21, type: 2, kind: "immunity", name: "Thunder", foundryValues: { value: ["thunder"], bypass: [] } },
      { id: 22, type: 2, kind: "immunity", name: "Poison", foundryValues: { value: ["poison"], bypass: [] } },
      { id: 23, type: 2, kind: "immunity", name: "Cold", foundryValues: { value: ["cold"], bypass: [] } },
      { id: 24, type: 2, kind: "immunity", name: "Radiant", foundryValues: { value: ["radiant"], bypass: [] } },
      { id: 25, type: 2, kind: "immunity", name: "Fire", foundryValues: { value: ["fire"], bypass: [] } },
      { id: 26, type: 2, kind: "immunity", name: "Necrotic", foundryValues: { value: ["necrotic"], bypass: [] } },
      { id: 27, type: 2, kind: "immunity", name: "Acid", foundryValues: { value: ["acid"], bypass: [] } },
      { id: 28, type: 2, kind: "immunity", name: "Psychic", foundryValues: { value: ["psychic"], bypass: [] } },
      { id: 29, type: 2, kind: "immunity", name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks", foundryValue: "physical", foundryValues: { value: ["bludgeoning", "piercing", "slashing"], bypass: ["mgc"] } },
      { id: 30, type: 2, kind: "immunity", name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Silvered", foundryValue: "physical", foundryValues: { value: ["bludgeoning", "piercing", "slashing"], bypass: ["mgc", "sil"] } },
      { id: 31, type: 2, kind: "immunity", name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Adamantine", foundryValue: "physical", foundryValues: { value: ["bludgeoning", "piercing", "slashing"], bypass: ["mgc", "ada"] } },
      { id: 32, type: 2, kind: "immunity", name: "Piercing and Slashing from Nonmagical Attacks that aren't Adamantine", foundryValue: "physical", foundryValues: { value: ["piercing", "slashing"], bypass: ["mgc", "ada"] } },
      { id: 33, type: 3, kind: "vulnerability", name: "Bludgeoning", foundryValues: { value: ["bludgeoning"], bypass: [] } },
      { id: 34, type: 3, kind: "vulnerability", name: "Piercing", foundryValues: { value: ["piercing"], bypass: [] } },
      { id: 35, type: 3, kind: "vulnerability", name: "Slashing", foundryValues: { value: ["slashing"], bypass: [] } },
      { id: 36, type: 3, kind: "vulnerability", name: "Lightning", foundryValues: { value: ["lightning"], bypass: [] } },
      { id: 37, type: 3, kind: "vulnerability", name: "Thunder", foundryValues: { value: ["thunder"], bypass: [] } },
      { id: 38, type: 3, kind: "vulnerability", name: "Poison", foundryValues: { value: ["poison"], bypass: [] } },
      { id: 39, type: 3, kind: "vulnerability", name: "Cold", foundryValues: { value: ["cold"], bypass: [] } },
      { id: 40, type: 3, kind: "vulnerability", name: "Radiant", foundryValues: { value: ["radiant"], bypass: [] } },
      { id: 41, type: 3, kind: "vulnerability", name: "Fire", foundryValues: { value: ["fire"], bypass: [] } },
      { id: 42, type: 3, kind: "vulnerability", name: "Necrotic", foundryValues: { value: ["necrotic"], bypass: [] } },
      { id: 43, type: 3, kind: "vulnerability", name: "Acid", foundryValues: { value: ["acid"], bypass: [] } },
      { id: 44, type: 3, kind: "vulnerability", name: "Psychic", foundryValues: { value: ["psychic"], bypass: [] } },

      { id: 45, type: 3, kind: "vulnerability", name: "Piercing from Magic Weapons Wielded by Good Creatures", value: "piercing-from-magic-weapons-wielded-by-good" },
      { id: 46, type: 3, kind: "vulnerability", name: "Bludgeoning, Piercing, and Slashing from Magic Weapons", value: "bludgeoning-piercing-and-slashing-from-magic-weapons" },

      { id: 47, type: 1, kind: "resistance", name: "Force", foundryValues: { value: ["force"], bypass: [] } },
      { id: 48, type: 2, kind: "immunity", name: "Force", foundryValues: { value: ["force"], bypass: [] } },
      { id: 49, type: 3, kind: "vulnerability", name: "Force", foundryValues: { value: ["force"], bypass: [] } },

      { id: 51, type: 1, kind: "resistance", name: "Ranged attacks", values: "ranged-attacks" },
      { id: 52, type: 1, kind: "resistance", name: "Damage dealt by traps", values: "damage-dealt-by-traps" },
      { id: 54, type: 1, kind: "resistance", name: "Bludgeoning from non magical attacks", foundryValues: { value: ["bludgeoning"], bypass: ["mgc"] } },

      { id: 55, type: 2, kind: "immunity", name: "Bludgeoning, Piercing, and Slashing from Metal Weapons", foundryValues: { value: ["bludgeoning", "piercing", "slashing"], bypass: [] } },
      { id: 56, type: 1, kind: "resistance", name: "Bludgeoning, Piercing, and Slashing while in Dim Light or Darkness", value: "bludgeoning-piercing-and-slashing-while-in-dim-or-light-darkness" },
      { id: 57, type: 1, kind: "resistance", name: "Damage from Spells", values: "damage-from-spells", midiValues: ["spells"] },
      { id: 60, type: 2, kind: "immunity", name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Adamantine or Silvered", foundryValues: { value: ["slashing", "bludgeoning", "piercing"], bypass: ["ada", "sil", "mgc"] } },
      { id: 61, type: 1, kind: "resistance", name: "Nonmagical Bludgeoning, Piercing, and Slashing (from Stoneskin)", foundryValues: { value: ["bludgeoning", "piercing", "slashing"], bypass: ["mgc"] } },
      { id: 62, type: 1, kind: "resistance", name: "All damage but Force, Radiant, and Psychic", foundryValues: { value: ["bludgeoning", "piercing", "slashing", "lightning", "thunder", "cold", "fire", "necrotic", "acid", "poison"], bypass: [] } },
      { id: 63, type: 2, kind: "immunity", name: "Petrified (Aberrant Armor Only)", value: "petrified-aberrant-armor-only" },
      { id: 64, type: 1, kind: "vulnerability", name: "Slashing from a Vorpal Sword", value: "slashing-from-a-vorpal-sword", },
      { id: 65, type: 1, kind: "resistance", name: "Damage of the type matching the animated breath's form (acid, cold, fire, lightning, or poison)", value: "damage-of-the-type-matching-the-animated-breaths-form-acid-cold-fire-lightning-or-poison" },
      { id: 66, type: 1, kind: "resistance", name: "Psychic (granted by Ruidium Armor)", foundryValues: { value: ["psychic"], bypass: [] } },
      { id: 67, type: 2, kind: "immunity", name: "Bludgeoning, Piercing, and Slashing that is Nonmagical", foundryValues: { value: ["slashing", "bludgeoning", "piercing"], bypass: ["mgc"] } },
      { id: 68, type: 1, kind: "resistance", name: "One of the following: acid, cold, fire, lightning, or poison", value: "one-of-the-following-acid-cold-fire-lightning-or" },
      { id: 69, type: 1, kind: "resistance", name: "Lightning (granted by darksteel greataxe)", foundryValues: { value: ["lightning"], bypass: [] } },
      { id: 70, type: 1, kind: "resistance", name: "Slashing and Piercing from Nonmagical Attacks", foundryValues: { value: ["slashing", "piercing"], bypass: ["mgc"] } },

      // condition immunities
      { id: 1, type: 4, kind: "immunity", name: "Blinded", foundryValue: "blinded" },
      { id: 2, type: 4, kind: "immunity", name: "Charmed", foundryValue: "charmed" },
      { id: 3, type: 4, kind: "immunity", name: "Deafened", foundryValue: "deafened" },
      { id: 4, type: 4, kind: "immunity", name: "Exhaustion", foundryValue: "exhaustion" },
      { id: 5, type: 4, kind: "immunity", name: "Frightened", foundryValue: "frightened" },
      { id: 6, type: 4, kind: "immunity", name: "Grappled", foundryValue: "grappled" },
      { id: 7, type: 4, kind: "immunity", name: "Incapacitated", foundryValue: "incapacitated" },
      { id: 8, type: 4, kind: "immunity", name: "Invisible", foundryValue: "invisible" },
      { id: 9, type: 4, kind: "immunity", name: "Paralyzed", foundryValue: "paralyzed" },
      { id: 10, type: 4, kind: "immunity", name: "Petrified", foundryValue: "petrified" },
      { id: 11, type: 4, kind: "immunity", name: "Poisoned", foundryValue: "poisoned" },
      { id: 12, type: 4, kind: "immunity", name: "Prone", foundryValue: "prone" },
      { id: 13, type: 4, kind: "immunity", name: "Restrained", foundryValue: "restrained" },
      { id: 14, type: 4, kind: "immunity", name: "Stunned", foundryValue: "stunned" },
      { id: 15, type: 4, kind: "immunity", name: "Unconscious", foundryValue: "unconscious" },
      // In DDB it is disease, but in FVTT ut is diseased
      { id: 16, type: 4, kind: "immunity", name: "Diseased", value: "disease", foundryValue: "diseased" },
    ],
    proficiencies: [
      // Armor
      { name: "All armor", type: "Armor", subType: null, foundryValue: "all", advancement: "" },
      { name: "Light Armor", type: "Armor", subType: "Light Armor", foundryValue: "lgt", advancement: "" },
      { name: "Medium Armor", type: "Armor", subType: "Medium Armor", foundryValue: "med", advancement: "" },
      { name: "Heavy Armor", type: "Armor", subType: "Heavy Armor", foundryValue: "hvy", advancement: "" },
      { name: "Shields", type: "Armor", subType: "Shield", foundryValue: "shl", advancement: "" },
      { name: "Studded Leather", type: "Armor", subType: "Light Armor", foundryValue: "studded", advancement: "lgt" },
      { name: "Scale Mail", type: "Armor", subType: "Medium Armor", foundryValue: "scalemail", advancement: "med" },
      { name: "Shield", type: "Armor", subType: "Shield", foundryValue: "shield", advancement: "shl" },
      { name: "Padded", type: "Armor", subType: "Light Armor", foundryValue: "padded", advancement: "lgt" },
      { name: "Leather", type: "Armor", subType: "Light Armor", foundryValue: "leather", advancement: "lgt" },
      { name: "Hide", type: "Armor", subType: "Medium Armor", foundryValue: "hide", advancement: "med" },
      { name: "Chain Shirt", type: "Armor", subType: "Medium Armor", foundryValue: "chainshirt", advancement: "med" },
      { name: "Breastplate", type: "Armor", subType: "Medium Armor", foundryValue: "breastplate", advancement: "med" },
      { name: "Half Plate", type: "Armor", subType: "Medium Armor", foundryValue: "halfplate", advancement: "med" },
      { name: "Ring Mail", type: "Armor", subType: "Heavy Armor", foundryValue: "ringmail", advancement: "hvy" },
      { name: "Chain Mail", type: "Armor", subType: "Heavy Armor", foundryValue: "chainmail", advancement: "hvy" },
      { name: "Splint", type: "Armor", subType: "Heavy Armor", foundryValue: "splint", advancement: "hvy" },
      { name: "Plate", type: "Armor", subType: "Heavy Armor", foundryValue: "plate", advancement: "hvy" },
      { name: "Spiked Armor", type: "Armor", subType: "Medium Armor", advancement: "med" },

      // Weapon Groups
      { name: "Simple Weapons", type: "Weapon", subType: "Simple Weapons", foundryValue: "sim", advancement: "" },
      { name: "Martial Weapons", type: "Weapon", subType: "Martial Weapons", foundryValue: "mar", advancement: "" },
      // Simple Weapons
      { name: "Boomerang", type: "Weapon", subType: "Simple Weapon", foundryValue: "", advancement: "sim", melee: false, ranged: true, properties: { ret: true } },
      { name: "Club", type: "Weapon", subType: "Simple Weapon", foundryValue: "club", advancement: "sim", melee: true, ranged: false, properties: { lgt: true } },
      { name: "Crossbow, Light", type: "Weapon", subType: "Simple Weapon", foundryValue: "lightcrossbow", advancement: "sim", melee: false, ranged: true, properties: { amm: true, lod: true, two: true } },
      { name: "Dagger", type: "Weapon", subType: "Simple Weapon", foundryValue: "dagger", advancement: "sim", melee: true, ranged: true, properties: { lgt: true, fin: true, thr: true } },
      { name: "Dart", type: "Weapon", subType: "Simple Weapon", foundryValue: "dart", advancement: "sim", melee: false, ranged: true, properties: { fin: true, thr: true } },
      { name: "Greatclub", type: "Weapon", subType: "Simple Weapon", foundryValue: "greatclub", advancement: "sim", melee: true, ranged: false, properties: { two: true } },
      { name: "Handaxe", type: "Weapon", subType: "Simple Weapon", foundryValue: "handaxe", advancement: "sim", melee: true, ranged: false, properties: { lgt: true, thr: true } },
      { name: "Javelin", type: "Weapon", subType: "Simple Weapon", foundryValue: "javelin", advancement: "sim", melee: true, ranged: true, properties: { thr: true } },
      { name: "Light Hammer", type: "Weapon", subType: "Simple Weapon", foundryValue: "lighthammer", advancement: "sim", melee: true, ranged: true, properties: { lgt: true, thr: true } },
      { name: "Mace", type: "Weapon", subType: "Simple Weapon", foundryValue: "mace", advancement: "sim", melee: true, ranged: false, properties: {} },
      { name: "Quarterstaff", type: "Weapon", subType: "Simple Weapon", foundryValue: "quarterstaff", advancement: "sim", melee: true, ranged: false, properties: { ver: true } },
      { name: "Shortbow", type: "Weapon", subType: "Simple Weapon", foundryValue: "shortbow", advancement: "sim", melee: false, ranged: true, properties: { amm: true, two: true } },
      { name: "Sickle", type: "Weapon", subType: "Simple Weapon", foundryValue: "sickle", advancement: "sim", melee: true, ranged: false, properties: { lgt: true } },
      { name: "Sling", type: "Weapon", subType: "Simple Weapon", foundryValue: "sling", advancement: "sim", melee: false, ranged: true, properties: { amm: true } },
      { name: "Spear", type: "Weapon", subType: "Simple Weapon", foundryValue: "spear", advancement: "sim", melee: true, ranged: true, properties: { thr: true, ver: true } },
      { name: "Yklwa", type: "Weapon", subType: "Simple Weapon", foundryValue: "", advancement: "sim", melee: true, ranged: false, properties: { amm: true } },
      // Martial Weapons
      { name: "Antimatter Rifle", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, two: true, fir: true } },
      { name: "Battleaxe", type: "Weapon", subType: "Martial Weapon", foundryValue: "battleaxe", advancement: "mar", melee: true, ranged: false, properties: { ver: true } },
      { name: "Blowgun", type: "Weapon", subType: "Martial Weapon", foundryValue: "blowgun", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true } },
      { name: "Crossbow, Hand", type: "Weapon", subType: "Martial Weapon", foundryValue: "handcrossbow", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lgt: true, lod: true } },
      { name: "Crossbow, Heavy", type: "Weapon", subType: "Martial Weapon", foundryValue: "heavycrossbow", advancement: "mar", melee: false, ranged: true, properties: { amm: true, hvy: true, two: true, lod: true } },
      { name: "Double-Bladed Scimitar", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: true, ranged: false, properties: { spc: true } },
      { name: "Flail", type: "Weapon", subType: "Martial Weapon", foundryValue: "flail", advancement: "mar", melee: true, ranged: false, properties: {} },
      { name: "Glaive", type: "Weapon", subType: "Martial Weapon", foundryValue: "glaive", advancement: "mar", melee: true, ranged: false, properties: { hvy: true, rch: true, two: true } },
      { name: "Greataxe", type: "Weapon", subType: "Martial Weapon", foundryValue: "greataxe", advancement: "mar", melee: true, ranged: false, properties: { hvy: true, two: true } },
      { name: "Greatsword", type: "Weapon", subType: "Martial Weapon", foundryValue: "greatsword", advancement: "mar", melee: true, ranged: false, properties: { hvy: true, two: true } },
      { name: "Halberd", type: "Weapon", subType: "Martial Weapon", foundryValue: "halberd", advancement: "mar", melee: true, ranged: false, properties: { hvy: true, two: true, rch: true } },
      { name: "Lance", type: "Weapon", subType: "Martial Weapon", foundryValue: "lance", advancement: "mar", melee: true, ranged: false, properties: { rch: true, spc: true } },
      { name: "Laser Pistol", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true } },
      { name: "Laser Rifle", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true, two: true } },
      { name: "Longbow", type: "Weapon", subType: "Martial Weapon", foundryValue: "longbow", advancement: "mar", melee: false, ranged: true, properties: { amm: true, hvy: true, two: true } },
      { name: "Longsword", type: "Weapon", subType: "Martial Weapon", foundryValue: "longsword", advancement: "mar", melee: true, ranged: false, properties: { ver: true } },
      { name: "Maul", type: "Weapon", subType: "Martial Weapon", foundryValue: "maul", advancement: "mar", melee: true, ranged: false, properties: { hvy: true, two: true } },
      { name: "Morningstar", type: "Weapon", subType: "Martial Weapon", foundryValue: "morningstar", advancement: "mar", melee: true, ranged: false, properties: {} },
      { name: "Musket", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true } },
      { name: "Net", type: "Weapon", subType: "Martial Weapon", foundryValue: "net", advancement: "mar", melee: true, ranged: false, properties: { spc: true, thw: true } },
      { name: "Pike", type: "Weapon", subType: "Martial Weapon", foundryValue: "pike", advancement: "mar", melee: true, ranged: false, properties: { hvy: true, two: true, rch: true } },
      { name: "Pistol, Automatic", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true } },
      { name: "Pistol", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true } },
      { name: "Rapier", type: "Weapon", subType: "Martial Weapon", foundryValue: "rapier", advancement: "mar", melee: true, ranged: false, properties: { fin: true } },
      { name: "Revenant Double-Bladed Scimitar", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", properties: { spc: true } },
      { name: "Revolver", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true } },
      { name: "Rifle, Automatic", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true, two: true, burst: true } },
      { name: "Rifle, Hunting", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true, two: true } },
      { name: "Scimitar", type: "Weapon", subType: "Martial Weapon", foundryValue: "scimitar", advancement: "mar", melee: true, ranged: false, properties: { fin: true, lgt: true } },
      { name: "Shortsword", type: "Weapon", subType: "Martial Weapon", foundryValue: "shortsword", advancement: "mar", melee: true, ranged: false, properties: { fin: true, lgt: true } },
      { name: "Shotgun", type: "Weapon", subType: "Martial Weapon", foundryValue: "", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lod: true, fir: true, two: true } },
      { name: "Trident", type: "Weapon", subType: "Martial Weapon", foundryValue: "trident", advancement: "mar", melee: true, ranged: false, properties: { ver: true, thr: true } },
      { name: "War Pick", type: "Weapon", subType: "Martial Weapon", foundryValue: "warpick", advancement: "mar", melee: true, ranged: false, properties: {} },
      { name: "Warhammer", type: "Weapon", subType: "Martial Weapon", foundryValue: "warhammer", advancement: "mar", melee: true, ranged: false, properties: { ver: true } },
      { name: "Whip", type: "Weapon", subType: "Martial Weapon", foundryValue: "whip", advancement: "mar", melee: true, ranged: false, properties: { fin: true, rch: true } },

      // special
      { name: "Light Crossbow", type: "Weapon", subType: "Simple Weapon", foundryValue: "lightcrossbow", advancement: "sim", melee: false, ranged: true, properties: { amm: true, lod: true, two: true } },
      { name: "Hand Crossbow", type: "Weapon", subType: "Martial Weapon", foundryValue: "handcrossbow", advancement: "mar", melee: false, ranged: true, properties: { amm: true, lgt: true, lod: true } },
      { name: "Heavy Crossbow", type: "Weapon", subType: "Martial Weapon", foundryValue: "heavycrossbow", advancement: "mar", melee: false, ranged: true, properties: { amm: true, hvy: true, two: true, lod: true } },
      { name: "Ammunition", type: "Weapon", subType: "Simple Weapon", foundryValue: "", advancement: "" },

      // Tools and Instruments and Stuff
      { name: "Alchemist's Supplies", type: "Tool", subType: "Supplies", ability: "int", baseTool: "alchemist", toolType: "art" },
      { name: "Brewer's Supplies", type: "Tool", subType: "Supplies", ability: "int", baseTool: "brewer", toolType: "art" },
      { name: "Calligrapher's Supplies", type: "Tool", subType: "Supplies", ability: "dex", baseTool: "calligrapher", toolType: "art" },
      { name: "Painter's Supplies", type: "Tool", subType: "Supplies", ability: "dex", baseTool: "painter", toolType: "art" },
      { name: "Carpenter's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "carpenter", toolType: "art" },
      { name: "Cartographer's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "cartographer", toolType: "art" },
      { name: "Cobbler's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "cobbler", toolType: "art" },
      { name: "Cook's Utensils", type: "Tool", subType: "Artisan's Tools", ability: "wis", baseTool: "cook", toolType: "art" },
      { name: "Glassblower's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "glassblower", toolType: "art" },
      { name: "Jeweler's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "jeweler", toolType: "art" },
      { name: "Leatherworker's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "leatherworker", toolType: "art" },
      { name: "Mason's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "mason", toolType: "art" },
      { name: "Navigator's Tools", type: "Tool", subType: "Artisan's Tools", ability: "int", baseTool: "navg", toolType: "" },
      { name: "Potter's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "potter", toolType: "art" },
      { name: "Smith's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "smith", toolType: "art" },
      { name: "Tinker's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "tinker", toolType: "art" },
      { name: "Weaver's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "weaver", toolType: "art" },
      { name: "Woodcarver's Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "woodcarver", toolType: "art" },
      { name: "Dice Set", type: "Tool", subType: "Gaming Set", ability: "int", baseTool: "dice", toolType: "game" },
      { name: "Dragonchess Set", type: "Tool", subType: "Gaming Set", ability: "int", baseTool: "chess", toolType: "game" },
      { name: "Playing Card Set", type: "Tool", subType: "Gaming Set", ability: "int", baseTool: "card", toolType: "game" },
      { name: "Three-Dragon Ante Set", type: "Tool", subType: "Gaming Set", ability: "int", baseTool: "card", toolType: "game" },
      { name: "Thieves' Tools", type: "Tool", subType: "Artisan's Tools", ability: "dex", baseTool: "thief", toolType: "" },
      { name: "Disguise Kit", type: "Tool", subType: "Kit", ability: "int", baseTool: "disg", toolType: "" },
      { name: "Forgery Kit", type: "Tool", subType: "Kit", ability: "int", baseTool: "forg", toolType: "" },
      { name: "Herbalism Kit", type: "Tool", subType: "Kit", ability: "int", baseTool: "herb", toolType: "" },
      { name: "Poisoner's Kit", type: "Tool", subType: "Kit", ability: "int", baseTool: "pois", toolType: "" },
      { name: "Bagpipes", type: "Tool", subType: "Musical Instrument", ability: "con", baseTool: "bagpipes", toolType: "music" },
      { name: "Birdpipes", type: "Tool", subType: "Musical Instrument", ability: "con", baseTool: null, toolType: "music" },
      { name: "Drum", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "drum", toolType: "music" },
      { name: "Dulcimer", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "dulcimer", toolType: "music" },
      { name: "Flute", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "flute", toolType: "music" },
      { name: "Glaur", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Hand Drum", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Horn", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "horn", toolType: "music" },
      { name: "Longhorn", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Lute", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "lute", toolType: "music" },
      { name: "Lyre", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "lyre", toolType: "music" },
      { name: "Pan Flute", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "panflute", toolType: "music" },
      { name: "Shawm", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Songhorn", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Tantan", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Thelarr", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Tocken", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Viol", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: "viol", toolType: "music" },
      { name: "Wargong", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Yarting", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Zulkoon", type: "Tool", subType: "Musical Instrument", ability: "dex", baseTool: null, toolType: "music" },
      { name: "Vehicles (Land)", type: "Tool", subType: "Vehicles", ability: "dex", baseTool: "land", toolType: "vehicle" },
      { name: "Vehicles (Air)", type: "Tool", subType: "Vehicles", ability: "dex", baseTool: "air", toolType: "vehicle" },
      { name: "Vehicles (Space)", type: "Tool", subType: "Vehicles", ability: "dex", baseTool: "space", toolType: "vehicle" },
      { name: "Vehicles (Water)", type: "Tool", subType: "Vehicles", ability: "dex", baseTool: "water", toolType: "vehicle" },
    ],
    characterValuesLookup: [
      { name: "pactWeapon", typeId: 28 },
      { name: "hexWarrior", typeId: 29 },
    ],
    // Supported Warlock Pact Weapon options
    pactFeatures: ["Improved Pact Weapon", "Lifedrinker"],
  },
  item: {
    characterValues: [
      { typeId: 8, value: "name" },
      //   { typeId: 9, value: 'notes'},  // note: Not supported by Foundry right now, skipping
      { typeId: 19, value: "price" },
      { typeId: 22, value: "weight" },
    ],
  },
  items: [
    { filterType: "Armor", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/armor.jpg" },
    { filterType: "Potion", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/potion.jpg" },
    { filterType: "Ring", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/ring.jpg" },
    { filterType: "Rod", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/rod.jpg" },
    { filterType: "Scroll", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/scroll.jpg" },
    { filterType: "Staff", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/staff.jpg" },
    { filterType: "Wand", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/wand.jpg" },
    { filterType: "Weapon", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/weapon.jpg" },
    { filterType: "Wondrous item", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/wondrousitem.jpg" },
  ],
  genericItemIcons: [
    { name: "Adventuring Gear", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/adventuring-gear.jpg" },
    { name: "Tool", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/tool.jpg" },
    { name: "Gemstone", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/gemstone.jpg" },
    { name: "Holy Symbol", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/holy-symbol.jpg" },
    { name: "Weapon", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/weapon.jpg" },
    { name: "Arcane Focus", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/arcane-focus.jpg" },
    { name: "Druidic Focus", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/druidic-focus.jpg" },
    { name: "Ammunition", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/ammunition.jpg" },
    { name: "Poison", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/poison.jpg" },
    { name: "Mount", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/mount.jpg" },
    { name: "Potion", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/potion.jpg" },
    { name: "Equipment Pack", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/pack.jpg" },
    // Vehicle (Land)/(Water)
    { name: "Vehicle", img: "https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/vehicle.jpg" },
  ],
  equipment: {
    armorType: [
      { name: "Light Armor", id: 1, value: "light" },
      { name: "Medium Armor", id: 2, value: "medium" },
      { name: "Heavy Armor", id: 3, value: "heavy" },
      { name: "Shield", id: 4, value: "shield" },
      { name: "Unarmored", id: 0, value: null },
      { name: "Unarmored Defense", id: -1, value: null },
      { name: "Natural Armor", id: -2, value: "natural" },
      { name: "Magical Bonus", id: -3, value: "bonus" },
      { name: "Clothing", id: -4, value: "clothing" },
    ],
    priceFormulas: {
      "common": "1d6 * 10",
      "uncommon": "1d6 * 100",
      "rare": "2d10 * 1000",
      "veryRare": "1d4 * 10000",
      "legendary": "2d6 * 25000",
      "artifact": "2d10 * 50000",
    },
  },
  weapon: {
    weaponRange: [
      { attackType: 1, value: "M" },
      { attackType: 2, value: "R" },
      { attackType: null, value: "R" },
    ],
    weaponType: [
      { categoryId: 1, value: "simple" },
      { categoryId: 2, value: "martial" },
      { categoryId: 3, value: "martial" }, // this is not 100% correct. a martialF for "Martial Firearms" would be better
      { categoryId: 0, value: "simple" }, // this is totally incorrect, this is of type ammunition
    ],
    properties: [
      { name: "Adamantine", value: "ada" },
      { name: "Ammunition (Firearms)", value: "fir" },
      { name: "Ammunition", value: "amm" },
      { name: "Finesse", value: "fin" },
      { name: "Firearm", value: "fir" },
      { name: "Focus", value: "foc" },
      { name: "Heavy", value: "hvy" },
      { name: "Light", value: "lgt" },
      { name: "Loading", value: "lod" },
      { name: "Magical", value: "mgc" },
      { name: "Reach", value: "rch" },
      { name: "Reload", value: "rel" },
      { name: "Returning", value: "ret" },
      { name: "Silvered", value: "sil" },
      { name: "Special", value: "spc" },
      { name: "Thrown", value: "thr" },
      { name: "Two-Handed", value: "two" },
      { name: "Versatile", value: "ver" },
      // { name: "Range", value: "fir" },
    ],
  },
  actions: {
    activationTypes: [
      { id: 0, value: "none" },
      { id: 1, value: "action" },
      { id: 2, value: "action" },
      { id: 3, value: "bonus" },
      { id: 4, value: "reaction" },
      { id: 5, value: "action" },
      { id: 6, value: "minute" },
      { id: 7, value: "hour" },
      { id: 8, value: "special" },
    ],
    attackTypes: [
      //  natural improv
      // { attackSubtype: 1, value: "" },
      { attackSubtype: 2, value: "natural" },
      { attackSubtype: 3, value: "simpleM" }, // unarmed
    ],
    damageType: [
      { name: "bludgeoning", id: 1 },
      { name: "piercing", id: 2 },
      { name: "slashing", id: 3 },
      { name: "necrotic", id: 4 },
      { name: "acid", id: 5 },
      { name: "cold", id: 6 },
      { name: "fire", id: 7 },
      { name: "lightning", id: 8 },
      { name: "thunder", id: 9 },
      { name: "poison", id: 10 },
      { name: "psychic", id: 11 },
      { name: "radiant", id: 12 },
      { name: "force", id: 13 },
      { name: null, id: null },
    ],
    aoeType: [
      { id: 1, value: "cone" },
      { id: 2, value: "" },
      { id: 3, value: "" },
      { id: 4, value: "line" },
      // presumably others here too! add when found
    ],
  },
  spell: {
    schools: [
      { id: "abj", name: "abjuration", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/abjuration.png" },
      { id: "con", name: "conjuration", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/conjuration.png" },
      { id: "div", name: "divination", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/divination.png" },
      { id: "enc", name: "enchantment", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/enchantment.png" },
      { id: "evo", name: "evocation", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/evocation.png" },
      { id: "ill", name: "illusion", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/illusion.png" },
      { id: "nec", name: "necromancy", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/necromancy.png" },
      { id: "trs", name: "transmutation", img: "https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/transmutation.png" },
    ],
    progression: [
      { name: "Artificer", value: "artificer" },
      { name: "Artificer (UA)", value: "artificer" },
      { name: "Bard", value: "full" },
      { name: "Barbarian", value: "none" },
      { name: "Blood Hunter", value: "pact" },
      { name: "Blood Hunter (archived)", value: "pact" },
      { name: "Cleric", value: "full" },
      { name: "Druid", value: "full" },
      { name: "Fighter", value: "third" },
      { name: "Hunter", value: "half" },
      { name: "Paladin", value: "half" },
      { name: "Ranger", value: "half" },
      { name: "Rogue", value: "third" },
      { name: "Sorcerer", value: "full" },
      { name: "Warlock", value: "pact" },
      { name: "Wizard", value: "full" },
      { name: "Monk", value: "none" },
    ],
    preparationModes: [
      { name: "Artificer", value: "prepared" },
      { name: "Artificer (UA)", value: "prepared" },
      { name: "Bard", value: "always" },
      { name: "Blood Hunter", value: "pact" },
      { name: "Blood Hunter (archived)", value: "pact" },
      { name: "Cleric", value: "prepared" },
      { name: "Druid", value: "prepared" },
      { name: "Fighter", value: "always" },
      { name: "Hunter", value: "always" },
      { name: "Paladin", value: "prepared" },
      { name: "Ranger", value: "always" },
      { name: "Rogue", value: "always" },
      { name: "Sorcerer", value: "always" },
      { name: "Warlock", value: "pact" },
      { name: "Wizard", value: "prepared" },
      { name: "Monk", value: "always" },
    ],
    activationTypes: [
      { activationType: 0, value: "none", name: "No Action" }, // doesn't exist an more
      { activationType: 1, value: "action", name: "Action", }, // action
      { activationType: 2, value: "none", name: "No Action" }, // no action
      { activationType: 3, value: "bonus", name: "Bonus Action" }, // bonus action
      { activationType: 4, value: "reaction", name: "Reaction", }, // reaction
      { activationType: 5, value: "special", name: "Unknown" }, // no longer exists
      { activationType: 6, value: "minute", name: "Minute" }, // minute
      { activationType: 7, value: "hour", name: "Hour" }, // hour
      { activationType: 8, value: "special", name: "Special" }, // special
    ],
  },
  monsters: {
    weapons: [
      // simple
      { name: "Boomerang", actionType: "rwak", weaponType: "simpleR", properties: { ret: true } },
      { name: "Club", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true } },
      { name: "Dagger", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, fin: true, thr: true } },
      { name: "Dart", actionType: "rwak", weaponType: "simpleR", properties: { fin: true, thr: true } },
      { name: "Greatclub", actionType: "mwak", weaponType: "simpleM", properties: { two: true } },
      { name: "Handaxe", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, thr: true } },
      { name: "Javelin", actionType: "mwak", weaponType: "simpleM", properties: { thr: true } },
      { name: "Light Crossbow", actionType: "rwak", weaponType: "simpleR", properties: { amm: true, lod: true, two: true } },
      { name: "Light Hammer", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true, thr: true } },
      { name: "Mace", actionType: "mwak", weaponType: "simpleM", properties: {} },
      { name: "Quarterstaff", actionType: "mwak", weaponType: "simpleM", properties: { ver: true } },
      { name: "Shortbow", actionType: "rwak", weaponType: "simpleR", properties: { amm: true, two: true } },
      { name: "Sickle", actionType: "mwak", weaponType: "simpleM", properties: { lgt: true } },
      { name: "Sling", actionType: "rwak", weaponType: "simpleR", properties: { amm: true } },
      { name: "Spear", actionType: "mwak", weaponType: "simpleM", properties: { thr: true, ver: true } },
      { name: "Yklwa", actionType: "rwak", weaponType: "simpleR", properties: { amm: true } },
      // martial
      { name: "Battleaxe", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
      { name: "Blowgun", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true } },
      { name: "Flail", actionType: "mwak", weaponType: "martialM", properties: {} },
      { name: "Glaive", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, rch: true, two: true } },
      { name: "Greataxe", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
      { name: "Greatsword", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
      { name: "Halberd", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true, rch: true } },
      { name: "Hand Crossbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lgt: true, lod: true } },
      { name: "Heavy Crossbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, hvy: true, two: true, lod: true } },
      { name: "Lance", actionType: "mwak", weaponType: "martialM", properties: { rch: true, spc: true } },
      { name: "Longbow", actionType: "rwak", weaponType: "martialR", properties: { amm: true, hvy: true, two: true } },
      { name: "Longsword", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
      { name: "Maul", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true } },
      { name: "Morningstar", actionType: "mwak", weaponType: "martialM", properties: {} },
      { name: "Musket", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true, fir: true } },
      { name: "Net", actionType: "mwak", weaponType: "martialR", properties: { spc: true, thw: true } },
      { name: "Pike", actionType: "mwak", weaponType: "martialM", properties: { hvy: true, two: true, rch: true } },
      { name: "Pistol", actionType: "rwak", weaponType: "martialR", properties: { amm: true, lod: true, fir: true } },
      { name: "Rapier", actionType: "mwak", weaponType: "martialM", properties: { fin: true } },
      { name: "Scimitar", actionType: "mwak", weaponType: "martialM", properties: { fin: true, lgt: true } },
      { name: "Shortsword", actionType: "mwak", weaponType: "martialM", properties: { fin: true, lgt: true } },
      { name: "Trident", actionType: "mwak", weaponType: "martialM", properties: { ver: true, thr: true } },
      { name: "War Pick", actionType: "mwak", weaponType: "martialM", properties: {} },
      { name: "Warhammer", actionType: "mwak", weaponType: "martialM", properties: { ver: true } },
      { name: "Whip", actionType: "mwak", weaponType: "martialM", properties: { fin: true, rch: true } },
      // natural
      { name: "Bite", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Claw", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Tail", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Wing", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Slam", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Rake", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Beak", actionType: "mwak", weaponType: "natural", properties: {} },
      { name: "Tentacles", actionType: "mwak", weaponType: "natural", properties: {} },
    ],
    resets: [
      { id: 1, value: "sr" },
      { id: "ShortRest", value: "sr" },
      { id: "Short", value: "sr" },
      { id: "short", value: "sr" },
      { id: 2, value: "lr" },
      { id: "LongRest", value: "lr" },
      { id: "Long", value: "lr" },
      { id: "long", value: "lr" },
      { id: "Day", value: "day" },
      { id: "day", value: "day" },
      { id: "Dawn", value: "day" },
      { id: "dusk", value: "day" },
      { id: "Consumable", value: "charges" },
      { id: "Other", value: "charges" },
    ],
  },
  COMPENDIUM_FOLDERS: {
    SPELL_LEVEL: [
      "0th Level (Cantrip)",
      "1st Level",
      "2nd Level",
      "3rd Level",
      "4th Level",
      "5th Level",
      "6th Level",
      "7th Level",
      "8th Level",
      "9th Level",
    ],
    RARITY: [
      "Common",
      "Uncommon",
      "Rare",
      "Very Rare",
      "Legendary",
      "Artifact",
      "Varies",
      "Unknown",
    ],
    ITEM_ROOT: {
      equipment: "Equipment",
      tool: "Tools",
      loot: "Loot",
      weapon: "Weapon",
      container: "Container",
      consumable: "Consumable",
    },
    EQUIPMENT: {
      heavy: "Heavy Armor",
      medium: "Medium Armor",
      light: "Light Armor",
      trinket: "Trinket",
      shield: "Shield",
      clothing: "Clothing",
    },
    WEAPON: {
      simpleM: "Simple Melee",
      simpleR: "Simple Ranged",
      martialM: "Martial Melee",
      martialR: "Martial Ranged",
    },
    TRINKET: [
      "Wondrous item",
      "Ring",
      "Arcane Focus",
      "Holy Symbol",
      "Druidic Focus",
      "Adventuring Gear",
      "Tattoo",
    ],
    CONSUMABLE: [
      "Adventuring Gear",
      "Ammunition",
      "Potion",
      "Scroll",
      "Poison",
      "Wand",
      "Rod",
      "Wondrous item",
    ],
    LOOT: [
      "Gemstone",
      "Adventuring Gear",
      "Miscellaneous",
    ],
    TOOLS: {
      art: "Artisan's Tools",
      music: "Musical Instrument",
      game: "Gaming Set",
    },
    CONTAINER: [
      "Equipment Pack",
      "Adventuring Gear",
      "Vehicle",
      "Mount",
      "Wondrous item",
    ],
  },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DICTIONARY);


/***/ }),

/***/ 2010:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBEffectHelper)
/* harmony export */ });
/* harmony import */ var _lib_DialogHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7073);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7407);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5259);
/* harmony import */ var _parser_item_special_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(9695);
/* harmony import */ var _parser_spells_special_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1838);
/* harmony import */ var _specialEquipment_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7309);
/* harmony import */ var _specialSpells_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3137);
/* harmony import */ var _vision5e_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(5042);
/* harmony import */ var _parser_features_fixes_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1278);
/* harmony import */ var _monsterFeatures_overTimeEffect_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4274);
/* harmony import */ var _effects_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(5751);
/* harmony import */ var _external_ExternalAutomations_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(767);















class DDBEffectHelper {

  static baseEffect = _effects_js__WEBPACK_IMPORTED_MODULE_11__/* .baseEffect */ .mS;

  static generateOverTimeEffect = _monsterFeatures_overTimeEffect_js__WEBPACK_IMPORTED_MODULE_10__/* .generateOverTimeEffect */ .FI;

  static getOvertimeDamage = _monsterFeatures_overTimeEffect_js__WEBPACK_IMPORTED_MODULE_10__/* .getOvertimeDamage */ .XP;

  static getMonsterFeatureDamage = _monsterFeatures_overTimeEffect_js__WEBPACK_IMPORTED_MODULE_10__/* .getMonsterFeatureDamage */ .Z1;

  static damageOverTimeEffect = _monsterFeatures_overTimeEffect_js__WEBPACK_IMPORTED_MODULE_10__/* .damageOverTimeEffect */ .LB;

  static generateStatusEffectChange = _effects_js__WEBPACK_IMPORTED_MODULE_11__/* .generateStatusEffectChange */ .f6;

  static addStatusEffectChange = _effects_js__WEBPACK_IMPORTED_MODULE_11__/* .addStatusEffectChange */ .sb;

  static generateTokenMagicFXChange = _effects_js__WEBPACK_IMPORTED_MODULE_11__/* .generateTokenMagicFXChange */ .UY;

  static generateATLChange = _effects_js__WEBPACK_IMPORTED_MODULE_11__/* .generateATLChange */ .Ci;

  static addToProperties = _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].addToProperties */ .Z.addToProperties;

  static removeFromProperties = _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].removeFromProperties */ .Z.removeFromProperties;

  /**
   * Generates and applies DDBI effects to a document.
   *
   * @param {Document} document - The document to apply effects to.
   * @param {object} options - Options for effect generation.
   * @param {boolean} options.useChrisPremades - Whether to use Chris premade effects. Default is false.
   * @return {Promise<void>} A promise that resolves when the effects have been applied.
   */
  static async addDDBIEffectToDocument(document, { useChrisPremades = false, isMonster = false } = {}) {
    if (foundry.utils.getProperty(document, "flags.ddbimporter.effectsApplied") === true
      || foundry.utils.getProperty(document, "flags.ddbimporter.chrisEffectsApplied") === true
    ) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn(`Skipping effect generation for ${document.name} as DDB Importer or Chris effect is already present.`);
      return;
    }
    const startingSpellPolicy = game.settings.get("ddb-importer", "munching-policy-add-spell-effects");
    const startingAddPolicy = game.settings.get("ddb-importer", "munching-policy-add-effects");
    try {
      game.settings.set("ddb-importer", "munching-policy-add-spell-effects", true);
      game.settings.set("ddb-importer", "munching-policy-add-effects", true);

      let data = document.toObject();
      // remove old effects
      data.effects = [];
      if (foundry.utils.hasProperty(data, "flags.dae")) delete data.flags.dae;
      if (foundry.utils.hasProperty(data, "flags.itemacro")) delete data.flags.itemacro;
      if (foundry.utils.hasProperty(data, "flags.midi-qol")) delete data.flags["midi-qol"];
      if (foundry.utils.hasProperty(data, "flags.ActiveAuras")) delete data.flags.ActiveAuras;

      if (_dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(data.type)) {
        (0,_specialEquipment_js__WEBPACK_IMPORTED_MODULE_6__/* .equipmentEffectAdjustment */ ._)(data);
        data = await (0,_specialEquipment_js__WEBPACK_IMPORTED_MODULE_6__/* .midiItemEffects */ .i)(data);
        (0,_parser_item_special_js__WEBPACK_IMPORTED_MODULE_13__/* .fixItems */ .x)([data]);
      } else if (data.type === "spell") {
        data = await (0,_specialSpells_js__WEBPACK_IMPORTED_MODULE_7__/* .spellEffectAdjustment */ .x)(data, true);
        await (0,_parser_spells_special_js__WEBPACK_IMPORTED_MODULE_5__/* .fixSpells */ .F)(null, [data]);
      } else if (data.type === "feat") {
        const mockCharacter = {
          system: _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getTemplate */ .Z.getTemplate("character"),
          type: "character",
          name: "",
          flags: {
            ddbimporter: {
              compendium: true,
              dndbeyond: {
                effectAbilities: [],
                totalLevels: 0,
                proficiencies: [],
                proficienciesIncludingEffects: [],
                characterValues: [],
              },
            },
          },
        };

        await (0,_parser_features_fixes_js__WEBPACK_IMPORTED_MODULE_9__/* .fixFeatures */ .t)([data]);
        data = (await (0,_parser_features_fixes_js__WEBPACK_IMPORTED_MODULE_9__/* .addExtraEffects */ .f)(null, [data], mockCharacter))[0];
      }

      if (useChrisPremades) data = (await _external_ExternalAutomations_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].applyChrisPremadeEffects */ .Z.applyChrisPremadeEffects({ documents: [data], force: true, isMonster }))[0];

      data = (0,_vision5e_js__WEBPACK_IMPORTED_MODULE_8__/* .addVision5eStub */ .p)(data);

      if (foundry.utils.getProperty(data, "flags.ddbimporter.effectsApplied") === true
        || foundry.utils.getProperty(data, "flags.ddbimporter.chrisEffectsApplied") === true
      ) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("New effects generated, removing existing effects");
        await document.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Removal complete, adding effects to item ${document.name}`);

        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info(`Updating actor document ${document.name} with`, {
          data: foundry.utils.duplicate(data),
        });
        await document.update(data);
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info(`No effects applied to document ${document.name}`);
      }
    } finally {
      game.settings.set("ddb-importer", "munching-policy-add-spell-effects", startingSpellPolicy);
      game.settings.set("ddb-importer", "munching-policy-add-effects", startingAddPolicy);
    }
  }

  /**
   * Adds DDBI effects to actor documents.
   *
   * @param {Object} actor - The actor object.
   * @param {Object} options - The options object.
   * @param {boolean} options.useChrisPremades - Whether to use Chris premades.
   * @return {Promise<void>} - A promise that resolves when the effects are added.
   */
  static async addDDBIEffectsToActorDocuments(actor, { useChrisPremades = false } = {}) {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info("Starting to add effects to actor items");
    const isMonster = actor.type === "npc";
    for (const doc of actor.items) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Processing ${doc.name}`);
      await DDBEffectHelper.addDDBIEffectToDocument(doc, { useChrisPremades, isMonster });
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info("Effect addition complete");
  }

  /**
   * Adds a save advantage effect for the next save on the specified target actor.
   *
   * @param {*} targetActor the target actor on which to add the effect.
   * @param {*} originItem the item that is the origin of the effect.
   * @param {*} ability the short ability name to use for save, e.g. str
   */
  static async addSaveAdvantageToTarget(targetActor, originItem, ability, additionLabel = "", icon = null) {
    const effectData = {
      _id: foundry.utils.randomID(),
      changes: [
        {
          key: `flags.midi-qol.advantage.ability.save.${ability}`,
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          value: "1",
          priority: 20,
        },
      ],
      origin: originItem.uuid,
      disabled: false,
      transfer: false,
      icon,
      img: icon,
      duration: { turns: 1 },
      flags: {
        dae: {
          specialDuration: [`isSave.${ability}`],
        },
      },
    };
    effectData.name = `${originItem.name}${additionLabel}: Save Advantage`;
    await MidiQOL.socket().executeAsGM("createEffects", { actorUuid: targetActor.uuid, effects: [effectData] });
  }

  static async attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid, scale = 1) {
    if (game.modules.get("sequencer")?.active) {
      if (Sequencer.Database.entryExists(sequencerFile)) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Trying to apply sequencer effect (${sequencerFile}) to ${templateUuid} from ${originUuid}`, sequencerFile);
        const template = await fromUuid(templateUuid);
        new Sequence()
          .effect()
          .file(Sequencer.Database.entryExists(sequencerFile))
          .size({
            width: canvas.grid.size * (template.width / canvas.dimensions.distance),
            height: canvas.grid.size * (template.width / canvas.dimensions.distance),
          })
          .persist(true)
          .origin(originUuid)
          .belowTokens()
          .opacity(0.5)
          .attachTo(template, { followRotation: true })
          .scaleToObject(scale)
          .play();
      }
    }
  }

  static async buttonDialog(config, direction) {
    return _lib_DialogHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].buttonDialog */ .Z.buttonDialog(config, direction);
  }

  static canSense(token, target) {
    return MidiQOL.canSense(token, target);
  }

  static checkCollision(ray, types = ["sight", "move"], mode = "any") {
    for (const type of types) {
      const result = CONFIG.Canvas.polygonBackends[type].testCollision(ray.A, ray.B, { mode, type });
      if (result) return result;
    }
    return false;
  }

  /**
   * Checks the cover bonus for a given token, target, item, and displayName.
   *
   * @param {any} token - The token object.
   * @param {any} target - The target object.
   * @param {any} item - The item object.
   * @param {string} displayName - The display name of the cover.
   * @return {string|number} The cover bonus or the display name of the cover.
   */
  static checkCover(token, target, item, displayName) {
    const cover = MidiQOL.computeCoverBonus(token, target, item);
    if (!displayName) return cover;
    switch (cover) {
      case 0:
        return "No Cover";
      case 2:
        return "Half Cover";
      case 5:
        return "Three-Quarters Cover";
      case 999:
        return "Full Cover";
      default:
        return "Unknown Cover";
    }
  }

  /**
   * If a custom AA condition animation exists for the specified name, registers the appropriate hook with AA
   * to be able to replace the default condition animation by the custom one.
   *
   * @param {*} condition condition for which to replace its AA animation by a custom one (it must be a value from CONFIG.DND5E.conditionTypes).
   * @param {*} macroData the midi-qol macro data.
   * @param {*} originItemName the name of item used for AA customization of the condition.
   * @param {*} conditionItemUuid the UUID of the item applying the condition.
   */
  static configureCustomAAForCondition(condition, macroData, originItemName, conditionItemUuid) {
    // Get default condition label
    const statusName = CONFIG.DND5E.conditionTypes[condition];
    if (!statusName) {
      return;
    }
    const customStatusName = `${statusName.label} [${originItemName}]`;
    if (AutomatedAnimations.AutorecManager.getAutorecEntries().aefx.find((a) => (a.label ?? a.name) === customStatusName)) {
      const aaHookId = Hooks.on("AutomatedAnimations-WorkflowStart", (data) => {
        if (
          data.item instanceof CONFIG.ActiveEffect.documentClass
          && data.item.name === statusName.label
          && data.item.origin === macroData.sourceItemUuid
        ) {
          data.recheckAnimation = true;
          data.item.name = customStatusName;
          Hooks.off("AutomatedAnimations-WorkflowStart", aaHookId);
        }
      });
      // Make sure that the hook is removed when the special spell effect is completed
      Hooks.once(`midi-qol.RollComplete.${conditionItemUuid}`, () => {
        Hooks.off("AutomatedAnimations-WorkflowStart", aaHookId);
      });
    }
  }

  static checkJB2a(free = true, patreon = true, notify = false) {
    if (patreon && game.modules.get('jb2a_patreon')?.active) {
      return true;
    } else if (!free) {
      if (notify) ui.notifications.error("This macro requires the patreon version of JB2A");
      return false;
    }
    if (free && game.modules.get('JB2A_DnD5e')?.active) return true;
    if (notify) ui.notifications.error("This macro requires either the patreon or free version of JB2A");
    return false;
  }

  static async _createJB2aActors(subFolderName, name) {
    const packKeys = ['jb2a_patreon.jb2a-actors', 'JB2A_DnD5e.jb2a-actors'];
    for (let key of packKeys) {
      let pack = game.packs.get(key);
      // eslint-disable-next-line no-continue
      if (!pack) continue;
      const actors = pack.index.filter((f) => f.name.includes(name));
      const subFolder = await _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getFolder */ .Z.getFolder("npc", subFolderName, "JB2A Actors", "#ceb180", "#cccc00", false);

      for (const actor of actors) {
        if (!game.actors.find((a) => a.name === actor.name && a.folder?.id === subFolder.id)) {
          await game.actors.importFromCompendium(pack, actor._id, {
            folder: subFolder.id,
          });
        }
      }
    }
  }

  static async checkTargetInRange({ sourceUuid, targetUuid, distance }) {
    if (!game.modules.get("midi-qol")?.active) {
      ui.notifications.error("checkTargetInRange requires midiQoL, not checking");
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error("checkTargetInRange requires midiQoL, not checking");
      return true;
    }
    const sourceToken = await fromUuid(sourceUuid);
    if (!sourceToken) return false;
    const targetsInRange = MidiQOL.findNearby(null, sourceUuid, distance);
    const isInRange = targetsInRange.reduce((result, possible) => {
      const collisionRay = new Ray(sourceToken, possible);
      const collision = DDBEffectHelper.checkCollision(collisionRay, ["sight"]);
      if (possible.uuid === targetUuid && !collision) result = true;
      return result;
    }, false);
    return isInRange;
  }

  /**
   * Display an item card on the screen.
   *
   * @param {Object} item - The item to display the card for
   * @return {Promise} A promise that resolves when the card is displayed
   */
  static async displayItemCard(item) {
    const msg = await item.displayCard({ createMessage: false });
    const DIV = document.createElement("DIV");
    DIV.innerHTML = msg.content;
    DIV.querySelector("div.card-buttons").remove();
    await ChatMessage.create({ content: DIV.innerHTML });
  }

  /**
   * Returns ids of tokens in template
   *
   * @param {*} templateDoc the templatedoc to check
   */
  static findContainedTokensInTemplate(templateDoc) {
    const contained = new Set();
    for (const tokenDoc of templateDoc.parent.tokens) {
      const startX = tokenDoc.width >= 1 ? 0.5 : tokenDoc.width / 2;
      const startY = tokenDoc.height >= 1 ? 0.5 : tokenDoc.height / 2;
      for (let x = startX; x < tokenDoc.width; x++) {
        for (let y = startY; y < tokenDoc.width; y++) {
          const curr = {
            x: tokenDoc.x + (x * templateDoc.parent.grid.size) - templateDoc.x,
            y: tokenDoc.y + (y * templateDoc.parent.grid.size) - templateDoc.y,
          };
          const contains = templateDoc.object.shape.contains(curr.x, curr.y);
          if (contains) contained.add(tokenDoc.id);
        }
      }
    }
    return [...contained];
  }

  /**
   * Finds the effect with the specified name for the given actor.
   *
   * @param {Actor} actor - The actor to search for the effect.
   * @param {string} name - The name of the effect to find.
   * @return {Effect} - The effect with the specified name, or undefined if not found.
   */
  static findEffect(actor, name) {
    return actor.effects.getName(name);
  }

  static getActorEffects(actor) {
    return Array.from(actor?.allApplicableEffects() ?? []);
  }

  /**
 * Asynchronously gets a new target and updates workflow data.
 *
 * @param {Object} item - The item to get the new target for
 * @return {Token|undefined} The new target, or undefined if no new target is found
 */
  static async getNewMidiQOLWorkflowTarget(workflow, item, oldToken, targetTitle = undefined) {
    workflow.targets.delete(oldToken);
    workflow.saves.delete(oldToken);
    workflow.hitTargets.delete(oldToken);
    await DDBEffectHelper.displayItemCard(item);
    await MidiQOL.resolveTargetConfirmation(item, { forceDisplay: true, title: targetTitle });

    const newToken = game.user.targets.first();
    if (!newToken) return undefined;
    workflow.targets.add(newToken);
    workflow.hitTargets.add(newToken);
    workflow.saveResults = workflow.saveResults.filter((e) => e.data.tokenId !== oldToken.id);
    return newToken;
  }

  /**
   * Finds effects for the given actor and names.
   *
   * @param {Actor} actor - The actor to find effects for.
   * @param {string[]} names - An array of effect names to search for.
   * @return {object[]} - An array of effects matching the given names.
   */
  static findEffects(actor, names) {
    const results = [];
    for (const name of names) {
      if (DDBEffectHelper.findEffect(actor, name)) {
        results.push(DDBEffectHelper.findEffect(actor, name));
      }
    }
    return results;
  }

  /**
   * Return actor from a UUID
   *
   * @param {string} uuid - The UUID of the actor.
   * @return {object|null} - Returns the actor document or null if not found.
   */
  static fromActorUuid(uuid) {
    const doc = fromUuidSync(uuid);
    if (doc instanceof CONFIG.Token.documentClass) return doc.actor;
    if (doc instanceof CONFIG.Actor.documentClass) return doc;
    return null;
  }

  /**
   * Returns the actor object associated with the given actor reference.
   *
   * @param {any} actorRef - The actor reference to retrieve the actor from.
   * @return {Actor|null} The actor object associated with the given actor reference, or null if no actor is found.
   */
  static getActor(actorRef) {
    if (actorRef instanceof Actor) return actorRef;
    if (actorRef instanceof Token) return actorRef.actor;
    if (actorRef instanceof TokenDocument) return actorRef.actor;
    if (_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].isString */ .Z.isString(actorRef)) return DDBEffectHelper.fromActorUuid(actorRef);
    return null;
  }

  /**
   * Retrieves the number of cantrip dice based on the level of the actor.
   *
   * @param {Actor} actor - The actor object
   * @return {number} The number of cantrip dice.
   */
  static getCantripDice(actor) {
    const level = actor.type === "character"
      ? actor.system.details.level
      : actor.system.details.cr;
    return 1 + Math.floor((level + 1) / 6);
  }


  // eslint-disable-next-line no-unused-vars
  static getConcentrationEffect(actor, _name = null) {
    return actor?.effects.find((ef) => foundry.utils.getProperty(ef, "flags.midi-qol.isConcentration"));
  }

  /**
   * This is a simple reworking of midi-qols measureDistances function, for use where midi-qol is not available
   * Measure distances for given segments with optional grid spaces.
   *
   * @param {Array} segments - Array of segments to measure distances for
   * @param {Object} options - Optional object with grid spaces configuration
   * @return {Array} Array of distances for each segment
   */
  static simpleMeasureDistances(segments, options = {}) {
    if (canvas?.grid?.grid.constructor.name !== "BaseGrid" || !options.gridSpaces) {
      const distances = canvas?.grid?.measureDistances(segments, options);
      return distances;
    }

    const rule = canvas?.grid.diagonalRule;
    if (!options.gridSpaces || !["555", "5105", "EUCL"].includes(rule)) {
      return canvas?.grid?.measureDistances(segments, options);
    }
    // Track the total number of diagonals
    let nDiagonal = 0;
    const d = canvas?.dimensions;

    const grid = canvas?.scene?.grid;
    if (!d || !d.size) return 0;

    // Iterate over measured segments
    return segments.map((s) => {
      const r = s.ray;
      // Determine the total distance traveled
      const nx = Math.ceil(Math.max(0, Math.abs(r.dx / d.size)));
      const ny = Math.ceil(Math.max(0, Math.abs(r.dy / d.size)));
      // Determine the number of straight and diagonal moves
      const nd = Math.min(nx, ny);
      const ns = Math.abs(ny - nx);
      nDiagonal += nd;

      if (rule === "5105") { // Alternative DMG Movement
        const nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);
        const spaces = (nd10 * 2) + (nd - nd10) + ns;
        return spaces * d.distance;
      } else if (rule === "EUCL") { // Euclidean Measurement
        const nx = Math.max(0, Math.abs(r.dx / d.size));
        const ny = Math.max(0, Math.abs(r.dy / d.size));
        return Math.ceil(Math.hypot(nx, ny) * grid?.distance);
      } else { // Standard PHB Movement
        return Math.max(nx, ny) * grid.distance;
      }
    });
  }

  /**
   * Get the distance segments between two objects.
   *
   * @param {Object} t1 - the first token
   * @param {Object} t2 - the second token
   * @param {boolean} wallBlocking - whether to consider walls as blocking
   * @return {Array} an array of segments representing the distance between the two objects
   */
  static _getDistanceSegments(t1, t2, wallBlocking = false) {
    const t1StartX = t1.document.width >= 1 ? 0.5 : t1.document.width / 2;
    const t1StartY = t1.document.height >= 1 ? 0.5 : t1.document.height / 2;
    const t2StartX = t2.document.width >= 1 ? 0.5 : t2.document.width / 2;
    const t2StartY = t2.document.height >= 1 ? 0.5 : t2.document.height / 2;
    let x, x1, y, y1;
    let segments = [];
    for (x = t1StartX; x < t1.document.width; x++) {
      for (y = t1StartY; y < t1.document.height; y++) {
        const origin = new PIXI.Point(...canvas.grid.getCenter(Math.round(t1.document.x + (canvas.dimensions.size * x)), Math.round(t1.document.y + (canvas.dimensions.size * y))));
        for (x1 = t2StartX; x1 < t2.document.width; x1++) {
          for (y1 = t2StartY; y1 < t2.document.height; y1++) {
            const dest = new PIXI.Point(...canvas.grid.getCenter(Math.round(t2.document.x + (canvas.dimensions.size * x1)), Math.round(t2.document.y + (canvas.dimensions.size * y1))));
            const r = new Ray(origin, dest);
            // eslint-disable-next-line max-depth
            if (wallBlocking) {
              const collisionCheck = CONFIG.Canvas.polygonBackends.move.testCollision(origin, dest, { mode: "any", type: "move" });
              // eslint-disable-next-line max-depth, no-continue
              if (collisionCheck) continue;
            }
            segments.push({ ray: r });
          }
        }
      }
    }
    return segments;
  }

  /**
   * Calculate the height difference between two tokens based on their elevation and dimensions.
   *
   * @param {type} t1 - description of parameter t1
   * @param {type} t2 - description of parameter t2
   * @return {type} the height difference between the two tokens
   */
  static _calculateTokeHeightDifference(t1, t2) {
    const t1Elevation = t1.document.elevation ?? 0;
    const t2Elevation = t2.document.elevation ?? 0;
    const t1TopElevation = t1Elevation + (Math.max(t1.document.height, t1.document.width) * (canvas?.dimensions?.distance ?? 5));
    const t2TopElevation = t2Elevation + (Math.min(t2.document.height, t2.document.width) * (canvas?.dimensions?.distance ?? 5));

    let heightDifference = 0;
    let t1ElevationRange = Math.max(t1.document.height, t1.document.width) * (canvas?.dimensions?.distance ?? 5);
    if (Math.abs(t2Elevation - t1Elevation) < t1ElevationRange) {
      // token 2 is within t1's size so height difference is functionally 0
      heightDifference = 0;
    } else if (t1Elevation < t2Elevation) { // t2 above t1
      heightDifference = t2Elevation - t1TopElevation;
    } else if (t1Elevation > t2Elevation) { // t1 above t2
      heightDifference = t1Elevation - t2TopElevation;
    }

    return heightDifference;

  }

  /**
   * This is a simple reworking of midi-qols get distance function, for use where midi-qol is not available
   * Calculate the distance between two tokens on the canvas, considering the presence of walls.
   *
   * @param {string} token1 - The ID of the first token
   * @param {string} token2 - The ID of the second token
   * @param {boolean} wallBlocking - Whether to consider walls as obstacles (default is false)
   * @return {number} The calculated distance between the two tokens
   */
  static getSimpleDistance(token1, token2, wallBlocking = false) {
    if (!canvas || !canvas.scene) return -1;
    if (!canvas.grid || !canvas.dimensions) return -1;
    const t1 = DDBEffectHelper.getToken(token1);
    const t2 = DDBEffectHelper.getToken(token2);
    if (!t1 || !t2) return -1;
    if (!canvas || !canvas.grid || !canvas.dimensions) return -1;

    const segments = DDBEffectHelper._getDistanceSegments(t1, t2, wallBlocking);
    if (segments.length === 0) return -1;

    const rayDistances = segments.map((ray) => DDBEffectHelper.simpleMeasureDistances([ray], { gridSpaces: true }));
    let distance = Math.min(...rayDistances);

    const heightDifference = DDBEffectHelper._calculateTokeHeightDifference(t1, t2);

    const distanceRule = canvas.grid.diagonalRule;
    // 5105 Alternative DMG Movement
    // 555 Standard Movement
    // EUCL Euclidean Measurement
    if (["555", "5105"].includes(distanceRule)) {
      let nd = Math.min(distance, heightDifference);
      let ns = Math.abs(distance - heightDifference);
      distance = nd + ns;
      let dimension = canvas?.dimensions?.distance ?? 5;
      if (distanceRule === "5105") distance += Math.floor(nd / 2 / dimension) * dimension;
    } else {
      // assumes euclidean
      distance = Math.sqrt((heightDifference * heightDifference) + (distance * distance));
    }

    return distance;
  }

  static getDistance(token1, token2, wallsBlocking = false) {
    if (game.modules.get("midi-qol")?.active) {
      return MidiQOL.computeDistance(token1, token2, wallsBlocking);
    } else {
      return DDBEffectHelper.getSimpleDistance(token1, token2, wallsBlocking);
    }
  }

  /**
   * Returns the highest ability of an actor based on the given abilities.
   *
   * @param {Object} actor - The actor object.
   * @param {Array|string} abilities - The abilities array or string.
   * @return {string|undefined} - The highest ability or undefined if no abilities are provided.
   */
  static getHighestAbility(actor, abilities) {
    if (typeof abilities === "string") {
      return abilities;
    } else if (Array.isArray(abilities)) {
      return abilities.reduce((prv, current) => {
        if (actor.system.abilities[current].value > actor.system.abilities[prv].value) return current;
        else return prv;
      }, abilities[0]);
    }
    return undefined;
  }

  /**
   * Returns the race or type of the given entity.
   *
   * @param {object} entity - The entity for which to retrieve the race or type.
   * @return {string} The race or type of the entity, in lowercase.
   */
  static getRaceOrType(entity) {
    const actor = DDBEffectHelper.getActor(entity);
    const systemData = actor?.system;
    if (!systemData) return "";
    if (systemData.details.race) {
      return (systemData.details?.race?.name ?? systemData.details?.race)?.toLocaleLowerCase() ?? "";
    }
    return systemData.details.type?.value.toLocaleLowerCase() ?? "";
  }

  /**
   * Retrieves the token based on the provided token reference.
   *
   * @param {any} tokenRef - The token reference to retrieve the token from.
   * @return {Token|undefined} The retrieved token if it exists, otherwise undefined.
   */
  static getToken(tokenRef) {
    if (!tokenRef) return undefined;
    if (tokenRef instanceof Token) return tokenRef;
    if (_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].isString */ .Z.isString(tokenRef)) return (fromUuidSync(tokenRef)?.object);
    if (tokenRef instanceof TokenDocument) return tokenRef.object;
    return undefined;
  }

  /**
   * Retrieves the TokenDocument associated with the given token reference.
   *
   * @param {any} tokenRef - The token reference to retrieve the TokenDocument for.
   * @return {TokenDocument|undefined} The TokenDocument associated with the token reference, or undefined if not found.
   */
  static getTokenDocument(tokenRef) {
    if (!tokenRef) return undefined;
    if (tokenRef instanceof TokenDocument) return tokenRef;
    if (typeof tokenRef === "string") {
      const document = fromUuidSync(tokenRef);
      if (document instanceof TokenDocument) return document;
      if (document instanceof Actor) return DDBEffectHelper.getTokenForActor(document)?.document;
    }
    if (tokenRef instanceof Token) return tokenRef.document;
    return undefined;
  }

  /**
   * Returns a token for the provided actor.
   *
   * @param {Actor} actor - The actor for which to retrieve the token.
   * @return {Token|undefined} The token associated with the actor, or undefined if no token is found.
   */
  static getTokenForActor(actor) {
    const tokens = actor.getActiveTokens();
    if (!tokens.length) return undefined;
    const controlled = tokens.filter((t) => t._controlled);
    return controlled.length ? controlled.shift() : tokens.shift();
  }

  /**
   * Get the image for the token.
   *
   * @param {object} token - The token for which to get the image.
   * @return {string} The image URL for the token.
   */
  static async getTokenImage(token) {
    const midiConfigSettings = game.settings.get("midi-qol", "ConfigSettings");
    let img = token.document?.texture?.src ?? token.actor.img ?? "";
    if (midiConfigSettings.usePlayerPortrait && token.actor.type === "character") {
      img = token.actor?.img ?? token.document?.texture?.src ?? "";
    }
    if (VideoHelper.hasVideoExtension(img)) {
      img = await game.video.createThumbnail(img, { width: 100, height: 100 });
    }
    return img;
  }

  /**
   * Retrieves the type or race of the given entity.
   *
   * @param {any} entity - The entity to retrieve the type or race from.
   * @return {string} The type or race of the entity, in lowercase. If the type or race is not available, an empty string is returned.
   */
  static getTypeOrRace(entity) {
    const actor = DDBEffectHelper.getActor(entity);
    const systemData = actor?.system;
    if (!systemData) return "";
    if (systemData.details.type?.value) {
      return systemData.details.type?.value.toLocaleLowerCase() ?? "";
    }
    return (systemData.details?.race?.name ?? systemData.details?.race)?.toLocaleLowerCase() ?? "";
  }

  /**
 * Returns a new duration which reflects the remaining duration of the specified one.
 *
 * @param {*} duration the source duration
 * @returns a new duration which reflects the remaining duration of the specified one.
 */
  static getRemainingDuration(duration) {
    const newDuration = {};
    if (duration.type === "seconds") {
      newDuration.seconds = duration.remaining;
    } else if (duration.type === "turns") {
      const remainingRounds = Math.floor(duration.remaining);
      const remainingTurns = (duration.remaining - remainingRounds) * 100;
      newDuration.rounds = remainingRounds;
      newDuration.turns = remainingTurns;
    }
    return newDuration;
  }


  /**
   * Returns true if the attack is a ranged weapon attack that hit. It also supports melee weapons
   * with the thrown property.
   * @param {*} macroData the midi-qol macro data.
   * @returns true if the attack is a ranged weapon attack that hit
   */
  static isRangedWeaponAttack(macroData) {
    if (macroData.hitTargets.length < 1) {
      return false;
    }
    if (macroData.item?.system.actionType === "rwak") {
      return true;
    }
    if (macroData.item?.system.actionType !== "mwak" || !macroData.item?.system.properties?.thr) {
      return false;
    }

    const sourceToken = canvas.tokens?.get(macroData.tokenId);
    const targetToken = macroData.hitTargets[0].object;
    const distance = MidiQOL.computeDistance(sourceToken, targetToken, true);
    const meleeDistance = 5; // Would it be possible to have creatures with reach and thrown weapon?
    return distance >= 0 && distance > meleeDistance;
  }

  /**
   * Check if actor a is smaller than b based on their sizes.
   *
   * @param {type} a
   * @param {type} b
   * @return {boolean} true if a is smaller than b, false otherwise
   */
  static isSmaller (a, b) {
    const sizeA = _dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].SIZES.find */ .Z.SIZES.find((s) => s.value === a.system.traits.size)?.size;
    const sizeB = _dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].SIZES.find */ .Z.SIZES.find((s) => s.value === b.system.traits.size)?.size;
    return sizeA < sizeB;
  }

  /**
   * If the requirements are met, returns true, false otherwise.
   *
   * @returns true if the requirements are met, false otherwise.
   */
  static requirementsSatisfied(name, dependencies) {
    let missingDep = false;
    dependencies.forEach((dep) => {
      if (!game.modules.get(dep)?.active) {
        const errorMsg = `${name}: ${dep} must be installed and active.`;
        ui.notifications.error(errorMsg);
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn(errorMsg);
        missingDep = true;
      }
    });
    return !missingDep;
  }

  /**
   * Asynchronously rolls a saving throw for an item.
   *
   * @param {Object} item - The item for which the saving throw is rolled
   * @param {Object} targetToken - The token representing the target of the saving throw
   * @param {Object} [workflow=null] - The workflow for which the saving throw is rolled
   * @return {Promise} A promise that resolves with the save result
   */
  static async rollSaveForItem(item, targetToken, workflow = null) {
    const { ability, dc } = foundry.utils.duplicate(item.system.save);
    const userID = MidiQOL.playerForActor(targetToken.actor)?.active
      ? MidiQOL.playerForActor(targetToken.actor).id
      : game.users.activeGM.id;
    const data = {
      request: "save",
      targetUuid: targetToken.document.uuid,
      ability,
      options: {
        name: "Reflect",
        skipDialogue: true,
        targetValue: dc,
      },
    };

    const save = await MidiQOL.socket().executeAsUser("rollAbility", userID, data);
    if (workflow) workflow.saveResults.push(save);
    return save;
  }


  /**
   * Selects all the tokens that are within X distance of the source token for the current game user.
   * @param {Token} sourceToken the reference token from which to compute the distance.
   * @param {number} distance the distance from the reference token.
   * @param {boolean} includeSource flag to indicate if the reference token should be included or not in the selected targets.
   * @returns an array of Token instances that were selected.
   */
  static selectTargetsWithinX(sourceToken, distance, includeSource) {
    let aoeTargets = MidiQOL.findNearby(null, sourceToken, distance);
    if (includeSource) {
      aoeTargets.unshift(sourceToken);
    }
    const aoeTargetIds = aoeTargets.map((t) => t.document.id);
    game.user?.updateTokenTargets(aoeTargetIds);
    game.user?.broadcastActivity({ aoeTargetIds });
    return aoeTargets;
  }

  static updateUserTargets(targets) {
    game.user.updateTokenTargets(targets);
  }

  static async wait(ms) {
    return new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
  }

  static isConditionEffectAppliedAndActive(condition, actor) {
    return DDBEffectHelper.getActorEffects(actor).some(
      (activeEffect) =>
        (activeEffect?.name.toLowerCase() == condition.toLowerCase())
        && !activeEffect?.disabled
    );
  }

  static getConditionEffectAppliedAndActive(condition, actor) {
    return DDBEffectHelper.getActorEffects(actor).find(
      (activeEffect) =>
        (activeEffect?.name.toLowerCase() == condition.toLowerCase())
        && !activeEffect?.disabled
    );
  }

  static async removeCondition({ actor, actorUuid, conditionName, level = null } = {}) {
    if (!actor) actor = await fromUuid(actorUuid);
    if (!actor) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error("No actor passed to remove condition");
      return;
    }
    const condition = CONFIG.statusEffects.find((se) => se.name.toLowerCase() === conditionName.toLowerCase());

    if (!condition) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`Condition ${conditionName} not found`);
      return;
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`removing ${condition.name}`, { condition });
    const existing = actor.document?.effects?.get(game.dnd5e.utils.staticID(`dnd5e${condition.id}`));
    if (existing) await existing.delete();
    if (condition.id === "exhaustion") {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Reducing exhaustion", level);
      await actor.update({ "system.attributes.exhaustion": level ?? 0 });
    }
  }

  static async addCondition({ conditionName, actor, actorUuid, level = null, origin = null } = {}) {
    if (!actor) actor = await fromUuid(actorUuid);
    if (!actor) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error("No actor passed to remove condition");
      return;
    }

    const condition = CONFIG.statusEffects.find((se) => se.name.toLowerCase() === conditionName.toLowerCase());

    if (!condition) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`Condition ${conditionName} not found`);
      return;
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`adding ${condition.name}`, { condition });
    const effect = await ActiveEffect.implementation.fromStatusEffect(condition.id);
    if (condition.level) effect.updateSource({ [`flags.dnd5e.${condition.id}Level`]: condition.level });
    effect.updateSource({ origin });
    const effectData = effect.toObject();
    await actor.createEmbeddedDocuments("ActiveEffect", [effectData], { keepId: true });
    if (condition.foundry === "exhaustion") {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Updating actor exhaustion", level);
      await actor.update({ "system.attributes.exhaustion": level ?? 1 });
    }
  }

  static async adjustCondition({ add = false, remove = false, actor, conditionName, level = null, origin = null } = {}) {
    const gmUser = game.users.find((user) => user.active && user.isGM);
    if (!gmUser) {
      ui.notifications.error("No GM user found, unable to adjust condition");
      return;
    }
    if (!add && !remove) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn("You must specify if you want to add or remove the condition");
      return;
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Adjusting condition", { add, remove, actor, conditionName, level, origin });
    if (remove) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Removing condition", { actor, conditionName, level });
      await globalThis.DDBImporter.socket.executeAsGM("removeCondition", { actorUuid: actor.uuid, conditionName, level });
    }
    if (add) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Adding condition", { actor, conditionName, level, origin });
      await globalThis.DDBImporter.socket.executeAsGM("addCondition", { actorUuid: actor.uuid, conditionName, level, origin });
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Condition adjusted", { add, remove, actor, conditionName, level, origin });

  }

  static extractListItems(text, { type = "ol", titleType = "em" } = {}) {
    const results = [];
    const parsedDoc = _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].htmlToDoc */ .Z.htmlToDoc(text);
    const list = parsedDoc.body.querySelector(type);
    if (list) {
      const listItems = list.querySelectorAll('li');
      listItems.forEach((item, index) => {
        // console.log('Item ' + (index + 1) + ': ' + item.textContent);
        const title = item.querySelector(titleType);
        const content = title.nextSibling;
        results.push({
          number: index + 1,
          title: title.textContent.replace(/\.$/, "").trim(),
          content: content.innerHTML ?? content.wholeText ?? content.textContent,
          full: item.innerHTML,
        });
      });
    }
    if (results.length > 0) return results;
    return DDBEffectHelper.extractParagraphItems(text, { titleType });
  }

  static extractParagraphItems(text, { type = "p", titleType = "em" } = {}) {
    const results = [];
    const parsedDoc = _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].htmlToDoc */ .Z.htmlToDoc(text);

    const listItems = parsedDoc.querySelectorAll(type);
    let i = 1;
    for (const item of listItems) {
      const title = item.querySelector(titleType);
      // eslint-disable-next-line no-continue
      if (!title) continue;
      const content = title.nextSibling;
      results.push({
        number: i,
        title: title.textContent.replace(/\.$/, "").trim(),
        content: content.innerHTML?.trim() ?? content.wholeText?.trim() ?? content.textContent?.trim(),
        full: item.innerHTML,
      });
      i++;
    }

    return results;
  }

  static async _verySimpleDamageRollToChat({ actor, flavor, formula, damageType = "damage", item, itemId, itemUuid } = {}) {
    const roll = new CONFIG.Dice.DamageRoll(formula, {}, { type: damageType });
    await roll.evaluate({ async: true });

    if (!item && itemId && !itemUuid && actor) {
      item = actor.getEmbeddedDocument("Item", itemId);
    }
    if (!item && itemUuid && actor) {
      item = await fromUuid(itemUuid);
    }

    if (item && !itemId) itemId = item._id;
    if (item && !itemUuid) itemUuid = item.uuid;

    roll.toMessage({
      speaker: ChatMessage.getSpeaker({ actor }),
      flavor,
      "flags.dnd5e": {
        targets: CONFIG.Item.documentClass._formatAttackTargets(),
        roll: {
          type: "damage",
          itemId,
          itemUuid,
        }
      },

    });
  }

  static async simpleDamageRollToChat({ event = undefined, actor, flavor, formulas = [], damageType = "damage", item, itemId, itemUuid, fastForward = false } = {}) {

    if (!item && itemId && !itemUuid && actor) {
      item = actor.getEmbeddedDocument("Item", itemId);
    }
    if (!item && itemUuid && actor) {
      item = await fromUuid(itemUuid);
    }

    if (item && !itemId) itemId = item._id;
    if (item && !itemUuid) itemUuid = item.uuid;

    const isHealing = damageType in CONFIG.DND5E.healingTypes;
    const title = game.i18n.localize(`DND5E.${isHealing ? "Healing" : "Damage"}Roll`);
    const rollConfig = {
      rollConfigs: [{
        parts: formulas,
        type: damageType
      }],
      flavor: flavor ?? title,
      event,
      title,
      fastForward,
      messageData: {
        "flags.dnd5e": {
          targets: CONFIG.Item.documentClass._formatAttackTargets(),
          roll: { type: "damage", itemId, itemUuid },
        },
        speaker: ChatMessage.implementation.getSpeaker()
      }
    };

    if (Hooks.call("dnd5e.preRollDamage", undefined, rollConfig) === false) return;
    const roll = await globalThis.dnd5e.dice.damageRoll(rollConfig);
    if (roll) Hooks.callAll("dnd5e.rollDamage", undefined, roll);
  }

  static syntheticItemWorkflowOptions({
    targets = undefined, showFullCard = false, useSpellSlot = false, castLevel = false, consume = false,
    configureDialog = false, targetConfirmation = undefined
  } = {}) {
    return [
      {
        showFullCard,
        createWorkflow: true,
        consumeResource: consume,
        consumeRecharge: consume,
        consumeQuantity: consume,
        consumeUsage: consume,
        consumeSpellSlot: useSpellSlot,
        consumeSpellLevel: castLevel,
        slotLevel: castLevel,
      },
      {
        targetUuids: targets,
        configureDialog,
        workflowOptions: {
          autoRollDamage: 'always',
          autoFastDamage: true,
          autoRollAttack: true,
          targetConfirmation,
        }
      }
    ];
  }
}


/***/ }),

/***/ 6516:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBMacros)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2397);
/* harmony import */ var _DDBEffectHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2010);




class DDBMacros {

  static MACROS = {
    WORLD: {
      // DARKNESS_GM: {
      //   name: "Darkness (DDB - GM)",
      //   type: "gm",
      //   file: "darkness.js",
      //   isGM: true,
      //   img: "icons/magic/unholy/orb-glowing-yellow-purple.webp",
      //   world: true,
      // },
      // CHILL_TOUCH: {
      //   name: "Chill Touch (Target effect)",
      //   type: "spell",
      //   file: "chillTouchWorld.js",
      //   isGM: false,
      //   img: "icons/magic/fire/flame-burning-hand-purple.webp",
      //   world: true,
      // },
    },
    ACTIVE_AURAS: {
      AA_ONLY: {
        name: "Active Aura Only (Generic)",
        type: "generic",
        file: "activeAuraOnly.js",
        isGM: false,
        img: null,
        world: true,
      },
      AA_ON_ENTRY: {
        name: "Active Aura Damage and Condition On Entry (Generic)",
        type: "generic",
        file: "activeAuraDamageAndConditionOnEntry.js",
        isGM: false,
        img: null,
        world: true,
      },
      AA_CONDITION_ON_ENTRY: {
        name: "Active Aura Condition On Entry (Generic)",
        type: "generic",
        file: "activeAuraConditionOnEntry.js",
        isGM: false,
        img: null,
        world: true,
      },
      AA_DAMAGE_ON_ENTRY: {
        name: "Active Aura Damage On Entry (Generic)",
        type: "generic",
        file: "activeAuraDamageOnEntry.js",
        isGM: false,
        img: null,
        world: true,
      },
    },
  };

  static async checkMacroFolder() {
    const macroFolder = game.folders.find((folder) => folder.name === "DDB Macros" && folder.type === "Macro");

    if (!macroFolder) {
      await Folder.create({
        color: "#FF0000",
        name: "DDB Macros",
        parent: null,
        type: "Macro",
      });
    }
  }

  static async configureDependencies() {
    // allow item use macros on items
    if (game.modules.get("midi-qol")?.active) {
      let midiQOLSettings = game.settings.get("midi-qol", "ConfigSettings");
      if (!midiQOLSettings.allowUseMacro) {
        midiQOLSettings.allowUseMacro = true;
        game.settings.set("midi-qol", "ConfigSettings", midiQOLSettings);
      }
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn("Midi-QOL needs to be installed for effects");
      // ui.notifications.warn("Midi-QOL needs to be installed for effects");
    }

    if (game.modules.get("itemacro")?.active && game.modules.get("dae")?.active) {
      const itemMacroSheet = game.settings.get("itemacro", "defaultmacro");
      if (itemMacroSheet) {
        game.settings.set("itemacro", "defaultmacro", false);
      }
    }

    if (game.modules.get("warpgate")?.active && _DDBEffectHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].checkJB2a */ .Z.checkJB2a(true, true, false)) {
      await _DDBEffectHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"]._createJB2aActors */ .Z._createJB2aActors("Dancing Lights", "Dancing light");
    }

    return true;
  }

  static async loadMacroFile(type, fileName, forceLoad = false, forceDDB = false) {
    const embedMacros = game.settings.get("ddb-importer", "embed-macros");
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Getting macro for ${type} ${fileName}`);
    const fileExists = forceLoad || (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge)
      ? true
      : await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fileExists */ .Z.fileExists(`[data] modules/ddb-importer/macros/${type}s`, fileName);

    let data;
    if (fileExists && (forceLoad || embedMacros) && !forceDDB) {
      const url = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getFileUrl */ .Z.getFileUrl(`[data] modules/ddb-importer/macros/${type}s`, fileName);
      const response = await fetch(url, { method: "GET" });
      data = await response.text();
    } else if (fileExists && (!embedMacros || forceDDB)) {
      data = `// Execute DDB Importer dynamic macro
return game.modules.get("ddb-importer")?.api.macros.executeMacro("${type}", "${fileName}", scope);
`;
    } else if (!fileExists) {
      data = "// Unable to load the macro file";
    }
    return data;
  }

  static generateItemMacroFlag(document, macroText) {
    const daeMacro = foundry.utils.isNewerVersion((game.modules.get("dae")?.version ?? 0), "11.0.21");
    const data = {
      name: document.name,
      type: "script",
      scope: "global",
      command: macroText,
    };
    const flag = daeMacro ? "flags.dae.macro" : "flags.itemacro.macro";
    foundry.utils.setProperty(document, flag, data);
    return document;
  }

  static async setItemMacroFlag(document, macroType, macroName) {
    const useDDBFunctions = game.settings.get("ddb-importer", "no-item-macros");
    if (!useDDBFunctions) {
      const itemMacroText = await DDBMacros.loadMacroFile(macroType, macroName);
      document = DDBMacros.generateItemMacroFlag(document, itemMacroText);
    }
    return document;
  }

  static generateMacroChange({ macroValues = "", macroType = null, macroName = null, keyPostfix = "", priority = 20 } = {}) {
    const useDDBFunctions = game.settings.get("ddb-importer", "no-item-macros");
    const macroKey = (useDDBFunctions)
      ? `macro.execute`
      : "macro.itemMacro";
    const macroValuePrefix = (useDDBFunctions)
      ? `function.DDBImporter.lib.DDBMacros.macroFunction.${macroType}("${macroName}") `
      : "";

    return {
      key: `${macroKey}${keyPostfix}`,
      value: `${macroValuePrefix}${macroValues}`,
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: priority,
    };
  }

  static generateMidiOnUseMacroFlagValue(macroType, macroName, triggerPoints = [], macroUuid = null) {
    const useDDBFunctions = game.settings.get("ddb-importer", "no-item-macros");
    const docMacroName = (macroUuid && !useDDBFunctions) ? `.${macroUuid}` : "";
    const valueContent = (useDDBFunctions)
      ? `function.DDBImporter.lib.DDBMacros.macroFunction.${macroType}("${macroName}")`
      : `ItemMacro${docMacroName}`;
    return triggerPoints.map((t) => `[${t}]${valueContent}`).join(",");
  }

  static setMidiOnUseMacroFlag(document, macroType, macroName, triggerPoints = []) {
    const value = DDBMacros.generateMidiOnUseMacroFlagValue(macroType, macroName, triggerPoints);
    foundry.utils.setProperty(document, "flags.midi-qol.onUseMacroName", value);
  }

  static generateItemMacroValue({ macroType = null, macroName = null, document = null } = {}) {
    const useDDBFunctions = game.settings.get("ddb-importer", "no-item-macros");
    const docMacroName = (document && !useDDBFunctions) ? `.${document.name}` : "";
    const valueContent = (useDDBFunctions)
      ? `function.DDBImporter.lib.DDBMacros.macroFunction.${macroType}("${macroName}")`.trim()
      : `ItemMacro${docMacroName}`.trim();
    return valueContent;
  }


  static generateOnUseMacroChange({ macroPass, macroType = null, macroName = null, priority = 20, document = null, macroParams = "" } = {}) {
    const valueStub = DDBMacros.generateItemMacroValue({ macroType, macroName, document });
    const valueContent = `${valueStub},${macroPass} ${macroParams}`.trim();

    return {
      key: "flags.midi-qol.onUseMacroName",
      value: valueContent,
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: priority,
    };
  }

  static generateOptionalMacroChange({ optionPostfix, macroPass = null, macroType = null, macroName = null, priority = 20, document = null, macroParams = "" } = {}) {
    const valueStub = DDBMacros.generateItemMacroValue({ macroType, macroName, document });
    const valueContent = macroPass
      ? `${valueStub},${macroPass} ${macroParams}`.trim()
      : `${valueStub} ${macroParams}`.trim();

    return {
      key: `flags.midi-qol.optional.${optionPostfix}`,
      value: valueContent,
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: priority,
    };
  }

  static async createMacro({ name, content, img, isGM, isTemp }) {
    const macroFolder = isTemp
      ? undefined
      : game.folders.find((folder) => folder.name === "DDB Macros" && folder.type === "Macro");

    const data = {
      name: name,
      type: "script",
      img: img ? img : "icons/svg/dice-target.svg",
      scope: "global",
      command: content,
      folder: macroFolder ? macroFolder.id : undefined,
      flags: {
        "advanced-macros": {
          runAsGM: isGM,
          runForSpecificUser: "",
        },
      },
      ownership: {
        default: isGM ? 0 : 2,
      },
    };

    const existingMacro = game.macros.find((m) => m.name == name);
    if (existingMacro) data._id = existingMacro.id;
    const macro = existingMacro
      ? existingMacro.update(data)
      : Macro.create(data, { displaySheet: false, temporary: isTemp });

    return macro;

  }

  static async createWorldMacros() {
    if (game.user.isGM) {
      await DDBMacros.checkMacroFolder();

      const worldMacros = [].concat(
        Object.values(DDBMacros.MACROS.WORLD),
        // Object.values(DDBMacros.MACROS.ACTIVE_AURAS),
      ).filter((m) => m.world);

      for (const macro of worldMacros) {
        const macroFile = await DDBMacros.loadMacroFile(macro.type, macro.file, true);

        if (macroFile) {
          await DDBMacros.createMacro({ name: macro.name, content: macroFile, img: macro.img, isGM: macro.isGM, isTemp: false });
        }
      }
    }
  }


  static async getMacroBody(type, fileName) {
    const macroText = await DDBMacros.loadMacroFile(type, fileName, true);
    if (!macroText) {
      ui.notifications.error(`Unable to load macro (${type}) ${fileName}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Unable to load macro (${type}) ${fileName}`);
      throw new Error(`Unable to load macro (${type}) ${fileName}`);
    }
    return macroText;
  }

  static _getMacroFileNameFromName(name) {
    const strippedName = name.split(".js")[0]; // sanitise name
    const fileName = `${strippedName}.js`;
    return {
      name: strippedName,
      fileName: fileName,
    };
  }

  static async loadDDBMacroToConfig(type, name, fileName) {
    const macroText = await DDBMacros.getMacroBody(type, fileName);
    const macro = await DDBMacros.createMacro({ name: `${type} ${fileName}`, content: macroText, img: null, isGM: false, isTemp: true });
    foundry.utils.setProperty(CONFIG.DDBI.MACROS, `${type}.${name}`, macro);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Macro (${type}) ${fileName} loaded from file into cache`, macro);
    return macro;
  }


  static async getMacro(type, name) {
    const names = DDBMacros._getMacroFileNameFromName(name);
    const macro = CONFIG.DDBI.MACROS[type]?.[names.name]
      ?? (await DDBMacros.loadDDBMacroToConfig(type, names.name, names.fileName));
    return macro;
  }

  static async executeDDBMacro(type, name, ...params) {
    // console.warn("executeDDBMacro", {type, name, parms: [...params] });
    const macro = await DDBMacros.getMacro(type, name);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Calling (${type}) macro "${name}" with spread params`, ...params);
    return macro.execute(...params);
  }

  /**
   * Expose some useful things in a macro.
   * @param {ActiveEffect} effect
   * @returns {object}
   */
  static _getEffectVariables(effect) {
    const actor = effect.parent instanceof Actor
      ? effect.parent
      : effect.parent.parent ?? null;
    const token = actor?.token?.object ?? actor?.getActiveTokens()[0] ?? null;
    const scene = token?.scene ?? game.scenes.active ?? null;
    const origin = effect.origin ? fromUuidSync(effect.origin) : null;
    const speaker = actor ? ChatMessage.implementation.getSpeaker({ actor }) : {};
    const item = effect.parent instanceof Item ? effect.parent : null;
    return {
      actor,
      token,
      speaker,
      scene,
      origin,
      effect,
      item,
    };
  }

  /**
   * Exectutes a DDB Macro as GM, don't pass in world objects like actors
   * ids = { actor, effect, token}
   */
  static async executeDDBMacroAsGM(type, name, ids = {}, ...params) {
    const gmUser = game.users.find((user) => user.active && user.isGM);
    if (!gmUser) {
      ui.notifications.error("No GM user found");
      return undefined;
    }
    if (game.user.isGM) {
      return DDBMacros.executeDDBMacro(type, name, ...params);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Executing macro as GM", { type, name, ids, params });
      const result = await globalThis.DDBImporter.socket.executeAsGM("ddbMacroFunction", type, name, {}, ids, ...params);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("GM Macro Result", result);
      return result;
    }
  }

  static getMacroFunction(type, name) {
    const macroFunction = async (...params) => {
      const macro = await DDBMacros.getMacro(type, name);
      return macro.execute(...params);
    };
    return macroFunction;
  }

  static macroFunction = {
    spell: (name) => DDBMacros.getMacroFunction("spell", name),
    feat: (name) => DDBMacros.getMacroFunction("feat", name),
    gm: (name) => DDBMacros.getMacroFunction("gm", name),
    item: (name) => DDBMacros.getMacroFunction("item", name),
    monsterFeature: (name) => DDBMacros.getMacroFunction("monsterFeature", name),
    generic: (name) => DDBMacros.getMacroFunction("generic", name),
  };

}


/***/ }),

/***/ 4536:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBSimpleMacro)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _DDBMacros_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6516);




/**
 * This class helps execute DDB Macros and is mainl
 */
class DDBSimpleMacro {

  static MACROS = {
    "feat": {
      "lay-on-hands": {
        name: "layOnHands",
        label: "Lay On Hands Macro"
      },
      "arcane-recovery": {
        name: "arcaneRecovery",
        label: "Arcane Recovery Macro"
      },
      "font-of-magic": {
        name: "fontOfMagic",
        label: "Font of Magic Macro",
      },
      "convert-sorcery-points": {
        name: "fontOfMagic",
        label: "Font of Magic Macro",
      },
    },
    "item": {
      "spell-refuleing-ring": {
        name: "spellRefuelingRing",
        label: "Spell Refueling Macro",
      }
    }
  };

  static getDescriptionAddition(name, type, params) {
    const safeName = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].referenceNameString */ .Z.referenceNameString(name).toLowerCase();
    const macroDetails = foundry.utils.getProperty(DDBSimpleMacro.MACROS, `${type}.${safeName}`);
    if (!macroDetails) return "";

    const parameters = params
      ? params
      : (macroDetails.parameters ?? "");

    return `<br><p>[[/ddbifunc functionName="${macroDetails.name ?? safeName}" functionType="${type}" functionParams="${parameters}"]]{${macroDetails.label}}</div></p>`;
  }


  /**
   * Executes a DDB macro function.
   *
   * @param {string} type - The type of the macro. e.g. gm
   * @param {string} name - The name of the macro. e.g. test
   * @param {object} context - The context object.
   * @param {object} ids - An object of ids you wish to resolve for the macro to run
   * @param {object} scope - ANy additional information/parameters in an object to pass to the macro
   * @return {Promise<any>} The result of the macro function.
   */
  static async execute(type, name, context = {}, ids = {}, { ...scope } = {}) {
    const names = _DDBMacros_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"]._getMacroFileNameFromName */ .Z._getMacroFileNameFromName(name);
    const script = await _DDBMacros_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getMacroBody */ .Z.getMacroBody(type, names.fileName);
    const effect = ids.effect ? await fromUuid(ids.effect) : null;
    const effectVariables = ids.effect
      ? _DDBMacros_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"]._getEffectVariables */ .Z._getEffectVariables(effect)
      : {};

    const actor = ids.actor
      ? await fromUuid(ids.actor)
      : null;
    if (actor) effectVariables.actor = actor;

    const token = ids.token
      ? await fromUuid(ids.token)
      : null;
    if (token) effectVariables.token = token;

    const item = ids.item
      ? await fromUuid(ids.item)
      : null;
    if (item) effectVariables.item = item;

    const origin = ids.origin
      ? await fromUuid(ids.origin)
      : null;
    if (origin) effectVariables.origin = origin;

    if (!effectVariables.speaker && actor) {
      const speaker = ChatMessage.implementation.getSpeaker({ actor, token });
      if (speaker) effectVariables.speaker = speaker;
    }

    effectVariables.character = game.user.character;
    effectVariables.scope = scope;
    foundry.utils.setProperty(effectVariables.scope, "flags.ddb-importer.ddbMacroFunction", true);

    const variables = foundry.utils.mergeObject(effectVariables, scope);

    // eslint-disable-next-line no-empty-function
    const AsyncFunction = (async function() {}).constructor;
    // eslint-disable-next-line no-new-func
    const fn = new AsyncFunction(...Object.keys(variables), `{${script}\n}`);

    try {
      const result = await fn.call(context, ...Object.values(variables));
      return result;
    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(err);
      return null;
    }
  }


}


/***/ }),

/***/ 2877:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AD": () => (/* binding */ generateBonusACEffect),
/* harmony export */   "LY": () => (/* binding */ generateFixedACEffect),
/* harmony export */   "qI": () => (/* binding */ generateACEffectChangesForItem),
/* harmony export */   "se": () => (/* binding */ generateBaseACItemEffect)
/* harmony export */ });
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1438);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _effects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5751);





// // ac -
// { type: "bonus", subType: "armor-class" },
// // e.g. robe of the archm
// { type: "set", subType: "unarmored-armor-class" },
// // bracers of defence
// { type: "bonus", subType: "unarmored-armor-class" },

/**
 *
 * @param {*} label
 */
function buildBaseACEffect(label) {
  let effect = {
    changes: [],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    origin: null,
    tint: "",
    disabled: true,
    transfer: true,
    selectedKey: [],
    img: "icons/svg/shield.svg",
  };
  effect.name = label;
  return effect;
}

// function maxACWrapper(formula) {
//   return `max(${formula}, @attributes.ac.armor + @attributes.ac.dex)`;
// }

/**
 *
 * Generate an effect given inputs for AC
 * This is a high priority set effect that will typically override all other AE.
 * @param {*} formula
 * @param {*} label
 * @param {*} alwaysActive
 * @param {*} priority
 * @param {*} mode
 */
function generateFixedACEffect(formula, label, alwaysActive = false, priority = 30, mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE) {
  let effect = buildBaseACEffect(label);

  effect.flags = {
    dae: { transfer: true, armorEffect: true },
    ddbimporter: { disabled: !alwaysActive, itemId: null, entityTypeId: null, characterEffect: true },
  };
  // effect.disabled = !alwaysActive;
  effect.disabled = false;
  effect.origin = "AC";

  const formulaChange = { key: "system.attributes.ac.formula", value: formula, mode, priority };
  const calcChange = { key: "system.attributes.ac.calc", value: "custom", mode, priority };
  effect.changes.push(calcChange, formulaChange);

  return effect;
}

/**
 * Generate stat sets
 *
 * @param {*} modifiers
 * @param {*} name
 * @param {*} subType
 */
function addACSetEffect(modifiers, name, subType) {
  let bonuses;

  if (modifiers.some((mod) => mod.statId !== null && mod.type === "set" && mod.subType === subType)) {
    modifiers.filter((mod) => mod.statId !== null && mod.type === "set" && mod.subType === subType)
      .forEach((mod) => {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === mod.statId);
        if (bonuses) {
          bonuses += " ";
        } else {
          bonuses = "";
        }
        bonuses += `@abilities.${ability.value}.mod`;
      });
  } else {
    // others are picked up here e.g. Draconic Resilience
    const fixedValues = modifiers.filter((mod) => mod.type === "set" && mod.subType === subType).map((mod) => mod.value);
    bonuses = Math.max(fixedValues);
  }

  let effects = [];
  const maxDexTypes = ["ac-max-dex-unarmored-modifier", "ac-max-dex-modifier"];

  if (bonuses && bonuses != 0) {
    const bonusSum = Number.isInteger(bonuses) ? 10 + bonuses : `10 + ${bonuses}`;
    let formula = "";
    switch (subType) {
      case "unarmored-armor-class": {
        let maxDexMod = 99;
        const ignoreDexMod = modifiers.some((mod) => mod.type === "ignore" && mod.subType === "unarmored-dex-ac-bonus");
        const maxDexArray = modifiers
          .filter((mod) => mod.type === "set" && maxDexTypes.includes(mod.subType))
          .map((mod) => mod.value);
        if (maxDexArray.length > 0) maxDexMod = Math.min(maxDexArray);
        if (ignoreDexMod) {
          formula = `${bonusSum}`;
        } else if (maxDexMod === 99) {
          formula = `${bonusSum} + @abilities.dex.mod`;
        } else {
          // formula = `@abilities.dex.mod > ${maxDexMod} ? ${bonusSum} + ${maxDexMod} : ${bonusSum} + @abilities.dex.mod`;
          formula = `min(${bonusSum} + ${maxDexMod}, ${bonusSum} + @abilities.dex.mod)`;
        }
        break;
      }
      default: {
        formula = `${bonusSum} + @abilities.dex.mod`;
      }
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating ${subType} AC set for ${name}: ${formula}`);
    effects.push(
      {
        key: "system.attributes.ac.formula",
        value: formula,
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        priority: 15,
      },
      {
        key: "system.attributes.ac.calc",
        value: "custom",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        priority: 15,
      },
    );
  }
  return effects;
}

/**
 *
 * @param {*} modifiers
 * @param {*} name
 */
function addACSets(modifiers, name) {
  let changes = [];
  const stats = ["unarmored-armor-class"];
  stats.forEach((set) => {
    const result = addACSetEffect(modifiers, name, set);
    changes = changes.concat(result);
  });

  return changes;
}

/**
 * Generates an AC bonus for an item
 *
 * @param {*} modifiers
 * @param {*} name
 * @param {*} subType
 */
function addACBonusEffect(modifiers, name, subType, restrictions = ["while wearing heavy armor", "while not wearing heavy armor", "", null]) {
  const bonusModifiers = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].filterModifiersOld */ .Z.filterModifiersOld(modifiers, "bonus", subType, restrictions);
  const changes = (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .addAddBonusEffect */ .cF)(bonusModifiers, name, subType, "system.attributes.ac.bonus");
  if (changes.length > 0) _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating ${subType} bonus for ${name}`);

  return changes;
}


/**
 *
 * Generate an effect given inputs for AC
 * This is a high priority set effect that will typically override all other AE.
 * @param {*} formula
 * @param {*} label
 * @param {*} alwaysActive
 * @param {*} priority
 * @param {*} mode
 */
function generateBonusACEffect(modifiers, label, subType, restrictions = [], alwaysActive = true) {
  let effect = buildBaseACEffect(label);

  effect.flags = {
    dae: { transfer: true, armorEffect: true },
    ddbimporter: { disabled: !alwaysActive, itemId: null, entityTypeId: null, characterEffect: true },
  };
  // effect.disabled = !alwaysActive;
  effect.disabled = false;
  effect.origin = "AC";

  const changes = addACBonusEffect(modifiers, label, subType, restrictions);
  if (changes.length > 0) effect.changes = changes;

  return effect;
}

function addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem) {
  if (
    isCompendiumItem
    || foundryItem.type === "feat"
    || (ddbItem.isAttuned && ddbItem.equipped) // if it is attuned and equipped
    || (ddbItem.isAttuned && !ddbItem.definition.canEquip) // if it is attuned but can't equip
    || (!ddbItem.definition.canAttune && ddbItem.equipped) // can't attune but is equipped
  ) {
    foundry.utils.setProperty(foundryItem, "flags.dae.alwaysActive", false);
    foundry.utils.setProperty(effect, "flags.ddbimporter.disabled", false);
    effect.disabled = false;
  } else {
    effect.disabled = true;
    foundry.utils.setProperty(effect, "flags.ddbimporter.disabled", true);
    foundry.utils.setProperty(foundryItem, "flags.dae.alwaysActive", false);
  }

  foundry.utils.setProperty(effect, "flags.ddbimporter.itemId", ddbItem.id);
  foundry.utils.setProperty(effect, "flags.ddbimporter.itemEntityTypeId", ddbItem.entityTypeId);
  // set dae flag for active equipped
  if (ddbItem.definition?.canEquip || ddbItem.definition?.canAttune) {
    foundry.utils.setProperty(foundryItem, "flags.dae.activeEquipped", true);
  } else {
    foundry.utils.setProperty(foundryItem, "flags.dae.activeEquipped", false);
  }

  return [foundryItem, effect];
}

function generateBaseACEffectChanges(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;
  // const noACValue = !foundryItem.system?.armor?.value;

  // note: I don't know why I had noACValue here. does this break stuff if I remove it?
  // if (noModifiers && noACValue) return [];
  if (noModifiers) return [];
  // console.error(`Item: ${foundryItem.name}`, ddbItem);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating supported AC changes for ${foundryItem.name} for effect ${effect.name}`);

  // base ac from modifiers
  const acSets = addACSets(ddbItem.definition.grantedModifiers, foundryItem.name);

  // ac bonus effects
  const acBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "armor-class",
  );
  const unarmoredACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "unarmored-armor-class",
  );
  const armoredACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "armored-armor-class",
  );
  const dualWieldACBonus = addACBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "dual-wield-armor-class",
  );

  const acChanges = [
    ...acSets,
    ...acBonus,
    ...unarmoredACBonus,
    ...armoredACBonus,
    ...dualWieldACBonus,
  ];

  return acChanges;

}

// generates changes and adds to effect for item
function generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;

  if (noModifiers) return [foundryItem, effect];

  const acChanges = generateBaseACEffectChanges(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);

  if (acChanges.length === 0) return [foundryItem, effect]; ;

  effect.changes = effect.changes.concat(acChanges);

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem);

  return [foundryItem, effect];

}

/**
 *
 * @param {*} ddb
 * @param {*} character
 * @param {*} ddbItem
 * @param {*} foundryItem
 * @param {*} isCompendiumItem
 */
function generateBaseACItemEffect(ddb, character, ddbItem, foundryItem, isCompendiumItem) {
  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;
  const noACValue = !foundryItem.system?.armor?.value;

  if (noModifiers && noACValue) return foundryItem;
  // console.error(`Item: ${foundryItem.name}`, ddbItem);
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating supported AC effects for ${foundryItem.name}`);

  let effect = (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .baseItemEffect */ .uT)(foundryItem, `${foundryItem.name} (AC)`);

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);

  if (effect.changes?.length > 0) {
    if (!foundryItem.effects) foundryItem.effects = [];
    foundryItem.effects.push(effect);
  }
  return foundryItem;
}


/***/ }),

/***/ 5751:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "cF": () => (/* binding */ addAddBonusEffect),
  "x8": () => (/* binding */ addSimpleConditionEffect),
  "sb": () => (/* binding */ addStatusEffectChange),
  "VN": () => (/* binding */ applyDefaultMidiFlags),
  "mS": () => (/* binding */ baseEffect),
  "yN": () => (/* binding */ baseEnchantmentEffect),
  "uT": () => (/* binding */ baseItemEffect),
  "xV": () => (/* binding */ effectModules),
  "Wk": () => (/* binding */ forceItemEffect),
  "pi": () => (/* binding */ forceManualReaction),
  "Ci": () => (/* binding */ generateATLChange),
  "Tb": () => (/* binding */ generateBaseSkillEffect),
  "wv": () => (/* binding */ generateCustomChange),
  "K7": () => (/* binding */ generateEffects),
  "zs": () => (/* binding */ generateMultiplyChange),
  "Pk": () => (/* binding */ generateOverrideChange),
  "f6": () => (/* binding */ generateStatusEffectChange),
  "UY": () => (/* binding */ generateTokenMagicFXChange),
  "Tq": () => (/* binding */ generateUnsignedAddChange),
  "OY": () => (/* binding */ generateUpgradeChange),
  "qk": () => (/* binding */ getEffectExcludedModifiers),
  "OJ": () => (/* binding */ getGenericConditionAffectData)
});

// UNUSED EXPORTS: generateChange, generateCustomBonusChange, generateDowngradeChange, generateSignedAddChange, getMidiCEOnFlags

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/effects/specialEquipment.js + 6 modules
var specialEquipment = __webpack_require__(7309);
;// CONCATENATED MODULE: ./src/effects/specialInfusions.js
// import {
//   baseItemEffect,
//   generateUpgradeChange,
//   generateAddChange,
//   generateMultiplyChange,
//   generateCustomChange,
// } from "./effects.js";

/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
function infusionEffectAdjustment(document) {

  return document;
}

// EXTERNAL MODULE: ./src/effects/acEffects.js
var acEffects = __webpack_require__(2877);
// EXTERNAL MODULE: ./src/parser/DDBCharacter.js + 10 modules
var DDBCharacter = __webpack_require__(3163);
;// CONCATENATED MODULE: ./src/effects/effects.js









/**
 * Add supported effects here to exclude them from calculations.
 */
const EFFECT_EXCLUDED_COMMON_MODIFIERS = [
  { type: "bonus", subType: "saving-throws" },
  { type: "bonus", subType: "ability-checks" },
  { type: "bonus", subType: "skill-checks" },
  { type: "bonus", subType: "proficiency-bonus" },

  { type: "set", subType: "strength-score" },
  { type: "set", subType: "dexterity-score" },
  { type: "set", subType: "constitution-score" },
  { type: "set", subType: "wisdom-score" },
  { type: "set", subType: "intelligence-score" },
  { type: "set", subType: "charisma-score" },

  // skills
  { type: "bonus", subType: "acrobatics" },
  { type: "bonus", subType: "animal-handling" },
  { type: "bonus", subType: "arcana" },
  { type: "bonus", subType: "athletics" },
  { type: "bonus", subType: "deception" },
  { type: "bonus", subType: "history" },
  { type: "bonus", subType: "insight" },
  { type: "bonus", subType: "intimidation" },
  { type: "bonus", subType: "investigation" },
  { type: "bonus", subType: "medicine" },
  { type: "bonus", subType: "nature" },
  { type: "bonus", subType: "perception" },
  { type: "bonus", subType: "performance" },
  { type: "bonus", subType: "persuasion" },
  { type: "bonus", subType: "religion" },
  { type: "bonus", subType: "sleight-of-hand" },
  { type: "bonus", subType: "stealth" },
  { type: "bonus", subType: "survival" },

  { type: "advantage", subType: "acrobatics" },
  { type: "advantage", subType: "animal-handling" },
  { type: "advantage", subType: "arcana" },
  { type: "advantage", subType: "athletics" },
  { type: "advantage", subType: "deception" },
  { type: "advantage", subType: "history" },
  { type: "advantage", subType: "insight" },
  { type: "advantage", subType: "intimidation" },
  { type: "advantage", subType: "investigation" },
  { type: "advantage", subType: "medicine" },
  { type: "advantage", subType: "nature" },
  { type: "advantage", subType: "perception" },
  { type: "advantage", subType: "performance" },
  { type: "advantage", subType: "persuasion" },
  { type: "advantage", subType: "religion" },
  { type: "advantage", subType: "sleight-of-hand" },
  { type: "advantage", subType: "stealth" },
  { type: "advantage", subType: "survival" },


  { type: "bonus", subType: "passive-insight" },
  { type: "bonus", subType: "passive-investigation" },
  { type: "bonus", subType: "passive-perception" },
  // advantage on skills - not added here as not used elsewhere in importer.
  // { type: "advantage", subType: "acrobatics" },

  // initiative
  { type: "advantage", subType: "initiative" },
  { type: "bonus", subType: "initiative" },

  { type: "bonus", subType: "strength-ability-checks" },
  { type: "bonus", subType: "dexterity-ability-checks" },
  { type: "bonus", subType: "constitution-ability-checks" },
  { type: "bonus", subType: "wisdom-ability-checks" },
  { type: "bonus", subType: "intelligence-ability-checks" },
  { type: "bonus", subType: "charisma-ability-checks" },

  { type: "bonus", subType: "strength-saving-throws" },
  { type: "bonus", subType: "dexterity-saving-throws" },
  { type: "bonus", subType: "constitution-saving-throws" },
  { type: "bonus", subType: "wisdom-saving-throws" },
  { type: "bonus", subType: "intelligence-saving-throws" },
  { type: "bonus", subType: "charisma-saving-throws" },

  // attack modifiers
  { type: "bonus", subType: "weapon-attacks" },
  { type: "bonus", subType: "melee-attacks" },
  { type: "bonus", subType: "ranged-attacks" },
  { type: "bonus", subType: "melee-weapon-attacks" },
  { type: "bonus", subType: "ranged-weapon-attacks" },
  { type: "damage", subType: null },

  // spell modifiers
  { type: "bonus", subType: "spell-save-dc" },
  { type: "bonus", subType: "spell-attacks" },
  { type: "bonus", subType: "melee-spell-attacks" },
  { type: "bonus", subType: "ranged-spell-attacks" },
  { type: "bonus", subType: "warlock-spell-save-dc" },
  { type: "bonus", subType: "warlock-spell-attacks" },
  { type: "bonus", subType: "spell-group-healing" }, // system.bonuses.heal.damage

  // hp modifiers
  { type: "bonus", subType: "hit-points-per-level" },
  { type: "bonus", subType: "hit-points" },

  // attunement
  { type: "set", subType: "attunement-slots" },

  // resistances - subType - e.g. poison - lookup from DICTIONARY
  { type: "resistance", subType: null },
  { type: "immunity", subType: null },
  { type: "vulnerability", subType: null },

];

const EFFECT_EXCLUDED_SENSE_MODIFIERS = [
  // senses
  { type: "set-base", subType: "darkvision" },
  { type: "sense", subType: "darkvision" },
  { type: "set-base", subType: "blindsight" },
  { type: "sense", subType: "blindsight" },
  { type: "set-base", subType: "tremorsense" },
  { type: "sense", subType: "tremorsense" },
  { type: "set-base", subType: "truesight" },
  { type: "sense", subType: "truesight" },
];

const EFFECT_EXCLUDED_SPEED_SET_MODIFIERS = [
  // speeds
  { type: "set", subType: "innate-speed-walking" },
  { type: "set", subType: "innate-speed-climbing" },
  { type: "set", subType: "innate-speed-swimming" },
  { type: "set", subType: "innate-speed-flying" },
];

const EFFECT_EXCLUDED_SPEED_BONUS_MODIFIERS = [
  { type: "bonus", subType: "speed" },
  { type: "bonus", subType: "speed-walking" },
  { type: "bonus", subType: "speed-climbing" },
  { type: "bonus", subType: "speed-swimming" },
  { type: "bonus", subType: "speed-flying" },
];

const EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS = EFFECT_EXCLUDED_SPEED_SET_MODIFIERS.concat(EFFECT_EXCLUDED_SPEED_BONUS_MODIFIERS);

const EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS = [
  { type: "bonus", subType: "unarmored-movement" },
];

const EFFECT_EXCLUDED_ALL_SPEED_MODIFIERS = EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);

const EFFECT_EXCLUDED_ABILITY_BONUSES = [
  { type: "bonus", subType: "strength-score" },
  { type: "bonus", subType: "dexterity-score" },
  { type: "bonus", subType: "constitution-score" },
  { type: "bonus", subType: "wisdom-score" },
  { type: "bonus", subType: "intelligence-score" },
  { type: "bonus", subType: "charisma-score" },
];

const EFFECT_EXCLUDED_PROFICIENCY_BONUSES = [
  // profs
  { type: "proficiency", subType: null },
];

const EFFECT_EXCLUDED_LANGUAGES_MODIFIERS = [
  // languages - e.g. dwarvish -- lookup from DICTIONARY
  { type: "language", subType: null },
];

const AC_BONUS_MODIFIERS = [
  { type: "bonus", subType: "unarmored-armor-class" },
  { type: "bonus", subType: "armor-class" },
  { type: "bonus", subType: "armored-armor-class" },
  { type: "bonus", subType: "dual-wield-armor-class" },
];

const AC_EFFECTS = [
  { type: "set", subType: "unarmored-armor-class" },
  { type: "ignore", subType: "unarmored-dex-ac-bonus" },
  { type: "set", subType: "ac-max-dex-modifier" },
];

function getEffectExcludedModifiers(type, features, ac) {
  let modifiers = [];

  if (type !== "item") {
    // features represent core non ac features
    if (features) {
      modifiers = modifiers.concat(EFFECT_EXCLUDED_COMMON_MODIFIERS, EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);
      if (!["race"].includes(type)) {
        modifiers = modifiers.concat(EFFECT_EXCLUDED_SENSE_MODIFIERS, EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS);
      }
    }
    // here ac represents the more exotic ac effects that set limits and change base
    modifiers = modifiers.concat(AC_BONUS_MODIFIERS);
    if (ac) {
      modifiers = modifiers.concat(AC_EFFECTS);
    }
  }

  // items are basically their own thing, all or nuffin
  if (type === "item") {
    modifiers = modifiers.concat(
      EFFECT_EXCLUDED_COMMON_MODIFIERS,
      EFFECT_EXCLUDED_ABILITY_BONUSES,
      EFFECT_EXCLUDED_LANGUAGES_MODIFIERS,
      EFFECT_EXCLUDED_PROFICIENCY_BONUSES,
      EFFECT_EXCLUDED_ALL_SPEED_MODIFIERS,
      AC_EFFECTS,
      AC_BONUS_MODIFIERS,
    );
  }
  return modifiers;
}

// eslint-disable-next-line complexity
function effectModules() {
  if (CONFIG.DDBI.EFFECT_CONFIG.MODULES.installedModules) {
    return CONFIG.DDBI.EFFECT_CONFIG.MODULES.installedModules;
  }
  const midiQolInstalled = game.modules.get("midi-qol")?.active ?? false;
  const timesUp = game.modules.get("times-up")?.active ?? false;
  const daeInstalled = game.modules.get("dae")?.active ?? false;
  const convenientEffectsInstalled = game.modules.get("dfreds-convenient-effects")?.active ?? false;

  const activeAurasInstalled = game.modules.get("ActiveAuras")?.active ?? false;
  const atlInstalled = game.modules.get("ATL")?.active ?? false;
  const tokenMagicInstalled = game.modules.get("tokenmagic")?.active ?? false;
  const autoAnimationsInstalled = game.modules.get("autoanimations")?.active ?? false;
  const chrisInstalled = game.modules.get("chris-premades")?.active ?? false;
  const vision5eInstalled = game.modules.get("vision-5e")?.active ?? false;
  const warpgateInstalled = game.modules.get("warpgate")?.active ?? false;

  CONFIG.DDBI.EFFECT_CONFIG.MODULES.installedModules = {
    hasCore: midiQolInstalled && timesUp && daeInstalled,
    hasMonster: midiQolInstalled && timesUp && daeInstalled,
    midiQolInstalled,
    timesUp,
    daeInstalled,
    convenientEffectsInstalled,
    atlInstalled,
    tokenMagicInstalled,
    activeAurasInstalled,
    autoAnimationsInstalled,
    chrisInstalled,
    vision5eInstalled,
    warpgateInstalled,
  };
  return CONFIG.DDBI.EFFECT_CONFIG.MODULES.installedModules;
}

function generateEffectDuration(foundryItem) {
  let duration = {
    seconds: null,
    startTime: null,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  switch (foundryItem.system?.duration?.units) {
    case "turn":
      duration.turns = foundryItem.system.duration.value;
      break;
    case "round":
      duration.rounds = foundryItem.system.duration.value;
      break;
    case "hour":
      duration.seconds = foundryItem.system.duration.value * 60 * 60;
      break;
    case "minute":
      duration.rounds = foundryItem.system.duration.value * 10;
      break;
    // no default
  }
  return duration;
}

function baseEffect(foundryItem, label,
  { transfer = true, disabled = false } = {}
) {
  let effect = {
    img: foundryItem.img,

    changes: [],
    duration: {},
    // duration: {
    //   seconds: null,
    //   startTime: null,
    //   rounds: null,
    //   turns: null,
    //   startRound: null,
    //   startTurn: null,
    // },
    tint: "",
    transfer,
    disabled,
    // origin: origin,
    flags: {
      dae: {
        transfer,
        stackable: "noneName",
        // armorEffect: true
      },
      ddbimporter: {
        disabled,
      },
      "midi-qol": { // by default force CE effect usage to off
        forceCEOff: true,
      },
      core: {},
    },
  };
  effect.name = label;
  effect.statuses = [];
  effect.duration = generateEffectDuration(foundryItem);
  return effect;
}

function baseEnchantmentEffect(foundryItem, label,
  { transfer = false, disabled = false, origin = null, id = null } = {}
) {
  const effect = baseEffect(foundryItem, label, { transfer, disabled });
  foundry.utils.setProperty(effect, "flags.dnd5e.type", "enchantment");
  foundry.utils.setProperty(effect, "flags.dnd5e.enchantment", {
    level: {
      min: null,
      max: null
    },
    riders: {
      effect: [],
      item: [],
    },
  });
  effect._id = id ?? foundry.utils.randomID();
  effect.origin = origin ?? null;
  return effect;
}

function baseItemEffect(foundryItem, label,
  { transfer = true, disabled = false } = {}
) {
  return baseEffect(foundryItem, label, { transfer, disabled });
}

function getMidiCEOnFlags(midiFlags = {}) {
  foundry.utils.setProperty(midiFlags, "forceCEOff", false);
  foundry.utils.setProperty(midiFlags, "forceCEOn", true);
  return midiFlags;
}

function applyDefaultMidiFlags(document) {
  if (effectModules().midiQolInstalled) {
    foundry.utils.setProperty(document, "flags.midi-qol.removeAttackDamageButtons", "default");
    foundry.utils.setProperty(document, "flags.midiProperties.confirmTargets", "default");
  }
  return document;
}

function forceItemEffect(document) {
  if (document.effects.length > 0 || foundry.utils.hasProperty(document.flags, "dae") || foundry.utils.hasProperty(document.flags, "midi-qol.onUseMacroName")) {
    document = applyDefaultMidiFlags(document);
    foundry.utils.setProperty(document, "flags.ddbimporter.effectsApplied", true);
    if (!foundry.utils.getProperty(document, "flags.midi-qol.forceCEOn")) foundry.utils.setProperty(document, "flags.midi-qol.forceCEOff", true);
  }
  return document;
}

function forceManualReaction(document) {
  foundry.utils.setProperty(document, "system.activation.type", "reactionmanual");
  return document;
}

// *
// CONST.ACTIVE_EFFECT_MODES.
// ADD: 2
// CUSTOM: 0
// DOWNGRADE: 3
// MULTIPLY: 1
// OVERRIDE: 5
// UPGRADE: 4
//

function generateBaseSkillEffect(id, label) {
  const mockItem = {
    img: "icons/svg/up.svg",
  };
  let skillEffect = baseItemEffect(mockItem, label);
  skillEffect.flags.dae = {};
  skillEffect.flags.ddbimporter.characterEffect = true;
  skillEffect.origin = `Actor.${id}`;
  delete skillEffect.transfer;
  return skillEffect;
}

function generateStatusEffectChange(statusName, priority = 20) {
  return {
    key: effectModules().daeInstalled ? "macro.StatusEffect" : "statuses",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    value: statusName.toLowerCase(),
    priority: priority,
  };
}

function addStatusEffectChange(effect, statusName, priority = 20, macro = false, level = null) {
  if (effectModules().daeInstalled) {
    const key = generateStatusEffectChange(statusName, priority, macro);
    effect.changes.push(key);
  } else {
    effect.statuses.push(statusName.toLowerCase());
    if (level) foundry.utils.setProperty(effect, `flags.dnd5e.${statusName.toLowerCase().trim()}Level`, level);
  }
  return effect;
}

function generateTokenMagicFXChange(macroValue, priority = 20) {
  return {
    key: 'macro.tokenMagic',
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: macroValue,
    priority: priority,
  };
}

function generateATLChange(atlKey, mode, value, priority = 20) {
  let key = atlKey;

  switch (atlKey) {
    case 'ATL.dimLight':
      key = 'ATL.light.dim';
      break;
    case 'ATL.brightLight':
      key = 'ATL.light.bright';
      break;
    case 'ATL.lightAnimation':
      key = 'ATL.light.animation';
      break;
    case 'ATL.lightColor':
      key = 'ATL.light.color';
      break;
    case 'ATL.lightAlpha':
      key = 'ATL.light.alpha';
      break;
    case 'ATL.lightAngle':
      key = 'ATL.light.angle';
      break;
    // no default
  }

  return {
    key,
    mode,
    value,
    priority,
  };
}

function addSimpleConditionEffect(document, condition, { disabled, transfer } = {}) {
  document.effects = [];
  const effect = baseItemEffect(document, `${document.name} - ${utils/* default.capitalize */.Z.capitalize(condition)}`, { disabled, transfer });
  addStatusEffectChange(effect, condition);
  document.effects.push(effect);
  return document;
}

function generateChange(bonus, priority, key, mode) {
  return {
    key: key,
    value: bonus,
    mode: mode,
    priority: priority,
  };
}

function generateSignedAddChange(bonus, priority, key) {
  const bonusValue = (Number.isInteger(bonus) && bonus >= 0) // if bonus is a positive integer
    || (!Number.isInteger(bonus) && !bonus.trim().startsWith("+") && !bonus.trim().startsWith("-")) // not an int and does not start with + or -
    ? `+${bonus}`
    : bonus;
  return generateChange(bonusValue, priority, key, CONST.ACTIVE_EFFECT_MODES.ADD);
}

function generateUnsignedAddChange(bonus, priority, key) {
  const bonusValue = `${bonus}`.trim().replace("+ +", "+").replace(/^\+\s+/, "");
  return generateChange(bonusValue.trim(), priority, key, CONST.ACTIVE_EFFECT_MODES.ADD);
}

function generateCustomChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.CUSTOM);
}

function generateCustomBonusChange(bonus, priority, key) {
  const bonusValue = (Number.isInteger(bonus) && bonus >= 0) // if bonus is a positive integer
    || (!Number.isInteger(bonus) && !bonus.trim().startsWith("+") && !bonus.trim().startsWith("-")) // not an int and does not start with + or -
    ? `+${bonus}`
    : bonus;
  return generateChange(bonusValue, priority, key, CONST.ACTIVE_EFFECT_MODES.CUSTOM);
}

function generateUpgradeChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.UPGRADE);
}

function generateOverrideChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.OVERRIDE);
}

function generateMultiplyChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.MULTIPLY);
}

function generateDowngradeChange(bonus, priority, key) {
  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.DOWNGRADE);
}


/**
 * Generates a global add for an item
 */
function addAddBonusEffect(modifiers, name, type, key) {
  let changes = [];
  // const bonus = DDBHelper.filterModifiersOld(modifiers, "bonus", type).reduce((a, b) => a + b.value, 0);
  const bonus = DDBHelper/* default.getValueFromModifiers */.Z.getValueFromModifiers(modifiers, name, type, "bonus");
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`, bonus);
    changes.push(generateUnsignedAddChange(`+ ${bonus}`, 18, key));
  }
  return changes;
}

/**
 * Generates a global custom bonus for an item
 */
function addCustomEffect(modifiers, name, type, key, extra = "") {
  let changes = [];
  const bonus = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "bonus", type).reduce((a, b) => a + b.value, 0);
  if (bonus !== 0) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`);
    changes.push(generateCustomChange(`${bonus}${(extra) ? extra : ""}`, 18, key));
  }
  return changes;
}

//
// Generate saving throw bonuses
//
function addGlobalSavingBonusEffect(modifiers, name) {
  const type = "saving-throws";
  const key = "system.bonuses.abilities.save";
  let changes = [];
  const regularBonuses = modifiers.filter((mod) => !mod.bonusTypes?.includes(2));
  const customBonuses = modifiers.filter((mod) => mod.bonusTypes?.includes(2));

  if (customBonuses.length > 0) {
    let customEffects = addAddBonusEffect(customBonuses, name, type, key);
    changes = changes.concat(customEffects);
  }

  const regularModifiers = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(regularBonuses, "bonus", type);

  if (regularModifiers.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${type} bonus for ${name}`);
    let bonuses = "";
    regularModifiers.forEach((modifier) => {
      let bonusParse = DDBHelper/* default.extractModifierValue */.Z.extractModifierValue(modifier);
      if (bonuses !== "") bonuses += " + ";
      bonuses += bonusParse;
    });
    if (bonuses === "") bonuses = 0;
    changes.push(generateUnsignedAddChange(`+ ${bonuses}`, 20, key));
    logger/* default.debug */.Z.debug(`Changes for ${type} bonus for ${name}`, changes);
  }

  return changes;
}

/**
 * Adds languages, can't handle custom languages
 */
function addLanguages(modifiers, name) {
  let changes = [];

  const ddbCharacter = new DDBCharacter/* default */.Z();
  const languages = ddbCharacter.getLanguagesFromModifiers(modifiers);

  languages.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating language ${prof} for ${name}`);
    changes.push(generateUnsignedAddChange(prof, 0, "system.traits.languages.value"));
  });
  if (languages?.custom != "") {
    logger/* default.debug */.Z.debug(`Generating language ${languages.custom} for ${name}`);
    changes.push(generateUnsignedAddChange(languages.custom, 0, "system.traits.languages.custom"));
  }

  return changes;
}


function damageBonus(type, modifiers, name) {
  let changes = [];
  const bonus = modifiers
    .filter((mod) => mod.dice || mod.die || mod.value)
    .map((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      if (die) {
        return utils/* default.parseDiceString */.Z.parseDiceString(die.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      } else {
        return utils/* default.parseDiceString */.Z.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;
      }
    });
  if (bonus && bonus.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${type} damage for ${name}`);
    const change = generateUnsignedAddChange(`${bonus.join(" + ")}`, 22, `system.bonuses.${type}.damage`);
    changes.push(change);
  }
  return changes;
}

/**
 * Generate global damage bonuses
*/
function addGlobalDamageBonus(modifiers, name) {
  let changes = [];
  // melee restricted attacks
  const meleeRestrictions = ["Melee Weapon Attacks"];
  const meleeRestrictedMods = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "damage", null, meleeRestrictions);
  const meleeBonuses = damageBonus("mwak", meleeRestrictedMods, name);
  changes.push(...meleeBonuses);

  const rangedRestrictions = ["Ranged Weapon Attacks"];
  const rangedRestrictionMods = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "damage", null, rangedRestrictions);
  const rangedBonuses = damageBonus("rwak", rangedRestrictionMods, name);
  changes.push(...rangedBonuses);

  const DAMAGE_SUBTYPE_MAP = {
    "one-handed-melee-attacks": ["mwak"],
  };

  for (const [subtype, damageTypes] of Object.entries(DAMAGE_SUBTYPE_MAP)) {
    const subTypeMods = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "damage", subtype);
    for (const damageType of damageTypes) {
      const bonus = damageBonus(damageType, subTypeMods, name);
      changes.push(...bonus);
    }
  }

  const allBonusMods = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "damage", null)
    .filter((mod) => !Object.keys(DAMAGE_SUBTYPE_MAP).includes(mod.subType))
    .filter((mod) => mod.dice || mod.die || mod.value);
  if (allBonusMods.length > 0) {
    logger/* default.debug */.Z.debug(`Generating all damage for ${name}`);
    changes.push(...damageBonus("mwak", allBonusMods, name));
    changes.push(...damageBonus("rwak", allBonusMods, name));
  }
  return changes;
}

function addWeaponAttackBonuses(modifiers, name) {
  const meleeAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "melee-attacks",
    "system.bonuses.mwak.attack"
  );
  const rangedAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "ranged-attacks",
    "system.bonuses.rwak.attack"
  );
  const meleeWeaponAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "melee-weapon-attacks",
    "system.bonuses.mwak.attack"
  );
  const rangedWeaponAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "ranged-weapon-attacks",
    "system.bonuses.rwak.attack"
  );
  const weaponAttackMeleeBonus = addAddBonusEffect(
    modifiers,
    name,
    "weapon-attacks",
    "system.bonuses.mwak.attack"
  );
  const weaponAttackRangedBonus = addAddBonusEffect(
    modifiers,
    name,
    "weapon-attacks",
    "system.bonuses.rwak.attack"
  );
  return [
    ...meleeAttackBonus,
    ...rangedAttackBonus,
    ...meleeWeaponAttackBonus,
    ...rangedWeaponAttackBonus,
    ...weaponAttackMeleeBonus,
    ...weaponAttackRangedBonus,
  ];
}


function addSpellAttackBonuses(modifiers, name) {
  const meleeSpellAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "spell-attacks",
    "system.bonuses.msak.attack"
  );
  const melee2SpellAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "melee-spell-attacks",
    "system.bonuses.msak.attack"
  );
  const rangedSpellAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "spell-attacks",
    "system.bonuses.rsak.attack"
  );
  const ranged2SpellAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "ranged-spell-attacks",
    "system.bonuses.rsak.attack"
  );
  const warlockMeleeSpellAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "warlock-spell-attacks",
    "system.bonuses.msak.attack"
  );
  const warlockRangedSpellAttackBonus = addAddBonusEffect(
    modifiers,
    name,
    "warlock-spell-attacks",
    "system.bonuses.msak.attack"
  );
  const warlockSpellDCBonus = addAddBonusEffect(
    modifiers,
    name,
    "warlock-spell-save-dc",
    "system.bonuses.spell.dc"
  );
  const spellDCBonus = addAddBonusEffect(
    modifiers,
    name,
    "spell-save-dc",
    "system.bonuses.spell.dc"
  );
  const healingSpellBonus = addCustomEffect(
    modifiers,
    name,
    "spell-group-healing",
    "system.bonuses.heal.damage",
    " + @item.level"
  );

  return [
    ...meleeSpellAttackBonus,
    ...melee2SpellAttackBonus,
    ...rangedSpellAttackBonus,
    ...ranged2SpellAttackBonus,
    ...warlockMeleeSpellAttackBonus,
    ...warlockRangedSpellAttackBonus,
    ...warlockSpellDCBonus,
    ...spellDCBonus,
    ...healingSpellBonus,
  ];
}

// *
// Get list of generic conditions/damages
//
function getGenericConditionAffectData(modifiers, condition, typeId, forceNoMidi = false) {
  const restrictions = [
    "",
    null,
    "While within 20 feet",
    "Dwarf Only",
    "While Not Incapacitated",
    // "As an Action", this is a timed/limited effect, dealt with elsewhere
    "While Staff is Held",
    "Helm has at least one ruby remaining",
    "while holding",
    "While Held",
  ];

  const ddbAdjustments = typeId === 4
    ? [
      { id: 11, type: 4, name: "Poisoned", slug: "poison" },
      { id: 16, type: 4, name: "Diseased", slug: "diseased" },
      { id: 16, type: 4, name: "Diseased", slug: "disease" },
    ]
      .concat(CONFIG.DDB.conditions.map((a) => {
        return {
          id: a.definition.id,
          type: 4,
          name: a.definition.name,
          slug: a.definition.slug,
        };
      }))
    : CONFIG.DDB.damageAdjustments;

  const result = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, condition, null, restrictions)
    .filter((modifier) => {
      const ddbLookup = ddbAdjustments.find((d) => d.type == typeId && d.slug === modifier.subType);
      if (!ddbLookup) return false;
      return dictionary/* default.character.damageAdjustments.some */.Z.character.damageAdjustments.some((adj) =>
        adj.type === typeId
        && ddbLookup.id === adj.id
        && (foundry.utils.hasProperty(adj, "foundryValues") || foundry.utils.hasProperty(adj, "foundryValue"))
      );
    })
    .map((modifier) => {
      const ddbLookup = ddbAdjustments.find((d) => d.type == typeId && d.slug === modifier.subType);
      const entry = dictionary/* default.character.damageAdjustments.find */.Z.character.damageAdjustments.find((adj) =>
        adj.type === typeId
        && ddbLookup.id === adj.id
      );
      if (!entry) return undefined;
      const valueData = foundry.utils.hasProperty(entry, "foundryValues")
        ? foundry.utils.getProperty(entry, "foundryValues")
        : foundry.utils.hasProperty(entry, "foundryValue")
          ? { value: entry.foundryValue }
          : undefined;
      return valueData;
    })
    .filter((adjustment) => adjustment !== undefined)
    .map((result) => {
      if (game.modules.get("midi-qol")?.active && result.midiValues && !forceNoMidi) {
        return {
          value: result.value.concat(result.midiValues),
          bypass: result.bypass,
        };
      } else {
        return result;
      }
    });

  return result;
}


function addCriticalHitImmunities(modifiers, name) {
  if (!game.modules.get("midi-qol")?.active) return [];
  const result = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "immunity", "critical-hits");

  if (result.length > 0) {
    logger/* default.debug */.Z.debug(`Generating critical hit immunity for ${name}`);
    return [generateCustomChange(1, 1, "flags.midi-qol.fail.critical.all")];
  } else {
    return [];
  }
}

/**
 * Get  Damage Conditions, and Condition Immunities
 * @param {*} ddbItem
 */
function addDamageConditions(modifiers) {
  let charges = [];

  const damageImmunityData = getGenericConditionAffectData(modifiers, "immunity", 2);
  const damageResistanceData = getGenericConditionAffectData(modifiers, "resistance", 1);
  const damageVulnerabilityData = getGenericConditionAffectData(modifiers, "vulnerability", 3);

  damageImmunityData.forEach((data) => {
    if (data.value && data.value.length > 0) charges.push(generateUnsignedAddChange(data.value, 1, "system.traits.di.value"));
    if (data.bypass && data.bypass.length > 0) charges.push(generateUnsignedAddChange(data.bypass, 1, "system.traits.di.bypasses"));
  });
  damageResistanceData.forEach((data) => {
    if (data.value && data.value.length > 0) charges.push(generateUnsignedAddChange(data.value, 1, "system.traits.dr.value"));
    if (data.bypass && data.bypass.length > 0) charges.push(generateUnsignedAddChange(data.bypass, 1, "system.traits.dr.bypasses"));
  });
  damageVulnerabilityData.forEach((data) => {
    if (data.value && data.value.length > 0) charges.push(generateUnsignedAddChange(data.value, 1, "system.traits.dv.value"));
    if (data.bypass && data.bypass.length > 0) charges.push(generateUnsignedAddChange(data.bypass, 1, "system.traits.dv.bypasses"));
  });

  const conditionImmunityData = getGenericConditionAffectData(modifiers, "immunity", 4);

  conditionImmunityData.forEach((data) => {
    if (data.value && data.value.length > 0) charges.push(generateUnsignedAddChange(data.value, 1, "system.traits.ci.value"));
    if (data.bypass && data.bypass.length > 0) charges.push(generateUnsignedAddChange(data.bypass, 1, "system.traits.ci.bypasses"));
  });

  // system.traits.di.all
  const allDamageImmunity = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "immunity", "all");
  if (allDamageImmunity?.length > 0) {
    charges.push(generateUnsignedAddChange("all", 1, "system.traits.di.value"));
  }

  return charges;
}

// *
// Generate stat bonuses
//
function addStatBonusEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "bonus" && modifier.subType === subType);

  let effects = [];
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      logger/* default.debug */.Z.debug(`Generating ${subType} stat bonus for ${name}`);
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]);

      if (game.modules.get("dae")?.active) {
        const bonusString = `min(@abilities.${ability.value}.max, @abilities.${ability.value}.value + ${bonus.value})`;
        // min(20, @abilities.con.value + 2)
        effects.push(generateOverrideChange(bonusString, 5, `system.abilities.${ability.value}.value`));
      } else {
        effects.push(generateSignedAddChange(bonus.value, 5, `system.abilities.${ability.value}.value`));
      }

    });
  }
  return effects;
}

function addStatBonuses(modifiers, name) {
  let changes = [];
  const stats = [
    "strength-score",
    "dexterity-score",
    "constitution-score",
    "wisdom-score",
    "intelligence-score",
    "charisma-score",
  ];
  stats.forEach((stat) => {
    const result = addStatBonusEffect(modifiers, name, stat);
    changes = changes.concat(result);
  });

  return changes;
}

// *
// Generate stat sets
//
function addStatSetEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "set" && modifier.subType === subType);

  let effects = [];
  // dwarfen "Maximum of 20"
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      logger/* default.debug */.Z.debug(`Generating ${subType} stat set for ${name}`);
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]).value;
      effects.push(generateUpgradeChange(bonus.value, 3, `system.abilities.${ability}.value`));
    });
  }
  return effects;
}

// requires midi
// does not add advantages with restrictions - which is most of them
function addAbilityAdvantageEffect(modifiers, name, subType, type) {
  const bonuses = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "advantage", subType);

  let effects = [];
  if (!game.modules.get("midi-qol")?.active) return effects;
  if (bonuses.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${subType} saving throw advantage for ${name}`);
    const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.long === subType.split("-")[0]).value;
    effects.push(generateCustomChange(1, 4, `flags.midi-qol.advantage.ability.${type}.${ability}`));
  }
  return effects;
}

function addStatChanges(modifiers, name) {
  let changes = [];
  const stats = ["strength", "dexterity", "constitution", "wisdom", "intelligence", "charisma"];
  stats.forEach((stat) => {
    const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ab) => ab.long === stat);
    const statEffect = addStatSetEffect(modifiers, name, `${stat}-score`);
    const savingThrowAdvantage = addAbilityAdvantageEffect(modifiers, name, `${stat}-saving-throws`, "save");
    const abilityCheckAdvantage = addAbilityAdvantageEffect(modifiers, name, `${stat}-ability-checks`, "check");
    const abilityBonusesSave = addAddBonusEffect(modifiers, name, `${stat}-saving-throws`, `system.abilities.${ability.value}.bonuses.save`);
    const abilityBonusesCheck = addAddBonusEffect(modifiers, name, `${stat}-ability-checks`, `system.abilities.${ability.value}.bonuses.check`);
    changes = changes.concat(statEffect, savingThrowAdvantage, abilityCheckAdvantage, abilityBonusesSave, abilityBonusesCheck);
  });

  return changes;
}

// *
// Senses
//
function addSenseBonus(modifiers, name) {
  let changes = [];

  const senses = ["darkvision", "blindsight", "tremorsense", "truesight"];

  senses.forEach((sense) => {
    const base = modifiers
      .filter((modifier) => modifier.type === "set-base" && modifier.subType === sense)
      .map((mod) => mod.value);
    if (base.length > 0) {
      logger/* default.debug */.Z.debug(`Generating ${sense} base for ${name}`);
      changes.push(generateUpgradeChange(Math.max(base), 10, `system.attributes.senses.${sense}`));
    }
    const bonus = modifiers
      .filter((modifier) => modifier.type === "sense" && modifier.subType === sense)
      .reduce((a, b) => a + b.value, 0);
    if (bonus > 0) {
      logger/* default.debug */.Z.debug(`Generating ${sense} bonus for ${name}`);
      changes.push(generateUnsignedAddChange(Math.max(bonus), 20, `system.attributes.senses.${sense}`));
    }
  });
  return changes;
}

/**
 * Proficiency bonus
 */

function addProficiencyBonus(modifiers, name) {
  let changes = [];
  const bonus = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "bonus", "proficiency-bonus").reduce((a, b) => a + b.value, 0);
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating proficiency bonus for ${name}`);
    changes.push(generateUnsignedAddChange(bonus, 0, "system.attributes.prof"));
  }
  return changes;
}

// *
// Generate set speeds
//
function addSetSpeedEffect(modifiers, name, subType) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "set" && modifier.subType === subType);

  let effects = [];
  // "Equal to Walking Speed"
  if (bonuses.length > 0) {
    bonuses.forEach((bonus) => {
      logger/* default.debug */.Z.debug(`Generating ${subType} speed set for ${name}`);
      const innate = subType.split("-").slice(-1)[0];
      const speedType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.innate === innate).type;
      // current assumption if no speed provided, set to walking speed
      const speed = bonus.value ? bonus.value : "@attributes.movement.walk";
      effects.push(generateUpgradeChange(speed, 5, `system.attributes.movement.${speedType}`));
    });
  }
  return effects;
}

/**
 * Innate Speeds
 */
function addSetSpeeds(modifiers, name) {
  let changes = [];
  const speedSets = [
    "innate-speed-walking",
    "innate-speed-climbing",
    "innate-speed-swimming",
    "innate-speed-flying",
    "innate-speed-burrowing",
    "speed-walking",
    "speed-climbing",
    "speed-swimming",
    "speed-flying",
    "speed-burrowing",
  ];
  speedSets.forEach((speedSet) => {
    const result = addSetSpeedEffect(modifiers, name, speedSet);
    changes = changes.concat(result);
  });

  return changes;
}

// *
// Generate speed bonus speeds
//
function addBonusSpeedEffect(modifiers, name, subType, speedType = null) {
  const bonuses = modifiers.filter((modifier) => modifier.type === "bonus" && modifier.subType === subType);

  let effects = [];
  // "Equal to Walking Speed"
  // max(10+(ceil(((@classes.monk.levels)-5)/4))*5,10)
  if (bonuses.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${subType} speed bonus for ${name}`);
    if (!speedType) {
      const innate = subType.split("-").slice(-1)[0];
      speedType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.innate === innate).type;
    }
    const bonusValue = bonuses.reduce((speed, mod) => speed + mod.value, 0);
    if (speedType === "all") {
      effects.push(generateUnsignedAddChange(`+ ${bonusValue}`, 9, `system.attributes.movement.${speedType}`));
    } else {
      effects.push(generateUnsignedAddChange(bonusValue, 9, `system.attributes.movement.${speedType}`));
    }
  }
  return effects;
}

/**
 * Bonus Speeds
 */
function addBonusSpeeds(modifiers, name) {
  let changes = [];
  const speedBonuses = ["speed-walking", "speed-climbing", "speed-swimming", "speed-flying", "speed-burrowing"];
  speedBonuses.forEach((speed) => {
    const result = addBonusSpeedEffect(modifiers, name, speed);
    changes = changes.concat(result);
  });

  changes = changes.concat(addBonusSpeedEffect(modifiers, name, "unarmored-movement", "walk"));
  changes = changes.concat(addBonusSpeedEffect(modifiers, name, "speed", "walk")); // probably all, but doesn't handle cases of where no base speed set, so say fly gets set to 10.

  return changes;
}

function addSkillProficiencies(modifiers) {
  let changes = [];
  const ddbCharacter = new DDBCharacter/* default */.Z();
  dictionary/* default.character.skills.forEach */.Z.character.skills.forEach((skill) => {
    const prof = ddbCharacter.getSkillProficiency(skill, modifiers);
    if (prof != 0) {
      changes.push(generateUpgradeChange(prof, 9, `system.skills.${skill.name}.value`));
    }
  });
  return changes;
}

function addProficiencies(modifiers, name) {
  let changes = [];

  const proficiencies = modifiers
    .filter((mod) => mod.type === "proficiency")
    .map((mod) => {
      return { name: mod.friendlySubtypeName };
    });

  const ddbCharacter = new DDBCharacter/* default */.Z();

  changes = changes.concat(addSkillProficiencies(modifiers));
  const toolProf = ddbCharacter.getToolProficiencies(proficiencies);
  const weaponProf = ddbCharacter.getWeaponProficiencies(proficiencies);
  const armorProf = ddbCharacter.getArmorProficiencies(proficiencies);

  for (const [key, value] of Object.entries(toolProf)) {
    logger/* default.debug */.Z.debug(`Generating tool proficiencies for ${name}`);
    changes.push(generateCustomChange(value.value, 8, `system.tools.${key}.value`));
    changes.push(generateCustomChange(`${value.ability}`, 8, `system.tools.${key}.ability`));
    changes.push(generateCustomChange("0", 8, `system.tools.${key}.bonuses.check`));
  }
  weaponProf.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating weapon proficiencies for ${name}`);
    changes.push(generateUnsignedAddChange(prof, 8, "system.traits.weaponProf.value"));
  });
  armorProf.value.forEach((prof) => {
    logger/* default.debug */.Z.debug(`Generating armor proficiencies for ${name}`);
    changes.push(generateUnsignedAddChange(prof, 8, "system.traits.armorProf.value"));
  });
  // if (toolProf?.custom != "") changes.push(generateCustomChange(toolProf.custom, 8, "system.traits.toolProf.custom"));
  if (weaponProf?.custom != "")
    changes.push(generateUnsignedAddChange(weaponProf.custom, 8, "system.traits.weaponProf.custom"));
  if (armorProf?.custom != "") changes.push(generateUnsignedAddChange(armorProf.custom, 8, "system.traits.armorProf.custom"));

  return changes;
}

/**
 * Add HP effects
 * @param {*} modifiers
 * @param {*} name
 */
function addHPEffect(ddb, modifiers, name, consumable) {
  let changes = [];

  // HP per level
  DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "bonus", "hit-points-per-level").forEach((bonus) => {
    const cls = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(ddb, bonus.componentId);
    if (cls) {
      logger/* default.debug */.Z.debug(`Generating HP Per Level effects for ${name} for class ${cls.definition.name}`);
      changes.push(generateUnsignedAddChange(`${bonus.value} * @classes.${cls.definition.name.toLowerCase()}.levels`, 14, "system.attributes.hp.bonuses.overall"));
    } else {
      logger/* default.debug */.Z.debug(`Generating HP Per Level effects for ${name} for all levels`);
      changes.push(generateUnsignedAddChange(bonus.value, 14, "system.attributes.hp.bonuses.level"));
    }
  });

  const hpBonusModifiers = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "bonus", "hit-points");
  if (hpBonusModifiers.length > 0 && !consumable) {
    let hpBonus = "";
    hpBonusModifiers.forEach((modifier) => {
      let hpParse = DDBHelper/* default.extractModifierValue */.Z.extractModifierValue(modifier);
      if (hpBonus !== "") hpBonus += " + ";
      hpBonus += hpParse;
    });
    changes.push(generateUnsignedAddChange(`${hpBonus}`, 14, "system.attributes.hp.bonuses.overall"));
  }

  return changes;
}

//
// Generate skill bonuses
//
function addSkillBonusEffect(modifiers, name, skill) {
  const bonus = DDBHelper/* default.getValueFromModifiers */.Z.getValueFromModifiers(modifiers, name, skill.subType, "bonus");

  let changes = [];
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating ${skill.subType} skill bonus for ${name}`, bonus);
    changes.push(generateUnsignedAddChange(bonus, 12, `system.skills.${skill.name}.bonuses.check`));
  }
  return changes;
}

//
// generate skill advantages
// requires midi
//
function addSkillMidiEffect(modifiers, name, skill, midiEffect = "advantage") {
  if (!game.modules.get("midi-qol")?.active) return [];
  const allowedRestrictions = [
    "",
    null,
    "Sound Only",
    "Sight Only",
    "that rely on smell",
    "While the hood is up, checks made to Hide ",
  ];
  const advantage = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, midiEffect, skill.subType, allowedRestrictions);

  let effects = [];
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating ${skill.subType} skill ${midiEffect} for ${name}`);
    effects.push(generateCustomChange(1, 5, `flags.midi-qol.${midiEffect}.skill.${skill.name}`));
    // handled by midi already
    // advantage/disadvantage on skill grants +/-5 passive bonus, https://www.dndbeyond.com/sources/phb/using-ability-scores#PassiveChecks
    // if (midiEffect === "advantage") {
    //   effects.push(generateAddChange(5, 5, `system.skills.${skill.name}.bonuses.passive`));
    // } else if (midiEffect === "disadvantage") {
    //   effects.push(generateAddChange(-5, 5, `system.skills.${skill.name}.bonuses.passive`));
    // }
  }
  return effects;
}

function addSkillPassiveBonusEffect(modifiers, name, skill) {
  const bonus = DDBHelper/* default.getValueFromModifiers */.Z.getValueFromModifiers(modifiers, name, `passive-${skill.subType}`, "bonus");

  let changes = [];
  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating ${skill.subType} skill bonus for ${name}`, bonus);
    changes.push(generateUnsignedAddChange(bonus, 12, `system.skills.${skill.name}.bonuses.passive`));
  }
  return changes;
}

function addSkillBonuses(modifiers, name) {
  let changes = [];
  dictionary/* default.character.skills.forEach */.Z.character.skills.forEach((skill) => {
    const newMods = modifiers.filter((mod) => {
      if (mod.subType === `passive-${skill.subType}`) {
        const passiveMods = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "bonus", `passive-${skill.subType}`);
        const advantageMods = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "advantage", skill.subType);
        if (passiveMods.length > 0 && advantageMods.length > 0) return false;
        else return true;
      } else {
        return true;
      }
    });
    const skillBonuses = addSkillBonusEffect(newMods, name, skill);
    const skillPassiveBonuses = addSkillPassiveBonusEffect(newMods, name, skill);
    const skillAdvantages = addSkillMidiEffect(newMods, name, skill, "advantage");
    changes = changes.concat(skillBonuses, skillPassiveBonuses, skillAdvantages);
  });


  return changes;
}

// Attunement Slot Bonus

function addAttunementSlots(modifiers, name) {
  let changes = [];
  const bonus = DDBHelper/* default.getValueFromModifiers */.Z.getValueFromModifiers(modifiers, name, "attunement-slots", "set");

  if (bonus) {
    logger/* default.debug */.Z.debug(`Generating Attunement bonus for ${name}`, bonus);
    changes.push(generateUpgradeChange(bonus, (10 + bonus), "system.attributes.attunement.max"));
  }
  return changes;
}


//
// initiative
//
function addInitiativeBonuses(modifiers, name) {
  let changes = [];
  const advantage = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "advantage", "initiative");
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating Initiative advantage for ${name}`);
    changes.push(generateUnsignedAddChange(1, 20, "flags.dnd5e.initiativeAdv"));
  }

  const advantageBonus = DDBHelper/* default.getValueFromModifiers */.Z.getValueFromModifiers(modifiers, "initiative", "initiative", "bonus");
  // alert feet gets special bonus
  if (advantageBonus && name !== "Alert") {
    logger/* default.debug */.Z.debug(`Generating Initiative bonus for ${name}`);
    changes.push(generateUnsignedAddChange(advantageBonus, 20, "system.attributes.init.bonus"));
  }

  return changes;
}

//
// attack rolls against you
// midi only
//
function addAttackRollDisadvantage(modifiers, name) {
  if (!game.modules.get("midi-qol")?.active) return [];
  let changes = [];
  const disadvantage = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "disadvantage", "attack-rolls-against-you", false);
  if (disadvantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating disadvantage for ${name}`);
    changes.push(generateCustomChange(1, 5, "flags.midi-qol.grants.disadvantage.attack.all"));
  }
  return changes;
}

// midi advantages on saving throws against spells and magical effects
function addMagicalAdvantage(modifiers, name) {
  if (!game.modules.get("midi-qol")?.active) return [];
  let changes = [];
  const restrictions = [
    "against spells and magical effects",
    "Against Spells and Magical Effects",
    "Against Spells",
    "against spells",
    "Against spells",
    "Against spells and magical effects within 10 ft. (or 30 ft. at level 17+) while holding the Holy Avenger",
  ];
  const advantage = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "advantage", "saving-throws", restrictions);
  if (advantage.length > 0) {
    logger/* default.debug */.Z.debug(`Generating magical advantage on saving throws for ${name}`);
    changes.push(generateCustomChange("1", 5, "flags.midi-qol.magicResistance.all"));
    // changes.push(generateCustomChange("magic-resistant", 5, "system.traits.dr.custom"));
  }
  return changes;
}

function consumableEffect(effect, ddbItem, foundryItem) {
  let label = `${foundryItem.name} - Consumable Effects`;
  effect.name = label;
  effect.disabled = false;
  effect.transfer = false;
  foundry.utils.setProperty(effect, "flags.ddbimporter.disabled", false);
  foundry.utils.setProperty(effect, "flags.dae.transfer", false);
  effect.duration = generateEffectDuration(foundryItem);
  if (!foundryItem.system.target?.value) {
    foundryItem.system.target = {
      value: 1,
      width: null,
      units: "",
      type: "creature",
    };
  }
  if (!foundryItem.system.range?.units) {
    foundryItem.system.range = {
      value: null,
      long: null,
      units: "touch",
    };
  }
  if (foundryItem.system.uses) {
    foundryItem.system.uses.autoDestroy = true;
    foundryItem.system.uses.autoUse = true;
  }

  return effect;
}

/**
 * This checks attunement status and similar to determine effect state
 * set disabled flags etc
 * @param {*} foundryItem
 * @param {*} effect
 * @param {*} ddbItem
 * @param {*} isCompendiumItem
 */
function addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem) {
  // check attunement status etc

  if (
    !ddbItem.definition?.canEquip
    && !ddbItem.definition?.canAttune
    && !ddbItem.definition?.isConsumable
    && dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(foundryItem.type)
  ) {
    // if item just gives a thing and not potion/scroll
    effect.disabled = false;
    foundry.utils.setProperty(effect, "flags.ddbimporter.disabled", false);
    foundry.utils.setProperty(foundryItem, "flags.dae.alwaysActive", true);
  } else if (
    isCompendiumItem
    || foundryItem.type === "feat"
    || (ddbItem.isAttuned && ddbItem.equipped) // if it is attuned and equipped
    || (ddbItem.isAttuned && !ddbItem.definition?.canEquip) // if it is attuned but can't equip
    || (!ddbItem.definition?.canAttune && ddbItem.equipped) // can't attune but is equipped
  ) {
    foundry.utils.setProperty(foundryItem, "flags.dae.alwaysActive", false);
    foundry.utils.setProperty(effect, "flags.ddbimporter.disabled", false);
    effect.disabled = false;
  } else {
    effect.disabled = true;
    foundry.utils.setProperty(effect, "flags.ddbimporter.disabled", true);
    foundry.utils.setProperty(foundryItem, "flags.dae.alwaysActive", false);
  }

  foundry.utils.setProperty(effect, "flags.ddbimporter.itemId", ddbItem.id);
  foundry.utils.setProperty(effect, "flags.ddbimporter.itemEntityTypeId", ddbItem.entityTypeId);
  // set dae flag for active equipped
  if (ddbItem.definition?.canEquip || ddbItem.definitio?.canAttune) {
    foundry.utils.setProperty(foundryItem, "flags.dae.activeEquipped", true);
  } else {
    foundry.utils.setProperty(foundryItem, "flags.dae.activeEquipped", false);
  }

  if (ddbItem.definition?.filterType === "Potion") {
    effect = consumableEffect(effect, ddbItem, foundryItem);
  }

  return [foundryItem, effect];
}

/**
 * Generate supported effects for items
 * @param {*} ddb
 * @param {*} character
 * @param {*} ddbItem
 * @param {*} foundryItem
 */
// eslint-disable-next-line no-unused-vars
function generateGenericEffects({ ddb, character, ddbItem, foundryItem, isCompendiumItem, labelOverride, description = "" } = {}) {
  if (!foundryItem.effects) foundryItem.effects = [];

  const label = labelOverride
    ? labelOverride
    : `${foundryItem.name} - Passive`;

  let effect = baseItemEffect(foundryItem, label);
  effect.description = description;

  if (!ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0) return [foundryItem, effect];
  logger/* default.debug */.Z.debug(`Generating Generic Effects for ${foundryItem.name}`, ddbItem);

  const globalSaveBonus = addGlobalSavingBonusEffect(ddbItem.definition.grantedModifiers, foundryItem.name);
  const globalAbilityBonus = addAddBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "ability-checks",
    "system.bonuses.abilities.check",
  );
  const globalSkillBonus = addAddBonusEffect(
    ddbItem.definition.grantedModifiers,
    foundryItem.name,
    "skill-checks",
    "system.bonuses.abilities.skill",
  );
  const languages = addLanguages(ddbItem.definition.grantedModifiers, foundryItem.name);
  const conditions = addDamageConditions(ddbItem.definition.grantedModifiers, foundryItem.name);
  const criticalHitImmunity = addCriticalHitImmunities(ddbItem.definition.grantedModifiers, foundryItem.name);
  const statSets = addStatChanges(ddbItem.definition.grantedModifiers, foundryItem.name);
  const statBonuses = addStatBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const senses = addSenseBonus(ddbItem.definition.grantedModifiers, foundryItem.name);
  const proficiencyBonus = addProficiencyBonus(ddbItem.definition.grantedModifiers, foundryItem.name);
  const speedSets = addSetSpeeds(ddbItem.definition.grantedModifiers, foundryItem.name);
  const spellAttackBonuses = addSpellAttackBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);

  const profs = addProficiencies(ddbItem.definition.grantedModifiers, foundryItem.name);
  const hp = addHPEffect(ddb, ddbItem.definition.grantedModifiers, foundryItem.name, ddbItem.definition.isConsumable);
  const skillBonus = addSkillBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const initiative = addInitiativeBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const disadvantageAgainst = addAttackRollDisadvantage(ddbItem.definition.grantedModifiers, foundryItem.name);
  const magicalAdvantage = addMagicalAdvantage(ddbItem.definition.grantedModifiers, foundryItem.name);
  const bonusSpeeds = addBonusSpeeds(ddbItem.definition.grantedModifiers, foundryItem.name);
  const weaponAttackBonuses = addWeaponAttackBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);
  const globalDamageBonus = addGlobalDamageBonus(ddbItem.definition.grantedModifiers, foundryItem.name);
  const attunementAdjustment = addAttunementSlots(ddbItem.definition.grantedModifiers, foundryItem.name);

  effect.changes = [
    ...criticalHitImmunity,
    ...globalSaveBonus,
    ...globalAbilityBonus,
    ...globalSkillBonus,
    ...languages,
    ...conditions,
    ...statSets,
    ...statBonuses,
    ...senses,
    ...proficiencyBonus,
    ...speedSets,
    ...spellAttackBonuses,
    ...profs,
    ...hp,
    ...skillBonus,
    ...initiative,
    ...disadvantageAgainst,
    ...magicalAdvantage,
    ...bonusSpeeds,
    ...weaponAttackBonuses,
    ...globalDamageBonus,
    ...attunementAdjustment,
  ];

  // if we don't have effects, lets return the item
  if (effect.changes?.length === 0) {
    return [foundryItem, effect];
  }

  // generate flags for effect (e.g. checking attunement and equipped status)
  [foundryItem, effect] = addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem);

  return [foundryItem, effect];
}

function addACEffect(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect, type) {
  // console.warn("addACEffect", {
  //   ddb,
  //   character,
  //   ddbItem: foundry.utils.deepClone(ddbItem),
  //   foundryItem: foundry.utils.deepClone(foundryItem),
  //   isCompendiumItem,
  //   effect: foundry.utils.deepClone(effect),
  //   equipment: foundryItem.type === "equipment",
  //   transfer: effect.transfer,
  //   ac: (foundryItem.system.armor?.type && ["trinket", "clothing"].includes(foundryItem.system.armor.type)),
  // });
  switch (type) {
    case "infusion":
    case "equipment":
    case "item":
    case "feature":
    case "feat": {
      if (foundryItem.type === "equipment") {
        if (type === "infusion"
          || (foundryItem.system.type?.value
            && ["trinket", "clothing"].includes(foundryItem.system.type.value))
        ) {
          foundryItem = (0,acEffects/* generateBaseACItemEffect */.se)(ddb, character, ddbItem, foundryItem, isCompendiumItem);
        }
      } else if (effect.transfer || type === "infusion") {
        [foundryItem, effect] = (0,acEffects/* generateACEffectChangesForItem */.qI)(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);
      } else {
        foundryItem = (0,acEffects/* generateBaseACItemEffect */.se)(ddb, character, ddbItem, foundryItem, isCompendiumItem);
      }
      break;
    }
    // no default
  }

  return [foundryItem, effect];
}

function generateEffects({ ddb, character, ddbItem, foundryItem, isCompendiumItem, type, description = "" } = {}) {
  logger/* default.debug */.Z.debug(`Checking ${foundryItem.name} for auto generated effects`, ddbItem);
  // set flags if using effects
  foundryItem = applyDefaultMidiFlags(foundryItem);
  let label;

  if (type === "item" && foundry.utils.hasProperty(ddbItem, "definition.grantedModifiers")) {
    ddbItem.definition.grantedModifiers = ddbItem.definition.grantedModifiers.filter((modifier) =>
      modifier.type !== "damage" && modifier.subType !== null
    );
  }

  const labelAdjustment = foundry.utils.getProperty(foundryItem, "flags.ddbimporter.effectLabelOverride");
  if (labelAdjustment) {
    label = labelAdjustment;
  } else if (type == "infusion") {
    label = `${foundryItem.name} - Infusion`;
  }
  let effect;
  [foundryItem, effect] = generateGenericEffects({
    ddb,
    character,
    ddbItem,
    foundryItem,
    isCompendiumItem,
    labelOverride: label,
    description,
  });
  [foundryItem, effect] = addACEffect(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect, type);

  if (effect.changes?.length > 0) {
    foundryItem.effects.push(effect);
  }

  switch (type) {
    case "infusion": {
      foundryItem = infusionEffectAdjustment(foundryItem);
      break;
    }
    case "equipment":
    case "item": {
      foundryItem = (0,specialEquipment/* equipmentEffectAdjustment */._)(foundryItem);
      break;
    }
    // spells and feats get called from respective parsers for async loading
    // no default
  }

  if (foundryItem.effects?.length > 0 || foundry.utils.hasProperty(document, "flags.dae") || foundry.utils.hasProperty(document, "flags.midi-qol.onUseMacroName")) {
    logger/* default.debug */.Z.debug(`${type} effect ${foundryItem.name}:`, foundry.utils.duplicate(foundryItem));
    foundry.utils.setProperty(foundryItem, "flags.ddbimporter.effectsApplied", true);
  }
  return foundryItem;

}


/***/ }),

/***/ 7252:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ ChrisPremadesHelper)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3893);
/* harmony import */ var _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7407);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6451);
/* eslint-disable no-continue */
/* eslint-disable require-atomic-updates */
// import DICTIONARY from "../dictionary.js";
// import SETTINGS from "../settings.js";








class ChrisPremadesHelper {

  static DDB_FLAGS_TO_REMOVE = [
    "midi-qol",
    "midiProperties",
    "ActiveAuras",
    "dae",
    "itemacro",
  ];

  static CP_FLAGS_TO_REMOVE = [
    "cf",
    "ddbimporter",
    "monsterMunch",
    "core",
    "link-item-resource-5e",
  ];

  static CP_FIELDS_TO_COPY = [
    "effects",
    "system.damage",
    "system.target",
    "system.range",
    "system.duration",
    "system.save",
    "system.activation",
    "system.ability",
    "system.critical",
    "system.formula",
    "system.actionType",
    "system.scaling",
  ];

  static CP_COMPENDIUM_TYPES = [
    { type: "spell", system: "spell" },
    { type: "feat", system: "feature" },
    { type: "feat", system: "trait" },
    { type: "feat", system: "feat" },
    { type: "equipment", system: "inventory" },
    { type: "weapon", system: "weapon" },
    { type: "consumable", system: "consumable" },
    { type: "tool", system: "tool" },
    { type: "loot", system: "loot" },
    // { type: "container", system: "container" },
    { type: "equipment", system: "container" },
    { type: "equipment", system: "backback" },
    { type: "equipment", system: "equipment" },
  ];

  static async getChrisCompendiumIndex(compendiumName, matchedProperties = {}) {
    const gamePack = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendium */ .Z.getCompendium(compendiumName);
    const index = await gamePack.getIndex({
      fields: ["name", "type", "flags.cf", "folder"].concat(Object.keys(matchedProperties))
    });
    return index;
  }

  static async getChrisCompendiums(type, isMonster = false, matchedProperties = {}) {
    if (chrisPremades.helpers.getSearchCompendiums) {
      const baseType = ChrisPremadesHelper.CP_COMPENDIUM_TYPES.find((t) => t.system === type)?.type ?? type;
      const compendiums = (
        isMonster
          ? (chrisPremades.helpers.getMonsterFeatureSearchCompendiums
            ? chrisPremades.helpers.getMonsterFeatureSearchCompendiums()
            : ['chris-premades.CPR Monster Features'])
          : []
      ).concat(await chrisPremades.helpers.getSearchCompendiums(baseType));
      const results = (await Promise.all(compendiums
        .filter((c) => game.packs.get(c))
        .map(async (c) => {
          const index = await ChrisPremadesHelper.getChrisCompendiumIndex(c, matchedProperties);
          // console.warn(`Matched`, {
          //   type, baseType, compendiums, index, c
          // });
          const result = {
            index: index.filter((i) => i.type === baseType),
            packName: c,
            compendium: game.packs.get(c),
          };
          return result;
        }))).filter((r) => r.index.length > 0);
      // console.warn("Results", results);
      return results;
    } else {
      return [];
    }
  }

  static getOriginalName(document, trimOption = false) {
    const flagName = document.flags.ddbimporter?.originalName ?? document.name;

    const regex = /(.*)\s*\((:?costs \d actions|\d\/Turn|Recharges after a Short or Long Rest|\d\/day|recharge \d-\d)\)/i;
    const nameMatch = flagName.replace(/[-]/g, "-").match(regex);
    const longName = nameMatch ? nameMatch[1].trim() : flagName;
    if (!trimOption) return longName;

    return longName.split(":")[0].trim();

  }

  static getTypeMatch(doc, isMonster = false) {
    if (_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(doc.type)) {
      return "inventory";
    }
    if (doc.type !== "feat") return doc.type;

    // feats cover a variety of sins, lets try and narrow it down
    if (isMonster) return "monsterfeature";

    // lets see if we have marked this as a class or race type
    const systemTypeValue = foundry.utils.getProperty(doc, "system.type.value");
    if (systemTypeValue && systemTypeValue !== "") {
      if (systemTypeValue === "class") return "feature";
      if (systemTypeValue === "race") return "trait";
      return systemTypeValue;
    }

    // can we derive the type from the ddb importer type flag?
    const ddbType = foundry.utils.getProperty(doc, "flags.ddbimporter.type");
    if (ddbType && !["", "other"].includes(ddbType)) {
      if (ddbType === "class") return "feature";
      if (ddbType === "race") return "trait";
      return ddbType;
    }

    if (doc.type === "feat") {
      return "feature";
    }

    return doc.type;
  }

  // matchedProperties = { "system.activation.type": "bonus" }
  static async getDocumentFromCompendium(key, name, ignoreNotFound, folderId, matchedProperties = {}) {
    const gamePack = game.packs.get(key);
    if (!gamePack) {
      ui.notifications.warn('Invalid compendium specified!');
      return false;
    }

    const packIndex = await gamePack.getIndex({
      fields: ['name', 'type', 'folder'].concat(Object.keys(matchedProperties))
    });

    const match = packIndex.find((item) =>
      item.name === name
      && (!folderId || (folderId && item.folder === folderId))
      && (Object.keys(matchedProperties).length === 0 || _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].matchProperties */ .Z.matchProperties(item, matchedProperties))
    );

    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Looking for ${name} in ${key} with properties`, {
      key,
      name, ignoreNotFound,
      folderId,
      matchedProperties,
      match,
      packIndex,
    });

    if (match) {
      return (await gamePack.getDocument(match._id))?.toObject();
    } else {
      if (!ignoreNotFound) {
        ui.notifications.warn(`Item not found in compendium ${key} with name ${name}! Check spelling?`);
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn(`Item not found in compendium ${key} with name ${name}! Check spelling?`, { key, name, folderId, matchedProperties });
      }
      return undefined;
    }
  }

  static async getDocumentFromName(documentName, type,
    { folderName = null, isMonster = false, matchedProperties = {} } = {}
  ) {

    const compendiums = await ChrisPremadesHelper.getChrisCompendiums(type, isMonster);
    if (compendiums.length === 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn(`No compendium found for Chris's Premade effect for ${type} and ${documentName}, with type ${type}!`);
      return undefined;
    }

    // console.warn("here", { this: this });

    // const allowFolders = ["weapon", "feat"].includes(this.original.type);

    for (const c of compendiums) {
      const folderId = isMonster // && allowFolders
        ? await _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumFolderId */ .Z.getCompendiumFolderId((folderName ?? documentName), c.packName)
        : undefined;

      // expected to find feature in a folder, but we could not
      // if (allowFolders && folderName && folderId === undefined) {
      if (folderName && folderId === undefined) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`No folder found for ${folderName} and ${documentName}, checking compendium name ${c.packName}`);
        continue;
      }

      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`CP Effect (From Name): Attempting to fetch ${documentName} from ${c.packName} with folderID ${folderId}`);
      // const chrisDoc = await ChrisPremadesHelper.getDocumentFromCompendium(c.packName, documentName, true, folderId, matchedProperties);
      const match = c.index.find((doc) =>
        doc.name === documentName
        && (!folderId || (folderId && doc.folder === folderId))
        && (Object.keys(matchedProperties).length === 0 || _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].matchProperties */ .Z.matchProperties(doc, matchedProperties))
      );

      if (!match) continue;
      return match;
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`No CP Effect found for ${documentName} from all matched compendiums with folderName ${folderName}`);
    return undefined;
  }


  constructor(document,
    { chrisNameOverride = null, isMonster = false, folderName = null, ignoreNotFound = true, type = null,
      matchedProperties = {} } = {}
  ) {
    this.original = foundry.utils.deepClone(document);
    this.document = document;
    this.chrisNameOverride = chrisNameOverride;
    this.isMonster = isMonster;
    this.folderName = folderName;
    this.ignoreNotFound = ignoreNotFound;
    this.type = type ?? ChrisPremadesHelper.getTypeMatch(document, isMonster);
    this.matchProperties = matchedProperties;
    this.ddbName = ChrisPremadesHelper.getOriginalName(document);
    this.chrisName = chrisNameOverride ?? CONFIG.chrisPremades?.renamedItems[this.ddbName] ?? this.ddbName;
    this.chrisDoc = null;
    this.appendChrisDescription = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "append-chris-premade-effect-description");
  }

  async findReplacement() {
    const compendiums = await ChrisPremadesHelper.getChrisCompendiums(this.original.type, this.isMonster);
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Compendiums found", {
      compendiums,
      this: this,
      type: this.original.type,
      isMonster: this.isMonster,
    });
    if (compendiums.length === 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn(`No compendium found for Chris's Premade effect for "${this.original.name}" with original type ${this.original.type} and with type object type ${this.type}!`, {
        this: this,
      });
      return undefined;
    }

    const allowFolders = ["weapon", "feat"].includes(this.original.type) && this.isMonster;

    for (const c of compendiums) {
      const folderId = allowFolders
        ? await _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumFolderId */ .Z.getCompendiumFolderId((this.folderName ?? this.chrisName), c.packName)
        : undefined;

      // expected to find feature in a folder, but we could not
      if (allowFolders && folderId === undefined) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Needed folder, but none found for ${this.folderName} and ${this.original.name}, using compendium name ${c.packName}`);
        continue;
      }

      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`CP Effect (find replacement): Attempting to fetch ${this.original.name} from ${c.packName} with folderID ${folderId}`);
      const chrisDoc = await ChrisPremadesHelper.getDocumentFromCompendium(c.packName, this.chrisName, this.ignoreNotFound, folderId, this.matchedProperties);
      if (!chrisDoc) continue;
      const chrisType = ChrisPremadesHelper.getTypeMatch(chrisDoc, this.isMonster);

      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Found", {
        thisType: this.type,
        chrisType,
        chrisDoc,
        truthy: this.type === chrisType,
      });
      if (this.type === chrisType || folderId) {
        this.chrisDoc = chrisDoc;
        return chrisDoc;
      }
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Skipping CP Effect found for ${this.original.name} from ${c.packName} with folderName ${this.folderName} as type mismatch`);
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`No CP Effect found for ${this.original.name} from all matched compendiums with folderName ${this.folderName}`);
    return undefined;
  }

  static appendDescription(source, target) {
    const description = foundry.utils.getProperty(source, "system.description");
    if (!description || description.value.trim() === "") return target;

    const text = description.value;
    if (text && text.trim() !== "") {
      target.system.description.value += `
<br>
<section class="secret">
<hr>
<h5>Automation notes - Chris's Premades (CPR):</h5>
${text}
</section>`;
    }
    const chat = description.chat;
    if (chat && chat.trim() !== "") {
      target.system.description.chat += `
<br>
<section class="secret">
<hr>
<h5>Automation notes - Chris's Premades (CPR):</h5>
${chat}
</section>`;
    }

    return target;
  }

  static copyDescription(source, target, { appendSourceDescription = false, prependSourceDescription = false } = {}) {
    const sourceDescription = foundry.utils.getProperty(source, "system.description");
    if (!sourceDescription || sourceDescription.value.trim() === "") return target;

    if (appendSourceDescription) {
      ChrisPremadesHelper.appendDescription(source, target);
    } else if (prependSourceDescription) {
      const mockSource = foundry.utils.deepClone(target);
      const mockDescription = foundry.utils.getProperty(source, "flags.ddbimporter.initialFeature")
        ?? foundry.utils.getProperty(source, "system.description");

      mockSource.system.description = foundry.utils.deepClone(foundry.utils.getProperty(target, "system.description"));
      target.system.description = foundry.utils.deepClone(mockDescription);
      ChrisPremadesHelper.appendDescription(mockSource, target);
    } else {
      target.system.description = foundry.utils.deepClone(sourceDescription);
    }

    return target;
  }

  updateOriginalDocument() {
    ChrisPremadesHelper.DDB_FLAGS_TO_REMOVE.forEach((flagName) => {
      delete this.document.flags[flagName];
    });

    this.document.effects = [];

    ChrisPremadesHelper.CP_FLAGS_TO_REMOVE.forEach((flagName) => {
      delete this.chrisDoc.flags[flagName];
    });

    this.document.flags = foundry.utils.mergeObject(this.document.flags, this.chrisDoc.flags);

    ChrisPremadesHelper.CP_FIELDS_TO_COPY.forEach((field) => {
      const values = foundry.utils.getProperty(this.chrisDoc, field);
      if (field === "effects") {
        values.forEach((effect) => {
          effect._id = foundry.utils.randomID();
        });
      }
      foundry.utils.setProperty(this.document, field, values);
    });

    if (this.appendChrisDescription) {
      ChrisPremadesHelper.appendDescription(this.chrisDoc, this.document);
    }

    foundry.utils.setProperty(this.document, "flags.ddbimporter.effectsApplied", true);
    foundry.utils.setProperty(this.document, "flags.ddbimporter.chrisEffectsApplied", true);
    foundry.utils.setProperty(this.document, "flags.ddbimporter.chrisPreEffectName", this.ddbName);

    const correctionProperties = foundry.utils.getProperty(CONFIG, `chrisPremades.correctedItems.${this.chrisName}`);
    if (correctionProperties) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Updating ${this.original.name} with a Chris correction properties`);
      this.document = foundry.utils.mergeObject(this.document, correctionProperties);
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Updated ${this.original.name} with a Chris effect`);
    delete this.document.folder;

  }

  static async find({ document, type, isMonster = false, folderName = null, chrisNameOverride = null } = {}) {
    if (!game.modules.get("chris-premades")?.active) return document;
    if (foundry.utils.getProperty(document, "flags.ddbimporter.ignoreItemForChrisPremades") === true) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info(`${document.name} set to ignore Chris's Premade effect application`);
      return document;
    }

    const chrisHelper = new ChrisPremadesHelper(document, { type, chrisNameOverride, folderName, ignoreNotFound: true, isMonster });
    const chrisDoc = await chrisHelper.findReplacement();
    if (!chrisDoc) {
      return document;
    }

    return chrisDoc.document;
  }

  static async findAndUpdate({ document, type, isMonster = false, folderName = null, chrisNameOverride = null } = {}) {
    if (!game.modules.get("chris-premades")?.active) return document;
    if (foundry.utils.getProperty(document, "flags.ddbimporter.ignoreItemForChrisPremades") === true) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info(`${document.name} set to ignore Chris's Premade effect application`);
      return document;
    }

    const chrisHelper = new ChrisPremadesHelper(document, { type, chrisNameOverride, folderName, ignoreNotFound: true, isMonster });
    const chrisDoc = await chrisHelper.findReplacement();
    if (!chrisDoc) {
      return document;
    }

    chrisHelper.updateOriginalDocument();

    return chrisHelper.document;
  }

  // eslint-disable-next-line no-unused-vars
  static async addAndReplaceRedundantChrisDocuments(actor, _folderName = null) {
    if (!game.modules.get("chris-premades")?.active) return;
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Beginning additions and removals of extra effects.");
    const documents = actor.getEmbeddedCollection("Item").toObject();
    const toAdd = [];
    const toDelete = new Set();
    const choiceRemovals = foundry.utils.getProperty(CONFIG, "chrisPremades.removeChoices") ?? [];
    const choiceAdditions = new Set();

    for (let doc of documents) {
      if (["class", "subclass", "background"].includes(doc.type)) continue;

      const ddbName = ChrisPremadesHelper.getOriginalName(doc);
      const chrisName = CONFIG.chrisPremades?.renamedItems[ddbName] ?? ddbName;
      const noChoiceName = ddbName.split(":")[0].trim();
      const newItemNames = new Set(foundry.utils.getProperty(CONFIG, `chrisPremades.additionalItems.${chrisName}`) ?? []);

      if (ddbName !== noChoiceName) {
        const noChoiceNewNames = foundry.utils.getProperty(CONFIG, `chrisPremades.additionalItems.${noChoiceName}`);
        if (noChoiceNewNames && !choiceAdditions.has(noChoiceName)) {
          noChoiceNewNames.forEach((i) => newItemNames.add(i));
          choiceAdditions.add(noChoiceName);
        }
      }

      if (newItemNames.size > 0) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Adding new items for ${chrisName}`);

        for (const newItemName of newItemNames) {
          _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Adding new item ${newItemName}`);
          const chrisDoc = await ChrisPremadesHelper.getDocumentFromName(newItemName, doc.type);
          if (!chrisDoc) {
            _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`DDB Importer expected to find an item in Chris's Premades for ${newItemName} but did not`, {
              ddbName,
              doc,
              chrisName,
              newItemNames,
              documents,
              chrisDoc,
            });
          } else if (!documents.some((d) => d.name === chrisDoc.name)) {
            ChrisPremadesHelper.copyDescription(doc, chrisDoc, { prependSourceDescription: this.appendDescription });
            foundry.utils.setProperty(chrisDoc, "flags.ddbimporter.ignoreItemUpdate", true);
            toAdd.push(chrisDoc);
          }
        }
      }

      const itemsToRemoveNames = new Set(foundry.utils.getProperty(CONFIG, `chrisPremades.removedItems.${chrisName}`) ?? []);
      if (choiceRemovals.includes(noChoiceName)) {
        itemsToRemoveNames.add(ddbName);
      }
      if (itemsToRemoveNames.size > 0) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Removing items for ${chrisName}`);
        for (const removeItemName of itemsToRemoveNames) {
          _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Removing item ${removeItemName}`);
          const deleteDoc = documents.find((d) => ChrisPremadesHelper.getOriginalName(d) === removeItemName);
          if (deleteDoc) toDelete.add(deleteDoc._id);
        }
      }
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Final Chris's Premades list", {
      toDelete,
      toAdd,
    });
    await actor.deleteEmbeddedDocuments("Item", Array.from(toDelete));
    await actor.createEmbeddedDocuments("Item", toAdd);

  }


  // eslint-disable-next-line complexity
  static async restrictedItemReplacer(actor, folderName = null) {
    if (!game.modules.get("chris-premades")?.active) return;
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Beginning additions and removals of restricted effects.");

    const documents = actor.getEmbeddedCollection("Item").toObject();
    const restrictedItems = foundry.utils.getProperty(CONFIG, `chrisPremades.restrictedItems`);

    const sortedItems = Object.keys(restrictedItems).map((key) => {
      const data = restrictedItems[key];
      data["key"] = key;
      return data;
    }).sort((a, b) => (a.priority ?? 0) - (b.priority ?? 0));
    const toAdd = [];
    const toDelete = new Set();

    for (const restrictedItem of sortedItems) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Checking restricted Item ${restrictedItem.key}: ${restrictedItem.originalName}`);
      const doc = documents.find((d) => {
        const ddbName = d.flags.ddbimporter?.chrisPreEffectName ?? ChrisPremadesHelper.getOriginalName(d);
        const retainDoc = foundry.utils.getProperty(document, "flags.ddbimporter.ignoreItemForChrisPremades") === true;
        return ddbName === restrictedItem.originalName && !retainDoc;
      });
      if (!doc) continue;
      if (["class", "subclass", "background"].includes(doc.type)) continue;
      const ddbName = doc.flags.ddbimporter?.chrisPreEffectName ?? ChrisPremadesHelper.getOriginalName(doc);

      const rollData = actor.getRollData();

      if (restrictedItem.requiredClass && !rollData.classes[restrictedItem.requiredClass.toLowerCase()]) continue;
      if (restrictedItem.requiredSubclass) {
        const subClassData = rollData.classes[restrictedItem.requiredClass.toLowerCase()].subclass;
        if (!subClassData) continue;
        if (subClassData.parent.name.toLowerCase() !== restrictedItem.requiredSubclass.toLowerCase()) continue;
      }
      if (restrictedItem.requiredRace
        && restrictedItem.requiredRace.toLocaleLowerCase() !== (rollData.details.race?.name ?? rollData.details?.race)?.toLocaleLowerCase()
      ) continue;


      if (restrictedItem.requiredEquipment) {
        for (const requiredEquipment of restrictedItem.requiredEquipment) {
          const itemMatch = documents.some((d) => ddbName === requiredEquipment && _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(d.type));
          if (!itemMatch) continue;
        }
      }

      if (restrictedItem.requiredFeature) {
        for (const requiredFeature of restrictedItem.requiredFeature) {
          const itemMatch = documents.some((d) => ddbName === requiredFeature && d.type === "feat");
          if (!itemMatch) continue;
        }
      }

      if (restrictedItem.requiredFeatures) {
        for (const requiredFeature of restrictedItem.requiredFeatures) {
          const itemMatch = documents.some((d) => ddbName === requiredFeature && d.type === "feat");
          if (!itemMatch) continue;
        }
      }

      // now replace the matched item with the replaced Item
      if (restrictedItem.replacedItemName && restrictedItem.replacedItemName !== "") {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Replacing item data for ${ddbName}, using restricted data from ${restrictedItem.key}`);
        const updateDocument = await ChrisPremadesHelper.findAndUpdate({
          document: foundry.utils.duplicate(doc),
          folderName,
          chrisNameOverride: restrictedItem.replacedItemName,
        });
        if (updateDocument) {
          await actor.deleteEmbeddedDocuments("Item", [doc._id]);
          await actor.createEmbeddedDocuments("Item", [updateDocument], { keepId: true });
        }
      }


      if (restrictedItem.additionalItems && restrictedItem.additionalItems.length > 0) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Adding new items for ${ddbName}, using restricted data from ${restrictedItem.key}`);

        const docAdd = documents.find((d) => d.name === ddbName);
        if (docAdd) {
          for (const newItemName of restrictedItem.additionalItems) {
            _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Adding new item ${newItemName}`);
            const chrisDoc = await ChrisPremadesHelper.getDocumentFromName(newItemName, docAdd.type);

            // eslint-disable-next-line max-depth
            if (!chrisDoc) {
              _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`DDB Importer expected to find an item in Chris's Premades for ${newItemName} but did not`, {
                ddbName,
                doc: docAdd,
                additionalItems: restrictedItem.additionalItems,
                documents,
                chrisDoc,
              });
            } else if (!documents.some((d) => d.name === chrisDoc.name)) {
              foundry.utils.setProperty(chrisDoc, "flags.ddbimporter.ignoreItemUpdate", true);
              toAdd.push(chrisDoc);
            }
          }
        }
      }

      if (restrictedItem.removedItems && restrictedItem.removedItems.length > 0) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Removing items for ${ddbName}, using restricted data from ${restrictedItem.key}`);
        for (const removeItemName of restrictedItem.removedItems) {
          _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Removing item ${removeItemName}`);
          const deleteDoc = documents.find((d) => ChrisPremadesHelper.getOriginalName(d) === removeItemName);
          if (deleteDoc) toDelete.add(deleteDoc._id);
        }
      }

    }

    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Adding and removing the following restricted Chris's Premades", {
      toDelete,
      toAdd,
    });
    await actor.deleteEmbeddedDocuments("Item", Array.from(toDelete));
    await actor.createEmbeddedDocuments("Item", toAdd);

  }

}


/***/ }),

/***/ 767:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ ExternalAutomations)
/* harmony export */ });
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8636);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);
/* harmony import */ var _ChrisPremadesHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7252);
/* eslint-disable no-continue */
/* eslint-disable require-atomic-updates */






class ExternalAutomations {

  constructor(actor) {
    this.actor = actor;
    const dynamicSync = game.settings.get("ddb-importer", "dynamic-sync");
    const updateUser = game.settings.get("ddb-importer", "dynamic-sync-user");
    const gmSyncUser = game.user.isGM && game.user.id == updateUser;
    const tier = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getPatreonTier */ .Z.getPatreonTier();
    const tiers = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].calculateAccessMatrix */ .Z.calculateAccessMatrix(tier);
    this.dynamicUpdateAllowed = dynamicSync && gmSyncUser && tiers?.experimentalMid;
    this.dynamicUpdateStatus = this.actor.flags?.ddbimporter?.activeUpdate;
  }

  getCurrentDynamicUpdateState() {
    return this.actor.flags?.ddbimporter?.activeUpdate ?? false;
  }

  async disableDynamicUpdates() {
    if (!this.dynamicUpdateStatus) return;
    const activeUpdateData = { flags: { ddbimporter: { activeUpdate: false } } };
    await this.actor.update(activeUpdateData);
  }

  async enableDynamicUpdates() {
    if (!this.dynamicUpdateStatus) return;
    const activeUpdateData = { flags: { ddbimporter: { activeUpdate: true } } };
    await this.actor.update(activeUpdateData);
  }

  static async applyChrisPremadeEffect({ document, type, isMonster = false, folderName = null, chrisNameOverride = null } = {}) {
    return _ChrisPremadesHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].findAndUpdate */ .Z.findAndUpdate({
      document,
      type,
      folderName,
      chrisNameOverride,
      isMonster
    });
  }

  static async applyChrisPremadeEffects({ documents, compendiumItem = false, force = false, isMonster = false, folderName = null } = {}) {
    if (!game.modules.get("chris-premades")?.active) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Chris Premades not active");
      return documents;
    }

    const applyChrisEffects = force || (compendiumItem
      ? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-chris-premades")
      : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-chris-premades"));
    if (!applyChrisEffects) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Not Applying basic premades");
      return documents;
    }

    for (let doc of documents) {
      if (["class", "subclass", "background"].includes(doc.type)) continue;
      const type = _ChrisPremadesHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getTypeMatch */ .Z.getTypeMatch(doc, isMonster);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Evaluating ${doc.name} of type ${type} for Chris's Premade application.`, { type, folderName, isMonster });

      doc = await _ChrisPremadesHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].findAndUpdate */ .Z.findAndUpdate({
        document: doc,
        type,
        folderName,
        isMonster,
      });
      if (isMonster && !["monsterfeature"].includes(type) && !foundry.utils.getProperty(doc, "flags.ddbimporter.effectsApplied") === true) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`No Chris' Premade found for ${doc.name} with type "${type}", checking for monster feature.`);
        doc = await _ChrisPremadesHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].findAndUpdate */ .Z.findAndUpdate({ document: doc, type: "monsterfeature", folderName, isMonster });
      }
    }

    return documents;
  }

  static async addChrisEffectsToActorDocuments(actor) {
    if (!game.modules.get("chris-premades")?.active) {
      ui.notifications.error("Chris Premades module not installed");
      return [];
    }

    const externalAutomations = new ExternalAutomations(actor);
    await externalAutomations.disableDynamicUpdates();

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info("Starting to update actor documents with Chris Premades effects");
    let documents = actor.getEmbeddedCollection("Item").toObject();
    const isMonster = actor.type === "npc";
    const folderName = isMonster ? actor.name : null;
    const data = (await ExternalAutomations.applyChrisPremadeEffects({
      documents,
      compendiumItem: false,
      force: true,
      folderName,
      isMonster,
    }))
      .filter((d) =>
        foundry.utils.getProperty(d, "flags.ddbimporter.chrisEffectsApplied") === true
        && !foundry.utils.hasProperty(d, "flags.items-with-spells-5e.item-spells.parent-item")
      );
    const dataIds = data.map((d) => d._id);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Chris premades generation complete, beginning replace", {
      isMonster,
      folderName,
      data,
      dataIds,
      actor,
      documents,
    });
    await actor.deleteEmbeddedDocuments("Item", dataIds);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Chris premades, deletion complete");
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Creating chris premade items", data);
    await actor.createEmbeddedDocuments("Item", data, { keepId: true });
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Delete and recreate complete, beginning restricted item replacer");
    await _ChrisPremadesHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].restrictedItemReplacer */ .Z.restrictedItemReplacer(actor, folderName);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Restricted item replacer complete, beginning Replacement of Redundant Chris Documents");
    await _ChrisPremadesHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].addAndReplaceRedundantChrisDocuments */ .Z.addAndReplaceRedundantChrisDocuments(actor);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info("Effect replacement complete");
    await externalAutomations.enableDynamicUpdates();
    return data.map((d) => d.name);
  }
}


/***/ }),

/***/ 1906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": () => (/* binding */ maskOfTheWildEffect)
/* harmony export */ });
/* harmony import */ var _DDBMacros_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6516);


async function maskOfTheWildEffect(document) {
  await _DDBMacros_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].setItemMacroFlag */ .Z.setItemMacroFlag(document, "feat", "maskOfTheWild.js");
  _DDBMacros_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].setMidiOnUseMacroFlag */ .Z.setMidiOnUseMacroFlag(document, "feat", "maskOfTheWild.js", ["postActiveEffects"]);

  return document;
}


/***/ }),

/***/ 5342:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": () => (/* binding */ recklessAttackEffect)
/* harmony export */ });
/* harmony import */ var _specialFeats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6696);


function recklessAttackEffect(document, allMWAK = false) {
  let attackEffect = (0,_specialFeats_js__WEBPACK_IMPORTED_MODULE_0__/* .baseFeatEffect */ .z)(document, `${document.name} (Attack Effect)`);

  attackEffect.changes.push(
    {
      key: allMWAK ? "flags.midi-qol.advantage.attack.mwak" : "flags.midi-qol.advantage.attack.str",
      value: `1`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
  );


  foundry.utils.setProperty(attackEffect, "flags.dae.stackable", "noneName");

  document.effects.push(attackEffect);

  let defenseEffect = (0,_specialFeats_js__WEBPACK_IMPORTED_MODULE_0__/* .baseFeatEffect */ .z)(document, `${document.name} (Defense Effect)`);

  defenseEffect.changes.push(
    {
      key: "flags.midi-qol.grants.advantage.attack.all",
      value: `1`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
  );
  defenseEffect.duration = {
    startTime: null,
    seconds: 12,
    rounds: 2,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  foundry.utils.setProperty(defenseEffect, "flags.dae.specialDuration", ["turnStartSource"]);
  foundry.utils.setProperty(defenseEffect, "flags.dae.stackable", "noneName");
  defenseEffect.statuses.push("Reckless");

  document.effects.push(defenseEffect);

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = null;
  foundry.utils.setProperty(document, "system.activation.type", "special");
  document.system.duration = {
    value: 1,
    units: "turn",
  };

  return document;
}


/***/ }),

/***/ 5310:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Q": () => (/* binding */ uncannyDodgeEffect)
/* harmony export */ });
/* harmony import */ var _specialFeats_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6696);


function uncannyDodgeEffect(document) {
  let effect = (0,_specialFeats_js__WEBPACK_IMPORTED_MODULE_0__/* .baseFeatEffect */ .z)(document, `${document.name} - 1/2 Damage`);
  effect.changes.push({
    key: "flags.midi-qol.uncanny-dodge",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 10,
  });
  effect.flags.dae.specialDuration = ["1Reaction"];
  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = null;
  document.system.activation.type = "reactiondamage";
  document.effects.push(effect);
  return document;
}


/***/ }),

/***/ 4274:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FI": () => (/* binding */ generateOverTimeEffect),
/* harmony export */   "LB": () => (/* binding */ damageOverTimeEffect),
/* harmony export */   "XP": () => (/* binding */ getOvertimeDamage),
/* harmony export */   "Z1": () => (/* binding */ getMonsterFeatureDamage),
/* harmony export */   "pD": () => (/* binding */ generateConditionOnlyEffect)
/* harmony export */ });
/* harmony import */ var _specialMonsters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6934);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7669);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _effects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5751);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5259);
/* harmony import */ var _parser_monster_features_DDBMonsterFeature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(512);







const DEFAULT_DURATION = 60;

function overTimeDamage({ document, turn, damage, damageType, saveAbility, saveRemove, saveDamage, dc } = {}) {
  return {
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: `turn=${turn},label=${document.name} (${_lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].capitalize */ .Z.capitalize(turn)} of Turn),damageRoll=${damage},damageType=${damageType},saveRemove=${saveRemove},saveDC=${dc},saveAbility=${saveAbility},saveDamage=${saveDamage},killAnim=true`,
    priority: "20",
  };
}

function overTimeSave({ document, turn, saveAbility, saveRemove = true, dc } = {}) {
  const turnValue = turn === "action" ? "end" : turn;
  const actionSave = turn === "action" ? ",actionSave=true" : "";
  return {
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: `turn=${turnValue},label=${document.name} (${_lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].capitalize */ .Z.capitalize(turn)} of Turn),saveRemove=${saveRemove},saveDC=${dc},saveAbility=${saveAbility},killAnim=true${actionSave}`,
    priority: "20",
  };
}

function startOrEnd(text) {
  const re = /at the (start|end) of each/i;
  const match = text.match(re);
  if (match) {
    return match[1];
  } else {
    return undefined;
  }
}

function getDuration(text) {
  const re = /for (\d+) (minute|hour)/;
  const match = text.match(re);
  if (match) {
    let minutes = parseInt(match[1]) * 60;
    if (match[2] === "hour") {
      minutes *= 60;
    }
    return minutes;
  } else {
    const reRounds = /for (\d+) round/;
    const roundMatch = text.match(reRounds);
    if (roundMatch) {
      return roundMatch[1] * 6;
    }
  }
  return DEFAULT_DURATION;
}

// A selection of example conditions
// DC 18 Strength saving throw or be knocked prone
// DC 14 Constitution saving throw or become poisoned for 1 minute.
// DC 12 Constitution saving throw or be poisoned for 1 minute
// DC 15 Wisdom saving throw or be frightened until the end of its next turn.
// DC 15 Charisma saving throw or be charmed
// DC 12 Charisma saving throw or become cursed
// DC 10 Intelligence saving throw or it cant take a reaction until the end of its next turn
// DC 12 Constitution saving throw or contract bluerot
// DC 17 Strength saving throw or be thrown up to 30 feet away in a straight line
// DC 13 Constitution saving throw or lose the ability to use reactions until the start of the weirds
// DC 16 Wisdom saving throw or move 1 round forward in time
// DC 15 Constitution saving throw, or for 1 minute, its speed is reduced by 10 feet; it can take either an action or a bonus action on each of its turns, not both; and it cant take reactions.
// DC 15 Constitution saving throw or have disadvantage on its attack rolls until the end of its next turn
// DC 15 Wisdom saving throw or be frightened until the end of its next turn
// DC 13 Strength saving throw or take an extra 3 (1d6) piercing damage and be grappled (escape DC 13)
// DC 15 Constitution saving throw or gain 1 level of exhaustion
// DC 20 Constitution saving throw or be paralyzed for 1 minute
// DC 17 Constitution saving throw or be cursed with loup garou lycanthropy
// DC 12 Constitution saving throw or be cursed with mummy rot
// DC 18 Strength saving throw or be swallowed by the neothelid. A swallowed creature is blinded and restrained, it has total cover against attacks and other effects outside the neothelid, and it takes 35 (10d6) acid damage at the start of each of the neothelids turns.</p><p>If the neothelid takes 30 damage or more on a single turn from a creature inside it, the neothelid must succeed on a DC 18 Constitution saving throw at the end of that turn or regurgitate all swallowed creatures, which fall prone in a space within 10 feet of the neothelid. If the neothelid dies, a swallowed creature is no longer restrained by it and can escape from the corpse by using 20 feet of movement, exiting prone.
// (before DC) it cant regain hit points for 1 minute
// DC 14 Dexterity saving throw or suffer one additional effect of the shadow dancers choice:</p><ul>\n<li>The target is grappled (escape DC 14) if it is a Medium or smaller creature. Until the grapple ends, the target is restrained, and the shadow dancer cant grapple another target.</li>\n<li>The target is knocked prone.</li>\n<li>The target takes 22 (4d10) necrotic damage.</li>\n</ul>\n</section>\nThe Shadow Dancer attacks with its Spiked Chain.
// DC 15 Constitution saving throw or be stunned until the end of its next turn.
// DC 15 Constitution saving throw or die.
// DC 20 Strength saving throw or be pulled up to 25 feet toward the balor.
// DC 11 Constitution saving throw or be poisoned until the end of the targets next turn.
// DC 14 Wisdom saving throw or be frightened of the quori for 1 minute.
// DC 13 Constitution saving throw or be poisoned for 1 hour. If the saving throw fails by 5 or more, the target is also unconscious while poisoned in this way. The target wakes up if it takes damage or if another creature takes an action to shake it awake.

function getSpecialDuration(effect, match) {
  // minutes
  if (match[7]
    && (match[7].includes("until the end of its next turn")
    || match[7].includes("until the end of the target's next turn"))
  ) {
    foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnEnd"]);
  } else if (match[7] && match[7].includes("until the start of the")) {
    foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnStartSource"]);
  }
  return effect;
}

function generateConditionEffect(effect, text, nameHint = null) {
  let results = {
    success: false,
    effect,
  };

  text = _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].nameString */ .Z.nameString(text);
  const conditionSearch = /\[\[\/save (?<ability>\w+) (?<dc>\d\d) format=long\]\](?:,)? or (be |be cursed|become|die|contract|have|it can't|suffer|gain|lose the)\s?(?:knocked )?(?:&(?:amp;)?Reference\[(?<condition>\w+)\]{\w+})?\s?(?:for (\d+) (minute))?(.*)?(?:.|$)/;
  let match = text.match(conditionSearch);
  if (!match) {
    const rawConditionSearch = /DC (?<dc>\d+) (?<ability>\w+) saving throw(?:,)? or (be |be cursed|become|die|contract|have|it can't|suffer|gain|lose the)\s?(?:knocked )?(?<condition>\w+)?\s?(?:for (\d+) (minute))?(.*)?(?:.|$)/;
    match = text.match(rawConditionSearch);
  }

  // console.warn("condition status", match);
  if (match) {
    results.success = true;
    results.save = {
      dc: parseInt(match.groups["dc"]),
      ability: match.groups["ability"].toLowerCase().substr(0, 3),
      scaling: "flat",
    };
    // group 4 condition - .e.g. "DC 18 Strength saving throw or be knocked prone"
    const group4Condition = match.groups.condition
      ? _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].character.damageAdjustments.filter */ .Z.character.damageAdjustments.filter((type) => type.type === 4)
        .find(
          (type) => type.name.toLowerCase() === match.groups.condition.toLowerCase()
            || type.foundryValue === match.groups.condition.toLowerCase()
        )
      : undefined;
    if (group4Condition) {
      results.condition = group4Condition.value;
      (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .addStatusEffectChange */ .sb)(results.effect, group4Condition.name, 20, true);
      effect = getSpecialDuration(results.effect, match);
      if (nameHint) results.effect.name = `${nameHint}: ${group4Condition.name}`;
    } else if (match[3] && match[3] === "die") {
      (0,_effects_js__WEBPACK_IMPORTED_MODULE_3__/* .addStatusEffectChange */ .sb)(results.effect, "Dead", 20, true);
      if (nameHint) results.effect.name = `Condition: Dead`;
    }
  }
  return results;
}

function overTimeSaveEnd(document, effect, save, text) {
  const saveSearch = /repeat the saving throw at the (end|start) of each/;
  const match = text.match(saveSearch);
  if (match) {
    effect.changes.push(overTimeSave({ document, turn: match[1], saveAbility: save.ability, dc: save.dc }));
  } else {
    const actionSaveSearch = /can use its action to repeat the saving throw/;
    const actionSaveMatch = text.match(actionSaveSearch);
    if (actionSaveMatch) {
      effect.changes.push(overTimeSave({ document, turn: "action", saveAbility: save.ability, dc: save.dc }));
    }
  }
}

function getMonsterFeatureDamage(damageText, featureDoc = null) {
  const preParsed = foundry.utils.getProperty(featureDoc, "flags.monsterMunch.actionInfo.damage");
  if (preParsed) return preParsed;
  _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug("Monster feature damage miss", { damageText, featureDoc });
  const feature = new _parser_monster_features_DDBMonsterFeature_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("overTimeFeature", { html: damageText });
  feature.prepare();
  feature.generateExtendedDamageInfo();
  return feature.actionInfo.damage;
}

function getOvertimeDamage(text, featureDoc = null) {
  if (text.includes("taking") && (text.includes("on a failed save") || text.includes("damage on a failure"))) {
    const damageText = text.split("taking")[1];
    return getMonsterFeatureDamage(damageText, featureDoc);
  }
  return undefined;
}

function effectCleanup(document, actor, effect) {
  if (effect.changes.length > 0 || effect.statuses.length > 0) {
    document.effects.push(effect);
    let overTimeFlags = foundry.utils.hasProperty(actor, "flags.monsterMunch.overTime")
      ? foundry.utils.getProperty(actor, "flags.monsterMunch.overTime")
      : [];
    overTimeFlags.push(document.name);
    foundry.utils.setProperty(actor, "flags.monsterMunch.overTime", overTimeFlags);
    // console.warn(`ITEM OVER TIME EFFECT: ${actor.name}, ${document.name}`);
    if (foundry.utils.getProperty(document, "system.duration.units") === "inst") {
      foundry.utils.setProperty(document, "system.duration", {
        units: "round",
        value: effect.duration.rounds,
      });
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Cleanup of over time effect for ${actor.name}, ${actor.name} for ${document.name}`, effect);
  }
  return { document, actor };
}

function generateConditionOnlyEffect(actor, document) {
  _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Checking for condition effects for ${document.name} on ${actor.name}`);
  if (!document.effects) document.effects = [];
  let effect = (0,_specialMonsters_js__WEBPACK_IMPORTED_MODULE_0__/* .baseMonsterFeatureEffect */ .Kh)(document, `${document.name}`);
  // add any condition effects
  const conditionResults = generateConditionEffect(effect, document.system.description.value, document.name);
  effect = conditionResults.effect;

  const durationSeconds = foundry.utils.hasProperty(document.flags, "monsterMunch.overTime.durationSeconds")
    ? foundry.utils.getProperty(document.flags, "monsterMunch.overTime.durationSeconds")
    : getDuration(document.system.description.value);
  foundry.utils.setProperty(effect, "duration.seconds", durationSeconds);
  const durationRounds = Number.parseInt(durationSeconds / 6);
  foundry.utils.setProperty(effect, "duration.rounds", durationRounds);

  const result = effectCleanup(document, actor, effect);
  return result;
}

function generateOverTimeEffect(actor, document) {
  _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Checking for over time effects for ${document.name} on ${actor.name}`);
  if (!document.effects) document.effects = [];
  let effect = (0,_specialMonsters_js__WEBPACK_IMPORTED_MODULE_0__/* .baseMonsterFeatureEffect */ .Kh)(document, `${document.name}`);
  // add any condition effects
  const conditionResults = generateConditionEffect(effect, document.system.description.value);
  effect = conditionResults.effect;
  if (conditionResults.success) {
    foundry.utils.setProperty(document, "flags.midiProperties.fulldam", true);
    overTimeSaveEnd(document, effect, conditionResults.save, document.system.description.value);
  }

  const durationSeconds = foundry.utils.hasProperty(document.flags, "monsterMunch.overTime.durationSeconds")
    ? foundry.utils.getProperty(document.flags, "monsterMunch.overTime.durationSeconds")
    : getDuration(document.system.description.value);
  foundry.utils.setProperty(effect, "duration.seconds", durationSeconds);
  const durationRounds = Number.parseInt(durationSeconds / 6);
  foundry.utils.setProperty(effect, "duration.rounds", durationRounds);

  const turn = startOrEnd(document.system.description.value);
  if (!turn) {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`No turn over time effect for ${document.name} on ${actor.name}`);
    return effectCleanup(document, actor, effect);
  }

  const saveFeature = new _parser_monster_features_DDBMonsterFeature_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("overTimeSaveFeature", { html: document.system.description.value });
  saveFeature.prepare();
  const save = saveFeature.getFeatSave();
  if (!Number.isInteger(Number.parseInt(save.dc))) return effectCleanup(document, actor, effect);

  const saveAbility = save.ability;
  const dc = save.dc;

  const dmg = getOvertimeDamage(document.system.description.value, document);
  if (!dmg) {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Adding non damage Overtime effect for ${document.name} on ${actor.name}`);
    return effectCleanup(document, actor, effect);
  }

  // overtime damage, revert any full damage flag, reset to default on save
  foundry.utils.setProperty(document, "flags.midiProperties.fulldam", false);

  const damage = foundry.utils.hasProperty(document.flags, "monsterMunch.overTime.damage")
    ? foundry.utils.getProperty(document.flags, "monsterMunch.overTime.damage")
    : dmg.parts.reduce((total, current) => {
      total = [total, `${current[0]}[${current[1]}]`].join(" + ");
      return total;
    }, "");

  const damageType = foundry.utils.hasProperty(document.flags, "monsterMunch.overTime.damageType")
    ? foundry.utils.getProperty(document.flags, "monsterMunch.overTime.damageType")
    : dmg.parts.length > 0
      ? dmg.parts[0][1]
      : "";

  const saveRemove = foundry.utils.hasProperty(document.flags, "monsterMunch.overTime.saveRemove")
    ? foundry.utils.getProperty(document.flags, "monsterMunch.overTime.saveRemove")
    : true;

  const saveDamage = foundry.utils.hasProperty(document.flags, "monsterMunch.overTime.saveDamage")
    ? foundry.utils.getProperty(document.flags, "monsterMunch.overTime.saveDamage")
    : "nodamage";

  _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`generateOverTimeEffect: Generated over time effect for ${actor.name}, ${document.name}`);
  effect.changes.push(overTimeDamage({ document, turn, damage, damageType, saveAbility, saveRemove, saveDamage, dc }));

  const result = effectCleanup(document, actor, effect);
  return result;
}


function damageOverTimeEffect({ document, startTurn = false, endTurn = false, durationSeconds, damage,
  damageType, saveAbility, saveRemove = true, saveDamage = "nodamage", dc } = {}
) {
  let effect = (0,_specialMonsters_js__WEBPACK_IMPORTED_MODULE_0__/* .baseMonsterFeatureEffect */ .Kh)(document, `${document.name}`);

  if (!startTurn && !endTurn) return document;

  if (startTurn) {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`damageOverTimeEffect: Generating damage over time effect START for ${document.name}`);
    effect.changes.push(
      overTimeDamage({ document, turn: "start", damage, damageType, saveAbility, saveRemove, saveDamage, dc })
    );
  }
  if (endTurn) {
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`damageOverTimeEffect: Generating damage over time effect END for ${document.name}`);
    effect.changes.push(
      overTimeDamage({ document, turn: "end", damage, damageType, saveAbility, saveRemove, saveDamage, dc })
    );
  }

  foundry.utils.setProperty(effect, "duration.seconds", durationSeconds);

  document.effects.push(effect);
  return document;
}


/***/ }),

/***/ 7309:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "_": () => (/* binding */ equipmentEffectAdjustment),
  "i": () => (/* binding */ midiItemEffects)
});

// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
;// CONCATENATED MODULE: ./src/effects/items/bootsOfSpeed.js


function bootsOfSpeedEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name}`);
  effect.changes.push((0,effects/* generateMultiplyChange */.zs)(2, 20, "system.attributes.movement.walk"));
  effect.duration = {
    startTime: null,
    seconds: 600,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  effect.transfer = true;
  effect.disabled = true;
  effect.flags.dae.transfer = true;
  effect.flags.dae.stackable = true;
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  document.system.activation.type = "bonus";
  document.effects.push(effect);

  return document;
}

// EXTERNAL MODULE: ./src/effects/DDBMacros.js
var DDBMacros = __webpack_require__(6516);
;// CONCATENATED MODULE: ./src/effects/items/cloakOfDisplacement.js



async function cloakOfDisplacementEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name} - Check`);
  foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "item", "cloakOfDisplacement.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "item", macroName: "cloakOfDisplacement.js" }));
  // eslint-disable-next-line require-atomic-updates
  document.effects[0] = effect;

  // foundry.utils.setProperty(document.effects[0], "flags.dae.specialDuration", ["isDamaged"]);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/items/javelinOfLightning.js



async function javelinOfLightningEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name}: Used Effect Tracker`);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "item", "javelinOfLightning.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: `"${document.name}"`, macroType: "item", macroName: "javelinOfLightning.js" }));
  effect.transfer = false;
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["newDay", "longRest"]);
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "item", "javelinOfLightning.js", ["postActiveEffects", "postDamageRoll", "preAttackRoll"]);

  // foundry.utils.setProperty(document.effects[0], "flags.dae.specialDuration", ["isDamaged"]);
  document.system.uses = {
    value: null,
    max: "",
    per: "",
  };

  document.system.formula = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/items/moonSickle.js
function moonSickleEffect(document) {
  document.effects[0].changes.push(
    {
      key: "system.bonuses.heal.damage",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+ d4",
      priority: "20",
    },
  );

  return document;
}

;// CONCATENATED MODULE: ./src/effects/items/pearlOfPower.js



async function pearlOfPowerEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "item", "pearlOfPower.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: `"${document.name}"`, macroType: "item", macroName: "pearlOfPower.js" }));
  effect.transfer = false;
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/items/stoneOfGoodLuck.js


function stoneOfGoodLuckEffect(document) {
  document.effects = [];

  const effect = (0,effects/* baseItemEffect */.uT)(document, document.name);

  effect.changes.push(
    {
      key: "system.bonuses.abilities.save",
      value: "+1",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 1,
    },
    {
      key: "system.bonuses.abilities.check",
      value: "+1",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 1,
    },
  );

  document.effects.push(effect);


  return document;
}

// EXTERNAL MODULE: ./src/effects/spells/haste.js
var haste = __webpack_require__(2391);
;// CONCATENATED MODULE: ./src/effects/specialEquipment.js

// load item effects









async function midiItemEffects(document) {

  const name = document.flags.ddbimporter?.originalName || document.name;

  switch (name) {
    case "Horn of Blasting": {
      document = (0,effects/* addSimpleConditionEffect */.x8)(document, "deafened");
      break;
    }
    // no default
  }

  if (!(0,effects/* effectModules */.xV)().hasCore) return document;
  document = (0,effects/* applyDefaultMidiFlags */.VN)(document);

  switch (name) {
    case "Cloak of Displacement": {
      document = await cloakOfDisplacementEffect(document);
      break;
    }
    case "Javelin of Lightning":
    case "Tempus Javelin": {
      document = await javelinOfLightningEffect(document);
      break;
    }
    case "Pearl of Power": {
      document = await pearlOfPowerEffect(document);
      break;
    }
    case "Potion of Speed": {
      document = (0,haste/* hasteEffect */.r)(document);
      break;
    }
    case "Spellguard Shield": {
      if (document.effects && document.effects.length > 0) {
        document.effects[0].changes.push(
          (0,effects/* generateCustomChange */.wv)(1, 20, "flags.midi-qol.grants.disadvantage.attack.msak"),
          (0,effects/* generateCustomChange */.wv)(1, 20, "flags.midi-qol.grants.disadvantage.attack.rsak")
        );
      }
      break;
    }
    // no default
  }

  return (0,effects/* forceItemEffect */.Wk)(document);
}

/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
function equipmentEffectAdjustment(document) {
  const name = document.flags.ddbimporter?.originalName ?? document.name;
  switch (name) {
    case "Armor of Invulnerability": {
      // this effect is 1/day, we have to add it
      let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name} - Invulnerability`, { transfer: false, disabled: false });
      effect.changes.push((0,effects/* generateUnsignedAddChange */.Tq)("physical", 20, "system.traits.di.value"));
      effect.duration = {
        startTime: null,
        seconds: 600,
        rounds: null,
        turns: null,
        startRound: null,
        startTurn: null,
      };
      effect.flags.dae.stackable = false;
      document.system.uses = {
        value: 1,
        max: "1",
        per: "day",
      };
      document.system.target = {
        value: null,
        width: null,
        units: "",
        type: "self",
      };
      document.system.range = {
        value: null,
        long: null,
        units: "self",
      };
      document.effects.push(effect);
      break;
    }
    case "Bracers of Archery": {
      // +2 damage to longbows/shortbows translates to +2 ranged weapon damage
      document.effects[0].changes.push({
        key: "system.bonuses.rwak.damage",
        value: "+2",
        mode: 0,
        priority: 20,
      });
      break;
    }
    case "Demon Armor": {
      // Unarmed strikes bonus/weapons
      document.effects[0].changes.push(
        {
          key: "items.Unarmed Strike.system.attack.bonus",
          value: "1",
          mode: 2,
          priority: 20,
        },
        {
          key: "items.Unarmed Strike.system.damage.parts.0.0",
          value: "1d8+@mod+1",
          mode: 5,
          priority: 20,
        },
        {
          key: "items.Unarmed Strike.system.properties.mgc",
          value: "true",
          mode: 5,
          priority: 20,
        }
      );
      break;
    }
    case "Belashyrras Beholder Crown": {
      let effect = (0,effects/* baseItemEffect */.uT)(document, `${document.name} - Passive Effects`);
      effect.changes.push((0,effects/* generateUpgradeChange */.OY)(120, 10, "system.attributes.senses.darkvision"));
      document.effects.push(effect);
      break;
    }
    case "Boots of Speed": {
      document = bootsOfSpeedEffect(document);
      break;
    }
    case "Moon Sickle, +1":
    case "Moon Sickle, +2":
    case "Moon Sickle, +3":
    case "Moon Sickle": {
      document = moonSickleEffect(document);
      break;
    }
    case "Stone of Good Luck (Luckstone)":
    case "Luckstone":
    case "Stone of Good Luck": {
      document = stoneOfGoodLuckEffect(document);
      break;
    }
    // no default
  }

  return (0,effects/* forceItemEffect */.Wk)(document);
}


/***/ }),

/***/ 6696:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "z": () => (/* binding */ baseFeatEffect),
  "M": () => (/* binding */ featureEffectAdjustment)
});

// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
;// CONCATENATED MODULE: ./src/effects/feats/alert.js


function alertEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);

  effect.changes.push({
    key: "flags.dnd5e.initiativeAlert",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: "0",
  });

  document.effects = [
    effect,
  ];
  return document;
}

// EXTERNAL MODULE: ./src/effects/DDBMacros.js
var DDBMacros = __webpack_require__(6516);
;// CONCATENATED MODULE: ./src/effects/feats/ancestralProtectors.js



async function ancestralProtectorsEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "ancestralProtectors.js");

  let effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push(
    DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "postAttackRoll", macroType: "spell", macroName: "ancestralProtectors.js", document }),
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/arcaneRecovery.js



async function arcaneRecoveryEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "arcaneRecovery.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "feat", macroName: "arcaneRecovery.js" }));
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);
  document.system.actionType = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/arcaneWard.js



async function arcaneWardEffect(document) {
  let detectionEffect = (0,effects/* baseItemEffect */.uT)(document, `${document.name}: Spell Detection`);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "arcaneWard.js");

  detectionEffect.changes.push(
    DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "preActiveEffects", macroType: "spell", macroName: "arcaneWard.js", document }),
  );

  document.effects.push(detectionEffect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/auraOfHate.js



function auraOfHateEffect(document) {

  let alliesEffect = (0,effects/* baseItemEffect */.uT)(document, `${document.name} (Self) - Passive`);
  alliesEffect.changes.push({
    "key": "system.bonuses.mwak.damage",
    "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
    "value": "+@abilities.cha.mod",
    "priority": 20
  });
  alliesEffect.statuses.push(alliesEffect.name);
  foundry.utils.setProperty(alliesEffect, "flags.dae.stackable", "none");

  document.effects.push(alliesEffect);


  if (!game.modules.get("ActiveAuras")?.active) return document;

  let otherEffect = (0,effects/* baseItemEffect */.uT)(document, `${document.name} (Fiends & Undead) - Passive`);
  otherEffect.flags.ActiveAuras = {
    aura: "All",
    radius: "@scale.oathbreaker.aura-of-hate",
    isAura: true,
    ignoreSelf: true,
    inactive: false,
    hidden: false,
    displayTemp: true,
    type: "undead; fiend",
  };
  otherEffect.changes.push({
    "key": "system.bonuses.mwak.damage",
    "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
    "value": "+@abilities.cha.mod",
    "priority": 20
  });
  otherEffect.statuses.push(otherEffect.name);

  foundry.utils.setProperty(otherEffect, "flags.dae.stackable", "none");

  document.effects.push(otherEffect);


  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/bardicInspiration.js


function bardicInspirationEffect(document) {
  document.system.damage.parts = [];
  let inspiredEffect = (0,effects/* baseItemEffect */.uT)(document, "Inspired");

  const diceString = "@scale.bard.bardic-inspiration";
  inspiredEffect.changes.push(
    {
      key: "flags.midi-qol.optional.bardicInspiration.attack.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: diceString,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.bardicInspiration.save.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: diceString,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.bardicInspiration.check.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: diceString,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.bardicInspiration.skill.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: diceString,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.bardicInspiration.label",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "Bardic Inspiration",
      priority: "20",
    }
  );
  inspiredEffect.transfer = false;
  inspiredEffect.disabled = false;
  foundry.utils.setProperty(inspiredEffect, "flags.dae.transfer", false);
  foundry.utils.setProperty(inspiredEffect, "flags.dae.stackable", false);
  foundry.utils.setProperty(inspiredEffect, "flags.dae.macroRepeat", "none");
  foundry.utils.setProperty(inspiredEffect, "flags.dae.specialDuration", []);

  if (document.flags.ddbimporter.subclass === "College of Valor") {
    inspiredEffect.changes.push(
      {
        key: "flags.midi-qol.optional.bardicInspiration.damage.all",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: diceString,
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.bardicInspiration.ac.all",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: diceString,
        priority: "20",
      }
    );
  }

  document.effects.push(inspiredEffect);

  foundry.utils.setProperty(document, "flags.midi-qol.effectActivation", false);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/bladesong.js



function bladesongEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`);

  foundry.utils.setProperty(document, "system.range", { value: null, units: "self", long: null });
  foundry.utils.setProperty(document, "system.range.value", null);
  foundry.utils.setProperty(document, "system.target.type", "self");
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);

  effect.changes.push(
    {
      key: "system.attributes.ac.bonus",
      value: "max(@abilities.int.mod,1)",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "system.attributes.concentration.bonuses.save",
      value: "max(@abilities.int.mod,1)",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "system.attributes.movement.walk",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "10",
      priority: "20",
    },
  );
  effect.duration = {
    startTime: null,
    seconds: 60,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push({
      key: "flags.midi-qol.advantage.skill.acr",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    });
  }

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/blessedHealer.js



async function blessedHealerEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "blessedHealer.js");

  effect.changes.push(
    DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "postActiveEffects", macroType: "feat", macroName: "blessedHealer.js", document }),
  );
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "blessedHealer.js", ["postActiveEffects"]);

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/blessedStrikes.js


function blessedStrikesEffect(document) {
  if (document.system.actionType === null) return document;
  let effect = baseFeatEffect(document, document.name, { transfer: true });

  effect.changes.push(
    {
      key: "flags.midi-qol.optional.blessedstrikes.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.name} Bonus Damage`,
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.blessedstrikes.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "each-round",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.blessedstrikes.damage.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.system.damage.parts[0][0]}`,
      priority: "5",
    },
  );

  document.system.damage.parts = [];
  document.system.actionType = null;

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/cloudRune.js
function cloudRuneEffect(document) {
  // Missing: reaction effect to transfer attack
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/crossbowExpert.js


function crossbowExpertEffect(document) {
  let effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push({
    key: "flags.midi-qol.ignoreNearbyFoes",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: 20,
  });
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/crusherCritical.js




async function crusherCriticalEffect(document) {
  const effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "crusherCritical.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  document.effects.push(effect);
  document.system.actionType = null;

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "crusherCritical.js");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/crusher.js




async function crusherEffect(document) {
  const effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "crusher.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  document.effects.push(effect);

  document.system.actionType = null;

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "crusher.js");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/dauntingRoar.js





function dauntingRoarEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Frightened", 20, true);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnEndSource", "endCombat"]);
  effect.duration.seconds = 12;
  effect.duration.turns = 2;

  document.effects.push(effect);
  // document.system.range = { value: null, units: "spec", long: null };
  // document.system.target = { value: 10, width: null, units: "ft", type: "enemy" };
  // document.system.activation.condition = "!target.effects.some((e) => e.name.toLowerCase().includes('deafened'))";

  foundry.utils.setProperty(document.flags, "midi-qol.effectActivation", true);

  foundry.utils.setProperty(document, "flags.midi-qol.itemCondition", "");
  foundry.utils.setProperty(document, "flags.midi-qol.effectCondition", "!target.effects.some((e) => e.name.toLowerCase().includes('deafened'))");
  foundry.utils.setProperty(document, "flags.midi-qol.AoETargetType", "enemy");
  foundry.utils.setProperty(document, "flags.midi-qol.AoETargetTypeIncludeSelf", false);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/defensiveDuelist.js


function defensiveDuelistEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.ac.bonus",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+ @system.attributes.prof",
      priority: "20",
    },
  );
  foundry.utils.setProperty(effect, "duration.turns", 1);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isAttacked"]);
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  document.system.duration = {
    value: null,
    units: "inst",
  };
  document.system.actionType = null;
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/deflectMissilesAttack.js


function deflectMissilesAttackEffect(document) {
  document = (0,effects/* forceManualReaction */.pi)(document);
  foundry.utils.setProperty(document, "system.range.long", 60);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/deflectMissiles.js


function deflectMissilesEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.DR.rwak",
    value: "[[1d10 + @mod + @classes.monk.levels]]",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 0,
  });
  effect.flags.dae.specialDuration = ["1Reaction"];
  // foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  // foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  foundry.utils.setProperty(document, "system.activation.type", "reactiondamage");
  // document.system.actionType = null;

  document.system.damage.parts = [];
  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/deftStike.js


function deftStrikeEffect(document) {
  let effect = baseFeatEffect(document, document.name, { transfer: true });

  effect.changes.push(
    {
      key: "flags.midi-qol.optional.deftStrike.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.name} Additional Damage`,
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.deftStrike.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "turn",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.deftStrike.damage.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "@scale.monk.martial-arts",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.deftStrike.countAlt",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "ItemUses.Ki Points",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.deftStrike.criticalDamage",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "5",
    },
  );

  document.system.damage.parts = [];
  document.system.actionType = null;

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/evasion.js


function evasionEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`, true);

  effect.changes.push(
    {
      key: "flags.midi-qol.superSaver.dex",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/favoredFoe.js



// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor
// the Marked effect gets applied to the target
async function favoredFoeEffect(document) {
  let effect = baseFeatEffect(document, `Marked by ${document.name}`, { transfer: false });
  effect.changes.push(
    {
      key: "flags.dae.onUpdateSource",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: document.name,
      priority: 20,
    },
  );
  effect.duration.seconds = 60;
  document.effects.push(effect);

  let damageBonusEffect = baseFeatEffect(document, document.name, { transfer: true });
  damageBonusEffect.changes.push({
    key: "flags.dnd5e.DamageBonusMacro",
    value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "favoredFoe.js", document }),
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 20,
  });
  document.effects.push(damageBonusEffect);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "favoredFoe.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "favoredFoe.js", ["postActiveEffects"]);

  foundry.utils.setProperty(document, "system.actionType", "util");
  document.system.damage.parts = [];
  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "",
  };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/fightingStyles.js


function fightingStyleInterceptionEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.DR.rwak",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1d10 + @system.attributes.prof",
      priority: "20",
    },
    {
      key: "flags.midi-qol.DR.mwak",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1d10 + @system.attributes.prof",
      priority: "20",
    },
    {
      key: "flags.midi-qol.DR.msak",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1d10 + @system.attributes.prof",
      priority: "20",
    },
    {
      key: "flags.midi-qol.DR.rsak",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1d10 + @system.attributes.prof",
      priority: "20",
    }
  );
  foundry.utils.setProperty(effect, "duration.turns", 1);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isDamaged"]);
  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.damage.parts = [];
  document.system.duration = {
    value: null,
    units: "inst",
  };
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/fireRune.js



function fireRuneEffect(document) {
  foundry.utils.setProperty(document, "system.range.units", "");
  foundry.utils.setProperty(document, "system.target.value", 1);
  foundry.utils.setProperty(document, "system.target.type", "creature");

  let baseEffect = baseFeatEffect(document, document.name);
  foundry.utils.setProperty(baseEffect, "duration.seconds", 60);


  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    (0,effects/* addStatusEffectChange */.sb)(baseEffect, "Restrained", 20, true);
    baseEffect.changes.push(
      {
        key: "flags.midi-qol.OverTime",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: `label=${document.name} (Start of Turn Damage),turn=start,savingThrow=false,damageRoll=${document.system.damage.parts[0][0]}, damageType=${document.system.damage.parts[0][1]},killAnim=true`,
        priority: "20",
      },
      {
        key: "flags.midi-qol.OverTime",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: `label=${document.name} (End of Turn Save),turn=end,saveDC=@attributes.spelldc,saveAbility=${document.system.save.ability},savingThrow=true,saveMagic=true,saveRemove=true,killAnim=true`,
        priority: "20",
      }
    );
  } else {
    let restrainedEffect = baseFeatEffect(document, `${document.name} (Restrained)`);
    (0,effects/* addStatusEffectChange */.sb)(restrainedEffect, "Restrained", 20, true);
    foundry.utils.setProperty(restrainedEffect, "duration.seconds", 60);
    document.effects.push(restrainedEffect);
  }

  document.effects.push(baseEffect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/fontOfMagic.js



async function fontOfMagicEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "fontOfMagic.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "fontOfMagic.js", ["preItemRoll"]);

  document.effects.push(effect);
  document.system.activation.type = "bonus";
  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/formOfTheBeastReaction.js


function formOfTheBeastReactionEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.ac.bonus",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+ 1d8",
      priority: "20",
    },
  );
  foundry.utils.setProperty(effect, "duration.turns", 1);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isAttacked"]);
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.damage.parts = [];
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  document.system.duration = {
    value: null,
    units: "inst",
  };
  document.system.actionType = null;
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/frostRune.js


function frostRuneEffect(document) {
  foundry.utils.setProperty(document, "system.target.type", "self");
  foundry.utils.setProperty(document, "system.range.units", "self");
  foundry.utils.setProperty(document, "system.range.value", "");
  foundry.utils.setProperty(document, "system.actionType", null);

  let bonusEffect = baseFeatEffect(document, `${document.name} (Sturdiness)`);
  bonusEffect.changes.push(
    {
      key: "system.abilities.con.bonuses.check",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+2",
      priority: "20",
    },
    {
      key: "system.abilities.con.bonuses.save",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+2",
      priority: "20",
    },
    {
      key: "system.abilities.str.bonuses.check",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+2",
      priority: "20",
    },
    {
      key: "system.abilities.str.bonuses.save",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "+2",
      priority: "20",
    },
  );
  foundry.utils.setProperty(bonusEffect, "duration.seconds", 600);
  document.effects.push(bonusEffect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/giantsMight.js



function giantsMightEffect(document) {
  let effect = baseFeatEffect(document, document.name);

  if ((0,effects/* effectModules */.xV)().atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.width", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 2, 5));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.height", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 2, 5));
  }

  effect.changes.push(
    {
      key: "system.traits.size",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "lg",
      priority: 25,
    },
    {
      key: "flags.midi-qol.advantage.ability.save.str",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "5",
    },
    {
      key: "flags.midi-qol.advantage.ability.check.str",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.giantsmight.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Giant's Might Bonus Damage",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.giantsmight.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "turn",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.giantsmight.damage.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.system.damage.parts[0][0]}`,
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.giantsmight.criticalDamage",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "5",
    },
  );

  document.system.damage.parts = [];

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/hadozeeDodge.js




function hadozeDodgeEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.DR.all",
    value: "[[+1d6 + @attributes.prof]]",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: 20,
  });
  effect.flags.dae.specialDuration = ["1Reaction"];
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(document, "system.activation.type", "reactiondamage");

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.damage.parts = [];
  document.system.ability = null;

  document.effects.push(effect);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/heavyArmorMaster.js



function heavyArmorMasterEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`, { transfer: true });
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push(
      {
        key: "flags.midi-qol.DR.non-magical",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "3",
        priority: "20",
      },
    );
  } else {
    effect.changes.push(
      {
        key: "system.traits.dm.amount.bludgeoning",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: "-3",
        priority: "20",
      },
      {
        key: "system.traits.dm.amount.slashing",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: "-3",
        priority: "20",
      },
      {
        key: "system.traits.dm.amount.piercing",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: "-3",
        priority: "20",
      },
      {
        key: "system.traits.dm.bypasses",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: "mgc",
        priority: "20",
      },
    );
  }

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/hillRune.js


function hillRuneEffect(document) {
  foundry.utils.setProperty(document, "system.target.type", "self");
  foundry.utils.setProperty(document, "system.range.units", "self");
  foundry.utils.setProperty(document, "system.range.value", "");
  foundry.utils.setProperty(document, "system.actionType", null);

  let bonusEffect = baseFeatEffect(document, `${document.name} (Resistance)`);
  bonusEffect.changes.push(
    {
      key: "system.traits.dr.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "bludgeoning",
      priority: "20",
    },
    {
      key: "system.traits.dr.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "slashing",
      priority: "20",
    },
    {
      key: "system.traits.dr.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "piercing",
      priority: "20",
    },
  );
  foundry.utils.setProperty(bonusEffect, "duration.seconds", 60);

  document.effects.push(bonusEffect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/holdBreath.js


function holdBreathEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  effect.duration.rounds = 600;
  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.effects.push(effect);

  foundry.utils.setProperty(document, "flags.midiProperties.toggleEffect", true);
  document.system.activation = {
    "type": "special",
    "cost": 1,
    "condition": ""
  };

  if (document.name === "Partially Amphibious") {
    document.system.uses = { value: 1, max: "1", per: "lr", type: "" };
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/indomitable.js


function indomitableEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.optional.Indomitable.save.fail",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "reroll",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.Indomitable.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "ItemUses.Indomitable",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.Indomitable.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Use Indomitable to Succeed?",
      priority: "20",
    }
  );
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/kiEmptyBody.js



function kiEmptyBodyEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    { key: "system.traits.dr.all", value: "", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.traits.dv.value", value: "force", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
  );

  (0,effects/* addStatusEffectChange */.sb)(effect, "invisible");

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.duration = { value: 1, units: "min" };
  document.system.actionType = null;

  document.effects.push(effect);
  return document;
}

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
;// CONCATENATED MODULE: ./src/effects/feats/maneuvers.js





function dermineDiceString(ddb) {
  const fighterClass = ddb.character.classes.find((klass) => klass.definition.name === "Fighter");
  if (fighterClass) {
    const combatSuperiority = fighterClass.classFeatures.find((feat) => feat.definition.name === "Combat Superiority");
    if (combatSuperiority) {
      return "@scale.battle-master.combat-superiority-die";
    }
  }
  return "1d6";
}

// eslint-disable-next-line complexity
async function maneuversEffect(ddb, character, document) {
  const diceString = dermineDiceString(ddb);

  logger/* default.debug */.Z.debug(`Generating effect for ${document.name}`);

  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  const ability = characterAbilities.str?.value > characterAbilities.dex?.value ? "str" : "dex";

  const name = document.flags.ddbimporter?.originalName ?? document.name;
  let effect = baseFeatEffect(document, document.name);
  foundry.utils.setProperty(document, "system.range.units", "");
  foundry.utils.setProperty(document, "system.range.value", null);
  foundry.utils.setProperty(document, "system.target.type", "self");

  // special durations
  switch (name) {
    case "Maneuvers: Rally": {
      foundry.utils.setProperty(effect, "duration.seconds", 86400);
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["longRest"]);
      break;
    }
    case "Maneuvers: Brace":
    case "Maneuvers: Riposte": {
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Attack:mwak"]);
      foundry.utils.setProperty(effect, "duration.turns", 2);
      break;
    }
    case "Maneuvers: Lunging Attack":
    case "Maneuvers: Sweeping Attack": {
      foundry.utils.setProperty(effect, "duration.turns", 1);
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Attack:mwak"]);
      break;
    }
    case "Maneuvers: Quick Toss": {
      foundry.utils.setProperty(effect, "duration.turns", 1);
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Attack:rwak"]);
      break;
    }
    case "Maneuvers: Tactical Assessment": {
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isSkill.inv", "isSkill.his", "isSkill.ins"]);
      break;
    }
    case "Maneuvers: Commanding Presence": {
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isSkill.itm", "isSkill.per", "isSkill.prf"]);
      break;
    }
    case "Maneuvers: Ambush": {
      foundry.utils.setProperty(effect, "duration.turns", 1);
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isSkill.ste"]);
      break;
    }
    case "Maneuvers: Distracting Strike": {
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isAttacked", "turnStartSource"]);
      break;
    }
    case "Maneuvers: Bait and Switch": {
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnStartSource"]);
      break;
    }
    case "Maneuvers: Feinting Attack": {
      foundry.utils.setProperty(effect, "duration.turns", 1);
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Attack"]);
      break;
    }
    case "Maneuvers: Trip Attack": {
      foundry.utils.setProperty(document, "system.duration.units", "inst");
      break;
    }
    case "Maneuvers: Menacing Attack":
    case "Maneuvers: Goading Attack": {
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnEndSource"]);
      break;
    }
    case "Maneuvers: Grappling Strike": {
      foundry.utils.setProperty(effect, "duration.turns", 1);
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isSkill.ath"]);
      break;
    }
    case "Maneuvers: Parry": {
      foundry.utils.setProperty(document, "system.duration.units", "inst");
      foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isDamaged"]);
      break;
    }
    // no default
  }

  const damageEffect = {
    "key": "system.bonuses.mwak.damage",
    "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
    "value": `+ ${diceString}`,
    "priority": "20"
  };
  // damage effect
  switch (name) {
    case "Maneuvers: Riposte":
    case "Maneuvers: Brace": {
      // manual reaction types
      document = (0,effects/* forceManualReaction */.pi)(document);
      effect.changes.push(damageEffect);
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Quick Toss":
    case "Maneuvers: Lunging Attack":
    case "Maneuvers: Feinting Attack": {
      effect.changes.push(damageEffect);
      document.effects.push(effect);
      break;
    }
    // no default
  }

  const rangedDamageEffect = {
    "key": "system.bonuses.rwak.damage",
    "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
    "value": `+ ${diceString}`,
    "priority": "20"
  };
  // damage effect
  switch (name) {
    case "Maneuvers: Commanders Strike":
    case "Maneuvers: Commander's Strike": {
      effect.changes.push(damageEffect);
      effect.changes.push(rangedDamageEffect);
      document.effects.push(effect);
      break;
    }
    // no default
  }

  // other effects
  switch (name) {
    // advantage effect
    case "Maneuvers: Distracting Strike":
    case "Maneuvers: Feinting Attack": {
      effect.changes.push(
        {
          "key": "flags.midi-qol.advantage.attack.all",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": "1",
          "priority": "20"
        }
      );
      document.effects.push(effect);
      break;
    }
    // skill bonus
    case "Maneuvers: Commanding Presence": {
      ["per", "itm", "prf"].forEach((skill) => {
        effect.changes.push(
          {
            "key": `system.skills.${skill}.bonuses.check`,
            "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
            "value": `+ ${diceString}`,
            "priority": "20"
          }
        );
      });
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Tactical Assessment": {
      ["inv", "his", "ins"].forEach((skill) => {
        effect.changes.push(
          {
            "key": `system.skills.${skill}.bonuses.check`,
            "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
            "value": `+ ${diceString}`,
            "priority": "20"
          }
        );
      });
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Ambush": {
      effect.changes.push(
        {
          "key": "system.skills.ste.bonuses.check",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": `+ ${diceString}`,
          "priority": "20"
        },
        {
          "key": "system.attributes.init.bonus",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": `+ ${diceString}`,
          "priority": "20"
        }
      );
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Evasive Footwork":
    case "Maneuvers: Bait and Switch": {
      effect.changes.push(
        {
          "key": "system.attributes.ac.bonus",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": `+ ${diceString}`,
          "priority": "20"
        }
      );
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Grappling Strike": {
      effect.changes.push(
        {
          "key": "system.skills.ath.bonuses.check",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": `+ ${diceString}`,
          "priority": "20"
        },
      );
      document.effects.push(effect);
      break;
    }
    case "Maneuvers: Menacing Attack": {
      (0,effects/* addStatusEffectChange */.sb)(effect, "Frightened", 20, true);
      break;
    }
    case "Maneuvers: Trip Attack": {
      (0,effects/* addStatusEffectChange */.sb)(effect, "Prone", 20, true);
      break;
    }
    case "Maneuvers: Parry": {
      foundry.utils.setProperty(document, "system.activation.type", "reactiondamage");
      effect.changes.push(
        {
          "key": "flags.midi-qol.DR.all",
          "mode": CONST.ACTIVE_EFFECT_MODES.ADD,
          "value": "1",
          "priority": "20"
        }
      );
      break;
    }
    case "Maneuvers: Rally": {
      await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "maneuversRally.js");
      effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: `${diceString} @abilities.cha.mod`, macroType: "feat", macroName: "maneuversRally.js" }));
      document.effects.push(effect);
      break;
    }
    // no default
  }
  // flags.dnd5e.initiativeAdv

  // set target
  switch (name) {
    case "Maneuvers: Trip Attack":
    case "Maneuvers: Maneuvering Attack":
    case "Maneuvers: Goading Attack":
    case "Maneuvers: Distracting Strike":
    case "Maneuvers: Menacing Attack":
    case "Maneuvers: Sweeping Attack":
    case "Maneuvers: Disarming Attack":
    case "Maneuvers: Pushing Attack":
    case "Maneuvers: Rally":
    case "Maneuvers: Bait and Switch":
    case "Maneuvers: Commanders Strike":
    case "Maneuvers: Commander's Strike": {
      foundry.utils.setProperty(document, "system.target.value", 1);
      foundry.utils.setProperty(document, "system.target.type", "creature");
      break;
    }
    // no default
  }

  // set regular damage
  switch (name) {
    case "Maneuvers: Parry":
    case "Maneuvers: Trip Attack":
    case "Maneuvers: Maneuvering Attack":
    case "Maneuvers: Goading Attack":
    case "Maneuvers: Distracting Strike":
    case "Maneuvers: Menacing Attack":
    case "Maneuvers: Sweeping Attack":
    case "Maneuvers: Disarming Attack":
    case "Maneuvers: Pushing Attack": {
      foundry.utils.setProperty(document, "system.damage.parts", [[diceString]]);
      break;
    }
    // no default
  }

  switch (name) {
    case "Maneuvers: Precision Attack": {
      foundry.utils.setProperty(document, "system.damage.parts", [[diceString, "midi-none"]]);
      break;
    }
    // no default
  }

  // saves
  switch (name) {
    case "Maneuvers: Trip Attack":
    case "Maneuvers: Disarming Attack":
    case "Maneuvers: Pushing Attack": {
      foundry.utils.setProperty(effect, "flags.midiProperties.fulldam", true);
      foundry.utils.setProperty(document, "system.damage.parts", [[diceString]]);
      foundry.utils.setProperty(document, "system.save", { ability: "str", dc: null, "scaling": ability });
      break;
    }
    case "Maneuvers: Menacing Attack":
    case "Maneuvers: Goading Attack": {
      foundry.utils.setProperty(effect, "flags.midiProperties.fulldam", true);
      foundry.utils.setProperty(document, "system.damage.parts", [[diceString]]);
      foundry.utils.setProperty(document, "system.save", { ability: "wis", dc: null, "scaling": ability });
      break;
    }
    // no default
  }

  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/mantleOfInspiration.js


async function mantleOfInspirationEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "mantleOfInspiration.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "mantleOfInspiration.js", ["preTargeting"]);

  return document;
}

// EXTERNAL MODULE: ./src/effects/feats/maskOfTheWild.js
var maskOfTheWild = __webpack_require__(1906);
;// CONCATENATED MODULE: ./src/effects/feats/mindLink.js


function mindLinkEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    { key: "system.traits.languages.custom", value: "Telepathy", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 10 },
  );

  effect.duration.seconds = 3600;
  effect.duration.hour = 1;

  document.effects.push(effect);
  return document;
}


// EXTERNAL MODULE: ./src/effects/specialSpells.js + 124 modules
var specialSpells = __webpack_require__(3137);
;// CONCATENATED MODULE: ./src/effects/feats/momentaryStasis.js



function momentaryStasis(document) {
  let effect = (0,specialSpells/* baseSpellEffect */.f)(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Incapacitated", 20, true);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isDamaged", "turnEndSource"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/pactMagic.js


function pactMagicEffect(document) {

  if (foundry.utils.getProperty(document, "flags.ddbimporter.subclass")?.startsWith("Order of the Profane Soul")) {
    const effect = baseFeatEffect(document, `${document.name} Level`, { transfer: true });
    effect.changes.push(
      {
        key: "system.spells.pact.level",
        value: "@scale.order-of-the-profane-soul.pact-level",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        priority: "20",
      },
    );
    document.effects.push(effect);

  }

  return document;
}



;// CONCATENATED MODULE: ./src/effects/feats/paladinDefaultAura.js
function paladinDefaultAuraEffect(document) {
  if (!game.modules.get("ActiveAuras")?.active) return document;
  document.effects.forEach((effect) => {
    if (effect.name.includes(" - Passive")) {
      // const distance = document.flags.ddbimporter?.dndbeyond?.levelScale?.fixedValue ?? 10;
      effect.flags.ActiveAuras = {
        aura: "Allies",
        radius: `@scale.paladin.${document.name.toLowerCase().replaceAll(" ", "-")}`,
        isAura: true,
        inactive: false,
        hidden: false,
        displayTemp: true,
      };
      effect.statuses.push(effect.name);
      foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");
    }
  });
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/patientDefense.js



function patientDefenseEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Dodge", 20, true);

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/piercer.js




async function commonPiercer(document) {
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "piercer.js");
  return document;
};

async function piercerCriticalEffect(document) {
  const effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "piercer.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  document.effects.push(effect);

  await commonPiercer(document);

  return document;
}


async function piercerRerollEffect(document) {
  const effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push(
    DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "postDamageRoll", macroType: "feat", macroName: "piercer.js", document }),
  );
  document.effects.push(effect);

  await commonPiercer(document);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/planarWarrior.js



async function planarWarriorEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "planarWarrior.js");

  let effect = baseFeatEffect(document, "Marked by Planar Warrior");

  foundry.utils.setProperty(effect, "duration.turns", 1);
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "planarWarrior.js", ["preItemRoll", "preActiveEffects"]);

  document.effects.push(effect);

  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.range = {
    value: 30,
    long: null,
    units: "ft",
  };
  document.system.damage = {
    parts: [],
    versatile: "",
    value: "",
  };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/potentCantrip.js


function potentCantripEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    { key: "flags.midi-qol.potentCantrip", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 },
  );
  document.effects.push(effect);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/powerfulBuild.js


function powerfulBuild (document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    { key: "flags.dnd5e.powerfulBuild", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 1 },
  );
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/radiantSoul.js



async function radiantSoulEffect(document) {

  if (document.flags.ddbimporter.type == "race") {
    let effect = baseFeatEffect(document, document.name);

    effect.changes.push(
      {
        key: "data.attributes.movement.fly",
        mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
        value: "30",
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.radiantsoul.label",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `${document.name} Bonus Damage`,
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.radiantsoul.count",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "each-round",
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.radiantsoul.damage.all",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: document.name === "Celestial Revelation (Radiant Soul)" ? "+@prof[radiant]" : "+@details.level[radiant]",
        priority: "20",
      }
    );
    effect.duration = {
      startTime: null,
      seconds: null,
      rounds: 10,
      turns: null,
      startRound: null,
      startTurn: null,
    };

    document.effects.push(effect);

    document.system["target"]["type"] = "self";
    document.system.range = { value: null, units: "self", long: null };
    document.system.actionType = "other";

  } else if (document.flags.ddbimporter.type == "class") {
    let effect = baseFeatEffect(document, document.name, { transfer: true });
    effect.changes.push(
      {
        key: "flags.dnd5e.DamageBonusMacro",
        value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "radiantSoul.js", document }),
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        priority: "20",
      },
    );

    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "radiantSoul.js");
    foundry.utils.setProperty(document, "system.activation.type", "special");

    document.effects.push(effect);
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/rage.js


function rageEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`);

  effect.changes.push(
    {
      key: "system.bonuses.mwak.damage",
      value: "+ @scale.barbarian.rage",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    },
    {
      key: "system.traits.dr.value",
      value: "piercing",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    },
    {
      key: "system.traits.dr.value",
      value: "slashing",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "system.traits.dr.value",
      value: "bludgeoning",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
    {
      key: "flags.midi-qol.advantage.ability.save.str",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
    {
      key: "flags.midi-qol.advantage.ability.check.str",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
    {
      key: "macro.tokenMagic",
      value: "outline",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 10,
    },
  );
  effect.duration = {
    startTime: null,
    seconds: 60,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  document.system.damage = {
    parts: [],
    versatile: "",
    value: "",
  };
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = { value: null, units: "self", long: null };
  document.effects.push(effect);
  return document;
}

// EXTERNAL MODULE: ./src/effects/feats/recklessAttack.js
var recklessAttack = __webpack_require__(5342);
;// CONCATENATED MODULE: ./src/effects/feats/runeCarver.js




async function runeCarverEffect(document) {

  let baseEffect = baseFeatEffect(document, document.name, { transfer: true });

  switch (document.name) {
    case "Rune Carver: Cloud Rune": {
      baseEffect.changes.push(
        {
          key: "flags.midi-qol.advantage.skill.dec",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
        {
          key: "flags.midi-qol.advantage.skill.slt",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
      );
      break;
    }
    case "Rune Carver: Fire Rune": {
      // Missing: prof bonus expertise for tool
      break;
    }
    case "Rune Carver: Frost Rune": {
      baseEffect.changes.push(
        {
          key: "flags.midi-qol.advantage.skill.ani",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
        {
          key: "flags.midi-qol.advantage.skill.itm",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
      );
      break;
    }
    case "Rune Carver: Stone Rune": {
      baseEffect.changes.push(
        {
          key: "flags.midi-qol.advantage.skill.ins",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
        {
          key: "system.attributes.senses.darkvision",
          value: "120",
          mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
          priority: 20,
        },
      );
      if ((0,effects/* effectModules */.xV)().atlInstalled) {
        baseEffect.changes.push(
          (0,effects/* generateATLChange */.Ci)("ATL.sight.range", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 120, 5),
          (0,effects/* generateATLChange */.Ci)("ATL.sight.visionMode", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, "darkvision", 5),
        );
      } else {
        await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "darkvision.js");
        baseEffect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "darkvision.js" }));
      }
      break;
    }
    case "Rune Carver: Hill Rune": {
      baseEffect.changes.push(
        {
          key: "system.traits.dr.value",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "poison",
          priority: "20",
        },
      );
      // Missing : advantage of saving throws against being poisoned
      break;
    }
    case "Rune Carver: Storm Rune": {
      baseEffect.changes.push(
        {
          key: "flags.midi-qol.advantage.skill.arc",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "1",
          priority: "20",
        },
      );
      // Missing : can't be surprised

      break;
    }
    // no default
  }

  if (baseEffect.changes.length > 0) {
    foundry.utils.setProperty(document, "system.target.type", "self");
    foundry.utils.setProperty(document, "system.range.units", "self");
    foundry.utils.setProperty(document, "system.range.value", "");
    foundry.utils.setProperty(document, "system.actionType", null);
    document.effects.push(baseEffect);
  }
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/sacredWeapon.js



function sacredWeaponEffect(document) {
  if (document.system.actionType === null) return document;
  const name = document.name.split(":").pop();
  document.system.actionType = "ench";

  document.system.damage.parts = [];
  document.system.chatFlavor = "";

  let enchantmentEffect = (0,effects/* baseEnchantmentEffect */.yN)(document, `${name}`);
  enchantmentEffect.changes.push(
    {
      key: "name",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: `{}, (${name})`,
      priority: 20,
    },
    {
      key: "system.properties",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "mgc",
      priority: 20,
    },
    {
      key: "system.attack.bonus",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "@abilities.cha.mod",
      priority: 20,
    },
  );
  enchantmentEffect.description = `The weapon shines with Sacred Energy.`;
  foundry.utils.setProperty(enchantmentEffect, "duration.seconds", 60);

  if (CONFIG.DDBI.EFFECT_CONFIG.MODULES.installedModules.atlInstalled) {
    let lightEffect = baseFeatEffect(document, `${name} (Light Effect)`, { transfer: false });
    lightEffect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.dim", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '5'));
    lightEffect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.color", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '#ffffff'));
    lightEffect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.alpha", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '0.25'));
    const lightAnimation = '{"type": "sunburst", "speed": 2,"intensity": 4}';
    lightEffect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.animation", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, lightAnimation));
    foundry.utils.setProperty(lightEffect, "duration.seconds", 60);
    lightEffect._id = foundry.utils.randomID();
    document.effects.push(lightEffect);
    foundry.utils.setProperty(enchantmentEffect, "flags.dnd5e.enchantment.riders.effect", [lightEffect._id]);
  } else {
    const macroToggle = `<br><p>[[/ddbifunc functionName="sacredWeaponLight" functionType="feat"]]{Toggle Sacred Weapon Light}</div></p>`;
    document.system.description.value += macroToggle;
    if (document.system.description.chat !== "") document.system.description.chat += macroToggle;
  }

  document.effects.push(enchantmentEffect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/savageAttacker.js


function savageAttackerEffect(document) {
  if (document.system.actionType === null) return document;
  let effect = baseFeatEffect(document, document.name, { transfer: true });

  effect.changes.push(
    {
      key: "flags.midi-qol.optional.savageAttacker.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.name} - Weapon Damage Reroll`,
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.savageAttacker.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "turn",
      priority: "5",
    },
    {
      key: "flags.midi-qol.optional.savageAttacker.damage.mwak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "reroll-kh",
      priority: "5",
    },
  );

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/sculptSpells.js


function sculptSpellsEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    { key: "flags.midi-qol.sculptSpell", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 10 },
  );
  document.effects.push(effect);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/sharpShooter.js


function sharpShooterEffect(document) {
  let effect = (0,effects/* baseEffect */.mS)(document, document.name, { transfer: false });

  effect.changes.push(
    {
      key: "system.bonuses.rwak.attack",
      value: "-5",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 30,
    },
    {
      key: "system.bonuses.rwak.damage",
      value: "+10",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 30,
    },
  );

  foundry.utils.setProperty(effect, "flags.dae.showIcon", true);

  document.effects.push(effect);

  let rageEffect = (0,effects/* baseEffect */.mS)(document, `${document.name} - Range Adjustment`, { transfer: true });

  rageEffect.changes.push(
    // changes range
    {
      key: "flags.midi-qol.sharpShooter",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 30,
    },
    {
      key: "flags.dnd5e.helpersIgnoreCover",
      value: "2",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 30,
    },
  );

  document.effects.push(rageEffect);
  document.system.activation = {
    "type": "none",
    "cost": 1,
    "condition": ""
  };

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = "other";

  foundry.utils.setProperty(document, "flags.midi-qol.effectActivation", false);
  foundry.utils.setProperty(document, "flags.midi-qol.removeAttackDamageButtons", false);
  foundry.utils.setProperty(document, "flags.midiProperties.toggleEffect", true);

  return document;
}

// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
;// CONCATENATED MODULE: ./src/effects/feats/shift.js



function shiftEffect(ddb, character, document) {
  const isBeasthide = ddb.character.options.race.find((trait) => trait.definition.name === "Beasthide");
  const isSwiftstride = ddb.character.options.race.find((trait) => trait.definition.name === "Swiftstride");
  const isWildhunt = ddb.character.options.race.find((trait) => trait.definition.name === "Wildhunt");
  const isLongtooth = ddb.character.options.race.find((trait) => trait.definition.name === "Longtooth");

  let effect = baseFeatEffect(document, `${document.name}`);

  if (isBeasthide) {
    document.system.damage.parts[0][0] = `1d6 + ${document.system.damage.parts[0][0]}`;
    effect.changes.push(
      {
        key: "system.attributes.ac.bonus",
        value: "+ 1",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        priority: 20,
      },
    );
    foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
    foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
    const description = (0,DDBTemplateStrings/* default */.Z)(ddb, character, isBeasthide.definition.description, isBeasthide.definition).text;
    document.system.description.value += `<h2>Beasthide</h2>\n${description}`;
    document.effects.push(effect);
  } else if (isSwiftstride) {
    effect.changes.push(
      {
        key: "system.attributes.movement.walk",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: "+ 10",
        priority: "20",
      },
    );
    foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
    foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
    const description = (0,DDBTemplateStrings/* default */.Z)(ddb, character, isSwiftstride.definition.description, isSwiftstride.definition).text;
    document.system.description.value += `<h2>Swiftstride</h2>\n${description}`;
    document.effects.push(effect);
  } else if (isWildhunt) {
    effect.changes.push(
      {
        key: "flags.midi-qol.advantage.ability.check.wis",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "1",
        priority: "20",
      },
    );
    foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
    foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
    const description = (0,DDBTemplateStrings/* default */.Z)(ddb, character, isWildhunt.definition.description, isWildhunt.definition).text;
    document.system.description.value += `<h2>Wildhunt</h2>\n${description}`;
    document.effects.push(effect);
  } else if (isLongtooth) {
    const description = (0,DDBTemplateStrings/* default */.Z)(ddb, character, isLongtooth.definition.description, isLongtooth.definition).text;
    document.system.description.value += `<h2>Longtooth</h2>\n${description}`;
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/slasherCritical.js




async function slasherCriticalEffect(document) {
  const effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "slasherCritical.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  document.effects.push(effect);
  document.system.actionType = null;
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "slasherCritical.js");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/slasherReduceSpeed.js




async function slasherReduceSpeedEffect(document) {
  const effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "slasherReduceSpeed.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  document.effects.push(effect);
  document.system.actionType = null;
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "slasherReduceSpeed.js");
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/slayersPrey.js



// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor
// the Marked effect gets applied to the target
async function slayersPreyEffect(document) {
  let effect = baseFeatEffect(document, `Marked by ${document.name}`, { transfer: true });
  effect.changes.push(
    {
      key: "flags.dae.onUpdateSource",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: document.name,
      priority: 20,
    },
  );
  effect.duration.seconds = 60;
  document.effects.push(effect);

  let damageBonusEffect = baseFeatEffect(document, document.name, { transfer: true });
  damageBonusEffect.changes.push({
    key: "flags.dnd5e.DamageBonusMacro",
    value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "slayersPrey.js", document }),
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 20,
  });
  document.effects.push(damageBonusEffect);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "slayersPrey.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "slayersPrey.js", ["postActiveEffects"]);

  foundry.utils.setProperty(document, "system.actionType", "util");
  document.system.damage.parts = [];
  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "",
  };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/squireOfSolamnia.js



async function squireOfSolamniaEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name, { transfer: false });
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "squireOfSolamnia.js");
  effect.changes.push(
    DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: `"${document.name}"`, macroType: "feat", macroName: "squireOfSolamnia.js" }),
    DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "postAttackRoll", macroType: "feat", macroName: "squireOfSolamnia.js", document }),
    {
      key: "flags.midi-qol.advantage.attack.mwak",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "1",
      priority: "20",
    },
    {
      key: "flags.midi-qol.advantage.attack.rwak",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "1",
      priority: "20",
    },
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "squireOfSolamnia.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    }
  );
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Attack"]);
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  document.system.damage.parts = [];
  document.system.actionType = null;

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/steadyAim.js



function steadyAimEffect(document) {
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    let effect = baseFeatEffect(document, document.name);
    effect.changes.push(
      {
        key: "flags.midi-qol.advantage.attack.all",
        value: "1",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        priority: 30,
      },
    );
    effect.flags.dae.specialDuration = ["1Attack"];
    foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");
    foundry.utils.setProperty(effect, "duration.turns", 1);

    document.system["target"]["type"] = "self";
    document.system.range = { value: null, units: "self", long: null };
    document.system.actionType = null;
    // document.system.duration = {
    //   value: 1,
    //   units: "turn",
    // };
    document.effects.push(effect);
  }

  let moveEffect = baseFeatEffect(document, `${document.name} Movement Restriction`);
  moveEffect.changes.push(
    {
      key: 'data.attributes.movement.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '0',
      priority: "40",
    },
  );
  moveEffect.duration = {
    startTime: null,
    seconds: 12,
    rounds: 2,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  moveEffect.flags.dae.specialDuration = ["turnStartSource"];
  foundry.utils.setProperty(moveEffect, "flags.dae.stackable", "noneName");
  document.effects.push(moveEffect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/stoneRune.js



function stoneRuneEffect(document) {
  foundry.utils.setProperty(document, "system.target.value", 1);
  foundry.utils.setProperty(document, "system.target.type", "creature");
  foundry.utils.setProperty(document, "system.range.units", "ft");
  foundry.utils.setProperty(document, "system.range.value", 30);

  let bonusEffect = baseFeatEffect(document, `${document.name} (Charm Effect)`);
  bonusEffect.statuses.push(`${document.name} (Charm Effect)`);
  foundry.utils.setProperty(bonusEffect, "duration.seconds", 60);
  (0,effects/* addStatusEffectChange */.sb)(bonusEffect, "Charmed", 20, true);
  (0,effects/* addStatusEffectChange */.sb)(bonusEffect, "Incapacitated", 20, true);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    bonusEffect.changes.push(
      {
        key: "flags.midi-qol.OverTime",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: `label=${document.name} (End of Turn Save),turn=end,saveDC=@attributes.spelldc,saveAbility=${document.system.save.ability},savingThrow=true,saveMagic=true,saveRemove=true,killAnim=true`,
        priority: "20",
      }
    );
  }

  document.effects.push(bonusEffect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/stonesEndurance.js



function stonesEnduranceEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.DR.all",
    value: "[[1d12 + @abilities.con.mod]]",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: 20,
  });
  effect.flags.dae.specialDuration = ["1Reaction"];
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  foundry.utils.setProperty(document, "system.activation.type", "reactiondamage");

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.damage.parts = [];
  document.system.ability = null;

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/stormRune.js


function stormRuneEffect(document) {

  let baseEffect = baseFeatEffect(document, document.name);
  foundry.utils.setProperty(baseEffect, "duration.seconds", 60);
  foundry.utils.setProperty(baseEffect, "flags.dae.stackable", "noneName");

  foundry.utils.setProperty(document, "system.target.type", "self");
  foundry.utils.setProperty(document, "system.range.units", "self");
  foundry.utils.setProperty(document, "system.range.value", "");
  foundry.utils.setProperty(document, "system.actionType", null);
  document.effects.push(baseEffect);

  let bonusEffect = baseFeatEffect(document, `${document.name} (Prophetic State)`);
  foundry.utils.setProperty(bonusEffect, "duration.seconds", 60);
  foundry.utils.setProperty(bonusEffect, "flags.dae.stackable", "noneName");
  bonusEffect.statuses.push("Prophetic State");

  // Missing effect for Prophetic State to enforce adv or disvantage

  document.effects.push(bonusEffect);


  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/unarmoredMovement.js


function unarmoredMovementEffect(document) {
  document.effects.forEach((effect) => {
    if (effect.name.includes("Passive") && (0,effects/* effectModules */.xV)().daeInstalled) {
      effect.changes = [
        {
          key: "system.attributes.movement.walk",
          value: `@scale.monk.unarmored-movement.value`,
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          priority: 20,
        },
      ];
    }
  });
  return document;
}


// EXTERNAL MODULE: ./src/effects/feats/uncannyDodge.js
var uncannyDodge = __webpack_require__(5310);
;// CONCATENATED MODULE: ./src/effects/feats/vedalkenDispassion.js


function vedalkenDispassionEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.ability.save.cha",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: 20,
    },
    {
      key: "flags.midi-qol.advantage.ability.save.wis",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: 20,
    },
    {
      key: "flags.midi-qol.advantage.ability.save.int",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: 20,
    }
  );
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/vigilantBlessing.js


function vigilantBlessingEffect(document) {
  let effect = baseFeatEffect(document, document.name);
  effect.changes.push({
    key: "flags.dnd5e.initiativeAdv",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 30,
  });
  effect.flags.dae.specialDuration = ["Initiative"];
  document.system["target"]["type"] = "creature";
  document.system.actionType = null;
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/visageOfTheAstralSelf.js



function visageOfTheAstralSelfEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`);

  effect.changes.push(
    {
      key: "system.attributes.senses.truesight",
      value: "120",
      mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
      priority: 20,
    },
  );

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push(
      {
        key: "flags.midi-qol.advantage.skill.itm",
        value: `1`,
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        priority: 20,
      },
      {
        key: "flags.midi-qol.advantage.skill.ins",
        value: `1`,
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        priority: 20,
      },
      {
        key: "ATL.sight.visionMode",
        value: `basic`,
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        priority: 20,
      },
      {
        key: "ATL.sight.range",
        value: `120`,
        mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
        priority: 20,
      },
    );
  }
  effect.duration = {
    startTime: null,
    seconds: 360,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);

  document.effects.push(effect);

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = null;
  document.system.duration = {
    value: 10,
    units: "minute",
  };


  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/warCaster.js


function warCasterEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.description = document.system.description.value;
  effect.changes.push(
    {
      key: "system.attributes.concentration.roll.mode",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
      priority: 10
    },
  );
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    document = (0,effects/* forceManualReaction */.pi)(document);
  }
  document.effects.push(effect);
  return document;
}


;// CONCATENATED MODULE: ./src/effects/feats/furryOfTheSmall.js



async function furyOfTheSmallEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "furyOfTheSmall.js");

  // let macroEffect = baseFeatEffect(document, `${document.name} (Size Checker)`, { transfer: true });
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "furyOfTheSmall.js", ["preDamageRoll"]);
  // document.effects.push(macroEffect);

  let effect = baseFeatEffect(document, document.name, { transfer: true });
  if (document.system.description.value.includes("once per turn")) {
    effect.changes.push(
      {
        key: "flags.midi-qol.optional.smallFury.damage.all",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "(@prof)",
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.smallFury.label",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `${document.name} (Only use on targets larger than you)`,
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.smallFury.count",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "turn",
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.smallFury.countAlt",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `ItemUses.${document.name}`,
        priority: "20",
      },
    );
  } else {
    effect.changes.push(
      {
        key: "flags.midi-qol.optional.smallFury.damage.all",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "(@details.level)",
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.smallFury.label",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `${document.name} (Only use on targets larger than you)`,
        priority: "20",
      },
      {
        key: "flags.midi-qol.optional.smallFury.count",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `ItemUses.${document.name}`,
        priority: "20",
      },
    );
  }
  document.effects.push(effect);
  document.system.damage = {
    parts: [],
    versatile: "",
    value: "",
  };
  document.system.duration.units = "perm";
  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/intimidatingPresence.js



function intimidatingPresenceEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Frightened", 20, true);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnEndSource"]);
  effect.duration.seconds = 12;
  effect.duration.turns = 2;
  document.effects.push(effect);

  // document.system.activation.condition = "!target.effects.some((e)=> e.name?.toLowerCase().includes('blind') || e.name?.toLowerCase().includes('deaf'))";
  foundry.utils.setProperty(document, "flags.midi-qol.effectCondition", "!target.effects.some((e)=> e.name?.toLowerCase().includes('blind') || e.name?.toLowerCase().includes('deaf'))");
  foundry.utils.setProperty(document.flags, "midi-qol.effectActivation", true);
  document.system.duration.units = "perm";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/sheildingStorm.js


function shieldingStormEffect(ddb, document) {

  const isDesert = ddb.character.actions.class.some((a) => a.name === "Storm Aura: Desert");
  const isSea = ddb.character.actions.class.some((a) => a.name === "Storm Aura: Sea");
  const isTundra = ddb.character.actions.class.some((a) => a.name === "Storm Aura: Tundra");

  const damageType = isDesert
    ? "fire"
    : isSea
      ? "lightning"
      : isTundra
        ? "cold"
        : "";

  let effect = baseFeatEffect(document, `${document.name} Aura`, { transfer: true });
  effect.changes.push({
    "key": "system.traits.dr.value",
    "mode": CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    "value": damageType,
    "priority": 20
  });

  effect.flags.ActiveAuras = {
    aura: "Allies",
    radius: "10",
    isAura: true,
    ignoreSelf: true,
    inactive: false,
    hidden: false,
    displayTemp: true,
  };

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/stormSoul.js


async function stormSoulEffect(ddb, document) {
  const isDesert = document.name.endsWith("Desert")
    || ddb.character.actions.class.some((a) => a.name === "Storm Aura: Desert");
  const isSea = document.name.endsWith("Sea")
    || ddb.character.actions.class.some((a) => a.name === "Storm Aura: Sea");
  const isTundra = document.name.endsWith("Tundra")
    || ddb.character.actions.class.some((a) => a.name === "Storm Aura: Tundra");

  let effect = baseFeatEffect(document, `${document.name}`, { transfer: true });

  const damageType = isDesert
    ? "fire"
    : isSea
      ? "lightning"
      : isTundra
        ? "cold"
        : "";

  effect.changes.push(
    {
      key: "system.traits.dr.value",
      value: damageType,
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );

  if (isSea) {
    effect.changes.push(
      {
        key: "system.attributes.movement.swim",
        value: "30",
        mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
        priority: 20,
      },
    );
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/ragingStormSea.js




async function ragingStormSeaEffect(document) {

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "ragingStormSea.js");

  const effect = baseFeatEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Prone", 20, true);
  document.effects.push(effect);

  const evaluationEffect = baseFeatEffect(document, `${document.name} (Trigger Checker)`, { transfer: true });

  evaluationEffect.changes.push(
    DDBMacros/* default.generateOptionalMacroChange */.Z.generateOptionalMacroChange({ optionPostfix: "ragingSea.damage.mwak", macroType: "feat", macroName: "ragingStormSea.js", document }),
    DDBMacros/* default.generateOptionalMacroChange */.Z.generateOptionalMacroChange({ optionPostfix: "ragingSea.damage.msak", macroType: "feat", macroName: "ragingStormSea.js", document }),
    DDBMacros/* default.generateOptionalMacroChange */.Z.generateOptionalMacroChange({ optionPostfix: "ragingSea.damage.rwak", macroType: "feat", macroName: "ragingStormSea.js", document }),
    DDBMacros/* default.generateOptionalMacroChange */.Z.generateOptionalMacroChange({ optionPostfix: "ragingSea.damage.rsak", macroType: "feat", macroName: "ragingStormSea.js", document }),
    {
      key: "flags.midi-qol.optional.ragingSea.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "reaction",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ragingSea.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Use your reaction to induce a save to apply prone?",
      priority: "20",
    },
  );
  document.effects.push(evaluationEffect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/ragingStormTundra.js



async function ragingStormTundraEffect(document) {
  const effect = baseFeatEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "ragingStormTundra.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "ragingStormTundra.js", ["preTargeting"]);
  effect.changes.push(
    {
      key: "system.attributes.movement.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "*0",
      priority: "20",
    },
  );
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/stormAuraTundra.js


async function stormAuraTundraEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "stormAuraTundra.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "stormAuraTundra.js", ["postActiveEffects"]);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/giantStature.js



function giantStatureEffect(document) {
  let effect = baseFeatEffect(document, document.name);

  if ((0,effects/* effectModules */.xV)().atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.width", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 2, 5));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.height", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 2, 5));
  }

  effect.changes.push(
    {
      key: "system.traits.size",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "lg",
      priority: 25,
    },
  );

  document.system.damage.parts = [];

  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/demiurgicColossus.js



function demiurgicColossusEffect(document) {
  let effect = baseFeatEffect(document, document.name);

  if ((0,effects/* effectModules */.xV)().atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.width", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 3, 5));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.height", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 3, 5));
  }

  effect.changes.push(
    {
      key: "system.traits.size",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "hg",
      priority: 25,
    },
  );

  document.system.damage.parts = [];

  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/greatWeaponMaster.js


function greatWeaponMasterEffect(document) {
  let effect = (0,effects/* baseEffect */.mS)(document, document.name, { transfer: false });

  effect.changes.push(
    {
      key: "system.bonuses.mwak.attack",
      value: "-5",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 30,
    },
    {
      key: "system.bonuses.mwak.damage",
      value: "+10",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 30,
    },
  );
  foundry.utils.setProperty(effect, "flags.dae.showIcon", true);
  document.effects.push(effect);

  document.system.activation = {
    "type": "none",
    "cost": 1,
    "condition": ""
  };

  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = "other";

  foundry.utils.setProperty(document, "flags.midi-qol.effectActivation", false);
  foundry.utils.setProperty(document, "flags.midi-qol.removeAttackDamageButtons", false);
  foundry.utils.setProperty(document, "flags.midiProperties.toggleEffect", true);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/psychicBlades.js
function psychicBladesEffect(document) {

  // document.system.actionType = "rwak";
  // foundry.utils.setProperty(document, "flags.midi-qol.effectCondition", "");
  // foundry.utils.setProperty(document, "flags.midi-qol.ignoreNearbyFoes", true);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/sneakAttack.js





async function sneakAttackEffect(document) {
  const effect = baseFeatEffect(document, document.name, { transfer: true });
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "sneakAttack.js");
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "feat", macroName: "sneakAttack.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );
  document.effects.push(effect);
  document.system.damage.parts = [];
  document.system.actionType = null;

  document.system.duration = {
    value: 24,
    units: "hours",
  };

  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/aspectOfTheBeastBear.js


function aspectOfTheBeastBearEffect(document) {
  let effect = baseFeatEffect(document, document.name, { transfer: true });

  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.ability.check.str",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "20",
    },
    {
      key: "system.attributes.encumbrance.max",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "@attributes.encumbrance.max * 2",
      priority: "20",
    },
    {
      key: "system.attributes.encumbrance.pct",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "dae.eval(100 * attributes.encumbrance.value / attributes.encumbrance.max)",
      priority: "20",
    },
  );

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/flurryOfBlows.js


async function flurryOfBlowsEffect(document) {

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "feat", "flurryOfBlows.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "feat", "flurryOfBlows.js", ["postActiveEffects"]);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/songOfVictory.js


function songOfVictoryEffect(document) {
  let effect = baseFeatEffect(document, `${document.name}`);

  foundry.utils.setProperty(document, "system.range", { value: null, units: "self", long: null });
  foundry.utils.setProperty(document, "system.range.value", null);
  foundry.utils.setProperty(document, "system.target.type", "self");
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);

  effect.changes.push(
    {
      key: "system.bonuses.mwak.damage",
      value: "max(@abilities.int.mod,1)",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
  );
  effect.duration = {
    startTime: null,
    seconds: 60,
    rounds: null,
    turns: null,
    startRound: null,
    startTurn: null,
  };

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/twinklingConstellations.js


function twinklingConstellationsEffect(document) {
  foundry.utils.setProperty(document, "system.target.type", "self");
  foundry.utils.setProperty(document, "system.range.units", "self");
  foundry.utils.setProperty(document, "system.range.value", "");
  foundry.utils.setProperty(document, "system.actionType", null);

  let effect = baseFeatEffect(document, document.name);
  foundry.utils.setProperty(effect, "duration.seconds", 600);

  effect.changes.push(
    {
      key: "system.attributes.movement.fly",
      mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
      value: "20",
      priority: "20",
    },
    {
      key: "system.attributes.movement.hover",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "true",
      priority: "20",
    },
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/armsOfTheAstralSelf.js


function armsOfTheAstralSelfEffect(document) {

  let effect = baseFeatEffect(document, `${document.name} (Save Modifications)`);

  effect.changes.push(
    {
      key: "system.abilities.str.bonuses.check",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "- @abilities.str.mod + @abilities.wis.mod",
      priority: "5",
    },
    {
      key: "system.abilities.str.bonuses.save",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "- @abilities.str.mod + @abilities.wis.mod",
      priority: "5",
    },
  );

  foundry.utils.setProperty(effect, "duration.seconds", 600);

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/ghostWalk.js


function ghostWalkEffect(document) {

  let effect = baseFeatEffect(document, `${document.name} (Fight)`);

  effect.changes.push(
    {
      key: "system.attributes.movement.fly",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "10",
      priority: "5",
    },
    {
      key: "system.attributes.movement.hover",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "true",
      priority: "5",
    },
  );

  foundry.utils.setProperty(effect, "duration.seconds", 600);

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/darkOnesOwnLuck.js


function darkOnesOwnLuckffect(document) {
  document.system.damage.parts = [];
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name, { transfer: true });
  effect.changes.push(
    {
      key: "flags.midi-qol.optional.darkOnesOwnLuck.check.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "+1d10",
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.darkOnesOwnLuck.save.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "+1d10",
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.darkOnesOwnLuck.label",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "Dark One's Own Luck",
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.darkOnesOwnLuck.count",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: `ItemUses.${document.name}`,
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.darkOnesOwnLuck.skill.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "+1d10",
      priority: 20,
    }
  );

  return document;
}

;// CONCATENATED MODULE: ./src/effects/feats/foeSlayer.js


function foeSlayerEffect(document) {
  let effect = baseFeatEffect(document, document.name, { transfer: true });
  effect.changes.push(
    {
      key: "flags.midi-qol.optional.foeSlayer.damage.msak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "@abilities.wis.mod",
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.foeSlayer.damage.mwak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "@abilities.wis.mod",
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.foeSlayer.damage.rsak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "@abilities.wis.mod",
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.foeSlayer.damage.rwak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "@abilities.wis.mod",
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.foeSlayer.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: document.name,
      priority: 20,
    },
    {
      key: "flags.midi-qol.optional.foeSlayer.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "each-round",
      priority: 20,
    },
  );
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/specialFeats.js


// effect loads
























































































function baseFeatEffect(document, label,
  { transfer = false, disabled = false } = {}
) {
  return (0,effects/* baseEffect */.mS)(document, label, { transfer, disabled });
}

// eslint-disable-next-line complexity
async function midiFeatureEffects(ddb, character, document) {
  const name = document.flags.ddbimporter?.originalName ?? document.name;

  document = (0,effects/* applyDefaultMidiFlags */.VN)(document);

  if (name.startsWith("Maneuvers: ") && ddb && character) {
    document = await maneuversEffect(ddb, character, document);
    return document;
  } else if (name.startsWith("Rune Carver: ")) {
    document = await runeCarverEffect(document);
    return document;
  }

  switch (name) {
    case "Arcane Recovery": {
      document = await arcaneRecoveryEffect(document);
      break;
    }
    case "Ancestral Protectors": {
      document = await ancestralProtectorsEffect(document);
      break;
    }
    case "Arcane Ward": {
      document = await arcaneWardEffect(document);
      break;
    }
    case "Aspect of the Beast: Bear": {
      document = await aspectOfTheBeastBearEffect(document);
      break;
    }
    case "Bardic Inspiration": {
      document = bardicInspirationEffect(document);
      break;
    }
    case "Blessed Healer": {
      document = await blessedHealerEffect(document);
      break;
    }
    case "Blessed Strikes": {
      document = blessedStrikesEffect(document);
      break;
    }
    case "Convert Sorcery Points":
    case "Font of Magic": {
      document = await fontOfMagicEffect(document);
      break;
    }
    case "Crusher": {
      document = await crusherEffect(document);
      break;
    }
    case "Crusher: Critical": {
      document = await crusherCriticalEffect(document);
      break;
    }
    case "Cloud Rune": {
      document = cloudRuneEffect(document);
      break;
    }
    case "Crossbow Expert": {
      document = crossbowExpertEffect(document);
      break;
    }
    case "Dark One's Own Luck":
    case "Dark Ones Own Luck": {
      document = darkOnesOwnLuckffect(document);
      break;
    }
    case "Daunting Roar": {
      document = dauntingRoarEffect(document);
      break;
    }
    case "Deflect Missiles": {
      document = deflectMissilesEffect(document);
      break;
    }
    case "Deflect Missiles Attack": {
      document = deflectMissilesAttackEffect(document);
      break;
    }
    case "Deft Strike": {
      document = await deftStrikeEffect(document);
      break;
    }
    case "Evasion": {
      document = evasionEffect(document);
      break;
    }
    case "Empty Body":
    case "Ki: Empty Body": {
      document = kiEmptyBodyEffect(document);
      break;
    }
    case "Favored Foe": {
      document = await favoredFoeEffect(document);
      break;
    }
    case "Foe Slayer": {
      document = foeSlayerEffect(document);
      break;
    }
    case "Fighting Style: Interception": {
      document = fightingStyleInterceptionEffect(document);
      break;
    }
    case "Form of the Beast: Tail (reaction)": {
      document = formOfTheBeastReactionEffect(document);
      break;
    }
    case "Fury of the Small": {
      document = await furyOfTheSmallEffect(document);
      break;
    }
    case "Flurry of Blows": {
      document = await flurryOfBlowsEffect(document);
      break;
    }
    case "Giant's Might": {
      document = giantsMightEffect(document);
      break;
    }
    case "Glide (Reaction)": {
      document = (0,effects/* forceManualReaction */.pi)(document);
      break;
    }
    case "Hadozee Dodge": {
      document = hadozeDodgeEffect(document);
      break;
    }
    case "Indomitable": {
      document = indomitableEffect(document);
      break;
    }
    case "Intimidating Presence": {
      document = intimidatingPresenceEffect(document);
      break;
    }
    case "Mantle of Inspiration": {
      document = await mantleOfInspirationEffect(document);
      break;
    }
    case "Mask of the Wild": {
      document = await (0,maskOfTheWild/* maskOfTheWildEffect */.L)(document);
      break;
    }
    case "Patient Defense": {
      document = patientDefenseEffect(document);
      break;
    }
    case "Potent Cantrip": {
      document = potentCantripEffect(document);
      break;
    }
    case "Equine Build":
    case "Little Giant":
    case "Hippo Build":
    case "Powerful Build": {
      document = powerfulBuild(document);
      break;
    }
    case "Piercer": {
      document = await piercerCriticalEffect(document);
      document = await piercerRerollEffect(document);
      break;
    }
    case "Piercer: Reroll Damage": {
      document = await piercerRerollEffect(document);
      break;
    }
    case "Piercer: Critical Hit": {
      document = await piercerCriticalEffect(document);
      break;
    }
    case "Planar Warrior": {
      document = await planarWarriorEffect(document);
      break;
    }
    case "Psychic Blades: Attack (DEX)":
    case "Psychic Blades: Attack (STR)":
    case "Psychic Blades: Bonus Attack (DEX)":
    case "Psychic Blades: Bonus Attack (STR)":
    case "Psychic Blades: Bonus Attack":
    case "Psychic Blades: Attack": {
      document = psychicBladesEffect(document);
      break;
    }
    case "Celestial Revelation (Radiant Soul)":
    case "Radiant Soul": {
      document = await radiantSoulEffect(document);
      break;
    }
    case "Raging Storm: Sea": {
      document = await ragingStormSeaEffect(document);
      break;
    }
    case "Raging Storm: Tundra": {
      document = await ragingStormTundraEffect(document);
      break;
    }
    case "Reckless Attack": {
      document = (0,recklessAttack/* recklessAttackEffect */.k)(document);
      break;
    }
    case "Sculpt Spells": {
      document = sculptSpellsEffect(document);
      break;
    }
    case "Sharpshooter": {
      document = sharpShooterEffect(document);
      break;
    }
    case "Savage Attacker": {
      document = savageAttackerEffect(document);
      break;
    }
    case "Shift": {
      if (ddb && character) document = shiftEffect(ddb, character, document);
      break;
    }
    case "Slasher: Reduce Speed": {
      document = await slasherReduceSpeedEffect(document);
      break;
    }
    case "Slasher: Critical Hit": {
      document = await slasherCriticalEffect(document);
      break;
    }
    case "Slayer's Prey": {
      document = await slayersPreyEffect(document);
      break;
    }
    case "Slow Fall": {
      document = (0,effects/* forceManualReaction */.pi)(document);
      break;
    }
    case "Squire of Solamnia: Precise Strike": {
      document = await squireOfSolamniaEffect(document);
      break;
    }
    case "Sneak Attack": {
      document = await sneakAttackEffect(document);
      break;
    }
    case "Stone's Endurance":
    case "Stones Endurance": {
      document = stonesEnduranceEffect(document);
      break;
    }
    case "Storm Aura: Tundra": {
      document = await stormAuraTundraEffect(document);
      break;
    }
    case "Storm Soul: Desert":
    case "Storm Soul: Sea":
    case "Storm Soul: Tundra":
    case "Storm Soul": {
      if (ddb) document = await stormSoulEffect(ddb, document);
      break;
    }
    case "Swiftstride Reaction": {
      document = (0,effects/* forceManualReaction */.pi)(document);
      break;
    }
    case "Uncanny Dodge": {
      document = (0,uncannyDodge/* uncannyDodgeEffect */.Q)(document);
      break;
    }
    case "Vedalken Dispassion": {
      document = vedalkenDispassionEffect(document);
      break;
    }
    // no default
  }
  return document;
}

/**
 * These are effects that can't be generated dynamically and have extra requirements
 */
// eslint-disable-next-line complexity
async function featureEffectAdjustment(ddb, character, document, midiEffects = false) {
  if (!document.effects) document.effects = [];

  const name = document.flags.ddbimporter?.originalName ?? document.name;

  // check that we can gen effects
  const deps = (0,effects/* effectModules */.xV)();

  // effects to always apply
  switch (name) {
    case "Alert": {
      document = alertEffect(document);
      break;
    }
    // if using active auras add the aura effect
    case "Aura of Courage":
    case "Aura of Protection": {
      document = paladinDefaultAuraEffect(document);
      break;
    }
    case "Aura of Hate": {
      document = auraOfHateEffect(document);
      break;
    }
    case "Arms of the Astral Self": {
      document = armsOfTheAstralSelfEffect(document);
      break;
    }
    case "Bladesong": {
      document = bladesongEffect(document);
      break;
    }
    case "Defensive Duelist": {
      document = defensiveDuelistEffect(document);
      break;
    }
    case "Demiurgic Colossus": {
      document = demiurgicColossusEffect(document);
      break;
    }
    case "Fire Rune": {
      document = fireRuneEffect(document);
      break;
    }
    case "Frost Rune": {
      document = frostRuneEffect(document);
      break;
    }
    case "Ghost Walk": {
      document = ghostWalkEffect(document);
      break;
    }
    case "Giant Stature":
    case "Giant's Havoc: Giant Stature": {
      document = giantStatureEffect(document);
      break;
    }
    case "Great Weapon Master": {
      document = greatWeaponMasterEffect(document);
      break;
    }
    case "Heavy Armor Master": {
      document = heavyArmorMasterEffect(document);
      break;
    }
    case "Partially Amphibious":
    case "Hold Breath": {
      document = holdBreathEffect(document);
      break;
    }
    case "Hill Rune": {
      document = hillRuneEffect(document);
      break;
    }
    case "Pact Magic": {
      document = pactMagicEffect(document);
      break;
    }
    case "Rage": {
      document = rageEffect(document);
      break;
    }
    case "Channel Divinity: Sacred Weapon":
    case "Sacred Weapon": {
      document = sacredWeaponEffect(document);
      break;
    }
    case "Song of Victory": {
      document = songOfVictoryEffect(document);
      break;
    }
    case "Shielding Storm": {
      if (ddb) document = shieldingStormEffect(ddb, document);
      break;
    }
    case "Steady Aim": {
      document = steadyAimEffect(document);
      break;
    }
    case "Stone Rune": {
      document = stoneRuneEffect(document);
      break;
    }
    case "Storm Rune": {
      document = stormRuneEffect(document);
      break;
    }
    case "Twinkling Constellations": {
      document = twinklingConstellationsEffect(document);
      break;
    }
    case "Unarmored Movement": {
      document = unarmoredMovementEffect(document);
      break;
    }
    case "Uncanny Dodge": {
      document = (0,uncannyDodge/* uncannyDodgeEffect */.Q)(document);
      break;
    }
    case "Vigilant Blessing": {
      document = vigilantBlessingEffect(document);
      break;
    }
    case "Visage of the Astral Self": {
      document = visageOfTheAstralSelfEffect(document);
      break;
    }
    case "War Caster":
    case "Warcaster": {
      document = warCasterEffect(document);
      break;
    }
    // no default
  }

  if (deps.daeInstalled) {
    switch (name) {
      case "Mind Link Response": {
        document = mindLinkEffect(document);
        break;
      }
      case "Momentary Stasis": {
        document = momentaryStasis(document);
        break;
      }
      case "Vigilant Blessing": {
        document = vigilantBlessingEffect(document);
        break;
      }
      // no default
    }
  }

  if (!deps.hasCore || !midiEffects) {
    return (0,effects/* forceItemEffect */.Wk)(document);
  }

  if (deps.midiQolInstalled && midiEffects) {
    document = await midiFeatureEffects(ddb, character, document);
  }

  return (0,effects/* forceItemEffect */.Wk)(document);
}


/***/ }),

/***/ 6934:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Kh": () => (/* binding */ baseMonsterFeatureEffect),
  "w1": () => (/* binding */ monsterFeatureEffectAdjustment),
  "Du": () => (/* binding */ transferEffectsToActor)
});

// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
// EXTERNAL MODULE: ./src/effects/feats/uncannyDodge.js
var uncannyDodge = __webpack_require__(5310);
;// CONCATENATED MODULE: ./src/effects/monsterFeatures/absorbtion.js


function absorptionEffect(item) {
  const absRegEx = /is subjected to (\w+) damage, it takes no damage and (?:instead )?regains a number of hit points equal to (half )?the (\w+) damage/i;
  const match = absRegEx.exec(item.system.description.value);
  if (!item.effects) item.effects = [];
  if (match) {
    let effect = (0,effects/* baseItemEffect */.uT)(item, `${item.name}`);
    effect.changes.push(
      {
        key: `flags.midi-qol.absorption.${match[1]}`,
        value: match[2] ? "0.5" : "1",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        priority: 20,
      }
    );
    effect.img = "icons/svg/downgrade.svg";
    effect.icon = "icons/svg/downgrade.svg";
    item.effects.push(effect);
  }
  return item;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/legendary.js


function generateLegendaryEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.optional.LegRes.save.fail.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "success",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.LegRes.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "@resources.legres.value",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.LegRes.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Use Legendary Resistance to Succeed?",
      priority: "20",
    }
  );

  document.effects.push(effect);
  return document;
}

// EXTERNAL MODULE: ./src/effects/monsterFeatures/overTimeEffect.js
var overTimeEffect = __webpack_require__(4274);
;// CONCATENATED MODULE: ./src/effects/monsterFeatures/packTactics.js



function generatePackTacticsEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.attack.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "findNearby(-1, targetUuid, 5, 0).length > 1",
      priority: "20",
    },
  );

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/reversalOfFortune.js



function generateReversalOfFortuneEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.DR.all",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1",
      priority: "20",
    },
  );

  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Reaction"]);
  foundry.utils.setProperty(effect, "duration.turns", 1);
  foundry.utils.setProperty(document, "system.activation.type", "reactiondamage");
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/suaveDefense.js



function generateSuaveDefenseEffect(ddbMonster, document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.ac.bonus",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: `+ ${ddbMonster.npc.system.abilities.cha.mod}`,
      priority: "20",
    },
  );

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/taunt.js



function generateTauntEffect(document) {
  let effect = (0,effects/* baseItemEffect */.uT)(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.disadvantage.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "20",
    },
  );

  effect.duration.rounds = 2;
  effect.duration.seconds = 12;
  effect.flags.dae.specialDuration = ["turnStart"];

  document.effects.push(effect);
  document = (0,effects/* forceItemEffect */.Wk)(document);
  return document;
}

// EXTERNAL MODULE: ./src/effects/specialFeats.js + 84 modules
var specialFeats = __webpack_require__(6696);
// EXTERNAL MODULE: ./src/effects/DDBMacros.js
var DDBMacros = __webpack_require__(6516);
;// CONCATENATED MODULE: ./src/effects/monsterFeatures/skeletalJuggernautEffects.js




function avalancheOfBonesEffect(document) {
  foundry.utils.setProperty(document, "system.duration", { value: null, units: "special" });
  foundry.utils.setProperty(document, "system.target", { value: 10, width: null, units: "ft", type: "creature" });
  foundry.utils.setProperty(document, "system.range", { value: null, long: null, units: "self" });

  let effect = (0,specialFeats/* baseFeatEffect */.z)(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Prone", 20, true);
  foundry.utils.setProperty(effect, "duration.turns", 99);
  foundry.utils.setProperty(effect, "duration.seconds", 9999);
  effect.transfer = false;

  document.effects.push(effect);
  document = (0,effects/* forceItemEffect */.Wk)(document);
  return document;
}

function fallingApartEffect(document) {
  let effect = (0,specialFeats/* baseFeatEffect */.z)(document, document.name);
  effect.changes.push(
    {
      "key": "flags.midi-qol.OverTime",
      "mode": CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      "value": `turn=start, damageRoll=10, damageType=none, condition=@attributes.hp.value > 0 && @attributes.hp.value < @attributes.hp.max, label=${document.name}`,
      "priority": "20"
    },
  );
  effect.transfer = true;
  document.effects.push(effect);
  document = (0,effects/* forceItemEffect */.Wk)(document);
  return document;
}

async function disassembleEffect(document) {
  let effect = (0,specialFeats/* baseFeatEffect */.z)(document, document.name);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "monsterFeature", "disassemble.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "monsterFeature", macroName: "disassemble.js", priority: 0 }));
  effect.transfer = true;
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["zeroHP"]);
  document.effects.push(effect);
  document = (0,effects/* forceItemEffect */.Wk)(document);
  return document;
}

async function skeletalJuggernautEffects(npc) {
  for (let item of npc.items) {
    if (item.name.startsWith("Avalanche of Bones")) {
      item = avalancheOfBonesEffect(item);
    } else if (item.name.startsWith("Falling Apart")) {
      item = fallingApartEffect(item);
    } else if (item.name.startsWith("Disassemble")) {
      item = await disassembleEffect(item);
    }
  }

  return npc;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/venomTroll.js





async function venomTrollEffects(npc) {
  for (let item of npc.items) {
    if (item.name.startsWith("Venom Spray")) {
      let effect = baseMonsterFeatureEffect(item, item.name);
      effect.changes.push(
        {
          key: "flags.midi-qol.OverTime",
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          value: "turn=end, saveAbility=con, saveDC=@abilities.str.dc, label=Poisoned by Venom Spray",
          priority: "20",
        },
      );
      (0,effects/* addStatusEffectChange */.sb)(effect, "Poisoned", 20, true);

      foundry.utils.setProperty(effect, "duration.seconds", 60);
      foundry.utils.setProperty(effect, "duration.rounds", 10);
      foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");

      await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(item, "monsterFeature", "venomSpray.js");
      DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(item, "monsterFeature", "venomSpray.js", ["postActiveEffects"]);

      item.effects.push(effect);
    } else if (item.name === "Poison Splash") {
      let effect = baseMonsterFeatureEffect(item, item.name);
      effect.changes.push(
        DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "isDamaged", macroType: "monsterFeature", macroName: "venomSpray.js" }),
      );
      effect.transfer = true;
      foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");

      await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(item, "monsterFeature", "poisonSplash.js");

      item.effects.push(effect);

      item.system.target = {
        "value": 5,
        "width": null,
        "units": "ft",
        "type": "creature"
      };
      item.system.range.units = "spec";
      item.system.duration.units = "inst";

    } else if (item.name === "Regeneration") {
      let effect = baseMonsterFeatureEffect(item, item.name);
      effect.changes.push(
        {
          key: "flags.midi-qol.OverTime",
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          value: `turn=start, damageRoll=${item.system.damage.parts[0][0]}, damageType=healing, condition=@attributes.hp.value > 0 && @attributes.hp.value < @attributes.hp.max, rollMode=gmroll, label=${item.name} (Fire or Acid prevents)`,
          priority: "20",
        },
      );
      foundry.utils.setProperty(effect, "flags.dae.transfer", true);
      effect.transfer = true;
      item.system.damage.parts = [];
      item.effects.push(effect);
    }
    item = (0,effects/* forceItemEffect */.Wk)(item);
  }

  return npc;
}


;// CONCATENATED MODULE: ./src/effects/monsterFeatures/quasit.js




function quasitEffects(npc) {
  for (let item of npc.items) {
    if (item.name.startsWith("Claws")) {
      let effect = baseMonsterFeatureEffect(item, item.name);
      effect.changes.push(
        {
          key: "flags.midi-qol.OverTime",
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          value: "turn=end, saveAbility=con, saveDC=@abilities.con.dc, label=Poisoned by Quasit Claws",
          priority: "20",
        },
      );
      (0,effects/* addStatusEffectChange */.sb)(effect, "Poisoned", 20, true);

      foundry.utils.setProperty(effect, "duration.seconds", 60);
      foundry.utils.setProperty(effect, "duration.rounds", 10);
      foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");

      item.effects.push(effect);
      foundry.utils.setProperty(item, "flags.midiProperties.fulldam", true);
      item = (0,effects/* forceItemEffect */.Wk)(item);
    }
  }

  return npc;
}


;// CONCATENATED MODULE: ./src/effects/monsterFeatures/invisibility.js




function invisibilityFeatureEffect(document) {
  if (document.type === "spell") return document;

  let effect = baseMonsterFeatureEffect(document, `${document.name} feature`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Invisible", 20, true);
  foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");

  const permanent = ["special"].includes(foundry.utils.getProperty(document, "flags.monsterMunch.type"));
  const improvedEffect = ["Superior Invisibility"].includes(document.name);

  if (permanent) {
    effect.transfer = true;
  } else if (!improvedEffect) {
    foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Action", "1Spell", "1Attack"]);
  }
  document.effects.push(effect);

  document.system.actionType = "other";
  document.system["target"]["type"] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.duration.units = "spec";

  foundry.utils.setProperty(document, "flags.midi-qol.forceCEOff", true);
  foundry.utils.setProperty(document, "flags.midiProperties.concentration", true);

  return document;
}


// EXTERNAL MODULE: ./src/effects/feats/recklessAttack.js
var recklessAttack = __webpack_require__(5342);
// EXTERNAL MODULE: ./src/effects/feats/maskOfTheWild.js
var maskOfTheWild = __webpack_require__(1906);
;// CONCATENATED MODULE: ./src/effects/monsterFeatures/deathlyChoir.js


async function deathlyChoirEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "monsterFeature", "deathlyChoir.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "monsterFeature", "deathlyChoir.js", ["prePreambleComplete"]);

  foundry.utils.setProperty(document, "system.target", { value: 10, width: null, units: "ft", type: "creature" });
  foundry.utils.setProperty(document, "system.range", { value: null, long: null, units: "spec" });

  return document;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/strahdZombie.js





async function strahdZombieEffects(npc) {
  for (let item of npc.items) {
    if (item.name.startsWith("Loathsome Limbs")) {
      let effect = baseMonsterFeatureEffect(item, item.name);
      effect.changes.push(
        DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "isDamaged", macroType: "monsterFeature", macroName: "loathsomeLimbs.js" }),
      );
      effect.transfer = true;
      foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");
      await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(item, "monsterFeature", "loathsomeLimbs.js");

      item.effects.push(effect);
    }
    item = (0,effects/* forceItemEffect */.Wk)(item);
  }

  return npc;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/beholderEyeRays.js



async function beholderEyeRaysEffect(document, rayNum = 3, range = 120) {
  foundry.utils.setProperty(document, "system.target", { value: rayNum, width: null, units: "", type: "creature" });
  foundry.utils.setProperty(document, "system.range", { value: range, long: null, units: "ft" });
  foundry.utils.setProperty(document, "system.damage", { parts: [], versatile: "", value: "" });
  foundry.utils.setProperty(document, "system.activation.type", "action");
  foundry.utils.setProperty(document, "system.actionType", "other");

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "monsterFeature", "eyeRays.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "monsterFeature", "eyeRays.js", ["postActiveEffects"]);

  document.system.save = {
    dc: null,
    ability: "",
    scaling: "spell",
  };

  foundry.utils.setProperty(document, "flags.midiProperties.magiceffect", true);

  document.effects = [];
  document = (0,effects/* forceItemEffect */.Wk)(document);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/spellReflection.js



async function spellReflectionEffect(document) {

  foundry.utils.setProperty(document, "system.activation.type", "special");
  foundry.utils.setProperty(document, "system.actionType", "other");

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "monsterFeature", "spellReflection.js");

  let effect = (0,effects/* baseEffect */.mS)(document, document.name, { transfer: true, disabled: false });
  effect.changes.push(
    DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "isSaveSuccess", macroType: "monsterFeature", macroName: "spellReflection.js", document }),
    DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "isAttacked", macroType: "monsterFeature", macroName: "spellReflection.js", document }),
  );
  document.effects.push(effect);

  return document;
}

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
;// CONCATENATED MODULE: ./src/effects/monsterFeatures/giantSpider.js




function giantSpiderEffects(npc) {
  for (let item of npc.items) {
    if (item.name.startsWith("Web")) {
      let effect = baseMonsterFeatureEffect(item, item.name);
      (0,effects/* addStatusEffectChange */.sb)(effect, "Restrained", 20, true);
      effect.changes.push(
        {
          key: "flags.midi-qol.OverTime",
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          value: "turn=start,name=You can take an action to break free of the web by rolling a Strength Ability Check",
          priority: "20",
        },
        {
          key: "flags.midi-qol.OverTime",
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
          value: "turn=end, rollType=check, actionSave=true, saveAbility=str, saveDC=@abilities.str.dc, label=Restrained by Web",
          priority: "20",
        },
      );

      foundry.utils.setProperty(effect, "duration.seconds", 60);
      foundry.utils.setProperty(effect, "duration.rounds", 10);
      foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");

      item.effects.push(effect);
      item = (0,effects/* forceItemEffect */.Wk)(item);
    }
  }

  return npc;
}


;// CONCATENATED MODULE: ./src/effects/monsterFeatures/beholderEyeRayLegendary.js



async function beholderEyeRayLegendaryEffect(document, rayNum = 3, range = 120) {
  foundry.utils.setProperty(document, "system.target", { value: rayNum, width: null, units: "", type: "creature" });
  foundry.utils.setProperty(document, "system.range", { value: range, long: null, units: "ft" });
  foundry.utils.setProperty(document, "system.damage", { parts: [], versatile: "", value: "" });
  foundry.utils.setProperty(document, "system.activation.type", "action");
  foundry.utils.setProperty(document, "system.actionType", "other");

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "monsterFeature", "eyeRay.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "monsterFeature", "eyeRay.js", ["postActiveEffects"]);

  document.system.save = {
    dc: null,
    ability: "",
    scaling: "spell",
  };

  foundry.utils.setProperty(document, "flags.midiProperties.magiceffect", true);

  document.effects = [];
  document = (0,effects/* forceItemEffect */.Wk)(document);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/monsterFeatures/multiAttack.js



async function multiAttackEffect(document) {
  let effect = (0,effects/* baseEffect */.mS)(document, document.name, { transfer: true, disabled: false });
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "monsterFeature", "multiAttack.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "monsterFeature", "multiAttack.js", ["preCompleted"]);
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/specialMonsters.js
/* eslint-disable require-atomic-updates */

























function baseMonsterFeatureEffect(document, label,
  { transfer = false, disabled = false } = {}
) {
  return (0,effects/* baseEffect */.mS)(document, label, { transfer, disabled });
}

function transferEffectsToActor(document) {
  // when legacy transferral gets removed, we don't need to do this.
  if (!CONFIG.ActiveEffect.legacyTransferral) return document;
  if (!document.effects) document.effects = [];
  // loop over items and item effect and transfer any effects to the actor
  document.items.forEach((item) => {
    item.effects.forEach((effect) => {
      if (effect.transfer) {
        const transferEffect = foundry.utils.duplicate(effect);
        if (!foundry.utils.hasProperty(item, "_id")) item._id = foundry.utils.randomID();
        if (!foundry.utils.hasProperty(effect, "_id")) effect._id = foundry.utils.randomID();
        transferEffect._id = foundry.utils.randomID();
        transferEffect.transfer = false;
        transferEffect.origin = `Actor.${document._id}.Item.${item._id}`;
        foundry.utils.setProperty(transferEffect, "flags.ddbimporter.originName", item.name);
        foundry.utils.setProperty(transferEffect, "flags.ddbimporter.localOriginEffect", true);
        document.effects.push(transferEffect);
      }
    });
  });

  return document;
}

/**
 * This function is mainly for effects that can't be dynamically generated
 * @param {*} document
 */
// eslint-disable-next-line complexity
async function monsterFeatureEffectAdjustment(ddbMonster, addMidiEffects = false) {
  let npc = foundry.utils.duplicate(ddbMonster.npc);

  if (!npc.effects) npc.effects = [];

  const deps = (0,effects/* effectModules */.xV)();
  if (!deps.hasCore || !addMidiEffects) {
    logger/* default.debug */.Z.debug(`Adding Condition Effects to ${npc.name}`);
    // damage over time effects
    for (let [index, item] of npc.items.entries()) {
      // auto condition effect
      if (item.type !== "spell") {
        // console.warn(`Auto-adding Condition Effect to ${item.name} in ${npc.name}`);
        const overTimeResults = (0,overTimeEffect/* generateConditionOnlyEffect */.pD)(npc, item);
        item = overTimeResults.document;
        npc = overTimeResults.actor;
      }

      item = (0,effects/* forceItemEffect */.Wk)(item);
      npc.items[index] = item;
    };
    return npc;
  }

  if (!addMidiEffects) return npc;

  // damage over time effects
  for (let [index, item] of npc.items.entries()) {
    item = (0,effects/* applyDefaultMidiFlags */.VN)(item);
    // Legendary Resistance Effects
    if (item.name.startsWith("Legendary Resistance")) item = generateLegendaryEffect(item);
    else if (item.name.startsWith("Pack Tactics")) item = generatePackTacticsEffect(item);
    else if (item.name === "Reversal of Fortune") item = generateReversalOfFortuneEffect(item);
    else if (item.name === "Suave Defense") item = generateSuaveDefenseEffect(ddbMonster, item);
    else if (item.name === "Uncanny Dodge") item = (0,uncannyDodge/* uncannyDodgeEffect */.Q)(item);
    else if (item.name === "Reckless") item = (0,recklessAttack/* recklessAttackEffect */.k)(item, true);
    else if (["Shared Invisibility", "Fallible Invisibility", "Invisibility", "Superior Invisibility"].includes(item.name))
      item = invisibilityFeatureEffect(item);
    else if (item.name.includes("Absorption")) item = absorptionEffect(item);
    else if (item.name === "Mask of the Wild") item = await (0,maskOfTheWild/* maskOfTheWildEffect */.L)(item);
    else if (item.name === "Spell Reflection") item = await spellReflectionEffect(item);
    else if (item.name === "Multiattack") item = await multiAttackEffect(item);

    // auto overtime effect
    if (item.type !== "spell") {
      const overTimeResults = (0,overTimeEffect/* generateOverTimeEffect */.FI)(npc, item);
      item = overTimeResults.document;
      npc = overTimeResults.actor;
    }

    item = (0,effects/* forceItemEffect */.Wk)(item);
    npc.items[index] = item;
  };

  switch (npc.name) {
    case "Bard": {
      npc.items.forEach((item) => {
        if (item.name === "Taunt") {
          item = generateTauntEffect(item);
        }
      });
      break;
    }
    case "Beholder": {
      for (let [index, item] of npc.items.entries()) {
        if (item.name === "Eye Rays") {
          npc.items[index] = await beholderEyeRaysEffect(item, 3, 120);
        } else if (item.name === "Eye Ray") {
          npc.items[index] = await beholderEyeRayLegendaryEffect(item, 3, 120);
        }
      }
      break;
    }
    case "Beholder Zombie": {
      for (let [index, item] of npc.items.entries()) {
        if (item.name === "Eye Ray") {
          npc.items[index] = await beholderEyeRaysEffect(item, 1, 60);
        }
      }
      break;
    }
    case "Carrion Crawler":
    case "Reduced-threat Carrion Crawler": {
      npc.items.forEach(function(item, index) {
        if (item.name === "Tentacles") {
          (0,effects/* addStatusEffectChange */.sb)(this[index].effects[0], "Paralyzed", 20, true);
          this[index] = (0,effects/* forceItemEffect */.Wk)(this[index]);
        }
      }, npc.items);
      break;
    }
    case "Giant Spider": {
      npc = giantSpiderEffects(npc);
      break;
    }
    case "Quasit": {
      npc = await quasitEffects(npc);
      break;
    }
    case "Rahadin": {
      for (let [index, item] of npc.items.entries()) {
        if (item.name === "Deathly Choir") {
          npc.items[index] = await deathlyChoirEffect(item);
        }
      }
      break;
    }
    case "Skeletal Juggernaut": {
      npc = await skeletalJuggernautEffects(npc);
      break;
    }
    case "Spectator": {
      for (let [index, item] of npc.items.entries()) {
        if (item.name === "Eye Rays") {
          npc.items[index] = await beholderEyeRaysEffect(item, 2, 90);
        }
      }
      break;
    }
    case "Strahd Zombie": {
      npc = await strahdZombieEffects(npc);
      break;
    }
    case "Venom Troll": {
      npc = await venomTrollEffects(npc);
      break;
    }
    // no default
  }

  switch (npc.system.details.type.value) {
    case "dragon": {
      npc.items.forEach(function (item, index) {
        if (item.name === "Frightful Presence") {
          this[index].effects[0].duration.rounds = 10;
        }
      }, npc.items);
      break;
    }
    // no default
  }

  return npc;
}


/***/ }),

/***/ 3137:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "f": () => (/* binding */ baseSpellEffect),
  "x": () => (/* binding */ spellEffectAdjustment)
});

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
// EXTERNAL MODULE: ./src/effects/DDBMacros.js
var DDBMacros = __webpack_require__(6516);
;// CONCATENATED MODULE: ./src/effects/spells/absorbElements.js




async function absorbElementsEffect(document) {
  const effect = baseSpellEffect(document, `${document.name} - Extra Damage`);
  effect.changes.push(
    {
      key: "system.bonuses.mwak.damage",
      value: `(@item.level)d6`,
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
    {
      key: "system.bonuses.msak.damage",
      value: `(@item.level)d6`,
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );

  effect.flags.dae.specialDuration = ["DamageDealt", "turnEnd"];
  effect.duration.rounds = 2;
  effect.duration.startTurn = 1;

  document.effects.push(effect);

  const resistanceEffect = baseSpellEffect(document, `${document.name} - Resistance`);
  resistanceEffect.changes.push(
    {
      key: "system.traits.dr.value",
      value: "fire",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    },
  );
  resistanceEffect.duration.rounds = 2;
  foundry.utils.setProperty(resistanceEffect, "flags.dae.specialDuration", ["turnStartSource"]);
  document.effects.push(resistanceEffect);

  document.system.damage = {
    parts: [],
    versatile: "",
    value: "",
  };
  document.system.target = {
    value: null,
    width: null,
    units: "",
    type: "self",
  };
  document.system.range = {
    value: null,
    long: null,
    units: "self",
  };
  foundry.utils.setProperty(document, "system.actionType", "util");

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "absorbElements.js");
    DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "absorbElements.js", ["postActiveEffects"]);
    foundry.utils.setProperty(document, "system.activation.type", "reactiondamage");
  }

  return document;
}



;// CONCATENATED MODULE: ./src/effects/spells/acidArrow.js


function acidArrowEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: `label=${document.name} (End of Turn),turn=end,damageRoll=(@spellLevel)d4[acid],damageType=acid,killAnim=true`,
    priority: "20",
  });
  effect.flags.dae.specialDuration = ["turnEnd"];
  effect.duration.rounds = 1;
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/aid.js




async function aidEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push({
      key: "system.attributes.hp.tempmax",
      value: "5 * (@spellLevel - 1)",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    });
    document.system.damage = { parts: [], versatile: "", value: "" };
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "aid.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@spellLevel", macroType: "spell", macroName: "aid.js", priority: 0 }));
  } else if ((0,effects/* effectModules */.xV)().daeInstalled) {
    effect.changes.push({
      key: "system.attributes.hp.tempmax",
      value: "5 * (@spellLevel - 1)",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 20,
    });
  }
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/alterSelf.js


function alterSelfEffect(document) {
  let effectAquaticAdaptation = baseSpellEffect(document, document.name);
  effectAquaticAdaptation.changes.push({
    key: "system.attributes.movement.swim",
    value: "@attributes.movement.walk",
    mode: 4,
    priority: 20,
  });
  document.effects.push(effectAquaticAdaptation);

  let effectNaturalWeapons = baseSpellEffect(document, document.name);
  effectNaturalWeapons.changes.push(
    { key: "items.Unarmed Strike.system.damage.parts.0.0", value: "1d6+@mod+1", mode: 5, priority: 20 },
    { key: "items.Unarmed Strike.system.properties.mgc", value: "true", mode: 5, priority: 20 },
    { key: "items.Unarmed Strike.system.proficient", value: "true", mode: 5, priority: 20 },
    { key: "items.Unarmed Strike.system.attack.bonus", value: "1", mode: 2, priority: 20 }
  );
  document.effects.push(effectNaturalWeapons);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/animalFriendship.js



function animalFriendshipEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Charmed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);
  document.effects.push(effect);

  return document;
}

// EXTERNAL MODULE: ./src/parser/companions/DDBSummonsManager.js
var DDBSummonsManager = __webpack_require__(6843);
;// CONCATENATED MODULE: ./src/effects/spells/arcaneEye.js


async function arcaneEyeEffect(document) {
  const manager = new DDBSummonsManager/* default */.Z();
  await manager.init();

  const summonActors = manager.itemHandler.compendium.index.filter((i) =>
    [
      "ArcaneEye",
    ].includes(i.flags?.ddbimporter?.summons?.summonsKey)
  );
  const profiles = summonActors
    .map((actor) => {
      return {
        _id: actor._id,
        name: actor.name,
        uuid: actor.uuid,
        count: 1,
      };
    });

  const summons = {
    "match": {
      "proficiency": false,
      "attacks": false,
      "saves": false
    },
    "bonuses": {
      "ac": "",
      "hp": "",
      "attackDamage": "",
      "saveDamage": "",
      "healing": ""
    },
    "profiles": profiles,
    "prompt": true
  };

  foundry.utils.setProperty(document, "system.summons", summons);
  foundry.utils.setProperty(document, "system.actionType", "summ");

  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/arcaneHand.js


async function arcaneHandEffect(document) {
  const manager = new DDBSummonsManager/* default */.Z();
  await manager.init();

  const summonActors = manager.itemHandler.compendium.index.filter((i) =>
    [
      "ArcaneHandRed",
      "ArcaneHandPurple",
      "ArcaneHandGreen",
      "ArcaneHandBlue",
      "ArcaneHandRock",
      "ArcaneHandRainbow",
    ].includes(i.flags?.ddbimporter?.summons?.summonsKey)
  );
  const profiles = summonActors
    .map((actor) => {
      return {
        _id: actor._id,
        name: actor.name,
        uuid: actor.uuid,
        count: 1,
      };
    });

  const summons = {
    "match": {
      "proficiency": false,
      "attacks": true,
      "saves": false
    },
    "bonuses": {
      "ac": "",
      "hp": "@attributes.hp.max",
      "attackDamage": "",
      "saveDamage": "",
      "healing": ""
    },
    "profiles": profiles,
    "prompt": true
  };

  foundry.utils.setProperty(document, "system.summons", summons);
  foundry.utils.setProperty(document, "system.actionType", "summ");

  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/arcaneSword.js


async function arcaneSwordEffect(document) {
  const manager = new DDBSummonsManager/* default */.Z();
  await manager.init();

  const summonActors = manager.itemHandler.compendium.index.filter((i) =>
    [
      "ArcaneSwordSpectralGreen",
      "ArcaneSwordAstralBlue",
    ].includes(i.flags?.ddbimporter?.summons?.summonsKey)
  );
  const profiles = summonActors
    .map((actor) => {
      return {
        _id: actor._id,
        name: actor.name,
        uuid: actor.uuid,
        count: 1,
      };
    });

  const summons = {
    "match": {
      "proficiency": false,
      "attacks": true,
      "saves": false
    },
    "bonuses": {
      "ac": "",
      "hp": "",
      "attackDamage": "",
      "saveDamage": "",
      "healing": ""
    },
    "profiles": profiles,
    "prompt": true
  };

  foundry.utils.setProperty(document, "system.summons", summons);
  foundry.utils.setProperty(document, "system.actionType", "summ");
  document.system.damage = { parts: [], versatile: "", value: "" };

  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/armorOfAgathys.js



async function armorOfAgathysEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dae.onUpdateTarget",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Armor of Agathys,ItemMacro,system.attributes.hp.temp,@item.level",
      priority: 20,
    },
  );
  effect.duration.seconds = 3600;
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "armorOfAgathys.js");
  foundry.utils.setProperty(document, "system.actionType", "util");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/auraOfLife.js
/* eslint-disable require-atomic-updates */




async function auraOfLifeEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.traits.dr.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "necrotic",
      priority: "20",
    },
    // {
    //   key: "flags.midi-qol.OverTime",
    //   mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    //   value: "turn=start,label=Aura of Life (Start of Turn),damageRoll=1,damageType=heal,killAnim=true,applyCondition=##attributes.hp.value <= 0",
    //   priority: "20",
    // }
  );

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "auraOfLife.js");
    effect.flags["ActiveAuras"] = {
      isAura: true,
      aura: "Allies",
      radius: 30,
      alignment: "",
      type: "",
      ignoreSelf: false,
      height: false,
      hidden: false,
      onlyOnce: false,
      save: false,
      savedc: null,
      displayTemp: true,
    };
    // foundry.utils.setProperty(effect, "duration.seconds", 600);
    foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@token", macroType: "spell", macroName: "auraOfLife.js" }));
    document.system.actionType = "other";
    document.system.damage.parts = [];
    document.system.range = { value: null, units: "self", long: null };
    document.system['target']['type'] = "self";
  }

  document.effects.push(effect);
  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/bane.js


function baneEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.bonuses.mwak.attack", value: "-1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.rwak.attack", value: "-1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.msak.attack", value: "-1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.rsak.attack", value: "-1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.abilities.save", value: "-1d4", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/banishment.js



async function banishmentEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "banishment.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@token", macroType: "spell", macroName: "banishment.js", priority: 0 }));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/barkskin.js


function barkskinEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.ac.value",
      mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
      value: "16",
      priority: "100",
    },
    {
      key: "system.attributes.ac.calc",
      mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
      value: "custom",
      priority: "100",
    }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/beaconofHope.js


function beaconofHopeEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.ability.save.wis",
      value: "1",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      priority: 20,
    },
    { key: "flags.midi-qol.advantage.deathSave", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 20 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/blackTentacles.js




async function blackTentaclesEffect(document) {
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled || !(0,effects/* effectModules */.xV)().midiQolInstalled) {
    let effect = baseSpellEffect(document, `${document.name} - Restrained`);
    (0,effects/* addStatusEffectChange */.sb)(effect, "Restrained", 20, true);
    document.effects.push(effect);

    return document;
  }

  let effect = baseSpellEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_ON_ENTRY.file);
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: null,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "str",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 60);
  foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "generic", macroName: DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_ON_ENTRY.file }));
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_ON_ENTRY.file, ["preActiveEffects"]);

  const aaMacroFlags = {
    applyStart: true,
    handleStartRoll: true,
    autoDamageIfCondition: true,
    applyEnd: false,
    applyEntry: true,
    applyImmediate: false,
    everyEntry: false,
    conditionEffect: true,
    damageEffect: true,
    removeOnOff: true,
    allowVsRemoveCondition: true,
    removalCheck: ["str", "dex"],
    removalSave: null,
    saveRemoves: false,
    condition: "Restrained",
    dice: `${document.system.damage.parts[0][0]}`,
    damageType: `${document.system.damage.parts[0][1]}`,
    save: `${document.system.save.ability}`,
    sequencerFile: "jb2a.black_tentacles.dark_purple",
  };
  foundry.utils.setProperty(document, "flags.ddbimporter.effect", aaMacroFlags);
  foundry.utils.setProperty(effect, "flags.ddbimporter.effect", aaMacroFlags);
  // foundry.utils.setProperty(document, "flags.midiProperties.nodam", true);
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.save.ability = "";
  document.system.actionType = "other";

  document.effects.push(effect);
  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/bless.js



function blessEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.bonuses.abilities.save", value: "+1d4", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.bonuses.mwak.attack", value: "+1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.rwak.attack", value: "+1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.msak.attack", value: "+1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.rsak.attack", value: "+1d4", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
  );
  document.effects.push(effect);

  if ((0,effects/* effectModules */.xV)().tokenMagicInstalled) {
    effect.changes.push((0,effects/* generateTokenMagicFXChange */.UY)("bloom"));
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/blindnessDeafness.js




async function blindnessDeafnessEffect(document) {
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    let effect = baseSpellEffect(document, document.name);
    effect.changes.push({
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "label=Blindness/Deafness (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=con,savingThrow=true,saveMagic=true,killAnim=true",
      priority: "20",
    });
    effect.duration.rounds = 10;
    effect.duration.seconds = 60;
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "blindnessDeafness.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "blindnessDeafness.js" }));
    DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "blindnessDeafness.js", ["postActiveEffects"]);
    document.effects.push(effect);
  } else {
    let blindnessEffect = baseSpellEffect(document, "Blindness");
    (0,effects/* addStatusEffectChange */.sb)(blindnessEffect, "Blinded", 20, true);
    document.effects.push(blindnessEffect);
    let deafenedEffect = baseSpellEffect(document, "Deafness");
    (0,effects/* addStatusEffectChange */.sb)(deafenedEffect, "Deafened", 20, true);
    document.effects.push(deafenedEffect);
  }


  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/blur.js



function blurEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'flags.midi-qol.grants.disadvantage.attack.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '1',
      priority: "20",
    }
  );

  if ((0,effects/* effectModules */.xV)().tokenMagicInstalled) {
    effect.changes.push((0,effects/* generateTokenMagicFXChange */.UY)("blur"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/boomingBlade.js


async function boomingBladeEffect(document) {
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system['target']['type'] = "self";
  document.system.range = { value: null, units: "self", long: null };
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "boomingBlade.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "boomingBlade.js", ["postActiveEffects"]);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/brandingSmite.js



async function brandingSmiteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "spell", macroName: "brandingSmite.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: "20",
    },
    {
      key: "flags.midi-qol.brandingSmite.level",
      value: "@item.level",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      priority: "20",
    },
  );
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Hit:rwak", "1Hit:mwak"]);

  document.system.actionType = "other";
  document.system.target.type = "self";
  document.system.damage.parts = [];
  document.effects.push(effect);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "brandingSmite.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "brandingSmite.js", ["postActiveEffects"]);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/callLightning.js



async function callLightningEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@spellLevel", macroType: "spell", macroName: "callLightning.js" }));
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);
  foundry.utils.setProperty(document, "system.actionType", "other");
  document.system.save.ability = "";
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "callLightning.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "callLightning.js", ["preTargeting"]);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/charmPerson.js



function charmPersonEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Charmed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/chillTouch.js


// import DDBMacros from "../DDBMacros.js";

async function chillTouchEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.traits.di.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "healing",
      priority: "30",
    },
  );
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push(
      {
        key: "flags.midi-qol.onUseMacroName",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `function.DDBImporter.lib.DDBMacros.macroFunction.spell("chillTouchDisadvantage"),preAttackRoll`,
        // value: "Chill Touch (Target effect),preAttackRoll",
        priority: "30",
      },
    );
    // const itemMacroText = await DDBMacros.loadMacroFile("spell", "chillTouch.js");
    // document = DDBMacros.generateItemMacroFlag(document, itemMacroText);
    // effect.changes.push(DDBMacros.generateMacroChange());
    foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnEndSource"]);
  }
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/chromaticOrb.js


async function chromaticOrbEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "chromaticOrb.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "chromaticOrb.js", ["postDamageRoll"]);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/cloudkill.js




async function cloudkillEffect(document) {
  // we require active auras for this effect
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled || !(0,effects/* effectModules */.xV)().midiQolInstalled) return document;

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        `label=${document.name} (Start of Turn),turn=start, saveAbility=con, killAnim=true, saveDC=@attributes.spelldc, saveDamage=halfdamage, rollType=save, saveMagic=true, damageBeforeSave=false, damageRoll=(@item.level)d8, damageType=${document.system.damage.parts[0][1]}`,
      priority: "20",
    },
  );
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@item.level", macroType: "generic", macroName: DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file }));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "str",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 600);
  // foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file, ["preActiveEffects"]);
  foundry.utils.setProperty(document, "flags.ddbimporter.effect", {
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.fog_cloud.2.green",
  });

  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";
  document.system.save.ability = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/colorSpray.js




async function colorSprayEffect(document) {

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "colorSpray.js", ["postActiveEffects"]);
    document.system.damage = { parts: [["6d10", "midi-none"]], versatile: "", value: "" };
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "colorSpray.js");
  } else {
    let effect = baseSpellEffect(document, `${document.name} - Blinded`);
    (0,effects/* addStatusEffectChange */.sb)(effect, "Blinded", 20, true);
    document.effects.push(effect);

  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/command.js




async function commandEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "command.js");
    DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "command.js", ["postSave"]);
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "command.js" }));
    effect.duration = {
      "seconds": 12,
      "rounds": 1,
      "turns": 1,
    };
    foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnStart"]);
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/comprehendLanguages.js


function comprehendLanguagesEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'system.traits.languages.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '1',
      priority: "20",
    }
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/confusion.js



async function confusionEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: "label=Confusion (End of Turn),turn=end,saveAbility=wis,saveDC=@attributes.spelldc,saveMagic=true,killAnim=true",
    priority: "20",
  });
  effect.flags.dae.macroRepeat = "startEveryTurn";
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "confusion.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "confusion.js" }));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/contagion.js




async function contagionEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Poisoned", 20, true);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.flags.dae.macroRepeat = "endEveryTurn";
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "contagion.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "contagion.js" }));
  }
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/createBonfire.js




async function createBonfireEffect(document) {
  // we require active auras for this effect
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled) return document;

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        "turn=end,label=Create Bonfire (End of Turn),damageRoll=(@cantripDice)d8,damageType=fire,saveRemove=false,saveDC=@attributes.spelldc,saveAbility=dex,saveDamage=nodamage,killAnim=true",
      priority: "20",
    },
  );
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: null,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 60);
  foundry.utils.setProperty(effect, "duration.rounds", 10);
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "generic", macroName: DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file }));
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file, ["preActiveEffects"]);

  document.effects.push(effect);

  foundry.utils.setProperty(document, "flags.ddbimporter.effect", {
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.flames.01.orange",
    sequencerScale: 2,
    isCantrip: true,
    saveOnEntry: true,
  });

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/crownofMadness.js



function crownofMadnessEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Charmed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push({
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "label=Crown of Madness (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=wis,saveMagic=true,killAnim=true",
      priority: "20",
    });
  }
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/crownofStars.js




async function crownofStarsEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  if ((0,effects/* effectModules */.xV)().atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.dim", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '60'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.bright", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '30'));
  }
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);

  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@spellLevel", macroType: "spell", macroName: "crownofStars.js" }));
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";
  document.effects.push(effect);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "crownofStars.js");
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/dancingLights.js


async function dancingLightsEffect(document) {
  const manager = new DDBSummonsManager/* default */.Z();
  await manager.init();

  const summonActors = manager.itemHandler.compendium.index.filter((i) =>
    [
      "DancingLightsYellow",
      "DancingLightsBlueTeal",
      "DancingLightsGreen",
      "DancingLightsBlueYellow",
      "DancingLightsPink",
      "DancingLightsPurpleGreen",
      "DancingLightsRed",
    ].includes(i.flags?.ddbimporter?.summons?.summonsKey)
  );
  const profiles = summonActors
    .map((actor) => {
      return {
        _id: actor._id,
        name: actor.name,
        uuid: actor.uuid,
        count: 4,
      };
    });

  const summons = {
    "match": {
      "proficiency": false,
      "attacks": false,
      "saves": false
    },
    "bonuses": {
      "ac": "",
      "hp": "",
      "attackDamage": "",
      "saveDamage": "",
      "healing": ""
    },
    "profiles": profiles,
    "prompt": true
  };

  foundry.utils.setProperty(document, "system.summons", summons);
  foundry.utils.setProperty(document, "system.actionType", "summ");

  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/darkness.js




async function darknessEffect(document) {
  const macroToggle = `<br><p>[[/ddbifunc functionName="darkness" functionType="spell"]]{Darkness Toggle}</div></p>`;
  document.system.description.value += macroToggle;
  if (document.system.description.chat !== "") document.system.description.chat += macroToggle;

  if (!(0,effects/* effectModules */.xV)().midiQolInstalled) return document;

  let effect = baseSpellEffect(document, document.name);
  // foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "darkness.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "darkness.js" }));
  document.effects.push(effect);
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "darkness.js", ["preTargeting"]);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/darkvision.js




async function darkvisionEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.senses.darkvision",
    value: "60",
    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
    priority: 20,
  });

  if ((0,effects/* effectModules */.xV)().atlInstalled) {
    effect.changes.push(
      (0,effects/* generateATLChange */.Ci)("ATL.sight.range", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 60, 5),
      (0,effects/* generateATLChange */.Ci)("ATL.sight.visionMode", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, "darkvision", 5),
    );
  } else if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "darkvision.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "darkvision.js" }));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/divineFavor.js


function divineFavorEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.bonuses.mwak.damage", value: "1d4[Radiant]", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },
    { key: "system.bonuses.rwak.damage", value: "1d4[Radiant]", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 }
  );
  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/divineWord.js



async function divineWordEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "divineWord.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "divineWord.js" }));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/dominateBeast.js



function dominateBeastEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Charmed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/dominateMonster.js



function dominateMonsterEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Charmed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/dominatePerson.js



function dominatePersonEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Charmed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);
  document.effects.push(effect);

  return document;
}

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
;// CONCATENATED MODULE: ./src/effects/spells/elementalWeapon.js



function elementalWeaponEffect(document) {
  document.system.damage.parts = [];
  document.system.chatFlavor = "";

  const elementTypes = [
    { type: "acid", img: "icons/magic/acid/dissolve-bone-white.webp" },
    { type: "cold", img: "icons/magic/water/barrier-ice-crystal-wall-jagged-blue.webp" },
    { type: "fire", img: "icons/magic/fire/barrier-wall-flame-ring-yellow.webp" },
    { type: "lightning", img: "icons/magic/lightning/bolt-strike-blue.webp" },
    { type: "thunder", img: "icons/magic/sonic/explosion-shock-wave-teal.webp" },
  ];

  const enchantments = [
    { bonus: "1", min: null, max: 3 },
    { bonus: "2", min: 5, max: 6 },
    { bonus: "3", min: 7, max: null },
  ];
  document.system.actionType = "ench";
  foundry.utils.setProperty(document, "system.enchantment", {
    restrictions: {
      allowMagical: false,
      type: "weapon",
    },
  });
  for (const element of elementTypes) {
    for (const e of enchantments) {
      let effect = (0,effects/* baseEnchantmentEffect */.yN)(document, `${document.name}: ${utils/* default.capitalize */.Z.capitalize(element.type)} +${e.bonus}`);
      e.img = element.img;
      foundry.utils.setProperty(effect, "flags.dnd5e.enchantment.level", { min: e.min, max: e.max });
      effect.changes.push(
        {
          key: "name",
          mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
          value: `{}, +${e.bonus} (${utils/* default.capitalize */.Z.capitalize(element.type)})`,
          priority: 20,
        },
        {
          key: "system.properties",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: "mgc",
          priority: 20,
        },
        {
          key: "system.magicalBonus",
          mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
          value: e.bonus,
          priority: 20,
        },
        {
          key: "system.damage.parts",
          mode: CONST.ACTIVE_EFFECT_MODES.ADD,
          value: `[["${e.bonus}d4[${element.type}]", "${element.type}"]]`,
          priority: 20,
        }
      );
      e.description = `This weapon has become a +${e.bonus} magic weapon, granting a bonus to attack and damage rolls.`;
      document.effects.push(effect);
    }
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/enhanceAbility.js



async function enhanceAbilityEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.duration.rounds = 600;
  effect.duration.seconds = 3600;
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "enhanceAbility.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "enhanceAbility.js" }));
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "enhanceAbility.js", ["postActiveEffects"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/enlargeReduce.js




async function enlargeReduceEffect(document) {

  // const macroToggle = `<br><p>[[/ddbifunc functionName="enlargeReduce" functionType="spell"]]{Enlarge/Reduce Toggle}</div></p>`;
  // document.system.description.value += macroToggle;
  // if (document.system.description.chat !== "") document.system.description.chat += macroToggle;

  if (!(0,effects/* effectModules */.xV)().atlInstalled) return document;

  let effect = baseSpellEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "enlargeReduce.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "enlargeReduce.js", priority: 0 }));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/ensnaringStrike.js




async function ensnaringStrikeEffect(document) {
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    let effect = baseSpellEffect(document, document.name);
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "ensnaringStrike.js");
    effect.changes.push(
      DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "postActiveEffects", macroType: "spell", macroName: "ensnaringStrike.js", document }),
    );
    foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
    foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);

    document.effects.push(effect);
    document.system.damage = { parts: [], versatile: "", value: "" };
    document.system.actionType = null;
    document.system.save.ability = "";
    document.system.target.type = "self";
    // DDBMacros.setMidiOnUseMacroFlag(document, "spell", "ensnaringStrike.js", ["preTargeting"]);
  } else {
    let effect = baseSpellEffect(document, `${document.name} - Restrained`);
    (0,effects/* addStatusEffectChange */.sb)(effect, "Restrained", 20, true);
    document.effects.push(effect);
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/entangle.js



function entangleEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Restrained`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Restrained", 20, true);

  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "You can take an action to break free by rolling a Strength Ability Check",
      priority: "20",
    },
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `turn=end, rollType=check, actionSave=true, saveAbility=str, saveDC=@attributes.spelldc, label=Restrained by ${document.name}`,
      priority: "20",
    },
  );

  foundry.utils.setProperty(effect, "duration.seconds", 60);
  foundry.utils.setProperty(effect, "duration.rounds", 10);
  foundry.utils.setProperty(effect, "flags.dae.stackable", "noneName");

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/eyebite.js



async function eyebiteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "eyebite.js");
  effect.flags.dae.macroRepeat = "startEveryTurn";
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "eyebite.js" }));
  document.effects.push(effect);
  foundry.utils.setProperty(document, "system.actionType", "other");
  foundry.utils.setProperty(document, "system.save.ability", "");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/faerieFire.js




async function faerieFireEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.grants.advantage.attack.all",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "20",
  });

  if (game.modules.get("ATL")?.active) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "faerieFire.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "faerieFire.js" }));
  }

  if ((0,effects/* effectModules */.xV)().tokenMagicInstalled) {
    effect.changes.push((0,effects/* generateTokenMagicFXChange */.UY)("glow"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/fear.js



function fearEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Frightened`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Frightened", 20, true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/feeblemind.js


function feeblemindEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.abilities.cha.value", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 50 },
    { key: "system.abilities.int.value", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 50 },
    { key: "flags.midi-qol.fail.spell.all", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 20 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/fireShield.js




async function fireShieldEffect(document) {
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    let effect = baseSpellEffect(document, document.name);
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "fireShield.js");
    effect.changes.push(
      DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "isDamaged", macroType: "spell", macroName: "fireShield.js" }),
    );
    DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "fireShield.js", ["postActiveEffects"]);

    effect.duration.seconds = 600;
    effect.duration.rounds = 60;

    document.effects.push(effect);
    document.system.damage = { parts: [], versatile: "", value: "" };
    document.system.target.type = "self";
    foundry.utils.setProperty(document, "system.actionType", "util");

    foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  } else {
    let fireEffect = baseSpellEffect(document, "Cold Shield");
    fireEffect.changes.push({
      key: "system.traits.dr.value",
      value: "fire",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    });
    document.effects.push(fireEffect);
    let coldEffect = baseSpellEffect(document, "Warm Shield");
    coldEffect.changes.push({
      key: "system.traits.dr.value",
      value: "cold",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    });
    document.effects.push(coldEffect);
  }
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/flameBlade.js



async function flameBladeEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@spellLevel", macroType: "spell", macroName: "flameBlade.js" })
  );

  effect.changes.push(
    {
      key: "ATL.light.dim",
      mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
      value: "20",
      priority: 20,
    },
    {
      key: "ATL.light.bright",
      mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
      value: "10",
      priority: 20,
    }
  );
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.system.actionType = "other";
  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "flameBlade.js", ["preTargeting"]);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "flameBlade.js");
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/fleshtoStone.js




async function fleshtoStoneEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Restrained", 20, true);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "fleshtoStone.js");
    effect.flags.dae.macroRepeat = "endEveryTurn";
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "fleshtoStone.js" }));
  }
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/fly.js


function flyEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.movement.fly",
    value: "60",
    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
    priority: 20,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/frostbite.js


function frostbiteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "flags.midi-qol.disadvantage.attack.mwak", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 50 },
    { key: "flags.midi-qol.disadvantage.attack.rwak", value: "1", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 50 },
  );
  foundry.utils.setProperty(effect, "duration.rounds", 2);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Attack:rwak", "1Attack:mwak", "turnEnd"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/geas.js



function geasEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Charmed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/grease.js




async function greaseEffect(document) {

  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled || !(0,effects/* effectModules */.xV)().midiQolInstalled) {
    let effect = baseSpellEffect(document, `${document.name} - Prone`);
    (0,effects/* addStatusEffectChange */.sb)(effect, "Prone", 20, true);
    document.effects.push(effect);

    return document;
  }

  // if we have active auras use a more advanced macro
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `turn=end,label=${document.name},saveRemove=false,saveDC=@attributes.spelldc,saveAbility=dex,saveDamage=nodamage,killAnim=true,macro=${DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.name */.Z.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.name}`,
      priority: "20",
    },
  );

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file);
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file, ["preActiveEffects"]);
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@item.level @attributes.spelldc", macroType: "generic", macroName: DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file }));

  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: null,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 60);
  // foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  const aaMacroFlags = {
    applyStart: true,
    applyEnd: true,
    applyEntry: true,
    applyImmediate: true,
    everyEntry: true,
    removeOnOff: false,
    allowVsRemoveCondition: false,
    removalCheck: null,
    removalSave: null,
    saveRemoves: false,
    condition: "Prone",
    save: document.system.save.ability,
    sequencerFile: "jb2a.grease.dark_green.loop",
  };
  foundry.utils.setProperty(document, "flags.ddbimporter.effect", aaMacroFlags);
  foundry.utils.setProperty(effect, "flags.ddbimporter.effect", aaMacroFlags);

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/greaterInvisibility.js



async function greaterInvisibilityEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Invisible", 20, true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/greenFlameBlade.js


async function greenFlameBladeEffect(document) {
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system['target']['type'] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = "other";
  document.system.save.ability = "";
  document.system.chatFlavor = "";
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "greenFlameBlade.js", ["postActiveEffects"]);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "greenFlameBlade.js");
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/guidance.js


function guidanceEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'flags.midi-qol.optional.guidance.label',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: 'Guidance',
      priority: "20",
    },
    {
      key: 'flags.midi-qol.optional.guidance.check.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '+ 1d4',
      priority: "20",
    },
    {
      key: 'flags.midi-qol.optional.guidance.skill.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '+ 1d4',
      priority: "20",
    },
    {
      key: 'system.attributes.init.bonus',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '+ 1d4',
      priority: "20",
    },
  );
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", [
    // "isSkill",
    // "isCheck",
    "isInitiative",
  ]);

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/guidingBolt.js


function guidingBoltEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.grants.advantage.attack.all",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    priority: 20,
  });
  effect.flags.dae.specialDuration = ["isAttacked"];
  effect.duration = {
    startTime: null,
    seconds: null,
    rounds: 1,
    turns: null,
    startRound: null,
    startTurn: null,
  };
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/hailOfThorns.js



async function hailOfThornsEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "hailOfThorns.js");
  effect.changes.push(
    DDBMacros/* default.generateOnUseMacroChange */.Z.generateOnUseMacroChange({ macroPass: "postActiveEffects", macroType: "spell", macroName: "hailOfThorns.js", document }),
  );
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);

  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = null;
  document.system.save.ability = "";
  document.system.target.type = "self";

  return document;
}

// EXTERNAL MODULE: ./src/effects/spells/haste.js
var haste = __webpack_require__(2391);
;// CONCATENATED MODULE: ./src/effects/spells/heroesFeast.js




async function heroesFeastEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.traits.di.value", value: "poison", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 },
    { key: "system.traits.ci.value", value: "frightened", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 },
    { key: "system.traits.ci.value", value: "poisoned", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 },
  );
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "heroesFeast.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@damage", macroType: "spell", macroName: "heroesFeast.js", priority: 0 }));
  }
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/heroism.js




async function heroismEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.traits.ci.value",
      value: "frightened",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: 20,
    },
  );

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push(
      {
        key: "flags.midi-qol.OverTime",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `turn=start,damageRoll=@attributes.spellmod,damageType=temphp,label=${document.name} Renewal,fastForwardDamage=true`,
        priority: 20,
      },
    );
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "heroism.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "heroism.js" }));
    // eslint-disable-next-line require-atomic-updates
    document.system.damage.parts = [];
  }
  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/hex.js



// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor
// the Marked effect gets applied to the target
async function hexEffect(document) {
  let effect = baseSpellEffect(document, "Marked");

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "hex.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "hex.js", ["postActiveEffects"]);
  foundry.utils.setProperty(document, "system.actionType", "util");

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/hideousLaughter.js




async function hideousLaughterEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Incapacitated`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Incapacitated", 20, true);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push({
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "label=Hideous Laughter (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=wis,saveMagic=true,killAnim=true",
      priority: "20",
    });

    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "hideousLaughter.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "hideousLaughter.js" }));
  }
  document.effects.push(effect);

  let proneEffect = baseSpellEffect(document, `${document.name} - Prone`);
  (0,effects/* addStatusEffectChange */.sb)(proneEffect, "Prone", 20, true);
  document.effects.push(proneEffect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/holdMonster.js



function holdMonsterEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Paralyzed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Paralyzed", 20, true);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push({
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: `label=${document.name} (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=wis,savingThrow=true,saveMagic=true,killAnim=true`,
      priority: "20",
    });
  }
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/holdPerson.js



function holdPersonEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Paralyzed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Paralyzed", 20, true);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push({
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: `label=${document.name} (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=wis,savingThrow=true,saveMagic=true,killAnim=true`,
      priority: "20",
    });
  }
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/holyAura.js



function holyAuraEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.advantage.ability.save.all",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "1",
      priority: "20",
    },
    {
      key: "flags.midi-qol.grants.disadvantage.attack.all",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "1",
      priority: "20",
    },
  );

  if (CONFIG.DDBI.EFFECT_CONFIG.MODULES.installedModules.atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.dim", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '5'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.color", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '#ffffff'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.alpha", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '0.25'));
    const lightAnimation = '{"type": "sunburst", "speed": 2,"intensity": 4}';
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.animation", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, lightAnimation));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/huntersMark.js



// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor
// the Marked effect gets applied to the target
async function huntersMarkEffect(document) {
  let effect = baseSpellEffect(document, "Marked");
  effect.changes.push(
    {
      key: "flags.dae.onUpdateSource",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Hunter's Mark",
      priority: 20,
    },
  );
  effect.duration.seconds = 3600;
  document.effects.push(effect);

  let damageBonusEffect = baseSpellEffect(document, "Hunter's Mark");
  damageBonusEffect.changes.push({
    key: "flags.dnd5e.DamageBonusMacro",
    value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "spell", macroName: "huntersMark.js", document }),
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 20,
  });
  damageBonusEffect.transfer = true;

  foundry.utils.setProperty(damageBonusEffect, "flags.dae.transfer", true);
  document.effects.push(damageBonusEffect);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "huntersMark.js");
  foundry.utils.setProperty(document, "system.actionType", "util");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/hypnoticPattern.js



function hypnoticPatternEffect(document) {
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    let effectHypnoticPatternCharmed = baseSpellEffect(document, `${document.name} - Charmed`);
    (0,effects/* addStatusEffectChange */.sb)(effectHypnoticPatternCharmed, "Charmed", 20, true);
    document.effects.push(effectHypnoticPatternCharmed);

    let effectHypnoticPatternIncapacitated = baseSpellEffect(document, `${document.name} - Incapacitated`);
    (0,effects/* addStatusEffectChange */.sb)(effectHypnoticPatternIncapacitated, "Incapacitated", 20, true);
    document.effects.push(effectHypnoticPatternIncapacitated);
  } else {
    let effect = baseSpellEffect(document, document.name);
    (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);
    (0,effects/* addStatusEffectChange */.sb)(effect, "Incapacitated", 20, true);
    document.effects.push(effect);
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/iceKnife.js


async function iceKnifeEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "iceKnife.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "iceKnife.js", ["postActiveEffects"]);
  document.system.damage = { parts: [["1d10", "piercing"]], versatile: "", value: "" };
  document.system.scaling = { mode: "none", formula: "" };
  document.system.target = {
    value: 1,
    width: null,
    units: "",
    type: "creature",
  };
  document.system.save.ability = "";
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/incendiaryCloud.js




async function incendiaryCloudEffect(document) {
  // we require active auras for this effect
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled) return document;

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        `label=${document.name} Turn End,turn=end, saveAbility=dex, saveDC=@attributes.spelldc, saveDamage=halfdamage, rollType=save, saveMagic=true, damageBeforeSave=false, damageRoll=(@item.level)d8, damageType=${document.system.damage.parts[0][1]},killAnim=true`,
      priority: "20",
    },
  );
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@item.level", macroType: "generic", macroName: DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file }));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 60);
  // foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file, ["preActiveEffects"]);
  foundry.utils.setProperty(document, "flags.ddbimporter.effect", {
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.fumes.fire.orange",
  });

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/insectPlague.js




async function insectPlagueEffect(document) {
  // we require active auras for this effect
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled) return document;

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        `label=${document.name} Turn End,turn=end, saveAbility=con, saveDC=@attributes.spelldc, saveDamage=halfdamage, rollType=save, saveMagic=true, damageBeforeSave=false, damageRoll=(@item.level)d10, damageType=${document.system.damage.parts[0][1]}, killAnim=true`,
      priority: "20",
    },
  );
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@item.level", macroType: "generic", macroName: DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file }));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 600);
  // foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_DAMAGE_ON_ENTRY.file, ["preActiveEffects"]);
  foundry.utils.setProperty(document, "flags.ddbimporter.effect", {
    dice: document.system.damage.parts[0][0],
    damageType: document.system.damage.parts[0][1],
    save: document.system.save.ability,
    sequencerFile: "jb2a.butterflies.many.orange",
  });

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/invisibility.js



async function invisibilityEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Invisible", 20, true);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Attack", "1Spell"]);

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/irresistibleDance.js



async function irresistibleDanceEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  effect.changes.push({
    key: "flags.midi-qol.disadvantage.ability.save.str",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "20",
  });
  effect.changes.push({
    key: "flags.midi-qol.disadvantage.attack.all",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "20",
  });
  effect.changes.push({
    key: "flags.midi-qol.grants.advantage.attack.all ",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    value: "1",
    priority: "20",
  });

  effect.flags.dae.macroRepeat = "startEveryTurn";
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "irresistibleDance.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "irresistibleDance.js" }));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/light.js



function lightEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  if ((0,effects/* effectModules */.xV)().atlInstalled) {
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.dim", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '40'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.bright", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '20'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.color", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '#ffffff'));
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.alpha", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '0.25'));
    const lightAnimation = '{"type": "pulse", "speed": 3,"intensity": 1}';
    effect.changes.push((0,effects/* generateATLChange */.Ci)("ATL.light.animation", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, lightAnimation));
  }

  foundry.utils.setProperty(document, "flags.midiProperties.autoFailFriendly", true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/longstrider.js


function longstriderEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.attributes.movement.walk", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.attributes.movement.fly", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.attributes.movement.burrow", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.attributes.movement.climb", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },
    { key: "system.attributes.movement.swim", value: "10", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mageArmor.js


function mageArmorEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.ac.calc",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: "mage",
    priority: "5",
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mageHand.js


async function mageHandEffect(document) {
  const manager = new DDBSummonsManager/* default */.Z();
  await manager.init();

  const summonActors = manager.itemHandler.compendium.index.filter((i) =>
    [
      "MageHandRed",
      "MageHandPurple",
      "MageHandGreen",
      "MageHandBlue",
      "MageHandRock",
      "MageHandRainbow",
    ].includes(i.flags?.ddbimporter?.summons?.summonsKey)
  );
  const profiles = summonActors
    .map((actor) => {
      return {
        _id: actor._id,
        name: actor.name,
        uuid: actor.uuid,
        count: 1,
      };
    });

  const summons = {
    "match": {
      "proficiency": false,
      "attacks": false,
      "saves": false
    },
    "bonuses": {
      "ac": "",
      "hp": "",
      "attackDamage": "",
      "saveDamage": "",
      "healing": ""
    },
    "profiles": profiles,
    "prompt": true
  };

  foundry.utils.setProperty(document, "system.summons", summons);
  foundry.utils.setProperty(document, "system.actionType", "summ");

  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/magicWeapon.js


function magicWeaponEffect(document) {
  const enchantments = [
    { bonus: "1", min: null, max: 3 },
    { bonus: "2", min: 4, max: 5 },
    { bonus: "3", min: 6, max: null },
  ];
  document.system.actionType = "ench";
  foundry.utils.setProperty(document, "system.enchantment", {
    restrictions: {
      allowMagical: false,
      type: "weapon",
    },
  });
  for (const e of enchantments) {
    let effect = (0,effects/* baseEnchantmentEffect */.yN)(document, `${document.name}: +${e.bonus}`);
    foundry.utils.setProperty(effect, "flags.dnd5e.enchantment.level", { min: e.min, max: e.max });
    effect.changes.push(
      {
        key: "name",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: `{}, +${e.bonus}`,
        priority: 20,
      },
      {
        key: "system.properties",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: "mgc",
        priority: 20,
      },
      {
        key: "system.magicalBonus",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: e.bonus,
        priority: 20,
      },
    );
    e.description = `This weapon has become a +${e.bonus} magic weapon, granting a bonus to attack and damage rolls.`;
    document.effects.push(effect);
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/massSuggestion.js



function massSuggestionEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Charmed`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Charmed", 20, true);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mindBlank.js


function mindBlankEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'system.traits.di.value',
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: 'psychic',
      priority: "20",
    }
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mirrorImage.js



function mirrorImageEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  if ((0,effects/* effectModules */.xV)().tokenMagicInstalled) {
    effect.changes.push((0,effects/* generateTokenMagicFXChange */.UY)("images"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/mistyStep.js



async function mistyStepEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "mistyStep.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@target", macroType: "spell", macroName: "mistyStep.js" }));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/moonbeam.js



async function moonbeamEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.flags.dae.macroRepeat = "startEveryTurn";
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "moonbeam.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@spellLevel", macroType: "spell", macroName: "moonbeam.js" }));
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);
  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";
  document.system.save.ability = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/passWithoutTrace.js


function passWithoutTraceEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'system.skills.ste.bonuses.check',
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: '+ 10',
      priority: "20",
    }
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/phantasmalKiller.js



async function phantasmalKillerEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Frightened", 20, true);
  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push({
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value:
        "label=Phantasmal Killer (End of Turn),turn=end,saveAbility=wis,saveDC=@attributes.spelldc,saveMagic=true,damageRoll=(@item.level)d10,damageType=psychic,savingThrow=true,damageBeforeSave=false,killAnim=true",
      priority: "20",
    });
    document.system.damage = { parts: [], versatile: "", value: "" };
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/polymorph.js
function polymorphEffect(document) {

  foundry.utils.setProperty(document, "flags.midiProperties.autoFailFriendly", true);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/protectionfromEnergy.js



async function protectionfromEnergyEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "protectionfromEnergy.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "protectionfromEnergy.js", priority: 0 }));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/protectionfromPoison.js


function protectionfromPoisonEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.traits.dr.value",
    value: "poison",
    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
    priority: 0,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/psychicScream.js



function psychicScreamEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Stunned`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Stunned", 20, true);

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    effect.changes.push(
      {
        key: "flags.midi-qol.OverTime",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: "label=Psychic Scream Stun (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=int,saveMagic=true,killAnim=true",
        priority: "20",
      },
    );
    effect.duration.rounds = 99;
    foundry.utils.setProperty(document, "flags.midiProperties.halfdam", true);
    foundry.utils.setProperty(document, "flags.midiProperties.saveDamage", "halfdam");
  }
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/rayOfSickness.js



function rayofSicknessEffect(document) {
  let effect = baseSpellEffect(document, `${document.name} - Poisoned`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Poisoned", 20, true);
  effect.flags.dae.specialDuration = ["turnEndSource"];
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/rayofEnfeeblement.js



async function rayofEnfeeblementEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.OverTime",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    value: `label=${document.name} (End of Turn),turn=end,saveDC=@attributes.spelldc,saveAbility=con,savingThrow=true,saveMagic=true,killAnim=true`,
    priority: "20",
  });
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "rayofEnfeeblement.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "rayofEnfeeblement.js" }));
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/rayofFrost.js


function rayofFrostEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.movement.walk",
    value: "-10",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    priority: 20,
  });
  effect.duration.rounds = 2;
  effect.flags.dae.specialDuration = ["turnStart"];
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/regenerate.js


function regenerateEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: 5,
      value: `label=${document.name} (Start of Turn),killAnim=true,turn=end,damageRoll=1,damageType=healing,condition=@attributes.hp.value > 0 && @attributes.hp.value < @attributes.hp.max`,
      priority: "20",
    }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/resilientSphere.js


function resilientSphereEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'system.attributes.movement.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '* 0.5',
      priority: "20",
    },
    {
      key: 'system.traits.di.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '1',
      priority: "20",
    },
  );

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/resistance.js


function resistanceEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: 'flags.midi-qol.optional.resistance.label',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: 'Resistance',
      priority: "20",
    },
    {
      key: 'flags.midi-qol.optional.resistance.save.all',
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: '+ 1d4',
      priority: "20",
    },
  );
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isSave"]);

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/shield.js



function shieldEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.ac.bonus",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    value: "+5",
    priority: "20",
  });
  effect.flags.dae.specialDuration = ["turnStart"];

  if ((0,effects/* effectModules */.xV)().tokenMagicInstalled) {
    effect.changes.push((0,effects/* generateTokenMagicFXChange */.UY)("water-field"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/shieldofFaith.js



function shieldofFaithEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.ac.bonus",
    mode: CONST.ACTIVE_EFFECT_MODES.ADD,
    value: "+2",
    priority: "20",
  });

  if ((0,effects/* effectModules */.xV)().tokenMagicInstalled) {
    effect.changes.push((0,effects/* generateTokenMagicFXChange */.UY)("bloom"));
  }

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/shillelagh.js


function shillelaghEffect(document) {
  document.system.actionType = "ench";

  foundry.utils.setProperty(document, "system.enchantment", {
    restrictions: {
      allowMagical: true,
      type: "weapon",
    },
  });

  const baseEffects = [
    {
      key: "name",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: `{} [${document.name}]`,
      priority: 20,
    },
    {
      key: "system.properties",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "mgc",
      priority: 20,
    },
  ];

  let wisdomEffect = (0,effects/* baseEnchantmentEffect */.yN)(document, `${document.name}: Use Spellcasting Modifier`, { transfer: false });
  wisdomEffect._id = foundry.utils.randomID();
  wisdomEffect.changes.push(
    ...baseEffects,
    {
      key: "system.ability",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "wis", // @attributes.spellcasting - system.ability only takes a numerical value
      priority: 20,
    },
  );
  document.effects.push(wisdomEffect);

  let effect = (0,effects/* baseEnchantmentEffect */.yN)(document, `${document.name}: No Spellcasting Modifier`);
  effect.changes.push(...baseEffects);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/silence.js




async function silenceEffect(document) {

  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled) {
    let effect = baseSpellEffect(document, `${document.name} - Deafened`);
    (0,effects/* addStatusEffectChange */.sb)(effect, "Deafened", 20, true);
    document.effects.push(effect);
    return document;
  }

  // if we have active auras use a more advanced macro
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "generic", "activeAuraOnly.js");

  let effect = baseSpellEffect(document, document.name);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Deafened", 20, true);
  effect.changes.push(
    {
      key: "flags.midi-qol.fail.spell.vocal",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1",
      priority: "50",
    },
    {
      key: "system.traits.di.value",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "thunder",
      priority: "50",
    }
  );
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 600);
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "generic", "activeAuraOnly.js", ["preActiveEffects"]);

  const limits = {
    sight: {
      hearing: { enabled: true, range: 0 }, // Hearing
    },
    sound: { enabled: true, range: 0 },
  };

  const walledtemplates = {
    wallRestriction: "move",
    wallsBlock: "walled",
  };

  foundry.utils.setProperty(document, "flags.limits", limits);
  foundry.utils.setProperty(document, "flags.walledtemplates", walledtemplates);

  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/sleep.js




async function sleepEffect(document) {

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "sleep.js");
    DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "sleep.js", ["postActiveEffects"]);
    document.system.damage = { parts: [["5d8", "midi-none"]], versatile: "", value: "" };
  } else {
    let effect = baseSpellEffect(document, `${document.name} - Unconscious`);
    (0,effects/* addStatusEffectChange */.sb)(effect, "Unconscious", 20, true);
    document.effects.push(effect);
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/slow.js


function slowEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.attributes.ac.bonus", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "-2", priority: "20" },
    { key: "system.attributes.movement.all", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: "/2", priority: "20" },
    { key: "system.abilities.dex.bonuses.save", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "-2", priority: "20" }
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spiderClimb.js


function spiderClimbEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "system.attributes.movement.climb",
    value: "@attributes.movement.walk",
    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,
    priority: 20,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spikeGrowth.js




async function spikeGrowthEffect(document) {
  // we require active auras for this effect
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled) return document;

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "spikeGrowth.js");

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.movement.walk",
      value: "0.5",
      mode: CONST.ACTIVE_EFFECT_MODES.MULTIPLY,
      priority: 30,
    },
  );
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "spikeGrowth.js" }));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    // save: "dex",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 600);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["isMoved"]);
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "spikeGrowth.js", ["preActiveEffects"]);

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spiritGuardians.js




async function spiritGuardiansEffect(document) {
  // we require active auras for this effect
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled) return document;

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.attributes.movement.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "/2",
      priority: "20",
    },
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value:
        "turn=start,label=Spirit Guardians (Start of Turn),damageRoll=(@spellLevel)d8,damageType=radiant,saveRemove=false,saveDC=@attributes.spelldc,saveAbility=wis,saveDamage=halfdamage,killAnim=true",
      priority: "20",
    }
  );
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "spiritGuardians.js");
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "Enemy",
    radius: 15,
    alignment: "",
    type: "",
    ignoreSelf: true,
    height: false,
    hidden: false,
    hostile: false,
    onlyOnce: false,
    displayTemp: true,
  };
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@token @spellLevel @attributes.spelldc", macroType: "spell", macroName: "spiritGuardians.js" }));
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system['target']['type'] = "self";
  document.system.range = { value: 15, units: "ft", long: null };
  document.system.actionType = "";
  document.system.save.ability = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spiritShroud.js




async function spiritShroudEffect(document) {
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled) return document;
  let effect = baseSpellEffect(document, document.name);

  effect.changes.push(
    {
      key: "flags.midi-qol.spiritShroud",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "@uuid",
      priority: 20
    },
    {
      key: "system.attributes.movement.all",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "-10",
      priority: "15",
    });
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "Enemy",
    radius: 10,
    alignment: "",
    type: "",
    ignoreSelf: true,
    height: false,
    hidden: false,
    hostile: false,
    onlyOnce: false,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "spiritShroud.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "spiritShroud.js", ["preActiveEffects"]);

  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system['target']['type'] = "self";
  document.system.range = { value: null, units: "self", long: null };
  document.system.actionType = "other";
  document.system.save.ability = "";

  document.effects.push(effect);
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/spiritualWeapon.js



async function spiritualWeaponEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "spiritualWeapon.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@item.level", macroType: "spell", macroName: "spiritualWeapon.js" }));
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  document.effects.push(effect);

  document.system.damage = { parts: [], versatile: "", value: "" };
  document.system.actionType = "other";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/stoneskin.js


function stoneskinEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "system.traits.dr.value",
      value: "bludgeoning",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    },
    {
      key: "system.traits.dr.value",
      value: "piercing",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    },
    {
      key: "system.traits.dr.value",
      value: "slashing",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    },
    {
      key: "system.traits.dr.bypass",
      value: "mgc",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      priority: 0,
    },
  );
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/stormSphere.js




async function stormSphereEffect(document) {
  // we require active auras for this effect
  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled) return document;

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.disadvantage.skill.prc",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "0",
      priority: "20",
    },
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value:
        "turn=end,label=Storm Sphere (End of Turn),damageRoll=(@item.level - 2)d6,damageType=bludgeoning,saveRemove=false,saveDC=@attributes.spelldc,saveAbility=str,saveDamage=nodamage,killAnim=true",
      priority: "20",
    }
  );
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "stormSphere.js");
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: 20,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "str",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 60);
  foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "stormSphere.js" }));
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "stormSphere.js", ["preActiveEffects"]);

  document.effects.push(effect);

  const damageOne = foundry.utils.duplicate(document.system.damage.parts[0]);
  const damageTwo = foundry.utils.duplicate(document.system.damage.parts[1]);
  document.system.damage = { parts: [damageOne], versatile: "", value: "" };
  document.system.formula = damageTwo[0];
  document.system.actionType = "save";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/sunbeam.js



function sunbeamEffect(document) {
  let effectSunbeamBlinded = baseSpellEffect(document, `${document.name} - Blinded`);
  (0,effects/* addStatusEffectChange */.sb)(effectSunbeamBlinded, "Blinded", 20, true);
  document.effects.push(effectSunbeamBlinded);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/swordburst.js
function swordBurstEffect(document) {
  foundry.utils.setProperty(document, "flags.midi-qol.AoETargetType", "any");
  foundry.utils.setProperty(document, "flags.midi-qol.AoETargetTypeIncludeSelf", false);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/thunderclap.js
function thunderclapEffect(document) {
  foundry.utils.setProperty(document, "flags.midi-qol.AoETargetType", "any");
  foundry.utils.setProperty(document, "flags.midi-qol.AoETargetTypeIncludeSelf", false);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/thunderousSmite.js



async function thunderousSmiteEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.dnd5e.DamageBonusMacro",
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "spell", macroName: "thunderousSmite.js", document }),
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      priority: "20",
    },
    {
      key: "flags.midi-qol.thunderousSmite.dc",
      value: "@attributes.spelldc",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      priority: "20",
    },
  );
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Hit:mwak"]);
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);


  document.system.damage.parts = [];
  document.system.save.ability = "";
  document.system.actionType = "other";
  document.effects.push(effect);
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "thunderousSmite.js", ["postActiveEffects", "preTargeting"]);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "thunderousSmite.js");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/tidalWave.js



function tidalWaveEffect(document) {

  let effect = baseSpellEffect(document, `${document.name} - Prone`);
  (0,effects/* addStatusEffectChange */.sb)(effect, "Prone", 20, true);
  effect.duration = {
    seconds: 99999,
    rounds: 999,
  };
  document.effects.push(effect);

  return document;

}

;// CONCATENATED MODULE: ./src/effects/spells/tolltheDead.js


async function tolltheDeadEffect(document) {
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "tolltheDead.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "tolltheDead.js", ["postActiveEffects"]);

  document.system.damage = { parts: [], versatile: "", value: "" };
  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/trueStrike.js


function trueStrikeEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.advantage.attack.all",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    priority: 20,
  });
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/viciousMockery.js


function viciousMockeryEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push({
    key: "flags.midi-qol.disadvantage.attack.all",
    value: "1",
    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
    priority: 20,
  });
  foundry.utils.setProperty(effect, "duration.turns", 2);
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["1Attack", "turnEnd"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/vitriolicSphere.js
// Vitriolic Sphere




function vitriolicSphereEffect(document) {

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    {
      key: "flags.midi-qol.OverTime",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `turn=end,label=${document.name} (End of Turn),damageRoll=5d4,damageType=acid,removeCondition=true,killAnim=true`,
      priority: "20",
    }
  );
  foundry.utils.setProperty(effect, "flags.dae.specialDuration", ["turnEnd"]);
  foundry.utils.setProperty(effect, "duration.rounds", 1);
  document.effects.push(effect);

  const damageOne = foundry.utils.duplicate(document.system.damage.parts[0]);
  const damageTwo = foundry.utils.duplicate(document.system.damage.parts[1]);
  document.system.damage = { parts: [damageOne], versatile: "", value: "" };
  document.system.formula = damageTwo[0];
  document.system.actionType = "save";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/wardingBond.js




async function wardingBondEffect(document) {
  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(
    { key: "system.attributes.ac.bonus", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "+ 1", priority: "20" },
    { key: "system.traits.dr.all", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: "1", priority: "20" },
    { key: "system.bonuses.abilities.save", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "+ 1", priority: "20" }
  );

  if ((0,effects/* effectModules */.xV)().midiQolInstalled) {
    await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "wardingBond.js");
    effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "spell", macroName: "wardingBond.js" }));
    document.effects.push(effect);
  }

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/web.js




async function webEffect(document) {

  if (!(0,effects/* effectModules */.xV)().activeAurasInstalled || !(0,effects/* effectModules */.xV)().midiQolInstalled) {
    let effectWebRestrained = baseSpellEffect(document, `${document.name} - Restrained`);
    (0,effects/* addStatusEffectChange */.sb)(effectWebRestrained, "Restrained", 20, true);
    document.effects.push(effectWebRestrained);
    return document;
  }

  // if we have active auras use a more advanced macro
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file);

  let effect = baseSpellEffect(document, document.name);
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroValues: "@item.level @attributes.spelldc", macroType: "generic", macroName: DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file }));
  effect.flags["ActiveAuras"] = {
    isAura: true,
    aura: "All",
    radius: null,
    alignment: "",
    type: "",
    ignoreSelf: false,
    height: false,
    hidden: false,
    // hostile: true,
    onlyOnce: false,
    save: "dex",
    savedc: null,
    displayTemp: true,
  };
  foundry.utils.setProperty(effect, "duration.seconds", 3600);
  foundry.utils.setProperty(effect, "flags.dae.macroRepeat", "startEveryTurn");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "generic", DDBMacros/* default.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file */.Z.MACROS.ACTIVE_AURAS.AA_CONDITION_ON_ENTRY.file, ["preActiveEffects"]);

  foundry.utils.setProperty(document, "flags.ddbimporter.effect", {
    applyStart: true,
    applyEntry: true,
    applyImmediate: false,
    everyEntry: false,
    allowVsRemoveCondition: true,
    removalCheck: "str",
    removalSave: null,
    saveRemoves: false,
    condition: "Restrained",
    save: document.system.save.ability,
    // sequencerFile: "jb2a.web.02",
  });

  document.effects.push(effect);
  document.system.actionType = "other";
  document.system.save.ability = "";

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/witchBolt.js



async function witchBoltEffect(document) {
  let effect = baseSpellEffect(document, document.name);

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "witchBolt.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "spell", "witchBolt.js", ["postActiveEffects"]);
  document.effects.push(effect);

  return document;
}

;// CONCATENATED MODULE: ./src/effects/spells/zephyrStrike.js



async function zephyrStrikeEffect(document) {
  let effect = baseSpellEffect(document, `${document.name}`);

  // macroToCall
  effect.changes.push(
    {
      key: "flags.midi-qol.optional.ZephyrStrike.macroToCall",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: DDBMacros/* default.generateItemMacroValue */.Z.generateItemMacroValue({ macroType: "spell", macroName: "zephyrStrike.js", document }),
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZephyrStrike.damage.mwak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.system.damage.parts[0][0]}`,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZephyrStrike.damage.rwak",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: `${document.system.damage.parts[0][0]}`,
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZephyrStrike.count",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZephyrStrike.label",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "Gain Zephyr Strike damage bonus?",
      priority: "20",
    },
    {
      key: "flags.midi-qol.optional.ZephyrStrike.criticalDamage",
      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
      value: "1",
      priority: "20",
    },
  );

  document.system.target.type = "self";
  foundry.utils.setProperty(effect, "flags.dae.selfTarget", true);
  foundry.utils.setProperty(effect, "flags.dae.selfTargetAlways", true);
  foundry.utils.setProperty(document, "system.actionType", "other");

  document.effects.push(effect);
  document.system.damage.parts = [];

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "spell", "zephyrStrike.js");

  return document;
}

;// CONCATENATED MODULE: ./src/effects/specialSpells.js



// spell effects load start































































































































function baseSpellEffect(document, label,
  { transfer = false, disabled = false } = {}
) {
  return (0,effects/* baseEffect */.mS)(document, label, { transfer, disabled });
}


// eslint-disable-next-line complexity
async function basicSpellEffects(document) {
  const name = document.flags.ddbimporter?.originalName ?? document.name;

  logger/* default.debug */.Z.debug(`Adding basic effects to ${name}`);
  switch (name) {
    case "Absorb Elements": {
      document = await absorbElementsEffect(document);
      break;
    }
    case "Aid": {
      document = await aidEffect(document);
      break;
    }
    case "Animal Friendship": {
      document = animalFriendshipEffect(document);
      break;
    }
    case "Aura of Life": {
      document = await auraOfLifeEffect(document);
      break;
    }
    case "Arcane Eye": {
      document = await arcaneEyeEffect(document);
      break;
    }
    case "Bigby's Hand":
    case "Arcane Hand": {
      document = await arcaneHandEffect(document);
      break;
    }
    case "Mordenkainen's Sword":
    case "Arcane Sword": {
      document = await arcaneSwordEffect(document);
      break;
    }
    case "Bane": {
      document = baneEffect(document);
      break;
    }
    case "Barkskin": {
      document = barkskinEffect(document);
      break;
    }
    case "Evard's Black Tentacles":
    case "Black Tentacles": {
      document = await blackTentaclesEffect(document);
      break;
    }
    case "Bless": {
      document = blessEffect(document);
      break;
    }
    case "Blindness/Deafness": {
      document = await blindnessDeafnessEffect(document);
      break;
    }
    case "Charm Person": {
      document = charmPersonEffect(document);
      break;
    }
    case "Chill Touch": {
      document = await chillTouchEffect(document);
      break;
    }
    case "Contagion": {
      document = await contagionEffect(document);
      break;
    }
    case "Crown of Madness": {
      document = crownofMadnessEffect(document);
      break;
    }
    case "Darkness": {
      document = await darknessEffect(document);
      break;
    }
    case "Darkvision": {
      document = await darkvisionEffect(document);
      break;
    }
    case "Dancing Lights": {
      document = await dancingLightsEffect(document);
      break;
    }
    case "Divine Favor": {
      document = divineFavorEffect(document);
      break;
    }
    case "Dominate Beast": {
      document = dominateBeastEffect(document);
      break;
    }
    case "Dominate Monster": {
      document = dominateMonsterEffect(document);
      break;
    }
    case "Dominate Person": {
      document = dominatePersonEffect(document);
      break;
    }
    case "Elemental Weapon": {
      document = elementalWeaponEffect(document);
      break;
    }
    case "Ensnaring Strike": {
      document = await ensnaringStrikeEffect(document);
      break;
    }
    case "Entangle": {
      document = entangleEffect(document);
      break;
    }
    case "Fear": {
      document = fearEffect(document);
      break;
    }
    case "Feeblemind": {
      document = feeblemindEffect(document);
      break;
    }
    case "Fire Shield": {
      document = await fireShieldEffect(document);
      break;
    }
    case "Flesh to Stone": {
      document = await fleshtoStoneEffect(document);
      break;
    }
    case "Fly": {
      document = flyEffect(document);
      break;
    }
    case "Geas": {
      document = geasEffect(document);
      break;
    }
    case "Grease": {
      document = await greaseEffect(document);
      break;
    }
    case "Greater Invisibility": {
      document = await greaterInvisibilityEffect(document);
      break;
    }
    case "Haste": {
      document = (0,haste/* hasteEffect */.r)(document);
      break;
    }
    case "Heroes' Feast": {
      document = await heroesFeastEffect(document);
      break;
    }
    case "Heroism": {
      document = await heroismEffect(document);
      break;
    }
    case "Tasha's Hideous Laughter":
    case "Hideous Laughter": {
      document = await hideousLaughterEffect(document);
      break;
    }
    case "Hold Monster": {
      document = holdMonsterEffect(document);
      break;
    }
    case "Hold Person": {
      document = holdPersonEffect(document);
      break;
    }
    case "Hypnotic Pattern": {
      document = hypnoticPatternEffect(document);
      break;
    }
    case "Invisibility": {
      document = await invisibilityEffect(document);
      break;
    }
    case "Light": {
      document = lightEffect(document);
      break;
    }
    case "Mage Armor": {
      document = mageArmorEffect(document);
      break;
    }
    case "Mage Hand": {
      document = await mageHandEffect(document);
      break;
    }
    case "Magic Weapon": {
      document = magicWeaponEffect(document);
      break;
    }
    case "Mass Suggestion": {
      document = massSuggestionEffect(document);
      break;
    }
    case "Mind Blank": {
      document = mindBlankEffect(document);
      break;
    }
    case "Mirror Image": {
      document = mirrorImageEffect(document);
      break;
    }
    case "Pass Without Trace": {
      document = passWithoutTraceEffect(document);
      break;
    }
    case "Phantasmal Killer": {
      document = await phantasmalKillerEffect(document);
      break;
    }
    case "Protection from Poison": {
      document = protectionfromPoisonEffect(document);
      break;
    }
    case "Psychic Scream": {
      document = psychicScreamEffect(document);
      break;
    }
    case "Ray of Sickness": {
      document = rayofSicknessEffect(document);
      break;
    }
    case "Shield": {
      document = shieldEffect(document);
      break;
    }
    case "Shillelagh": {
      document = shillelaghEffect(document);
      break;
    }
    case "Shield of Faith": {
      document = shieldofFaithEffect(document);
      break;
    }
    case "Sleep": {
      document = await sleepEffect(document);
      break;
    }
    case "Slow": {
      document = slowEffect(document);
      break;
    }
    case "Spider Climb": {
      document = spiderClimbEffect(document);
      break;
    }
    case "Stoneskin": {
      document = stoneskinEffect(document);
      break;
    }
    case "Sunbeam": {
      document = sunbeamEffect(document);
      break;
    }
    case "Tidal Wave": {
      document = tidalWaveEffect(document);
      break;
    }
    case "Warding Bond": {
      document = await wardingBondEffect(document);
      break;
    }
    case "Web": {
      document = await webEffect(document);
      break;
    }
    // no default
  }

  return document;
}

/**
 * This function is for effects that can't be dynamically generated
 * @param {*} document
 */
// eslint-disable-next-line complexity
async function midiEffectAdjustment(document) {
  const deps = (0,effects/* effectModules */.xV)();
  const name = document.flags.ddbimporter?.originalName ?? document.name;
  document = (0,effects/* applyDefaultMidiFlags */.VN)(document);

  // check that we can gen effects
  if (!deps.hasCore) {
    logger/* default.warn */.Z.warn("Sorry, you're missing some required modules for advanced automation of spell effects. Please install them and try again.", deps);
    return document;
  }

  logger/* default.debug */.Z.debug(`Adding effects to ${name}`);
  switch (name) {
    case "Melf's Acid Arrow":
    case "Acid Arrow": {
      document = acidArrowEffect(document);
      break;
    }
    case "Alter Self": {
      document = alterSelfEffect(document);
      break;
    }
    case "Armor of Agathys": {
      document = await armorOfAgathysEffect(document);
      break;
    }
    case "Banishment": {
      document = await banishmentEffect(document);
      break;
    }
    case "Beacon of Hope": {
      document = beaconofHopeEffect(document);
      break;
    }
    case "Blur": {
      document = blurEffect(document);
      break;
    }
    case "Booming Blade": {
      document = await boomingBladeEffect(document);
      break;
    }
    case "Branding Smite": {
      document = await brandingSmiteEffect(document);
      break;
    }
    case "Call Lightning": {
      document = await callLightningEffect(document);
      break;
    }
    case "Chromatic Orb": {
      document = await chromaticOrbEffect(document);
      break;
    }
    case "Cloudkill": {
      document = await cloudkillEffect(document);
      break;
    }
    case "Color Spray": {
      document = await colorSprayEffect(document);
      break;
    }
    case "Command": {
      document = await commandEffect(document);
      break;
    }
    case "Comprehend Languages": {
      document = comprehendLanguagesEffect(document);
      break;
    }
    case "Confusion": {
      document = await confusionEffect(document);
      break;
    }
    case "Counterspell": {
      document = (0,effects/* forceManualReaction */.pi)(document);
      break;
    }
    case "Crown of Stars": {
      document = await crownofStarsEffect(document);
      break;
    }
    case "Create Bonfire": {
      document = await createBonfireEffect(document);
      break;
    }
    case "Divine Word": {
      document = await divineWordEffect(document);
      break;
    }
    case "Enhance Ability": {
      document = await enhanceAbilityEffect(document);
      break;
    }
    case "Enlarge/Reduce": {
      document = await enlargeReduceEffect(document);
      break;
    }
    case "Eyebite": {
      document = await eyebiteEffect(document);
      break;
    }
    case "Faerie Fire": {
      document = await faerieFireEffect(document);
      break;
    }
    case "Feather Fall": {
      document = (0,effects/* forceManualReaction */.pi)(document);
      break;
    }
    case "Flame Blade": {
      document = await flameBladeEffect(document);
      break;
    }
    case "Frostbite": {
      document = frostbiteEffect(document);
      break;
    }
    case "Green-Flame Blade": {
      document = await greenFlameBladeEffect(document);
      break;
    }
    case "Guidance": {
      document = guidanceEffect(document);
      break;
    }
    case "Guiding Bolt": {
      document = guidingBoltEffect(document);
      break;
    }
    case "Hail of Thorns": {
      document = await hailOfThornsEffect(document);
      break;
    }
    case "Hex": {
      document = await hexEffect(document);
      break;
    }
    case "Holy Aura": {
      document = holyAuraEffect(document);
      break;
    }
    case "Hunter's Mark": {
      document = await huntersMarkEffect(document);
      break;
    }
    case "Ice Knife": {
      document = await iceKnifeEffect(document);
      break;
    }
    case "Incendiary Cloud": {
      document = await incendiaryCloudEffect(document);
      break;
    }
    case "Insect Plague": {
      document = await insectPlagueEffect(document);
      break;
    }
    case "Otto's Irresistible Dance":
    case "Irresistible Dance": {
      document = await irresistibleDanceEffect(document);
      break;
    }
    case "Longstrider": {
      document = longstriderEffect(document);
      break;
    }
    case "Misty Step": {
      if (!deps.autoAnimationsInstalled) {
        document = await mistyStepEffect(document);
      }
      break;
    }
    case "Moonbeam": {
      document = await moonbeamEffect(document);
      break;
    }
    case "Polymorph": {
      document = polymorphEffect(document);
      break;
    }
    case "Protection from Energy": {
      document = await protectionfromEnergyEffect(document);
      break;
    }
    case "Ray of Enfeeblement": {
      document = await rayofEnfeeblementEffect(document);
      break;
    }
    case "Ray of Frost": {
      document = rayofFrostEffect(document);
      break;
    }
    case "Regenerate": {
      document = regenerateEffect(document);
      break;
    }
    case "Otiluke's Resilient Sphere":
    case "Resilient Sphere": {
      document = resilientSphereEffect(document);
      break;
    }
    case "Resistance": {
      document = resistanceEffect(document);
      break;
    }
    case "Silence": {
      document = await silenceEffect(document);
      break;
    }
    case "Spike Growth": {
      document = await spikeGrowthEffect(document);
      break;
    }
    case "Spirit Guardians": {
      document = await spiritGuardiansEffect(document);
      break;
    }
    case "Spirit Shroud": {
      document = await spiritShroudEffect(document);
      break;
    }
    case "Spiritual Weapon": {
      document = await spiritualWeaponEffect(document);
      break;
    }
    case "Storm Sphere": {
      document = await stormSphereEffect(document);
      break;
    }
    case "Sword Burst": {
      document = swordBurstEffect(document);
      break;
    }
    case "Thunderclap": {
      document = thunderclapEffect(document);
      break;
    }
    case "Thunderous Smite": {
      document = await thunderousSmiteEffect(document);
      break;
    }
    case "Toll the Dead": {
      document = await tolltheDeadEffect(document);
      break;
    }
    case "True Strike": {
      document = trueStrikeEffect(document);
      break;
    }
    case "Vicious Mockery": {
      document = viciousMockeryEffect(document);
      break;
    }
    case "Vitriolic Sphere": {
      document = await vitriolicSphereEffect(document);
      break;
    }
    case "Witch Bolt": {
      document = await witchBoltEffect(document);
      break;
    }
    case "Zephyr Strike": {
      document = await zephyrStrikeEffect(document);
      break;
    }
    // no default
  }

  return document;
}


async function spellEffectAdjustment(document, midiEffects = false) {
  if (!document.effects) document.effects = [];
  document = await basicSpellEffects(document);
  if (midiEffects) document = await midiEffectAdjustment(document);
  try {
    document = (0,effects/* forceItemEffect */.Wk)(document);
  } catch (err) {
    await Promise.all(document);
    logger/* default.error */.Z.error("Error applying effects: ", { err, document });
  }
  return document;
}


/***/ }),

/***/ 2391:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": () => (/* binding */ hasteEffect)
/* harmony export */ });
/* harmony import */ var _specialSpells_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3137);


function hasteEffect(document) {
  let effect = (0,_specialSpells_js__WEBPACK_IMPORTED_MODULE_0__/* .baseSpellEffect */ .f)(document, document.name);
  effect.changes.push(
    { key: "system.attributes.ac.bonus", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: "+2", priority: "20" },
    {
      key: "flags.midi-qol.advantage.ability.save.dex",
      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
      value: "1",
      priority: "20",
    },
    { key: "system.attributes.movement.all", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: "*2", priority: "30" }
  );
  effect.duration = {
    startTime: null,
    seconds: null,
    rounds: 10,
    startRound: null,
    startTurn: null,
  };
  document.effects.push(effect);

  return document;
}


/***/ }),

/***/ 5042:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": () => (/* binding */ addVision5eStubs),
/* harmony export */   "p": () => (/* binding */ addVision5eStub)
/* harmony export */ });
/* harmony import */ var _effects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5751);
/* harmony import */ var _specialSpells_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3137);




const VISION_EFFECTS = {
  "Detect Evil and Good": {
    effectName: "Detect Evil and Good",
    type: "spell",
    transfer: false,
  },
  "Echolocation": {
    effectName: "Echolocation",
    type: "feat",
    transfer: true,
  },
  "Detect Thoughts": {
    effectName: "Detect Thoughts",
    type: "spell",
    transfer: false,
  },
  "Detect Magic": {
    effectName: "Detect Magic",
    type: "spell",
    transfer: false,
  },
  "Detect Poison and Disease": {
    effectName: "Detect Poison and Disease",
    type: "spell",
    transfer: false,
  },
  "Eldritch Invocations: Devil's Sight": {
    effectName: "Devil's Sight",
    type: "feat",
    transfer: true,
  },
  "Devil's Sight": {
    effectName: "Devil's Sight",
    type: "feat",
    transfer: true,
  },
  "See Invisibility": {
    effectName: "See Invisibility",
    type: "spell",
    transfer: false,
  },
  "Ghostly Gaze": {
    effectName: "Ghostly Gaze",
    type: "feat",
    transfer: false,
  },
};

function addVision5eStub(document) {
  if (!document.effects) document.effects = [];

  const name = document.flags?.ddbimporter?.originalName ?? document.name;

  // if document name in Vision effects then add effect
  if (VISION_EFFECTS[name]
    && document.type === VISION_EFFECTS[name].type
    && !document.effects.some((e) => e.name === VISION_EFFECTS[name].effectName)
  ) {
    const effect = (0,_specialSpells_js__WEBPACK_IMPORTED_MODULE_1__/* .baseSpellEffect */ .f)(document, VISION_EFFECTS[name].effectName);
    effect.transfer = VISION_EFFECTS[name].transfer;
    document.effects.push(effect);
    if (VISION_EFFECTS[name].type === "spell") {
      document.system.target.type = "self";
    }
    foundry.utils.setProperty(document, "flags.ddbimporter.effectsApplied", true);
  }
  return document;
}

function addVision5eStubs(documents) {
  // check that we can gen effects
  const deps = (0,_effects_js__WEBPACK_IMPORTED_MODULE_0__/* .effectModules */ .xV)();
  if (!deps.vision5eInstalled) return documents;

  for (let document of documents) {
    document = addVision5eStub(document);
  }

  return documents;
}


/***/ }),

/***/ 9187:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "v": () => (/* binding */ createDDBCompendium)
/* harmony export */ });
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6451);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3893);
/* harmony import */ var _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7407);




async function createDDBCompendium(compendiumSetting) {
  const compendiumName = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, compendiumSetting.setting);
  const compendiumData = {
    id: compendiumName,
    type: compendiumSetting.type,
    label: `DDB ${compendiumSetting.title}`,
    image: compendiumSetting.image,
    dnd5eTypeTags: compendiumSetting.types,
  };

  const createCompendiumFolder = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "top-level-compendium-folder");
  const compendiumFolder = createCompendiumFolder
    ? await _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getFolder */ .Z.getFolder("compendium", "", "D&D Beyond", "#6f0006", "#98020a", false)
    : null;
  if (createCompendiumFolder) compendiumData.folder = compendiumFolder._id;
  const result = await _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].createIfNotExists */ .Z.createIfNotExists(compendiumData);

  if (result.created) {
    await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, compendiumSetting.setting, result.compendium.metadata.id);
  } else if (result.compendium?.folder === null && createCompendiumFolder) {
    result.compendium.configure({ folder: compendiumFolder._id });
  }
}

/* harmony default export */ async function __WEBPACK_DEFAULT_EXPORT__() {
  if (game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "auto-create-compendium")) {
    for (const compendium of _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUMS.filter */ .Z.COMPENDIUMS.filter((c) => c.auto)) {
      await createDDBCompendium(compendium);
    }
  }
}


/***/ }),

/***/ 3893:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6968);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);





const CompendiumHelper = {

  // a mapping of compendiums with content type
  LOOKUP: [
    { type: "adventure", compendium: "entity-adventure-compendium" },
    { type: "adventures", compendium: "entity-adventure-compendium" },
    { type: "background", compendium: "entity-background-compendium" },
    { type: "backgrounds", compendium: "entity-background-compendium" },
    { type: "class", compendium: "entity-class-compendium" },
    { type: "classes", compendium: "entity-class-compendium" },
    { type: "classfeatures", compendium: "entity-feature-compendium" },
    { type: "consumable", compendium: "entity-item-compendium" },
    { type: "container", compendium: "entity-item-compendium" },
    { type: "custom", compendium: "entity-override-compendium" },
    { type: "equipment", compendium: "entity-item-compendium" },
    { type: "feat", compendium: "entity-feature-compendium" },
    { type: "feats", compendium: "entity-feat-compendium" },
    { type: "feature", compendium: "entity-feature-compendium" },
    { type: "features", compendium: "entity-feature-compendium" },
    { type: "inventory", compendium: "entity-item-compendium" },
    { type: "item", compendium: "entity-item-compendium" },
    { type: "items", compendium: "entity-item-compendium" },
    { type: "journal", compendium: "entity-journal-compendium" },
    { type: "JournalEntry", compendium: "entity-journal-compendium" },
    { type: "journals", compendium: "entity-journal-compendium" },
    { type: "loot", compendium: "entity-item-compendium" },
    { type: "magicitem", compendium: "entity-item-compendium" },
    { type: "magicitems", compendium: "entity-item-compendium" },
    { type: "monster", compendium: "entity-monster-compendium" },
    { type: "monsters", compendium: "entity-monster-compendium" },
    { type: "npc", compendium: "entity-monster-compendium" },
    { type: "override", compendium: "entity-override-compendium" },
    { type: "race", compendium: "entity-race-compendium" },
    { type: "races", compendium: "entity-race-compendium" },
    { type: "RollTable", compendium: "entity-table-compendium" },
    { type: "spell", compendium: "entity-spell-compendium" },
    { type: "spell", compendium: "entity-spell-compendium" },
    { type: "spells", compendium: "entity-spell-compendium" },
    { type: "subclass", compendium: "entity-subclass-compendium" },
    { type: "subclasses", compendium: "entity-subclass-compendium" },
    { type: "summon", compendium: "entity-summons-compendium" },
    { type: "summons", compendium: "entity-summons-compendium" },
    { type: "table", compendium: "entity-table-compendium" },
    { type: "tables", compendium: "entity-table-compendium" },
    { type: "tool", compendium: "entity-item-compendium" },
    { type: "trait", compendium: "entity-trait-compendium" },
    { type: "traits", compendium: "entity-trait-compendium" },
    { type: "vehicle", compendium: "entity-vehicle-compendium" },
    { type: "vehicles", compendium: "entity-vehicle-compendium" },
    { type: "weapon", compendium: "entity-item-compendium" },
  ],

  getCompendiumLabel: (type) => {
    const compendiumName = CompendiumHelper.LOOKUP.find((c) => c.type == type).compendium;
    const compendiumLabel = game.settings.get("ddb-importer", compendiumName);
    return compendiumLabel;
  },

  getCompendium: (label, fail = true) => {
    const compendium = game.packs.get(label);
    if (compendium) {
      return compendium;
    } else {
      if (fail) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Unable to find compendium ${label}`);
        ui.notifications.error(`Unable to open the Compendium ${label}. Check the compendium exists and is set in "Module Settings > DDB Importer > Compendiums"`);
        throw new Error(`Unable to open the Compendium ${label}. Check the compendium exists and is set in "Module Settings > DDB Importer > Compendiums".`);
      }
      return undefined;
    }
  },

  getCompendiumType: (type, fail = true) => {
    const compendiumLabel = CompendiumHelper.getCompendiumLabel(type);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Getting compendium ${compendiumLabel} for update of ${type}`);
    const compendium = CompendiumHelper.getCompendium(compendiumLabel, false);
    if (compendium) {
      return compendium;
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Unable to find compendium ${compendiumLabel} for ${type} documents`);
      ui.notifications.error(`Unable to open the Compendium ${compendiumLabel}. Check the compendium exists and is set in "Module Settings > DDB Importer > Compendiums"`);
      if (fail) {
        throw new Error(`Unable to open the Compendium ${compendiumLabel}. Check the compendium exists and is set in "Module Settings > DDB Importer > Compendiums"`);
      }
      return undefined;
    }
  },

  loadCompendiumIndex: async (type, indexOptions = {}) => {
    const compendiumLabel = CompendiumHelper.getCompendiumLabel(type);
    foundry.utils.setProperty(CONFIG.DDBI, `compendium.label.${type}`, compendiumLabel);
    const compendium = await CompendiumHelper.getCompendium(compendiumLabel);

    if (compendium) {
      const index = await compendium.getIndex(indexOptions);
      foundry.utils.setProperty(CONFIG.DDBI, `compendium.index.${type}`, index);
      return index;
    } else {
      return undefined;
    }
  },

  /* eslint-disable require-atomic-updates */
  copyExistingActorProperties: async (type, foundryActor) => {
    const compendium = CompendiumHelper.getCompendiumType(type);

    if (game.settings.get("ddb-importer", "munching-policy-update-existing")) {
      const existingNPC = await compendium.getDocument(foundryActor._id);

      const updateImages = game.settings.get("ddb-importer", "munching-policy-update-images");
      if (!updateImages && existingNPC.system.img !== CONST.DEFAULT_TOKEN) {
        foundryActor.img = existingNPC.system.img;
      }
      if (!updateImages && foundry.utils.getProperty(existingNPC, "prototypeToken.texture.src") !== CONST.DEFAULT_TOKEN) {
        foundryActor.prototypeToken.texture.src = existingNPC.prototypeToken.texture.src;
        foundryActor.prototypeToken.scale = existingNPC.prototypeToken.scale;
        foundryActor.prototypeToken.randomImg = existingNPC.prototypeToken.randomImg;
        foundryActor.prototypeToken.mirrorX = existingNPC.prototypeToken.mirrorX;
        foundryActor.prototypeToken.mirrorY = existingNPC.prototypeToken.mirrorY;
        foundryActor.prototypeToken.lockRotation = existingNPC.prototypeToken.lockRotation;
        foundryActor.prototypeToken.rotation = existingNPC.prototypeToken.rotation;
        foundryActor.prototypeToken.alpha = existingNPC.prototypeToken.alpha;
        foundryActor.prototypeToken.lightAlpha = existingNPC.prototypeToken.lightAlpha;
        foundryActor.prototypeToken.lightAnimation = existingNPC.prototypeToken.lightAnimation;
        foundryActor.prototypeToken.tint = existingNPC.prototypeToken.tint;
        foundryActor.prototypeToken.lightColor = existingNPC.prototypeToken.lightColor;
      }

      const retainBiography = game.settings.get("ddb-importer", "munching-policy-monster-retain-biography");
      if (retainBiography) {
        foundryActor.system.details.biography = existingNPC.system.details.biography;
      }

      _DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].copySupportedItemFlags */ .Z.copySupportedItemFlags(existingNPC.toObject(), foundryActor);
    }

    return foundryActor;

  },
  /* eslint-enable require-atomic-updates */

  getActorIndexActor: async (type, npc) => {
    const monsterIndexFields = ["name", "flags.ddbimporter.id"];
    const legacyName = game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    const index = await CompendiumHelper.loadCompendiumIndex(type, { fields: monsterIndexFields });
    const npcMatch = index.contents.find((entity) =>
      foundry.utils.hasProperty(entity, "flags.ddbimporter.id")
      && entity.flags.ddbimporter.id == npc.flags.ddbimporter.id
      && ((!legacyName && entity.name.toLowerCase() === npc.name.toLowerCase())
        || (legacyName && npc.flags.ddbimporter.isLegacy && npc.name.toLowerCase().startsWith(entity.name.toLowerCase()))
        || (legacyName && entity.name.toLowerCase() === npc.name.toLowerCase()))
    );
    return npcMatch;
  },

  existingActorCheck: async (type, foundryActor) => {
    const matchingActor = await CompendiumHelper.getActorIndexActor(type, foundryActor);
    if (matchingActor) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Found existing ${type}, updating: ${matchingActor.name}`);
      // eslint-disable-next-line require-atomic-updates
      foundryActor._id = matchingActor._id;
      foundryActor = await CompendiumHelper.copyExistingActorProperties(type, foundryActor);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`No existing compendium match for ${foundryActor.name}`);
    }
    return foundryActor;
  },

  sanitize: (text) => {
    if (text && typeof text === "string") {
      return text.replace(/\s|\./g, '-').toLowerCase();
    }
    return text;
  },

  getDefaultCompendiumName: (compendiumLabel) => {
    const sanitizedLabel = CompendiumHelper.sanitize(compendiumLabel);
    const name = `ddb-${game.world.id}-${sanitizedLabel}`;
    return name;
  },

  /**
   * Attempts to find a compendium pack by name, if not found, create a new one based on item type
   * @param  {string} label - Label of compendium to find
   * @param  {string} type - Name of compendium
   * @param  {string} id - Id of compendium, optional, used in place of label to find compendium
   * @param  {string} packageType - package type of compendium, defaults to world
   * @returns {object} - Object consisting of compendium and creation result
   */
  // eslint-disable-next-line no-unused-vars
  createIfNotExists: async ({ label, type, id = undefined, packageType = "world", folderId = null, dnd5eTypeTags = [] } = {}) => {
    if (id) _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Checking if Compendium with id ${id} exists for ${_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID}`);
    else if (label) _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Checking if Compendium with label ${label} exists for ${_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID}`);
    const compendium = await game.packs.get(id) ?? game.packs.find((p) => p.metadata.label === label);
    if (compendium) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Compendium '${id}' (${compendium.metadata.label}) found, will not create compendium.`);
      return {
        compendium,
        created: false
      };
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Compendium for ${label}, was not found, creating it now.`);
      const name = CompendiumHelper.getDefaultCompendiumName(label);
      const defaultCompendium = await game.packs.get(`${packageType}.${name}`);
      if (defaultCompendium) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Could not load Compendium '${id}', and could not create default Compendium '${name}' as it already exists. Please check your DDB Importer Compendium setup.`);
        return {
          compendium: null,
          created: false,
        };
      } else {
        // create a compendium for the user
        const newCompendium = await CompendiumCollection.createCompendium({
          type,
          label,
          name,
          package: packageType,
          // flags: {
          //   dnd5e: {
          //     types: dnd5eTypeTags,
          //   }
          // }
        });
        if (folderId) await newCompendium.setFolder(folderId);
        return {
          compendium: newCompendium,
          created: true
        };
      }
    }
  },

  getCompendiumNames: () => {
    return _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].COMPENDIUMS.map */ .Z.COMPENDIUMS.map((ddbCompendium) => {
      return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, ddbCompendium.setting);
    });
  },

  deleteDefaultCompendiums: (force = true) => {
    if (!force) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn("Pass 'true' to this function to force deletion.");
    }
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "auto-create-compendium", false);

    const clone = foundry.utils.deepClone(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].DEFAULT_SETTINGS */ .Z.DEFAULT_SETTINGS);
    const compendiumSettings = _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].APPLY_GLOBAL_DEFAULTS */ .Z.APPLY_GLOBAL_DEFAULTS(clone.READY.COMPENDIUMS);

    for (const [name, data] of Object.entries(compendiumSettings)) {
      const compendiumName = CompendiumHelper.getDefaultCompendiumName(data.default);

      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Setting: ${name} : Deleting compendium ${data.name} with key world.${compendiumName}}`);
      game.packs.delete(`world.${compendiumName}`);
    }
  },

  /**
   * Queries a compendium for a single document
   * Returns either the entry from the index, or the complete document from the compendium
   */
  queryCompendiumEntry: async (compendiumName, documentName, getDocument = false) => {
    // normalize the entity name for comparison
    documentName = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(documentName);

    // get the compendium
    const compendium = game.packs.get(compendiumName);
    if (!compendium) return null;

    // retrieve the compendium index
    const index = await compendium.getIndex();

    let id = index.find((entity) => _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(entity.name) === documentName);
    if (id && getDocument) {
      let entity = await compendium.getDocument(id._id);
      return entity;
    }
    return id ? id : null;
  },

  /**
   * Queries a compendium for a single document
   * Returns either the entry from the index, or the complete document from the compendium
   */
  queryCompendiumEntries: async (compendiumName, documentNames, getDocuments = false) => {
    // get the compendium
    let compendium = game.packs.get(compendiumName);
    if (!compendium) return null;

    // retrieve the compendium index
    let index = await compendium.getIndex();
    index = index.map((entry) => {
      entry.normalizedName = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(entry.name);
      return entry;
    });

    // get the indices of all the entitynames, filter un
    let indices = documentNames
      .map((entityName) => {
        // sometimes spells do have restricted use in paranthesis after the name. Let's try to find those restrictions and add them later
        if (entityName.search(/(.+)\(([^()]+)\)*/) !== -1) {
          const match = entityName.match(/(.+)\(([^()]+)\)*/);
          return {
            name: _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(match[1].trim()),
            restriction: match[2].trim(),
          };
        } else {
          return {
            name: _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(entityName),
            restriction: null,
          };
        }
      })
      .map((data) => {
        let entry = index.find((entity) => entity.normalizedName === data.name);
        if (entry) {
          return {
            _id: entry._id,
            name: data.restriction ? `${entry.name} (${data.restriction})` : entry.name,
          };
        } else {
          return null;
        }
      });

    if (getDocuments) {
      // replace non-null values with the complete entity from the compendium
      let entities = await Promise.all(
        indices.map((entry) => {
          return new Promise((resolve) => {
            if (entry) {
              compendium.getDocument(entry._id).then((entity) => {
                entity.name = entry.name; // transfer restrictions over, if any
                // remove redudant info
                delete entity.id;
                delete entity.ownership;
                resolve(entity);
              });
            } else {
              resolve(null);
            }
          });
        })
      );
      return entities;
    }
    return indices;
  },

  /**
   * Queries a compendium for a given document name
   * @returns the index entries of all matches, otherwise an empty array
   */
  queryCompendium: async (compendiumName, documentName, getDocument = false) => {
    documentName = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(documentName);

    let compendium = game.packs.get(compendiumName);
    if (!compendium) return null;
    let index = await compendium.getIndex();
    let id = index.find((entity) => _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizeString */ .Z.normalizeString(entity.name) === documentName);
    if (id && getDocument) {
      let entity = await compendium.getEntity(id._id);
      return entity;
    }
    return id ? id : null;
  },

  /**
   *
   * @param {[string]} items Array of Strings or
   */
  async retrieveMatchingCompendiumItems(items, compendiumName) {
    const GET_ENTITY = true;

    const itemNames = items.map((item) => {
      if (typeof item === "string") return item;
      if (typeof item === "object" && Object.prototype.hasOwnProperty.call(item, "name")) return item.name;
      return "";
    });

    const results = await CompendiumHelper.queryCompendiumEntries(compendiumName, itemNames, GET_ENTITY);
    const cleanResults = results.filter((item) => item !== null);

    return cleanResults;
  }


};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CompendiumHelper);


/***/ }),

/***/ 9771:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBCampaigns)
/* harmony export */ });
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8636);
/* harmony import */ var _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2449);
/* harmony import */ var _Secrets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2048);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5259);
/* harmony import */ var _DDBProxy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(546);







class DDBCampaigns {


  static getCampaignId() {
    const campaignId = game.settings.get("ddb-importer", "campaign-id").split("/").pop();

    if (campaignId && campaignId !== "" && !Number.isInteger(parseInt(campaignId))) {
      _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].munchNote */ .Z.munchNote(`Campaign Id is invalid! Set to "${campaignId}", using empty string`, true);
      _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error(`Campaign Id is invalid! Set to "${campaignId}", using empty string`);
      return "";
    } else if (campaignId.includes("join")) {
      _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].munchNote */ .Z.munchNote(`Campaign URL is a join campaign link, using empty string! Set to "${campaignId}"`, true);
      _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error(`Campaign URL is a join campaign link, using empty string! Set to "${campaignId}"`);
      return "";
    }
    return campaignId;
  }

  static getDDBCampaigns(cobalt = null) {
    const cobaltCookie = cobalt ? cobalt : (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_2__/* .getCobalt */ .HF)();
    const parsingApi = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getProxy */ .Z.getProxy();
    const betaKey = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getPatreonKey */ .Z.getPatreonKey();
    const body = { cobalt: cobaltCookie, betaKey: betaKey };

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/proxy/campaigns`, {
        method: "POST",
        cache: "no-cache",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          if (data.success) {
            resolve(data.data);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error(`Campaign fetch failed, got the following message: ${data.message}`, data);
            resolve([]);
          }
        })
        .catch((error) => {
          _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error(`Cobalt cookie check error`);
          _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error(error);
          _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error(error.stack);
          reject(error);
        });
    });

  }

  static async refreshCampaigns(cobalt = null) {
    if (cobalt) {
      const results = await DDBCampaigns.getDDBCampaigns(cobalt);
      CONFIG.DDBI.CAMPAIGNS = results;
    }
    return CONFIG.DDBI.CAMPAIGNS;
  }

  static async getAvailableCampaigns() {
    if (CONFIG.DDBI.CAMPAIGNS) return CONFIG.DDBI.CAMPAIGNS;
    // eslint-disable-next-line require-atomic-updates
    CONFIG.DDBI.CAMPAIGNS = [];
    const campaignId = DDBCampaigns.getCampaignId();
    const campaigns = await DDBCampaigns.getDDBCampaigns();

    if (!campaigns || campaigns.length === 0) {
      if (campaignId && campaignId.trim() !== "") {
        // eslint-disable-next-line require-atomic-updates
        CONFIG.DDBI.CAMPAIGNS = [
          {
            id: campaignId,
            name: "Unable to fetch campaigns, showing only selected",
            dmUsername: campaignId,
          }
        ];
      }
    } else if (campaigns && campaigns.length > 0) {
      // eslint-disable-next-line require-atomic-updates
      CONFIG.DDBI.CAMPAIGNS = campaigns;
    }

    CONFIG.DDBI.CAMPAIGNS.forEach((campaign) => {
      const selected = parseInt(campaign.id) === parseInt(campaignId);
      campaign.selected = selected;
    });

    return CONFIG.DDBI.CAMPAIGNS;
  }

}


/***/ }),

/***/ 819:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBCompendiumFolders)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3893);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);





class DDBCompendiumFolders {
  resetFolderLookups() {
    this.rootItemFolders = {};
    this.equipmentFolders = {};
    this.weaponFolders = {};
    this.trinketFolders = {};
    this.consumableFolders = {};
    this.lootFolders = {};
    this.toolFolders = {};
    this.containerFolders = {};
    this.validFolderIds = [];
    this.classFolders = {};
    this.subClassFolders = {};
    this.raceFolders = {};
    this.subRaceFolders = {};
    this.traitFolders = {};
    this.traitSubFolders = {};
    this.summonFolders = {};
    this.summonSubFolders = {};
  }

  constructor(type, packName) {
    this.type = type;
    this.packName = packName;
    this.resetFolderLookups();

    this.entityTypes = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].entityMap */ .Z.entityMap();
    this.entityType = this.entityTypes.get(type);

    // this.monsterFolders = {};
    // this.spellFolders = {};
    // this.itemFolders = {};

    this.compendiumFolderTypeMonster = game.settings.get("ddb-importer", "munching-selection-compendium-folders-monster");
    this.compendiumFolderTypeSpell = game.settings.get("ddb-importer", "munching-selection-compendium-folders-spell");
    this.compendiumFolderTypeItem = game.settings.get("ddb-importer", "munching-selection-compendium-folders-item");

  }

  async addCompendiumFolderIds(documents) {
    const results = documents.map(async (d) => {
      const folderId = await this.getFolderId(d);
      // eslint-disable-next-line require-atomic-updates
      if (folderId) d.folder = folderId;
      return d;
    });
    return Promise.all(results);
  }

  async loadCompendium(type = null) {
    if (type) {
      this.packName = await _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(type);
      this.entityType = this.entityTypes.get(type);
    }
    this.compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendium */ .Z.getCompendium(this.packName);
    await this.createCompendiumFolders();
  }

  async createCompendiumFolder({ name, parentId = null, color = "#6f0006", folderId = null, flagTag = "" } = {}) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Finding folder", {
      folders: this.compendium.folders,
      parentId,
    });
    const existingFolder = this.compendium.folders.find((f) =>
      f.name === name
      && flagTag === f.flags?.ddbimporter?.flagTag
      && (parentId === null
        || (parentId === f.folder?._id)
      )
    );
    if (existingFolder) return existingFolder;

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Creating folder", {
      folders: this.compendium.folders,
      parentId,
    });

    const newFolder = await Folder.create({
      _id: folderId,
      name,
      color,
      type: this.entityType,
      folder: parentId,
      flags: {
        ddbimporter: {
          flagTag,
        },
      }
    }, { pack: this.packName, keepId: true });

    return newFolder;
  }

  async createCreatureTypeCompendiumFolders() {
    for (const monsterType of CONFIG.DDB.monsterTypes) {
      const folder = this.getFolder(monsterType.name)
        ?? (await this.createCompendiumFolder({ name: monsterType.name, color: "#6f0006" }));
      this.validFolderIds.push(folder._id);
    }
  }

  async createAlphabeticalCompendiumFolders() {
    for (let i = 9; ++i < 36;) {
      const folderName = i.toString(36).toUpperCase();
      const folder = this.getFolder(folderName)
        ?? (await this.createCompendiumFolder({ name: folderName, color: "#6f0006" }));
      this.validFolderIds.push(folder._id);
    }
  }

  async createChallengeRatingCompendiumFolders() {
    for (const cr of CONFIG.DDB.challengeRatings) {
      const paddedCR = String(cr.value).padStart(2, "0");
      const folder = this.getFolder(`CR ${paddedCR}`)
        ?? (await this.createCompendiumFolder({ name: `CR ${paddedCR}`, color: "#6f0006" }));
      this.validFolderIds.push(folder._id);
    }
  }

  // spell level
  async createSpellLevelCompendiumFolders() {
    for (const levelName of _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.SPELL_LEVEL */ .Z.COMPENDIUM_FOLDERS.SPELL_LEVEL) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for folder '${levelName}'`);
      const folder = this.getFolder(levelName)
        ?? (await this.createCompendiumFolder({ name: levelName }));
      this.validFolderIds.push(folder._id);
    }
  }

  // spell school
  async createSpellSchoolCompendiumFolders() {
    for (const school of _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].spell.schools */ .Z.spell.schools) {
      const schoolName = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].capitalize */ .Z.capitalize(school.name);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for folder '${schoolName}'`);
      const folder = this.getFolder(schoolName)
        ?? (await this.createCompendiumFolder({ name: schoolName }));
      this.validFolderIds.push(folder._id);
    }
  }

  // item rarity folder
  async createItemRarityCompendiumFolders() {
    for (const rarityName of _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.RARITY */ .Z.COMPENDIUM_FOLDERS.RARITY) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for folder '${rarityName}'`);
      const folder = this.getFolder(rarityName, rarityName)
        ?? (await this.createCompendiumFolder({ name: rarityName, flagTag: rarityName }));
      this.validFolderIds.push(folder._id);
    }
  }

  // item type folder
  async createItemTypeCompendiumFolders() {
    for (const [key, folderName] of Object.entries(_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.ITEM_ROOT */ .Z.COMPENDIUM_FOLDERS.ITEM_ROOT)) {
      const flagTag = folderName;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for root folder '${folderName}' with key '${key}'`);
      const folder = this.getFolder(folderName, flagTag)
        ?? (await this.createCompendiumFolder({ name: folderName, flagTag: folderName }));
      this.rootItemFolders[key] = folder;
      this.validFolderIds.push(folder._id);
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Root item folders", this.rootItemFolders);

    for (const [key, folderName] of Object.entries(_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.EQUIPMENT */ .Z.COMPENDIUM_FOLDERS.EQUIPMENT)) {
      const flagTag = `equipment/${folderName}`;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Equipment folder '${folderName}' with key '${key}'`);

      const folder = this.getFolder(folderName, flagTag)
        ?? (await this.createCompendiumFolder({ name: folderName, parentId: this.rootItemFolders["equipment"]._id, color: "#222222", flagTag }));
      this.equipmentFolders[key] = folder;
      this.validFolderIds.push(folder._id);
    }

    for (const [key, folderName] of Object.entries(_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.WEAPON */ .Z.COMPENDIUM_FOLDERS.WEAPON)) {
      const flagTag = `weapon/${folderName}`;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Weapon folder '${folderName}' with key '${key}'`);
      const folder = this.getFolder(folderName, flagTag)
        ?? (await this.createCompendiumFolder({ name: folderName, parentId: this.rootItemFolders["weapon"]._id, color: "#222222", flagTag }));
      this.weaponFolders[key] = folder;
      this.validFolderIds.push(folder._id);
    }

    for (const [key, folderName] of Object.entries(_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.TOOLS */ .Z.COMPENDIUM_FOLDERS.TOOLS)) {
      const flagTag = `tool/${folderName}`;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Tool folder '${folderName}' with key '${key}'`);
      const folder = this.getFolder(folderName, flagTag)
        ?? (await this.createCompendiumFolder({ name: folderName, parentId: this.rootItemFolders["tool"]._id, color: "#222222", flagTag }));
      this.toolFolders[key] = folder;
      this.validFolderIds.push(folder._id);
    }

    for (const folderName of _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.TRINKET */ .Z.COMPENDIUM_FOLDERS.TRINKET) {
      const flagTag = `trinket/${folderName}`;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Equipment\\Trinket folder '${folderName}'`);
      const folder = this.getFolder(folderName, flagTag)
       ?? (await this.createCompendiumFolder({ name: folderName, parentId: this.equipmentFolders["trinket"]._id, color: "#444444", flagTag }));
      this.trinketFolders[folderName] = folder;
      this.validFolderIds.push(folder._id);
    }

    for (const folderName of _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.CONSUMABLE */ .Z.COMPENDIUM_FOLDERS.CONSUMABLE) {
      const flagTag = `consumable/${folderName}`;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Consumable folder '${folderName}'`);
      const folder = this.getFolder(folderName, flagTag)
       ?? (await this.createCompendiumFolder({ name: folderName, parentId: this.rootItemFolders["consumable"]._id, color: "#222222", flagTag }));
      this.consumableFolders[folderName] = folder;
      this.validFolderIds.push(folder._id);
    }

    for (const folderName of _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.LOOT */ .Z.COMPENDIUM_FOLDERS.LOOT) {
      const flagTag = `loot/${folderName}`;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Loot folder '${folderName}'`);
      const folder = this.getFolder(folderName, flagTag)
       ?? (await this.createCompendiumFolder({ name: folderName, parentId: this.rootItemFolders["loot"]._id, color: "#222222", flagTag }));
      this.lootFolders[folderName] = folder;
      this.validFolderIds.push(folder._id);
    }

    for (const folderName of _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.CONTAINER */ .Z.COMPENDIUM_FOLDERS.CONTAINER) {
      const flagTag = `container/${folderName}`;
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Container folder '${folderName}'`);
      const folder = this.getFolder(folderName, flagTag)
        ?? (await this.createCompendiumFolder({ name: folderName, parentId: this.rootItemFolders["container"]._id, color: "#222222", flagTag }));
      this.containerFolders[folderName] = folder;
      this.validFolderIds.push(folder._id);
    }
  }

  async createClassFeatureFolders(includeOptions = true) {
    const classNames = CONFIG.DDB.classConfigurations
      .filter((c) => !c.name.includes("archived") && !c.name.includes("(UA)"))
      .map((c) => c.name);

    for (const className of classNames) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for class folder '${className}'`);
      const folder = this.getFolder(className)
        ?? (await this.createCompendiumFolder({ name: className }));
      this.validFolderIds.push(folder._id);
      this.classFolders[className] = folder;
      if (includeOptions) {
        const flagTag = `optional/${className}`;
        const optionalFolder = this.getFolder("Optional Features", flagTag)
          ?? (await this.createCompendiumFolder({ name: "Optional Features", parentId: folder._id, color: "#222222", flagTag }));
        this.validFolderIds.push(optionalFolder._id);
      }
      if (includeOptions && className === "Artificer") {
        const flagTag = `infusions/Artificer`;
        const infusionsFolder = this.getFolder("Infusions", flagTag)
          ?? (await this.createCompendiumFolder({ name: "Infusions", parentId: folder._id, color: "#222222", flagTag }));
        this.validFolderIds.push(infusionsFolder._id);
      }
    }
  }

  async createSubClassFeatureFolder(subclassName, parentClassName) {
    const flagTag = `subclass/${subclassName}`;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Subclass folder '${subclassName}' with Parent Class '${parentClassName}'`);

    const folder = this.getFolder(subclassName, flagTag)
      ?? (await this.createCompendiumFolder({
        name: subclassName,
        parentId: this.classFolders[parentClassName]._id,
        color: "#222222",
        flagTag,
      }));
    this.subClassFolders[subclassName] = folder;
    this.validFolderIds.push(folder._id);
  }

  async getRacialBaseFolder(type, baseRaceName) {
    const folderType = type.includes("trait") ? "traitFolders" : "raceFolders";
    const flagType = type.includes("trait") ? "trait" : "race";
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for race folder '${baseRaceName}'`);
    const existingFolder = this.getFolder(baseRaceName, `${flagType}/${baseRaceName}`);
    if (existingFolder) return existingFolder;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Not found, creating race folder '${baseRaceName}'`);
    const newFolder = await this.createCompendiumFolder({
      name: baseRaceName,
      flagTag: `${flagType}/${baseRaceName}`,
    });
    this.validFolderIds.push(newFolder._id);
    this[folderType][baseRaceName] = newFolder;
    return newFolder;
  }

  async createBaseRacialFolders(type) {
    const raceNames = CONFIG.DDB.raceGroups.map((c) => c.name);
    for (const raceName of raceNames) {
      await this.getRacialBaseFolder(type, raceName);
    }
  }

  async createSubTraitFolders(baseRaceName, fullRaceName) {
    const flagTag = `trait/${baseRaceName}/${fullRaceName}`;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Race folder '${fullRaceName}' with Base Race '${baseRaceName}'`);

    const parentFolder = await this.getRacialBaseFolder("trait", baseRaceName);

    const folder = this.getFolder(fullRaceName, flagTag)
      ?? (await this.createCompendiumFolder({
        name: fullRaceName,
        parentId: parentFolder._id,
        color: "#222222",
        flagTag,
      }));
    this.traitSubFolders[fullRaceName] = folder;
    this.validFolderIds.push(folder._id);
  }

  async createSummonsFolder(type) {
    const flagTag = `summons/${type}`;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Summons folder '${type}'`);
    const existingFolder = this.getFolder(type, flagTag);
    if (existingFolder) return existingFolder;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Not found, creating summons folder '${type}'`);
    const newFolder = await this.createCompendiumFolder({
      name: type,
      flagTag,
    });
    this.validFolderIds.push(newFolder._id);
    this.summonFolders[type] = newFolder;
    return newFolder;
  }

  async createSummonsSubFolder(type, subFolderName) {
    const flagTag = `summons/${type}/${subFolderName}`;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for Summons folder '${subFolderName}' with Base Folder '${subFolderName}'`);

    const parentFolder = await this.createSummonsFolder(type);

    const folder = this.getFolder(subFolderName, flagTag)
      ?? (await this.createCompendiumFolder({
        name: subFolderName,
        parentId: parentFolder._id,
        color: "#222222",
        flagTag,
      }));
    this.summonSubFolders[subFolderName] = folder;
    this.validFolderIds.push(folder._id);
  }

  // eslint-disable-next-line complexity
  async createCompendiumFolders() {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking and creating Compendium folder structure for ${this.type}`);

    this.resetFolderLookups();

    switch (this.type) {
      case "race":
      case "races": {
        // we create these as needed
        // this.createBaseRacialFolders("race");
        break;
      }
      case "trait":
      case "traits": {
        // we create these as needed
        // this.createBaseRacialFolders("trait");
        break;
      }
      case "summons":
      case "summon": {
        // we create these as needed
        // this.createBaseSummonFolders("summon");
        break;
      }
      case "monsters":
      case "npc":
      case "monster": {
        switch (this.compendiumFolderTypeMonster) {
          case "TYPE": {
            await this.createCreatureTypeCompendiumFolders();
            break;
          }
          case "ALPHA": {
            await this.createAlphabeticalCompendiumFolders();
            break;
          }
          case "CR": {
            await this.createChallengeRatingCompendiumFolders();
            break;
          }
          // no default
        }
        break;
      }
      case "spell":
      case "spells": {
        switch (this.compendiumFolderTypeSpell) {
          case "SCHOOL":
            await this.createSpellSchoolCompendiumFolders();
            break;
          case "LEVEL":
            await this.createSpellLevelCompendiumFolders();
            break;
          // no default
        }
        break;
      }
      case "inventory":
      case "item":
      case "items": {
        switch (this.compendiumFolderTypeItem) {
          case "TYPE":
            await this.createItemTypeCompendiumFolders();
            break;
          case "RARITY":
            await this.createItemRarityCompendiumFolders();
            break;
          // no default
        }
        break;
      }
      case "features": {
        await this.createClassFeatureFolders();
        break;
      }
      case "subclass":
      case "subclasses": {
        await this.createClassFeatureFolders(false);
        break;
      }
      // no default
    }
    return this.compendium.folders;
  }

  static getItemCompendiumFolderNameForRarity(document) {
    let name;
    const rarity = document.system.rarity;

    if (rarity && rarity != "") {
      switch (rarity.toLowerCase().trim()) {
        case "common":
          name = "Common";
          break;
        case "uncommon":
          name = "Uncommon";
          break;
        case "rare":
          name = "Rare";
          break;
        case "very rare":
        case "veryrare":
          name = "Very Rare";
          break;
        case "legendary":
          name = "Legendary";
          break;
        case "artifact":
          name = "Artifact";
          break;
        case "varies":
          name = "Varies";
          break;
        case "unknown":
        default:
          name = "Unknown";
          break;
      }
    } else {
      name = "Unknown";
    }
    return { name, flagTag: name };
  }

  getItemCompendiumFolderNameForType(document) {
    const result = {
      name: undefined,
      flagTag: "",
    };

    switch (document.type) {
      case "dnd-tashas-cauldron.tattoo":
      case "tattoo": {
        const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
        result.name = this.trinketFolders[ddbType].name;
        result.flagTag = `trinket/${result.name}`;
        break;
      }
      case "equipment": {
        switch (document.system?.type?.value) {
          case "trinket": {
            const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
            const isContainer = foundry.utils.getProperty(document, "flags.ddbimporter.dndbeyond.isContainer") === true;
            result.name = isContainer
              ? this.containerFolders[ddbType].name
              : this.trinketFolders[ddbType].name;
            result.flagTag = isContainer
              ? `container/${result.name}`
              : `trinket/${result.name}`;
            break;
          }
          default: {
            result.name = this.equipmentFolders[document.system.type.value].name;
            result.flagTag = `equipment/${result.name}`;
            break;
          }
        }
        break;
      }
      case "weapon": {
        result.name = this.weaponFolders[document.system.type.value].name;
        result.flagTag = `weapon/${result.name}`;
        break;
      }
      case "consumable": {
        const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
        if (ddbType) {
          result.name = this.consumableFolders[ddbType].name;
          result.flagTag = `consumable/${result.name}`;
        }
        break;
      }
      case "loot": {
        const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
        if (ddbType) {
          result.name = this.lootFolders[ddbType].name;
          result.flagTag = `loot/${result.name}`;
        }
        break;
      }
      case "container": {
        const ddbType = document.flags?.ddbimporter?.dndbeyond?.type;
        if (ddbType) {
          result.name = this.containerFolders[ddbType].name;
          result.flagTag = `container/${result.name}`;
        }
        break;
      }
      case "tool": {
        const toolType = document.system.type.value;
        const instrument = document.flags?.ddbimporter?.dndbeyond?.tags.includes("Instrument");
        const ddbType = ["art", "music", "game"].includes(toolType);
        if (instrument) {
          result.name = this.toolFolders["music"].name;
          result.flagTag = `tool/${result.name}`;
        } else if (ddbType) {
          result.name = this.toolFolders[toolType].name;
          result.flagTag = `tool/${result.name}`;
        } else {
          result.name = this.rootItemFolders[document.type].name;
          result.flagTag = `Tools`;
        }

        break;
      }
      default: {
        result.name = this.rootItemFolders[document.type].name;
        result.flagTag = `${result.name}`;
        break;
      }
    }

    return result;
  }

  getItemCompendiumFolderName(document) {
    let name;
    switch (this.compendiumFolderTypeItem) {
      case "RARITY": {
        name = DDBCompendiumFolders.getItemCompendiumFolderNameForRarity(document);
        break;
      }
      case "TYPE": {
        name = this.getItemCompendiumFolderNameForType(document);
        break;
      }
      // no default
    }
    return name;
  }

  // eslint-disable-next-line class-methods-use-this
  getClassFeatureFolderName(document) {
    const result = {
      name: undefined,
      flagTag: "",
    };
    const subClassName = foundry.utils.getProperty(document, "flags.ddbimporter.subClass");
    const className = foundry.utils.getProperty(document, "flags.ddbimporter.class");
    const optional = foundry.utils.getProperty(document, "flags.ddbimporter.optionalFeature");
    const infusion = foundry.utils.getProperty(document, "flags.ddbimporter.infusionFeature");
    if (infusion) {
      result.name = "Infusions";
      result.flagTag = `infusions/${className}`;
    } else if (optional) {
      result.name = "Optional Features";
      result.flagTag = `optional/${className}`;
    } else if (subClassName && subClassName.trim() !== "") {
      result.name = subClassName;
      result.flagTag = `subclass/${subClassName}`;
    } else if (className && className.trim() !== "") {
      result.name = className;
    } else {
      result.name = "Unknown";
    }

    if (result.name) return result;
    else return undefined;
  }

  // eslint-disable-next-line class-methods-use-this
  getRaceTraitFolderName(document) {
    const result = {
      name: undefined,
      flagTag: "",
    };
    // "flags.ddbimporter.baseRaceName",
    // "flags.ddbimporter.baseName",
    // "flags.ddbimporter.subRaceShortName",
    // "flags.ddbimporter.isSubRace",
    // const isSubRace = foundry.utils.getProperty(document, "flags.ddbimporter.isSubRace");
    // const baseRaceName = foundry.utils.getProperty(document, "flags.ddbimporter.baseRaceName");
    // const baseName = foundry.utils.getProperty(document, "flags.ddbimporter.baseName");
    // const subRaceShortName = foundry.utils.getProperty(document, "flags.ddbimporter.subRaceShortName");
    const fullRaceName = foundry.utils.getProperty(document, "flags.ddbimporter.fullRaceName");
    // const name = document.name;
    // const lowercaseName = name.toLowerCase();

    const groupName = foundry.utils.getProperty(document, "flags.ddbimporter.groupName");

    result.name = fullRaceName;
    result.flagTag = `trait/${groupName}/${fullRaceName}`;

    return result;
  }

  // eslint-disable-next-line class-methods-use-this
  getRaceFolderName(document) {
    const result = {
      name: undefined,
      flagTag: "",
    };

    const fullRaceName = foundry.utils.getProperty(document, "flags.ddbimporter.fullRaceName");
    const groupName = foundry.utils.getProperty(document, "flags.ddbimporter.groupName");
    result.name = groupName ?? fullRaceName;
    result.flagTag = `race/${(groupName ?? fullRaceName)}`;

    return result;
  }

  // eslint-disable-next-line class-methods-use-this
  getSummonFolderName(document) {
    const result = {
      name: undefined,
      flagTag: "",
    };

    const folderHint = foundry.utils.getProperty(document, "flags.ddbimporter.summons.folder");
    const summonHint = foundry.utils.getProperty(document, "flags.ddbimporter.summons.name");
    result.name = folderHint ?? summonHint ?? document.name;
    result.flagTag = `summon/${result.name}`;

    return result;
  }

  // eslint-disable-next-line class-methods-use-this
  getClassFolderName(document) {
    const result = {
      name: undefined,
      flagTag: "",
    };
    const className = foundry.utils.getProperty(document, "flags.ddbimporter.class");
    if (className && className.trim() !== "") {
      result.name = className;
    } else {
      result.name = "Unknown";
    }

    if (result.name) return result;
    else return undefined;
  }

  // eslint-disable-next-line complexity
  getCompendiumFolderName(document) {
    let name;
    switch (this.type) {
      case "trait":
      case "traits": {
        name = this.getRaceTraitFolderName(document);
        break;
      }
      case "race":
      case "races": {
        name = this.getRaceFolderName(document);
        break;
      }
      case "feature":
      case "features": {
        name = this.getClassFeatureFolderName(document);
        break;
      }
      case "subclass":
      case "subclasses": {
        name = this.getClassFolderName(document);
        break;
      }
      case "summon":
      case "summons": {
        name = this.getSummonFolderName(document);
        break;
      }
      case "monsters":
      case "npc":
      case "monster": {
        switch (this.compendiumFolderTypeMonster) {
          case "TYPE": {
            const creatureType = document.system?.details?.type?.value
              ? document.system?.details?.type?.value
              : "Unknown";
            const ddbType = CONFIG.DDB.monsterTypes.find((c) => creatureType.toLowerCase() == c.name.toLowerCase());
            if (ddbType) name = ddbType.name;
            break;
          }
          case "ALPHA": {
            name = document.name
              .replace(/[^a-z]/gi, "")
              .charAt(0)
              .toUpperCase();
            break;
          }
          case "CR": {
            if (document.system.details.cr !== undefined || document.system.details.cr !== "") {
              const paddedCR = String(document.system.details.cr).padStart(2, "0");
              name = `CR ${paddedCR}`;
            }
          }
          // no default
        }
        break;
      }
      case "spell":
      case "spells": {
        switch (this.compendiumFolderTypeSpell) {
          case "SCHOOL": {
            const school = document.system?.school;
            if (school) {
              name = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].capitalize */ .Z.capitalize(_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].spell.schools.find */ .Z.spell.schools.find((sch) => school == sch.id).name);
            }
            break;
          }
          case "LEVEL": {
            const levelFolder = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].COMPENDIUM_FOLDERS.SPELL_LEVEL */ .Z.COMPENDIUM_FOLDERS.SPELL_LEVEL[document.system?.level];
            if (levelFolder) {
              name = levelFolder;
            }
            break;
          }
          // no default
        }
        break;
      }
      case "inventory":
      case "item":
      case "items": {
        name = this.getItemCompendiumFolderName(document);
      }
      // no default
    }
    return name;
  }

  getFolder(folderName, flagTag = "") {
    const folder = this.compendium.folders.find((f) =>
      f.name == folderName
      && f.flags?.ddbimporter?.flagTag === flagTag
    );
    return folder;
  }

  getFolderId(document) {
    const folderName = this.getCompendiumFolderName(document);
    if (folderName) {
      const folder = this.getFolder((folderName.name ?? folderName), (folderName.flagTag ?? ""));
      if (folder) return folder._id;
    }

    return undefined;
  }

  async addToCompendiumFolder(document) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking ${document.name} in ${this.packName}`);

    const folderName = this.getCompendiumFolderName(document);
    if (folderName) {
      const folder = this.compendium.folders.find((f) => f.name == (folderName.name ?? folderName));
      if (folder) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Moving ${this.type} ${document.name} to folder ${folder.name}`);
        await document.update({ folder: folder._id });
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unable to find folder "${folderName}" in "${this.packName}" for ${this.type}`);
      }
    }
  }


  #getIndexFields() {
    switch (this.type) {
      case "spells":
      case "spell": {
        return [
          "name",
          "system.level",
          "system.school",
        ];
      }
      case "inventory":
      case "items":
      case "item": {
        return [
          "name",
          "type",
          "flags.ddbimporter.dndbeyond.type",
          "flags.ddbimporter.dndbeyond.tags",
          "system.armor.type",
          "system.type.value",
          "system.rarity",
          "system.type.value",
          "system.details.type.value",
        ];
      }
      case "monster":
      case "monsters": {
        return [
          "name",
          "type",
          "system.details.type.value",
          "system.details.cr",
        ];
      }
      case "summon":
      case "summons": {
        return [
          "name",
          "type",
          "flags.ddbimporter.summons.name",
          "flags.ddbimporter.summons.folder",
        ];
      }
      case "class":
      case "subclass":
      case "classes":
      case "subclasses":
      case "feature": {
        return [
          "name",
          "flags.ddbimporter.class",
          "flags.ddbimporter.subClass",
          "flags.ddbimporter.optionalFeature",
          "flags.ddbimporter.infusionFeature",
        ];
      }
      case "trait":
      case "traits":
      case "race":
      case "races": {
        return [
          "name",
          "flags.ddbimporter.baseRaceName",
          "flags.ddbimporter.baseName",
          "flags.ddbimporter.subRaceShortName",
          "flags.ddbimporter.isSubRace",
          "flags.ddbimporter.fullRaceName",
          "flags.ddbimporter.groupName"
        ];
      }
      default:
        return ["name"];
    }
  }

  // eslint-disable-next-line complexity
  async migrateExistingCompendium() {
    if (!this.compendium) return undefined;

    const foldersToRemove = this.compendium.folders.filter((f) => !this.validFolderIds.includes(f._id));
    await Folder.deleteDocuments(foldersToRemove.map((f) => f._id), { pack: this.packName });

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Remaining Compendium Folders", this.compendium.folders);

    const index = await this.compendium.getIndex({ fields: this.#getIndexFields() });

    const results = [];
    for (const i of index) {
      const folderId = this.getFolderId(i);
      if (folderId) {
        results.push({
          _id: i._id,
          folder: folderId,
        });
      }
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Folder update results", results);

    switch (this.type) {
      case "trait":
      case "traits":
      case "race":
      case "races":
      case "features":
      case "feature":
      case "class":
      case "classes":
      case "subclass":
      case "subclasses":
      case "inventory":
      case "items":
      case "item":
      case "spells":
      case "spell": {
        await Item.updateDocuments(results, { pack: this.packName });
        break;
      }
      case "summon":
      case "summons":
      case "monsters":
      case "npc":
      case "monster": {
        await Actor.updateDocuments(results, { pack: this.packName });
        break;
      }
      // no default
    }


    return this.compendium.folders;
  }

  async removeUnusedFolders() {
    const folderIds = this.compendium.folders
      .filter((c) => c.contents.length === 0 && c.children.length === 0)
      .map((f) => f.id);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Deleting compendium folders", folderIds);
    await Folder.deleteDocuments(folderIds, { pack: this.packName });
  }
}


/***/ }),

/***/ 1438:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _effects_effects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5751);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);





const DDBHelper = {

  getBookName: (bookId) => {
    const book = CONFIG.DDB.sources.find((source) => source.name.toLowerCase() == bookId.toLowerCase());
    if (book) {
      return book.description;
    } else {
      return "";
    }
  },

  getDamageType: (data) => {
    if (data.definition.damageType) {
      const damageTypeReplace = data.definition.grantedModifiers.find((mod) =>
        mod.type === "replace-damage-type"
        && (!mod.restriction || mod.restriction === "")
      );

      const damageType = damageTypeReplace
        ? damageTypeReplace.subType.toLowerCase()
        : data.definition.damageType.toLowerCase();
      return damageType;
    } else {
      return undefined;
    }
  },

  globalDamageTagInfo: (mod) => {
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
    const midiInstalled = game.modules.get("midi-qol")?.active;
    const damageRestrictionHints = game.settings.get("ddb-importer", "add-damage-restrictions-to-hints") && !midiInstalled;
    const hintOrRestriction = globalDamageHints || damageRestrictionHints;
    const restriction = damageRestrictionHints && mod.restriction && mod.restriction !== "" ? mod.restriction : "";
    const hintAndRestriction = globalDamageHints && restriction !== "" ? " - " : "";

    return {
      globalDamageHints,
      damageRestrictionHints,
      hintOrRestriction,
      hintAndRestriction,
      restriction,
    };
  },

  getDamageTag(mod, overrideDamageType) {
    const damageTagData = DDBHelper.globalDamageTagInfo(mod);
    const damageType = overrideDamageType
      ? overrideDamageType
      : mod.subType ? mod.subType : "";
    const hintTag = damageType !== "" && damageTagData.globalDamageHints ? damageType : "";
    const damageHint = damageTagData.hintOrRestriction
      ? `${hintTag}${damageTagData.hintAndRestriction}${damageTagData.restriction}`
      : "";
    const damageTag = damageTagData.hintOrRestriction ? `[${damageHint}]` : "";
    return {
      globalDamageHints: damageTagData.globalDamageHints,
      damageRestrictionHints: damageTagData.damageRestrictionHints,
      hintOrRestriction: damageTagData.hintOrRestriction,
      hintAndRestriction: damageTagData.hintAndRestriction,
      restriction: damageTagData.restriction,
      damageType,
      damageHint,
      damageTag,
    };
  },

  getDamageTagForMod: (mod) => {
    const damageTagData = DDBHelper.getDamageTag(mod);
    return damageTagData;
  },

  getDamageTagForItem(data) {
    const damageType = DDBHelper.getDamageType(data);
    const damageTagData = DDBHelper.getDamageTag({}, damageType);
    return damageTagData;
  },

  hasChosenCharacterOption: (ddb, optionName) => {
    const hasClassOptions = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]
      .flat()
      .some((option) => option.definition.name === optionName);
    return hasClassOptions;
  },

  getClassFromOptionID: (ddb, optionId) => {
    // Use case class spell - which class?
    // componentId on spells.class[0].componentId = options.class[0].definition.id
    // options.class[0].definition.componentId = classes[0].classFeatures[0].definition.id
    const option = ddb.character.options.class.find((option) => option.definition.id === optionId);

    if (option) {
      const klass = ddb.character.classes.find((klass) =>
        klass.classFeatures.some((feature) => feature.definition.id === option.componentId)
      );
      return klass;
    }
    return undefined;
  },

  /**
   * Look up a component by id
   * For now we assume that most features we are going to want to get a scaling value
   * from are character options
   * @param {*} ddb
   * @param {*} featureId
   */

  findComponentByComponentId: (ddb, componentId) => {
    let result;

    ddb.character.classes.forEach((cls) => {
      const feature = cls.classFeatures.find((component) => component.definition.id === componentId);
      if (feature) result = feature;
    });

    const optionalClassFeature = ddb.classOptions.find((option) => option.id == componentId);
    if (optionalClassFeature && !result) {
      result = optionalClassFeature;
      const optionalLevelScales = optionalClassFeature.levelScales && optionalClassFeature.levelScales.length > 0;
      if (result && !result.levelScale && optionalLevelScales) {
        const klass = ddb.character.classes.find((cls) => cls.definition.id === optionalClassFeature.classId);
        const klassLevel = klass ? klass.level : undefined;
        if (klassLevel) {
          const levelFilteredScales = optionalClassFeature.levelScales.filter((scale) => scale.level <= klassLevel);
          if (levelFilteredScales.length > 0) {
            result.levelScale = levelFilteredScales
              .reduce((previous, current) => {
                if (previous.level > current.level) return previous;
                return current;
              });
          }
        }
      }
    }

    return result;
  },

  /**
 * Gets the levelscaling value for a feature
 * @param {*} feature
 */
  getExactScalingValue: (feature) => {
    const die = feature.levelScale?.dice ? feature.levelScale.dice : feature.levelScale?.die ? feature.levelScale.die : undefined;
    if (feature && feature.levelScale && feature.levelScale.fixedValue) {
      return feature.levelScale.fixedValue;
    } else if (die) {
      return die.diceString;
    } else {
      return "{{scalevalue-unknown}}";
    }
  },

  getScaleValueLink: (ddb, feature) => {
    const featDefinition = feature.definition ? feature.definition : feature;

    const klass = ddb.character.classes.find((cls) =>
      (cls.definition.id === featDefinition.classId
      || cls.subclassDefinition?.id === featDefinition.classId)
      && featDefinition.levelScales?.length > 0
    );

    if (klass) {
      const featureName = featDefinition.name.toLowerCase().replace(/\s|'|/g, '-');
      const klassName = klass.subclassDefinition?.id === featDefinition.classId
        ? klass.subclassDefinition.name.toLowerCase().replace(/\s|'|/g, '-')
        : klass.definition.name.toLowerCase().replace(/\s|'|/g, '-');
      return `@scale.${klassName}.${featureName}`;
    }

    return undefined;

  },

  getScaleValueString: (ddb, feature) => {
    const classOption = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]
      .flat()
      .find((option) => option.definition.id === feature.componentId);

    let feat = feature.levelScale ? feature : DDBHelper.findComponentByComponentId(ddb, feature.componentId);
    if (!feat && foundry.utils.hasProperty(feature, "flags.ddbimporter.dndbeyond.choice")) {
      feat = DDBHelper.findComponentByComponentId(ddb, feature.flags.ddbimporter.dndbeyond.choice.componentId);
    }
    if (!feat && classOption) {
      feat = DDBHelper.findComponentByComponentId(ddb, classOption.componentId);
    }
    if (!feat) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("no scale value for ", feature);
      return { name: undefined, value: undefined };
    }
    const scaleValue = DDBHelper.getScaleValueLink(ddb, feat);
    if (scaleValue) {
      return {
        name: feat.definition?.name ? feat.definition?.name : feat.name,
        value: scaleValue,
      };
    }
    // final fallback if scale value extraction fails
    return {
      name: feat.definition?.name ? feat.definition?.name : feat.name,
      value: DDBHelper.getExactScalingValue(feat),
    };
  },

  /**
   *
   * Gets the sourcebook for a subset of dndbeyond sources
   * @param {obj} definition item definition
   */
  // eslint-disable-next-line complexity
  getSourceData: (definition) => {
    const fullSource = game.settings.get("ddb-importer", "use-full-source");
    const results = [];
    if (definition.sources?.length > 0) {
      // is basic rules (e.g. SRD)
      const basicRules = definition.sources.some((source) => source.sourceType === 2 && source.sourceId === 1);
      const hasPage = definition.sources.some((source) => source.pageNumber !== null);
      const sources = hasPage
        ? definition.sources.filter((source) => source.pageNumber !== null)
        : basicRules
          ? definition.sources.filter((source) => source.sourceType === 2 && source.sourceId === 1)
          : definition.sources.some((source) => source.sourceType === 1)
            ? definition.sources.filter((source) => source.sourceType === 1)
            : definition.sources;
      for (const ds of sources) {
        const ddbSource = CONFIG.DDB.sources.find((ddb) => ddb.id === ds.sourceId);

        results.push({
          book: ddbSource ? (fullSource ? ddbSource.description : ddbSource.name) : "Homebrew",
          page: ds.pageNumber ?? "",
          license: "",
          custom: "",
          id: ddbSource ? ddbSource.id : 9999999,
        });
      }
    } else if (definition.sourceIds) {
      for (const sourceId of definition.sourceIds) {
        const ddbSource = CONFIG.DDB.sources.find((ddb) => ddb.id === sourceId);
        results.push({
          book: ddbSource ? (fullSource ? ddbSource.description : ddbSource.name) : "Homebrew",
          page: definition.sourcePageNumber ?? "",
          license: "",
          custom: "",
          id: ddbSource ? ddbSource.id : 9999999,
        });
      }
    } else if (definition.sourceId) {
      const ddbSource = CONFIG.DDB.sources.find((ddb) => ddb.id === definition.sourceId);
      results.push({
        book: ddbSource ? (fullSource ? ddbSource.description : ddbSource.name) : "Homebrew",
        page: definition.sourcePageNumber ?? "",
        license: "",
        custom: "",
        id: ddbSource ? ddbSource.id : 9999999,
      });
    }
    return results;
  },

  /**
   * Fetches the sources and pages for a definition
   * @param {obj} data item
   */
  parseSource: (definition) => {
    const sources = DDBHelper.getSourceData(definition);
    const latestSource = sources.length > 0
      ? sources.reduce((prev, current) => {
        return prev.id > current.id ? prev : current;
      })
      : null;

    if (!latestSource) return {
      name: "",
      page: "",
      license: "",
      custom: "",
    };
    delete latestSource.id;
    return latestSource;
  },

  getActiveItemModifiers: (ddb, includeExcludedEffects = false) => {
    // are we adding effects to items?
    const excludedModifiers = (!includeExcludedEffects) ? (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .getEffectExcludedModifiers */ .qk)("item", true, true) : [];
    // get items we are going to interact on
    const modifiers = ddb.character.inventory
      .filter(
        (item) =>
          ((!item.definition.canEquip && !item.definition.canAttune && !item.definition.isConsumable) // if item just gives a thing and not potion/scroll
          || (item.isAttuned && item.equipped) // if it is attuned and equipped
          || (item.isAttuned && !item.definition.canEquip) // if it is attuned but can't equip
            || (!item.definition.canAttune && item.equipped)) // can't attune but is equipped
          && item.definition.grantedModifiers.length > 0
      )
      .flatMap((item) => item.definition.grantedModifiers)
      .filter((mod) => !excludedModifiers.some((exMod) =>
        mod.type === exMod.type
        && (mod.subType === exMod.subType || !exMod.subType))
      );

    return modifiers;
  },

  getActiveItemEffectModifiers: (ddb) => {
    return DDBHelper.getActiveItemModifiers(ddb, true).filter((mod) =>
      (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .getEffectExcludedModifiers */ .qk)("item", true, true).some((exMod) => mod.type === exMod.type
      && (mod.subType === exMod.subType || !exMod.subType))
    );
  },

  getModifiers: (ddb, type, includeExcludedEffects = false, effectOnly = false, useUnfilteredModifiers = false) => {
    // are we adding effects to documents?
    const excludedModifiers = (!includeExcludedEffects || (includeExcludedEffects && effectOnly))
      ? (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .getEffectExcludedModifiers */ .qk)(type, true, true)
      : (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_2__/* .getEffectExcludedModifiers */ .qk)(type, false, false);
    // get items we are going to interact on
    let modifiers = [];
    const baseMods = useUnfilteredModifiers
      ? ddb.unfilteredModifiers[type]
      : ddb.character.modifiers[type];
    if (effectOnly) {
      modifiers = baseMods
        .filter((mod) => excludedModifiers.some((exMod) =>
          mod.type === exMod.type
        && (mod.subType === exMod.subType || !exMod.subType))
        );
    } else {
      modifiers = baseMods
        .filter((mod) => !excludedModifiers.some((exMod) =>
          mod.type === exMod.type
        && (mod.subType === exMod.subType || !exMod.subType))
        );
    }

    return modifiers;
  },

  filterModifiers: (modifiers, type, { subType = null, restriction = ["", null] } = {}) => {
    return modifiers
      .flat()
      .filter(
        (modifier) =>
          modifier.type === type
          && (subType !== null ? modifier.subType === subType : true)
          && (!restriction ? true : restriction.includes(modifier.restriction))
      );
  },

  filterModifiersOld: (modifiers, type, subType = null, restriction = ["", null]) => {
    return DDBHelper.filterModifiers(modifiers, type, { subType, restriction });
  },

  isComponentIdInClassFeatures: (ddb, componentId, classId) => {
    return ddb.character.classes
      .filter((klass) => classId === klass.definition?.id || classId === klass.subclassDefinition?.id)
      .some((klass) =>
        klass.classFeatures.some((feat) => feat.definition.id == componentId)
      );
  },

  getClassFeatureIds(ddb, { classId = null, requiredLevel = null, exactLevel = null } = {}) {
    return ddb.character.classes
      .filter((klass) =>
        (classId === null
          ? true
          : (classId === klass.definition?.id || classId === klass.subclassDefinition?.id))
      ).map((klass) => klass.classFeatures)
      .flat()
      .filter((feat) =>
        (requiredLevel === null || feat.definition.requiredLevel >= requiredLevel)
        && (exactLevel === null || feat.definition.requiredLevel == exactLevel)
      ).map((feat) => feat.definition.id);
  },

  isModClassFeature: (ddb, mod, { classFeatureIds = null, classId = null, requiredLevel = null, exactLevel = null } = {}) => {
    return ddb.character.classes.some((klass) =>
      (classId === null
        ? true
        : (classId === klass.definition?.id || classId === klass.subclassDefinition?.id))
      && klass.classFeatures.some((feat) =>
        feat.definition.id == mod.componentId
        && feat.definition.entityTypeId == mod.componentTypeId
        && (classFeatureIds === null || classFeatureIds.includes(feat.definition.id))
        && (requiredLevel === null || feat.definition.requiredLevel >= requiredLevel)
        && (exactLevel === null || feat.definition.requiredLevel == exactLevel)
        // make sure this class feature is not replaced
        && !ddb.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == feat.definition.id)
      ));
  },

  isModClassOption: (ddb, mod, { classFeatureIds = null, classId = null, requiredLevel = null, exactLevel = null } = {}) => {
    const klassFeatureIds = classFeatureIds ? classFeatureIds : DDBHelper.getClassFeatureIds(ddb, { classId, requiredLevel, exactLevel });
    return ddb.character.options.class.some((option) =>
      // is this option actually part of the class list?
      klassFeatureIds.includes(option.componentId)
      // does this class option match a modifier?
      && ((option.componentTypeId == mod.componentTypeId && option.componentId == mod.componentId)
      || (option.definition.entityTypeId == mod.componentTypeId && option.definition.id == mod.componentId))
      // has this feature set been replaced by an optional class feature?
      && !ddb.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == option.componentId)
      // has it been chosen?
      && (
        ddb.character.choices.class.some((choice) =>
          choice.componentId == option.componentId
          && choice.componentTypeId == option.componentTypeId
          && foundry.utils.hasProperty(choice, "optionValue")
        )
        || !ddb.character.choices.class.some((choice) =>
          choice.componentId == option.componentId
          && choice.componentTypeId == option.componentTypeId)
      )
    );
  },

  isModOptionalClassFeature: (ddb, mod, { classFeatureIds = null, classId = null, requiredLevel = null, exactLevel = null } = {}) => {
    const klassFeatureIds = classFeatureIds ? classFeatureIds : DDBHelper.getClassFeatureIds(ddb, { classId, requiredLevel, exactLevel });
    return ddb.character.options.class.some((option) =>
      // is this option actually part of the class list?
      klassFeatureIds.includes(option.componentId)
      // does this modifier match a class option?
      && ((option.componentTypeId == mod.componentTypeId && option.componentId == mod.componentId)
        || (option.definition.entityTypeId == mod.componentTypeId && option.definition.id == mod.componentId))
      // !data.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == option.definition.id) &&
      // optional class feature
      && ddb.character.optionalClassFeatures?.some((f) => f.classFeatureId == option.componentId)
      // has it been chosen?
      && (
        ddb.character.choices.class.some((choice) =>
          choice.componentId == option.componentId
          && choice.componentTypeId == option.componentTypeId
          && choice.optionValue
        )
        || ddb.classOptions?.some((classOption) =>
          classOption.id == option.componentId
          && classOption.entityTypeId == option.componentTypeId
          && (classId === null || classId === classOption.classId)
        )
      )
    );
  },

  isModOptionalClassChoice(ddb, mod, { classFeatureIds = null, classId = null, requiredLevel = null, exactLevel = null } = {}) {
    const klassFeatureIds = classFeatureIds ? classFeatureIds : DDBHelper.getClassFeatureIds(ddb, { classId, requiredLevel, exactLevel });
    return ddb.character.choices.class.some((choice) =>
      // is this option actually part of the class list?
      // classFeatureIds.includes(choice.componentId)
      choice.componentTypeId == mod.componentTypeId
      && choice.componentId == mod.componentId
      && ddb.character.optionalClassFeatures?.some((f) =>
        f.classFeatureId == choice.componentId
        && (!f.affectedClassFeatureId || klassFeatureIds.includes(f.affectedClassFeatureId))
      )
    );
  },

  isModAChosenClassMod: (ddb, mod, { classFeatureIds = null, classId = null, requiredLevel = null, exactLevel = null } = {}) => {
    const klassFeatureIds = classFeatureIds ? classFeatureIds : DDBHelper.getClassFeatureIds(ddb, { classId, requiredLevel, exactLevel });
    const isClassFeature = DDBHelper.isModClassFeature(ddb, mod, { classFeatureIds: klassFeatureIds, classId, requiredLevel, exactLevel });
    // console.warn("isClassFeature", {isClassFeature, mod, klassFeatureIds, classId, requiredLevel, exactLevel});
    if (isClassFeature) return true;
    const isClassOption = DDBHelper.isModClassOption(ddb, mod, { classFeatureIds: klassFeatureIds, classId, requiredLevel, exactLevel });
    if (isClassOption) return true;
    // if it's been replaced by a class feature lets check that
    const isOptionalClassOption = DDBHelper.isModOptionalClassFeature(ddb, mod, { classFeatureIds: klassFeatureIds, classId, requiredLevel, exactLevel });
    if (isOptionalClassOption) return true;
    // new class feature choice
    const isOptionalClassChoice = DDBHelper.isModOptionalClassChoice(ddb, mod, { classFeatureIds: klassFeatureIds, classId, requiredLevel, exactLevel });

    // console.warn("isClassFeature2", {isClassFeature, mod, klassFeatureIds, classId, requiredLevel, exactLevel, isClassOption, isOptionalClassOption, isOptionalClassChoice});
    return isOptionalClassChoice;
  },

  getChosenClassModifiers: (ddb, { includeExcludedEffects = false, effectOnly = false, classId = null, requiredLevel = null, exactLevel = null, availableToMulticlass = null, useUnfilteredModifiers = null, filterOnFeatureIds = [] } = {}) => {
    const classFeatureIds = DDBHelper.getClassFeatureIds(ddb, { classId, requiredLevel, exactLevel })
      .filter((id) => {
        if (filterOnFeatureIds.length === 0) return true;
        return filterOnFeatureIds.includes(id);
      });
    // get items we are going to interact on
    const modifiers = DDBHelper
      .getModifiers(ddb, 'class', includeExcludedEffects, effectOnly, useUnfilteredModifiers)
      .filter((mod) =>
        (
          availableToMulticlass === null
          || mod.availableToMulticlass === undefined
          || mod.availableToMulticlass === null
          || mod.availableToMulticlass === availableToMulticlass
        )
        && DDBHelper.isModAChosenClassMod(ddb, mod, { classFeatureIds, classId, requiredLevel, exactLevel })
      );

    // console.warn("getChosenClassModifiers", {classFeatureIds, modifiers});
    return modifiers;
  },

  filterBaseCharacterModifiers: (ddb, type, { subType = null, restriction = ["", null], includeExcludedEffects = false, effectOnly = false, classId = null, availableToMulticlass = null, useUnfilteredModifiers = null } = {}) => {
    const modifiers = [
      DDBHelper.getChosenClassModifiers(ddb, { includeExcludedEffects, effectOnly, classId, availableToMulticlass, useUnfilteredModifiers }),
      DDBHelper.getModifiers(ddb, "race", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
      DDBHelper.getModifiers(ddb, "background", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
      DDBHelper.getModifiers(ddb, "feat", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
    ];

    return DDBHelper.filterModifiersOld(modifiers, type, subType, restriction);
  },

  getAllModifiers: (ddb, { includeExcludedEffects = false, effectOnly = false, classId = null, availableToMulticlass = null, useUnfilteredModifiers = null } = {}) => {
    return [
      DDBHelper.getChosenClassModifiers(ddb, { includeExcludedEffects, effectOnly, classId, availableToMulticlass, useUnfilteredModifiers }),
      DDBHelper.getModifiers(ddb, "race", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
      DDBHelper.getModifiers(ddb, "background", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
      DDBHelper.getModifiers(ddb, "feat", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
      DDBHelper.getActiveItemModifiers(ddb, includeExcludedEffects),
    ].flat();
  },

  // I need to getChosenOriginFeatures from data.optionalOriginFeatures

  filterBaseModifiers: (ddb, type, { subType = null, restriction = ["", null], includeExcludedEffects = false, effectOnly = false, classId = null, availableToMulticlass = null, useUnfilteredModifiers = null } = {}) => {
    const modifiers = [
      DDBHelper.getChosenClassModifiers(ddb, { includeExcludedEffects, effectOnly, classId, availableToMulticlass, useUnfilteredModifiers }),
      DDBHelper.getModifiers(ddb, "race", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
      DDBHelper.getModifiers(ddb, "background", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
      DDBHelper.getModifiers(ddb, "feat", includeExcludedEffects, effectOnly, useUnfilteredModifiers),
      DDBHelper.getActiveItemModifiers(ddb, includeExcludedEffects),
    ];

    return DDBHelper.filterModifiersOld(modifiers, type, subType, restriction);
  },

  stringIntAdder(one, two) {
    const oneInt = `${one}`.trim().replace(/^[+-]\s*/, "");
    const twoInt = `${two}`.trim().replace(/^[+-]\s*/, "");
    if (Number.isInteger(parseInt(oneInt)) && Number.isInteger(parseInt(twoInt))) {
      const num = parseInt(oneInt) + parseInt(twoInt);
      return `${num}`;
    } else {
      const twoAdjusted = (/^[+-]/).test(`${two}`.trim()) ? two : `+ ${two}`;
      return `${one} ${twoAdjusted}`;
    }
  },

  /**
   * Checks the list of modifiers provided for a matching bonus type
   * and returns a sum of it's value. May include a dice string.
   * @param {*} modifiers
   * @param {*} character
   * @param {*} bonusSubType
   */
  getModifierSum: (modifiers, character) => {
    let sum = "";
    let diceString = "";
    let modBonus = 0;
    modifiers.forEach((modifier) => {
      const die = modifier.dice ?? modifier.die ?? undefined;
      const fixedBonus = die?.fixedValue ?? 0;
      const statBonus = (Number.isInteger(modifier.statId))
        ? modifier.statId
        : Number.isInteger(modifier.abilityModifierStatId)
          ? modifier.abilityModifierStatId
          : null;
      if (Number.isInteger(statBonus)) {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === modifier.statId);
        modBonus += character.system.abilities[ability.value].mod;
      }
      if (die) {
        const mod = die.diceString;
        diceString += diceString === "" ? mod : " + " + mod;
        if (die.diceString) {
          const mod = die.diceString + modBonus + fixedBonus;
          diceString += diceString === "" ? mod : " + " + mod;
        } else if (fixedBonus) {
          sum = DDBHelper.stringIntAdder(sum, fixedBonus + modBonus);
        }
      } else if (modifier.fixedValue) {
        sum = DDBHelper.stringIntAdder(sum, modifier.fixedValue);
      } else if (modifier.value) {
        sum = DDBHelper.stringIntAdder(sum, modifier.value);
      } else if (modBonus !== 0) {
        sum = DDBHelper.stringIntAdder(sum, modBonus);
      }
      if (modifier.modifierTypeId === 1 && modifier.bonusTypes.includes(1)) {
        // prof bonus
        sum = DDBHelper.stringIntAdder(sum, character.system.attributes.prof);
      }

    });
    if (diceString !== "") {
      sum = diceString + " + " + sum;
    }

    sum = `${sum}`.trim().replace(/\+\s*\+/, "+").replace(/^\+\s*/, "");

    return sum !== "" ? sum : 0;
  },

  /**
   * Searches for selected options if a given feature provides choices to the user
   * @param {string} type character property: "class", "race" etc.
   * @param {object} feat options to search for
   */
  getChoices: (ddb, type, feat) => {
    const id = feat.id ? feat.id : feat.definition.id ? feat.definition.id : null;
    const featDefinition = feat.definition ? feat.definition : feat;

    if (ddb.character.choices[type] && Array.isArray(ddb.character.choices[type])) {
      // find a choice in the related choices-array
      const choices = ddb.character.choices[type].filter(
        (characterChoice) => characterChoice.componentId && characterChoice.componentId === id
      );

      if (choices) {
        const choiceDefinitions = ddb.character.choices.choiceDefinitions;

        const options = choices
          .filter(
            (choice) => {
              const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
              const validOption = optionChoice && optionChoice.options.find((option) => option.id === choice.optionValue);
              return validOption;
            })
          .map((choice) => {
            // console.warn(choice);
            const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
            let result = optionChoice.options.find((option) => option.id === choice.optionValue);
            result.componentId = choice.componentId;
            result.componentTypeId = choice.componentTypeId;
            result.choiceId = choice.id;
            result.parentChoiceId = choice.parentChoiceId;
            result.subType = choice.subType;
            result.type = type;
            result.wasOption = false;
            return result;
          });

        if (options.length > 0) return options;

        if (ddb.character.options[type]?.length > 0) {
          // if it is a choice option, try and see if the mod matches
          const optionMatch = ddb.character.options[type]
            .filter(
              (option) =>
                // id match
                (!featDefinition.componentTypeId && !featDefinition.entityTypeId && id == option.componentId)
                || (!featDefinition.componentTypeId && foundry.utils.hasProperty(featDefinition, "entityTypeId")
                  && featDefinition.entityTypeId == option.componentTypeId && id == option.componentId
                )
                // && // the choice id matches the option componentID
                // (featDefinition.componentTypeId == option.componentTypeId || // either the choice componenttype and optiontype match or
                //   featDefinition.componentTypeId == option.definition.entityTypeId) && // the choice componentID matches the option definition entitytypeid
                // option.componentTypeId == featDefinition.entityTypeId
            )
            .map((option) => {
              return {
                id: option.definition.id,
                entityTypeId: option.definition.entityTypeId,
                label: option.definition.name,
                description: option.definition.description,
                componentId: option.componentId,
                componentTypeId: option.componentTypeId,
                choiceId: null,
                sourceId: option.definition.sourceId,
                parentChoiceId: null,
                subType: `${type}-option`,
                type: type,
                wasOption: true,
              };
            });
          if (optionMatch.length > 0) return optionMatch;
        }
      }
    }
    // we could not determine if there are any choices left
    return [];
  },

  getComponentIdFromOptionValue: (ddb, type, optionId) => {
    if (ddb.character?.choices && ddb.character.choices[type] && Array.isArray(ddb.character.choices[type])) {
      // find a choice in the related choices-array
      const choice = ddb.character.choices[type].find(
        (characterChoice) => characterChoice.optionValue && characterChoice.optionValue === optionId
      );
      if (choice) return choice.componentId;
    }
    // we could not determine if there are any choices left
    return undefined;
  },

  determineActualFeatureId: (ddb, featureId, type = "class") => {
    const optionalFeatureReplacement = ddb.character?.optionalClassFeatures
      ? ddb.character.optionalClassFeatures
        .filter((f) => f.classFeatureId === featureId)
        .map((f) => f.affectedClassFeatureId)
      : [];
    // are we dealing with an optional class feature?
    const choiceFeature = DDBHelper.getComponentIdFromOptionValue(ddb, type, featureId);

    if (choiceFeature) {
      const choiceOptionalFeature = ddb.character.optionalClassFeatures
        .filter((f) => f.classFeatureId === choiceFeature)
        .map((f) => f.affectedClassFeatureId);
      if (choiceOptionalFeature && choiceOptionalFeature.length > 0) {
        return choiceOptionalFeature[0];
      }
    } else if (optionalFeatureReplacement && optionalFeatureReplacement.length > 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Feature ${featureId} is replacing ${optionalFeatureReplacement[0]}`);
      return optionalFeatureReplacement[0];
    }
    return featureId;
  },

  findSubClassByFeatureId: (ddb, featureId) => {
    // optional class features need this filter, as they replace existing features
    const featId = DDBHelper.determineActualFeatureId(ddb, featureId);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Finding subclass featureId ${featureId} with featId ${featId}`);

    let klass = ddb.character.classes.find((cls) => {
      let classFeatures = cls.definition.classFeatures;
      if (!cls.subclassDefinition) return false;
      if (!cls.subclassDefinition.classFeatures) return false;

      const subClassFeatures = cls.subclassDefinition.classFeatures.filter((f) =>
        !classFeatures.some((cf) => cf.id === f.id)
      );

      return subClassFeatures.some((feature) => feature.id === featId);
    });
    return klass;
  },

  findClassByFeatureId: (ddb, featureId) => {
    // optional class features need this filter, as they replace existing features
    const featId = DDBHelper.determineActualFeatureId(ddb, featureId);
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Finding featureId ${featureId} with featId ${featId}`);

    let klass = ddb.character.classes.find((cls) => {
      let classFeatures = cls.classFeatures;
      let featureMatch = classFeatures.find((feature) => feature.definition.id === featId);

      if (featureMatch) {
        return true;
      } else {
        // if not in global class feature list lets dig down
        classFeatures = cls.definition.classFeatures;
        if (cls.subclassDefinition && cls.subclassDefinition.classFeatures) {
          classFeatures = classFeatures.concat(cls.subclassDefinition.classFeatures);
        }
        return classFeatures.some((feature) => feature.id === featId);
      }
    });
    // try class option lookup
    if (!klass) {
      const option = ddb.character.options.class.find((option) => option.definition.id == featureId);
      if (option) {
        klass = ddb.character.classes.find((cls) => cls.classFeatures.find((feature) => feature.definition.id == option.componentId));
      }
      if (option && !klass && ddb.classOptions) {
        const classOption = ddb.classOptions.find((cOption) => cOption.id == option.componentId);
        if (classOption) {
          klass = ddb.character.classes.find((cls) => cls.definition.id === classOption.classId);
        }
      }
    }
    // class option lookups
    if (!klass && ddb.classOptions) {
      const classOption = ddb.classOptions.find((option) => option.id == featureId);
      if (classOption) {
        klass = ddb.character.classes.find((cls) => cls.definition.id == classOption.classId);
      }
    }
    if (klass) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Class ${klass.definition.name} found for ${featureId} with featId ${featId}`);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Class not found for ${featureId}`);
    }

    return klass;
  },

  getCustomValueFromCharacter(ddbItem, character, type) {
    if (!character) return null;
    const characterValues = character.flags.ddbimporter.dndbeyond.characterValues;
    const customValue = characterValues.filter((value) =>
      value.valueId == ddbItem.id
      && value.valueTypeId == ddbItem.entityTypeId
    );

    if (customValue) {
      const value = customValue.find((value) => value.typeId == type);
      if (value) return value.value;
    }
    return null;
  },

  getCustomValue(foundryItem, ddb, type) {
    const characterValues = ddb.character?.characterValues;
    if (!characterValues) return null;
    const customValue = characterValues.filter(
      (value) =>
        (value.valueId == foundryItem.flags.ddbimporter.dndbeyond?.id
          && value.valueTypeId == foundryItem.flags.ddbimporter.dndbeyond?.entityTypeId)
        || (value.valueId == foundryItem.flags.ddbimporter.id
          && value.valueTypeId == foundryItem.flags.ddbimporter.entityTypeId)
    );

    if (customValue) {
      const customName = customValue.find((value) => value.typeId == type);
      if (customName) return customName.value;
    }
    return null;
  },

  addCustomValues(ddb, foundryItem) {
    // to hit override requires a lot of crunching
    // const toHitOverride = DDBHelper.getCustomValue(item, character, 13);
    const toHitBonus = DDBHelper.getCustomValue(foundryItem, ddb, 12);
    const damageBonus = DDBHelper.getCustomValue(foundryItem, ddb, 10);
    // const displayAsAttack = DDBHelper.getCustomValue(item, character, 16);
    const costOverride = DDBHelper.getCustomValue(foundryItem, ddb, 19);
    const weightOverride = DDBHelper.getCustomValue(foundryItem, ddb, 22);
    // dual wield 18
    // silvered
    const silvered = DDBHelper.getCustomValue(foundryItem, ddb, 20);
    // adamantine
    const adamantine = DDBHelper.getCustomValue(foundryItem, ddb, 21);
    // off-hand
    // const offHand = DDBHelper.getCustomValue(ddbItem, character, 18);
    const dcOverride = DDBHelper.getCustomValue(foundryItem, ddb, 15);
    const dcBonus = DDBHelper.getCustomValue(foundryItem, ddb, 14);

    if (toHitBonus) {
      if (foundry.utils.hasProperty(foundryItem, "system.attack.bonus") && parseInt(foundryItem.system.attack.bonus) === 0) {
        foundryItem.system.attack.bonus = toHitBonus;
      } else {
        foundryItem.system.attack.bonus += ` + ${toHitBonus}`;
      }
    }
    if (damageBonus && foundryItem.system?.damage?.parts && foundryItem.system?.damage?.parts.length !== 0) {
      foundryItem.system.damage.parts[0][0] = foundryItem.system.damage.parts[0][0].concat(` +${damageBonus}`);
    } else if (damageBonus && foundryItem.system?.damage?.parts) {
      const part = [`+${damageBonus}`, ""];
      foundryItem.system.damage.parts.push(part);
    }
    if (costOverride) foundryItem.system.cost = costOverride;
    if (weightOverride) foundryItem.system.weight = weightOverride;
    if (silvered) foundryItem.system.properties['sil'] = true;
    if (adamantine) foundryItem.system.properties['ada'] = true;
    if (dcBonus) {
      if (foundryItem.flags.ddbimporter.dndbeyond.dc) {
        foundryItem.system.save.dc = parseInt(foundryItem.flags.ddbimporter.dndbeyond.dc) + dcBonus;
        foundryItem.system.save.scaling = "flat";
      }
    }
    if (dcOverride) {
      foundryItem.system.save.dc = dcOverride;
      foundryItem.system.save.scaling = "flat";
    }
    return foundryItem;
  },

  getName(ddb, item, character = null, allowCustom = true) {
    // spell name
    const customName = character
      ? DDBHelper.getCustomValueFromCharacter(item, character, 8)
      : DDBHelper.getCustomValue(item, ddb, 8);
    if (customName && allowCustom) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(customName);
    } else if (item.definition?.name) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(item.definition.name);
    } else if (item.name) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(item.name);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("Unable to determine name for:", item);
      return "Unknown thing.";
    }
  },

  displayAsAttack(ddb, item, character = null) {
    const customDisplay = character
      ? DDBHelper.getCustomValueFromCharacter(item, character, 16)
      : DDBHelper.getCustomValue(item, ddb, 16);
    if (typeof customDisplay == "boolean") {
      return customDisplay;
    } else if (foundry.utils.hasProperty(item, "displayAsAttack")) {
      return item.displayAsAttack;
    } else {
      return false;
    }
  },

  extractModifierValue(modifier) {
    let value = "";
    let modBonus = "";

    let statBonus = (modifier.statId)
      ? modifier.statId
      : modifier.abilityModifierStatId
        ? modifier.abilityModifierStatId
        : null;

    if (statBonus) {
      const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === modifier.statId).value;
      modBonus = modBonus === "" ? `@abilities.${ability}.mod` : `${modBonus} + @abilities.${ability}.mod`;
    }

    if (modifier.modifierTypeId === 1 && modifier.bonusTypes.includes(1)) {
      // prof bonus
      modBonus = modBonus === "" ? `@prof` : `${modBonus} + @prof`;
    }

    const die = modifier.dice ? modifier.dice : modifier.die ? modifier.die : undefined;

    if (die) {
      const fixedBonus = die.fixedValue ? ` + ${die.fixedValue}` : "";
      if (die.diceString) {
        value = die.diceString + modBonus + fixedBonus;
      } else if (fixedBonus) {
        value = fixedBonus + modBonus;
      }
    } else if (modifier.fixedValue) {
      value = modifier.fixedValue;
    } else if (modifier.value) {
      value = modifier.value;
    } else if (modBonus) {
      value = modBonus;
    }

    if (value === "" && modifier.subType == "saving-throws" && modifier.bonusTypes.includes(2)) {
      // we set the value to zero and when the saving throw is calculated it will
      // be updated by the attunedItemsBonus function above
      value = "@attributes.attunement.value";
    }

    return value;
  },

  getValueFromModifiers(modifiers, name, modifierSubType, modifierType = "bonus") {
    let bonuses;
    const bonusEffects = DDBHelper.filterModifiersOld(modifiers, modifierType, modifierSubType, null);

    if (bonusEffects.length > 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Generating ${modifierSubType} ${modifierType} for ${name}`);
      bonuses = "";
      bonusEffects.forEach((modifier) => {
        let bonusParse = DDBHelper.extractModifierValue(modifier);
        if (bonuses !== "") bonuses += " + ";
        bonuses += bonusParse;
      });
      if (bonuses === "") {
        bonuses = undefined;
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Modifier value 0 for ${modifierSubType} ${modifierType} for ${name}. Reset to undefined`, {
          modifiers,
          name,
          modifierSubType,
          modifierType,
        });
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Modifier value string for ${modifierSubType} ${modifierType} for ${name}`, bonuses);
      }
    }

    return bonuses;
  },

  findMatchedDDBItem(item, ownedItems, existingMatchedItems = []) {
    return ownedItems.find((owned) => {
      // have we already matched against this id? lets not double dip
      const existingMatch = existingMatchedItems.find((matched) => {
        return foundry.utils.getProperty(owned, "flags.ddbimporter.id") === foundry.utils.getProperty(matched, "flags.ddbimporter.id");
      });
      if (existingMatch) return false;
      // the simple match
      const simpleMatch
        = item.name === owned.name
        && item.type === owned.type
        && item.flags?.ddbimporter?.id === owned.flags?.ddbimporter?.id;
      // account for choices in ddb
      const isChoice
        = foundry.utils.hasProperty(item, "flags.ddbimporter.dndbeyond.choice.choiceId")
        && foundry.utils.hasProperty(owned, "flags.ddbimporter.dndbeyond.choice.choiceId");
      const choiceMatch = isChoice
        ? item.flags.ddbimporter.dndbeyond.choice.choiceId
          === owned.flags.ddbimporter.dndbeyond.choice.choiceId
        : true;
      // force an override
      const overrideDetails = foundry.utils.getProperty(owned, "flags.ddbimporter.overrideItem");
      const overrideMatch
        = overrideDetails
        && item.name === overrideDetails.name
        && item.type === overrideDetails.type
        && item.flags?.ddbimporter?.id === overrideDetails.ddbId;

      return (simpleMatch && choiceMatch) || overrideMatch;
    });
  }

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DDBHelper);


/***/ }),

/***/ 6968:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBItemImporter)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);
/* harmony import */ var _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3893);
/* harmony import */ var _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2449);
/* harmony import */ var _Iconizer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(306);
/* harmony import */ var _DDBCompendiumFolders_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(819);
/* harmony import */ var _NameMatcher_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3901);
/* harmony import */ var _effects_vision5e_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(5042);
/* harmony import */ var _effects_external_ExternalAutomations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(767);











class DDBItemImporter {

  constructor(type, documents, { matchFlags = [], deleteBeforeUpdate = null, indexFilter = {}, useCompendiumFolders = null } = {}) {
    this.type = type;
    this.documents = documents;
    this.useCompendiumFolders = useCompendiumFolders ?? true;
    this.matchFlags = matchFlags;

    this.compendium = _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCompendiumType */ .Z.getCompendiumType(this.type);
    this.compendium.configure({ locked: false });
    this.compendiumIndex = null;
    this.indexFilter = indexFilter;

    this.results = [];

    this.deleteBeforeUpdate = deleteBeforeUpdate ?? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-delete-during-update");
  }

  async buildIndex(indexFilter = {}) {
    this.indexFilter = indexFilter;
    this.compendiumIndex = await this.compendium.getIndex(this.indexFilter);
  }

  async init() {
    await this.buildIndex(this.indexFilter);
  }

  #flagMatch(item1, item2) {
    // console.warn("flagMatch", {item1, item2, matchFlags});
    if (this.matchFlags.length === 0) return true;
    const matched = this.matchFlags.some((flag) =>
      foundry.utils.hasProperty(item1, `flags.ddbimporter.${flag}`)
      && foundry.utils.hasProperty(item2, `flags.ddbimporter.${flag}`)
      && item1.flags.ddbimporter[flag] === item2.flags.ddbimporter[flag]
    );
    return matched;
  }

  static copyFlagGroup(flagGroup, originalItem, targetItem) {
    if (targetItem.flags === undefined) targetItem.flags = {};
    // if we have generated effects we dont want to copy some flag groups. mostly for AE on spells
    const effectsProperty = foundry.utils.getProperty(targetItem, "flags.ddbimporter.effectsApplied")
      && _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].EFFECTS_IGNORE_FLAG_GROUPS.includes */ .Z.EFFECTS_IGNORE_FLAG_GROUPS.includes(flagGroup);
    if (originalItem.flags && !!originalItem.flags[flagGroup] && !effectsProperty) {
      // logger.debug(`Copying ${flagGroup} for ${originalItem.name}`);
      targetItem.flags[flagGroup] = originalItem.flags[flagGroup];
    }
  }

  static copySupportedItemFlags(originalItem, targetItem) {
    _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].SUPPORTED_FLAG_GROUPS.forEach */ .Z.SUPPORTED_FLAG_GROUPS.forEach((flagGroup) => {
      this.copyFlagGroup(flagGroup, originalItem, targetItem);
    });
  }


  static updateCharacterItemFlags(itemData, replaceData) {
    if (itemData.flags?.ddbimporter?.importId) foundry.utils.setProperty(replaceData, "flags.ddbimporter.importId", itemData.flags.ddbimporter.importId);
    if (replaceData.flags?.ddbimporter?.ddbCustomAdded) {
      replaceData.system = itemData.system;
      replaceData.type = itemData.type;
    }
    if (itemData.system.quantity) replaceData.system.quantity = itemData.system.quantity;
    if (itemData.system.attuned) replaceData.system.attuned = itemData.system.attuned;
    if (itemData.system.attunement) replaceData.system.attunement = itemData.system.attunement;
    if (itemData.system.equipped) replaceData.system.equipped = itemData.system.equipped;
    if (itemData.system.resources) replaceData.system.resources = itemData.system.resources;
    if (itemData.system.preparation) replaceData.system.preparation = itemData.system.preparation;
    if (itemData.system.proficient) replaceData.system.proficient = itemData.system.proficient;
    if (!_dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(itemData.type)) {
      if (itemData.system.uses) replaceData.system.uses = itemData.system.uses;
      if (itemData.system.consume) replaceData.system.consume = itemData.system.consume;
      if (itemData.system.ability) replaceData.system.ability = itemData.system.ability;
    }
    if (foundry.utils.hasProperty(itemData, "system.levels")) replaceData.system.levels = itemData.system.levels;
    if (foundry.utils.getProperty(itemData, "flags.ddbimporter.price.xgte")) {
      replaceData.system.price.value = itemData.system.price.value;
      replaceData.system.price.denomination = itemData.system.price.denomination;
      foundry.utils.setProperty(replaceData, "flags.ddbimporter.price", itemData.flags.ddbimporter.price);
    }
    return replaceData;
  }

  static updateMatchingItems(oldItems, newItems,
    { looseMatch = false, monster = false, keepId = false, keepDDBId = false, overrideId = false, linkItemFlags = false } = {}
  ) {
    let results = [];

    for (let newItem of newItems) {
      let item = foundry.utils.duplicate(newItem);

      const matched = overrideId
        ? oldItems.find((oldItem) => foundry.utils.getProperty(oldItem, "flags.ddbimporter.overrideId") == item._id)
        : _NameMatcher_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].looseItemNameMatch */ .Z.looseItemNameMatch(item, oldItems, looseMatch, monster); // eslint-disable-line no-await-in-loop

      if (matched) {
        const match = foundry.utils.duplicate(matched);
        // in some instances we want to keep the ddb id
        if (keepDDBId && foundry.utils.hasProperty(item, "flags.ddbimporter.id")) {
          foundry.utils.setProperty(match, "flags.ddbimporter.id", foundry.utils.duplicate(item.flags.ddbimporter.id));
        }
        if (!item.flags.ddbimporter) {
          foundry.utils.setProperty(item, "flags.ddbimporter", match.flags.ddbimporter);
        } else if (match.flags.ddbimporter && item.flags.ddbimporter) {
          const mergedFlags = foundry.utils.mergeObject(item.flags.ddbimporter, match.flags.ddbimporter);
          foundry.utils.setProperty(item, "flags.ddbimporter", mergedFlags);
        }
        if (!item.flags.monsterMunch && match.flags.monsterMunch) {
          foundry.utils.setProperty(item, "flags.monsterMunch", match.flags.monsterMunch);
        }
        foundry.utils.setProperty(item, "flags.ddbimporter.originalItemName", match.name);
        foundry.utils.setProperty(item, "flags.ddbimporter.replaced", true);
        if (linkItemFlags && foundry.utils.hasProperty(match, "flags.link-item-resource-5e")) {
          foundry.utils.setProperty(item, "flags.link-item-resource-5e", match.flags["link-item-resource-5e"]);
        }
        item = DDBItemImporter.updateCharacterItemFlags(match, item);

        if (!keepId) delete item["_id"];
        results.push(item);
      }
    }

    return results;
  }

  /**
   * Removes items
   * @param {*} itemsToRemove
   */
  removeItems(itemsToRemove, matchDDBId = false) {
    this.documents = this.documents.filter((item) =>
      !itemsToRemove.some((originalItem) =>
        (item.name === originalItem.name || item.flags?.ddbimporter?.originalName === originalItem.name)
        && item.type === originalItem.type
        && (!matchDDBId || (matchDDBId && item.flags?.ddbimporter?.id === originalItem.flags?.ddbimporter?.id))
      )
    );
  }


  async getSRDCompendiumItems(looseMatch = false, keepId = false, monster = false) {
    const compendiumName = _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].SRD_COMPENDIUMS.find */ .Z.SRD_COMPENDIUMS.find((c) => c.type == this.type).name;
    const srdPack = _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCompendium */ .Z.getCompendium(compendiumName);
    const srdIndices = ["name", "type", "flags.ddbimporter.dndbeyond.alternativeNames"];
    const index = await srdPack.getIndex({ fields: srdIndices });

    const matchedIds = index.filter((i) =>
      index.some((orig) => {
        const extraNames = foundry.utils.getProperty(orig, "flags.ddbimporter.dndbeyond.alternativeNames") ?? [];
        if (looseMatch) {
          const looseNames = _NameMatcher_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getLooseNames */ .Z.getLooseNames(orig.name, extraNames);
          return looseNames.includes(i.name.split("(")[0].trim().toLowerCase());
        } else {
          return i.name === orig.name || extraNames.includes(i.name);
        }
      })
    ).map((i) => i._id);

    const loadedItems = (await srdPack.getDocuments(matchedIds))
      .map((i) => {
        const item = i.toObject();
        delete i.folder;
        if (item.flags.ddbimporter) {
          item.flags.ddbimporter["pack"] = compendiumName;
        } else {
          item.flags.ddbimporter = { pack: compendiumName };
        }
        return item;
      });
    // logger.debug(`SRD ${type} loaded items:`, loadedItems);

    const matchingOptions = {
      looseMatch,
      monster,
      keepId,
    };

    const results = DDBItemImporter.updateMatchingItems(this.documents, loadedItems, matchingOptions);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`SRD ${this.type} result items:`, results);

    return results;
  }

  async addCompendiumFolderIds(documents) {
    if (this.useCompendiumFolders) {
      const compendiumFolders = new _DDBCompendiumFolders_js__WEBPACK_IMPORTED_MODULE_6__/* .DDBCompendiumFolders */ .Z(this.type);
      await compendiumFolders.loadCompendium(this.type);
      const results = await compendiumFolders.addCompendiumFolderIds(documents);
      return results;
    } else {
      return documents;
    }
  }

  async getFilteredItems(item) {
    const indexEntries = this.compendiumIndex.filter((idx) => idx.name === item.name);

    const mapped = await Promise.all(indexEntries.map((idx) => {
      const entry = this.compendium.getDocument(idx._id).then((doc) => doc);
      return entry;
    }));

    const flagFiltered = mapped.filter((idx) => {
      const nameMatch = idx.name === item.name;
      const flagMatched = this.#flagMatch(idx, item);
      return nameMatch && flagMatched;
    });

    return flagFiltered;
  }


  /**
   * Asynchronously creates a new item to be added to a compendium based on its type.
   * @param {object} item - the data for the new item to be created
   * @return {Promise<object|null>} a Promise that resolves with the imported item or null if import failed
   */
  async createCompendiumItem(item) {
    let newItem;
    switch (this.type) {
      case "table":
      case "tables": {
        newItem = new RollTable(item);
        break;
      }
      default: {
        try {
          const options = {
            displaySheet: false,
            keepId: true,
            temporary: true,
          };
          newItem = new Item.implementation(item, options);
        } catch (err) {
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Error creating ${item.name}`, { item, err });
          throw err;
        }

      }
    }
    if (!newItem) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Item ${item.name} failed creation`, { item, newItem });
    }
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Creating ${item.name}`);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Pushing ${item.name} to compendium`);
    return this.compendium.importDocument(newItem);
  }

  async updateCompendiumItem(updateItem, existingItem) {
    // purge existing active effects on this item
    if (existingItem.results) await existingItem.deleteEmbeddedDocuments("TableResult", [], { deleteAll: true });
    if (existingItem.effects) await existingItem.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
    if (existingItem.flags) DDBItemImporter.copySupportedItemFlags(existingItem, updateItem);
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Updating ${updateItem.name} compendium entry`);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating ${updateItem.name} compendium entry`);

    const update = existingItem.update(updateItem, { pack: this.compendium.metadata.id, render: false });
    // const update = existingItem.update(updateItem, { pack: compendium.metadata.id, recursive: false, render: false });
    return update;
  }

  async deleteCreateCompendiumItem(updateItem, existingItem) {
    if (existingItem.flags) DDBItemImporter.copySupportedItemFlags(existingItem, updateItem);
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Removing and Recreating ${updateItem.name} compendium entry`);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Removing and Recreating ${updateItem.name} compendium entry`);
    await existingItem.delete();
    let newItem = await this.createCompendiumItem(updateItem);
    return newItem;
  }


  async updateCompendiumItems(inputItems) {
    let results = [];
    for (const item of inputItems) {
      const existingItems = await this.getFilteredItems(item);
      // we have a match, update first match
      if (existingItems.length >= 1) {
        const existingItem = existingItems[0];
        // eslint-disable-next-line require-atomic-updates
        item._id = existingItem._id;

        if (item.type !== existingItem.type || this.deleteBeforeUpdate) {
          if (item.type !== existingItem.type) {
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(`Item type mismatch ${item.name} from ${existingItem.type} to ${item.type}. DDB Importer will delete and recreate this item from scratch. You can most likely ignore this message.`);
          }
          let newItem = this.deleteCreateCompendiumItem(item, existingItem);
          results.push(newItem);
        } else {
          let update = this.updateCompendiumItem(item, existingItem);
          results.push(update);
        }
      }
    }

    return Promise.all(results);
  }

  async createCompendiumItems(inputItems) {
    let promises = [];
    for (const item of inputItems) {
      const existingItems = await this.getFilteredItems(item);
      // we have a single match
      if (existingItems.length === 0) {
        let newItem = await this.createCompendiumItem(item);
        promises.push(newItem);
      }
    };
    return Promise.all(promises);
  }

  async updateCompendium(updateExisting = false, filterDuplicates = true) {
    if (!game.user.isGM) return [];
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Getting compendium for update of ${this.type} documents (checking ${this.documents.length} docs)`);

    if (this.compendium.metadata.type === "Item" && this.deleteBeforeUpdate) {
      await Item.deleteDocuments([], { pack: this.compendium.metadata.id, deleteAll: true });
    }

    // remove duplicate items based on name and type
    const filterItems = filterDuplicates
      ? [...new Map(this.documents.map((item) => {
        let filterItem = item["name"] + item["type"];
        this.matchFlags.forEach((flag) => {
          filterItem += item.flags.ddbimporter[flag];
        });
        return [filterItem, item];
      })).values()]
      : this.documents;

    // v11 compendium folders - just add to doc before creation/update
    const inputItems = (await this.addCompendiumFolderIds(filterItems)).map((item) => {
      if (foundry.utils.hasProperty(item, "system.description.value")) {
        item.system.description.value = `<div class="ddb">
${item.system.description.value}
</div>`;
        item.system.description.chat = item.system.description.chat.trim() !== ""
          ? `<div class="ddb">
${item.system.description.chat}
</div>`
          : "";
      }
      return item;
    });

    let results = [];
    // update existing items
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Creating and updating ${inputItems.length} ${this.type} items in compendium...`, true);

    if (updateExisting) {
      results = await this.updateCompendiumItems(inputItems);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updated ${results.length} existing ${this.type} items in compendium`);
    }

    // create new items
    const createResults = await this.createCompendiumItems(inputItems);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Created ${createResults.length} new ${this.type} items in compendium`);
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote("", true);

    this.results = createResults.concat(results);
    return new Promise((resolve) => resolve(this.results));
  }

  async loadPassedItemsFromCompendium(items,
    { looseMatch = false, monsterMatch = false, keepId = false, deleteCompendiumId = true,
      indexFilter = {}, // { fields: ["name", "flags.ddbimporter.id"] }
      keepDDBId = false, linkItemFlags = false } = {}
  ) {

    await this.buildIndex(indexFilter);

    const firstPassItems = await this.compendiumIndex.filter((i) =>
      items.some((orig) => {
        const extraNames = foundry.utils.getProperty(orig, "flags.ddbimporter.dndbeyond.alternativeNames") ?? [];
        if (looseMatch) {
          const looseNames = _NameMatcher_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getLooseNames */ .Z.getLooseNames(orig.name, extraNames);
          return looseNames.includes(i.name.split("(")[0].trim().toLowerCase());
        } else if (monsterMatch) {
          const monsterNames = _NameMatcher_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getMonsterNames */ .Z.getMonsterNames(orig.name);
          // console.log(magicNames)
          if (i.name === orig.name) {
            return true;
          } else if (monsterNames.includes(i.name.toLowerCase())) {
            return true;
          } else {
            return false;
          }
        } else {
          return i.name === orig.name || extraNames.includes(i.name);
        }
      })
    );

    let loadedItems = [];
    for (const i of firstPassItems) {
      let item = await this.compendium.getDocument(i._id).then((doc) => {
        const docData = doc.toObject();
        if (deleteCompendiumId) delete docData._id;
        delete docData.folder;
        _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].COMPENDIUM_REMOVE_FLAGS.forEach */ .Z.COMPENDIUM_REMOVE_FLAGS.forEach((flag) => {
          if (foundry.utils.hasProperty(docData, flag)) foundry.utils.setProperty(docData, flag, undefined);
        });

        return docData;
      });
      foundry.utils.setProperty(item, "flags.ddbimporter.pack", `${this.compendium.metadata.id}`);
      loadedItems.push(item);
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`compendium ${this.type} loaded items:`, loadedItems);

    const matchingOptions = {
      looseMatch,
      monster: monsterMatch,
      keepId,
      keepDDBId,
      linkItemFlags,
    };

    const results = await DDBItemImporter.updateMatchingItems(items, loadedItems, matchingOptions);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`compendium ${this.type} result items:`, results);
    return results;
  }


  /**
   * gets items from compendium
   * @param {*} items
   * @param {*} type
   * @param {*} options
   */
  static async getCompendiumItems(items, type,
    { looseMatch = false, monsterMatch = false, keepId = false,
      deleteCompendiumId = true, keepDDBId = false, linkItemFlags = false } = {}
  ) {

    const itemImporter = new DDBItemImporter(type, []);
    await itemImporter.init();

    const loadOptions = {
      looseMatch,
      monsterMatch,
      keepId,
      keepDDBId,
      deleteCompendiumId,
      linkItemFlags,
    };
    const results = await itemImporter.loadPassedItemsFromCompendium(items, loadOptions);

    return results;
  }

  async srdFiddling(removeDuplicates = true, matchDDBId = false) {
    const useSrd = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd");

    if (useSrd) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Replacing SRD compendium items");
      const srdItems = await this.getSRDCompendiumItems();
      if (removeDuplicates) this.removeItems(srdItems, matchDDBId);
      this.documents = this.documents.concat(srdItems);
    }
  }

  async iconAdditions() {
    this.documents = await _Iconizer_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].updateIcons */ .Z.updateIcons(this.documents);
  }

  static async buildHandler(type, documents, updateBool,
    { srdFidding = true, removeSRDDuplicates = true, ids = null, vision5e = false, chrisPremades = false, matchFlags = [],
      deleteBeforeUpdate = null, filterDuplicates = true, useCompendiumFolders = null, updateIcons = true } = {}
  ) {
    const handler = new DDBItemImporter(type, documents, { matchFlags, deleteBeforeUpdate, useCompendiumFolders });
    await handler.init();
    if (srdFidding) await handler.srdFiddling(removeSRDDuplicates);
    if (updateIcons) await handler.iconAdditions();
    const filteredItems = (ids !== null && ids.length > 0)
      ? handler.documents.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))
      : handler.documents;
    if (vision5e) {
      handler.documents = (0,_effects_vision5e_js__WEBPACK_IMPORTED_MODULE_8__/* .addVision5eStubs */ .j)(filteredItems);
    }
    if (chrisPremades) {
      handler.documents = await _effects_external_ExternalAutomations_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].applyChrisPremadeEffects */ .Z.applyChrisPremadeEffects({ documents: handler.documents, compendiumItem: true });
    }
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].munchNote */ .Z.munchNote(`Importing ${handler.documents.length} ${type} documents!`, true);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Importing ${handler.documents.length} ${type} documents!`, foundry.utils.deepClone(documents));
    await handler.updateCompendium(updateBool, filterDuplicates);
    await handler.buildIndex();
    return handler;
  }

}


/***/ }),

/***/ 546:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6451);


const DDBProxy = {

  isCustom: () => {
    return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "custom-proxy");
  },

  resetProxy: () => {
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "api-endpoint", _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].DEFAULT_SETTINGS.READY.PROXY["api-endpoint"]["default"] */ .Z.DEFAULT_SETTINGS.READY.PROXY["api-endpoint"]["default"]);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "custom-proxy", false);
  },

  getProxy: () => {
    if (DDBProxy.isCustom() || CONFIG.DDBI.DEV.enabled) return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "api-endpoint");
    else return _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].URLS.PROXY */ .Z.URLS.PROXY;
  },

  getDynamicProxy: () => {
    if (CONFIG.DDBI.DEV.enabled) return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "dynamic-api-endpoint");
    else return _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].URLS.DYNAMIC */ .Z.URLS.DYNAMIC;
  },

  getCORSProxy: () => {
    if (DDBProxy.isCustom() || CONFIG.DDBI.DEV.enabled || CONFIG.DDBI.DEV.customCors) return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cors-endpoint");
    return _settings_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].URLS.CORS */ .Z.URLS.CORS;
  },


};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DDBProxy);


/***/ }),

/***/ 7162:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IP": () => (/* binding */ parseDamageRolls),
/* harmony export */   "RN": () => (/* binding */ parseTags),
/* harmony export */   "uB": () => (/* binding */ importCacheLoad)
/* harmony export */ });
/* unused harmony exports loadDDBCompendiumIndexes, parseToHitRoll */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3893);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6451);





const INDEX_COMPENDIUMS = [
  "spell",
  "spells",
  "item",
  "items",
  "magicitems",
  "monsters",
  "magicitem",
  "monster",
  "vehicle",
  "vehicles",
];

const ATTACK_ACTION_HINTS = {
  "Opportunity Attack": "Opportunity Attacks",
  "Grapple": "Grappling",
  "Shove": "Shoving",
  "Interact with an Object": "Use an Object",
};

const RULE_ADJUSTMENT = {
  "rule": "rules",
  "skill": "skills",
  "ability": "abilities",
  "condition": "conditions",
  "creatureType": "creatureTypes",
  "damageType": "damageTypes",
  "spellComponent": "spellComponents",
  "spellTag": "spellTags",
  "spellSchool": "spellSchools",
  "areaTargetType": "areaTargetTypes",
};

const SUPER_LOOSE = [
  "rules",
  "actions",
  "areaTargetType",
];


async function loadDDBCompendiumIndexes() {
  for (const i of INDEX_COMPENDIUMS) {
    await _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].loadCompendiumIndex */ .Z.loadCompendiumIndex(i);
  }
}


function findMatchingTagInIndex(type, tag) {
  const index = foundry.utils.hasProperty(CONFIG.DDBI, `compendium.index.${type}`)
    ? foundry.utils.getProperty(CONFIG.DDBI, `compendium.index.${type}`)
    : undefined;
  if (!index) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Unable to load compendium ${type}s`);
    return tag;
  }
  const strippedTag = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stripHtml */ .Z.stripHtml(tag);
  const match = index.find((entry) => _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].nameString */ .Z.nameString(entry.name).toLowerCase() === _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].nameString */ .Z.nameString(strippedTag).replace("&nbsp;", " ").toLowerCase());
  if (match) {
    const label = foundry.utils.getProperty(CONFIG.DDBI, `compendium.label.${type}`);
    return `@Compendium[${label}.${match._id}]{${tag}}`;
  } else if (strippedTag.includes(";")) {
    const tagSplit = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].nameString */ .Z.nameString(strippedTag.replace("&nbsp;", " ")).split(";")[0];
    const splitMatch = index.find((entry) => _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].nameString */ .Z.nameString(entry.name).toLowerCase() === tagSplit.toLowerCase());
    if (splitMatch) {
      const label = foundry.utils.getProperty(CONFIG.DDBI, `compendium.label.${type}`);
      return `@Compendium[${label}.${splitMatch._id}]{${tagSplit}}`;
    }
  }
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Unable to find tag parse compendium match in ${type} for ${tag}`);
  return tag;
}


function generateDDBRuleLinks() {
  const rules = {
    "senses": { // CONFIG.DDB.senses
    },
    "actions": { // CONFIG.DDB.basicActions
    },
    "weaponproperties": { // CONFIG.DDB.weaponProperties
      // foundry does not yet have weapon property descriptions
    },
  };

  for (const sense of CONFIG.DDB.senses) {
    const slug = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalizeString */ .Z.normalizeString(sense.name);
    if (CONFIG.DND5E.rules[slug]) {
      rules.senses[slug] = {
        reference: CONFIG.DND5E.rules[slug],
        label: sense.name,
        id: sense.id,
      };
    }
  }

  for (const action of CONFIG.DDB.basicActions) {
    const slug = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalizeString */ .Z.normalizeString(action.name);
    const lookup = CONFIG.DND5E.rules[slug] ?? ATTACK_ACTION_HINTS[action.name];
    if (lookup) {
      rules.actions[slug] = {
        reference: CONFIG.DND5E.rules[slug],
        label: action.name,
        id: action.id,
      };
    }
  }

  return rules;
}


function getRuleLookups() {
  if (CONFIG.DDBI.RULE_MATCHES) return CONFIG.DDBI.RULE_MATCHES;

  const baseRules = {
    "rules": {},
    "conditions": CONFIG.DND5E.conditionTypes,
    "skills": CONFIG.DND5E.skills,
    "abilities": CONFIG.DND5E.abilities,
    "creatureTypes": CONFIG.DND5E.creatureTypes,
    "damageTypes": CONFIG.DND5E.damageTypes,
    "spellComponents": CONFIG.DND5E.spellComponents,
    "spellTags": CONFIG.DND5E.spellTags,
    "spellSchools": CONFIG.DND5E.spellSchools,
    "areaTargetTypes": CONFIG.DND5E.areaTargetTypes
  };

  const rules = {};
  for (const [key, value] of Object.entries(CONFIG.DND5E.rules)) {
    rules[key] = {
      label: _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(key),
      reference: value,
    };
  }
  baseRules["rules"] = foundry.utils.mergeObject(foundry.utils.mergeObject({}, rules), baseRules.spellTags);
  CONFIG.DDBI.RULE_MATCHES = foundry.utils.mergeObject(baseRules, generateDDBRuleLinks());
  return CONFIG.DDBI.RULE_MATCHES;
}


/**
 * Replaces a rule based on the given type, reference, slug, and forceTrimCheck flag.
 *
 * @param {string} baseType - The base type of the rule.
 * @param {string} text - The text to be replaced/used as description.
 * @param {string} slug - The slug to identify the rule.
 * @param {boolean} forceTrimCheck - Optional flag to force trim check.
 * @return {string} The replaced reference based on the rule.
 */
function ruleReplacer(baseType, text, slug, forceTrimCheck = false) {
  const type = RULE_ADJUSTMENT[baseType] ?? baseType;

  const rules = getRuleLookups()[type];
  if (!rules) return text;

  if (forceTrimCheck || ["abilities", "skills", "spellSchools"].includes("type")) {
    // ensure it's not a trimmed slug
    const trimmedSlug = slug.substring(0, 3).toLowerCase();
    if (rules[trimmedSlug] && type[trimmedSlug].reference) {
      const result = `&Reference[${trimmedSlug}]{${text}}`;
      return result;
    }
  }

  if (rules[slug] && rules[slug].reference) {
    const result = `&Reference[${slug}]{${text}}`;
    return result;
  }

  return text;
}

/**
 * Replaces a tag in the given string with a modified version.
 *  /(\[([^\]]+)]([^[]+)\[\/([^\]]+)]/g;
 *
 * @param {string} match - the entire matched string
 * @param {string} tagType - tag name e.g. skills
 * @param {string} tagName - tag name e.g. Acrobatics
 * @param {number} _p4 - final tag closure
 * @param {number} _offset - the zero-based index of the match in the string
 * @param {string} _string - the input string
 * @return {string} the modified string with the replaced tag
 */
// eslint-disable-next-line no-unused-vars
function replaceTag(match, tagType, tagName, _p4, _offset, _string) {
  if (!tagName) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Unable to tag parse ${match}`);
    return match;
  }

  if (INDEX_COMPENDIUMS.includes(tagType)) {
    return findMatchingTagInIndex(tagType, tagName);
  }

  const strippedP2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stripHtml */ .Z.stripHtml(tagName);
  const lowerCaseTag = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalizeString */ .Z.normalizeString(strippedP2);
  const result = ruleReplacer(tagType, tagName, lowerCaseTag);

  return result;
}

/**
 * Parses loose rule references in the given text.
 * Fast and loose search and replace
 *
 * @param {string} text - The text to parse rule references from
 * @param {boolean} superLoose - Flag to indicate whether to allow super loose rule references
 * @return {string} The parsed text with rule references replaced
 */
function parseLooseRuleReferences(text, superLoose = false) {
  for (const [type, entries] of Object.entries(getRuleLookups())) {
    // console.error(`Reference Check`, { text });
    // eslint-disable-next-line no-continue
    if (!superLoose && SUPER_LOOSE.includes(type)) continue;
    for (const [key, value] of Object.entries(entries)) {
      // eslint-disable-next-line no-continue
      if (!value.reference) continue;
      const linkRegEx = new RegExp(`(&Reference)?(^| |\\(|\\[|>)(DC (\\d\\d) )?(${value.label})( (saving throw|average=true|average=false))?( |\\)|\\]|\\.|,|$|\\n|<)`, "ig");
      const replaceRule = (match, p1, p2, p3, p4, p5, p6, p7, p8) => {
        // console.warn("match", { match, p1, p2, p3, p4, p5, p6, p7, p8 });
        if (p1 || (p7 && p7.includes("average="))) return match; // already a reference match don't match this
        if (p3 && Number.isInteger(parseInt(p4)) && p7) {
          if (p7.toLowerCase() === "saving throw") {
            return `${p2}[[/save ${key} ${p4} format=long]]${p8}`;
          }
        }
        return `${p2}${p3 ?? ""}&Reference[${key}]{${p5}}${p6 ?? ""}${p8}`;
      };
      text = text.replaceAll(linkRegEx, replaceRule);
    }
  }


  return text;
}

function parseHardReferenceTag(type, text) {
  const index = foundry.utils.hasProperty(CONFIG.DDBI, `compendium.index.${type}`)
    ? foundry.utils.getProperty(CONFIG.DDBI, `compendium.index.${type}`)
    : undefined;
  if (!index) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Unable to load compendium ${type}s`);
    return text;
  }

  const referenceRegexReplacer = (match, referenceName, postfix) => {
    const cMatch = index.find((f) => f.name.toLowerCase() === referenceName.toLowerCase());
    const replacedText = cMatch ? `@UUID[${cMatch.uuid}]{${referenceName}}` : referenceName;
    // console.warn("match", { match, document, prefix, spellName, postfix, compendium: this.spellCompendium.index, cMatch, replacedSpell });
    return `${replacedText}${postfix}`;
  };


  if (["spell", "spells"].includes(type.toLowerCase())) {
    // easiest, e.g.wand of fireballs
    const simpleStrongRegex = /(?:<strong>)([\w\s]*?)(?:<\/strong>)(\s*spell)/gi;
    text = `${text}`.replaceAll(simpleStrongRegex, referenceRegexReplacer);
    // <strong>cone of cold</strong> (5 charges)
    const chargeSpellRegex = /(?:<strong>)([\w\s]*?)(?:<\/strong>)(\s*\(\d* charge)/gi;
    text = `${text}`.replaceAll(chargeSpellRegex, referenceRegexReplacer);
  } else if (["item", "items", "magicitem", "magicitems"].includes(type)) {
    // easiest, e.g.wand of fireballs
    const simpleStrongRegex = /(?:<strong>)([\w\s]*?)(?:<\/strong>)(\s*item)/gi;
    text = `${text}`.replaceAll(simpleStrongRegex, referenceRegexReplacer);
  }

  return text;
}

function damageRollGenerator({ text, damageType, actor, document, extraMods = [] } = {}) {
  let result;
  const damageHint = damageType ? ` type=${damageType}` : "";
  const diceParse = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].parseDiceString */ .Z.parseDiceString(text, null, "");
  const baseAbility = foundry.utils.getProperty(document, "flags.monsterMunch.actionInfo.baseAbility");
  const mods = extraMods.join(" + ");

  if (baseAbility) {
    const baseAbilityMod = actor ? actor.system.abilities[baseAbility].mod : diceParse.bonus;
    const bonusMod = (diceParse.bonus && diceParse.bonus !== 0) ? diceParse.bonus - baseAbilityMod : "";
    const useMod = (diceParse.bonus && diceParse.bonus !== 0) ? " + @mod " : "";
    const finalMods = mods.length > 0
      ? `${useMod} + ${mods}`
      : useMod;

    // console.warn("RESULTS", {
    //   text,
    //   diceParse,
    //   baseAbility,
    //   baseAbilityMod,
    //   bonusMod,
    //   useMod,
    //   finalMods
    // });

    const reParse = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].diceStringResultBuild */ .Z.diceStringResultBuild(diceParse.diceMap, diceParse.dice, bonusMod, finalMods, "");
    result = `[[/damage ${reParse.diceString}${damageHint} average=true]]`;
  } else {
    // console.warn("RESULTS2", {
    //   text,
    //   diceParse,
    //   baseAbility,
    //   document,
    // });
    // const reParse = utils.diceStringResultBuild(diceParse.diceMap, diceParse.dice, undefined, mods, "");
    // result = `[[/damage ${reParse.diceString}${damageHint} average=true]]`;
    result = `[[/damage ${diceParse.diceString}${damageHint} average=true]]`;
  }

  return result;
}

// eslint-disable-next-line complexity
function parseDamageRolls({ text, document, actor } = {}) {
  // (2d8 + 3) piercing damage
  // [[/damage 2d6 fire average=true]]
  // 5 (1d4 + 3) piercing damage plus 10 (3d6) psychic damage, or 1 piercing damage plus 10 (3d6) psychic damage while under the effect of Reduce.

  const strippedHtml = _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stripHtml */ .Z.stripHtml(`${text}`).trim();

  const hitIndex = strippedHtml.indexOf("Hit:");
  let hit = (hitIndex > 0) ? strippedHtml.slice(hitIndex) : `${strippedHtml}`;
  hit = hit.split("At the end of each")[0].split("At the start of each")[0];
  hit = hit.replace(/[-]/g, "-");
  const damageExpression = new RegExp(/((?:takes\s+|plus\s+|saving throw or take\s+)|(?:[\w]*\s+))(?:([0-9]+))?(?:\s*\(?([0-9]*d[0-9]+(?:\s*[-+]\s*(?:[0-9]+|PB|the spell[']s level))*(?:\s+plus [^)]+)?)\)?)\s*([\w ]*?)\s*damage/gi);

  const matches = [...hit.matchAll(damageExpression)];
  const regainExpression = new RegExp(/(regains|regain)\s+?(?:([0-9]+))?(?: *\(?([0-9]*d[0-9]+(?:\s*[-+]\s*[0-9]+)??)\)?)?\s+hit\s+points/);

  const regainMatch = hit.match(regainExpression);

  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${document.name} Damage matches`, { hit, matches, regainMatch });

  const includesDiceRegExp = /[0-9]*d[0-9]+/;

  for (const dmg of matches) {
    if (dmg[1] == "DC " || dmg[4] == "hit points by this") {
      continue; // eslint-disable-line no-continue
    }

    const bonusMods = [];
    if (dmg[3]?.includes(" + PB") || dmg[3]?.includes(" plus PB")) bonusMods.push("@prof");
    if (dmg[3] && (/the spell[']s level/i).test(dmg[3])) bonusMods.push("@item.level");

    const damage = bonusMods.length > 0
      ? `${dmg[2]}${dmg[3].replace(" + PB", "").replace(" plus PB", "").replace(" + the spells level", "").replace(" + the spell's level", "")}`
      : dmg[3] && dmg[3].startsWith("d") // satisfies parsing where no average damage e.g. horn of blasting summary
        ? `${dmg[2] ?? ""}${dmg[3] ?? ""}`
        : dmg[3] ?? dmg[2];

    if (damage && includesDiceRegExp.test(damage)) {
      const parsedDiceDamage = damageRollGenerator({ text: damage, damageType: dmg[4], actor, document, bonusMods });
      const replaceValue = `${dmg[1]} ${parsedDiceDamage} damage`;
      // console.warn("DAMAGE PARSE", {
      //   damage,
      //   dmg,
      //   parsedDiceDamage,
      //   replaceValue,
      // });

      text = text.replace(dmg[0], replaceValue);

    } else {
      const noDiceRegex = /(\d+) (\w+) damage/i;
      const fixedDamageMatch = dmg[0].match(noDiceRegex);
      // console.warn("no dice match",{
      //   noDiceRegex,
      //   fixedDamageMatch,
      //   dmg
      // })
      if (fixedDamageMatch) {
        text = text.replace(fixedDamageMatch[0], `[[/damage ${fixedDamageMatch[1]} ${fixedDamageMatch[2]} average=false]] damage`);
      }
    }
  }

  if (regainMatch) {
    const damageValue = regainMatch[3]
      ? regainMatch[2]
        ? `${regainMatch[2]}${regainMatch[3]}`
        : regainMatch[3]
      : regainMatch[2];
    const parsedDiceDamage = Number.isInteger(parseInt(damageValue))
      ? `[[/damage ${damageValue} type=heal average=false]]`
      : damageRollGenerator({ text: damageValue, damageType: "heal", actor, document });
    const replaceValue = `${regainMatch[1]} ${parsedDiceDamage} hit points`;
    // console.warn("DAMAGE PARSE", {
    //   regainMatch,
    //   damageValue,
    //   parsedDiceDamage,
    //   replaceValue,
    // });

    text = text.replace(regainMatch[0], replaceValue);
  }

  return text;
}

function parseToHitRoll({ text, document } = {}) {

  if (!document) return text;

  const matches = utils.stripHtml(`${text}`).trim().match(
    /(?:Melee|Ranged|Melee\s+or\s+Ranged)\s+(?:|Weapon|Spell)\s*Attack:\s*([+-]\d+|your (?:\w+\s*)*)(?:,)?\s+(plus PB\s|\+ PB\s)?to\s+hit/i
  );

  const toHit = matches && Number.isInteger(parseInt(matches[1]));

  if (!toHit) return text;

  const ability = foundry.utils.getProperty(document, "flags.monsterMunch.actionInfo.baseAbility");
  const proficient = foundry.utils.getProperty(document, "flags.monsterMunch.actionInfo.proficient") ? " + @prof" : "";
  const extraNum = foundry.utils.getProperty(document, "flags.monsterMunch.actionInfo.extraAttackBonus");
  const extra = extraNum === 0 ? "" : ` + ${extraNum}`;
  const result = `[[/roll 1d20 + @abilities.${ability}.mod${proficient}${extra}]]`;

  text = text.replace(matches[1], result);

  return text;

}

function parseTags(text) {
  for (const tag of ["spell", "item", "spells", "items"]) {
    text = parseHardReferenceTag(tag, text);
  }
  const tagRegEx = /\[([^\]]+)]{?([^[}]+)}?\[\/([^\]]+)]/g;
  const matches = text.match(tagRegEx);
  if (matches) {
    return text.replaceAll(tagRegEx, replaceTag);
  }
  if (game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-loose-srd-reference-matching")) {
    const superLoose = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-super-loose-srd-reference-matching");
    text = parseLooseRuleReferences(text, superLoose);
  }
  return text;
}


async function importCacheLoad() {
  await loadDDBCompendiumIndexes();
  getRuleLookups();
}


/***/ }),

/***/ 5366:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "p": () => (/* binding */ generateTable)
});

;// CONCATENATED MODULE: ./vendor/lowdash/uniq.js
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var uniq_hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(uniq_hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    Set = getNative(root, 'Set'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return uniq_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : uniq_hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

;// CONCATENATED MODULE: ./vendor/parseTable.js
/**
 * @license
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Nick Williams
 * Copyright (c) 2021 Jack Holloway
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



/**
 * generates factory functions to convert table rows to objects,
 * based on the titles in the table's <thead>
 * @param  {Array<String>} headings the values of the table's <thead>
 * @return {(row: HTMLTableRowElement) => Object} a function that takes a table row and spits out an object
 */
function mapRow(headings, highSplit = false) {
  return function mapRowToObject({ cells }) {
    const lowCells = [...cells];
    const highCells = lowCells.length > headings.length
      ? lowCells.splice(Math.ceil(lowCells.length / 2))
      : [];
    const range = highSplit ? highCells : lowCells;

    return range.reduce((result, cell, i) => {
      const input = cell.querySelector("input,select");
      var value;

      if (input) {
        value = input.type === "checkbox" ? input.checked : input.value;
      } else {
        value = cell.innerHTML;
      }

      return Object.assign(result, { [headings[i]]: value });
    }, {});
  };
}

/**
 * given a table, generate an array of keys/column names
 *
 * @param  {HTMLTableElement} table the table to convert
 * @return {Array<String>}       array of strings representing each header in the table
 */
function getHeadings(table, unique = true) {
  if (!table.tHead || table.tHead.rows.length === 0) return [];
  const headings = [...table.tHead.rows[0].cells].map((heading) => {
    return heading.textContent;
  }); // .filter((h) => h.trim() !== "");

  if (unique) return uniq(headings);
  return headings;
}


function getRowsFromHeader(table) {
  let rows = [...table.tHead.rows];
  rows.splice(0, 1);
  return rows;
}

/**
 * given a table, generate an array of objects.
 * each object corresponds to a row in the table.
 * each object's key/value pairs correspond to a column's heading and the row's value for that column
 *
 * @param  {HTMLTableElement} table the table to convert
 * @return {Array<Object>}       array of objects representing each row in the table
 */
function parseTable(table) {
  const headings = getHeadings(table);
  const allHeadings = getHeadings(table, false);

  if (headings.length === 0) return [];
  // some tables are misformated and only have a thead and no tbody
  const rows = table.tBodies[0]
    ? [...table.tBodies[0].rows]
    : table.tHead.rows.length > 1
      ? getRowsFromHeader(table)
      : [];
  // DDB often puts d rolls alongside each other. we attempt to detect these
  const lowResults = rows.map(mapRow(headings));
  const highResults = allHeadings.length !== headings.length
    ? rows.map(mapRow(headings, true))
    : [];

  return lowResults.concat(highResults);
}


// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/DDBItemImporter.js
var DDBItemImporter = __webpack_require__(6968);
;// CONCATENATED MODULE: ./src/lib/DDBTable.js






function diceRollMatcher(match, p1, p2, p3, p4, p5) {
  if (p5 && p5.toLowerCase() === "damage") {
    let dmgString = `${p4} damage`;
    dmgString = dmgString[0].toUpperCase() + dmgString.substring(1);
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2, null, `[${p4.toLowerCase()}]`).diceString;
    return `${p1 ? p1 : ""}[[/r ${diceString} # ${dmgString}]]${p3} damage`;
  } else if (p5 && p1 && p5.toLowerCase() === "points" && p1.toLowerCase() === "regains") {
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2, null, "[healing]").diceString;
    return `${p1 ? p1 : ""}[[/r ${diceString} # Healing]]${p3} hit points`;
  } else {
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(p2).diceString;
    const result = `${p1 ? p1 : ""}[[/r ${diceString}]]${p3 ? p3 : ""} ${p4 ? p4 : ""} ${p5 ? p5 : ""}`.trim();
    return result;
  }
}

function replaceRollLinks(text) {
  text = text.replace(/[-]/gu, "-").replace(/-+/g, "-");
  const damageRegex = new RegExp(/([.>( ^]|^|regains +)?(\d*d\d+(?:\s*[+-]\s*\d*d*\d*)*)([.,<)]|$| +) *([a-z,A-Z]*) *(damage|points)?/, "g");
  text = text.replace(damageRegex, diceRollMatcher);

  // const Regex
  // to hit rolls
  const toHitRegex = new RegExp(/ ([+-]) *(\d+) to hit/, "g");
  text = text.replace(toHitRegex, " [[/r 1d20 $1 $2]] to hit");
  return text;
}

function findDiceColumns(table) {
  let result = [];
  if (table.tHead) {
    const headings = getHeadings(table);
    headings.forEach((h) => {
      const diceRegex = new RegExp(/(\d*[d|D]\d+(\s*[+-]?\s*\d*)?)/, "g");
      const match = h.replace(/[-]/gu, "-").replace(/-+/g, "-").match(diceRegex);
      if (match && !h.match(/lasts 1d10 minutes/i)) {
        result.push(h);
      }
    });
  }
  return result;
}

function guessTableName(parentName, htmlDocument, tableNum) {
  const element = htmlDocument.querySelectorAll('table');
  let track = element[tableNum];
  let sibling = track.previousElementSibling;

  while (!sibling && track.parentElement?.nodeName === "DIV") {
    if (!track.parentElement.previousElementSibling) {
      track = track.parentElement;
    } else {
      sibling = track.parentElement.previousElementSibling;
    }
  }

  if (sibling) {
    return sibling.textContent.split(".")[0];
  } else {
    logger/* default.warn */.Z.warn(`No table name identified for ${parentName}`);
    return "";
  }
}


function tableReplacer(htmlDocument, tableNum, compendiumTables, compendiumLabel) {
  // future enhancement - replace liks to DDB spells, monsters, items etc to munched compendium
  const element = htmlDocument.querySelectorAll('table');
  const tablePoint = element[tableNum];

  if (tablePoint) {
    compendiumTables.slice().reverse().forEach((table) => {
      const link = table.uuid
        ? `@UUID[${table.uuid}]`
        : `@Compendium[${compendiumLabel}.${table.name}]`;
      tablePoint.insertAdjacentHTML("afterend", `<div id="table-link">${link}{Open RollTable ${table.name}}</div>`);
    });
  }

  return htmlDocument;
}


function diceInt(text) {
  if (text === "0") return 10;
  if (text === "00") return 100;
  return parseInt(text);
}

/**
 * This could be:
 * a single value e.g. 19
 * a range of values 19-20
 * remaining values 19+
 * @param {*} value
 * @returns array of range
 */
function getDiceTableRange(value) {
  const document = utils/* default.htmlToDoc */.Z.htmlToDoc(value);
  const text = document.body.textContent.replace(/[-]/gu, "-").replace(/-+/g, "-").replace(/\s/g, "").trim();
  // eslint-disable-next-line no-useless-escape
  const valueRegex = new RegExp(/^(\d+)\-(\d+)|^(\d+)(\+?)$/);
  const valueMatch = text.match(valueRegex);

  if (valueMatch) {
    if (valueMatch[1] !== undefined && valueMatch[2] !== undefined) {
      const low = diceInt(valueMatch[1]);
      const high = diceInt(valueMatch[2]);
      return [low, high];
    }

    if (valueMatch[3]) {
      if (valueMatch[4] !== undefined && valueMatch[4] === "+") {
        const low = diceInt(valueMatch[3]);
        return [low, 0];
      }
      if (valueMatch[4] !== undefined && valueMatch[4] === "") {
        const low = diceInt(valueMatch[3]);
        return [low, low];
      }
    }
  }

  // logger.debug(`Dice range: Unable to table range match '${value}' text was '${text}'`);
  return [];
}


function buildTable({ parsedTable, keys, diceKeys, tableName, parentName, html } = {}) {
  let generatedTables = [];

  diceKeys.forEach((diceKey) => {
    const nameExtension = diceKeys > 1 ? ` [${diceKeys}]` : "";
    const realName = ((tableName && tableName !== "") ? tableName : "Unnamed Table") + nameExtension;
    logger/* default.debug */.Z.debug(`Generating table ${realName}`);

    const diceRegex = new RegExp(/(\d*d\d+(\s*[+-]?\s*\d*d*\d*)?)/, "g");
    const formulaMatch = diceKey.match(diceRegex);

    const spellCastingAttackRegex = new RegExp(/make a spell attack roll/ig);
    const spellCastingAttackMatch = diceKey.includes("d20") && spellCastingAttackRegex.test(html);

    let table = {
      "name": realName,
      "sort": 100000,
      "flags": {
        "ddbimporter": {
          "parentName": parentName,
          "keys": keys,
          "diceKeys": diceKeys
        }
      },
      "img": "icons/svg/d20-grey.svg",
      "description": "",
      "results": [],
      "formula": formulaMatch
        ? spellCastingAttackMatch
          ? "1d20 + @prof + @attributes.spellmod"
          : formulaMatch[0].trim()
        : "",
      "replacement": true,
      "displayRoll": true,
    };

    const concatKeys = (keys.length - diceKeys.length) > 1;
    // loop through rows and build result entry.
    // if more than one result key then we will concat the results.
    parsedTable.forEach((entry) => {
      const result = {
        flags: {},
        type: 0,
        text: "",
        img: "icons/svg/d20-black.svg",
        resultId: null,
        weight: 1,
        range: [],
        drawn: false,
        resultCollection: "",
      };
      Object.entries(entry).forEach(([key, value]) => {
        if (key === diceKey) {
          result.range = getDiceTableRange(value);
        } else if (diceKeys.includes(key)) return;
        if (concatKeys) {
          if (result.text != "") result.text += "\n\n";
          result.text += `<b>${key}</b>${value}`;
        } else {
          result.text = value;
        }
      });
      result.text = replaceRollLinks(result.text);
      const diceRollerRegexp = new RegExp(/\[\[\/r\s*([0-9d+-\s]*)(:?#.*)?\]\]/);
      result.text = result.text.replace(diceRollerRegexp, "[[$1]] ($&)");
      table.results.push(result);
    });

    if (table.results.some((r, i, a) => {
      const low = r.range[0];
      const high = r.range[1];
      if (low > high) {
        // console.warn(`Low ${low} is greater than high ${high}`, {
        //   low,
        //   high,
        //   a,
        //   length: a.length,
        //   i,
        // });
        if (high === 0 && i === (a.length - 1)) {
          r.range[1] += 100;
          a[i] = r;
        } else {
          return true;
        }
      }
      return false;
    })) {
      return;
    }
    generatedTables.push(table);

  });

  logger/* default.debug */.Z.debug(`Generated Tables for ${tableName}`, generatedTables);

  return generatedTables;
}


async function buildAndImportTable({ parsedTable, keys, diceKeys, finalName, name, updateExisting, html } = {}) {
  const data = buildTable({ parsedTable, keys, diceKeys, tableName: finalName, parentName: name, html });
  const handlerOptions = { srdFidding: false, updateIcons: false };
  const handler = await DDBItemImporter/* default.buildHandler */.Z.buildHandler("tables", data, updateExisting, handlerOptions);
  return handler.results;
}

async function generateTable(parentName, html, updateExisting, type = "") {
  let name = `${parentName}`;
  const document = utils/* default.htmlToDoc */.Z.htmlToDoc(html);
  const tableNodes = document.querySelectorAll("table");
  let tablesMatched = [];
  let updatedDocument = utils/* default.htmlToDoc */.Z.htmlToDoc(html);
  if (type === "background" && !name.startsWith("Background:")) {
    name = `Background: ${name}`;
  }
  if (name.startsWith("Background:")) {
    const namesArray = name.split(":");
    // if (parentNamesArray.length > 2) parentNamesArray.pop();
    name = namesArray.join(":");
  }

  const tableCompendiumLabel = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("tables");
  let tableNum = 0;
  let foundTables = [];
  for (const node of tableNodes) {
    const parsedTable = parseTable(node);
    const keys = getHeadings(node);
    const diceKeys = findDiceColumns(node);
    let nameGuess = guessTableName(name, document, tableNum);
    if (nameGuess.split(" ").length > 5 && diceKeys.length === 1 && keys.length === 2) {
      nameGuess = keys[1];
    } else if (nameGuess.trim() === "") {
      nameGuess = keys[1];
    }
    const finalName = `${name}: ${nameGuess}`;
    const tableGenerated = await CompendiumHelper/* default.queryCompendiumEntry */.Z.queryCompendiumEntry(tableCompendiumLabel, finalName, true);

    logger/* default.debug */.Z.debug(`Table detection triggered for ${name} (parentName: ${parentName})!`, {
      finalName,
      diceKeys,
      keys,
      node,
      html,
      parsedTable,
      foundTables,
      nameGuess,
      tableGenerated,
    });

    try {
      const builtTables = tableGenerated
        ? [tableGenerated]
        : await buildAndImportTable({ parsedTable, keys, diceKeys, finalName, name, updateExisting, html });

      if (builtTables.length > 0) {
        let tableData = {
          nameGuess,
          finalName,
          parentName,
          name,
          tableNum,
          uuids: builtTables.map((t) => t.uuid),
          length: parsedTable.length,
          keys: keys,
          diceKeys: diceKeys,
          diceTable: diceKeys.length > 0,
          multiDiceKeys: diceKeys.length > 1,
          diceKeysNumber: diceKeys.length,
          totalKeys: keys.length,
          builtTables: builtTables.map((t) => t.toObject()),
        };
        tablesMatched.push(tableData);
        updatedDocument = tableReplacer(updatedDocument, tableNum, builtTables, tableCompendiumLabel);
      }
    } catch (error) {
      logger/* default.error */.Z.error("Table parser failed, please log a bug!", error);
    }
    tableNum++;
  }

  return updatedDocument.body.innerHTML;
}


/***/ }),

/***/ 258:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ parseTemplateString)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1438);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5259);
/* harmony import */ var _DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7162);






function evaluateMath(obj) {
  // eslint-disable-next-line no-new-func
  return Function('"use strict";return ' + obj.replace(/\+\s*\+/g, "+"))();
}


/**
 * Parse a match and replace template values ready for evaluation
 * @param {*} ddb
 * @param {*} character
 * @param {*} match
 * @param {*} feature
 */
// eslint-disable-next-line complexity
function parseMatch(ddb, character, match, feature) {
  const featureDef = feature.definition ?? feature;
  const splitMatchAt = match.split("@");
  let result = splitMatchAt[0];
  const classOption = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]
    .flat()
    .find((option) => option.definition.id === featureDef.componentId);
  let linktext = `${result}`;

  // scalevalue
  if (result.includes("scalevalue")) {
    let scaleValue = _DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getScaleValueString */ .Z.getScaleValueString(ddb, feature);
    // if (scaleValue.value.startsWith("@")) scaleValue.value = `[[${scaleValue.value}]]{${scaleValue.name}}`;
    if (scaleValue && scaleValue.value) {
      result = result.replace("scalevalue", scaleValue.value);
      linktext = result.replace("scalevalue", " (Scaled Value) ");
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn("Unable to parse scalevalue", {
        ddb,
        feature: featureDef,
        scaleValue,
      });
    }
  }

  // savedc:int
  // savedc:str,dex
  if (result.includes("savedc")) {
    const regexp = /savedc:([a-z]{3})(?:,)?([a-z]{3})?/g;
    const matches = [...result.matchAll(regexp)];

    matches.forEach((match) => {
      const saves = match.slice(1);
      const saveDCs = saves
        .filter((save) => save)
        .map((save) => {
          return `8 + @abilities.${save}.mod + @prof`;
        });
      const saveRegexp = RegExp(match[0], "g");
      if (saveDCs.length > 1) {
        result = result.replace(saveRegexp, `max(${saveDCs.join(", ")})`);
      } else {
        result = result.replace(saveRegexp, saveDCs[0]);
      }

      linktext = result.replace(saveRegexp, " (Save DC) ");
    });
  }

  // modifier:int@min:1
  // (modifier:cha)+1
  if (result.includes("modifier")) {
    const regexp = /modifier:([a-z]{3})(?:,)?([a-z]{3})?/g;
    // creates array from match groups and dedups
    // const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];
    const matches = [...result.matchAll(regexp)];

    matches.forEach((match) => {
      const mods = match.slice(1);
      const modValues = mods
        .filter((mod) => mod)
        .map((ab) => {
          return ` + @abilities.${ab}.mod`;
        });
      const abRegexp = RegExp(match[0], "g");
      if (modValues.length > 1) {
        result = result.replace(abRegexp, `max(${modValues.join(", ")})`);
        linktext = result.replace(abRegexp, " (Modifier) ");
      } else {
        result = result.replace(abRegexp, modValues[0]);
        linktext = result.replace(abRegexp, ` (${_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(modValues[0])} Modifier) `);
      }

    });
  }

  // classlevel*5
  // (classlevel/2)@roundup
  if (result.includes("classlevel")) {
    const cls = featureDef.classId
      ? ddb.character.classes.find((cls) =>
        cls.definition.id == featureDef.classId
        || featureDef.classId === cls.subclassDefinition?.id
      )
      : _DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findClassByFeatureId */ .Z.findClassByFeatureId(ddb, featureDef.componentId);

    if (cls) {
      const clsLevel = ` + @classes.${cls.definition.name.toLowerCase().replace(" ", "-")}.levels`;
      result = result.replace("classlevel", clsLevel);
      linktext = result.replace("classlevel", ` (${cls.definition.name} Level) `);
    } else if (classOption) {
      // still not found a cls? could be an option
      const optionCls = _DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findClassByFeatureId */ .Z.findClassByFeatureId(ddb, classOption.componentId);
      if (optionCls) {
        const clsLevel = ` + @classes.${optionCls.definition.name.toLowerCase().replace(" ", "-")}.levels`;
        result = result.replace("classlevel", clsLevel);
        linktext = result.replace("classlevel", ` (${optionCls.definition.name} Level) `);
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].error */ .Z.error(
          `Unable to parse option class info. classOption ComponentId is: ${classOption.componentId}.  ComponentId is ${featureDef.componentId}`
        );
      }
    } else {
      if (!featureDef.componentId) {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Feature failed componentID parse", featureDef);
      }
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].error */ .Z.error(`Unable to parse option class info. ComponentId is ${featureDef.componentId}`);
    }
  }

  if (result.includes("characterlevel")) {
    result = result.replace("characterlevel", " + @details.level");
    linktext = result.replace("characterlevel", ` (Character Level) `);
  }

  if (result.includes("proficiency")) {
    result = result.replace("proficiency", " + @prof");
    linktext = result.replace("proficiency", ` (Proficiency Bonus) `);
  }

  // abilityscore:int
  if (result.includes("spellattack")) {
    const regexp = /spellattack:([a-z]{3})/g;
    // creates array from match groups and dedups
    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];

    ability.forEach((ab) => {
      const abRegexp = RegExp(`spellattack:${ab}`, "g");
      result = result.replace(abRegexp, ` + @abilities.${ab}.mod + @prof + @bonus.rsak.attack`);
      linktext = result.replace(abRegexp, ` (${_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(ab)} Spell Attack) `);
    });
  }

  // abilityscore:int
  if (result.includes("abilityscore")) {
    const regexp = /abilityscore:([a-z]{3})/g;
    // creates array from match groups and dedups
    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];

    ability.forEach((ab) => {
      const abRegexp = RegExp(`abilityscore:${ab}`, "g");
      result = result.replace(abRegexp, ` + @abilities.${ab}.value`);
      linktext = result.replace(abRegexp, ` (${_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].capitalize */ .Z.capitalize(ab)} Score) `);
    });
  }

  // limiteduse
  if (result.includes("limiteduse")) {
    const limitedUse = featureDef.limitedUse?.maxUses || "";
    result = result.replace("limiteduse", limitedUse);
    linktext = result.replace("limiteduse", ` (Has limited uses) `);
  }

  if (result.includes("fixedvalue:")) {
    const fvRegexp = /fixedvalue:(\d+)/g;
    result = result.replace(fvRegexp, "$1");
    linktext = result.replace(fvRegexp, "");
  }

  return {
    parsed: result,
    linktext,
  };
}

/**
 * Apply the expression constraint
 * @param {*} value
 * @param {*} constraint
 */
const applyConstraint = (value, constraint) => {
  // {{(classlevel/2)@rounddown#unsigned}}
  // @ features
  // @roundup
  // @roundown
  // min:1
  // max:3
  const splitConstraint = constraint.split(":");
  const multiConstraint = splitConstraint[0].split("*");
  const match = multiConstraint[0];

  let result = value;

  switch (match) {
    case "max": {
      result = Math.min(splitConstraint[1], result);
      break;
    }
    case "min": {
      result = Math.max(splitConstraint[1], result);
      break;
    }
    case "roundup": {
      result = Math.ceil(result);
      break;
    }
    case "rounddown":
    case "roundown": {
      result = Math.floor(result);
      break;
    }
    default: {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Missed match is ${match}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`ddb-importer does not know about template constraint {{@${constraint}}}. Please log a bug.`, { value, constraint });
    }
  }

  if (multiConstraint.length > 1) {
    const evalStatement = `${result}*${multiConstraint[1]}`;
    result = evaluateMath(evalStatement.replace(")", ""));
  }

  if (match == "unsigned") {
    result = `${result}`.trim().replace(/^\+\s*/, "");
  } else if (match == "signed") {
    if (!`${result}`.trim().startsWith("+") && !`${result}`.trim().startsWith("-")) {
      result = `+ ${result}`;
    }
  }

  return result;
};


/**
 * Apply the expression constraint
 * @param {*} result
 * @param {*} constraint
 */
const addConstraintEvaluations = (value, constraintList) => {
  let result = `${value}`;

  // {{@rounddown,max:9}}
  // {{(classlevel/2)@rounddown#unsigned}}
  // @ features
  // @roundup
  // @roundown
  // min:1
  // max:3
  constraintList.split(",").forEach((constraint) => {
    const splitConstraint = constraint.split(":");
    const multiConstraint = splitConstraint[0].split("*");
    const match = multiConstraint[0];

    switch (match) {
      case "max": {
        result = `min(${result}, ${splitConstraint[1]})`;
        break;
      }
      case "min": {
        result = `max(${result}, ${splitConstraint[1]})`;
        break;
      }
      case "roundup": {
        result = `ceil(${result})`;
        break;
      }
      case "rounddown":
      case "roundown": {
        result = `floor(${result})`;
        break;
      }
      default: {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Missed match is ${match}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`ddb-importer does not know about template constraint {{@${constraint}}}. Please log a bug.`, { value, constraint });
      }
    }

    if (multiConstraint.length > 1) {
      result = `${result}*${multiConstraint[1].replace(")", "")}`;
    }
  });

  if (typeof result === 'string') result = result.trim().replace(/^\+\s*/, "");

  return result;
};

const escapeRegExp = (string) => {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
};

const getNumber = (theNumber, signed) => {
  if (signed == "unsigned") {
    theNumber = `${theNumber}`.trim().replace(/^\+\s*/, "");
  } else if (signed == "signed" && !`${theNumber}`.trim().startsWith("+") && !`${theNumber}`.trim().startsWith("-")) {
    theNumber = `+ ${theNumber}`;
  }

  return theNumber.toString();
};


/**
 * Replaces the matched string with the appropriate value or format, based on the value of p2.
 *
 * @param {string} match - the matched string
 * @param {string} p1 - the first capturing group
 * @param {string} p2 - the second capturing group
 * @return {string} the replaced or formatted string
 */
function replaceRoll(match, p1, p2) {
  if (!p2) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`Unable to roll parse ${match}`);
    return match;
  }
  const isRollRegex = /([0-9]*d[0-9]+)|(@scale\.)/g;
  const isRollMatches = p2.match(isRollRegex);
  if (isRollMatches) {
    return match;
  } else if (Number.isInteger(parseInt(p2))) {
    return p2;
  } else {
    const prefix = p2.trim().startsWith("+") ? "+ " : "";
    return `${prefix}[[${p2}]]`;
  }
}

/**
 * Fix rollables in the given text by replacing them with the correct syntax.
 *
 * @param {string} text - The input text to be fixed.
 * @return {string} The text with corrected rollables.
 */
function fixRollables(text) {
  const diceMatchRegex = /(?:<strong>)?\+*\s*(\d*d\d\d*\s*\+*)\s*(?:<\/strong>)?\+*\s*\[\[(\/roll)?/g;
  const matches = text.match(diceMatchRegex);
  if (matches) {
    const replaceString = matches[2] ? "[[ $1 + " : "[[/roll $1 + ";
    text = text.replaceAll(diceMatchRegex, replaceString);
  }

  const noRollRegex = /(\[\[\/roll)([\w\s.,@\d+-\\*/()]*(?![0-9]*d[0-9]+)(?!@scale\.)[\w\s.,@\d-+\\*/()]*)(\]\])/g;
  // const noRollMatches = text.match(noRollRegex);
  // console.warn("noRollMatches", {text: foundry.utils.duplicate(text), noRollMatches});
  text = text.replaceAll(noRollRegex, replaceRoll);

  return text;
}

/**
 * Replaces occurrences of matchString in the text with a roll command where appropriate
 *
 * @param {string} text - the input text
 * @param {string} matchString - the string to match and replace
 * @return {string} the text with replacements
 */
function rollMatch(text, matchString) {
  const rollMatch = new RegExp(`(?:^|[ "'(+>])(\\d*d\\d\\d*\\s)({{${matchString}}})(?:$|[., "')+<])`, "g");
  return text.replace(rollMatch, (m) => `[[/roll ${m[1] !== undefined ? m[1] : ""}${m[2]}]`);
}

/**
 * This will parse a snippet/description with template boilerplate in from DDB.
 * e.g. Each creature in the area must make a DC {{savedc:con}} saving throw.
 * @param {object} ddb - The ddb object.
 * @param {object} character - The character object.
 * @param {string} text - The template string to parse.
 * @param {object} feature - The feature object.
 * @return {object} - The parsed template string result object.
 */
function parseTemplateString(ddb, character, text, feature) {
  if (!text) return text;
  const featureDefinition = feature.definition ?? feature;

  text = text.replace(/\r\n/g, "</p>\r\n<p>&bull;");
  let result = {
    id: featureDefinition.id,
    entityTypeId: featureDefinition.entityTypeId,
    componentId: featureDefinition.componentId ? featureDefinition.componentId : null,
    componentTypeId: featureDefinition.componentTypeId ? featureDefinition.componentTypeId : null,
    damageTypeId: featureDefinition.damageTypeId ? featureDefinition.damageTypeId : null,
    text,
    resultStrings: [],
    displayStrings: [],
    definitions: [],
  };

  const regexp = /{{(.*?)}}/g;
  // creates array from match groups and dedups
  const matches = [...new Set(Array.from(result.text.matchAll(regexp), (m) => m[1]))];

  // eslint-disable-next-line complexity
  matches.forEach((match) => {
    let entry = {
      parsed: null,
      match,
      replacePattern: new RegExp(`{{${escapeRegExp(match)}}}`, "g"),
      rollMatch: new RegExp(`(?:^|[ "'(+>])(\\d*d\\d\\d*\\s)({{${match}}})(?:$|[., "')+<])`, "g"),
      rollMatchTest: false,
      type: null,
      subType: null,
    };

    entry.rollMatchTest = entry.rollMatch.test(result.text);

    // console.warn("parseTemplateString", { text: foundry.utils.duplicate(text), feature, entry, match, result });

    const splitSignedBase = match.split("#");
    const splitSigned = splitSignedBase.length > 1 && ["signed", "unsigned"].includes(splitSignedBase[1])
      ? splitSignedBase
      : !match.includes("@")
        ? [match.replace("#", "@")]
        : splitSignedBase;
    const splitRemoveUnsigned = splitSigned[0];
    const signed = splitSigned.length > 1
      ? splitSigned[1]
      : match.includes("modifier")
        ? "signed"
        : null;
    const splitMatchAt = splitRemoveUnsigned.split("@");

    // console.warn("splitMatchAt", { splitMatchAt, splitRemoveUnsigned, signed, splitSigned, splitSignedBase, match });

    const parsedMatchData = parseMatch(ddb, character, splitRemoveUnsigned, feature);
    const parsedMatch = parsedMatchData.parsed;
    result.displayStrings.push(parsedMatchData);
    const dicePattern = /\d*d\d\d*/;
    const typeSplit = splitMatchAt[0].split(":");
    entry.type = typeSplit[0];

    if (typeSplit.length > 1) entry.subType = typeSplit[1];
    // do we have a dice string, e.g. sneak attack?
    if (parsedMatch.match(dicePattern) || parsedMatch.includes("@scale")) {
      if (parsedMatch.match(dicePattern)) entry.type = "dice";
      entry.parsed = parsedMatch;
      if (splitMatchAt.length > 1) {
        for (let i = 1; i < splitMatchAt.length; i++) {
          if (splitMatchAt[i].includes(")")) entry.parsed = entry.parsed.replace("(", "");
          entry.parsed = addConstraintEvaluations(entry.parsed, splitMatchAt[i]);
        }
      }
      // console.warn("entry", {
      //   entry,
      //   replacePattern: entry.replacePattern.test(result.text),
      //   match: entry.rollMatch.test(result.text),
      // });
      if (entry.rollMatchTest) {
        entry.parsed = rollMatch(text, entry.parsed);
      } else {
        entry.parsed = `[[/roll ${entry.parsed}]]`;
      }

      result.text = result.text.replace(entry.replacePattern, entry.parsed);
    } else {
      // we try and eval the expression!
      try {
        const openExpression = (parsedMatch.match(/\(/g) || []).length;
        const closeExpression = (parsedMatch.match(/\)/g) || []).length;

        let evalString = parsedMatch;
        if (openExpression != closeExpression) {
          for (let i = 0; i < openExpression - closeExpression; i++) {
            evalString = evalString.replace("(", "").trim();
          }
        }

        for (let start = evalString.startsWith("("), end = evalString.endsWith(")"); start && end; start = evalString.startsWith("("), end = evalString.endsWith(")")) {
          evalString = evalString.replace(/^\(/, "").replace(/\)$/, "");
        }
        entry.evalString = evalString;
        // console.warn("evalString", {
        //   evalString,
        //   splitMatchAt,
        // });
        if (splitMatchAt.length > 1) {
          let evalConstraint = `${evalString}`;
          for (let i = 1; i < splitMatchAt.length; i++) {
            // console.warn(`splitMatch ${i}`, {
            //   evalConstraintPre: `${evalConstraint}`,
            //   matchat: splitMatchAt[i],
            //   isInt: Number.isInteger(Number.parseInt(evalConstraint)),
            // });
            evalConstraint = Number.isInteger(Number.parseInt(evalConstraint)) && !evalConstraint.includes("@")
              ? applyConstraint(evalConstraint, splitMatchAt[i])
              : addConstraintEvaluations(evalConstraint, splitMatchAt[i]);
            // console.warn(`evalConstraint ${i} post`, `${evalConstraint}`);
          }
          // console.warn("evalConstraint", evalConstraint);
          entry.evalConstraint = evalConstraint;
          entry.parsed = getNumber(evalConstraint, signed);
        } else {
          entry.parsed = getNumber(`${evalString}`, signed);
        }
        entry.parsed = entry.parsed
          .replaceAll("+ +", "+")
          .replaceAll("++", "+")
          .replaceAll("* +", "*")
          .replaceAll(":", "");
        const isRoll = entry.rollMatchTest;
        // there are some edge cases here where some template string matches do not get the correct [[]] boxes because
        // they are not all [[/roll ]] boxes
        // I need to move the [[]] box addition to outside this process loop
        if (!isRoll && (/^\+\s/).test(entry.parsed.trim())) {
          entry.parsed = `${entry.parsed.trim().replace(/^\+\s/, "+ [[")}]]`;
        } else if (!isRoll && [undefined, null, "unsigned"].includes(signed)) {
          entry.parsed = `[[${entry.parsed.trim()}]]`;
        } else {
          if (entry.rollMatchTest) {
            entry.parsed = rollMatch(text, entry.parsed);
          } else {
            entry.parsed = `[[${entry.parsed}]]`;
          }
          _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("template string odd match", {
            result,
            entry,
            signed,
            isRoll,
          });
        }
        result.text = result.text.replace(entry.replacePattern, entry.parsed);
      } catch (err) {
        result.text = result.text.replace(entry.replacePattern, `{{${match}}}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`ddb-importer does not know about template value {{${match}}}. Please log a bug.`, err);
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(err.stack);
      }
    }
    if (entry.parsed && !entry.parsed.includes("NaN")) result.resultStrings.push(entry.parsed);
    result.definitions.push(entry);
  });

  result.text = fixRollables(result.text);
  result.text = result.text.replace(/\+\s*\+/g, "+").replace(/\+\s*\+/g, "+");
  result.text = result.text.replace(/\+<\/strong>\+/g, "+</strong>");

  result.text = (0,_DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_3__/* .parseTags */ .RN)(result.text);
  if (foundry.utils.hasProperty(character, "flags.ddbimporter.dndbeyond.templateStrings")) {
    character.flags.ddbimporter.dndbeyond.templateStrings.push(result);
  }

  // console.warn(`${feature.name} tempalte`, result);
  return result;
}


/***/ }),

/***/ 7073:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ DialogHelper)
});

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
;// CONCATENATED MODULE: ./src/lib/AdvancedDialog.js


class AdvancedDialog {

  /**
   * A class that constructs a chooser dialog with the given prompt information and buttons.
   *
   * @param {Array} inputs - An array of input fields for the dialog.
   *   @param {string} input.label - The label of the input field.
   *   @param {string} input.type - The type of the input field.
   *   @param {Array} input.options - The options of the input field. This varies depending on the type, see notes below.
   * @param {Array} buttons - An array of buttons for the dialog.
   *   @param {string} button.label - The label of the button.
   *   @param {string} button.value - The value associated with the button.
   *   @param {function} button.callback - The (optional) callback function for the button.
   * @param {object} config - The configuration object for the dialog.
   *   @param {string} config.title - The title of the dialog.
   *   @param {string} config.defaultButton - The default button label.
   *   @param {function} config.close - The callback function for closing the dialog.
   *   @param {object} config.options - Additional options for the foundry Dialog.
   *   @param {function} config.render - Optional function to pass to render call for Dialog.
   */
  constructor(inputs = [], buttons = [], // prompt information
    { title = "", defaultButton = "OK", close = (resolve) => resolve({ success: false }), options = {}, render = null } = {}, // dialog config
  ) {
    this.inputs = inputs;
    this.buttons = buttons;
    this.dialog = null;

    this.config = {
      title,
      defaultButtonLabel: defaultButton,
      close,
      options,
      render,
      classes: ["dialog", "ddb-advanced-dialog"],
    };
  }

  /**
   * Generates the table header label HTML element with the specified ID and label text.
   *
   * @param {type} id - The ID of the input element associated with the label.
   * @param {type} label - The text to be displayed as the label.
   * @return {string} The generated HTML for the table header label.
   */
  static _generateTableHeaderLabel(id, label) {
    return `<th><label for="ddb-${id}">${label}</label></th>`;
  }

  /**
   * Generates the HTML stub for a selection element based on the given type, label, options, and index.
   *
   * @param {string} type - The type of the selection element.
   * @param {string} label - The label of the selection element.
   * @param {array} options - The options for the selection element.
   * @param {number} idx - The index of the selection element.
   * @return {string} The HTML stub for the selection element.
   */
  static _generateSelectionHtmlStub(type, label, options, idx) {
    const thLabel = AdvancedDialog._generateTableHeaderLabel(idx, label);
    switch (type.toLowerCase()) {
      case "button":
        return "";
      case "checkbox": {
        const checked = options?.checked ? "checked" : "";
        return `${thLabel}<td><input type="${type}" id="ddb-${idx}" ${checked} value="${idx}"/></td>`;
      }
      case "label":
        return `<td class="colspan2">${label}</td>`;
      case "radio": {
        const checked = options?.checked ? "checked" : "";
        const group = options?.group ?? "radio";
        return `${thLabel}<td><input type="${type}" id="ddb-${idx}" ${checked} value="${idx}" name="${group}"/></td>`;
      }
      case "select": {
        const optionString = options
          .map((entry, idx) => {
            const selected = entry.selected ? "selected" : "";
            return `<option value="${idx}" ${selected}>${entry.label}</option>`;
          })
          .join("\n");
        return `${thLabel}<td><select id="ddb-${idx}">${optionString}</select></td>`;
      }
      case "number": {
        let value = "";
        if (utils/* default.isObject */.Z.isObject(options)) {
          const values = [];
          for (const [key, v] of Object.entries(options)) {
            const stringValue = `${v}`.trim();
            values.push(`${key}="${stringValue}"`);
          }
          value = values.join(" ");
        } else if (Array.isArray(options)) {
          const values = [];
          for (const option of options) {
            values.push(`${option.key}="${option.value}"`);
          }
          value = values.join(" ");
        } else if (utils/* default.isString */.Z.isString(options)) {
          value = `value="${options}"`;
        } else {
          value = `value=""`;
        }
        return `${thLabel}</th><td><input type="${type}" id="ddb-${idx}" ${value}/></td>`;
      }
      default: {
        const value = Array.isArray(options) ? options[0] : options;
        return `${thLabel}</th><td><input type="${type}" id="ddb-${idx}" value="${value}"/></td>`;
      }
    }
  }


  /**
   * Generate the HTML for the selection table.
   *
   * @param {Array} data - An array of objects containing type, label, and options.
   * @return {string} The generated HTML.
   */
  _generateSelectionHtml() {
    return [
      `<table class="ddb-selection-table">`,
      ...this.inputs.map(({ type, label, options }, id) => {
        const rowContent = AdvancedDialog._generateSelectionHtmlStub(type, label, options, id);
        return `<tr>${rowContent}</tr>`;
      }),
      `</table>`
    ].join(`\n`);
  };


  /**
   * Parses the selection results based on the given inputs, HTML, and checked text.
   *
   * @param {HTMLElement} html - The HTML element to parse.
   * @return {Array} The parsed selection results.
   */
  _parseSelectionResults(html) {
    const results = this.inputs
      .map((input, idx) => {
        switch (input.type.toLowerCase()) {
          case "label":
            return null;
          case "radio":
          case "checkbox": {
            return html.find(`input#ddb-${idx}`)[0].checked;
          }
          case "number":
            return html.find(`input#ddb-${idx}`)[0].valueAsNumber;
          case "select":
            // the value is the index of the selected option
            return input.options[html.find(`select#ddb-${idx}`).val()].value;
          default:
            return html.find(`input#ddb-${idx}`)[0].value;
        }
      });
    return results;
  }

}


class ChooserDialog extends AdvancedDialog {

  /**
   * Asynchronously waits for the dialog choices to be made or closed.
   *
   * @return {Promise} A promise that resolves when the action is completed.
   * @example
   *  let dialog = new DDBImporter.DialogHelper.ChooserDialog([{
   *      label: 'Group 1 Radio Label 1',
   *      type: 'radio',
   *      options: {
   *        group: 'group1',
   *      },
   *    }, {
   *      label: 'Group 1 Radio Label 2',
   *      type: 'radio',
   *      options: {
   *        group: 'group1',
   *        checked: true,
   *      },
   *    },
   *    {
   *      label: 'Group 2 Radio Label 1',
   *      type: 'radio',
   *      options: {
   *        group: 'group2',
   *      },
   *    },
   *    {
   *      label: 'Group 2 Radio Label 2',
   *      type: 'radio',
   *      options: {
   *        group: 'group2',
   *      },
   *    },
   *    {
   *      label: 'Default Group Radio Label 1',
   *      type: 'radio',
   *    },
   *    {
   *      label: 'Default Group Radio Label 2',
   *      type: 'radio',
   *    },
   *    {
   *      label: 'Checkbox Label',
   *      type: 'checkbox',
   *      options: {
   *        checked: true,
   *      },
   *    },{
   *      type: 'select',
   *      label: 'Select Dialog Label',
   *      options: [
   *          { label: 'String Option', value: "option1" },
   *          { label: 'Map Option', value: { valuesCanBeObjects: true }, selected:true },
   *          { label: 'Int Option', value: 3 },
   *      ],
   *    }],
   *    [{
   *      label: "Yes",
   *      value: "yes",
   *      callback: () => console.log("Yes was clicked"),
   *    }, {
   *      label: "No",
   *      value: "no"
   *    }, {
   *      label: "<b>Callback Function</b>",
   *      value: "html",
   *      default: true,
   *      callback: (results) => {
   *        console.warn(results);
   *        results.extra =  {
   *          a: 1,
   *          b: 2,
   *        };
   *        console.log("Adding some extra data");
   *      },
   *    }],
   *    {
   *     title: 'A wrapped choice dialog',
   *      options: {
   *        width: 450,
   *      }
   *    });
   *
   *  let result = await d.ask();
   */
  async ask() {
    return new Promise((resolve) => {

      const buttonObject = (this.buttons.length > 0)
        ? this.buttons.reduce((o, button) => ({
          ...o,
          [button.label]: {
            label: button.label,
            callback: (html) => {
              const results = {
                button,
                results: this._parseSelectionResults(html),
                inputs: this.inputs,
                success: true,
              };
              if (utils/* default.isFunction */.Z.isFunction(button.callback)) {
                // button.callback(results, html).then(() => {
                //   console.warn("Callbacj resykts", results);
                //   resolve(results);
                // });
                resolve(button.callback(results, html));
              } else {
                resolve(results);
              }
            },
          }
        }), {})
        // inserts default button
        : {
          defaultButton: {
            label: this.config.defaultButtonLabel,
            callback: (html) =>
              resolve({
                button: { value: "default", label: this.config.defaultButtonLabel },
                results: this._parseSelectionResults(html),
                inputs: this.inputs,
                success: true,
              }),
          }
        };

      this.dialog = new Dialog(
        {
          title: this.config.title,
          content: this._generateSelectionHtml(),
          default: this.buttons.find((b) => b.default)?.label ?? this.config.defaultButtonLabel,
          close: (...abc) => this.config.close(resolve, ...abc),
          buttons: buttonObject,
          render: this.config.render,
        },
        {
          classes: this.config.classes,
          focus: true,
          ...this.config.options
        }
      );
      this.dialog.render(true);
    });
  }

  static async Ask(...args) {
    const dialog = new ChooserDialog(...args);
    return dialog.ask();
  }
}

;// CONCATENATED MODULE: ./src/lib/DialogHelper.js


class DialogHelper {

  /**
   * Generates a dialog with buttons and options in the specified direction.
   *
   * @param {Object} options - An object containing the dialog options.
   *   @param {string} options.title - The title of the dialog.
   *   @param {string} options.content - The content of the dialog.
   *   @param {Array} options.buttons - An array of buttons for the dialog.
   *     @param {Object} button - An object representing a button.
   *       @param {string} button.label - The label of the button.
   *       @param {string} button.value - The value associated with the button.
   *   @param {Object} options.options - Additional options to pass to the dialog.
   * @param {string} direction - The direction of the dialog buttons.
   * @return {Promise} A promise that resolves with the button value or rejects with an error.
   *
   *     @example
     const selected = await DDBImporter.EffectHelper.buttonDialog(
       {
        buttons: [{ label: "Label1", value: "Value1"}, {label: "Label2", value: "Value2" }],
        title: "A title",
        content: "Some <b>bold</b> content"
      },
      'row'
     );
     console.warn(`You selected ${selected}`);
   */
  static async buttonDialog({ title = "", content = "", buttons, options = { height: "auto" } } = {}, direction = "row") {

    return new Promise((resolve) => {
      new Dialog(
        {
          title,
          content,
          buttons: buttons.reduce((o, button) => ({
            ...o,
            [button.label]: { label: button.label, callback: () => resolve(button.value) }
          }), {}),
          close: () => resolve(this),
        },
        {
          classes: ["dialog", `ddb-button-dialog-${direction}`],
          ...options,
        }
      ).render(true);
    });
  }

  static ChooserDialog = ChooserDialog;

  static async AskUserButtonDialog(user, ...buttonArgs) {
    return globalThis.DDBImporter.socket.executeAsUser("simpleButtonDialog", user, ...buttonArgs);
  }

  static async AskUserChooserDialog(user, ...dialogArgs) {
    return globalThis.DDBImporter.socket.executeAsUser("chooserDialog", user, ...dialogArgs);
  }
}


/***/ }),

/***/ 4222:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": () => (/* binding */ DirectoryPicker)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7669);
/**
 * Game Settings: Directory
 */




class DirectoryPicker extends FilePicker {
  constructor(options = {}) {
    super(options);
  }

  _onSubmit(event) {
    event.preventDefault();
    const path = event.target.target.value;
    const activeSource = this.activeSource;
    const bucket = this.sources.s3?.bucket && this.sources.s3.bucket !== ""
      ? this.sources.s3.bucket
      : null;

    // console.warn("Clicked", {
    //   event,
    //   bucket,
    //   target: event.target.bucket,
    //   targetTargget: event.target.target,
    //   path,
    //   pathv12,
    //   currentTarget,
    //   currentTargetValue: currentTarget.value,
    //   activeSource,
    //   thisBucket: this.sources.s3.bucket,
    // })

    this.field.value = DirectoryPicker.format({
      activeSource,
      bucket,
      path,
    });
    this.close();
  }

  static async uploadToPath(path, file) {
    const options = DirectoryPicker.parse(path);
    return FilePicker.upload(options.activeSource, options.current, file, { bucket: options.bucket }, { notify: false });
  }

  // returns the type "Directory" for rendering the SettingsConfig
  static Directory(val) {
    return val;
  }

  // formats the data into a string for saving it as a GameSetting
  static format(value) {
    return value.bucket !== null && value.bucket !== ""
      ? `[${value.activeSource}:${value.bucket}] ${value.path ?? value.current ?? ""}`
      : `[${value.activeSource}] ${value.path ?? value.current ?? ""}`;
  }

  // parses the string back to something the FilePicker can understand as an option
  static parse(str) {
    let matches = str.match(/\[(.+)\]\s*(.+)/);
    if (matches) {
      let source = matches[1];
      const current = matches[2].trim();
      const [s3, bucket] = source.split(":");
      if (bucket !== undefined) {
        return {
          activeSource: s3,
          bucket: bucket,
          current: current,
          fullPath: str,
        };
      } else {
        return {
          activeSource: s3,
          bucket: null,
          current: current,
          fullPath: str,
        };
      }
    }
    // failsave, try it at least
    return {
      activeSource: "data",
      bucket: null,
      current: str,
    };
  }

  // Adds a FilePicker-Simulator-Button next to the input fields
  static processHtml(html) {
    $(html)
      .find(`input[data-dtype="Directory"], .ddb-directory`)
      .each((index, element) => {
        // disable the input field raw editing
        $(element).prop("readonly", true);

        // if there is no button next to this input element yet, we add it
        if (!$(element).next().length) {
          let picker = new DirectoryPicker({
            field: $(element)[0],
            ...DirectoryPicker.parse($(element).val()),
          });
          let pickerButton = $(
            '<button type="button" class="file-picker" data-type="imagevideo" data-target="img" title="Pick directory"><i class="fas fa-file-import fa-fw"></i></button>'
          );
          pickerButton.on("click", () => {
            picker.render(true);
          });
          $(element).parent().append(pickerButton);
        }
      });
  }

  /** @override */
  activateListeners(html) {
    super.activateListeners(html);

    // remove unnecessary elements
    $(html).find("ol.files-list").remove();
    $(html).find("footer div").remove();
    $(html).find("footer button").text("Select Directory");
  }

  static async forgeCreateDirectory(target) {
    if (!target) return undefined;
    const response = await ForgeAPI.call('assets/new-folder', { path: target });
    if (!response || response.error) {
      throw new Error(response ? response.error : "Unknown error while creating directory.");
    }
    return response;
  }

  /**
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async createDirectory(source, target, options = {}) {
    if (!target) {
      throw new Error("No directory name provided");
    }
    if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
      return DirectoryPicker.forgeCreateDirectory(target);
    }
    return FilePicker.createDirectory(source, target, options);
  }

  /**
   * Verifies server path exists, and if it doesn't creates it.
   *
   * @param  {object} parsedPath - output from DirectoryPicker,parse
   * @param  {string} targetPath - if set will check this path, else check parsedPath.current
   * @returns {boolean} - true if verfied, false if unable to create/verify
   */
  static async verifyPath(parsedPath, targetPath = null) {
    try {
      if (CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(parsedPath.fullPath)) return true;
      const paths = (targetPath) ? targetPath.split("/") : parsedPath.current.split("/");
      let currentSource = paths[0];

      for (let i = 0; i < paths.length; i += 1) {
        try {
          if (currentSource !== paths[i]) {
            currentSource = `${currentSource}/${paths[i]}`;
          }
          await DirectoryPicker.createDirectory(parsedPath.activeSource, `${currentSource}`, { bucket: parsedPath.bucket });
        } catch (err) {
          const errMessage = `${(err?.message ?? _utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].isString */ .Z.isString(err) ? err : err)}`.replace(/^Error: /, "").trim();
          // if (errMessage.startsWith("EEXIST")) {
          //   const newBrowsePath = DirectoryPicker.format({
          //     activeSource: parsedPath.activeSource,
          //     bucket: parsedPath.bucket,
          //     current: currentSource,
          //   });
          //   console.warn("about to check files on existing folder", newBrowsePath);
          //   await FileHelper.generateCurrentFiles(newBrowsePath);
          // }
          if (!errMessage.startsWith("EEXIST") && !errMessage.startsWith("The S3 key")) {
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Error trying to verify path [${parsedPath.activeSource}], ${parsedPath.current}`, err);
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("parsedPath", parsedPath);
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("targetPath", targetPath);
          }
        }
      }
    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Unable to verify path", err);
      return false;
    }

    return true;
  }

  static async verifyDirectory(parsedPath, targetPath = null) {
    if (CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(parsedPath.fullPath)) return true;
    return DirectoryPicker.verifyPath(parsedPath, targetPath);
  }

  /**
   * Browse files using Forge API
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async browseForgeFiles(source, target, options = {}) {
    if (target.startsWith(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX)) {
      if (options.wildcard)
        options.wildcard = target;
      target = target.slice(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX.length);
      target = target.split("/").slice(1, -1).join("/"); // Remove userid from url to get target path
    }

    const response = await ForgeAPI.call('assets/browse', { path: decodeURIComponent(target), options });
    if (!response || response.error) {
      ui.notifications.error(response ? response.error : "An unknown error occured accessing The Forge API");
      return { target, dirs: [], files: [], gridSize: null, private: false, privateDirs: [], extensions: options.extensions };
    }
    // Should be decodeURIComponent but FilePicker's _onPick needs to do encodeURIComponent too, but on each separate path.
    response.target = decodeURI(response.folder);
    delete response.folder;
    response.dirs = response.dirs.map((d) => d.path.slice(0, -1));
    response.files = response.files.map((f) => f.url);
    // 0.5.6 specific
    response.private = true;
    response.privateDirs = [];
    response.gridSize = null;
    response.extensions = options.extensions;
    return response;
  }

  /**
   * Browse files using FilePicker
   * @param  {string} source
   * @param  {string} target
   * @param  {object} options={}
   */
  static async browseFiles(source, target, options = {}) {
    if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
      if (target.startsWith(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX)) source = "forgevtt";

      if (source === "forgevtt") {
        return DirectoryPicker.browseForgeFiles(source, target, options);
      }
    }

    return FilePicker.browse(source, target, options);
  }
}


/***/ }),

/***/ 2397:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4222);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);
/* harmony import */ var _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(546);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7669);






const FileHelper = {
  BAD_DIRS: ["[data]", "[data] ", "", null],

  removeFileExtension: (name) => {
    let nameArray = name.split(".");
    nameArray.pop();
    return nameArray.join(".");
  },


  /**
   * Read data from a user provided File object
   * @param {File} file           A File object
   * @return {Promise.<String>}   A Promise which resolves to the loaded text data
   */
  readBlobFromFile: (file) => {
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
      reader.onload = () => {
        resolve(reader.result);
      };
      reader.onerror = () => {
        reader.abort();
        reject();
      };
      reader.readAsBinaryString(file);
    });
  },

  download: (content, fileName, contentType) => {
    let a = document.createElement("a");
    let file = new Blob([content], { type: contentType });
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
  },

  addFileToKnown: (parsedDir, file) => {
    CONFIG.DDBI.KNOWN.FILES.add(file);
    const split = file.split(parsedDir.current);
    if (split.length > 1) {
      const fileName = split[1].startsWith("/") ? split[1] : `/${split[1]}`;
      CONFIG.DDBI.KNOWN.FILES.add(`${parsedDir.fullPath}${fileName}`);
      CONFIG.DDBI.KNOWN.LOOKUPS.set(`${parsedDir.fullPath}${fileName}`, file);
    }
  },

  fileExistsUpdate: (parsedDir, fileList) => {
    const targetFiles = fileList.filter((f) => !CONFIG.DDBI.KNOWN.FILES.has(f));
    for (const file of targetFiles) {
      FileHelper.addFileToKnown(parsedDir, file);
    }
  },

  dirExistsUpdate: (dirList) => {
    const targetFiles = dirList.filter((f) => !CONFIG.DDBI.KNOWN.DIRS.has(f));
    for (const file of targetFiles) {
      CONFIG.DDBI.KNOWN.DIRS.add(file);
    }
  },

  doesDirExist: async (directoryPath) => {
    const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
    try {
      await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.browse */ .B.browse(dir.activeSource, dir.current, {
        bucket: dir.bucket,
      });
      return true;
    } catch (error) {
      return false;
    }
  },

  generateCurrentFilesFromParsedDir: async (parsedDir) => {
    if (!CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(parsedDir.fullPath)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for files in ${parsedDir.fullPath}...`, parsedDir);
      const fileList = await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.browse */ .B.browse(parsedDir.activeSource, parsedDir.current, {
        bucket: parsedDir.bucket,
      });
      FileHelper.fileExistsUpdate(parsedDir, fileList.files);
      FileHelper.dirExistsUpdate(fileList.dirs);
      // lets do some forge fun because
      if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
        if (fileList.bazaar) {
          // eslint-disable-next-line require-atomic-updates
          CONFIG.DDBI.KNOWN.FORGE.TARGETS[parsedDir.fullPath] = {};
          fileList.files.forEach((file) => {
            const fileName = file.split("/").pop();
            CONFIG.DDBI.KNOWN.FORGE.TARGETS[parsedDir.fullPath][fileName] = file;
            FileHelper.addFileToKnown(parsedDir, file);
          });
        } else {
          const status = ForgeAPI.lastStatus || (await ForgeAPI.status());
          const userId = status.user;
          // eslint-disable-next-line require-atomic-updates
          CONFIG.DDBI.KNOWN.FORGE.TARGET_URL_PREFIX[parsedDir.fullPath] = `https://assets.forge-vtt.com/${userId}/${parsedDir.current}`;
        }
      }

      CONFIG.DDBI.KNOWN.CHECKED_DIRS.add(parsedDir.fullPath);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Skipping full dir scan for ${parsedDir.fullPath}...`);
    }
  },

  generateCurrentFiles: async (directoryPath) => {
    if (!CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(directoryPath)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for files in directoryPath ${directoryPath}...`);
      const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
      await FileHelper.generateCurrentFilesFromParsedDir(dir);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Skipping full dir scan for ${directoryPath}...`);
    }
  },

  fileExists: async (directoryPath, filename) => {
    const fileRef = `${directoryPath}/${filename}`;
    let existingFile = CONFIG.DDBI.KNOWN.FILES.has(fileRef);
    if (existingFile) return true;

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking for ${filename} at ${fileRef}...`);
    await FileHelper.generateCurrentFiles(directoryPath);

    const filePresent = CONFIG.DDBI.KNOWN.FILES.has(fileRef);

    if (filePresent) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Found ${fileRef} after directory scan.`);
    } else {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Could not find ${fileRef}`, {
        directoryPath,
        filename,
        fileUrl: fileRef,
      });
    }

    return filePresent;
  },

  convertImageToWebp: async function (file, filename) {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Converting file ${filename} to webp`);

    // Load the data into an image
    const result = new Promise((resolve) => {
      let rawImage = new Image();

      rawImage.addEventListener("load", () => {
        resolve(rawImage);
      });

      rawImage.src = URL.createObjectURL(file);
    })
      .then((rawImage) => {
        // Convert image to webp ObjectURL via a canvas blob
        return new Promise((resolve) => {
          let canvas = document.createElement("canvas");
          let ctx = canvas.getContext("2d");
          const quality = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "webp-quality");

          canvas.width = rawImage.width;
          canvas.height = rawImage.height;
          ctx.drawImage(rawImage, 0, 0);

          canvas.toBlob((blob) => {
            resolve(blob);
          }, "image/webp", quality);
        });
      }).then((blob) => {
        return blob;
      });

    return result;
  },

  uploadFile: async function (data, path, filename, forceWebp = false) {
    const useWebP = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp");
    const file = new File([data], filename, { type: data.type });
    const imageType = data.type.startsWith("image") && data.type !== "image/webp";
    const uploadFile = useWebP && (imageType || forceWebp)
      ? new File([await FileHelper.convertImageToWebp(file, filename)], filename, { type: "image/webp" })
      : file;

    const result = await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.uploadToPath */ .B.uploadToPath(path, uploadFile);
    return result;
  },

  uploadImage: async function (data, path, filename, forceWebp = false) {
    return new Promise((resolve, reject) => {
      FileHelper.uploadFile(data, path, filename, forceWebp)
        .then((result) => {
          resolve(result.path);
        })
        .catch((error) => {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("error uploading file: ", error);
          reject(error);
        });
    });
  },

  downloadImage: async function (url) {
    return new Promise((resolve, reject) => {
      fetch(url, {
        method: "GET",
        headers: {
          "x-requested-with": "foundry"
        },
      })
        .then((response) => {
          if (!response.ok) {
            reject("Could not retrieve image");
          }
          return response.blob();
        })
        .then((blob) => resolve(blob))
        .catch((error) => reject(error.message));
    });
  },

  uploadRemoteImage: async function (originalUrl, targetDirectory, baseFilename, useProxy = true) {
    // prepare filenames
    const filename = baseFilename;
    const useWebP = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp");
    const ext = useWebP
      ? "webp"
      : originalUrl
        .split(".")
        .pop()
        .split(/#|\?|&/)[0];
    const urlEncode = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cors-encode");
    const stripProtocol = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cors-strip-protocol");
    const corsPathPrefix = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cors-path-prefix");
    let url = originalUrl.split("?")[0];

    try {
      const proxyEndpoint = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCORSProxy */ .Z.getCORSProxy();
      const fiddledUrl = stripProtocol ? url.replace(/^https:\/\//, corsPathPrefix) : `${corsPathPrefix}${url}`;
      const target = urlEncode ? encodeURIComponent(fiddledUrl) : fiddledUrl;
      url = useProxy ? proxyEndpoint + target : url;
      const data = await FileHelper.downloadImage(url);
      // hack as proxy returns ddb access denied as application/xml
      if (data.type === "application/xml") return null;
      const result = await FileHelper.uploadImage(data, targetDirectory, filename + "." + ext);
      FileHelper.addFileToKnown(_lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(targetDirectory), result);
      CONFIG.DDBI.KNOWN.LOOKUPS.set(`${targetDirectory}/${baseFilename}`, result);
      return result;
    } catch (error) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("Image upload error", error);
      ui.notifications.warn(`Image upload failed. Please check your ddb-importer upload folder setting. ${originalUrl}`);
      return null;
    }
  },

  getForgeUrl: async (directoryPath, filename) => {
    let uri;
    if (!CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(directoryPath)) {
      await FileHelper.generateCurrentFiles(directoryPath);
    }
    const prefix = CONFIG.DDBI.KNOWN.FORGE.TARGET_URL_PREFIX[directoryPath];
    const bazaarTargetPath = CONFIG.DDBI.KNOWN.FORGE.TARGETS[directoryPath];
    const bazaarTarget = bazaarTargetPath ? bazaarTargetPath[filename] : undefined;
    if (bazaarTarget) {
      uri = bazaarTarget;
    } else if (prefix) {
      uri = `${prefix}/${filename}`;
    } else {
      // we can't find the directory path for some reason, final fallback, try and guess the url
      const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
      if (dir.activeSource == "data") {
        // Local on-server file system
        uri = `https://assets.forge-vtt.com/bazaar/${dir.current}/${filename}`;
      } else if (dir.activeSource == "forgevtt") {
        const status = ForgeAPI.lastStatus || (await ForgeAPI.status());
        const userId = status.user;
        uri = `https://assets.forge-vtt.com/${userId}/${dir.current}/${filename}`;
      }
    }
    return uri;
  },

  getFileUrl: async (directoryPath, filename) => {
    let uri;
    try {
      if (typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge) {
        uri = await FileHelper.getForgeUrl(directoryPath, filename);
        return uri;
      } else {
        const dir = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(directoryPath);
        if (dir.activeSource == "data") {
          // Local on-server file system
          uri = dir.current + "/" + filename;
        } else if (dir.activeSource == "forgevtt") {
          const status = ForgeAPI.lastStatus || (await ForgeAPI.status());
          const userId = status.user;
          uri = `https://assets.forge-vtt.com/${userId}/${dir.current}/${filename}`;
        } else if (dir.activeSource == "s3") {
          // S3 Bucket
          uri = `https://${dir.bucket}.${game.data.files.s3.endpoint.hostname}/${dir.current}/${filename}`;
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("DDB Importer cannot handle files stored in that location", dir);
        }
      }
    } catch (exception) {
      throw new Error(`Unable to determine file URL for directoryPath "${directoryPath}" and filename "${filename}"`);
    }
    return encodeURI(uri);
  },

  getImagePath: async (imageUrl, { type = "ddb", imageNamePrefix = "", name = undefined, download = false,
    remoteImages = false, force = false, pathPostfix = "", targetDirectory = undefined } = {}
  ) => {
    if (!name || !targetDirectory) {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`You must supply a targetDirectory and name for the image ${imageUrl}`, { name, targetDirectory, type });
      throw new Error(`You must supply a targetDirectory and name for the image ${imageUrl}`);
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Getting image path for ${imageUrl}`, {
      type,
      imageNamePrefix,
      name,
      download,
      remoteImages,
      force,
      pathPostfix,
      targetDirectory,
    });
    const uploadDirectory = `${targetDirectory}${pathPostfix}`;
    if (!CONFIG.DDBI.KNOWN.CHECKED_DIRS.has(uploadDirectory)) {
      const parsedPath = _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.parse */ .B.parse(uploadDirectory);
      await _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.verifyPath */ .B.verifyPath(parsedPath);
      await FileHelper.generateCurrentFilesFromParsedDir(parsedPath);
    }
    const downloadImage = (download) ? download : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-download-images");
    const remoteImage = (remoteImages) ? remoteImages : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-remote-images");
    const useWebP = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-webp");

    if (imageUrl && downloadImage) {
      const ext = useWebP
        ? "webp"
        : imageUrl.split(".").pop().split(/#|\?|&/)[0];
      if (!name) name = imageUrl.split("/").pop();

      // image upload
      const fileNamePrefix = !imageNamePrefix || imageNamePrefix.trim() === "" ? "" : `${imageNamePrefix}-`;
      const filename = `${fileNamePrefix}${_utils_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].referenceNameString */ .Z.referenceNameString(name)}`;
      const imageExists = await FileHelper.fileExists(uploadDirectory, filename + "." + ext);

      if (imageExists && !force) {
        // eslint-disable-next-line require-atomic-updates
        // const image = await FileHelper.getFileUrl(uploadDirectory, filename + "." + ext);
        const image = CONFIG.DDBI.KNOWN.LOOKUPS.get(`${uploadDirectory}/${filename}.${ext}`);
        return image.trim();
      } else {
        // eslint-disable-next-line require-atomic-updates
        const image = await FileHelper.uploadRemoteImage(imageUrl, uploadDirectory, filename);
        // did upload succeed? if not fall back to remote image path
        if (image) {
          return image.trim();
        } else {
          return null;
        }

      }
    } else if (imageUrl && remoteImage) {
      try {
        return imageUrl.trim();
      } catch (ignored) {
        return null;
      }
    }
    return null;
  },

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileHelper);


/***/ }),

/***/ 7407:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ FolderHelper)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6968);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);





class FolderHelper {

  static async getOrCreateFolder (root, entityType, folderName, folderColor = "") {
    let folder = game.folders.contents.find((f) =>
      f.type === entityType && f.name === folderName
      // if a root folder we want to match the root id for the parent folder
      && (root ? root.id : null) === (f.folder?.id ?? null)
    );
    // console.warn(`Looking for ${root} ${entityType} ${folderName}`);
    // console.warn(folder);
    if (folder) return folder;
    folder = await Folder.create(
      {
        name: folderName,
        type: entityType,
        color: folderColor,
        parent: (root) ? root.id : null,
      },
      { displaySheet: false }
    );
    return folder;
  }

  // eslint-disable-next-line no-unused-vars
  static async getFolder(kind, subFolder = "", baseFolderName = "D&D Beyond Import", baseColor = "#6f0006", subColor = "#98020a", typeFolder = true) {
    const entityTypes = _utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].entityMap */ .Z.entityMap();
    const folderName = game.i18n.localize(`ddb-importer.item-type.${kind}`);
    const entityType = entityTypes.get(kind);
    const baseFolder = await FolderHelper.getOrCreateFolder(null, entityType, baseFolderName, baseColor);
    const entityFolder = typeFolder
      ? await FolderHelper.getOrCreateFolder(baseFolder, entityType, folderName, subColor)
      : baseFolder;
    if (subFolder !== "") {
      const subFolderName = subFolder.charAt(0).toUpperCase() + subFolder.slice(1);
      const typeFolder = await FolderHelper.getOrCreateFolder(entityFolder, entityType, subFolderName, subColor);
      return typeFolder;
    } else {
      return entityFolder;
    }
  }

  /**
   * Retrieves the folder ID of a compendium with a given name within a specified compendium.
   *
   * @param {string} name - The name of the folder to search for.
   * @param {string} compendiumName - The name of the compendium to search within.
   * @return {Promise<string|undefined>} The ID of the folder if found, otherwise undefined.
   */
  static async getCompendiumFolderId(name, compendiumName) {
    const compendium = game.packs.get(compendiumName);
    return compendium.folders.find((f) => f.name === name)?._id;
  }

  /**
   * Updates game folder items
   * @param {*} type
   */
  static async updateFolderItems(type, input, update = true) {
    const folderLookup = _settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].GAME_FOLDER_LOOKUPS.find */ .Z.GAME_FOLDER_LOOKUPS.find((c) => c.type == type);
    const itemFolderNames = [...new Set(input[type]
      .filter((item) => item.flags?.ddbimporter?.dndbeyond?.lookupName)
      .map((item) => item.flags.ddbimporter.dndbeyond.lookupName))];

    const getSubFolders = async () => {
      return Promise.all(
        itemFolderNames.map((name) => {
          return FolderHelper.getFolder(folderLookup.folder, name);
        })
      );
    };

    const subFolders = await getSubFolders();

    const defaultItemsFolder = await FolderHelper.getFolder(folderLookup.folder);
    const existingItems = await game.items.entities.filter((item) => {
      const itemFolder = subFolders.find((folder) =>
        item.flags?.ddbimporter?.dndbeyond?.lookupName
        && folder.name === item.flags.ddbimporter.dndbeyond.lookupName
      );
      return itemFolder && item.type === folderLookup.itemType && item.folder === itemFolder._id;
    });

    // update or create folder items
    const updateItems = async () => {
      return Promise.all(
        input[type]
          .filter((item) => existingItems.some((idx) => idx.name === item.name))
          .map(async (item) => {
            const existingItem = await existingItems.find((existing) => item.name === existing.name);
            item._id = existingItem._id;
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Updating ${type} ${item.name}`);
            _DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].copySupportedItemFlags */ .Z.copySupportedItemFlags(existingItem, item);
            await Item.update(item);
            return item;
          })
      );
    };

    const createItems = async () => {
      return Promise.all(
        input[type]
          .filter((item) => !existingItems.some((idx) => idx.name === item.name))
          .map(async (item) => {
            if (!game.user.can("ITEM_CREATE")) {
              ui.notifications.warn(`Cannot create ${folderLookup.type} ${item.name} for ${type}`);
            } else {
              _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Creating ${type} ${item.name}`);
              const itemsFolder = subFolders.find((folder) =>
                item.flags?.ddbimporter?.dndbeyond?.lookupName
                && folder.name === item.flags.ddbimporter.dndbeyond.lookupName
              );
              item.folder = (itemsFolder) ? itemsFolder._id : defaultItemsFolder._id;
              await Item.create(item);
            }
            return item;
          })
      );
    };

    if (update) await updateItems();
    await createItems();

    // lets generate our compendium info like id, pack and img for use
    // by things like magicitems
    const folderIds = [defaultItemsFolder._id, ...subFolders.map((f) => f._id)];
    const items = Promise.all(
      game.items.entities
        .filter((item) => item.type === folderLookup.itemType && folderIds.includes(item.folder))
        .map((result) => {
          const subFolder = (result.flags.ddbimporter?.dndbeyond?.lookupName)
            ? result.flags.ddbimporter.dndbeyond.lookupName
            : null;
          return {
            magicItem: {
              _id: result._id,
              id: result._id,
              pack: "world",
              img: result.img,
              name: result.name,
              subFolder: subFolder,
              flatDc: result.flags?.ddbimporter?.dndbeyond?.overrideDC,
              dc: result.flags?.ddbimporter?.dndbeyond?.dc,
            },
            _id: result._id,
            name: result.name,
            compendium: false,
          };
        })
    );
    return items;
  }

}




/***/ }),

/***/ 306:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ Iconizer)
/* harmony export */ });
/* harmony import */ var _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2449);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6451);
/* harmony import */ var _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3893);
/* harmony import */ var _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2397);
/* harmony import */ var _NameMatcher_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3901);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7669);









// const BASE_PATH = ROUTE_PREFIX ? `/${ROUTE_PREFIX}` : "";

const TYPE_MAP = {
  items: "items",
  weapons: "items",
  weapon: "items",
  item: "items",
  equipment: "items",
  consumable: "items",
  tool: "items",
  loot: "items",
  container: "items",
  inventory: "items",
  spells: "spells",
  spell: "spells",
  feats: "feats",
  feat: "feats",
  classes: "classes",
  class: "classes",
  subclass: "classes",
  monster: "monster",
  summons: "monster",
  summon: "monster",
  backgrounds: "backgrounds",
  background: "backgrounds",
  traits: "traits",
  races: "races",
  race: "races",
  tattoo: "items",
  "dnd-tashas-cauldron.tattoo": "items",
};

const FILE_MAP = {
  items: ["items.json", "class-features.json", "races.json"],
  traits: ["class-features.json", "races.json", "general.json", "items.json"],
  spells: ["spells.json"],
  races: ["races.json"],
  feats: ["feats.json", "class-features.json", "races.json", "general.json"],
  classes: ["classes.json"],
  monster: ["named-monster-features.json", "generic-monster-features.json"],
  backgrounds: ["backgrounds.json", "feats.json", "class-features.json", "races.json", "general.json"],
};

function sanitiseName(name) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].nameString */ .Z.nameString(name).toLowerCase();
}

async function loadDataFile(fileName) {
  _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Getting icon mapping for ${fileName}`);
  const fileExists = await _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].fileExists */ .Z.fileExists("[data] modules/ddb-importer/data", fileName);

  const url = await _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getFileUrl */ .Z.getFileUrl("[data] modules/ddb-importer/data", fileName);
  if (!fileExists) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].warn */ .Z.warn(`Possible missing file, icon load may fail. Fetching ${url}`);
  }

  const data = await foundry.utils.fetchJsonWithTimeout(url);
  return data;
}

async function loadIconMap(type) {
  // check to see if dictionary is loaded
  if (CONFIG.DDBI.ICONS[type]) return;

  _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Loading Inbuilt Icon Map for ${type}`);
  let data = [];
  for (const fileName of FILE_MAP[type]) {
    const dataLoad = await loadDataFile(fileName);
    data = data.concat(dataLoad);
  }

  CONFIG.DDBI.ICONS[type] = data;
  // console.warn(iconMap);
}

function looseMatch(item, typeValue) {
  const originalName = item.flags?.ddbimporter?.originalName;
  if (originalName) {
    const originalMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name) === sanitiseName(originalName));
    if (originalMatch) return originalMatch.path;
  }

  const sanitisedName = sanitiseName(item.name);
  if (item.name.includes(":")) {
    const nameArray = sanitisedName.split(":");
    const postMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name) === nameArray[1].trim());
    if (postMatch) return postMatch.path;
    const subMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name) === nameArray[0].trim());
    if (subMatch) return subMatch.path;
  }

  const startsMatchEntry = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitisedName.split(":")[0].trim().startsWith(sanitiseName(entry.name).split(":")[0].trim()));
  if (startsMatchEntry) return startsMatchEntry.path;
  const startsMatchItem = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name).split(":")[0].trim().startsWith(sanitisedName.split(":")[0].trim()));
  if (startsMatchItem) return startsMatchItem.path;

  if (item.type === "subclass" && item.system.classIdentifier) {
    const sanitisedClassName = sanitiseName(item.system.classIdentifier);
    const subClassMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => sanitiseName(entry.name).startsWith(sanitisedClassName));
    if (subClassMatch) return subClassMatch.path;
  }

  return null;
}

function getIconPath(item, type, monsterName) {
  // check to see if we are able to load a dic for that type
  const typeValue = TYPE_MAP[type];
  if (!typeValue || !CONFIG.DDBI.ICONS[typeValue]) return null;

  const iconMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => {
    const sanitisedName = sanitiseName(entry.name);
    const sanitisedItemName = sanitiseName(item.name);
    if (type === "monster") {
      return sanitisedName === sanitisedItemName.split("(")[0].trim() && entry.monster && sanitiseName(entry.monster) == sanitiseName(monsterName);
    }
    return sanitisedName === sanitisedItemName;
  });

  if (!iconMatch && type === "monster") {
    const genericMonsterIconMatch = CONFIG.DDBI.ICONS[typeValue].find((entry) => {
      const sanitisedName = sanitiseName(entry.name);
      const sanitisedItemName = sanitiseName(item.name);
      return sanitisedName === sanitisedItemName;
    });
    if (genericMonsterIconMatch) return genericMonsterIconMatch.path;
  }

  if (iconMatch) {
    return iconMatch.path;
  } else {
    return looseMatch(item, typeValue);
  }
}


async function loadIconMaps(types) {
  let promises = [];

  const mapTypes = types
    .filter((type) => TYPE_MAP[type])
    .map((type) => TYPE_MAP[type]).filter((type, i, ar) => ar.indexOf(type) === i);

  mapTypes.forEach((type) => {
    // logger.debug(`Loading ${type}`);
    promises.push(loadIconMap(type));
  });

  return Promise.all(promises);
}

const STUBS = {
  1: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
  viewBox="0 0 512 512" width="512" height="512">
    <g>
      <circle style="fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;" cx="250" cy="250" r="220">
      </circle>
      <text font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' font-size="300" font-weight="400" fill="black" x="50%" y="52%" text-anchor="middle" stroke="#000000" dy=".3em">REPLACEME</text>
    </g>
  </svg>`,
  2: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
  viewBox="0 0 512 512" width="512" height="512">
    <g>
      <circle style="fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;" cx="250" cy="250" r="220">
      </circle>
      <text font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' font-size="230" font-weight="400" fill="black" x="50%" y="52%" text-anchor="middle" stroke="#000000" dy=".3em">REPLACEME</text>
    </g>
  </svg>`,
  3: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
  viewBox="0 0 512 512" width="512" height="512">
    <g>
      <circle style="fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;" cx="250" cy="250" r="220">
      </circle>
      <text font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' font-size="170" font-weight="400" fill="black" x="50%" y="52%" text-anchor="middle" stroke="#000000" dy=".3em">REPLACEME</text>
    </g>
  </svg>`,
  4: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
  viewBox="0 0 512 512" width="512" height="512">
    <g>
      <circle style="fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;" cx="250" cy="250" r="220">
      </circle>
      <text font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"' font-size="140" font-weight="400" fill="black" x="50%" y="52%" text-anchor="middle" stroke="#000000" dy=".3em">REPLACEME</text>
    </g>
  </svg>`,
};

function unPad(match, p1) {
  if (isNaN(parseInt(p1))) {
    return p1;
  } else {
    return parseInt(p1);
  }
}

class Iconizer {

  static async generateIcon(adventure, title) {
    // default path
    let iconPath = "icons/svg/book.svg";
    let stub = title.trim().split(".")[0].split(" ")[0];
    stub = stub.replace(/(\d+)/, unPad);
    if (stub.length <= 4) {
      iconPath = `assets/icons/${stub}.svg`;
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(stub);
      let content = STUBS[stub.length];
      content = content.replace("REPLACEME", stub);
      const uploadPath = await adventure.importRawFile(iconPath, content, "text/plain", true);
      return uploadPath;
    }
    return iconPath;
  }

  static async iconPath(item, monster = false, monsterName = "") {
    const itemTypes = [item.type];
    if (monster) itemTypes.push("monster");
    await loadIconMaps(itemTypes);

    let iconPath;
    // logger.debug(`Inbuilt icon match started for ${item.name} [${item.type}]`);
    // if we have a monster lets check the monster dict first
    if (monster) {
      const monsterPath = getIconPath(item, "monster", monsterName);
      if (monsterPath) {
        iconPath = monsterPath;
      }
    }
    if (!iconPath) iconPath = getIconPath(item, item.type);
    return iconPath;
  }

  static async copyInbuiltIcons(items, monster = false, monsterName = "") {
    // get unique array of item types to be matching
    const itemTypes = items.map((item) => item.type).filter((item, i, ar) => ar.indexOf(item) === i);

    if (monster) itemTypes.push("monster");
    await loadIconMaps(itemTypes);

    return new Promise((resolve) => {
      const iconItems = items.map((item) => {
        if (foundry.utils.getProperty(item, "flags.ddbimporter.keepIcon") !== true) {
          // logger.debug(`Inbuilt icon match started for ${item.name} [${item.type}]`);
          // if we have a monster lets check the monster dict first
          if (monster && !["spell"].includes(item.type)) {
            const monsterPath = getIconPath(item, "monster", monsterName);
            if (monsterPath) {
              item.img = monsterPath;
              return item;
            }
          }
          const pathMatched = getIconPath(item, item.type);
          if (pathMatched) {
            item.img = pathMatched;
            if (item.effects) {
              item.effects.forEach((effect) => {
                if (!effect.icon || effect.icon === "") {
                  effect.icon = pathMatched;
                }
                if (!effect.img || effect.img === "") {
                  effect.img = pathMatched;
                }
              });
            }
          }
        }
        return item;
      });
      resolve(iconItems);
    });
  }

  static async getSRDIconMatch(type) {
    const compendiumName = _settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].SRD_COMPENDIUMS.find */ .Z.SRD_COMPENDIUMS.find((c) => c.type == type).name;
    const srdPack = _CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getCompendium */ .Z.getCompendium(compendiumName);
    const srdIndices = ["name", "img", "prototypeToken.texture.src", "type", "system.activation", "prototypeToken.texture.scaleY", "prototypeToken.texture.scaleX"];
    const index = await srdPack.getIndex({ fields: srdIndices });
    return index;
  }

  static async getSRDImageLibrary() {
    if (CONFIG.DDBI.SRD_LOAD.mapLoaded) return CONFIG.DDBI.SRD_LOAD.iconMap;
    const compendiumFeatureItems = await Iconizer.getSRDIconMatch("features");
    const compendiumInventoryItems = await Iconizer.getSRDIconMatch("inventory");
    const compendiumSpellItems = await Iconizer.getSRDIconMatch("spells");
    const compendiumMonsterFeatures = await Iconizer.getSRDIconMatch("monsterfeatures");
    const compendiumMonsters = await Iconizer.getSRDIconMatch("monsters");

    // eslint-disable-next-line require-atomic-updates
    CONFIG.DDBI.SRD_LOAD.iconMap = [
      ...compendiumInventoryItems,
      ...compendiumSpellItems,
      ...compendiumFeatureItems,
      ...compendiumMonsterFeatures,
      ...compendiumMonsters,
    ];
    return CONFIG.DDBI.SRD_LOAD.iconMap;
  }

  static async copySRDIcons(items, srdImageLibrary = null, nameMatchList = []) {
    // eslint-disable-next-line require-atomic-updates
    if (!srdImageLibrary) srdImageLibrary = await Iconizer.getSRDImageLibrary();

    const srdItems = items.map((item) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Matching ${item.name}`);
      const nameMatch = nameMatchList.find((m) => m.name === item.name);
      if (nameMatch) {
        item.img = nameMatch.img;
      } else {
        const match = _NameMatcher_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].looseItemNameMatch */ .Z.looseItemNameMatch(item, srdImageLibrary, true);
        if (match) {
          srdImageLibrary.push({ name: item.name, img: match.img });
          item.img = match.img;
        }
      }
      return item;
    });
    return srdItems;
  }

  static async retainExistingIcons(items) {
    return new Promise((resolve) => {
      const newItems = items.map((item) => {
        if (item.flags.ddbimporter?.ignoreIcon) {
          _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Retaining icon for ${item.name} to ${item.flags.ddbimporter.matchedImg}`);
          item.img = item.flags.ddbimporter.matchedImg;
        }
        return item;
      });
      resolve(newItems);
    });
  }

  static async getDDBItemImages(items, download) {
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`Fetching DDB Item Images`);
    const downloadImages = (download) ? true : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-download-images");
    const remoteImages = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-remote-images");
    const targetDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
    const useDeepPaths = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-deep-file-paths");

    const itemMap = items.map(async (item) => {
      let itemImage = {
        name: item.name,
        type: item.type,
        img: null,
        large: null,
      };

      const pathPostfix = useDeepPaths ? `/item/${item.type}` : "";

      if (foundry.utils.hasProperty(item, "flags.ddbimporter.dndbeyond")) {
        if (item.flags.ddbimporter.dndbeyond.avatarUrl) {
          const avatarUrl = item.flags.ddbimporter.dndbeyond['avatarUrl'];
          if (avatarUrl && avatarUrl != "") {
            _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`Downloading ${item.name} image`);
            const imageNamePrefix = useDeepPaths ? "" : "item";
            const downloadOptions = { type: "item", name: item.name, download: downloadImages, remoteImages, targetDirectory, pathPostfix, imageNamePrefix };
            const smallImage = await _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getImagePath */ .Z.getImagePath(avatarUrl, downloadOptions);
            _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Final image ${smallImage}`);
            itemImage.img = smallImage;
          }
        }
        if (item.flags.ddbimporter.dndbeyond.largeAvatarUrl) {
          const largeAvatarUrl = item.flags.ddbimporter.dndbeyond['largeAvatarUrl'];
          if (largeAvatarUrl && largeAvatarUrl != "") {
            const imageNamePrefix = useDeepPaths ? "" : "item";
            const name = useDeepPaths ? `${item.name}-large` : item.name;
            const downloadOptions = { type: "item-large", name, download: downloadImages, remoteImages, targetDirectory, pathPostfix, imageNamePrefix };
            const largeImage = await _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getImagePath */ .Z.getImagePath(largeAvatarUrl, downloadOptions);
            itemImage.large = largeImage;
            if (!itemImage.img) itemImage.img = largeImage;
          }
        }
      }

      _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote("");
      return itemImage;
    });

    return Promise.all(itemMap);
  }

  static async getDDBHintImages(type, items, download) {
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`Fetching DDB Hint Images for ${type}`);
    const downloadImages = (download) ? true : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-download-images");
    const remoteImages = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-remote-images");
    const targetDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
    const useDeepPaths = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-deep-file-paths");

    const imageNamePrefix = useDeepPaths ? "" : type;

    for (const item of items) {
      // eslint-disable-next-line no-continue
      if (item.type !== type || item.img) continue;
      const ddbImg = foundry.utils.getProperty(item, "flags.ddbimporter.ddbImg");
      // eslint-disable-next-line no-continue
      if (!ddbImg || ddbImg === "") continue;
      const pathPostfix = useDeepPaths ? `/${type}/${item.type}` : "";
      const name = useDeepPaths ? `${item.name}` : item.name;
      const downloadOptions = { type, name, download: downloadImages, remoteImages, targetDirectory, pathPostfix, imageNamePrefix };
      const img = await _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getImagePath */ .Z.getImagePath(ddbImg, downloadOptions);
      if (img) item.img = img;
    }

    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote("");

    return items;
  }

  static async getDDBGenericItemImages(download) {
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`Fetching DDB Generic Item icons`);
    const targetDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
    const useDeepPaths = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-deep-file-paths");
    const imageNamePrefix = useDeepPaths ? "" : "item";
    const pathPostfix = useDeepPaths ? "/ddb/item" : "";

    const itemMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].items.map */ .Z.items.map(async (item) => {
      const downloadOptions = { type: "item", name: item.filterType, download, targetDirectory, pathPostfix, imageNamePrefix };
      const img = await _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getImagePath */ .Z.getImagePath(item.img, downloadOptions);
      let itemIcons = {
        filterType: item.filterType,
        img: img,
      };
      return itemIcons;
    });

    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote("");
    return Promise.all(itemMap);
  }


  static async getDDBGenericLootImages(download) {
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`Fetching DDB Generic Loot icons`);
    const targetDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
    const useDeepPaths = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-deep-file-paths");
    const imageNamePrefix = useDeepPaths ? "" : "equipment";
    const pathPostfix = useDeepPaths ? "/ddb/loot" : "";

    const itemMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].genericItemIcons.map */ .Z.genericItemIcons.map(async (item) => {
      const downloadOptions = { type: "equipment", name: item.name, download, targetDirectory, pathPostfix, imageNamePrefix };
      const img = await _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getImagePath */ .Z.getImagePath(item.img, downloadOptions);
      let itemIcons = {
        name: item.name,
        img: img,
      };
      return itemIcons;
    });

    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote("");
    return Promise.all(itemMap);
  }

  static async getDDBGenericItemIcons(items, download) {
    const genericItems = await Iconizer.getDDBGenericItemImages(download);
    const genericLoots = await Iconizer.getDDBGenericLootImages(download);

    let updatedItems = items.map((item) => {
      // logger.debug(item.name);
      // logger.debug(item.flags.ddbimporter.dndbeyond.filterType);
      const excludedItems = ["spell", "feat", "class"];
      if (!excludedItems.includes(item.type)
          && item.flags
          && item.flags.ddbimporter
          && item.flags.ddbimporter.dndbeyond) {
        let generic = null;
        if (item.flags.ddbimporter.dndbeyond.filterType) {
          generic = genericItems.find((i) => i.filterType === item.flags.ddbimporter.dndbeyond.filterType);
        } else if (item.flags.ddbimporter.dndbeyond.type) {
          generic = genericLoots.find((i) => i.name === item.flags.ddbimporter.dndbeyond.type);
        }
        if (generic && (!item.img || item.img == "" || item.img == CONST.DEFAULT_TOKEN)) {
          item.img = generic.img;
        }
      }
      return item;
    });
    return Promise.all(updatedItems);
  }

  static async getDDBSchoolSpellImages(download) {
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`Fetching spell school icons`);
    const targetDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
    const useDeepPaths = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-deep-file-paths");
    const imageNamePrefix = useDeepPaths ? "" : "spell";
    const pathPostfix = useDeepPaths ? "/spell/school" : "";

    const schoolMap = _dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].spell.schools.map */ .Z.spell.schools.map(async (school) => {
      const downloadOptions = { type: "spell", name: school.name, download, targetDirectory, imageNamePrefix, pathPostfix };
      const img = await _FileHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getImagePath */ .Z.getImagePath(school.img, downloadOptions);
      let schoolIcons = {
        name: school.name,
        img: img,
        id: school.id,
      };
      return schoolIcons;
    });

    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote("");
    return Promise.all(schoolMap);
  }

  static async getDDBSpellSchoolIcons(items, download) {
    const schools = await Iconizer.getDDBSchoolSpellImages(download);

    let updatedItems = items.map((item) => {
      // logger.debug(item.name);
      // logger.debug(item.flags.ddbimporter.dndbeyond);
      if (item.type == "spell") {
        const school = schools.find((school) => school.id === item.system.school);
        if (school && (!item.img || item.img == "" || item.img == CONST.DEFAULT_TOKEN)) {
          item.img = school.img;
        }
      }
      return item;
    });
    return Promise.all(updatedItems);
  }

  static async getDDBEquipmentIcons(items, download) {
    const itemImages = await Iconizer.getDDBItemImages(items.filter((item) => _dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(item.type)), download);

    let updatedItems = items.map((item) => {
      // logger.debug(item.name);
      // logger.debug(item.flags.ddbimporter.dndbeyond);
      if (_dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(item.type)) {
        if (!item.img || item.img == "" || item.img == CONST.DEFAULT_TOKEN) {
          const imageMatch = itemImages.find((m) => m.name == item.name && m.type == item.type);
          if (imageMatch && imageMatch.img) {
            item.img = imageMatch.img;
            foundry.utils.setProperty(item, "flags.ddbimporter.keepIcon", true);
          }
          if (imageMatch && imageMatch.large) {
            item.flags.ddbimporter.dndbeyond['pictureUrl'] = imageMatch.large;
          }
        }
      }
      return item;
    });
    return Promise.all(updatedItems);
  }

  static async updateMagicItemImages(items) {
    const useSRDCompendiumIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-srd-icons");
    const ddbSpellIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-ddb-spell-icons");
    const inbuiltIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-inbuilt-icons");
    const ddbItemIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-ddb-item-icons");

    // if we still have items to add, add them
    if (items.length > 0) {
      if (ddbItemIcons) {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Magic items: adding equipment icons");
        items = await Iconizer.getDDBEquipmentIcons(items, true);
      }

      if (inbuiltIcons) {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Magic items: adding inbuilt icons");
        items = await Iconizer.copyInbuiltIcons(items);
      }

      if (useSRDCompendiumIcons) {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Magic items: adding srd compendium icons");
        items = await Iconizer.copySRDIcons(items);
      }

      if (ddbSpellIcons) {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Magic items: adding ddb spell school icons");
        items = await Iconizer.getDDBSpellSchoolIcons(items, true);
      }
    }
    return items;
  }

  static async preFetchDDBIconImages() {
    await Iconizer.getDDBGenericItemImages(true);
    await Iconizer.getDDBGenericLootImages(true);
    await Iconizer.getDDBSchoolSpellImages(true);
  }


  /**
   * Add an item to effects, if available
   * @param {*} items
   */
  static addItemEffectIcons(items) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Adding Icons to effects");
    items.forEach((item) => {
      if (item.effects && (item.img && (item.img !== "" || item.img !== CONST.DEFAULT_TOKEN))) {
        item.effects.forEach((effect) => {

          if (!effect.icon || effect.icon === "" || effect.icon === CONST.DEFAULT_TOKEN) {
            effect.icon = item.img;
          }
          if (!effect.img || effect.img === "" || effect.img === CONST.DEFAULT_TOKEN) {
            effect.img = item.img;
          }
        });
      }

    });
    return items;
  }

  static addActorEffectIcons(actor) {
    if (!actor.effects) return actor;
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Adding Icons to actor effects");
    actor.effects.forEach((effect) => {
      const name = foundry.utils.getProperty(effect, "flags.ddbimporter.originName");
      if (name) {
        const actorItem = actor.items.find((i) => i.name === name);
        if (actorItem) {
          effect.icon = actorItem.img;
          effect.img = actorItem.img;
        }
      }
    });
    return actor;
  }

  static async updateIcons(items, srdIconUpdate = true, monster = false, monsterName = "") {
    // this will use ddb item icons as a fall back
    const ddbItemIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-item-icons");
    if (ddbItemIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("DDB Equipment Icon Match");
      items = await Iconizer.getDDBEquipmentIcons(items);
    }

    const inBuiltIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-inbuilt-icons");
    if (inBuiltIcons) {
      items = await Iconizer.getDDBHintImages("class", items);
      items = await Iconizer.getDDBHintImages("subclass", items);
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Inbuilt icon matching (Monster? ${monster ? monsterName : monster})`);
      items = await Iconizer.copyInbuiltIcons(items, monster, monsterName);
    }

    // check for SRD icons
    const srdIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd-icons");
    // eslint-disable-next-line require-atomic-updates
    if (srdIcons && srdIconUpdate) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("SRD Icon Matching");
      items = await Iconizer.copySRDIcons(items);
    }

    // this will use ddb spell school icons as a fall back
    const ddbSpellIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-spell-icons");
    if (ddbSpellIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("DDB Spell School Icon Match");
      items = await Iconizer.getDDBSpellSchoolIcons(items, true);
    }

    // this will use ddb generic icons as a fall back
    const ddbGenericItemIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-generic-item-icons");
    if (ddbGenericItemIcons) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("DDB Generic Item Icon Match");
      items = await Iconizer.getDDBGenericItemIcons(items, true);
    }

    // update any generated effects
    const addEffects = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-effects");
    if (addEffects) {
      items = Iconizer.addItemEffectIcons(items);
    }

    return items;
  }


}


/***/ }),

/***/ 6886:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _FileHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2397);
/* harmony import */ var _PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8636);
/* harmony import */ var _Secrets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2048);
/* harmony import */ var _apps_DDBSources_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5982);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6451);
/* harmony import */ var _effects_effects_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5751);
// import logger from "../logger.js";








const MuncherSettings = {

  disableCharacterActiveEffectSettings: (html) => {
    $(html).find("#character-import-policy-dae-effect-copy").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-dae-effect-copy", false);
    $(html).find("#character-import-policy-add-spell-effects").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-spell-effects", false);
    $(html).find("#character-import-policy-dae-effect-copy").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-dae-effect-copy", false);
    $(html).find("#character-import-policy-add-item-effects").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-item-effects", false);
    $(html).find("#character-import-policy-add-character-effects").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-character-effects", false);
    $(html).find("#character-import-policy-active-effect-copy").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-active-effect-copy", false);
    $(html).find("#character-update-policy-use-chris-premades").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-chris-premades", false);
  },

  setRecommendedCharacterActiveEffectSettings: (html) => {
    $(html).find("#character-import-policy-dae-effect-copy").prop("checked", !(0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)().hasCore);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-dae-effect-copy", !(0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)().hasCore);
    $(html).find("#character-import-policy-add-spell-effects").prop("checked", (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)().hasCore);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-spell-effects", (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)().hasCore);
    $(html).find("#character-import-policy-dae-effect-copy").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-dae-effect-copy", false);
    $(html).find("#character-import-policy-add-item-effects").prop("checked", true);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-item-effects", true);
    $(html).find("#character-import-policy-add-character-effects").prop("checked", true);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-character-effects", true);
    $(html).find("#character-import-policy-active-effect-copy").prop("checked", false);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-active-effect-copy", false);
    $(html).find("#character-update-policy-use-chris-premades").prop("checked", !(0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)().chrisInstalled);
    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-chris-premades", !(0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)().chrisInstalled);

  },

  getInstalledIcon: (name) => {
    return (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)()[name] ? "<i class='fas fa-check-circle' style='color: green'></i>" : "<i class='fas fa-times-circle' style='color: red'></i> ";
  },

  getCharacterImportSettings: () => {
    const importPolicies1 = [
      {
        name: "name",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-name"),
        description: "Name",
      },
      {
        name: "hp",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-hp"),
        description: "HP",
      },
      {
        name: "xp",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-xp"),
        description: "XP",
      },
      {
        name: "hit-die",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-hit-die"),
        description: "Hit Die",
      },
      {
        name: "image",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-image"),
        description: "Image",
      },
      {
        name: "bio",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-bio"),
        description: "Bio",
      },
      {
        name: "languages",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-languages"),
        description: "Languages",
      },
      {
        name: "spell-use",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-spell-use"),
        description: "Spell Slots",
      }
    ];
    const importPolicies2 = [
      {
        name: "class",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-class"),
        description: "Classes",
      },
      {
        name: "feat",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-feat"),
        description: "Features",
      },
      {
        name: "weapon",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-weapon"),
        description: "Weapons",
      },
      {
        name: "equipment",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-equipment"),
        description: "Other Equipment",
      },
      {
        name: "currency",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-currency"),
        description: "Currency",
      },
      {
        name: "spell",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-spell"),
        description: "Spells",
      },
    ];

    const effectModulesAvailable = (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)();
    const chrisInstalled = effectModulesAvailable.chrisInstalled;
    const generateSpellEffects = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-spell-effects");
    if (generateSpellEffects && !effectModulesAvailable.hasCore) {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-spell-effects", false);
    }

    const spellEffectText = `These are highly automated and required the following modules: DAE${MuncherSettings.getInstalledIcon("daeInstalled")}, Midi-QOL${MuncherSettings.getInstalledIcon("midiQolInstalled")}, and Times Up${MuncherSettings.getInstalledIcon("timesUp")}. Optional, but recommended automation modules: Active Auras${MuncherSettings.getInstalledIcon("activeAurasInstalled")}, Active Token Effects${MuncherSettings.getInstalledIcon("atlInstalled")}.`;

    const installedModulesText = `
<p>Some Active Effects do not require any external modules, many of these will be created regardless of what settings are checked here, some will need these options checked.</p>
<p>Some Active Effects need DAE${MuncherSettings.getInstalledIcon("daeInstalled")}, and although not required, it is <em>strongly recommended</em> if generating active effects with DDB Importer.</p>
<p>The following modules are entirely optional but offer pretty animations for your spells and attacks (Automated Animations${MuncherSettings.getInstalledIcon("autoAnimationsInstalled")}). DAE${MuncherSettings.getInstalledIcon("daeInstalled")} offers several effect options that are useful but not provided by the core system. Active Auras${MuncherSettings.getInstalledIcon("activeAurasInstalled")} offers support for things like Paladin auras, as well as more automated effects for spells such as Spike Growth. Active Token Effects${MuncherSettings.getInstalledIcon("atlInstalled")} allows for effects to change tokens size and vision.</p>
<p>For games looking for high levels of automation, particularly around spells and more complex character features such as Battle Master Manoeuvres, then the "Midi-QOL" suite is required. This will allow varying degrees of automation from auto-calculating hit rolls, advantage damage, and even applying it for you (if desired).</p>
<p>For high automation games you will need some additional modules, but are otherwise not required: Midi-QOL${MuncherSettings.getInstalledIcon("midiQolInstalled")}, and Times Up${MuncherSettings.getInstalledIcon("timesUp")}.</p>
`;
    // const importExtras = game.settings.get(SETTINGS.MODULE_ID, "character-update-policy-import-extras");

    const importConfig = [
      {
        name: "use-inbuilt-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-inbuilt-icons"),
        description: "Use icons from the inbuilt dictionary. (High coverage of items, feats, and spells).",
        enabled: true,
      },
      {
        name: "use-srd-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-srd-icons"),
        description: "Use icons from the SRD compendium. (This can take a while).",
        enabled: true,
      },
      {
        name: "use-ddb-spell-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-ddb-spell-icons"),
        description: "Use spell school icons from D&DBeyond.",
        enabled: true,
      },
      {
        name: "use-ddb-item-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-ddb-item-icons"),
        description: "Use equipment icons from D&DBeyond (where they exist).",
        enabled: true,
      },
      {
        name: "use-ddb-generic-item-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-ddb-generic-item-icons"),
        description: "Use D&D Beyond generic item type images, if available (final fallback)",
        enabled: true,
      },
      {
        name: "use-full-description",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-full-description"),
        description: "For actions use full description and snippets, else use snippets only.",
        enabled: true,
      },
      {
        name: "add-description-to-chat",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "add-description-to-chat"),
        description: "Add the snippet to the chat card (otherwise will use description).",
        enabled: true,
      },
      // {
      //   name: "use-actions-as-features",
      //   isChecked: game.settings.get(SETTINGS.MODULE_ID, "character-update-policy-use-actions-as-features"),
      //   description:
      //     "Import D&D Beyond Actions as Features, not weapons.",
      //   enabled: true,
      // },
      {
        name: "use-action-and-feature",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-action-and-feature"),
        description:
          "[CAUTION] If a feature is marked as an action, import both the action and the feature. This might lead to some weird behaviour.",
        enabled: true,
      },
      {
        name: "ignore-non-ddb-items",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-ignore-non-ddb-items"),
        description:
          "Ignore items on character sheet that have not been imported from D&D Beyond. This will remove items that have been removed from the DDB character since the last import, but will keep items added to the character within Foundry.",
        enabled: true,
      },
      {
        name: "create-companions",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-create-companions"),
        description: "Generate summon monster actors? (Requires item/actor create permissions)",
        enabled: true,
      },
    ];

    const advancedImportConfig = [
      {
        name: "use-override",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-override"),
        title: "Replace Items using those in your Override compendium",
        description:
          "Use existing items from <i>ddb-import Override compendium</i>, rather than parsing from DDB. This is useful if you want to place customised items into the compendium for use by characters.",
        enabled: true,
      },
      {
        name: "use-existing",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-existing"),
        title: "[Caution] Replace Items using ddb-importer compendiums",
        description:
          "Use existing items from <i>ddb-import compendiums</i>, rather than parsing from DDB. This is useful if you have customised the items in the compendium, although you will lose any custom effects applied by this module e.g. Improved Divine Smite. Please consider marking the item you wish to keep as ignored by import instead.",
        enabled: true,
      },
      {
        name: "use-srd",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-srd"),
        title: "[Caution] Replace Items using SRD compendiums",
        description:
          "Use the <i>SRD compendiums</i>, rather than DDB. Importing using SRD will not include features like fighting style and divine smite in damage calculations. Please consider marking the item you wish to keep as ignored by import instead.",
        enabled: true,
      },
    ];

    const effectImportConfig = [
      {
        name: "add-character-effects",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-character-effects"),
        title: "Generate Automation Effects for Character Features/Racial Traits/Feats/Backgrounds",
        description: null,
        enabled: true,
      },
      {
        name: "add-item-effects",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-add-item-effects"),
        title: "Generate Automation Effects for Equipment",
        description: null,
        enabled: true,
      },
      {
        name: "add-spell-effects",
        isChecked: generateSpellEffects && effectModulesAvailable.hasCore,
        title: "Generate Automation Effects for Spells",
        description: spellEffectText,
        enabled: effectModulesAvailable.hasCore,
      },
      {
        name: "use-chris-premades",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-chris-premades"),
        title: "Use Automation Effects from Chris's Premades module?",
        description: `Chris's Premades ${MuncherSettings.getInstalledIcon("chrisInstalled")} offer even more automation for all aspects of D&D, but have even more pre-requisites. You should investigate and set up this module before importing with this option selected. Requires Chris's Premades ${MuncherSettings.getInstalledIcon("chrisInstalled")} module.<br>These will replace any effects created by DDB Importer.`,
        enabled: chrisInstalled,
      },
      {
        name: "active-effect-copy",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-active-effect-copy"),
        title: "Retain Active Effects?",
        description:
          "Retain existing Active Effects, this will try and transfer any existing effects on the actor such as custom effects, effects from conditions or existing spells. Untick this option if you experience <i>odd</i> behaviour.",
        enabled: true,
      },
    ];

    const syncConfig = [
      {
        name: "action-use",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-action-use"),
        description: "Action Uses",
        enabled: true,
      },
      {
        name: "currency",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-currency"),
        description: "Currency",
        enabled: true,
      },
      {
        name: "deathsaves",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-deathsaves"),
        description: "Death Saves",
        enabled: true,
      },
      {
        name: "equipment",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-equipment"),
        description: "Equipment",
        enabled: true,
      },
      {
        name: "condition",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-condition"),
        description: "Conditions/Exhaustion",
        enabled: true,
      },
      {
        name: "hitdice",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-hitdice"),
        description: "Hit Dice/Short Rest",
        enabled: true,
      },
      {
        name: "hitpoints",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-hitpoints"),
        description: "Hit Points",
        enabled: true,
      },
      {
        name: "inspiration",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-inspiration"),
        description: "Inspiration",
        enabled: true,
      },
      {
        name: "spells-prepared",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-spells-prepared"),
        description: "Spells Prepared",
        enabled: true,
      },
      {
        name: "spells-slots",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-spells-slots"),
        description: "Spell Slots",
        enabled: true,
      },
      {
        name: "spells-sync",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-spells-sync"),
        description: "Spells Known",
        enabled: false,
      },
      {
        name: "xp",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "sync-policy-xp"),
        description: "XP",
        enabled: true,
      },
    ];

    const extrasConfig = [];

    const uploadDir = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "image-upload-directory");
    const dataDirSet = !_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].BAD_DIRS.includes */ .Z.BAD_DIRS.includes(uploadDir);
    const tier = _PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getPatreonTier */ .Z.getPatreonTier();
    const tiers = _PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].calculateAccessMatrix */ .Z.calculateAccessMatrix(tier);

    const result = {
      installedModulesText,
      importPolicies1,
      importPolicies2,
      importConfig,
      extrasConfig,
      advancedImportConfig,
      effectImportConfig,
      dataDirSet,
      syncConfig,
      tiers,
    };

    return result;
  },

  toggleByName(name, value = null) {
    const checkbox = document.querySelector(`input[type="checkbox"][name="${name}"]`);
    if (value === null) checkbox.checked = !checkbox.checked;
    else checkbox.checked = value;
  },

  updateActorSettings: (html, event) => {
    const selection = event.currentTarget.dataset.section;
    const checked = event.currentTarget.checked;

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating munching-policy-${selection} to ${checked}`);
    if (selection === "add-description-to-chat") {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "add-description-to-chat", checked);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-use-full-description", false);
      MuncherSettings.toggleByName("character-import-policy-use-full-description", false);
      // $(html).find("#character-import-policy-use-full-description").prop("checked", false);
    } else {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "character-update-policy-" + selection, checked);
    }

    // if (selection === "dae-copy" && checked) {
    //   $(html).find("#character-import-policy-dae-effect-copy").prop("checked", false);
    //   game.settings.set(SETTINGS.MODULE_ID, "character-update-policy-dae-effect-copy", false);
    // } else if (selection === "dae-effect-copy" && checked) {
    //   $(html).find("#character-import-policy-add-item-effects").prop("checked", true);
    //   game.settings.set(SETTINGS.MODULE_ID, "character-update-policy-add-item-effects", true);
    //   $(html).find("#character-import-policy-add-character-effects").prop("checked", true);
    //   game.settings.set(SETTINGS.MODULE_ID, "character-update-policy-add-character-effects", true);
    // }

    if (selection === "use-full-description") {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "add-description-to-chat", false);
      // $(html).find("#character-import-policy-add-description-to-chat").prop("checked", false);
      MuncherSettings.toggleByName("character-import-policy-add-description-to-chat", false);
    }
  },

  getCompendiumFolderLookups: (type) => {
    const compendiumFolderSetting = game.settings.settings.get(`ddb-importer.munching-selection-compendium-folders-${type}`);
    const settingValue = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, `munching-selection-compendium-folders-${type}`);

    let selections = [];
    for (const [key, value] of Object.entries(compendiumFolderSetting.choices)) {
      selections.push({
        key: key,
        label: value,
        selected: key === settingValue,
      });
    }

    return selections;
  },

  getMuncherSettings: (includeHomebrew = true) => {
    const cobalt = (0,_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)() != "";
    const betaKey = _PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getPatreonKey */ .Z.getPatreonKey() != "";
    const tier = _PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getPatreonTier */ .Z.getPatreonTier();
    const tiers = _PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].calculateAccessMatrix */ .Z.calculateAccessMatrix(tier);
    const effectModulesAvailable = (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_6__/* .effectModules */ .xV)();
    const chrisInstalled = effectModulesAvailable.chrisInstalled;
    const compendiumFolderMonsterStyles = MuncherSettings.getCompendiumFolderLookups("monster");
    const compendiumFolderSpellStyles = MuncherSettings.getCompendiumFolderLookups("spell");
    const compendiumFolderItemStyles = MuncherSettings.getCompendiumFolderLookups("item");
    const spellEffectText = `Create Automation Effects for spells?<br>
These effects automate a lot of common spells, but do require the use of a number of external modules, including "Midi-QOL", which potentially introduces a much higher level of automation and complexity above the base Foundry system.<br>
These require the following modules: DAE${MuncherSettings.getInstalledIcon("daeInstalled")}, Midi-QOL${MuncherSettings.getInstalledIcon("midiQolInstalled")}, and Times Up${MuncherSettings.getInstalledIcon("timesUp")} as a minimum.<br>
Effects can also be created to use Active Auras${MuncherSettings.getInstalledIcon("activeAurasInstalled")}, Active Token Effects${MuncherSettings.getInstalledIcon("atlInstalled")}, Token Magic FX${MuncherSettings.getInstalledIcon("tokenMagicInstalled")}, and Automated Animations${MuncherSettings.getInstalledIcon("autoAnimationsInstalled")}.
`;

    const generateSpellEffects = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-spell-effects");
    if (generateSpellEffects && !effectModulesAvailable.hasCore) {
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-spell-effects", false);
    }

    const enableSources = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-source-filter");
    const sourceArray = enableSources
      ? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-muncher-sources").flat()
      : [];
    const sourcesSelected = enableSources && sourceArray.length > 0;
    const sourceNames = _apps_DDBSources_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getSourcesLookups */ .Z.getSourcesLookups(sourceArray).filter((source) => source.selected).map((source) => source.label);
    const homebrewDescription = sourcesSelected
      ? "Include homebrew? SOURCES SELECTED! You can't import homebrew with a source filter selected"
      : "Include homebrew?";
    const sourceDescription = `Importing from the following sources only: ${sourceNames.join(", ")}`;

    const itemConfig = [
      {
        name: "use-ddb-item-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-item-icons"),
        description: "Use D&D Beyond item images, if available",
        enabled: true,
      },
      {
        name: "use-ddb-generic-item-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-generic-item-icons"),
        description: "Use D&D Beyond generic item type images, if available (final fallback)",
        enabled: true,
      },
      {
        name: "add-effects",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-effects"),
        description: "Add Automation effects to equipment?",
        enabled: true,
      },
      {
        name: "item-homebrew",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew"),
        description: homebrewDescription,
        enabled: !sourcesSelected,
      },
      {
        name: "item-homebrew-only",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew-only"),
        description: "Only import homebrew items?",
        enabled: !sourcesSelected,
      },
    ];

    const spellConfig = [
      {
        name: "use-ddb-spell-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-ddb-spell-icons"),
        description: "If no other icon, use the D&DBeyond spell school icon.",
        enabled: true,
      },
      {
        name: "add-spell-effects",
        isChecked: generateSpellEffects && effectModulesAvailable.hasCore,
        description: spellEffectText,
        enabled: effectModulesAvailable.hasCore,
      },
      {
        name: "spell-homebrew",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-spell-homebrew"),
        description: homebrewDescription,
        enabled: !sourcesSelected,
      },
      {
        name: "spell-homebrew-only",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-spell-homebrew-only"),
        description: "Only import homebrew spells?",
        enabled: !sourcesSelected,
      },
    ];

    const tokenizerReady = game.modules.get("vtta-tokenizer")?.active;

    const basicMonsterConfig = [
      {
        name: "hide-description",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-hide-description"),
        description: "Hide monster action description from players?",
        enabled: true,
      },
      {
        name: "monster-items",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-items"),
        description: "[Experimental] Load attack/weapon items from DDB compendium instead of parsing action/attack? (Poor success rate).",
        enabled: true,
      },
      {
        name: "monster-use-item-ac",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-use-item-ac"),
        description: "Use AC items instead of setting a flat AC? (Recommended if using spell effects like shield on NPC's).",
        enabled: true,
      },
      {
        name: "use-full-token-image",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-full-token-image"),
        description: "Use avatar image for token rather than token image (full art).",
        enabled: true,
      },
      {
        name: "use-token-avatar-image",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-token-avatar-image"),
        description: "Use token image for avatar rather than avatar image (close up).",
        enabled: true,
      },
      {
        name: "use-srd-monster-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd-monster-images"),
        description: "Use images from the SRD compendiums.",
        enabled: true,
      },
      {
        name: "update-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-images"),
        description: "[CAUTION] Update Monster images on existing npcs? (This will dramatically slow down re-munching).",
        enabled: true,
      },
      {
        name: "monster-tokenize",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-tokenize"),
        description: "Auto-Tokenize monsters token image? (Adds Tokenizer default token ring using the Tokenizer module).",
        enabled: tokenizerReady,
      },
      {
        name: "monster-retain-biography",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-retain-biography"),
        description: "Should monsters retain existing biography?",
        enabled: true,
      },
      {
        name: "monster-strip-name",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-strip-name"),
        description: "Strip uses and recharge information from action names?",
        enabled: true,
      },
      {
        name: "monster-set-legendary-resource-bar",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-set-legendary-resource-bar"),
        description: "Monsters display legendary resources on bar2? (Like the SRD Monsters).",
        enabled: true,
      },
      {
        name: "add-monster-effects",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-add-monster-effects"),
        description: `Generate Automation Effects that use Midi-QOL on monster attacks/features? <br>These are for a highly automated game, and are things such as managing abilities with conditions that have saves every round, or attacks which apply conditions such as frightened or prone.<br>Requires DAE${MuncherSettings.getInstalledIcon("daeInstalled")}, Midi-QOL${MuncherSettings.getInstalledIcon("midiQolInstalled")}.`,
        enabled: effectModulesAvailable.hasMonster,
      },
    ];

    const homebrewMonsterConfig = includeHomebrew
      ? [
        {
          name: "monster-homebrew",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew") && !sourcesSelected,
          description: homebrewDescription,
          enabled: tiers.homebrew && !sourcesSelected,
        },
        {
          name: "monster-homebrew-only",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew-only") && !sourcesSelected,
          description: "Homebrew monsters only? (Otherwise both)",
          enabled: tiers.homebrew && !sourcesSelected,
        },
        {
          name: "monster-exact-match",
          isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-exact-match"),
          description: "Exact name match?",
          enabled: tiers.homebrew,
        }
      ]
      : [];

    const monsterConfig = basicMonsterConfig.concat(homebrewMonsterConfig);

    const genericConfig = [
      {
        name: "update-existing",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing"),
        description: "Update existing things.",
        enabled: true,
      },
      {
        name: "use-inbuilt-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-inbuilt-icons"),
        description: "Use icons from the inbuilt dictionary. (High coverage, recommended, fast).",
        enabled: true,
      },
      {
        name: "use-srd-icons",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd-icons"),
        description: "Use icons from the SRD compendiums.",
        enabled: true,
      },
      {
        name: "download-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-download-images"),
        description: "Download D&D Beyond images (takes longer and needs space).",
        enabled: true,
      },
      {
        name: "remote-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-remote-images"),
        description: "Use D&D Beyond remote images (a lot quicker)",
        enabled: true,
      },
      {
        name: "use-chris-premades",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-chris-premades"),
        description: `Use Automation Effects from Chris's Premades module? These provide high quality automations for spells, features, monsters, etc. (Requires Chris's Premades ${MuncherSettings.getInstalledIcon("chrisInstalled")} module).<br>These will replace any effects created by DDB Importer.`,
        enabled: chrisInstalled,
      },
      {
        name: "use-srd",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd"),
        description:
          "[CAUTION] Use SRD compendium things instead of importing. This is not recommended, and may break adventure munching functionality.",
        enabled: true,
      },
      {
        name: "exclude-legacy",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-exclude-legacy"),
        description: "Exclude legacy monsters/races from import? These are replaced by newer versions e.g. in Monsters of the Multiverse.",
        enabled: true,
      },
      {
        name: "legacy-postfix",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-legacy-postfix"),
        description: "Append (Legacy) to Legacy monster/race names? These are replaced by newer versions e.g. in Monsters of the Multiverse.",
        enabled: true,
      },
      {
        name: "use-source-filter",
        isChecked: enableSources,
        description: "Restrict import to specific source book(s)? (DDB sets this as the <i>first</i> book a monster appears in).",
        enabled: true,
      }
    ];

    const worldUpdateConfig = [
      {
        name: "update-world-monster-update-images",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-world-monster-update-images"),
        description: "Update Monster images?",
        enabled: true,
      },
      {
        name: "update-world-monster-retain-biography",
        isChecked: game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-world-monster-retain-biography"),
        description: "Retain existing biography?",
        enabled: true,
      },
    ];

    const resultData = {
      cobalt,
      genericConfig,
      monsterConfig,
      spellConfig,
      itemConfig,
      worldUpdateConfig,
      beta: betaKey && cobalt,
      tiers,
      compendiumFolderMonsterStyles,
      compendiumFolderItemStyles,
      compendiumFolderSpellStyles,
      sourcesSelected,
      sourceDescription,
      enableSources,
      version: CONFIG.DDBI.version,
    };

    // console.warn(resultData);

    return resultData;
  },

  // eslint-disable-next-line complexity
  updateMuncherSettings: (html, event, dialog) => {
    const selection = event.currentTarget.dataset.section;
    const checked = event.currentTarget.checked;

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating munching-policy-${selection} to ${checked}`);

    game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-" + selection, checked);

    switch (selection) {
      case "monster-homebrew": {
        if (!checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew-only", false);
          $("#munching-policy-monster-homebrew-only").prop("checked", false);
        }
        break;
      }
      case "monster-homebrew-only": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew", true);
          $("#munching-policy-monster-homebrew").prop("checked", true);
        }
        break;
      }
      case "spell-homebrew": {
        if (!checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-spell-homebrew-only", false);
          $("#munching-policy-spell-homebrew-only").prop("checked", false);
        }
        break;
      }
      case "spell-homebrew-only": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-spell-homebrew", true);
          $("#munching-policy-spell-homebrew").prop("checked", true);
        }
        break;
      }
      case "item-homebrew": {
        if (!checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew-only", false);
          $("#munching-policy-item-homebrew-only").prop("checked", false);
        }
        break;
      }
      case "item-homebrew-only": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew", true);
          $("#munching-policy-item-homebrew").prop("checked", true);
        }
        break;
      }
      case "remote-images": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-download-images", false);
          $("#munching-generic-policy-download-images").prop("checked", false);
        }
        break;
      }
      case "download-images": {
        if (checked) {
          game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-remote-images", false);
          $("#munching-generic-policy-remote-images").prop("checked", false);
        }
        break;
      }
      case "use-source-filter": {
        $("#munch-source-select").prop("disabled", !checked);
        $("#munch-source-div").toggleClass("ddbimporter-hidden");
        dialog.render(true);
        break;
      }
      // no default
    }
  },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MuncherSettings);


/***/ }),

/***/ 3901:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ NameMatcher)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);



class NameMatcher {

  static getMonsterNames(name) {
    let magicNames = [name, name.toLowerCase()];

    // +2 sword
    let frontPlus = name.match(/^(\+\d*)\s*(.*)/);
    if (frontPlus) {
      magicNames.push(`${frontPlus[2].trim()}, ${frontPlus[1]}`.toLowerCase().trim());
    }

    // sword +2
    let backPlus = name.match(/(.*)\s*(\+\d*)$/);
    if (backPlus) {
      magicNames.push(`${backPlus[1].trim()}, ${backPlus[2]}`.toLowerCase().trim());
    }

    return magicNames;
  }

  static getLooseNames(name, extraNames = [], removeMagic = true) {
    let looseNames = new Set(extraNames.map((name) => name.toLowerCase()));
    looseNames.add(name.toLowerCase());
    looseNames.add(name.replace(",", "").toLowerCase());
    let refactNameArray = name.split("(")[0].trim().split(", ");
    refactNameArray.unshift(refactNameArray.pop());
    const refactName = refactNameArray.join(" ").trim();
    looseNames.add(refactName.toLowerCase());

    let deconNameArray = name.replace("(", "").replace(")", "").trim().split(",");
    deconNameArray.unshift(deconNameArray.pop());
    const deconName = deconNameArray.join(" ").trim();
    looseNames.add(deconName.toLowerCase());

    // word smart quotes are the worst
    looseNames.add(name.replace("'", "").toLowerCase());
    looseNames.add(name.replace("", "'").toLowerCase());
    looseNames.add(name.replace(" armor", "").toLowerCase());
    looseNames.add(name.replace(/s$/, "").toLowerCase()); // trim s, e.g. crossbow bolt(s)
    looseNames.add(name.replace(",", "").toLowerCase()); // +1 weapons etc
    looseNames.add(`${name} attack`.toLowerCase()); // Claw Attack
    looseNames.add(name.replace(" (1 day)", "").toLowerCase());
    looseNames.add(name.replace(" (10-foot)", "").toLowerCase());
    looseNames.add(name.replace(" (bag of 20)", "").toLowerCase());
    looseNames.add(name.replace(" (bag of 1000)", "").toLowerCase());
    looseNames.add(name.replace(" (per day)", "").toLowerCase());
    looseNames.add(name.replace("(10 foot)", "(10-foot)").toLowerCase());
    looseNames.add(name.replace("(10-foot)", "(10 foot)").toLowerCase());
    looseNames.add(name.replace("(0 - Cantrip)", "Cantrip").toLowerCase());
    looseNames.add(name.replace(/\((\d..) Level\)/, "$1 Level").toLowerCase());

    if (removeMagic || (!removeMagic && name.split(",")[0].length > 1 && !(/\+\d$/).test(name.trim()))) {
      looseNames.add(name.split(",")[0].toLowerCase());
    }

    if (removeMagic) {
      let refactNamePlusArray = name
        .replace(/\+\d*\s*/, "")
        .trim()
        .split("(")[0]
        .trim()
        .split(", ");
      refactNamePlusArray.unshift(refactNamePlusArray.pop());
      const refactNamePlus = refactNamePlusArray.join(" ").trim();
      looseNames.add(refactNamePlus.toLowerCase());
      looseNames.add(
        refactName
          .replace(/\+\d*\s*/, "")
          .trim()
          .toLowerCase()
      );
      looseNames.add(
        refactName
          .replace(/\+\d*\s*/, "")
          .trim()
          .toLowerCase()
          .replace(/s$/, "")
      );
    }

    return Array.from(looseNames);
  }

  // The monster setting is less vigorous!
  static looseItemNameMatch(item, items, loose = false, monster = false, magicMatch = false) {
    // first pass is a strict match
    let matchingItem = items.find((matchItem) => {
      let activationMatch = false;
      const extraNames = foundry.utils.getProperty(matchItem, "flags.ddbimporter.dndbeyond.alternativeNames") ?? [];

      const itemActivationProperty = Object.prototype.hasOwnProperty.call(item.system, "activation");
      const matchItemActivationProperty = Object.prototype.hasOwnProperty.call(item.system, "activation");

      if (itemActivationProperty && item.system?.activation?.type == "") {
        activationMatch = true;
      } else if (matchItemActivationProperty && itemActivationProperty) {
        // I can't remember why I added this. Maybe I was concerned about identical named items with
        // different activation times?
        // maybe I just want to check it exists?
        // causing issues so changed.
        // activationMatch = matchItem.system.activation.type === item.system.activation.type;
        activationMatch = matchItemActivationProperty && itemActivationProperty;
      } else if (!itemActivationProperty) {
        activationMatch = true;
      }

      const nameMatch = item.name === matchItem.name || extraNames.includes(item.name);
      const isMatch = nameMatch && item.type === matchItem.type && activationMatch;
      return isMatch;
    });

    if (!matchingItem && monster) {
      matchingItem = items.find((matchItem) => {
        const monsterNames = NameMatcher.getMonsterNames(matchItem.name);
        const monsterMatch = monsterNames.includes(item.name.toLowerCase())
          && _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].types.monster.includes */ .Z.types.monster.includes(matchItem.type)
          && _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(item.type);
        return monsterMatch;
      });
    }

    if (!matchingItem && magicMatch) {
      // is this an inverse match for updates?
      // if so strip out the non-magic names, we want to match on the magic names
      const magicName = item.name
        .replace(/(.*)\s+(\+\d*)\s*/, "$1, $2")
        .trim()
        .toLowerCase();
      const magicName2 = item.name
        .replace(/(.*)\s+(\+\d*)\s*/, "$2 $1")
        .trim()
        .toLowerCase();
      matchingItem = items.find((matchItem) => [magicName, magicName2].includes(matchItem.name.trim().toLowerCase()));
    }

    if (!matchingItem && loose) {
      const extraNames = foundry.utils.getProperty(item, "flags.ddbimporter.dndbeyond.alternativeNames") ?? [];
      const looseNames = NameMatcher.getLooseNames(item.name, extraNames, !magicMatch);
      // console.warn("loose names", looseNames);
      for (const looseName of looseNames) {
        matchingItem = items.find((matchItem) => {
          const looseItemMatch = (looseName === matchItem.name.toLowerCase()
            || looseName === matchItem.name.toLowerCase().replace(" armor", ""))
            && _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(item.type)
            && _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].types.inventory.includes */ .Z.types.inventory.includes(matchItem.type);
          return looseItemMatch;
        });
        if (matchingItem) {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Broke on ${looseName}`, matchingItem);
          break;
        }
      }

      // super loose name match!
      if (!matchingItem) {
        // still no matching item, lets do a final pass
        matchingItem = items.find((matchItem) =>
          looseNames.includes(matchItem.name.split("(")[0].trim().toLowerCase())
        );
      }
    }
    return matchingItem;
  }
}


/***/ }),

/***/ 8636:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2449);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6451);
/* harmony import */ var _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(546);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7669);






async function setLocalStorage(key, value) {
  // remove item if null or undefined
  if (value === null || value === undefined) {
    localStorage.removeItem(key);
  } else {
    localStorage.setItem(key, value);
  }
}


const PatreonHelper = {

  getPatreonKey: (local = false) => {
    if (local) {
      return localStorage.getItem("ddb-patreon-key");
    } else {
      return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key");
    }
  },

  setPatreonKey: async (key, local = false) => {
    if (local) {
      setLocalStorage("ddb-patreon-key", key);
    } else {
      await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key", key);
    }
  },

  getPatreonUser: (local = false) => {
    if (local) {
      return localStorage.getItem("ddb-patreon-user");
    } else {
      return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-user");
    }
  },

  setPatreonUser: async (user, local = false) => {
    if (local) {
      setLocalStorage("ddb-patreon-user", user);
    } else {
      await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-user", user);
    }
  },

  getPatreonTier: (local = false) => {
    if (local) {
      return localStorage.getItem("ddb-patreon-tier");
    } else {
      return game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier");
    }
  },

  setPatreonTier: async (local = false) => {
    const tier = await PatreonHelper.fetchPatreonTier(local);
    if (local) {
      setLocalStorage("ddb-patreon-tier", tier);
    } else {
      await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier", tier);
    }
  },

  fetchPatreonTier: async (local = false) => {
    if (_DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].isCustom */ .Z.isCustom()) return { success: true, message: "custom proxy", data: "CUSTOM" };
    const key = PatreonHelper.getPatreonKey(local);
    const parsingApi = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getProxy */ .Z.getProxy();
    const body = { betaKey: key };

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/patreon/tier`, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`API Failure: ${data.message}`);
            reject(data.message);
          }
          let currentEmail = PatreonHelper.getPatreonUser(local);
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Fetched Patreon tier information", {
            user: data.email,
            tier: data.data
          });
          if (data.email !== currentEmail) {
            PatreonHelper.setPatreonUser(data.email, local).then(() => {
              resolve(data.data);
            });
          } else {
            resolve(data.data);
          }
        })
        .catch((error) => reject(error));
    });
  },

  getPatreonValidity: async (betaKey) => {
    if (_DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].isCustom */ .Z.isCustom()) return { success: true, message: "custom proxy", data: true };
    const parsingApi = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getProxy */ .Z.getProxy();
    const body = { betaKey: betaKey };

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/patreon/valid`, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          resolve(data);
        })
        .catch((error) => reject(error));
    });
  },

  calculateAccessMatrix: (tier) => {
    const godTier = tier === "GOD";
    const undyingTier = tier === "UNDYING";
    const coffeeTier = tier === "COFFEE";
    const custom = tier === "CUSTOM" || _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].isCustom */ .Z.isCustom();

    const tiers = {
      god: godTier,
      undying: undyingTier,
      custom: custom,
      coffee: coffeeTier,
      source: godTier || undyingTier || coffeeTier || custom,
      experimentalMid: godTier || undyingTier,
      homebrew: godTier || undyingTier || coffeeTier || custom,
      all: godTier || undyingTier || coffeeTier || custom,
      supporter: godTier || undyingTier || coffeeTier,
      not: !godTier && !undyingTier && !coffeeTier && !custom,
    };

    return tiers;
  },

  checkPatreon: async (local = false) => {
    const tier = await PatreonHelper.fetchPatreonTier(local);
    const matrix = PatreonHelper.calculateAccessMatrix(tier);
    return matrix;
  },

  linkToPatreon: async () => {

    const proxy = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getProxy */ .Z.getProxy();
    const patreonId = "oXQUxnRAbV6mq2DXlsXY2uDYQpU-Ea2ds0G_5hIdi0Bou33ZRJgvV8Ub3zsEQcHp";
    const patreonAuthUrl = `${proxy}/patreon/auth`;
    const patreonScopes = encodeURI("identity identity[email]");

    const socketOptions = {
      transports: ['websocket', 'polling', 'flashsocket'],
      // reconnection: false,
      // reconnectionAttempts: 10,
    };
    const socket = io(`${proxy}/`, socketOptions);

    socket.on("connect", () => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("DDB Muncher socketID", socket.id);
      const serverDetails = {
        id: socket.id,
        world: game.world.title,
        userId: game.userId,
      };
      socket.emit("register", serverDetails);

    });

    socket.on('registered', (data) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Foundry instance registered with DDB Muncher Proxy`);
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(data);
      _utils_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].renderPopup */ .Z.renderPopup("web", `https://www.patreon.com/oauth2/authorize?response_type=code&client_id=${patreonId}&redirect_uri=${patreonAuthUrl}&state=${data.userHash}&scope=${patreonScopes}`);
    });

    socket.on('auth', (data) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Response from auth socket!`, data);

      CONFIG.DDBI.POPUPS["web"].close();

      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "beta-key", data.key);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-user", data.email);
      game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "patreon-tier", data.tier);

      $('#ddb-patreon-user').text(data.email);
      $('#ddb-patreon-tier').text(data.tier);
      $('#ddb-patreon-valid').text("True");
      $('#ddb-beta-key').val(data.key);

      socket.disconnect();
    });

    socket.on('error', (data) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Error Response from socket!`, data);
      socket.disconnect();
    });
  },

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PatreonHelper);


/***/ }),

/***/ 2048:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": () => (/* binding */ checkCobalt),
/* harmony export */   "HF": () => (/* binding */ getCobalt),
/* harmony export */   "Mi": () => (/* binding */ isLocalCobalt),
/* harmony export */   "Nr": () => (/* binding */ moveCobaltToLocal),
/* harmony export */   "Tl": () => (/* binding */ deleteLocalCobalt),
/* harmony export */   "hc": () => (/* binding */ setCobalt),
/* harmony export */   "pC": () => (/* binding */ moveCobaltToSettings)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6451);
/* harmony import */ var _DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(546);
/* harmony import */ var _PatreonHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8636);





function isJSON(str) {
  try {
    return (JSON.parse(str) && !!str && str !== null);
  } catch (e) {
    return false;
  }
}

function isLocalCobalt(keyPostfix) {
  return keyPostfix && keyPostfix !== "" && localStorage.getItem(`ddb-cobalt-cookie-${keyPostfix}`) !== null;
}

function getCobalt(keyPostfix = "") {
  let cobalt;
  const localCookie = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local");
  const characterCookie = isLocalCobalt(keyPostfix);

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Getting Cookie: Key postfix? "${keyPostfix}" -  Local? ${localCookie} - Character? ${characterCookie}`);
  if (characterCookie) {
    cobalt = localStorage.getItem(`ddb-cobalt-cookie-${keyPostfix}`);
  } else if (localCookie) {
    cobalt = localStorage.getItem("ddb-cobalt-cookie");
  } else {
    cobalt = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie");
  }

  return cobalt;
}

async function setCobalt(value, keyPostfix = "") {
  const localCookie = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local");
  const characterCookie = keyPostfix && keyPostfix !== "";

  let cobaltValue = value;
  if (isJSON(value)) {
    cobaltValue = JSON.parse(value).cbt;
  }

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Setting Cookie: Key postfix? "${keyPostfix}" -  Local? ${localCookie} - Character? ${characterCookie}`);
  if (characterCookie) {
    localStorage.setItem(`ddb-cobalt-cookie-${keyPostfix}`, cobaltValue);
  } else if (localCookie) {
    localStorage.setItem("ddb-cobalt-cookie", cobaltValue);
  } else {
    await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie", cobaltValue);
  }
}

function deleteLocalCobalt(keyPostfix) {
  const localCookie = isLocalCobalt(keyPostfix);

  if (localCookie) {
    localStorage.removeItem(`ddb-cobalt-cookie-${keyPostfix}`);
  }
}

async function moveCobaltToLocal() {
  localStorage.setItem('ddb-cobalt-cookie', game.settings.get("ddb-importer", "cobalt-cookie"));
  await game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie", "");
  game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local", true);
}

async function moveCobaltToSettings() {
  game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie", localStorage.getItem('ddb-cobalt-cookie'));
  game.settings.set(_settings_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "cobalt-cookie-local", false);
}

async function checkCobalt(keyPostfix = "", alternativeKey = null) {
  const cobaltCookie = alternativeKey
    ? isJSON(alternativeKey)
      ? JSON.parse(alternativeKey).cbt
      : alternativeKey
    : getCobalt(keyPostfix);
  const parsingApi = _DDBProxy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getProxy */ .Z.getProxy();
  const betaKey = _PatreonHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getPatreonKey */ .Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, betaKey: betaKey };

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/auth`, {
      method: "POST",
      cache: "no-cache",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => resolve(data))
      .catch((error) => {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Cobalt cookie check error`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(error);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(error.stack);
        reject(error);
      });
  });
}


/***/ }),

/***/ 7669:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const utils = {
  debug: () => {
    return true;
  },

  capitalize: (s) => {
    if (typeof s !== "string") return "";
    return s.charAt(0).toUpperCase() + s.slice(1);
  },

  /**
   * Async for each loop
   *
   * @param  {array} array - Array to loop through
   * @param  {function} callback - Function to apply to each array item loop
   */
  asyncForEach: async (array, callback) => {
    for (let index = 0; index < array.length; index += 1) {
      // eslint-disable-next-line callback-return, no-await-in-loop
      await callback(array[index], index, array);
    }
  },

  removeCompendiumLinks: (text) => {
    const linkRegExTag = /@\w+\[(.*)\](\{.*?\})/g;
    const linkRegExNoTag = /@\w+\[(.*)\]/g;
    function replaceRule(match, p1, p2) {
      if (p2) {
        return `${p2}`;
      } else {
        return `${p1}`;
      }
    }
    return text.replaceAll(linkRegExTag, replaceRule).replaceAll(linkRegExNoTag, replaceRule);
  },

  normalizeString: (str) => {
    return str.toLowerCase().replace(/\W/g, "");
  },

  referenceNameString: (str) => {
    return str.replace(/[^a-zA-Z0-9]/g, "-")
      .replace(/-+/g, "-")
      .trim()
      .replace(/-$/g, '');
  },

  idString: (str) => {
    return str.replace(/[^a-zA-Z0-9]/g, "");
  },

  namedIDStub(name, { prefix = "ddb", postfix = null, length = 16 } = {}) {
    const nameSplit = name.split(" ").map((n) => utils.idString(n));
    const remainingN = length - (prefix ? `${prefix}`.length : 0) - (postfix ? `${postfix}`.length : 0);
    const quotient = Math.floor(remainingN / nameSplit.length);
    let remainder = remainingN % nameSplit.length;
    let result = `${prefix ?? ""}`;

    for (let i = 0; i < nameSplit.length; i++) {
      const splitLength = nameSplit[i].length > quotient + remainder
        ? quotient + remainder
        : Math.min(nameSplit[i].length, quotient + remainder);
      result += utils.capitalize(nameSplit[i].substring(0, splitLength));
      const remainderUsed = splitLength > quotient
        ? splitLength - quotient
        : 0;
      remainder -= remainderUsed;
    }

    if (postfix) result += postfix;
    const padding = length - result.length;
    if (padding > 0) {
      result += "I".repeat(padding);
    }

    return result;
  },

  nameString: (str) => {
    return str.replaceAll("", "'").trim();
  },

  stripHtml: (html, preferInnerText = false) => {
    let tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    if (preferInnerText) {
      return tmp.innerText ?? tmp.textContent ?? "";
    }
    return tmp.textContent || tmp.innerText || "";
  },

  htmlToElement: (html) => {
    const template = document.createElement('template');
    html = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = html;
    return template.content.firstChild;
  },

  htmlToDoc: (text) => {
    const parser = new DOMParser();
    return parser.parseFromString(text, "text/html");
  },

  htmlToDocumentFragment: (text) => {
    const dom = new DocumentFragment();
    $.parseHTML(text).forEach((element) => {
      dom.appendChild(element);
    });
    return dom;
  },

  replaceHtmlSpaces: (str) => {
    return str.replace(/&nbsp;/g, ' ').replace(/\xA0/g, ' ').replace(/\s\s+/g, ' ').trim();
  },

  renderLesserString: (str) => {
    return utils.replaceHtmlSpaces(utils.stripHtml(str)).trim().toLowerCase();
  },

  stringKindaEqual(a, b) {
    return utils.renderLesserString(a) === utils.renderLesserString(b);
  },

  findByProperty: (arr, property, searchString) => {
    function levenshtein(a, b) {
      let tmp;
      if (a.length === 0) {
        return b.length;
      }
      if (b.length === 0) {
        return a.length;
      }
      if (a.length > b.length) {
        tmp = a;
        a = b;
        b = tmp;
      }

      let i,
        j,
        res,
        alen = a.length,
        blen = b.length,
        row = Array(alen);
      for (i = 0; i <= alen; i++) {
        row[i] = i;
      }

      for (i = 1; i <= blen; i++) {
        res = i;
        for (j = 1; j <= alen; j++) {
          tmp = row[j - 1];
          row[j - 1] = res;
          res = b[i - 1] === a[j - 1] ? tmp : Math.min(tmp + 1, Math.min(res + 1, row[j] + 1));
        }
      }
      return res;
    }

    const maxDistance = 3;
    let minDistance = 100;
    let nearestHit = undefined;
    let nearestDistance = minDistance;

    if (!Array.isArray(arr)) return undefined;
    arr
      .filter((entry) => Object.prototype.hasOwnProperty.call(entry, property))
      .forEach((entry) => {
        let distance = levenshtein(searchString, entry[property]);
        if (distance < nearestDistance && distance <= maxDistance && distance < minDistance) {
          nearestHit = entry;
          nearestDistance = distance;
        }
      });

    return nearestHit;
  },

  calculateModifier: (val) => {
    return Math.floor((val - 10) / 2);
  },

  diceStringResultBuild: (diceMap, dice, bonus = "", mods = "", diceHint = "", specialFlags = "") => {
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
    const resultBonus = bonus === 0 ? "" : `${bonus > 0 ? ' +' : ' '} ${bonus}`;
    const diceHintAdd = globalDamageHints && diceHint && diceMap;
    const hintString = diceHintAdd ? diceHint : "";
    const diceHintString = diceMap.map(({ sign, count, die }, index) =>
      `${index ? `${sign} ` : ''}${count}d${die}${specialFlags}${hintString}`
    ).join(' ');

    const result = {
      dice,
      diceMap,
      diceHintString,
      bonus,
      diceString: [
        diceHintString,
        mods,
        resultBonus
      ].join('').trim(),
    };
    return result;
  },

  parseDiceString: (inStr, mods = "", diceHint = "", specialFlags = "") => {
    // sanitizing possible inputs a bit
    const str = `${inStr}`.toLowerCase().replace(/[-]/gu, "-").replace(/\s+/gu, "");

    // all found dice strings, e.g. 1d8, 4d6
    let dice = [];
    // all bonuses, e.g. -1+8
    let bonuses = [];

    const diceRegex = /(?<rawSign>[+-]*)(?<count>\d+)(?:d(?<die>\d+))?/gu;

    for (const { groups } of str.matchAll(diceRegex)) {
      const {
        rawSign = '+',
        count,
        die
      } = groups;

      // sign. We only take the sign standing exactly in front of the dice string
      // so +-1d8 => -1d8. Just as a failsave
      const sign = rawSign === "" ? "+" : rawSign.slice(-1);

      if (die) {
        dice.push({
          sign,
          count: parseInt(sign + count),
          die: parseInt(die)
        });
      } else {
        bonuses.push({
          sign,
          count: parseInt(sign + count)
        });
      }
    }

    // sum up the bonus
    const bonus = bonuses.reduce((prev, cur) => prev + cur.count, 0);

    // group the dice, so that all the same dice are summed up if they have the same sign
    // e.g.
    // +1d8+2d8 => 3d8
    // +1d8-2d8 => +1d8 -2d8 will remain as-is
    const diceMap = [];

    const groupBySign = utils.groupBy(dice, 'sign');
    for (const group of groupBySign.values()) {
      const groupByDie = utils.groupBy(group, 'die');

      for (const dieGroup of groupByDie.values()) {
        diceMap.push(
          dieGroup.reduce((acc, item) => ({
            ...acc,
            count: acc.count + item.count
          }))
        );
      }
    }

    diceMap.sort((a, b) => {
      if (a.die < b.die) return -1;
      if (a.die > b.die) return 1;
      if (a.sign === b.sign) {
        if (a.count < b.count) return -1;
        if (a.count > b.count) return 1;
        return 0;
      } else {
        return a.sign === "+" ? -1 : 1;
      }
    });

    const result = utils.diceStringResultBuild(diceMap, dice, bonus, mods, diceHint, specialFlags);
    return result;
  },

  isObject: (obj) => {
    return typeof obj === 'object' && !Array.isArray(obj) && obj !== null;
  },

  isString: (str) => {
    return typeof str === 'string' || str instanceof String;
  },

  isArray: (arr) => {
    return Array.isArray(arr);
  },

  isBoolean: (bool) => {
    return typeof bool === 'boolean';
  },

  isFunction: (func) => {
    return func instanceof Function;
  },

  mergeDeep: (target, source) => {
    let output = Object.assign({}, target);
    if (utils.isObject(target) && utils.isObject(source)) {
      Object.keys(source).forEach((key) => {
        if (utils.isObject(source[key])) {
          if (!(key in target)) Object.assign(output, { [key]: source[key] });
          else output[key] = utils.mergeDeep(target[key], source[key]);
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      });
    }
    return output;
  },

  filterDeprecated: (data) => {
    for (let prop in data) {
      if (
        data[prop]
        && Object.prototype.hasOwnProperty.call(data[prop], "_deprecated")
        && data[prop]["_deprecated"] === true
      ) {
        delete data[prop];
      }
      if (prop === "_deprecated" && data[prop] === true) {
        delete data[prop];
      }
    }
    return data;
  },

  getTemplateLegacy: (type) => {
    const templates = game.data.template;
    for (let entityType in templates) {
      if (
        templates[entityType].types
        && Array.isArray(templates[entityType].types)
        && templates[entityType].types.includes(type)
      ) {
        let obj = utils.mergeDeep({}, utils.filterDeprecated(templates[entityType][type]));
        if (obj.templates) {
          obj.templates.forEach((tpl) => {
            obj = utils.mergeDeep(obj, utils.filterDeprecated(templates[entityType].templates[tpl]));
          });
          delete obj.templates;
        }
        // store the result as JSON for easy cloning
        return JSON.stringify(obj);
      }
    }
    return undefined;
  },

  // eslint-disable-next-line complexity
  getTemplate: (type) => {
    switch (type.toLowerCase()) {
      case "character":
        return game.dnd5e.dataModels.actor.CharacterData.schema.initial();
      case "npc":
        return game.dnd5e.dataModels.actor.NPCData.schema.initial();
      case "vehicle":
        return game.dnd5e.dataModels.actor.VehicleData.schema.initial();
      case "class":
        return game.dnd5e.dataModels.item.ClassData.schema.initial();
      case "background":
        return game.dnd5e.dataModels.item.BackgroundData.schema.initial();
      case "consumable":
        return game.dnd5e.dataModels.item.ConsumableData.schema.initial();
      case "backpack":
      case "container":
        return game.dnd5e.dataModels.item.ContainerData.schema.initial();
      case "equipment":
      case "armor":
        return game.dnd5e.dataModels.item.EquipmentData.schema.initial();
      case "feat":
        return game.dnd5e.dataModels.item.FeatData.schema.initial();
      case "loot":
        return game.dnd5e.dataModels.item.LootData.schema.initial();
      case "race":
        return game.dnd5e.dataModels.item.RaceData.schema.initial();
      case "spell":
        return game.dnd5e.dataModels.item.SpellData.schema.initial();
      case "subclass":
        return game.dnd5e.dataModels.item.SubclassData.schema.initial();
      case "tool":
        return game.dnd5e.dataModels.item.ToolData.schema.initial();
      case "weapon":
        return game.dnd5e.dataModels.item.WeaponData.schema.initial();
      case "journalpage":
        return game.dnd5e.dataModels.journal.ClassJournalPageData.schema.initial();
      case "dnd-tashas-cauldron.tattoo":
      case "tattoo":
        return CONFIG.Item.dataModels["dnd-tashas-cauldron.tattoo"].schema.initial();
      default:
        return undefined;
    }
  },

  entityMap: () => {
    let entityTypes = new Map();
    entityTypes.set("spell", "Item");
    entityTypes.set("spells", "Item");
    entityTypes.set("inventory", "Item");
    entityTypes.set("item", "Item");
    entityTypes.set("items", "Item");
    entityTypes.set("equipment", "Item");
    entityTypes.set("consumable", "Item");
    entityTypes.set("tool", "Item");
    entityTypes.set("loot", "Item");
    entityTypes.set("class", "Item");
    entityTypes.set("backpack", "Item");
    entityTypes.set("container", "Item");
    entityTypes.set("magic-items", "Item");
    entityTypes.set("magic-item-spells", "Item");
    entityTypes.set("npc", "Actor");
    entityTypes.set("character", "Actor");
    entityTypes.set("monsters", "Actor");
    entityTypes.set("monster", "Actor");
    entityTypes.set("extras", "Actor");
    entityTypes.set("summon", "Actor");
    entityTypes.set("summons", "Actor");
    entityTypes.set("scene", "Scene");
    entityTypes.set("page", "JournalEntry");
    entityTypes.set("journal", "JournalEntry");
    entityTypes.set("journalEntry", "JournalEntry");
    entityTypes.set("background", "Item");
    entityTypes.set("compendium", "Compendium");
    entityTypes.set("class", "Item");
    entityTypes.set("classes", "Item");
    entityTypes.set("subclass", "Item");
    entityTypes.set("subclasses", "Item");
    entityTypes.set("feature", "Item");
    entityTypes.set("features", "Item");
    entityTypes.set("classfeatures", "Item");
    entityTypes.set("races", "Item");
    entityTypes.set("traits", "Item");
    return entityTypes;
  },

  versionCompare: (v1, v2, options) => {
    let lexicographical = options && options.lexicographical,
      zeroExtend = options && options.zeroExtend,
      v1parts = v1.split("."),
      v2parts = v2.split(".");

    function isValidPart(x) {
      return (lexicographical ? /^\d+[A-Za-z]*$/ : /^\d+$/).test(x);
    }

    if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
      return NaN;
    }

    if (zeroExtend) {
      while (v1parts.length < v2parts.length) v1parts.push("0");
      while (v2parts.length < v1parts.length) v2parts.push("0");
    }

    if (!lexicographical) {
      v1parts = v1parts.map(Number);
      v2parts = v2parts.map(Number);
    }

    for (let i = 0; i < v1parts.length; ++i) {
      if (v2parts.length == i) {
        return 1;
      }

      if (v1parts[i] > v2parts[i]) {
        return 1;
      }
      if (v1parts[i] < v2parts[i]) {
        return -1;
      }
    }

    if (v1parts.length != v2parts.length) {
      return -1;
    }

    return 0;
  },

  groupBy(arr, property) {
    const map = new Map();

    for (const item of arr) {
      const prop = item[property];
      const group = map.get(prop) ?? [];

      group.push(item);
      map.set(prop, group);
    }

    return map;
  },

  async namePrompt(question) {
    const content = `
    <label class="text-label">
      <input type="text" name="name"/>
    </label>
  `;
    const name = await new Promise((resolve) => {
      new Dialog({
        title: question,
        content,
        buttons: {
          ok: {
            label: "Okay",
            callback: async (html) => {
              const value = html.find("input[type='text'][name='name']").val();
              resolve(value);
            },
          },
          cancel: {
            label: "Cancel",
            callback: () => {
              resolve("");
            },
          }
        },
        default: "ok",
        close: () => {
          resolve("");
        },
      }).render(true);
    });
    return name;
  },

  renderPopup: (type, url) => {
    if (CONFIG.DDBI.POPUPS[type] && !CONFIG.DDBI.POPUPS[type].close) {
      CONFIG.DDBI.POPUPS[type].focus();
      CONFIG.DDBI.POPUPS[type].location.href = url;
    } else {
      const ratio = window.innerWidth / window.innerHeight;
      const width = Math.round(window.innerWidth * 0.5);
      const height = Math.round(window.innerWidth * 0.5 * ratio);
      CONFIG.DDBI.POPUPS[type] = window.open(
        url,
        "ddb_sheet_popup",
        `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
      );
    }
    return true;
  },

  addToProperties: (properties, value) => {
    const setProperties = properties
      ? utils.isArray(properties)
        ? new Set(properties)
        : properties
      : new Set();

    setProperties.add(value);
    return Array.from(setProperties);
  },

  removeFromProperties: (properties, value) => {
    const setProperties = properties
      ? utils.isArray(properties)
        ? new Set(properties)
        : properties
      : new Set();

    setProperties.delete(value);
    return Array.from(setProperties);
  },

  // matchedProperties = { "system.activation.type": "bonus" }
  matchProperties: (document, matchedProperties = {}) => {
    for (const [key, value] of Object.entries(matchedProperties)) {
      if (foundry.utils.getProperty(document, key) !== value) {
        return false;
      }
    }
    return true;
  },

  ordinalSuffixOf(i) {
    let j = i % 10,
      k = i % 100;
    if (j === 1 && k !== 11) {
      return i + "st";
    }
    if (j === 2 && k !== 12) {
      return i + "nd";
    }
    if (j === 3 && k !== 13) {
      return i + "rd";
    }
    return i + "th";
  },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utils);


/***/ }),

/***/ 5259:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": () => (/* binding */ setupLogger),
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2397);
/* eslint-disable no-continue */


const logger = {

  LOG_PREFIX: "DDB Importer",
  LOG_MSG_DEFAULT: "No logging message provided.  Please see the payload for more information.",

  _showMessage: (logLevel, data) => {
    if (!logLevel || !data || typeof (logLevel) !== 'string') {
      return false;
    }

    try {
      const setting = game.settings.get("ddb-importer", "log-level");
      const logLevels = ["DEBUG", "TIME", "TIMEEND", "TIMELOG", "INFO", "WARN", "ERR", "OFF"];
      const logLevelIndex = logLevels.indexOf(logLevel.toUpperCase());
      if (setting == "OFF"
              || logLevelIndex === -1
              || logLevelIndex < logLevels.indexOf(setting)) {
        return false;
      }
      return true;
    } catch (err) {
      return true;
    }

  },
  _addToLogFile: (logLevel, data) => {
    if (foundry.utils.getProperty(CONFIG.debug, "ddbimporter.record") === true) {
      CONFIG.debug.ddbimporter.log.push({
        level: logLevel,
        data: data,
      });
    }
  },
  // eslint-disable-next-line complexity
  log: (logLevel, ...data) => {
    logger._addToLogFile(logLevel, data);
    if (!logger._showMessage(logLevel, data)) {
      return;
    }

    const logLevelType = logLevel.startsWith("TIME")
      ? "DEBUG"
      : logLevel.toUpperCase();

    const msgContent = data[0] && typeof (data[0] == 'string')
      ? data[0]
      : logger.LOG_MSG_DEFAULT;
    const payload = data[0] && typeof (data[0] == 'string')
      ? data.length > 1
        ? data.slice(1)
        : null
      : data.slice();
    const msg = `${logger.LOG_PREFIX} | ${logLevelType} > ${msgContent}`;

    switch (logLevel.toUpperCase()) {
      case "DEBUG":
        if (payload) {
          console.debug(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.debug(msg);// eslint-disable-line no-console
        }
        break;
      case "INFO":
        if (payload) {
          console.info(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.info(msg);// eslint-disable-line no-console
        }
        break;
      case "WARN":
        if (payload) {
          console.warn(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.warn(msg);// eslint-disable-line no-console
        }
        break;
      case "ERR":
        if (payload) {
          console.error(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.error(msg);// eslint-disable-line no-console
        }
        break;
      case "TIME":
        if (payload) {
          console.time(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.time(msg);// eslint-disable-line no-console
        }
        break;
      case "TIMEEND":
        if (payload) {
          console.timeEnd(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.timeEnd(msg);// eslint-disable-line no-console
        }
        break;
      case "TIMELOG":
        if (payload) {
          console.timeLog(msg, ...payload);// eslint-disable-line no-console
        } else {
          console.timeLog(msg);// eslint-disable-line no-console
        }
        break;
      default: break;
    }
  },

  debug: (...data) => {
    logger.log("DEBUG", ...data);
  },

  info: (...data) => {
    logger.log("INFO", ...data);
  },

  warn: (...data) => {
    logger.log("WARN", ...data);
  },

  error: (...data) => {
    logger.log("ERR", ...data);
  },

  time: (...data) => {
    logger.log("TIME", ...data);
  },

  timeEnd: (...data) => {
    logger.log("TIMEEND", ...data);
  },

  timeLog: (...data) => {
    logger.log("TIMELOG", ...data);
  },

};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);

const getCircularReplacer = () => {
  const seen = new WeakSet();
  return (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (seen.has(value)) {
        return;
      }
      seen.add(value);
    }
    // eslint-disable-next-line consistent-return
    return value;
  };
};

function downloadLog() {
  _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].download */ .Z.download(JSON.stringify(CONFIG.debug.ddbimporter.log, getCircularReplacer()), `ddbimporter-log-data.json`, "application/json");
  foundry.utils.setProperty(CONFIG.debug, "ddbimporter.log", []);
}

function setupLogger() {
  const enabledDebugLogging = false;

  const defaults = {
    record: enabledDebugLogging,
    log: [],
    download: downloadLog,
  };

  foundry.utils.setProperty(CONFIG.debug, "ddbimporter", defaults);
}


/***/ }),

/***/ 9441:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": () => (/* binding */ downloadAdventureConfig),
/* harmony export */   "k": () => (/* binding */ generateAdventureConfig)
/* harmony export */ });
/* harmony import */ var _lib_DDBCampaigns_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9771);
/* harmony import */ var _lib_Secrets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2048);
/* harmony import */ var _vehicles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1187);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2397);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3893);
/* harmony import */ var _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(546);







async function getMonsterMap () {
  // ddb://monsters
  const monsterCompendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel("monster");
  const monsterCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getCompendium */ .Z.getCompendium(monsterCompendiumLabel);
  const monsterIndices = ["name", "flags.ddbimporter.id"];
  const monsterIndex = await monsterCompendium.getIndex({ fields: monsterIndices });

  const results = monsterIndex
    .filter((monster) => monster.flags?.ddbimporter?.id)
    .map((monster) => {
      return {
        id: monster.flags.ddbimporter.id,
        _id: monster._id,
        compendium: monsterCompendiumLabel,
        name: monster.name,
        documentName: monster.name,
      };
    });

  return Promise.all(results);
}

async function getSpellMap() {
  // ddb://spells
  // mm 2176
  const spellCompendiumLabel = await game.settings.get("ddb-importer", "entity-spell-compendium");
  const spellCompendium = await game.packs.find((pack) => pack.collection === spellCompendiumLabel);
  const spellIndices = ["name", "flags.ddbimporter.definitionId"];
  const spellIndex = await spellCompendium.getIndex({ fields: spellIndices });

  const results = spellIndex
    .filter((spell) => spell.flags?.ddbimporter?.definitionId)
    .map((spell) => {
      return {
        id: spell.flags.ddbimporter.definitionId,
        _id: spell._id,
        compendium: spellCompendiumLabel,
        name: spell.name,
        documentName: spell.name,
      };
    });

  return Promise.all(results);
}

async function getItemMap() {
  // ddb://magicitems
  const itemCompendiumLabel = await game.settings.get("ddb-importer", "entity-item-compendium");
  const itemCompendium = await game.packs.find((pack) => pack.collection === itemCompendiumLabel);
  const itemIndices = ["name", "flags.ddbimporter.definitionId"];
  const itemIndex = await itemCompendium.getIndex({ fields: itemIndices });

  const results = itemIndex
    .filter((item) => item.flags?.ddbimporter?.definitionId)
    .map((item) => {
      return {
        id: item.flags.ddbimporter.definitionId,
        _id: item._id,
        compendium: itemCompendiumLabel,
        name: item.name,
        documentName: item.name,
      };
    });

  return Promise.all(results);
}

const ATTACK_ACTION_MAP = {
  "Opportunity Attack": {
    hint: "Opportunity Attacks",
    page: "Making an Attack"
  },
  Grapple: {
    hint: "Grappling",
    page: "Making an Attack"
  },
  Shove: {
    hint: "Shoving a Creature",
    page: "Making an Attack"
  },
  "Two-Weapon Fighting": {
    hint: "Two-Weapon Fighting",
    page: "Making an Attack"
  },
  "Interact with an Object": {
    hint: "Use an Object",
    page: "Actions in Combat",
  },
};

async function generateAdventureConfig(full = false, cobalt = true, fullPageMap = false, legacy = false) {
  const result = {
    schemaVersion: CONFIG.DDBI.schemaVersion,
    debug: false,
    observeAll: false,
    version: game.modules.get("ddb-importer").version,
    lookups: {
      monsters: [],
      items: [],
      spells: [],
      skills: [],
      senses: [],
      conditions: [],
      actions: [],
      weaponproperties: [],
      vehicles: [],
      rule: [],
    },
    fullPageMap: [],
  };

  if (cobalt) {
    result.cobalt = (0,_lib_Secrets_js__WEBPACK_IMPORTED_MODULE_1__/* .getCobalt */ .HF)();
    result.campaignId = _lib_DDBCampaigns_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getCampaignId */ .Z.getCampaignId();
  }

  // @Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}

  if (full) {
    result.lookups.monsters = await getMonsterMap();
    result.lookups.spells = await getSpellMap();
    result.lookups.items = await getItemMap();
  }

  // vehicles
  if (!_lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].isCustom */ .Z.isCustom() && cobalt) {
    const vehicleData = await (0,_vehicles_js__WEBPACK_IMPORTED_MODULE_2__/* .getVehicleData */ .f)();

    result.lookups.vehicles = vehicleData.map((v) => {
      return {
        id: v.id,
        url: v.url,
        name: v.name,
      };
    });
  }

  if (legacy) {
    const rulesCompendium = "dnd5e.rules";
    const srdCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getCompendium */ .Z.getCompendium(rulesCompendium);
    if (!srdCompendium) return result;

    const srdIndex = await srdCompendium.getIndex();
    const srdDocuments = await srdCompendium.getDocuments();
    result.index = srdIndex;

    const skillEntryDocument = srdDocuments.find((d) => d.name === "Chapter 7: Using Ability Scores");
    if (skillEntryDocument) {
      result.lookups.skills = CONFIG.DDB.abilitySkills.map((skill) => {
        const skillEntryPage = skillEntryDocument.pages.find((p) => p.name === "Using Each Ability");
        const stat = CONFIG.DDB.stats.find((s) => s.id === skill.stat);
        const headerLink = `${stat.name} Checks`;
        return {
          id: skill.id,
          _id: skillEntryDocument._id,
          name: skill.name,
          compendium: rulesCompendium,
          documentName: skillEntryDocument.name,
          pageId: skillEntryPage._id,
          headerLink,
        };
      });
    }

    const senseEntryDocument = srdDocuments.find((d) => d.name === "Appendix D: Senses and Speeds");
    if (senseEntryDocument) {
      result.lookups.senses = CONFIG.DDB.senses
        .filter((sense) => senseEntryDocument.pages.some((p) => p.name === sense.name))
        .map((sense) => {
          const senseEntryPage = senseEntryDocument.pages.find((p) => p.name === sense.name);
          return {
            id: sense.id,
            _id: senseEntryDocument._id,
            name: sense.name,
            compendium: rulesCompendium,
            documentName: senseEntryDocument.name,
            pageId: senseEntryPage._id,
            headerLink: null,
          };
        });
    }

    const conditionEntryDocument = srdDocuments.find((d) => d.name === "Appendix A: Conditions");
    if (conditionEntryDocument) {
      result.lookups.conditions = CONFIG.DDB.conditions
        .filter((condition) => conditionEntryDocument.pages.some((p) => p.name.trim() === condition.definition.name.trim()))
        .map((condition) => {
          const conditionEntryPage = conditionEntryDocument.pages.find((p) => p.name.trim() === condition.definition.name.trim());
          return {
            id: condition.definition.id,
            _id: conditionEntryDocument.id,
            name: condition.definition.name,
            compendium: rulesCompendium,
            slug: condition.definition.slug,
            documentName: conditionEntryDocument.name,
            pageId: conditionEntryPage._id,
            headerLink: null,
          };
        });
    }

    const actionEntryDocument = srdDocuments.find((d) => d.name === "Chapter 9: Combat");
    if (actionEntryDocument) {
      const actionEntryPage = actionEntryDocument.pages.find((p) => p.name === "Actions in Combat");
      CONFIG.DDB.basicActions.forEach((action) => {
        if (ATTACK_ACTION_MAP[action.name]) {
          const attackEntryPage = actionEntryDocument.pages.find((p) => p.name === ATTACK_ACTION_MAP[action.name].page);
          result.lookups.actions.push({
            id: action.id,
            _id: actionEntryDocument._id,
            name: action.name,
            compendium: rulesCompendium,
            documentName: actionEntryDocument.name,
            pageId: attackEntryPage._id,
            headerLink: ATTACK_ACTION_MAP[action.name].hint,
          });
        } else if (action.id < 100) {
          result.lookups.actions.push({
            id: action.id,
            _id: actionEntryDocument.id,
            name: action.name,
            compendium: rulesCompendium,
            documentName: actionEntryDocument.name,
            pageId: actionEntryPage._id,
            headerLink: action.name,
          });
        }
      });
    }

    const equipmentDocument = srdDocuments.find((d) => d.name === "Chapter 5: Equipment");
    if (equipmentDocument) {
      const weaponPropertiesPage = equipmentDocument.pages.find((p) => p.name === "Weapons");
      result.lookups.weaponproperties = CONFIG.DDB.weaponProperties.map((prop) => {
        return {
          id: prop.id,
          _id: equipmentDocument._id,
          name: prop.name,
          compendium: rulesCompendium,
          documentName: equipmentDocument.name,
          pageId: weaponPropertiesPage._id,
          headerLink: "Weapon Properties",
        };
      });
    }

    if (fullPageMap) {
      srdDocuments.forEach((document) => {
        document.pages.forEach((page) => {
          result.fullPageMap.push({
            id: null,
            _id: document.id,
            name: page.name,
            compendium: rulesCompendium,
            documentName: document.name,
            pageId: page._id,
            headerLink: null,
          });
        });
      });
    }
  }

  return result;

}

async function downloadAdventureConfig() {
  const fullConfig = game.settings.get("ddb-importer", "adventure-muncher-full-config");
  const result = await generateAdventureConfig(fullConfig);
  _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].download */ .Z.download(JSON.stringify(result, null, 4), `adventure-config.json`, "application/json");
  return result;
}


/***/ }),

/***/ 267:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": () => (/* binding */ getFeats)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7162);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1438);
/* harmony import */ var _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6968);





const FEAT_TEMPLATE = {
  "name": "",
  "type": "feat",
  "system": {
    "description": {
      "value": "",
      "chat": "",
    },
    "type": {
      "value": "feat",
    },
    "source": "",
  },
  "sort": 2600000,
  "flags": {
    "ddbimporter": {
      "type": "feat",
    },
    "obsidian": {
      "source": {
        "type": "feat"
      }
    },
  },
  "img": null
};

function buildBase(data) {
  let result = foundry.utils.duplicate(FEAT_TEMPLATE);

  result.name = data.name;
  result.system.description.value += `${data.description}\n\n`;
  result.system.description.chat += `${data.snippet}\n\n`;

  result.flags.ddbimporter = {
    featId: data.id,
    version: CONFIG.DDBI.version,
  };

  result.flags.ddbimporter['prerequisites'] = data.prerequisites;
  if (data.prerequisites.length > 0) {
    const requirements = data.prerequisites.map((requirement) => requirement.description);
    result.system.requirements = requirements.join(", ");
    result.system.description.value += `<h3>Requirements</h3>\n\n${requirements.join("\n\n")}\n\n`;
  }

  result.system.source = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].parseSource */ .Z.parseSource(data);

  result.system.description.value = (0,_lib_DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_1__/* .parseTags */ .RN)(result.system.description.value);

  return result;
}


async function buildFeat(feat,) {
  let result = buildBase(feat);

  return result;
}


async function getFeats(data) {
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("get feats started");
  const updateBool = game.settings.get("ddb-importer", "munching-policy-update-existing");

  let feats = [];

  data.forEach((feat) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`${feat.name} feat parsing started...`);
    const parsedFeat = buildFeat(feat);
    feats.push(parsedFeat);
  });

  const itemHandler = await _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].buildHandler */ .Z.buildHandler("feats", feats, updateBool, { chrisPremades: true });
  return itemHandler.documents;
}


/***/ }),

/***/ 9633:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Fx": () => (/* binding */ addNPC),
/* harmony export */   "K8": () => (/* binding */ useSRDMonsterImages),
/* harmony export */   "NM": () => (/* binding */ generateIconMap),
/* harmony export */   "ln": () => (/* binding */ buildNPC),
/* harmony export */   "ph": () => (/* binding */ copyExistingMonsterImages),
/* harmony export */   "xD": () => (/* binding */ getNPCImage)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3893);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2397);
/* harmony import */ var _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2449);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6451);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7669);
/* harmony import */ var _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(306);
/* harmony import */ var _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6968);









// check items to see if retaining item, img or resources
async function existingItemRetentionCheck(currentItems, newItems, checkId = true) {
  const returnItems = [];

  await newItems.forEach((item) => {
    const existingItem = currentItems.find((owned) => {
      const simpleMatch
        = item.name === owned.name
        && item.type === owned.type
        && item.system.activation?.type === owned.system.activation?.type
        && ((checkId && item.flags?.ddbimporter?.id === owned.flags?.ddbimporter?.id) || !checkId);

      return simpleMatch;
    });

    if (existingItem) {
      if (existingItem.flags.ddbimporter?.ignoreItemImport) {
        returnItems.push(foundry.utils.duplicate(existingItem));
      } else {
        item["_id"] = existingItem.id;
        if (foundry.utils.getProperty(existingItem, "flags.ddbimporter.ignoreIcon") === true) {
          item.img = existingItem.img;
          foundry.utils.setProperty(item, "flags.ddbimporter.ignoreIcon", true);
        }
        if (foundry.utils.getProperty(existingItem, "flags.ddbimporter.retainResourceConsumption")) {
          item.system.consume = existingItem.system.consume;
          foundry.utils.setProperty(item, "flags.ddbimporter.retainResourceConsumption", true);
          if (foundry.utils.hasProperty(existingItem, "flags.link-item-resource-5e")) {
            foundry.utils.setProperty(item, "flags.link-item-resource-5e", existingItem.flags["link-item-resource-5e"]);
          }
        } else if (foundry.utils.getProperty(item, "system.consume.target")
          && foundry.utils.getProperty(item, "system.recharge.value")) {
          item.system.consume.target = existingItem.id;
        }

        if (!item.effects
          || (item.effects && item.effects.length == 0 && existingItem.effects && existingItem.effects.length > 0)
        ) {
          item.effects = foundry.utils.duplicate(existingItem.getEmbeddedCollection("ActiveEffect"));
        }

        returnItems.push(item);
      }
    } else {
      returnItems.push(item);
    }
  });

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Finished retaining items");
  return returnItems;
}


async function addNPCToCompendium(npc, type = "monster") {
  const itemImporter = new _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(type, []);
  if (itemImporter.compendium) {
    const npcBasic = (await itemImporter.addCompendiumFolderIds([foundry.utils.duplicate(npc)]))[0];

    let compendiumNPC;
    if (foundry.utils.hasProperty(npc, "_id") && itemImporter.compendium.index.has(npc._id)) {
      if (game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing")) {
        const existingNPC = await itemImporter.compendium.getDocument(npc._id);

        if (foundry.utils.hasProperty(npcBasic, "prototypeToken.flags.tagger.tags")
          && foundry.utils.hasProperty(existingNPC, "prototypeToken.flags.tagger.tags")
        ) {
          const newTags = [...new Set(npcBasic.prototypeToken.flags.tagger.tags, existingNPC.prototypeToken.flags.tagger.tags)];
          foundry.utils.setProperty(existingNPC, "prototypeToken.flags.tagger.tags", newTags);
        }

        const existing3dModel = foundry.utils.getProperty(existingNPC.prototypeToken, "flags.levels-3d-preview.model3d");
        if (existing3dModel && existing3dModel.trim() !== "") {
          foundry.utils.setProperty(npcBasic.prototypeToken, "flags.levels-3d-preview.model3d", existing3dModel);
        }

        const monsterTaggedItems = npcBasic.items.map((item) => {
          foundry.utils.setProperty(item, "flags.ddbimporter.parentId", npc._id);
          return item;
        });
        const existingItems = existingNPC.getEmbeddedCollection("Item");
        npcBasic.items = await existingItemRetentionCheck(existingItems, monsterTaggedItems, false);

        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("NPC Update Data", foundry.utils.duplicate(npcBasic));
        await existingNPC.deleteEmbeddedDocuments("Item", [], { deleteAll: true });
        await existingNPC.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
        // compendiumNPC = await existingNPC.update(npcBasic, { pack: compendium.collection, recursive: false, render: false, keepId: true });
        compendiumNPC = await existingNPC.update(npcBasic, { pack: itemImporter.compendium.collection, render: false, keepId: true });
        if (!compendiumNPC) {
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("No changes made to base character", npcBasic);
          compendiumNPC = existingNPC;
        }
      }
    } else {
      // create the new npc
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Creating NPC actor ${npcBasic.name}`);
      const options = {
        displaySheet: false,
        pack: itemImporter.compendium.collection,
        keepId: true,
      };
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("NPC New Data", foundry.utils.duplicate(npcBasic));
      compendiumNPC = await Actor.create(npcBasic, options);
    }

  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Error opening compendium, check your settings");
  }
  return npc;
}

// export async function addNPCDDBId(npc, type = "monster") {
//   let npcBasic = foundry.utils.duplicate(npc);
//   const compendium = CompendiumHelper.getCompendiumType(type, false);
//   if (compendium) {
//     // unlock the compendium for update/create
//     compendium.configure({ locked: false });
//     const monsterIndexFields = ["name", "flags.ddbimporter.id"];

//     const index = await compendium.getIndex({ fields: monsterIndexFields });
//     const npcMatch = index.contents.find((entity) =>
//       !foundry.utils.hasProperty(entity, "flags.ddbimporter.id")
//       && entity.name.toLowerCase() === npcBasic.name.toLowerCase()
//     );

//     if (npcMatch) {
//       if (game.settings.get(SETTINGS.MODULE_ID, "munching-policy-update-existing")) {
//         const existingNPC = await compendium.getDocument(npcMatch._id);
//         const updateDDBData = {
//           _id: npcMatch._id,
//           "flags.ddbimporter.id": npcBasic.flags.ddbimporter.id,
//         };
//         logger.debug("NPCId Update Data", foundry.utils.duplicate(updateDDBData));
//         await existingNPC.update(updateDDBData);
//       }
//     }
//   } else {
//     logger.error("Error opening compendium, check your settings");
//   }
// }


// eslint-disable-next-line complexity, no-unused-vars
async function getNPCImage(npcData, { type = "monster", forceUpdate = false, forceUseFullToken = false,
  forceUseTokenAvatar = false, disableAutoTokenizeOverride = false } = {}
) {
  // check to see if we have munched flags to work on
  if (!foundry.utils.hasProperty(npcData, "flags.monsterMunch.img")) {
    return npcData;
  }

  const updateImages = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-images");
  if (!forceUpdate && !updateImages && npcData.img !== CONST.DEFAULT_TOKEN) {
    return npcData;
  }

  const isStock = npcData.flags.monsterMunch.isStockImg;
  const useAvatarAsToken = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-full-token-image") || forceUseFullToken;
  const useTokenAsAvatar = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-token-avatar-image") || forceUseTokenAvatar;

  let ddbAvatarUrl = useTokenAsAvatar
    ? foundry.utils.getProperty(npcData, "flags.monsterMunch.tokenImg")
    : foundry.utils.getProperty(npcData, "flags.monsterMunch.img");
  let ddbTokenUrl = useAvatarAsToken
    ? foundry.utils.getProperty(npcData, "flags.monsterMunch.img")
    : foundry.utils.getProperty(npcData, "flags.monsterMunch.tokenImg");

  if (!ddbAvatarUrl && ddbTokenUrl) ddbAvatarUrl = ddbTokenUrl;
  if (!ddbTokenUrl && ddbAvatarUrl) ddbTokenUrl = ddbAvatarUrl;

  const hasAvatarProcessedAlready = CONFIG.DDBI.KNOWN.AVATAR_LOOKUPS.get(ddbAvatarUrl);
  const hasTokenProcessedAlready = CONFIG.DDBI.KNOWN.TOKEN_LOOKUPS.get(ddbTokenUrl);

  const npcType = type.startsWith("vehicle")
    ? "vehicle"
    : npcData.system.details.type.value
      ?? (npcData.system.details.type.custom && npcData.system.details.type.custom !== ""
        ? npcData.system.details.type.custom
        : "unknown");
  const genericNPCName = _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].referenceNameString */ .Z.referenceNameString(npcType);
  const npcName = _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].referenceNameString */ .Z.referenceNameString(npcData.name);

  const targetDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
  const subType = foundry.utils.getProperty(npcData, "system.details.type.value") ?? "other";
  const useDeepPaths = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-deep-file-paths");

  if (ddbAvatarUrl && foundry.utils.getProperty(npcData, "flags.monsterMunch.imgSet") !== true) {
    if (hasAvatarProcessedAlready) {
      npcData.img = CONFIG.DDBI.KNOWN.AVATAR_LOOKUPS.get(ddbAvatarUrl);
    } else {
      const ext = ddbAvatarUrl.split(".").pop().split(/#|\?|&/)[0];
      const genericNpc = ddbAvatarUrl.endsWith(npcType + "." + ext) || isStock;
      const name = genericNpc ? genericNPCName : npcName;
      const nameType = genericNpc ? "npc-generic" : "npc";
      const imageNamePrefix = useDeepPaths ? "" : nameType;
      const pathPostfix = useDeepPaths ? `/monster/avatar/${subType}` : "";
      const downloadOptions = { type: nameType, name, targetDirectory, pathPostfix, imageNamePrefix, force: forceUpdate || updateImages };
      // eslint-disable-next-line require-atomic-updates
      npcData.img = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getImagePath */ .Z.getImagePath(ddbAvatarUrl, downloadOptions);
    }
  }

  if (ddbTokenUrl && foundry.utils.getProperty(npcData, "flags.monsterMunch.tokenImgSet") !== true) {
    if (hasTokenProcessedAlready) {
      npcData.prototypeToken.texture.src = CONFIG.DDBI.KNOWN.TOKEN_LOOKUPS.get(ddbTokenUrl);
    } else {
      const tokenExt = ddbTokenUrl.split(".").pop().split(/#|\?|&/)[0];
      const genericNpc = ddbTokenUrl.endsWith(npcType + "." + tokenExt) || isStock;
      const name = genericNpc ? genericNPCName : npcName;
      const nameType = genericNpc ? "npc-generic-token" : "npc-token";
      const imageNamePrefix = useDeepPaths ? "" : nameType;
      const pathPostfix = useDeepPaths ? `/monster/token/${subType}` : "";
      // Token images always have to be downloaded.
      const downloadOptions = {
        type: nameType,
        name, download: true,
        remoteImages: false,
        force: forceUpdate || updateImages,
        imageNamePrefix,
        pathPostfix,
        targetDirectory
      };
      // eslint-disable-next-line require-atomic-updates
      npcData.prototypeToken.texture.src = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getImagePath */ .Z.getImagePath(ddbTokenUrl, downloadOptions);
    }
  }

  // check avatar, if not use token image
  // eslint-disable-next-line require-atomic-updates
  if (!npcData.img && npcData.prototypeToken.texture.src) npcData.img = npcData.prototypeToken.texture.src;

  // final check if image comes back as null
  // eslint-disable-next-line require-atomic-updates
  if (npcData.img === null) npcData.img = CONST.DEFAULT_TOKEN;
  // eslint-disable-next-line require-atomic-updates
  if (npcData.prototypeToken.texture.src === null) npcData.prototypeToken.texture.src = CONST.DEFAULT_TOKEN;

  // do we now want to tokenize that?
  const useTokenizer = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-tokenize")
    && !disableAutoTokenizeOverride
    && game.modules.get("vtta-tokenizer")?.active;
  // we don't tokenize if this path was already looked up, as it will already be done
  if (useTokenizer && !hasTokenProcessedAlready) {
    const compendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(type);
    const tokenizerName = isStock
      ? npcType
      : npcData.name;
    const autoOptions = { name: tokenizerName, nameSuffix: `-${compendiumLabel}`, updateActor: false };
    // eslint-disable-next-line require-atomic-updates
    npcData.prototypeToken.texture.src = await window.Tokenizer.autoToken(npcData, autoOptions);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Generated tokenizer image at ${npcData.prototypeToken.texture.src}`);
  }

  if (!hasAvatarProcessedAlready) CONFIG.DDBI.KNOWN.AVATAR_LOOKUPS.set(ddbAvatarUrl, npcData.img);
  if (!hasTokenProcessedAlready) CONFIG.DDBI.KNOWN.TOKEN_LOOKUPS.set(ddbTokenUrl, npcData.prototypeToken.texture.src);

  return npcData;
}

async function swapItems(data) {
  const swap = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-items");

  if (swap) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Replacing items...");
    // console.info(data.items);
    const getItemOptions = {
      monsterMatch: true,
    };
    const updatedItems = await _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getCompendiumItems */ .Z.getCompendiumItems(data.items, "inventory", getItemOptions);
    const itemsToRemove = updatedItems.map((item) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`${item.name} to ${item.flags.ddbimporter.originalItemName}`);
      return { name: item.flags.ddbimporter.originalItemName, type: item.type };
    });
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Swapping items", itemsToRemove);
    // console.warn(itemsToRemove);
    const lessUpdatedItems = data.items.filter((item) =>
      !itemsToRemove.some((target) => item.name === target.name && item.type === target.type)
    );
    // console.log(lessUpdatedItems);
    const newItems = lessUpdatedItems.concat(updatedItems);
    // console.error(newItems);
    // eslint-disable-next-line require-atomic-updates
    data.items = newItems;

  }
}

async function linkResourcesConsumption(actor) {
  if (actor.items.some((item) => item.system.recharge?.value)) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Resource linking for ${actor.name}`);
    actor.items.forEach((item) => {
      if (item.system?.recharge?.value) {
        const itemID = foundry.utils.randomID(16);
        item._id = itemID;
        if (item.type === "weapon") {
          item.type = "feat";
          delete item.system.type.value;
          item.system.type = {
            value: "monster",
            subtype: "",
          };
        }
        item.system.consume = {
          type: "charges",
          target: itemID,
          amount: null,
        };
      }
    });
  }
  return actor;
}

// async function buildNPC(data, srdIconLibrary, iconMap) {
async function buildNPC(data, type = "monster", temporary = true, update = false, handleBuild = false) {
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Importing Images");
  await getNPCImage(data, { type });
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Checking Items");
  await swapItems(data);

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Importing Icons");
  // eslint-disable-next-line require-atomic-updates
  data.items = await _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].updateIcons */ .Z.updateIcons(data.items, false, true, data.name);
  data = _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].addActorEffectIcons */ .Z.addActorEffectIcons(data);
  if (!["monster", "summons"].includes(type)) data = await linkResourcesConsumption(data);

  if (handleBuild) {
    // create the new npc
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Creating NPC actor");
    if (update) {
      const npc = game.actors.get(data._id);
      await npc.deleteEmbeddedDocuments("Item", [], { deleteAll: true });
      await Actor.updateDocuments([data]);
      return npc;
    } else {
      const options = {
        temporary,
        displaySheet: false,
      };
      const npc = await Actor.create(data, options);
      // temporary
      //   ? new Actor.implementation(data, options)
      //   : await Actor.create(data, options);
      return npc;
    }

  } else {
    return data;
  }

}

async function parseNPC(data, type) {
  const buildNpc = await buildNPC(data, type);
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Processing ${type} ${buildNpc.name} for the compendium`);
  const compendiumNPC = await addNPCToCompendium(buildNpc, type);
  return compendiumNPC;
}

function addNPC(data, type) {
  return new Promise((resolve, reject) => {
    parseNPC(data, type)
      .then((npc) => {
        resolve(npc);
      })
      .catch((error) => {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`error parsing NPC type ${type}: ${error} ${data.name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(error.stack);
        reject(error);
      });
  });
}

async function useSRDMonsterImages(monsters) {
  // eslint-disable-next-line require-atomic-updates
  if (game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd-monster-images")) {
    const srdImageLibrary = await _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getSRDImageLibrary */ .Z.getSRDImageLibrary();
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Updating SRD Monster Images`, true);

    monsters.forEach((monster) => {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Checking ${monster.name} for srd images`);
      const nameMatch = srdImageLibrary.find((m) => m.name === monster.name && m.type === "npc");
      if (nameMatch) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating monster ${monster.name} to srd images`, nameMatch);
        const compendiumName = _settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SRD_COMPENDIUMS.find */ .Z.SRD_COMPENDIUMS.find((c) => c.type == "monsters").name;
        const moduleArt = game.dnd5e.moduleArt.map.get(`Compendium.${compendiumName}.${nameMatch._id}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating monster ${monster.name} to srd images`, { nameMatch, moduleArt });
        monster.prototypeToken.texture.scaleY = nameMatch.prototypeToken.texture.scaleY;
        monster.prototypeToken.texture.scaleX = nameMatch.prototypeToken.texture.scaleX;
        if (moduleArt?.actor && nameMatch.actor !== "" && !moduleArt.actor.includes("mystery-man")) {
          monster.img = moduleArt.actor;
          foundry.utils.setProperty(monster, "flags.monsterMunch.imgSet", true);
        } else if (nameMatch.img && nameMatch.img !== "" && !nameMatch.img.includes("mystery-man")) {
          monster.img = nameMatch.img;
          foundry.utils.setProperty(monster, "flags.monsterMunch.imgSet", true);
        }
        if (moduleArt?.token && !foundry.utils.hasProperty(moduleArt, "token.texture.src")) {
          monster.prototypeToken.texture.src = moduleArt.token;
        } else if (moduleArt?.token?.texture?.src
          && moduleArt.token.texture.src !== ""
          && !moduleArt.token.texture.src.includes("mystery-man")
        ) {
          monster.prototypeToken.texture.src = moduleArt.token.texture.src;
          foundry.utils.setProperty(monster, "flags.monsterMunch.tokenImgSet", true);
          if (moduleArt.token.texture.scaleY) monster.prototypeToken.texture.scaleY = moduleArt.token.texture.scaleY;
          if (moduleArt.token.texture.scaleX) monster.prototypeToken.texture.scaleX = moduleArt.token.texture.scaleX;
        } else if (nameMatch.prototypeToken?.texture?.src
          && nameMatch.prototypeToken.texture.src !== ""
          && !nameMatch.prototypeToken.texture.src.includes("mystery-man")
        ) {
          foundry.utils.setProperty(monster, "flags.monsterMunch.tokenImgSet", true);
          monster.prototypeToken.texture.src = nameMatch.prototypeToken.texture.src;
        }
      }
    });
  }

  return monsters;
}

async function generateIconMap(monsters) {
  let promises = [];

  const srdIcons = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-srd-icons");
  // eslint-disable-next-line require-atomic-updates
  if (srdIcons) {
    const srdImageLibrary = await _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getSRDImageLibrary */ .Z.getSRDImageLibrary();
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Updating SRD Icons`, true);
    let itemMap = [];

    monsters.forEach((monster) => {
      _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Processing ${monster.name}`);
      promises.push(
        _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].copySRDIcons */ .Z.copySRDIcons(monster.items, srdImageLibrary, itemMap).then((items) => {
          monster.items = items;
        })
      );
    });
  }

  return Promise.all(promises);
}

function copyExistingMonsterImages(monsters, existingMonsters) {
  const updated = monsters.map((monster) => {
    const existing = existingMonsters.find((m) => monster.name === m.name);
    if (existing) {
      monster.img = existing.img;
      for (const key of Object.keys(monster.prototypeToken)) {
        if (!["sight", "detectionModes", "flags"].includes(key) && foundry.utils.hasProperty(existing.prototypeToken, key)) {
          monster.prototypeToken[key] = foundry.utils.deepClone(existing.prototypeToken[key]);
        }
      }
      return monster;
    } else {
      return monster;
    }
  });
  return updated;
}


/***/ }),

/***/ 8638:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S": () => (/* binding */ parseItems)
/* harmony export */ });
/* harmony import */ var _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2449);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7669);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2397);
/* harmony import */ var _lib_Secrets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2048);
/* harmony import */ var _lib_DDBCampaigns_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9771);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6451);
/* harmony import */ var _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(546);
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8636);
/* harmony import */ var _parser_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3163);
/* harmony import */ var _effects_vision5e_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(5042);
/* harmony import */ var _effects_DDBMacros_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6516);
/* harmony import */ var _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(306);
/* harmony import */ var _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(6968);
/* harmony import */ var _effects_external_ExternalAutomations_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(767);
// Main module class
















async function getCharacterInventory(items) {
  return items.map((item) => {
    return {
      chargesUsed: 0,
      definitionId: 0,
      definitionTypeId: 0,
      displayAsAttack: null,
      entityTypeId: 0,
      equipped: false,
      id: 0,
      isAttuned: false,
      quantity: item.bundleSize ? item.bundleSize : 1,
      definition: item,
    };
  });
}

async function generateImportItems(items) {
  const mockCharacter = {
    system: _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getTemplate */ .Z.getTemplate("character"),
    type: "character",
    name: "",
    flags: {
      ddbimporter: {
        compendium: true,
        dndbeyond: {
          effectAbilities: [],
          totalLevels: 0,
          proficiencies: [],
          proficienciesIncludingEffects: [],
          characterValues: [],
        },
      },
    },
  };
  const mockDDB = {
    character: {
      classes: [],
      race: {
        racialTraits: [],
      },
      characterValues: [],
      inventory: items,
      customItems: null,
      options: {
        class: [],
        race: [],
        feat: [],
      },
      modifiers: {
        race: [],
        class: [],
        background: [],
        feat: [],
        item: [],
        condition: [],
      },
      feats: [],
    }
  };
  let itemSpells = []; // here we need to parse each available spell and build a mock spell parser
  const ddbCharacter = new _parser_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z(mockDDB);
  ddbCharacter.raw.character = mockCharacter;
  ddbCharacter.source = {
    ddb: mockDDB
  };
  ddbCharacter.raw.itemSpells = [];
  const inventory = await ddbCharacter.getInventory();
  const results = {
    items: inventory,
    itemSpellNames: itemSpells, // this needs to be a list of spells to find
  };
  return results;
}

function getItemData(sourceFilter) {
  const cobaltCookie = (0,_lib_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)();
  const campaignId = _lib_DDBCampaigns_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getCampaignId */ .Z.getCampaignId();
  const parsingApi = _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getProxy */ .Z.getProxy();
  const betaKey = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].getPatreonKey */ .Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };
  const debugJson = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "debug-json");
  const enableSources = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-source-filter");
  const useGenerics = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-generic-items");
  const sources = enableSources
    ? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-muncher-sources").flat()
    : [];

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/items`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].download */ .Z.download(JSON.stringify(data), `items-raw.json`, "application/json");
        }
        if (!data.success) {
          _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => {
        const genericsFilteredData = data.data.filter((item) => item.canBeAddedToInventory || useGenerics);
        if (sources.length == 0 || !sourceFilter) return genericsFilteredData;
        return genericsFilteredData.filter((item) =>
          item.sources.some((source) => sources.includes(source.sourceId))
        );
      })
      .then((data) => {
        if (sources.length > 0) return data;
        if (game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew-only")) {
          return data.filter((item) => item.isHomebrew);
        } else if (!game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-item-homebrew")) {
          return data.filter((item) => !item.isHomebrew);
        } else {
          return data;
        }
      })
      .then((data) => getCharacterInventory(data))
      .then((items) => generateImportItems(items))
      .then((data) => resolve(data))
      .catch((error) => reject(error));
  });
}

async function addMagicItemSpells(items, spells, updateBool) {
  if (spells.length === 0) return;
  const itemHandler = new _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z("itemspells", spells);
  await itemHandler.init();
  const itemSpells = await itemHandler.updateCompendium(updateBool);
  // scan the inventory for each item with spells and copy the imported data over
  items.forEach((item) => {
    if (item.flags.magicitems.spells) {
      for (let [i, spell] of Object.entries(item.flags.magicitems.spells)) {
        const itemSpell = itemSpells.find((item) => item.name === spell.name);
        if (itemSpell) {
          for (const [key, value] of Object.entries(itemSpell)) {
            item.flags.magicitems.spells[i][key] = value;
          }
        }
      }
    }
  });
}

async function parseItems(ids = null, deleteBeforeUpdate = null) {
  const updateBool = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing");
  const magicItemsInstalled = !!game.modules.get("magicitems");
  const uploadDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");

  // to speed up file checking we pregenerate existing files now.
  _logger_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].info */ .Z.info("Checking for existing files...");
  await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles(uploadDirectory);
  _logger_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].info */ .Z.info("Check complete, getting ItemData.");

  await _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].generateCompendiumFolders */ .Z.generateCompendiumFolders("items");

  if (!CONFIG.DDBI.EFFECT_CONFIG.MODULES.configured) {
    // eslint-disable-next-line require-atomic-updates
    CONFIG.DDBI.EFFECT_CONFIG.MODULES.configured = await _effects_DDBMacros_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].configureDependencies */ .Z.configureDependencies();
  }

  _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote("Downloading item data..");

  // disable source filter if ids provided
  const sourceFilter = !(ids !== null && ids.length > 0);
  const results = await getItemData(sourceFilter);
  let items = results.items;

  _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote("Parsing item data..");

  // Items Spell addition is currently not done, parsing out spells needs to be addded
  // let itemSpells = results.value.itemSpells;
  let itemSpells = null;

  // store all spells in the folder specific for Dynamic Items
  if (magicItemsInstalled && itemSpells && Array.isArray(itemSpells)) {
    await addMagicItemSpells(items, itemSpells, updateBool);
  }

  await _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].preFetchDDBIconImages */ .Z.preFetchDDBIconImages();

  const itemHandler = new _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z("items", items, { deleteBeforeUpdate });
  await itemHandler.init();
  await itemHandler.srdFiddling();
  await itemHandler.iconAdditions();
  const filteredItems = (ids !== null && ids.length > 0)
    ? itemHandler.documents.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))
    : itemHandler.documents;
  const vision5eItems = (0,_effects_vision5e_js__WEBPACK_IMPORTED_MODULE_10__/* .addVision5eStubs */ .j)(filteredItems);
  itemHandler.documents = await _effects_external_ExternalAutomations_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].applyChrisPremadeEffects */ .Z.applyChrisPremadeEffects({ documents: vision5eItems, compendiumItem: true });

  const finalCount = itemHandler.documents.length;
  _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote(`Importing ${finalCount} items!`, true);
  _logger_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].time */ .Z.time("Item Import Time");

  const updateResults = await itemHandler.updateCompendium(updateBool);
  const updatePromiseResults = await Promise.all(updateResults);

  _logger_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].debug */ .Z.debug({ finalItems: itemHandler.documents, updateResults, updatePromiseResults });
  _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].munchNote */ .Z.munchNote("");
  _logger_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].timeEnd */ .Z.timeEnd("Item Import Time");
  return updateResults;
}




/***/ }),

/***/ 3466:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": () => (/* binding */ updateItemPrices),
/* harmony export */   "e": () => (/* binding */ calculatePrice)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3893);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5259);





// Function to calculate the new price
async function calculatePrice(rarity, consumable = false) {
  if (!_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equipment.priceFormulas */ .Z.equipment.priceFormulas[rarity]) return null;
  const roll = new Roll(_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equipment.priceFormulas */ .Z.equipment.priceFormulas[rarity]);
  await roll.evaluate({ async: true });
  return consumable ? parseInt(roll.total / 2) : roll.total;
}

// Function to update item prices
async function updateItemPrices({ keepExistingNonDDBPrices = true, keepExistingDDBPrices = true, compendiumName = null } = {}) {
  const packName = compendiumName ?? (await _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel("equipment"));
  const pack = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendium */ .Z.getCompendium(packName);
  pack.configure({ locked: false });

  if (!pack) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].error */ .Z.error("Compendium not found:", packName);
    return [];
  }

  const items = (await pack.getIndex({
    fields: [
      "name",
      "type",
      "system.rarity",
      "system.price.value",
      "flags.ddbimporter.price",
    ],
  })).filter((i) => {
    const rarity = i.system.rarity;
    if (!(rarity in _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equipment.priceFormulas */ .Z.equipment.priceFormulas)) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(`No update needed for ${i.name}, item has no rarity`);
      return false;
    }
    const gpPrice = i.system.price.value;
    const noGpValue = (gpPrice === undefined || gpPrice === null || gpPrice === 0);

    if (noGpValue) return true;
    const existingDDBPrice = foundry.utils.getProperty(i, "flags.ddbimporter.price.xgte");
    // console.warn(`checking ${i.name}`, { existingDDBPrice, keepExistingDDBPrices, keepExistingNonDDBPrices, i });
    if (!keepExistingDDBPrices && existingDDBPrice) return true;
    if (!keepExistingNonDDBPrices && !existingDDBPrice) return true;
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(`No update needed for ${i.name}`);
    return false;
  });

  const updates = [];

  // const items = await pack.getDocuments();

  for (let item of items) {
    const rarity = item.system.rarity;
    const gpPrice = item.system.price.value;
    const isConsumable = item.type === "consumable";

    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(`Processing ${item.name}: Rarity - ${rarity}, Price - ${gpPrice}, Consumable - ${isConsumable}`);

    const newPrice = keepExistingDDBPrices && foundry.utils.hasProperty(item, "flags.ddbimporter.price.value")
      ? foundry.utils.getProperty(item, "flags.ddbimporter.price.value")
      : await calculatePrice(rarity, isConsumable);
    if (newPrice !== null) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(`Adding update of GP price of ${item.name} (Rarity: ${rarity}) to ${newPrice} gp`);
      updates.push({
        _id: item._id,
        "system.price.value": newPrice,
        "system.price.denomination": "gp",
        "flags.ddbimporter.price": { xgte: true, value: newPrice },
      });
    }
  }

  await Item.updateDocuments(updates, { pack: packName });

  ui.notifications.info(`Attempted to update prices for ${updates.length} items.`);
  return items;
}


/***/ }),

/***/ 6502:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ parseSpells)
});

// EXTERNAL MODULE: ./src/apps/DDBMuncher.js + 17 modules
var DDBMuncher = __webpack_require__(2449);
// EXTERNAL MODULE: ./src/parser/spells/special.js
var special = __webpack_require__(1838);
// EXTERNAL MODULE: ./src/parser/spells/parseSpell.js + 12 modules
var parseSpell = __webpack_require__(1702);
;// CONCATENATED MODULE: ./src/parser/spells/getGenericSpells.js
// Import parsing functions



async function getSpells(spells) {
  let items = await Promise.all(spells
    .filter((spell) => spell.definition)
    .filter((spell) => {
      // remove archived material
      if (spell.definition.sources && spell.definition.sources.some((source) => source.sourceId === 39)) {
        return false;
      } else {
        return true;
      }
    })
    .map(async (spell) => {
      spell.flags = {
        ddbimporter: {
          generic: true,
          dndbeyond: {
            lookup: "generic",
            lookupName: "generic",
            level: spell.castAtLevel,
            castAtLevel: spell.castAtLevel,
          },
        },
      };

      return (0,parseSpell/* parseSpell */.T)(spell, null);
    }));

  if (items) {
    await (0,special/* fixSpells */.F)(null, items);
  }

  return items;
}

// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/DDBCampaigns.js
var DDBCampaigns = __webpack_require__(9771);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
// EXTERNAL MODULE: ./src/effects/vision5e.js
var vision5e = __webpack_require__(5042);
// EXTERNAL MODULE: ./src/lib/PatreonHelper.js
var PatreonHelper = __webpack_require__(8636);
// EXTERNAL MODULE: ./src/effects/DDBMacros.js
var DDBMacros = __webpack_require__(6516);
// EXTERNAL MODULE: ./src/lib/Iconizer.js
var Iconizer = __webpack_require__(306);
// EXTERNAL MODULE: ./src/lib/DDBItemImporter.js
var DDBItemImporter = __webpack_require__(6968);
// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/effects/external/ExternalAutomations.js
var ExternalAutomations = __webpack_require__(767);
;// CONCATENATED MODULE: ./src/muncher/spells.js
// Main module class
















function getSpellData(className, sourceFilter) {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };
  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");
  const enableSources = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-use-source-filter");
  const sources = enableSources
    ? game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-muncher-sources").flat()
    : [];

  return new Promise((resolve, reject) => {
    fetch(`${parsingApi}/proxy/class/spells`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `spells-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher/* default.munchNote */.Z.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => {
        if (sources.length == 0 || !sourceFilter) return data.data;
        return data.data.filter((spell) =>
          spell.definition.sources.some((source) => sources.includes(source.sourceId))
        );
      })
      .then((data) => {
        if (sources.length > 0) return data;
        if (game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-spell-homebrew-only")) {
          return data.filter((spell) => spell.definition.isHomebrew);
        } else if (!game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-spell-homebrew")) {
          return data.filter((spell) => !spell.definition.isHomebrew);
        } else {
          return data;
        }
      })
      .then((data) => resolve(data))
      .catch((error) => {
        logger/* default.warn */.Z.warn(error);
        reject(error);
      });
  });
}

async function parseSpells(ids = null, deleteBeforeUpdate = null) {
  const updateBool = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-update-existing");
  const uploadDirectory = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");

  // to speed up file checking we pregenerate existing files now.
  await FileHelper/* default.generateCurrentFiles */.Z.generateCurrentFiles(uploadDirectory);
  await DDBMuncher/* default.generateCompendiumFolders */.Z.generateCompendiumFolders("spells");

  if (!CONFIG.DDBI.EFFECT_CONFIG.MODULES.configured) {
    // eslint-disable-next-line require-atomic-updates
    CONFIG.DDBI.EFFECT_CONFIG.MODULES.configured = await DDBMacros/* default.configureDependencies */.Z.configureDependencies();
  }


  DDBMuncher/* default.munchNote */.Z.munchNote("Downloading spell data..");

  // disable source filter if ids provided
  const sourceFilter = !(ids !== null && ids.length > 0);
  const results = await Promise.allSettled([
    getSpellData("Cleric", sourceFilter),
    getSpellData("Druid", sourceFilter),
    getSpellData("Sorcerer", sourceFilter),
    getSpellData("Warlock", sourceFilter),
    getSpellData("Wizard", sourceFilter),
    getSpellData("Paladin", sourceFilter),
    getSpellData("Ranger", sourceFilter),
    getSpellData("Bard", sourceFilter),
    getSpellData("Graviturgy", sourceFilter),
    getSpellData("Chronurgy", sourceFilter),
    getSpellData("Artificer", sourceFilter),
  ]);

  DDBMuncher/* default.munchNote */.Z.munchNote("Parsing spell data.");

  const filteredResults = results
    .filter((r) => r.status === "fulfilled")
    .map((r) => r.value).flat().flat()
    .filter((v, i, a) => a.findIndex((t) => t.definition.name === v.definition.name) === i);

  const rawSpells = await getSpells(filteredResults);

  const spells = rawSpells
    .filter((spell) => spell?.name)
    .map((spell) => {
      spell.name = utils/* default.nameString */.Z.nameString(spell.name);
      return spell;
    });

  if (results.some((r) => r.status === "rejected")) {
    DDBMuncher/* default.munchNote */.Z.munchNote("Failed to parse some spells, see the developer console (F12) for details.");
    logger/* default.error */.Z.error("Failed spell parsing", results);
  }

  await Iconizer/* default.preFetchDDBIconImages */.Z.preFetchDDBIconImages();

  const uniqueSpells = spells.filter((v, i, a) => a.findIndex((t) => t.name === v.name) === i);
  const itemHandler = new DDBItemImporter/* default */.Z("spells", uniqueSpells, { deleteBeforeUpdate });
  await itemHandler.init();
  await itemHandler.srdFiddling();
  await itemHandler.iconAdditions();
  const filteredSpells = (ids !== null && ids.length > 0)
    ? itemHandler.documents.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))
    : itemHandler.documents;
  const visionSpells = (0,vision5e/* addVision5eStubs */.j)(filteredSpells);
  itemHandler.documents = await ExternalAutomations/* default.applyChrisPremadeEffects */.Z.applyChrisPremadeEffects({ documents: visionSpells, compendiumItem: true });

  const finalCount = itemHandler.documents.length;
  DDBMuncher/* default.munchNote */.Z.munchNote(`Importing ${finalCount} spells...`, true);
  logger/* default.time */.Z.time("Spell Import Time");
  const updateResults = await itemHandler.updateCompendium(updateBool);
  const updatePromiseResults = await Promise.all(updateResults);

  logger/* default.debug */.Z.debug({ finalSpells: itemHandler.documents, updateResults, updatePromiseResults });
  DDBMuncher/* default.munchNote */.Z.munchNote("");
  logger/* default.timeEnd */.Z.timeEnd("Spell Import Time");
  return updateResults;
}




/***/ }),

/***/ 8089:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BU": () => (/* binding */ updateWorldMonsters),
/* harmony export */   "CY": () => (/* binding */ parseCritters),
/* harmony export */   "mk": () => (/* binding */ resetCompendiumActorImages)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2397);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3893);
/* harmony import */ var _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2449);
/* harmony import */ var _importMonster_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9633);
/* harmony import */ var _parser_DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4029);
/* harmony import */ var _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6968);








let totalTargets = 0;
let count = 0;

async function updateActorsWithActor(targetActors, sourceActor) {
  let results = [];
  count++;

  for (let targetActor of targetActors) {
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Updating ${count}/${totalTargets} world monsters`);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Updating ${count}/${totalTargets} world monsters`, targetActor);
    const monsterItems = sourceActor.items.toObject().map((item) => {
      delete item._id;
      return item;
    });
    const actorUpdate = foundry.utils.duplicate(sourceActor);
    // pop items in later
    delete actorUpdate.items;


    const updateImages = game.settings.get("ddb-importer", "munching-policy-update-world-monster-update-images");
    if (!updateImages) {
      actorUpdate.img = targetActor.img;
      actorUpdate.prototypeToken.texture.src = targetActor.prototypeToken.texture.src;
      actorUpdate.prototypeToken.scale = targetActor.prototypeToken.scale;
      actorUpdate.prototypeToken.randomImg = targetActor.prototypeToken.randomImg;
      actorUpdate.prototypeToken.mirrorX = targetActor.prototypeToken.mirrorX;
      actorUpdate.prototypeToken.mirrorY = targetActor.prototypeToken.mirrorY;
      actorUpdate.prototypeToken.lockRotation = targetActor.prototypeToken.lockRotation;
      actorUpdate.prototypeToken.rotation = targetActor.prototypeToken.rotation;
      actorUpdate.prototypeToken.alpha = targetActor.prototypeToken.alpha;
      actorUpdate.prototypeToken.lightAlpha = targetActor.prototypeToken.lightAlpha;
      actorUpdate.prototypeToken.lightAnimation = targetActor.prototypeToken.lightAnimation;
      actorUpdate.prototypeToken.tint = targetActor.prototypeToken.tint;
      actorUpdate.prototypeToken.lightColor = targetActor.prototypeToken.lightColor;
    }

    const retainBiography = game.settings.get("ddb-importer", "munching-policy-update-world-monster-retain-biography");
    if (retainBiography) {
      actorUpdate.system.details.biography = targetActor.system.details.biography;
    }

    actorUpdate._id = targetActor.id;
    if (targetActor.folder) actorUpdate.folder = targetActor.folder._id;
    actorUpdate.sort = targetActor.sort;
    actorUpdate.ownership = targetActor.ownership;
    _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].copySupportedItemFlags */ .Z.copySupportedItemFlags(targetActor, actorUpdate);
    await targetActor.deleteEmbeddedDocuments("Item", [], { deleteAll: true });
    await targetActor.update(actorUpdate);
    // console.warn("afterdelete", foundry.utils.duplicate(targetActor));
    await targetActor.createEmbeddedDocuments("Item", monsterItems);
    // console.warn("after create", foundry.utils.duplicate(targetActor));

  };

  return Promise.all(results);
}

async function updateWorldMonsters() {
  let results = [];
  // get ddb monsters compendium
  const monsterCompendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel("monster");
  const monsterCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendium */ .Z.getCompendium(monsterCompendiumLabel);

  if (monsterCompendium) {
    const monsterIndices = ["name", "flags.ddbimporter.id"];
    const index = await monsterCompendium.getIndex({ fields: monsterIndices });
    totalTargets = game.actors.filter((a) => a.type === "npc" && foundry.utils.hasProperty(a, "flags.ddbimporter.id")).length;
    count = 0;
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Updating ${count}/${totalTargets} world monsters`);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Checking ${totalTargets} world monsters`);

    for (const [key, value] of index.entries()) {

      const worldMatches = game.actors.filter((actor) =>
        actor.flags?.ddbimporter?.id
        && actor.name === value.name
        && actor.flags.ddbimporter.id == value.flags?.ddbimporter?.id
      );

      if (worldMatches.length > 0) {
        _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Found ${value.name} world monster`, true);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Matched ${value.name} (${key})`);
        const monster = await monsterCompendium.getDocument(value._id);
        let updatedActors = await updateActorsWithActor(worldMatches, monster, count);
        results.push(updatedActors);
      }
    }
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote(`Finished updating ${totalTargets} world monsters`);
    _apps_DDBMuncher_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].munchNote */ .Z.munchNote("", true);

  } else {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Error opening compendium, check your settings");
  }
  return results;
}

async function resetCompendiumActorImages(compendiumName = null, type = "monster") {
  const monsterCompendiumLabel = compendiumName ? compendiumName : _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel(type);
  const monsterCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendium */ .Z.getCompendium(monsterCompendiumLabel);
  const fields = ["name", "flags.monsterMunch", "system.details.type.value", "img", "prototypeToken.texture.src"];
  const index = await monsterCompendium.getIndex({ fields });

  const otherDirectory = game.settings.get("ddb-importer", "other-image-upload-directory").replace(/^\/|\/$/g, "");
  await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles(otherDirectory);

  const updates = await Promise.all(index
    .filter((i) => i.name !== "#[CF_tempEntity]")
    .map(async (i) => {
      const options = { forceUpdate: true, disableAutoTokenizeOverride: true, type };
      const update = await (0,_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .getNPCImage */ .xD)(foundry.utils.duplicate(i), options);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Resetting ${i.name}`, update);
      return update;
    }));

  const results = await Actor.updateDocuments(updates, { pack: monsterCompendiumLabel });
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Reset results", results);
  return results;
}

async function parseCritters(ids = null) {
  const monsterFactory = new _parser_DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z();
  const parsedExtras = await monsterFactory.processIntoCompendium(ids);
  return parsedExtras;
}


/***/ }),

/***/ 1187:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "f": () => (/* binding */ getVehicleData),
  "b": () => (/* binding */ parseTransports)
});

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/apps/DDBMuncher.js + 17 modules
var DDBMuncher = __webpack_require__(2449);
// EXTERNAL MODULE: ./src/muncher/importMonster.js
var importMonster = __webpack_require__(9633);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/DDBCampaigns.js
var DDBCampaigns = __webpack_require__(9771);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
;// CONCATENATED MODULE: ./src/parser/vehicle/templates/vehicle.js
async function newVehicle(name) {
  const options = {
    temporary: true,
    displaySheet: false,
  };
  const vehicleClass = await Actor.create({ name, type: "vehicle" }, options);
  let vehicle = vehicleClass.toObject();
  const flags = {
    dnd5e: {},
    monsterMunch: {},
    ddbimporter: {
      dndbeyond: {},
    },
  };
  foundry.utils.setProperty(vehicle, "flags", flags);
  return vehicle;
};

// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
;// CONCATENATED MODULE: ./src/parser/vehicle/conditions.js


function getDamageImmunities(ddb) {
  const config = CONFIG.DDB.damageTypes;

  let values = [];
  let custom = [];

  const damageTypes = dictionary/* default.actions.damageType.filter */.Z.actions.damageType.filter((d) => d.name !== null).map((d) => d.name);

  ddb.damageImmunities.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    if (adjustment && damageTypes.includes(adjustment.name.toLowerCase())) {
      values.push(adjustment.name.toLowerCase());
    } else if (adjustment && adjustment.slug === "bludgeoning-piercing-and-slashing-from-nonmagical-attacks") {
      values.push("physical");
    } else if (adjustment) {
      const midiQolInstalled = game.modules.get("midi-qol")?.active;
      if (midiQolInstalled) {
        if (adjustment.name.toLowerCase().includes("silvered")) {
          values.push("silver");
        } else if (adjustment.name.toLowerCase().includes("adamantine")) {
          values.push("adamant");
        } else if (adjustment.slug === "damage-from-spells") {
          values.push("spell");
        } else {
          custom.push(adjustment.name);
        }
      } else {
        custom.push(adjustment.name);
      }
    }
  });

  const adjustments = {
    value: values,
    custom: custom.join("; "),
  };

  return adjustments;
}

function getConditionImmunities(ddb) {
  const config = CONFIG.DDB.conditions.map((condition) => {
    return {
      id: condition.definition.id,
      name: condition.definition.name,
      type: condition.definition.type,
      slug: condition.definition.slug,
    };
  });

  let values = [];
  let custom = [];

  ddb.conditionImmunities.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    const valueAdjustment = dictionary/* default.conditions.find */.Z.conditions.find((condition) => condition.label.toLowerCase() == adjustment.name.toLowerCase());
    if (adjustment && valueAdjustment) {
      values.push(valueAdjustment.foundry);
    } else if (adjustment) {
      custom.push(adjustment.name);
    }
  });

  const adjustments = {
    value: values,
    custom: custom.join("; "),
  };

  return adjustments;
}

;// CONCATENATED MODULE: ./src/parser/vehicle/abilities.js
const ABILITIES = [
  { id: 1, value: "str", long: "strength" },
  { id: 2, value: "dex", long: "dexterity" },
  { id: 3, value: "con", long: "constitution" },
  { id: 4, value: "int", long: "intelligence" },
  { id: 5, value: "wis", long: "wisdom" },
  { id: 6, value: "cha", long: "charisma" },
];

//     "abilities": {
// "str": {
//   "value": 27,
//   "proficient": 0,
//   "min": 3,
//   "mod": 8,
//   "save": 8,
//   "prof": 0,
//   "saveBonus": 0,
//   "checkBonus": 0,
//   "dc": 23
// },
// "dex": {
//   "value": 14,
//   "proficient": 1,
//   "min": 3,
//   "mod": 2,
//   "save": 9,
//   "prof": 7,
//   "saveBonus": 0,
//   "checkBonus": 0,
//   "dc": 17
// },
/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} ddb JSON Import
 * @param {obj} CONFIG.DDB config
 */
function getAbilities(abilities, ddb) {
  // go through every ability
  ABILITIES.forEach((ability) => {
    const value = ddb.stats.find((stat) => stat.id === ability.id)?.value || 10;
    const mod = value === 0
      ? -5
      : CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;

    abilities[ability.value]['value'] = value;
    abilities[ability.value]['proficient'] = 0;
    abilities[ability.value]['mod'] = mod;

  });

  return abilities;
}


function getAbilityMods(ddb) {
  let abilities = {};

  ABILITIES.forEach((ability) => {
    const value = ddb.stats.find((stat) => stat.id === ability.id)?.value || 10;
    const mod = value === 0
      ? -5
      : CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;

    abilities[ability.value] = mod;
  });

  return abilities;

}

;// CONCATENATED MODULE: ./src/parser/vehicle/size.js


const SIZES = [
  { name: "Tiny", value: "tiny", size: 0.5 },
  { name: "Small", value: "sm", size: 0.8 },
  { name: "Medium", value: "med", size: 1 },
  { name: "Large", value: "lg", size: 2 },
  { name: "Huge", value: "huge", size: 3 },
  { name: "Gargantuan", value: "grg", size: 4 },
];

function getSizeFromId(sizeId) {
  const size = CONFIG.DDB.creatureSizes.find((s) => s.id == sizeId).name;
  const sizeData = SIZES.find((s) => size == s.name);

  if (!sizeData) {
    logger/* default.warn */.Z.warn(`No size found, using medium`, size);
    return { name: "Medium", value: "med", size: 1 };
  }
  return sizeData;
}

function getSize (ddb) {
  const sizeData = getSizeFromId(ddb.sizeId);
  const token = {
    scale: sizeData.size >= 1 ? 1 : sizeData.size,
    value: sizeData.size >= 1 ? sizeData.size : 1,
  };

  const data = {
    value: sizeData.value,
    token: token,
  };

  return data;

}

;// CONCATENATED MODULE: ./src/parser/vehicle/capacity.js
function getCapacity(ddb) {
  let capacity = {
    creature: "",
    cargo: null,
  };

  if (ddb.cargoCapacity) {
    capacity.cargo = ddb.cargoCapacity;
  }

  if (ddb.creatureCapacity && ddb.creatureCapacity.length > 0) {
    const capacityStrings = ddb.creatureCapacity.map((c) => {
      const size = c.sizeId
        ? `${CONFIG.DDB.creatureSizes.find((s) => s.id == c.sizeId).name.toLowerCase()} `
        : "";

      return `${c.capacity} ${size}${c.type}`;
    });
    capacity.creature = capacityStrings.join(", ");
  }

  return capacity;
}

;// CONCATENATED MODULE: ./src/parser/vehicle/movement.js
const FLIGHT_IDS = [
  "7",
  "8",
];

const MOVEMENT_DICT = {
  "land": "walk",
  "water": "swim",
  "air": "fly",
  "magical": "Magical",
};

function getMovement(ddb, configurations, movement) {

  // is it travel pace?
  if (configurations.ETP) {
    movement["units"] = "mi";
    const travelPaceMilesPerHour = ddb.travelPace / 5280;
    if (FLIGHT_IDS.includes(ddb.id) || configurations.DT === "spelljammer") {
      movement["fly"] = travelPaceMilesPerHour;
    } else {
      movement["swim"] = travelPaceMilesPerHour;
    }
  } else {
    const primaryComponent = ddb.components.find((c) => c.isPrimaryComponent);
    if (primaryComponent && primaryComponent.speeds && primaryComponent.speeds.length > 0) {
      movement["units"] = "ft";
      const type = MOVEMENT_DICT[primaryComponent.speeds[0].type];
      movement[type] = primaryComponent.speeds[0].modes[0].value;
    }

  }

  return movement;
}

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
;// CONCATENATED MODULE: ./src/parser/vehicle/templates/component.js
// import logger from '../../../logger.js';


function newComponent(name, type) {
  // logger.debug("Generating new component:", { name, type });
  let feat = {
    name: name,
    type: type,
    system: utils/* default.getTemplate */.Z.getTemplate(type),
    flags: {
      ddbimporter: {
        dndbeyond: {
        },
      },
    },
  };
  return feat;
};

// EXTERNAL MODULE: ./src/lib/DDBReferenceLinker.js
var DDBReferenceLinker = __webpack_require__(7162);
;// CONCATENATED MODULE: ./src/parser/vehicle/components.js





const TYPE_MAPPING = {
  hull: "equipment",
  helm: "equipment",
  weapon: "weapon",
  movement: "equipment",
  control: "equipment",
  // "crew" action: feat
  // "action", action: feat
  feature: "feat",
  // "loot": loot
};

function getActivation(action, crew = false) {
  const actionType = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find((type) => type.id === action.activation?.activationType);
  const activation = {
    type: crew ? "crew" : actionType ? actionType.value : "action",
    cost: action.activation?.activationTime || 1,
    condition: "",
  };
  return activation;
}

function getLimitedUse(action) {
  if (
    action.limitedUse
    && (action.limitedUse.maxUses)
  ) {
    const resetType = dictionary/* default.resets.find */.Z.resets.find((type) => type.id === action.limitedUse.resetType);
    let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;

    const finalMaxUses = (maxUses) ? parseInt(maxUses) : null;

    return {
      value: (finalMaxUses !== null && finalMaxUses != 0) ? maxUses - action.limitedUse.numberUsed : null,
      max: (finalMaxUses != 0) ? finalMaxUses : null,
      per: resetType ? resetType.value : "",
    };
  } else {
    return {
      value: null,
      max: null,
      per: "",
    };
  }
}

function calculateRange(action, weapon) {
  if (action.range && action.range.aoeType && action.range.aoeSize) {
    weapon.system.range = { value: null, units: "self", long: "" };
    weapon.system.target = {
      value: action.range.aoeSize,
      type: dictionary/* default.actions.aoeType.find */.Z.actions.aoeType.find((type) => type.id === action.range.aoeType)?.value,
      units: "ft",
    };
  } else if (action.range && action.range.range) {
    weapon.system.range = {
      value: action.range.range,
      units: "ft",
      long: action.range.longRange || "",
    };
  } else {
    weapon.system.range = { value: 5, units: "ft", long: "" };
  }
  return weapon;
}


function getSaveAbility(description) {
  const save = description.match(/DC ([0-9]+) (.*?) saving throw|\(save DC ([0-9]+)\)/);
  if (save) {
    return save[2] ? save[2].toLowerCase().substr(0, 3) : "";
  } else {
    return "";
  }
}

function getActionType(action) {
  let actionType = "rwak";
  // lets see if we have a save stat for things like Dragon born Breath Weapon
  if (typeof action.saveStatId === "number" || action.fixedSaveDc) {
    actionType = "save";
  } else if (action.actionType === 1) {
    if (action.attackTypeRange === 2) {
      actionType = "rwak";
    } else {
      actionType = "mwak";
    }
  } else if (action.rangeId && action.rangeId === 1) {
    actionType = "mwak";
  } else if (action.rangeId && action.rangeId === 2) {
    actionType = "rwak";
  } else {
    actionType = "other";
  }
  return actionType;
}


function getWeaponProperties(action, weapon) {
  if (action.name) weapon.name += `: ${action.name}`;
  weapon.system.description.value += `\n${action.description}`;

  if (action.fixedToHit !== null) {
    weapon.system.attack.bonus = `${action.fixedToHit}`;
  }

  weapon.system.type.value = "siege";
  weapon.system.target = {
    "value": 1,
    "width": null,
    "units": "",
    "type": "creature"
  };
  if (Number.isInteger(action.numberOfTargets)) weapon.system.target.value = action.numberOfTargets;

  const damageType = dictionary/* default.actions.damageType.find */.Z.actions.damageType.find((type) => type.id === action.damageTypeId).name;

  if (action.dice?.diceString) weapon.system.damage.parts = [[action.dice.diceString, damageType]];

  if (action.fixedSaveDc) {
    const saveAbility = (action.saveStatId)
      ? dictionary/* default.character.abilities.find */.Z.character.abilities.find((stat) => stat.id === action.saveStatId).value
      : getSaveAbility(action.description);
    weapon.system.save = {
      ability: saveAbility,
      dc: Number.parseInt(action.fixedSaveDc),
      scaling: "flat",
    };
  }

  weapon.system.equipped = true;
  weapon.system.actionType = getActionType(action);
  weapon.system.uses = getLimitedUse(action);
  weapon.system.activation = getActivation(action, weapon.system.activation.type === "crew");
  weapon = calculateRange(action, weapon);

  return weapon;

}

// eslint-disable-next-line complexity
function buildComponents(ddb, configurations, component) {
  const results = [];
  const types = component.definition.types.map((t) => t.type);
  const item = foundry.utils.duplicate(newComponent(component.definition.name, TYPE_MAPPING[types[0]]));

  if (types[0] === "equipment") {
    foundry.utils.setProperty(item, "data.armor.type", "vehicle");
  }

  if (component.description) item.system.description.value = (0,DDBReferenceLinker/* parseTags */.RN)(component.description);

  item.system.quantity = component.count;

  item.system.armor = {
    value: null,
    type: "vehicle",
    dex: null
  };
  item.system.hp = {
    value: null,
    max: null,
    dt: null,
    conditions: ""
  };

  if (component.groupType === "action-station") {
    item.system.activation.type = "crew";
    switch (component.definition.coverType) {
      case "full":
        item.system.cover = 1;
        break;
      case "half":
        item.system.cover = 0.5;
        break;
      case "three-quarters":
        item.system.cover = 0.75;
        break;
      default:
        item.system.cover = undefined;
        break;
    }

  } else if (component.definition.groupType === "component") {

    if (component.definition.speeds && component.definition.speeds.length > 0) {
      item.system.speed = {
        value: component.definition.speeds[0].modes[0].value,
        conditions: component.definition.speeds[0].modes[0].description
          ? component.definition.speeds[0].modes[0].description
          : "",
      };
      if (component.definition.speeds[0].modes.length > 1) {
        const speedConditions = [];
        for (let i = 1; i < component.definition.speeds[0].modes.length; i++) {
          const speedValue = component.definition.speeds[0].modes[i].value;
          const speedCondition = component.definition.speeds[0].modes[i].description
            ? component.definition.speeds[0].modes[i].description
            : "";
          const speedRestriction = component.definition.speeds[0].modes[i].restrictionsText
            ? component.definition.speeds[0].modes[i].restrictionsText
            : "";
          speedConditions.push(`${speedValue} ${speedCondition}${speedRestriction}`);
        }

        const speedAdjustment = component.definition.types.find((t) => t.type === "movement");
        if (speedAdjustment && speedAdjustment.adjustments && speedAdjustment.adjustments.length > 0) {
          speedAdjustment.adjustments.filter((a) => a.type === "speed").forEach((a) => {
            a.values.forEach((v) => {
              speedConditions.push(`-${v.perDamageValue}ft speed per ${v.perDamageTaken} damage taken`);
            });
          });
        }
        if (speedConditions.length > 0) {
          item.system.speed.conditions += speedConditions.join("; ");
        }
      }
    }

    if (Number.isInteger(component.definition.armorClass)) {
      item.system.armor = {
        value: parseInt(component.definition.armorClass),
        type: "vehicle",
        dex: null
      };
    }

    if (Number.isInteger(component.definition.hitPoints)) {
      item.system.hp = {
        value: parseInt(component.definition.hitPoints),
        max: parseInt(component.definition.hitPoints),
        dt: null,
        conditions: ""
      };
      if (component.definition.damageThreshold) {
        item.system.hp.dt = component.definition.damageThreshold;
      }
    }
  }

  if (types.includes("weapon") && component.definition.actions.length > 0) {
    logger/* default.debug */.Z.debug("processing weapon", component);
    component.definition.actions.forEach((action) => {
      const actionItem = getWeaponProperties(action, foundry.utils.duplicate(item));
      logger/* default.debug */.Z.debug("action item", actionItem);
      results.push(actionItem);
    });
  } else {
    results.push(item);
  }

  return results;

}

function processComponents(ddb, configurations) {
  const components = ddb.components.sort((c) => c.displayOrder);

  const componentCount = {};
  const uniqueComponents = [];
  components.forEach((component) => {
    const key = component.definitionKey;
    const count = componentCount[key] || 0;
    if (count === 0) uniqueComponents.push(component);
    componentCount[key] = count + 1;
  });


  const componentItems = uniqueComponents
    .filter((f) => f.definition.name)
    .map((component) => {
      component.count = componentCount[component.definitionKey];
      const builtItems = buildComponents(ddb, configurations, component);
      return builtItems;
    })
    .flat();

  const featureItems = ddb.features
    .filter((f) => f.name)
    .map((feature) => {
      foundry.utils.setProperty(feature, "definition.types", [{ type: "feature" }]);
      foundry.utils.setProperty(feature, "definition.name", feature.name);
      const builtItems = buildComponents(ddb, configurations, feature);
      return builtItems;
    })
    .flat();

  return featureItems.concat(componentItems);
}

;// CONCATENATED MODULE: ./src/parser/vehicle/threshold.js
const ACTION_THRESHOLDS = [
  {
    id: "7",
    thresholds: {
      0: 1,
      1: 10,
      2: 20,
    },
  },
  {
    id: "11",
    thresholds: {
      0: null,
      1: null,
      2: null,
    },
  },
  {
    id: "9",
    thresholds: {
      0: null,
      1: null,
      2: null,
    },
  },
  {
    id: "1",
    thresholds: {
      0: 3,
      1: 20,
      2: 40,
    },
  },
  {
    id: "2",
    thresholds: {
      0: 1,
      1: null,
      2: 2,
    },
  },
  {
    id: "3",
    thresholds: {
      0: 20,
      1: null,
      2: 40,
    },
  },
  {
    id: "8",
    thresholds: {
      0: 1,
      1: null,
      2: 1,
    },
  },
  {
    id: "4",
    thresholds: {
      0: 1,
      1: null,
      2: 2,
    },
  },
  {
    id: "5",
    thresholds: {
      0: 3,
      1: 10,
      2: 20,
    },
  },
  {
    id: "12",
    thresholds: {
      0: null,
      1: null,
      2: null,
    },
  },
  {
    id: "10",
    thresholds: {
      0: null,
      1: null,
      2: null,
    },
  },
  {
    id: "6",
    thresholds: {
      0: 3,
      1: 10,
      2: 20,
    },
  },
];

;// CONCATENATED MODULE: ./src/parser/vehicle/vehicle.js














// eslint-disable-next-line complexity
async function parseVehicle(ddb, extra = {}) {

  logger/* default.debug */.Z.debug("Parsing vehicle", { extra });
  let vehicle = foundry.utils.duplicate(await newVehicle(ddb.name));
  const configurations = {};
  ddb.configurations.forEach((c) => {
    configurations[c.key] = c.value;
  });

  let img = ddb.largeAvatarUrl;
  // foundry doesn't support gifs
  if (img && img.match(/.gif$/)) {
    img = null;
  }
  vehicle.prototypeToken.name = ddb.name;
  vehicle.flags.monsterMunch = {
    url: ddb.url,
    img: (img) ? img : ddb.avatarUrl,
    tokenImg: ddb.avatarUrl,
  };
  vehicle.flags.ddbimporter = {
    id: ddb.id,
    version: CONFIG.DDBI.version,
    configurations,
  };

  // const removedHitPoints = ddb.removedHitPoints ? ddb.removedHitPoints : 0;
  // const temporaryHitPoints = ddb.temporaryHitPoints ? ddb.removedHitPoints : 0;

  // abilities
  vehicle.system.abilities = getAbilities(vehicle.system.abilities, ddb);

  // Conditions
  vehicle.system.traits.di = getDamageImmunities(ddb);
  vehicle.system.traits.ci = getConditionImmunities(ddb);

  // size
  const size = getSize(ddb);
  vehicle.system.traits.size = size.value;
  vehicle.prototypeToken.width = size.token.value;
  vehicle.prototypeToken.height = size.token.value;
  vehicle.prototypeToken.scale = size.token.scale;

  vehicle.system.attributes.capacity = getCapacity(ddb);

  if (configurations.ST === "dimension") {
    vehicle.system.traits.dimensions = `(${ddb.length} ft. by ${ddb.width} ft.)`;
  }
  if (configurations.ST === "weight") {
    vehicle.system.traits.dimensions = `(${ddb.weight} lb.)`;
  }

  const movement = foundry.utils.duplicate(vehicle.system.attributes.movement);
  vehicle.system.attributes.movement = getMovement(ddb, configurations, movement);

  const primaryComponent = ddb.components.find((c) => c.isPrimaryComponent);
  // // ac
  // if we are using actor level HP apply
  if (!configurations.ECCR && primaryComponent) {
    vehicle.system.attributes.hp.value = primaryComponent.definition.hitPoints;
    vehicle.system.attributes.hp.max = primaryComponent.definition.hitPoints;
    if (!configurations.ECMT && Number.isInteger(primaryComponent.definition.mishapThreshold)) {
      vehicle.system.attributes.hp.mt = primaryComponent.definition.mishapThreshold;
    }
    if (!configurations.ECDT && Number.isInteger(primaryComponent.definition.damageThreshold)) {
      vehicle.system.attributes.hp.dt = primaryComponent.definition.damageThreshold;
    }
  }

  // if we are using actor level AC apply
  if (configurations.PCMT === "vehicle" && primaryComponent) {
    const mods = getAbilityMods(ddb);
    if (configurations.DT === "spelljammer") {
      vehicle.system.attributes.ac.motionless = primaryComponent.definition.armorClassDescription;
      vehicle.system.attributes.ac.flat = primaryComponent.definition.armorClass;
    } else {
      vehicle.system.attributes.ac.motionless = primaryComponent.definition.armorClass;
      vehicle.system.attributes.ac.flat = primaryComponent.definition.armorClass + mods["dex"];
    }
  }

  vehicle.system.vehicleType = FLIGHT_IDS.includes(ddb.id) || configurations.DT === "spelljammer"
    ? "air"
    : configurations.DT === "ship"
      ? "water"
      : "land";

  vehicle.items = processComponents(ddb, configurations);

  // No 5e support for vehicles yet:
  // fuel data

  // details
  vehicle.system.details.source = DDBHelper/* default.parseSource */.Z.parseSource(ddb);
  vehicle.system.details.biography.value = (0,DDBReferenceLinker/* parseTags */.RN)(ddb.description);

  if (configurations.EAS) {
    vehicle.system.attributes.actions.stations = true;
  }

  if (ddb.actionsText) {
    vehicle.system.details.biography.value += `<h2>Actions</h2>\n<p>${ddb.actionsText}</p>`;
    const componentActionSummaries = ddb.componentActionSummaries.map((feature) => {
      return `<h3>${feature.name}</h3>\n<p>${feature.description}</p>`;
    }).join('\n');
    vehicle.system.details.biography.value += `\n<p>${componentActionSummaries}</p>`;

    const actionsRegex = /On its turn(?:,*) the (?:.*?) can take (\d+) action/g;
    const actionsMatch = ddb.actionsText.match(actionsRegex);
    const numberOfActions = actionsMatch ? parseInt(actionsMatch[1]) : 1;

    vehicle.system.attributes.actions.value = numberOfActions;
    const actionThreshold = ACTION_THRESHOLDS.find((t) => t.id === ddb.id);
    vehicle.system.attributes.actions.thresholds = actionThreshold ? actionThreshold.thresholds : [];

  } else if (ddb.features.length > 0) {
    const featuresText = ddb.features.map((feature) => {
      return `<h3>${feature.name}</h3>\n<p>${feature.description}</p>`;
    }).join('\n');
    vehicle.system.details.biography.value += `<h2>Features</h2>\n<p>${featuresText}</p>`;
  }

  vehicle = await CompendiumHelper/* default.existingActorCheck */.Z.existingActorCheck("vehicle", vehicle);

  return vehicle;
}


async function parseVehicles(ddbData, extra = false) {

  let foundryActors = [];
  let failedVehicleNames = [];

  ddbData.forEach((vehicle) => {
    try {
      logger/* default.debug */.Z.debug(`Attempting to parse ${vehicle.name}`);
      const foundryActor = parseVehicle(vehicle, extra);
      foundryActors.push(foundryActor);
    } catch (err) {
      logger/* default.error */.Z.error(`Failed parsing ${vehicle.name}`);
      logger/* default.error */.Z.error(err);
      logger/* default.error */.Z.error(err.stack);
      failedVehicleNames.push(vehicle.name);
    }
  });

  const result = {
    actors: await Promise.all(foundryActors),
    failedVehicleNames,
  };

  return result;
}

// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
// EXTERNAL MODULE: ./src/lib/PatreonHelper.js
var PatreonHelper = __webpack_require__(8636);
// EXTERNAL MODULE: ./src/lib/DDBCompendiumFolders.js
var DDBCompendiumFolders = __webpack_require__(819);
// EXTERNAL MODULE: ./src/lib/DDBItemImporter.js
var DDBItemImporter = __webpack_require__(6968);
// EXTERNAL MODULE: ./src/hooks/ready/checkCompendiums.js
var checkCompendiums = __webpack_require__(9187);
;// CONCATENATED MODULE: ./src/muncher/vehicles.js














/**
 *
 * @returns {Promise<Array<JSON>>} A promise that resolves to an array of JSON vehicles from DDB
 */
function getVehicleData(ids) {
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();

  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };

  if (ids && ids.length > 0) {
    body.ids = [...new Set(ids)];
  } else {
    const searchFilter = $("#monster-munch-filter")[0];
    const searchTerm = searchFilter?.value || "";
    const enableSources = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-use-source-filter");
    const sources = enableSources
      ? game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-muncher-sources").flat()
      : [];
    body.sources = sources;
    body.search = searchTerm;
    body.homebrew = body.sources.length > 0 ? false : game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-homebrew");
    body.homebrewOnly = body.sources.length > 0 ? false : game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-homebrew-only");
    body.searchTerm = encodeURIComponent(searchTerm);
    body.exactMatch = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-exact-match");
    body.excludeLegacy = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-exclude-legacy");
  }

  const url = ids && ids.length > 0
    ? `${parsingApi}/proxy/vehicles/ids`
    : `${parsingApi}/proxy/vehicles`;

  const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  return new Promise((resolve, reject) => {
    fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    })
      .then((response) => response.json())
      .then((data) => {
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `vehicles-raw.json`, "application/json");
        }
        if (!data.success) {
          DDBMuncher/* default.munchNote */.Z.munchNote(`Failure: ${data.message}`);
          reject(data.message);
        }
        return data;
      })
      .then((data) => resolve(data.data))
      .catch((error) => reject(error));
  });
}

/**
 *
 * @param {*} ddbData json data from DDB
 * @returns array of vehicles processed to Foundry
 */
async function processVehicleData(ddbData) {
  DDBMuncher/* default.munchNote */.Z.munchNote(`Retrieved ${ddbData.length} vehicles, starting parse...`, true, false);
  logger/* default.info */.Z.info(`Retrieved ${ddbData.length} vehicles`);
  const parsedVehicles = await parseVehicles(ddbData);

  DDBMuncher/* default.munchNote */.Z.munchNote(
    `Parsed ${parsedVehicles.actors.length} vehicles, failed ${parsedVehicles.failedVehicleNames.length} vehicles`,
    false,
    true
  );
  logger/* default.info */.Z.info(`Parsed ${parsedVehicles.actors.length} vehicles, failed ${parsedVehicles.failedVehicleNames.length} vehicles`);
  if (parsedVehicles.failedVehicleNames && parsedVehicles.failedVehicleNames.length !== 0) {
    logger/* default.error */.Z.error(`Failed to parse`, parsedVehicles.failedVehicleNames);
  }
  return parsedVehicles.actors;
}


async function parseTransports(ids = null) {
  const compData = settings/* default.COMPENDIUMS.find */.Z.COMPENDIUMS.find((c) => c.title === "Vehicles");
  await (0,checkCompendiums/* createDDBCompendium */.v)(compData);

  foundry.utils.setProperty(CONFIG.DDBI, "MUNCHER.TEMPORARY", {});
  const updateBool = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-update-existing");
  const updateImages = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-update-images");
  const uploadDirectory = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");

  // to speed up file checking we pregenerate existing files now.
  logger/* default.info */.Z.info("Checking for existing files...");
  DDBMuncher/* default.munchNote */.Z.munchNote(`Checking existing image files...`);
  await FileHelper/* default.generateCurrentFiles */.Z.generateCurrentFiles(uploadDirectory);
  logger/* default.info */.Z.info("Check complete getting vehicle data...");
  DDBMuncher/* default.munchNote */.Z.munchNote(`Getting vehicle data from DDB...`);
  let vehicleJSON = await getVehicleData(ids);
  let vehicles = await processVehicleData(vehicleJSON);

  const vehicleHandler = new DDBItemImporter/* default */.Z("vehicles", vehicles);
  await vehicleHandler.init();

  if (!updateBool || !updateImages) {
    DDBMuncher/* default.munchNote */.Z.munchNote(`Calculating which vehicles to update...`, true);
    const existingVehicles = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(vehicles, "vehicles", { keepDDBId: true });
    const existingVehiclesTotal = existingVehicles.length + 1;
    if (!updateBool) {
      logger/* default.debug */.Z.debug("Removing existing vehicles from import list");
      logger/* default.debug */.Z.debug(`Matched ${existingVehiclesTotal}`);
      DDBMuncher/* default.munchNote */.Z.munchNote(`Removing ${existingVehiclesTotal} from update...`);
      vehicleHandler.removeItems(existingVehicles);
    }
    if (!updateImages) {
      logger/* default.debug */.Z.debug("Copying vehicle images across...");
      DDBMuncher/* default.munchNote */.Z.munchNote(`Copying images for ${existingVehiclesTotal} vehicles...`);
      vehicles = (0,importMonster/* copyExistingMonsterImages */.ph)(vehicles, existingVehicles);
    }
  }
  DDBMuncher/* default.munchNote */.Z.munchNote("");
  DDBMuncher/* default.munchNote */.Z.munchNote(`Fiddling with the SRD data...`, true);
  await vehicleHandler.srdFiddling();
  await vehicleHandler.iconAdditions();

  DDBMuncher/* default.munchNote */.Z.munchNote(`Generating Icon Map..`, true);
  await (0,importMonster/* generateIconMap */.NM)(vehicleHandler.documents);

  // Compendium folders not yet in use for Vehicles
  const compendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z("vehicles");
  DDBMuncher/* default.munchNote */.Z.munchNote(`Checking compendium folders..`, true);
  await compendiumFolders.loadCompendium("vehicles");
  DDBMuncher/* default.munchNote */.Z.munchNote("", true);

  let vehiclesParsed = [];
  let currentVehicle = 1;
  const vehicleCount = vehicleHandler.documents.length;
  DDBMuncher/* default.munchNote */.Z.munchNote(`Preparing to wax ${vehicleCount} vehicles!`, true);
  for (const vehicle of vehicleHandler.documents) {
    DDBMuncher/* default.munchNote */.Z.munchNote(`[${currentVehicle}/${vehicleCount}] Importing ${vehicle.name}`, false, true);
    logger/* default.debug */.Z.debug(`Importing/second parse of ${vehicle.name} data`);
    const munched = await (0,importMonster/* addNPC */.Fx)(vehicle, "vehicle");
    vehiclesParsed.push(munched);
    currentVehicle += 1;
  }
  logger/* default.debug */.Z.debug("Vehicles Parsed", vehiclesParsed);
  DDBMuncher/* default.munchNote */.Z.munchNote("", false, true);
  foundry.utils.setProperty(CONFIG.DDBI, "MUNCHER.TEMPORARY", {});

  if (ids !== null) {
    return Promise.all(vehiclesParsed);
  }
  return vehicleCount;
}


/***/ }),

/***/ 3163:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ DDBCharacter)
});

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/parser/spells/metadata.js
var metadata = __webpack_require__(6721);
// EXTERNAL MODULE: ./src/parser/spells/parseSpell.js + 12 modules
var parseSpell = __webpack_require__(1702);
// EXTERNAL MODULE: ./src/parser/spells/ability.js
var ability = __webpack_require__(2352);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/parser/spells/special.js
var special = __webpack_require__(1838);
;// CONCATENATED MODULE: ./src/parser/spells/CharacterSpellFactory.js
/* eslint-disable no-continue */



// Import parsing functions






class CharacterSpellFactory {

  constructor(ddbCharacter) {
    this.ddbCharacter = ddbCharacter;
    this.ddb = ddbCharacter.source.ddb;
    this.character = ddbCharacter.raw.character;

    this.items = [];

    this.proficiencyModifier = this.character.system.attributes.prof;
    this.lookups = (0,metadata/* getLookups */.t)(this.ddb.character);

    logger/* default.debug */.Z.debug("Character spell lookups", this.lookups);
    this.characterAbilities = this.character.flags.ddbimporter.dndbeyond.effectAbilities;

    this.healingBoost = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.ddb, "bonus", { subType: "spell-group-healing" }).reduce((a, b) => a + b.value, 0);

    this.spellCounts = {

    };
  }

  _getSpellCount(name) {
    if (!this.spellCounts[name]) {
      this.spellCounts[name] = 0;
    }
    return ++this.spellCounts[name];
  }

  async getClassSpells() {
    for (const playerClass of this.ddb.character.classSpells) {
      const classInfo = this.ddb.character.classes.find((cls) => cls.id === playerClass.characterClassId);
      const spellCastingAbility = (0,ability/* getSpellCastingAbility */.sX)(classInfo);
      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      logger/* default.debug */.Z.debug("Spell parsing, class info", classInfo);

      const cantripBoost
        = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddb).filter(
          (mod) =>
            mod.type === "bonus"
            && mod.subType === `${classInfo.definition.name.toLowerCase()}-cantrip-damage`
            && (mod.restriction === null || mod.restriction === "")
        ).length > 0;

      // parse spells chosen as spellcasting (playerClass.spells)
      for (const spell of playerClass.spells) {
        if (!spell.definition) continue;
        // add some data for the parsing of the spells into the data structure
        spell.flags = {
          ddbimporter: {
            dndbeyond: {
              lookup: "classSpell",
              class: classInfo.definition.name,
              level: classInfo.level,
              characterClassId: playerClass.characterClassId,
              spellLevel: spell.definition.level,
              // spellSlots: character.system.spells,
              ability: spellCastingAbility,
              mod: abilityModifier,
              dc: 8 + this.proficiencyModifier + abilityModifier,
              cantripBoost: cantripBoost,
              overrideDC: false,
              id: spell.id,
              entityTypeId: spell.entityTypeId,
              healingBoost: this.healingBoost,
              usesSpellSlot: spell.usesSpellSlot,
              forceMaterial: classInfo.definition.name === "Artificer",
            },
          },
          "spell-class-filter-for-5e": {
            parentClass: classInfo.definition.name.toLowerCase(),
          },
          "tidy5e-sheet-kgar": {
            parentClass: classInfo.definition.name.toLowerCase(),
          },
          // "spellbook-assistant-manager": {
          //   class: classInfo.definition.name.toLowerCase(),
          // }
        };

        // Check for duplicate spells, normally domain ones
        // We will import spells from a different class that are the same though
        // as they may come from with different spell casting mods
        const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character, { namePostfix: `${this._getSpellCount(spell.definition.name)}` });
        foundry.utils.setProperty(parsedSpell, "system.sourceClass", classInfo.definition.name.toLowerCase());
        const duplicateSpell = this.items.findIndex(
          (existingSpell) => {
            const existingName = (existingSpell.flags.ddbimporter.originalName ? existingSpell.flags.ddbimporter.originalName : existingSpell.name);
            const parsedName = (parsedSpell.flags.ddbimporter.originalName ? parsedSpell.flags.ddbimporter.originalName : parsedSpell.name);
            // some spells come from different classes but end up having the same ddb id
            const classIdMatch = (classInfo.definition.name === existingSpell.flags.ddbimporter.dndbeyond.class || spell.id === existingSpell.flags.ddbimporter.dndbeyond.id);
            return existingName === parsedName && classIdMatch;
          });
        const duplicateItem = this.items[duplicateSpell];
        if (!duplicateItem) {
          this.items.push(parsedSpell);
        } else if (spell.alwaysPrepared || parsedSpell.system.preparation.mode === "always"
          || (spell.alwaysPrepared === duplicateItem.alwaysPrepared && parsedSpell.system.preparation.mode === duplicateItem.system.preparation.mode && parsedSpell.prepared && !duplicateItem.prepared)) {
          // if our new spell is always known we overwrite!
          // it's probably domain
          this.items[duplicateSpell] = parsedSpell;
        } else {
          // we'll emit a console message if it doesn't match this case for future debugging
          logger/* default.info */.Z.info(`Duplicate Spell ${spell.definition.name} detected in class ${classInfo.definition.name}.`);
        }
      }
    }

  }

  async getSpecialClassSpells() {
    for (const spell of this.ddb.character.spells.class) {
      if (!spell.definition) continue;
      // If the spell has an ability attached, use that
      let spellCastingAbility = undefined;
      const featureId = DDBHelper/* default.determineActualFeatureId */.Z.determineActualFeatureId(this.ddb, spell.componentId);
      const classInfo = this.lookups.classFeature.find((clsFeature) => clsFeature.id == featureId);

      logger/* default.debug */.Z.debug("Class spell parsing, class info", classInfo);
      // Sometimes there are spells here which don't have an class Info
      // this seems to be part of the optional tasha's rules, lets not parse for now
      // as ddb implementation is not yet finished
      // / options.class.[].definition.id
      if (!classInfo) {
        logger/* default.warn */.Z.warn(`Unable to add ${spell.definition.name}`);
      }
      if (!classInfo) continue;
      let klass = DDBHelper/* default.getClassFromOptionID */.Z.getClassFromOptionID(this.ddb, spell.componentId);

      if (!klass) klass = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.ddb, spell.componentId);

      logger/* default.debug */.Z.debug("Class spell, class found?", klass);

      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      } else if (klass) {
        spellCastingAbility = (0,ability/* getSpellCastingAbility */.sX)(klass);
        // force these spells to always be prepared
        spell.alwaysPrepared = true;
      } else {
        // if there is no ability on spell, we default to wis
        spellCastingAbility = "wis";
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            class: (klass) ? klass.definition.name : undefined,
            lookup: "classFeature",
            lookupName: classInfo.name,
            lookupId: classInfo.id,
            level: this.character.flags.ddbimporter.dndbeyond.totalLevels,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + this.proficiencyModifier + abilityModifier,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: this.healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
            forceMaterial: klass?.definition?.name === "Artificer",
          },
        },
        "tidy5e-sheet-kgar": {
          parentClass: (klass) ? klass.definition.name : undefined,
        },
      };

      // Check for duplicate spells, normally domain ones
      // We will import spells from a different class that are the same though
      // as they may come from with different spell casting mods
      const duplicateSpell = this.items.findIndex(
        (existingSpell) =>
          (existingSpell.flags.ddbimporter.originalName ? existingSpell.flags.ddbimporter.originalName : existingSpell.name) === spell.definition.name
          && klass
          && klass.definition.name === existingSpell.flags.ddbimporter.dndbeyond.class
          && spell.usesSpellSlot && existingSpell.flags.ddbimporter.dndbeyond.usesSpellSlot
      );
      if (!this.items[duplicateSpell]) {
        const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character, { namePostfix: `${this._getSpellCount(spell.definition.name)}` });
        if (spell.flags.ddbimporter.dndbeyond.class) foundry.utils.setProperty(parsedSpell, "system.sourceClass", spell.flags.ddbimporter.dndbeyond.class.toLowerCase());
        this.items.push(parsedSpell);
      } else if (spell.alwaysPrepared) {
        // if our new spell is always known we overwrite!
        // it's probably domain
        const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character, { namePostfix: `${this._getSpellCount(spell.definition.name)}` });
        if (spell.flags.ddbimporter.dndbeyond.class) foundry.utils.setProperty(parsedSpell, "system.sourceClass", spell.flags.ddbimporter.dndbeyond.class.toLowerCase());
        this.items[duplicateSpell] = parsedSpell;
      } else {
        // we'll emit a console message if it doesn't match this case for future debugging
        logger/* default.info */.Z.info(`Duplicate Spell ${spell.definition.name} detected in class ${classInfo.name}.`);
      }
    }
  }

  async handleGrantedSpells(spell, type) {
    if (spell.limitedUse && spell.definition.level !== 0) {
      const dups = this.ddb.character.spells[type].filter((otherSpell) => otherSpell.definition.name === spell.definition.name).length > 1;
      const duplicateSpell = this.items.findIndex(
        (existingSpell) =>
          (existingSpell.flags.ddbimporter.originalName ? existingSpell.flags.ddbimporter.originalName : existingSpell.name) === spell.definition.name
          && existingSpell.flags.ddbimporter.dndbeyond.usesSpellSlot
      );
      if (!dups && !this.items[duplicateSpell]) {
        // also parse spell as non-limited use
        let unlimitedSpell = foundry.utils.duplicate(spell);
        unlimitedSpell.limitedUse = null;
        unlimitedSpell.usesSpellSlot = true;
        unlimitedSpell.alwaysPrepared = true;
        unlimitedSpell.flags.ddbimporter.dndbeyond.usesSpellSlot = true;
        unlimitedSpell.flags.ddbimporter.dndbeyond.granted = true;
        unlimitedSpell.flags.ddbimporter.dndbeyond.lookup = type;
        delete unlimitedSpell.id;
        delete unlimitedSpell.flags.ddbimporter.dndbeyond.id;
        const parsedSpell = await (0,parseSpell/* parseSpell */.T)(unlimitedSpell, this.character, { namePostfix: `${this._getSpellCount(unlimitedSpell.definition.name)}` });
        this.items.push(parsedSpell);
      }
    }
  }

  async getRaceSpells() {
    for (const spell of this.ddb.character.spells.race) {
      if (!spell.definition)
        continue;
      // for race spells the spell spellCastingAbilityId is on the spell
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      let raceInfo = this.lookups.race.find((rc) => rc.id === spell.componentId);

      if (!raceInfo) {
        // for some reason we haven't matched the race option id with the spell
        // this happens with at least the SCAG optional spells casting half elf
        raceInfo = {
          name: "Racial spell",
          id: spell.componentId,
        };
      }

      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            lookup: "race",
            lookupName: raceInfo.name,
            lookupId: raceInfo.id,
            race: this.ddb.character.race.fullName,
            level: spell.castAtLevel,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + this.proficiencyModifier + abilityModifier,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: this.healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
          },
        },
      };

      this.handleGrantedSpells(spell, "race");
      const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character, { namePostfix: `${this._getSpellCount(spell.definition.name)}` });
      this.items.push(parsedSpell);
    }
  }

  async getFeatSpells() {
    for (const spell of this.ddb.character.spells.feat) {
      if (!spell.definition)
        continue;
      // If the spell has an ability attached, use that
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      let featInfo = this.lookups.feat.find((ft) => ft.id === spell.componentId);

      if (!featInfo) {
        // for some reason we haven't matched the feat option id with the spell
        // we fiddle the result
        featInfo = {
          name: "Feat option spell",
          id: spell.componentId,
        };
      }

      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            lookup: "feat",
            lookupName: featInfo.name,
            lookupId: featInfo.id,
            level: spell.castAtLevel,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + this.proficiencyModifier + abilityModifier,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: this.healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
          },
        },
      };

      this.handleGrantedSpells(spell, "feat");
      const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character, { namePostfix: `${this._getSpellCount(spell.definition.name)}` });
      this.items.push(parsedSpell);
    }
  }

  async getBackgroundSpells() {
    if (!this.ddb.character.spells.background) this.ddb.character.spells.background = [];
    for (const spell of this.ddb.character.spells.background) {
      if (!spell.definition)
        continue;
      // If the spell has an ability attached, use that
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(this.characterAbilities[spellCastingAbility].value);

      // add some data for the parsing of the spells into the data structure
      spell.flags = {
        ddbimporter: {
          dndbeyond: {
            lookup: "background",
            lookupName: "Background",
            level: spell.castAtLevel,
            ability: spellCastingAbility,
            mod: abilityModifier,
            dc: 8 + this.proficiencyModifier + abilityModifier,
            overrideDC: false,
            id: spell.id,
            entityTypeId: spell.entityTypeId,
            healingBoost: this.healingBoost,
            usesSpellSlot: spell.usesSpellSlot,
          },
        },
      };

      this.handleGrantedSpells(spell, "background");
      const parsedSpell = await (0,parseSpell/* parseSpell */.T)(spell, this.character, { namePostfix: `${this._getSpellCount(spell.definition.name)}` });
      this.items.push(parsedSpell);
    }
  }

  async getCharacterSpells() {
    // each class has an entry here, each entry has spells
    // we loop through each class and process
    await this.getClassSpells();

    // Parse any spells granted by class features, such as Barbarian Totem
    await this.getSpecialClassSpells();

    // Race spells are handled slightly differently
    await this.getRaceSpells();

    // feat spells are handled slightly differently
    await this.getFeatSpells();

    // background spells are handled slightly differently
    await this.getBackgroundSpells();

    await (0,special/* fixSpells */.F)(this.ddb, this.items);

    return this.items.sort((a, b) => a.name.localeCompare(b.name));
  }
}

// EXTERNAL MODULE: ./src/effects/DDBMacros.js
var DDBMacros = __webpack_require__(6516);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/DDBCampaigns.js
var DDBCampaigns = __webpack_require__(9771);
// EXTERNAL MODULE: ./src/lib/DDBReferenceLinker.js
var DDBReferenceLinker = __webpack_require__(7162);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/effects/vision5e.js
var vision5e = __webpack_require__(5042);
// EXTERNAL MODULE: ./src/parser/character/filterModifiers.js
var filterModifiers = __webpack_require__(2187);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
// EXTERNAL MODULE: ./src/lib/DDBTemplateStrings.js
var DDBTemplateStrings = __webpack_require__(258);
// EXTERNAL MODULE: ./src/parser/advancements/AdvancementHelper.js
var AdvancementHelper = __webpack_require__(333);
;// CONCATENATED MODULE: ./src/parser/classes/DDBClass.js











class DDBClass {

  static SPECIAL_ADVANCEMENTS = {};

  static PROFICIENCY_FEATURES = [
    "Proficiencies",
    "Primal Knowledge",
    "Master of Intrigue",
    "Implements of Mercy",
    "Bonus Proficiencies",
    "Otherworldly Glamour",
    "Survivalist",
    "Training in War and Song",
    "Blessings of Knowledge",
    "Elegant Courtier", // this is a you get a thing or otherwise choose from two others
  ];

  static EXPERTISE_FEATURES = [
    "Expertise",
    "Canny",
    "Deft Explorer",
    "Survivalist",
    "Blessings of Knowledge",
    // "Tool Expertise", // revisit,this doesn't work the same way
  ];

  static PROFICIENCY_OR_EXPERTISE_FEATURES = [
    "Mystical Erudition",
    "Mystical Erudition (Additional)",
  ];

  static LANGUAGE_FEATURES = [
    "Proficiencies",
    "Primal Knowledge",
    "Master of Intrigue",
    "Thieves' Cant",
    "Druidic",
    "Giant's Power",
    "Blessings of Knowledge",
    "Mystical Erudition",
    "Draconic Disciple",
    "Tongue of Dragons",
    "Wind Speaker",
    "Master of Intrigue",
    "Favored Enemy",
    "Deft Explorer",
    "Canny",
    "Draconic Gift",
    "Speech of the Woods",
  ];

  // you gain proficiency in one of the following skills of your choice: Animal Handling, History, Insight, Performance, or Persuasion. Alternatively, you learn one language of your choice.
  static LANGUAGE_OR_SKILL_FEATURE = [
    "Bonus Proficiency",
  ];

  static TOOL_FEATURES = [
    "Proficiencies",
    "Tool Proficiency",
    "Tools of the Trade",
    "Student of War",
    "Gunsmith",
    "Implements of Mercy",
    "Master of Intrigue",
  ];

  static ARMOR_FEATURES = [
    "Proficiencies",
    "Tools of the Trade",
    "Training in War and Song",
  ];

  static WEAPON_FEATURES = [
    "Proficiencies",
    "Firearm Proficiency",
    "Training in War and Song",
  ];

  static CONDITION_FEATURES = [
    "Inured to Undeath",
    "Elemental Gift",
    "Thought Shield",
    "Necrotic Husk",
    "Radiant Soul",
    "Oceanic Soul",
    "Fathomless Soul",
    "Psychic Defenses",
    "Heart of the Storm",
    "Wind Soul",
    "Beguiling Defenses",
    "Emissary of Redemption",
    "Aura of Warding",
    "Supernatural Resistance",
    "Guarded Mind",
    "Soul of the Forge",
    "Avatar of Battle",
    "Saint of Forge and Fire",
    "Divine Health",
    "Purity of Body",
    "Storm Soul",
    // "Desert",
    // "Sea",
    // "Tundra"
    "Chemical Mastery",
    "Poison Resilience",
    "Poison Immunity",
    "Constructed Resilience",
    "Natural Resilience",
    "Mechanical Nature",
    "Acid Resistance",
    "Necrotic Resistance",
    "Mountain Born",
    "Fire Resistance",
    "Psychic Resilience",
    "Gnomish Magic Resistance",
    "Dwarven Resilience",
    "Lightning Resistance",
    "Celestial Resistance",
    "Draconic Resistance",
    "Hellish Resistance",
    "Magic Resistance",
  ];

  _generateSource() {
    const classSource = DDBHelper/* default.parseSource */.Z.parseSource(this.ddbClassDefinition);
    this.data.system.source = classSource;
  }

  _fleshOutCommonDataStub() {
    this.data.system.identifier = utils/* default.referenceNameString */.Z.referenceNameString(this.ddbClassDefinition.name.toLowerCase());
    this._determineClassFeatures();

    this._proficiencyFeatureIds = this.classFeatures
      .filter((feature) => DDBClass.PROFICIENCY_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)))
      .map((feature) => feature.id);
    this._proficiencyFeatures = this.classFeatures
      .filter((feature) => this._proficiencyFeatureIds.includes(feature.id));

    this._expertiseFeatureIds = this.classFeatures
      .filter((feature) => DDBClass.EXPERTISE_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)))
      .map((feature) => feature.id);
    this._expertiseFeatures = this.classFeatures
      .filter((feature) => this._expertiseFeatureIds.includes(feature.id));

    this._languageFeatureIds = this.classFeatures
      .filter((feature) => DDBClass.LANGUAGE_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)))
      .map((feature) => feature.id);
    this._languageFeatures = this.classFeatures
      .filter((feature) => this._languageFeatureIds.includes(feature.id));

    this._toolFeatureIds = this.classFeatures
      .filter((feature) => DDBClass.TOOL_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)))
      .map((feature) => feature.id);
    this._toolFeatures = this.classFeatures
      .filter((feature) => this._toolFeatureIds.includes(feature.id));

    this._armorFeatureIds = this.classFeatures
      .filter((feature) => DDBClass.ARMOR_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)))
      .map((feature) => feature.id);
    this._armorFeatures = this.classFeatures
      .filter((feature) => DDBClass.ARMOR_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)));

    this._weaponFeatureIds = this.classFeatures
      .filter((feature) => DDBClass.WEAPON_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)))
      .map((feature) => feature.id);
    this._weaponFeatures = this.classFeatures
      .filter((feature) => DDBClass.WEAPON_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)));

    this._languageOrSkillFeatureIds = this.classFeatures.concat(this._languageFeatures)
      .filter((feature) => DDBClass.LANGUAGE_OR_SKILL_FEATURE.includes(utils/* default.nameString */.Z.nameString(feature.name)))
      .map((feature) => feature.id);
    this._languageOrSkillFeatures = this.classFeatures
      .filter((feature) => DDBClass.LANGUAGE_OR_SKILL_FEATURE.includes(utils/* default.nameString */.Z.nameString(feature.name)));

    this._conditionFeatureIds = this.classFeatures
      .filter((feature) => DDBClass.CONDITION_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)))
      .map((feature) => feature.id);
    this._conditionFeatures = this.classFeatures
      .filter((feature) => DDBClass.CONDITION_FEATURES.includes(utils/* default.nameString */.Z.nameString(feature.name)));

    this._generateSource();
  }

  _generateDataStub() {
    this.data = {
      _id: foundry.utils.randomID(),
      name: this.ddbClass.definition.name,
      type: "class",
      system: utils/* default.getTemplate */.Z.getTemplate("class"),
      flags: {
        ddbimporter: {
          id: this.ddbClass.id,
          definitionId: this.ddbClass.definition.id,
          entityTypeId: this.ddbClass.entityTypeId,
          type: "class",
          isStartingClass: this.ddbClass.isStartingClass,
          ddbImg: this.ddbClass.definition.portraitAvatarUrl,
        },
        obsidian: {
          source: {
            type: "class",
            text: this.ddbClass.definition.name,
          }
        },
      },
      img: null,
    };
  }

  _generateSpellCastingProgression() {
    if (this.ddbClassDefinition.canCastSpells) {
      const spellProgression = dictionary/* default.spell.progression.find */.Z.spell.progression.find((cls) => cls.name === this.ddbClass.definition.name);
      const spellCastingAbility = (0,ability/* getSpellCastingAbility */.sX)(this.ddbClass, this._isSubClass, this._isSubClass);
      if (spellProgression) {
        this.data.system.spellcasting = {
          progression: spellProgression.value,
          ability: spellCastingAbility,
        };
      }
      const spellSlotDivisor = this.ddbClassDefinition.spellRules?.multiClassSpellSlotDivisor
        ? this.ddbClassDefinition.spellRules.multiClassSpellSlotDivisor
        : undefined;
      this.data.flags.ddbimporter.spellSlotDivisor = spellSlotDivisor;
      this.data.flags.ddbimporter.spellCastingAbility = spellCastingAbility;
    }
  }

  async _buildCompendiumIndex(type, indexFilter = {}) {
    if (Object.keys(indexFilter).length > 0) this._indexFilter[type] = indexFilter;
    await this._compendiums[type].getIndex(this._indexFilter[type]);
  }

  // async init() {
  //   await this._buildCompendiumIndex("features");
  //   // await this._buildCompendiumIndex("class");
  //   // await this._buildCompendiumIndex("subclasses");
  // }

  async _generateDescriptionStub(character) {
    this.data.system.description.value = "<h1>Description</h1>";
    this.data.system.description.value += this.ddbClass.definition.description;
    // this excludes the subclass features
    this.data.system.description.value += await this._buildClassFeaturesDescription();
    // not all classes have equipment descriptions
    if (this.ddbClass.definition.equipmentDescription && !this._isSubClass) {
      // eslint-disable-next-line require-atomic-updates
      this.data.system.description.value += `<h1>Starting Equipment</h1>\n${this.ddbClass.definition.equipmentDescription}\n\n`;
    }

    if (character) {
      this.data.system.description.value = (0,DDBTemplateStrings/* default */.Z)(
        this.ddbData,
        character,
        this.data.system.description.value,
        this.data
      ).text;
    }
  }

  constructor(ddbData, classId, { noMods = false } = {}) {
    this._indexFilter = {
      features: {
        fields: [
          "name",
          "flags.ddbimporter.classId",
          "flags.ddbimporter.class",
          "flags.ddbimporter.subClass",
          "flags.ddbimporter.parentClassId",
          "flags.ddbimporter.featureName",
        ]
      },
      feats: {
        fields: [
          "name",
          "flags.ddbimporter",
        ]
      },
      class: {},
      subclasses: {},
    };

    // setup ddb source
    this.ddbData = ddbData;
    this.ddbClass = ddbData.character.classes.find((c) => c.definition.id === classId);
    this.ddbClassDefinition = this.ddbClass.definition;

    // quick helpers
    this.classFeatureIds = this.ddbClass.definition.classFeatures.map((f) => f.id);
    this.subClassFeatureIds = this.ddbClass.subclassDefinition && this.ddbClass.subclassDefinition.name
      ? this.ddbClass.classFeatures
        .filter((f) => f.definition.classId === this.ddbClass.subclassDefinition.id)
        .map((f) => f.definition.id)
      : [];

    // compendium
    this._compendiums = {
      features: CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("classfeatures"),
      feats: CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("feats"),
      // class: CompendiumHelper.getCompendiumType("class"),
      // subclasses: CompendiumHelper.getCompendiumType("subclasses"),
    };
    // this._compendiumFeaturesLabel = CompendiumHelper.getCompendiumLabel("features");

    this._advancementMatches = {
      features: {},
    };

    this._isSubClass = false;
    this._generateDataStub();

    this.options = {
      noMods,
    };

    this.dictionary = dictionary/* default.character.class.find */.Z.character["class"].find((c) => c.name === this.ddbClassDefinition.name);

    this.advancementHelper = new AdvancementHelper/* default */.Z({
      ddbData,
      type: "class",
      noMods: this.options.noMods,
    });

    this.SPECIAL_ADVANCEMENTS = DDBClass.SPECIAL_ADVANCEMENTS;

  }

  // this excludes any class/sub class features
  _determineClassFeatures() {
    this._excludedFeatureIds = this._isSubClass
      ? this.classFeatureIds
      : this.subClassFeatureIds;

    this.classFeatures = this.getClassFeatures(this._excludedFeatureIds);
  }

  isMartialArtist() {
    return this.classFeatures.some((feature) => feature.name === "Martial Arts");
  }

  /**
   * Retrieves the class features, excluding the ones specified by their IDs.
   *
   * @param {Array} excludedIds - An array of IDs of class features to exclude (default: [])
   * @return {Array} An array of class features
   */
  getClassFeatures(excludedIds = []) {
    const excludedFeatures = this.ddbData.character.optionalClassFeatures
      .filter((f) => f.affectedClassFeatureId)
      .map((f) => f.affectedClassFeatureId);

    const optionFeatures = this.ddbData.classOptions
      ? this.ddbData.classOptions
        .filter((feature) => feature.classId === this.ddbClassDefinition.id && !excludedIds.includes(feature.id))
      : [];

    const classFeatures = this.ddbClass.classFeatures
      .filter((feature) =>
        !excludedFeatures.includes(feature.definition.id)
        && !excludedIds.includes(feature.definition.id)
        && feature.definition.classId === this.ddbClassDefinition.id
      )
      .map((feature) => feature.definition);

    return classFeatures.concat(optionFeatures)
      .sort((a, b) => a.displayOrder - b.displayOrder)
      .sort((a, b) => a.requiredLevel - b.requiredLevel);
  }

  /**
   * Finds a match in the compendium features for the given feature.
   *
   * @param {Object} feature - The feature to find a match for.
   * @return {Object|undefined} - The matched feature, or undefined if no match is found.
   */
  getFeatureCompendiumMatch(feature) {
    return this._compendiums.features.index.find((match) =>
      ((foundry.utils.hasProperty(match, "flags.ddbimporter.featureName") && feature.name.trim().toLowerCase() == match.flags.ddbimporter.featureName.trim().toLowerCase())
        || (!foundry.utils.hasProperty(match, "flags.ddbimporter.featureName")
          && (feature.name.trim().toLowerCase() == match.name.trim().toLowerCase()
          || `${feature.name} (${this.ddbClassDefinition.name})`.trim().toLowerCase() == match.name.trim().toLowerCase()))
      )
      && foundry.utils.hasProperty(match, "flags.ddbimporter")
      && (match.flags.ddbimporter.class == this.ddbClassDefinition.name
        || match.flags.ddbimporter.parentClassId == this.ddbClassDefinition.id
        || match.flags.ddbimporter.classId == this.ddbClassDefinition.id)
    );
  }

  getFeatCompendiumMatch(featName) {
    const smallName = featName.trim().toLowerCase();
    return this._compendiums.feats.index.find((match) =>
      ((foundry.utils.hasProperty(match, "flags.ddbimporter.featureName")
        && smallName == match.flags.ddbimporter.featureName.trim().toLowerCase())
        || (!foundry.utils.hasProperty(match, "flags.ddbimporter.featureName")
          && (smallName == match.name.trim().toLowerCase()
          || smallName.split(":")[0].trim() == match.name.trim().toLowerCase()))
      )
    );
  }

  async _buildClassFeaturesDescription() {
    logger/* default.debug */.Z.debug(`Parsing ${this.ddbClassDefinition.name} features`);
    let description = "<h1>Class Features</h1>\n\n";
    let classFeatures = [];

    this.classFeatures.forEach((feature) => {
      const classFeaturesAdded = classFeatures.some((f) => f === feature.name);

      if (!classFeaturesAdded && !this._excludedFeatureIds.includes(feature.id)) {
        const featureMatch = this.getFeatureCompendiumMatch(feature);
        if (featureMatch) {
          const title = (featureMatch)
            ? `<p><b>@UUID[${featureMatch.uuid}]{${feature.name}}</b></p>`
            : `<p><b>${feature.name}</b></p>`;
          description += `${title}\n${feature.description}\n\n`;
        }
        classFeatures.push(feature.name);
      }
    });

    return description;
  }

  _generateHitDice() {
    this.data.system.hitDice = `d${this.ddbClass.definition.hitDice}`;
    this.data.system.hitDiceUsed = this.ddbClass.hitDiceUsed;
  }

  _setClassLevel() {
    this.data.system.levels = this.ddbClass.level;
  }

  // ADVANCEMENT FUNCTIONS

  // don't generate feature advancements for these features
  static EXCLUDED_FEATURE_ADVANCEMENTS = [
    "Ability Score Improvement",
    "Expertise",
    "Bonus Proficiencies",
    "Bonus Proficiency",
    "Tool Proficiency",

    "Speed",
    "Size",
    "Feat",
    "Languages",
    "Hit Points",
    "Proficiencies",

    // tashas
    "Primal Knowledge",
    "Martial Versatility",
  ];

  async _generateFeatureAdvancements() {
    logger/* default.debug */.Z.debug(`Parsing ${this.ddbClass.definition.name} features for advancement`);

    const advancements = [];
    this.classFeatures
      .filter((feature) => !DDBClass.EXCLUDED_FEATURE_ADVANCEMENTS.includes(feature.name))
      .forEach((feature) => {
        const featureMatch = this.getFeatureCompendiumMatch(feature);

        if (featureMatch) {
          const levelAdvancement = advancements.findIndex((advancement) => advancement.level === feature.requiredLevel);

          if (levelAdvancement == -1) {
            const advancement = new game.dnd5e.documents.advancement.ItemGrantAdvancement();
            this._advancementMatches.features[advancement._id] = {};
            this._advancementMatches.features[advancement._id][featureMatch.name] = featureMatch.uuid;

            const update = {
              configuration: {
                items: [{ uuid: featureMatch.uuid }]
              },
              value: {},
              level: feature.requiredLevel,
              title: "Features",
              icon: "",
              classRestriction: ""
            };
            advancement.updateSource(update);
            advancements.push(advancement.toObject());
          } else {
            advancements[levelAdvancement].configuration.items.push({ uuid: featureMatch.uuid });
            this._advancementMatches.features[advancements[levelAdvancement]._id][featureMatch.name] = featureMatch.uuid;
          }
        }
      });

    // TO DO: for choice features such as fighting styles:

    // {
    //   "type": "ItemChoice",
    //   "configuration": {
    //     "hint": "Choose one of the following options. You cant take a Fighting Style option more than once, even if you later get to choose again.",
    //     "choices": {
    //       "2": 1
    //     },
    //     "allowDrops": true,
    //     "type": "feat",
    //     "pool": [
    //       "Compendium.dnd5e.classfeatures.8YwPFv3UAPjWVDNf",
    //       "Compendium.dnd5e.classfeatures.zSlV0O2rQMdoq6pB",
    //       "Compendium.dnd5e.classfeatures.hCop9uJrWhF1QPb4",
    //       "Compendium.dnd5e.classfeatures.mHcSjcHJ8oZu3hkb"
    //     ],
    //     "spell": {
    //       "ability": "",
    //       "preparation": "",
    //       "uses": {
    //         "max": "",
    //         "per": ""
    //       }
    //     },
    //     "restriction": {
    //       "type": "class",
    //       "subtype": "fightingStyle",
    //       "level": ""
    //     }
    //   },
    //   "value": {},
    //   "title": "Fighting Style",
    //   "icon": "systems/dnd5e/icons/svg/item-choice.svg",
    //   "_id": "ih8WlydEZdg3rCPh"
    // },

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateScaleValueAdvancementsFromFeatures() {
    let specialFeatures = [];
    const advancements = this.classFeatures
      .filter((feature) => feature.levelScales?.length > 0)
      .map((feature) => {
        let advancement = AdvancementHelper/* default.generateScaleValueAdvancement */.Z.generateScaleValueAdvancement(feature);
        const specialLookup = this.SPECIAL_ADVANCEMENTS[advancement.title];
        if (specialLookup) {
          if (specialLookup.additionalAdvancements) {
            specialLookup.additionalFunctions.forEach((fn) => {
              specialFeatures.push(fn(advancement));
            });
          }
          if (specialLookup.fixFunction) advancement = specialLookup.fixFunction(advancement);
        }
        return advancement;
      });

    this.data.system.advancement = this.data.system.advancement.concat(advancements, specialFeatures);
  }

  _generateHTMLSaveAdvancement() {
    const advancements = [];
    // FUTURE ENHANCEMENT FOR BULK: Add what to do if no mods supplied
    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateSaveAdvancement(feature, availableToMulticlass, level) {
    const modFilters = {
      includeExcludedEffects: true,
      classId: this.ddbClassDefinition.id,
      exactLevel: level,
      availableToMulticlass,
      useUnfilteredModifiers: true,
      filterOnFeatureIds: [feature.id],
    };
    const mods = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddbData, modFilters);


    return AdvancementHelper/* default.getSaveAdvancement */.Z.getSaveAdvancement(mods, availableToMulticlass, level);

  }

  _generateSaveAdvancements() {
    if (this.options.noMods) {
      this._generateHTMLSaveAdvancement();
      return;
    }
    const advancements = [];
    for (let i = 0; i <= 20; i++) {
      [true, false].forEach((availableToMulticlass) => {
        if (!availableToMulticlass && i > 1) return;
        const proficiencyFeatures = this._proficiencyFeatures.filter((f) => f.requiredLevel === i);

        for (const proficiencyFeature of proficiencyFeatures) {
          const advancement = this._generateSaveAdvancement(proficiencyFeature, availableToMulticlass, i);
          if (advancement) advancements.push(advancement.toObject());
        }
      });
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateSkillAdvancement(feature, availableToMulticlass, i) {
    const modFilters = {
      includeExcludedEffects: true,
      classId: this.ddbClassDefinition.id,
      exactLevel: i,
      availableToMulticlass: availableToMulticlass === false ? null : true,
      useUnfilteredModifiers: true,
      filterOnFeatureIds: [feature.id],
    };
    const mods = this.options.noMods ? [] : DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddbData, modFilters);
    const skillExplicitMods = mods.filter((mod) =>
      mod.type === "proficiency"
      && dictionary/* default.character.skills.map */.Z.character.skills.map((s) => s.subType).includes(mod.subType)
    );
    const filterModOptions = { subType: `choose-a-${this.ddbClassDefinition.name.toLowerCase()}-skill` };
    const skillChooseMods = DDBHelper/* default.filterModifiers */.Z.filterModifiers(mods, "proficiency", filterModOptions);
    const skillMods = skillChooseMods.concat(skillExplicitMods);

    return this.advancementHelper.getSkillAdvancement(skillMods, feature, availableToMulticlass, i);
  }

  _generateSkillAdvancements() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      [true, false].forEach((availableToMulticlass) => {
        if ((!availableToMulticlass && i > 1)) return;
        if (this._isSubClass && !availableToMulticlass) return;
        const skillFeatures = this._proficiencyFeatures.filter((f) => f.requiredLevel === i);

        for (const feature of skillFeatures) {
          const baseProficiency = feature.name === "Proficiencies";
          if (availableToMulticlass
            && baseProficiency
            && this.dictionary.multiclassSkill === 0
          // eslint-disable-next-line no-continue
          ) continue;
          const advancement = this._generateSkillAdvancement(feature, availableToMulticlass, i);
          if (advancement) advancements.push(advancement.toObject());
        }
      });
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateLanguageAdvancement(feature, level) {
    const modFilters = {
      includeExcludedEffects: true,
      classId: this.ddbClassDefinition.id,
      exactLevel: level,
      useUnfilteredModifiers: true,
      filterOnFeatureIds: [feature.id],
    };
    const mods = this.options.noMods ? [] : DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddbData, modFilters);

    return this.advancementHelper.getLanguageAdvancement(mods, feature, level);
  }

  _generateLanguageAdvancements() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      const languageFeatures = this._languageFeatures.filter((f) => f.requiredLevel === i);

      for (const feature of languageFeatures) {
        const advancement = this._generateLanguageAdvancement(feature, i);
        if (advancement) advancements.push(advancement.toObject());
      }
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateSkillOrLanguageAdvancements() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      const skillFeatures = this._languageOrSkillFeatures.filter((f) => f.requiredLevel === i);

      for (const feature of skillFeatures) {
        const skillAdvancement = this._generateSkillAdvancement(feature, true, i);
        const languageAdvancement = this._generateLanguageAdvancement(feature, i);
        // console.warn(`SkillOrLanguageAdvancements`, {
        //   i,
        //   feature,
        //   skillAdvancement,
        //   languageAdvancement,
        // });
        if (skillAdvancement && languageAdvancement && skillAdvancement.configuration.choices.length > 0) {
          const advancement = skillAdvancement.toObject();
          advancement.configuration.choices[0].pool.push(...languageAdvancement.toObject().configuration.choices[0].pool);
          advancements.push(advancement);
        } else {
          logger/* default.error */.Z.error(`Failed Skill or Lanugage Advancement Generation`, {
            i,
            feature,
            skillAdvancement,
            languageAdvancement,
          });
        }
      }
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateToolAdvancement(feature, level) {
    const modFilters = {
      includeExcludedEffects: true,
      classId: this.ddbClassDefinition.id,
      exactLevel: level,
      useUnfilteredModifiers: true,
      filterOnFeatureIds: [feature.id],
    };
    const mods = this.options.noMods ? [] : DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddbData, modFilters);
    return this.advancementHelper.getToolAdvancement(mods, feature, level);
  }

  _generateToolAdvancements() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      const toolFeatures = this._toolFeatures.filter((f) => f.requiredLevel === i);

      for (const feature of toolFeatures) {
        const advancement = this._generateToolAdvancement(feature, i);
        if (advancement) advancements.push(advancement.toObject());
      }
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateArmorAdvancement(feature, availableToMulticlass, level) {
    const modFilters = {
      includeExcludedEffects: true,
      classId: this.ddbClassDefinition.id,
      exactLevel: level,
      availableToMulticlass: availableToMulticlass === false ? null : true,
      useUnfilteredModifiers: true,
      filterOnFeatureIds: [feature.id],
    };
    const mods = this.options.noMods ? [] : DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddbData, modFilters);
    return this.advancementHelper.getArmorAdvancement(mods, feature, availableToMulticlass, level);
  }

  _generateArmorAdvancements() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      [true, false].forEach((availableToMulticlass) => {
        if ((!availableToMulticlass && i > 1)) return;
        if (this._isSubClass && !availableToMulticlass) return;
        const armorFeatures = this._armorFeatures.filter((f) => f.requiredLevel === i);

        for (const feature of armorFeatures) {
          const advancement = this._generateArmorAdvancement(feature, availableToMulticlass, i);
          if (advancement) advancements.push(advancement.toObject());
        }
      });
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateWeaponAdvancement(feature, level) {
    const modFilters = {
      includeExcludedEffects: true,
      classId: this.ddbClassDefinition.id,
      exactLevel: level,
      useUnfilteredModifiers: true,
      filterOnFeatureIds: [feature.id],
    };
    const mods = this.options.noMods ? [] : DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddbData, modFilters);
    return this.advancementHelper.getWeaponAdvancement(mods, feature, level);
  }

  _generateWeaponAdvancements() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      const weaponFeatures = this._weaponFeatures.filter((f) => f.requiredLevel === i);

      for (const feature of weaponFeatures) {
        const advancement = this._generateWeaponAdvancement(feature, i);
        if (advancement) advancements.push(advancement.toObject());
      }
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateExpertiseAdvancements() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      const expertiseFeature = this._expertiseFeatures.find((f) => f.requiredLevel === i);
      // eslint-disable-next-line no-continue
      if (!expertiseFeature) continue;

      const advancement = this.advancementHelper.getExpertiseAdvancement(expertiseFeature, i);
      if (advancement) advancements.push(advancement.toObject());
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateConditionAdvancement(feature, level) {
    const modFilters = {
      includeExcludedEffects: true,
      classId: this.ddbClassDefinition.id,
      exactLevel: level,
      useUnfilteredModifiers: true,
      filterOnFeatureIds: [feature.id],
    };
    const mods = this.options.noMods ? [] : DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddbData, modFilters);

    return this.advancementHelper.getConditionAdvancement(mods, feature, level);
  }

  _generateConditionAdvancements() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      const conditionAdvancements = this._conditionFeatures.filter((f) => f.requiredLevel === i);
      for (const feature of conditionAdvancements) {
        const advancement = this._generateConditionAdvancement(feature, i);
        if (advancement) advancements.push(advancement.toObject());
      }
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateHPAdvancement(character) {
    // const value = "value": {
    //   "1": "max",
    //   "2": "avg"
    // },
    const value = {};

    const rolledHP = foundry.utils.getProperty(character, "flags.ddbimporter.rolledHP") ?? false;
    const startingClass = foundry.utils.getProperty(this.data, "flags.ddbimporter.isStartingClass") === true;
    const useMaxHP = game.settings.get("ddb-importer", "character-update-policy-use-hp-max-for-rolled-hp");
    if (rolledHP && !useMaxHP) {
      const baseHP = foundry.utils.getProperty(character, "flags.ddbimporter.baseHitPoints");
      const totalLevels = foundry.utils.getProperty(character, "flags.ddbimporter.dndbeyond.totalLevels");
      const hpPerLevel = Math.floor(baseHP / totalLevels);
      const leftOvers = Math.floor(baseHP % totalLevels);

      for (let i = 1; i <= this.data.system.levels; i++) {
        value[`${i}`] = i === 1 && startingClass ? (hpPerLevel + leftOvers) : hpPerLevel;
      }
    } else {
      for (let i = 1; i <= this.data.system.levels; i++) {
        value[`${i}`] = i === 1 && startingClass ? "max" : "avg";
      }
    };

    const advancement = new game.dnd5e.documents.advancement.HitPointsAdvancement();
    advancement.updateSource({ value });
    this.data.system.advancement.push(advancement.toObject());
  }


  async _addFoundryAdvancements() {
    for (const packId of settings/* default.FOUNDRY_COMPENDIUM_MAP.classes */.Z.FOUNDRY_COMPENDIUM_MAP.classes) {
      const pack = CompendiumHelper/* default.getCompendium */.Z.getCompendium(packId, false);
      if (!pack) continue;
      await pack.getIndex();
      const klassMatch = pack.index.find((k) =>
        k.name === this.ddbClassDefinition.name
        && k.type === "class"
      );
      if (!klassMatch) continue;
      const foundryKlass = await pack.getDocument(klassMatch._id);
      const scaleAdvancements = foundryKlass.system.advancement.filter((foundryA) =>
        foundryA.type === "ScaleValue"
        && !this.data.system.advancement.some((ddbA) => ddbA.configuration.identifier === foundryA.configuration.identifier)
      ).map((advancement) => {
        return advancement.toObject();
      });
      this.data.system.advancement.push(...scaleAdvancements);
      return;
    }
  }

  _generateAbilityScoreAdvancement() {
    const advancements = [];

    for (let i = 0; i <= 20; i++) {
      const abilityAdvancementFeature = this.classFeatures.find((f) => f.name === "Ability Score Improvement" && f.requiredLevel === i);

      // eslint-disable-next-line no-continue
      if (!abilityAdvancementFeature) continue;
      const advancement = new game.dnd5e.documents.advancement.AbilityScoreImprovementAdvancement();
      advancement.updateSource({ configuration: { points: 2 }, level: i, value: { type: "asi" } });

      // if advancement has taken ability improvements
      const modFilters = {
        includeExcludedEffects: true,
        classId: this.ddbClassDefinition.id,
        exactLevel: i,
        useUnfilteredModifiers: true,
      };
      const mods = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.ddbData, modFilters);

      const assignments = {};
      dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
        const count = DDBHelper/* default.filterModifiers */.Z.filterModifiers(mods, "bonus", { subType: `${ability.long}-score` }).length;
        if (count > 0) assignments[ability.value] = count;
      });

      // create a leveled advancement
      if (Object.keys(assignments).length > 0) {
        advancement.updateSource({
          value: {
            assignments,
          },
        });
      } else if (abilityAdvancementFeature.requiredLevel <= this.ddbClass.level) {
        // feat id selection happens later once features have been generated
        // "type": "feat",
        // "feat": {
        //   "vu8kJ2iTCEiGQ1mv": "Compendium.world.ddb-test2-ddb-feats.Item.3mfeQMT6Fh1VRubU"
        // }
        advancement.updateSource({
          value: {
            type: "feat",
            feat: {
            },
          },
        });
        // abilityAdvancementFeature.id: 313
        // abilityAdvancementFeature.entityTypeId: 12168134
        const featChoice = this.ddbData.character.feats.find((f) =>
          f.componentId == abilityAdvancementFeature.id
          && f.componentTypeId == abilityAdvancementFeature.entityTypeId
        );
        const featureMatch = featChoice ? this.getFeatCompendiumMatch(featChoice.definition.name) : null;
        if (featureMatch) {
          this._advancementMatches.features[advancement._id] = {};
          this._advancementMatches.features[advancement._id][featureMatch.name] = featureMatch.uuid;
        } else {
          logger/* default.info */.Z.info("Missing asi feat linking match for", { abilityAdvancementFeature, featChoice, this: this });
        }

      }

      advancements.push(advancement.toObject());
    }

    this.data.system.advancement = this.data.system.advancement.concat(advancements);
  }

  _generateWealth() {
    const diceString = this.ddbClassDefinition.wealthDice.diceString;
    const diceMultiplier = this.ddbClassDefinition.wealthDice.diceMultiplier;
    this.data.system.wealth = diceMultiplier && diceString
      ? `${diceString}*${diceMultiplier}`
      : "";
  }

  async _copyFoundryEquipment() {
    for (const packId of settings/* default.FOUNDRY_COMPENDIUM_MAP.classes */.Z.FOUNDRY_COMPENDIUM_MAP.classes) {
      const pack = CompendiumHelper/* default.getCompendium */.Z.getCompendium(packId, false);
      if (!pack) continue;
      await pack.getIndex();
      const klassMatch = pack.index.find((k) =>
        k.name === this.ddbClassDefinition.name
        && k.type === "class"
      );
      if (!klassMatch) continue;
      const foundryKlass = await pack.getDocument(klassMatch._id);
      const startingEquipment = foundry.utils.duplicate(foundryKlass.system.startingEquipment);
      this.data.system.startingEquipment = startingEquipment;
      return;
    }
  }

  async _generateCommonAdvancements() {
    this._generateScaleValueAdvancementsFromFeatures();
    await this._generateFeatureAdvancements();
    this._generateSaveAdvancements();
    this._generateSkillAdvancements();
    this._generateExpertiseAdvancements();
    this._generateLanguageAdvancements();
    this._generateToolAdvancements();
    this._generateArmorAdvancements();
    this._generateWeaponAdvancements();
    // FUTURE: Equipment? (for backgrounds), needs better handling in Foundry
    this._generateSkillOrLanguageAdvancements();
    this._generateConditionAdvancements();
    this._generateSpellCastingProgression();
    // FUTURE: choice options such as fighting styles, this requires improved feature parsing
    await this._addFoundryAdvancements();
  }

  // fixes
  // eslint-disable-next-line class-methods-use-this, no-empty-function
  _fixes() {
    // Currently empty but stubbed for DDBSubClass
  }


  // GENERATE CLASS

  async generateFromCharacter(character) {
    await this._buildCompendiumIndex("features");
    this._setClassLevel();
    this._fleshOutCommonDataStub();

    // these are class specific
    this._generateHPAdvancement(character);
    await this._generateCommonAdvancements();
    this._generateHitDice();
    this._generateAbilityScoreAdvancement();
    this._generateWealth();
    this._copyFoundryEquipment();

    // finally a description
    await this._generateDescriptionStub(character);

    this._fixes();
  }

}

;// CONCATENATED MODULE: ./src/parser/classes/DDBSubClass.js




class DDBSubClass extends DDBClass {

  // these are advancement helpers
  static SPECIAL_ADVANCEMENTS = {
    "Combat Superiority": {
      fix: true,
      fixFunction: AdvancementHelper/* default.renameTotal */.Z.renameTotal,
      additionalAdvancements: true,
      additionalFunctions: [AdvancementHelper/* default.addAdditionalUses */.Z.addAdditionalUses, AdvancementHelper/* default.addSingularDie */.Z.addSingularDie],
    },
    "Rune Carver": {
      fix: true,
      fixFunction: AdvancementHelper/* default.renameTotal */.Z.renameTotal,
      additionalAdvancements: false,
      additionalFunctions: [],
    },
  };

  _fleshOutCommonDataStub() {
    super._fleshOutCommonDataStub();
    // add parent class identifier
    this.data.system.classIdentifier = utils/* default.referenceNameString */.Z.referenceNameString(this.ddbClass.definition.name.toLowerCase());

  }

  _generateDataStub() {
    this.data = {
      _id: foundry.utils.randomID(),
      name: this.ddbClass.subclassDefinition.name,
      type: "subclass",
      system: utils/* default.getTemplate */.Z.getTemplate("subclass"),
      flags: {
        ddbimporter: {
          subclassDefinitionId: this.ddbClass.id,
          id: this.ddbClass.subclassDefinition.id,
          type: "class",
          ddbImg: this.ddbClass.subclassDefinition.portraitAvatarUrl ?? this.ddbClass.definition.portraitAvatarUrl,
        },
        obsidian: {
          source: {
            type: "class",
            text: this.ddbClass.subclassDefinition.name,
          }
        },
      },
      img: null,
    };
  }

  constructor(ddb, classId) {
    super(ddb, classId);

    this.ddbClassDefinition = this.ddbClass.subclassDefinition;
    this._isSubClass = true;
    this.SPECIAL_ADVANCEMENTS = DDBSubClass.SPECIAL_ADVANCEMENTS;
  }


  _fixes() {
    if (this.data.name.startsWith("Order of the Profane Soul")) {
      this.data.name = "Order of the Profane Soul";
      const slotsScaleValue = {
        _id: foundry.utils.randomID(),
        type: "ScaleValue",
        configuration: {
          distance: { units: "" },
          identifier: `pact-slots`,
          type: "number",
          scale: {
            3: {
              value: 1,
            },
            6: {
              value: 2,
            },
          },
        },
        value: {},
        title: `Pact Slots`,
        icon: null,
      };

      const levelScaleValue = {
        _id: foundry.utils.randomID(),
        type: "ScaleValue",
        configuration: {
          distance: { units: "" },
          identifier: `pact-level`,
          type: "number",
          scale: {
            3: {
              value: 1,
            },
            7: {
              value: 2,
            },
            13: {
              value: 3,
            },
          },
        },
        value: {},
        title: `Pact Level`,
        icon: null,
      };

      this.data.system.advancement.push(slotsScaleValue, levelScaleValue);
    } else if (this.data.name.startsWith("Path of the Storm Herald")) {
      const desert = {
        _id: foundry.utils.randomID(),
        type: "ScaleValue",
        configuration: {
          distance: { units: "" },
          identifier: `storm-aura-desert`,
          type: "number",
          scale: {
            3: {
              value: 2,
            },
            5: {
              value: 3,
            },
            10: {
              value: 4,
            },
            15: {
              value: 5,
            },
            20: {
              value: 6,
            },
          },
        },
        value: {},
        title: `Storm Aura Desert`,
        icon: null,
      };

      const sea = {
        _id: foundry.utils.randomID(),
        type: "ScaleValue",
        configuration: {
          distance: { units: "" },
          identifier: `storm-aura-sea`,
          type: "dice",
          scale: {
            3: {
              number: 1,
              faces: 6,
            },
            10: {
              number: 2,
              faces: 6,
            },
            15: {
              number: 3,
              faces: 6,
            },
            20: {
              number: 4,
              faces: 6,
            },
          },
        },
        value: {},
        title: `Storm Aura Sea`,
        icon: null,
      };

      const tundra = {
        _id: foundry.utils.randomID(),
        type: "ScaleValue",
        configuration: {
          distance: { units: "" },
          identifier: `storm-aura-tundra`,
          type: "number",
          scale: {
            3: {
              value: 2,
            },
            5: {
              value: 3,
            },
            10: {
              value: 4,
            },
            15: {
              value: 5,
            },
            20: {
              value: 6,
            },
          },
        },
        value: {},
        title: `Storm Aura Tundra`,
        icon: null,
      };

      this.data.system.advancement.push(desert, sea, tundra);
    }
  }

  async generateFromCharacter(character) {
    await this._buildCompendiumIndex("features");
    this._fleshOutCommonDataStub();
    await this._generateCommonAdvancements();
    await this._generateDescriptionStub(character);
    this._fixes();
  }

}

;// CONCATENATED MODULE: ./src/parser/classes/CharacterClassFactory.js




class CharacterClassFactory {

  constructor(ddbCharacter) {
    this.ddbCharacter = ddbCharacter;
    this.character = this.ddbCharacter.raw.character;
    this.source = this.ddbCharacter.source.ddb;
    this.ddbClasses = {
    };
  }

  async processCharacter() {
    const documents = [];
    for (const characterClass of this.source.character.classes) {
      const ddbClass = new DDBClass(this.source, characterClass.definition.id);
      await ddbClass.generateFromCharacter(this.character);
      this.ddbClasses[ddbClass.data.name] = ddbClass;
      documents.push(foundry.utils.deepClone(ddbClass.data));

      if (characterClass.subclassDefinition && characterClass.subclassDefinition.name) {
        const ddbSubClass = new DDBSubClass(this.source, characterClass.definition.id);
        await ddbSubClass.generateFromCharacter(this.character);
        this.ddbClasses[ddbSubClass.data.name] = ddbSubClass;
        documents.push(foundry.utils.deepClone(ddbSubClass.data));
      }
    }

    logger/* default.debug */.Z.debug(`Processed ${documents.length} classes`, { documents });
    this.ddbCharacter.updateItemIds(documents);

    return documents;
  }

  #itemGrantLink(ddbClass, klass, advancementIndex) {
    // "added": {
    //   "TlT20Gh1RofymIDY": "Compendium.dnd5e.classfeatures.Item.u4NLajXETJhJU31v",
    //   "2PZlmOVkOn2TbR1O": "Compendium.dnd5e.classfeatures.Item.hpLNiGq7y67d2EHA"
    // }
    const advancement = klass.system.advancement[advancementIndex];
    const aData = ddbClass._advancementMatches.features[advancement._id];
    const added = {};

    if (!aData || !advancement) {
      logger/* default.warn */.Z.warn(`Advancement for ${klass.name} (idx ${advancementIndex}) missing required data for linking`, {
        advancement,
        aData,
        klass,
        ddbClass,
      });
      return;
    }
    for (const [advancementFeatureName, uuid] of Object.entries(aData)) {
      logger/* default.debug */.Z.debug(`Advancement ${advancement._id} searching for Feature ${advancementFeatureName} (${uuid})`, {
        a: advancement,
        ddbClass,
        advancementFeatureName,
        uuid,
      });

      const characterFeature = this.ddbCharacter.getDataFeature(advancementFeatureName, { hints: [klass.name] });
      if (characterFeature) {
        logger/* default.debug */.Z.debug(`Advancement ${advancement._id} found Feature ${advancementFeatureName} (${uuid})`);
        added[characterFeature._id] = uuid;
        foundry.utils.setProperty(characterFeature, "flags.dnd5e.sourceId", uuid);
        foundry.utils.setProperty(characterFeature, "flags.dnd5e.advancementOrigin", `${klass._id}.${advancement._id}`);
      }
    }

    if (Object.keys(added).length > 0) {
      advancement.value = {
        added,
      };
      klass.system.advancement[advancementIndex] = advancement;
    }
  }

  #abilityScoreFeatLink(ddbClass, klass, advancementIndex) {
    // "value": {
    //   "type": "feat",
    //   "feat": {
    //     "B09QLNujzaGh6zt7": "Compendium.world.ddb-test2-ddb-feats.Item.cHie2wNgxBG9m62F"
    //   }
    // }
    const advancement = klass.system.advancement[advancementIndex];
    const aData = ddbClass._advancementMatches.features[advancement._id];
    const feats = {};

    if (!aData || !advancement) {
      logger/* default.warn */.Z.warn(`Advancement for ${klass.name} (idx ${advancementIndex}) missing required data for linking`, {
        advancement,
        aData,
        klass,
        ddbClass,
      });
      return;
    }

    for (const [advancementFeatureName, uuid] of Object.entries(aData)) {
      logger/* default.debug */.Z.debug(`Ability Score Advancement ${advancement._id} searching for Feat ${advancementFeatureName} (${uuid})`, {
        a: advancement,
        ddbClass,
        advancementFeatureName,
        uuid,
      });

      const characterFeature = this.ddbCharacter.getDataFeature(advancementFeatureName, { hints: [klass.name] });
      if (characterFeature) {
        logger/* default.debug */.Z.debug(`Ability Score Advancement ${advancement._id} found Feat ${advancementFeatureName} (${uuid})`);
        feats[characterFeature._id] = uuid;
        foundry.utils.setProperty(characterFeature, "flags.dnd5e.sourceId", uuid);
        foundry.utils.setProperty(characterFeature, "flags.dnd5e.advancementOrigin", `${klass._id}.${advancement._id}`);
      }
    }

    if (Object.keys(feats).length > 0) {
      // eslint-disable-next-line require-atomic-updates
      klass.system.advancement[advancementIndex].value = {
        type: "feat",
        feat: feats,
      };
    }
  }

  linkFeatures() {
    logger/* default.debug */.Z.debug("Linking Advancements to Features", {
      CharacterClassFactory: this,
    });
    for (const klass of this.ddbCharacter.data.classes) {
      const ddbClass = this.ddbClasses[klass.name];
      logger/* default.debug */.Z.debug("Linking Advancements to Features for Class", {
        klass,
        ddbClass,
      });

      for (let idx = 0; idx < klass.system.advancement.length; idx++) {
        const a = klass.system.advancement[idx];
        if (a.type === "ItemGrant" && a.level <= ddbClass.ddbClass.level) {
          this.#itemGrantLink(ddbClass, klass, idx);
        } else if (a.type === "AbilityScoreImprovement" && a.value.type === "feat") {
          this.#abilityScoreFeatLink(ddbClass, klass, idx);
        }
      }
      logger/* default.debug */.Z.debug(`Processed ${klass.name} class advancements`, klass.system.advancement);
    };
  }
}

// EXTERNAL MODULE: ./src/parser/features/DDBAction.js
var DDBAction = __webpack_require__(3164);
// EXTERNAL MODULE: ./src/parser/features/DDBAttackAction.js
var DDBAttackAction = __webpack_require__(5345);
// EXTERNAL MODULE: ./src/parser/features/DDBFeature.js
var DDBFeature = __webpack_require__(4074);
;// CONCATENATED MODULE: ./src/parser/features/DDBChoiceFeature.js






class DDBChoiceFeature extends DDBFeature/* default */.Z {

  _prepare() {
    this._levelScale = null;
    this._levelScales = null;
    this._limitedUse = null;
    this._classOption = null;

    this._classFeatureComponent = DDBHelper/* default.findComponentByComponentId */.Z.findComponentByComponentId(this.ddbData, this.ddbDefinition.id);

    if (!this._classFeatureComponent) {
      this._classOption = [
        this.ddbData.character.options.race,
        this.ddbData.character.options.class,
        this.ddbData.character.options.feat,
      ]
        .flat()
        .find((option) => option.definition.id === this.ddbDefinition.componentId);
      if (this._classOption) {
        this._classFeatureComponent = DDBHelper/* default.findComponentByComponentId */.Z.findComponentByComponentId(this.ddbData, this._classOption.componentId);
      }
    }

    if (this._classFeatureComponent) {
      this._levelScale = this._classFeatureComponent.levelScale;
      this._levelScales = this._classFeatureComponent.definition?.levelScales;
      this._limitedUse = this._classFeatureComponent.definition?.limitedUse;
      // I don't think I actually use these
      // foundry.utils.setProperty(this.data.flags, "ddbimporter.dndbeyond.levelScale", this._levelScale);
      // foundry.utils.setProperty(this.data.flags, "ddbimporter.dndbeyond.levelScales", this._levelScales);
      // foundry.utils.setProperty(this.data.flags, "ddbimporter.dndbeyond.limitedUse", this._limitedUse);
    }

  }


  build(choice) {
    try {
      this._generateSystemType();

      logger/* default.debug */.Z.debug(`Adding choice ${choice.label}`);

      if (this.data.name === choice.label) {
        this._generateSystemSubType();
        return;
      }

      this.data.name = choice.label
        ? choice.label.startsWith(this.data.name.trim())
          ? choice.label
          : `${this.data.name}: ${choice.label}`
        : this.data.name;
      this.data.name = utils/* default.nameString */.Z.nameString(this.data.name);
      const namePointRegex = /(.*) \((\d) points?\)/i;
      const nameMatch = this.data.name.match(namePointRegex);
      if (nameMatch) {
        this.data.name = nameMatch[1];
        this._resourceCharges = Number.parseInt(nameMatch[2]);
      }
      this._generateSystemSubType();

      // get description for chris premades
      this._generateDescription(true);
      foundry.utils.setProperty(this.data, "flags.ddbimporter.initialFeature", foundry.utils.deepClone(this.data.system.description));

      if (choice.wasOption && choice.description) {
        this.ddbDefinition.description = choice.description;
        this.ddbDefinition.snippet = choice.snippet ? choice.snippet : "";
      } else {
        if (this.ddbDefinition.description) {
          this.ddbDefinition.description = choice.description
            ? this.ddbDefinition.description + "<h3>" + choice.label + "</h3>" + choice.description
            : this.ddbDefinition.description;
        }
        if (this.ddbDefinition.snippet) {
          this.ddbDefinition.snippet = choice.description
            ? this.ddbDefinition.snippet + "<h3>" + choice.label + "</h3>" + choice.description
            : this.ddbDefinition.snippet;
        }
      }
      // add these flags in so they can be used by the description parser
      foundry.utils.setProperty(this.ddbDefinition, "flags.ddbimporter.dndbeyond.choice", choice);

      this._generateActivation();
      this._generateResourceConsumption();
      this._generateDescription(false);
      this.data.flags.ddbimporter.dndbeyond.choice = {
        label: choice.label,
        choiceId: choice.choiceId,
        componentId: choice.componentId,
        componentTypeId: choice.componentTypeId,
        parentChoiceId: choice.parentChoiceId,
        subType: choice.subType,
        wasOption: choice.wasOption,
        entityTypeId: choice.entityTypeId,
        type: choice.type,
      };

      this.data._id = foundry.utils.randomID();
      this._addEffects(choice, this.type);

    } catch (err) {
      logger/* default.warn */.Z.warn(
        `Unable to Generate Choice Action: ${this.name}, please log a bug report. Err: ${err.message}`,
        "extension"
      );
      logger/* default.error */.Z.error("Error", err);
    }
  }

  static buildChoiceFeatures(ddbFeature) {
    logger/* default.debug */.Z.debug(`Processing Choice Features ${ddbFeature._choices.map((c) => c.label).join(",")}`, {
      choices: ddbFeature._choices,
      feature: ddbFeature,
    });
    const features = [];
    ddbFeature._choices.forEach((choice) => {
      const choiceFeature = new DDBChoiceFeature({
        ddbData: ddbFeature.ddbData,
        ddbDefinition: foundry.utils.deepClone(ddbFeature.ddbDefinition),
        type: ddbFeature.type,
        rawCharacter: ddbFeature.rawCharacter,
      });
      choiceFeature.build(choice);
      logger/* default.debug */.Z.debug(`DDBChoiceFeature.buildChoiceFeatures: ${choiceFeature.ddbDefinition.name}`, {
        choiceFeature,
        choice,
        ddbFeature,
      });
      features.push(choiceFeature.data);
    });
    return features;
  }

}

;// CONCATENATED MODULE: ./src/parser/features/DDBClassFeatures.js






class DDBClassFeatures {

  constructor({ ddbData, rawCharacter = null } = {}) {
    this.ddbData = ddbData;
    this.rawCharacter = rawCharacter;
    this.data = [];

    this.featureList = {
      class: [],
      subClass: [],
    };
    this.data = [];
    this._processed = [];

    this.excludedFeatures = this.ddbData.character.optionalClassFeatures
      .filter((f) => f.affectedClassFeatureId)
      .map((f) => f.affectedClassFeatureId);
  }

  _getFeatures(featureDefinition, type, source, filterByLevel = true) {
    const feature = new DDBFeature/* default */.Z({
      ddbData: this.ddbData,
      ddbDefinition: featureDefinition,
      rawCharacter: this.rawCharacter,
      type,
      source,
    });
    feature.build();
    const allowedByLevel = !filterByLevel || (filterByLevel && feature.hasRequiredLevel);

    logger/* default.debug */.Z.debug(`DDBClassFeatures._getFeatures: ${feature.ddbDefinition.name}`, {
      featureDefinition,
      feature,
      this: this,
    });

    if (!allowedByLevel) return [];
    if (feature.isChoiceFeature) {
      return DDBChoiceFeature.buildChoiceFeatures(feature);
    } else {
      return [feature.data];
    }
  }


  _generateClassFeatures(klass) {

    const className = klass.definition.name;
    const classFeatureIds = klass.definition.classFeatures.map((f) => f.id);

    const classFeatures = klass.classFeatures.filter(
      (feat) =>
        classFeatureIds.includes(feat.definition.id)
        && DDBFeatures.includedFeatureNameCheck(feat.definition.name)
        && feat.definition.requiredLevel <= klass.level
    );

    const classFeatureList = classFeatures
      .filter((feat) => !this.excludedFeatures.includes(feat.definition.id))
      .map((feat) => {
        let items = this._getFeatures(feat, "class", className);
        return items.map((item) => {
          item.flags.ddbimporter.dndbeyond.class = className;
          foundry.utils.setProperty(item.flags, "ddbimporter.class", klass.definition.name);
          foundry.utils.setProperty(item.flags, "ddbimporter.classId", klass.definition.id);
          // const subClass = foundry.utils.getProperty(klass, "subclassDefinition");
          // foundry.utils.setProperty(item.flags, "ddbimporter.subclass", subClass?.name);
          // foundry.utils.setProperty(item.flags, "ddbimporter.subclassId", subClass?.id);
          item.flags.obsidian.source.text = className;
          // add feature to all features list
          this.featureList.class.push(foundry.utils.duplicate(item));
          return item;
        });
      })
      .flat()
      .sort((a, b) => {
        return a.flags.ddbimporter.dndbeyond.displayOrder - b.flags.ddbimporter.dndbeyond.displayOrder;
      });

    classFeatureList.forEach((item) => {
      // have we already processed an identical item?
      if (!DDBFeatures.isDuplicateFeature(this._processed, item)) {
        const existingFeature = DDBFeatures.getNameMatchedFeature(this.data, item);
        const duplicateFeature = DDBFeatures.isDuplicateFeature(this.data, item);
        if (existingFeature && !duplicateFeature) {
          const levelAdjustment = `<h3>${className}: Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.system.description.value}`;
          existingFeature.system.description.value += levelAdjustment;
          existingFeature.effects.push(...item.effects);
        } else if (!existingFeature) {
          this.data.push(item);
        }
      }
    });
    this._processed.push(...this.featureList.class, ...classFeatureList);
  }

  _generateSubClassFeatures(klass) {
    const subClassFeatureIds = klass.classFeatures
      .filter((f) => f.definition.classId === klass.subclassDefinition.id)
      .map((f) => f.definition.id);

    const className = klass.definition.name;
    const subClassName = `${className} : ${klass.subclassDefinition.name}`;

    let subClassItems = [];

    const subClassFeatures = klass.classFeatures.filter(
      (feat) =>
        subClassFeatureIds.includes(feat.definition.id)
        && DDBFeatures.includedFeatureNameCheck(feat.definition.name)
        && feat.definition.requiredLevel <= klass.level
        && !this.excludedFeatures.includes(feat.definition.id)
    );

    const subClassFeatureList = subClassFeatures
      .map((feat) => {
        let items = this._getFeatures(feat, "class", subClassName);
        return items.map((item) => {
          item.flags.ddbimporter.dndbeyond.class = subClassName;
          item.flags.obsidian.source.text = className;
          foundry.utils.setProperty(item.flags, "ddbimporter.class", klass.definition.name);
          foundry.utils.setProperty(item.flags, "ddbimporter.classId", klass.definition.id);
          const subClass = foundry.utils.getProperty(klass, "subclassDefinition");
          foundry.utils.setProperty(item.flags, "ddbimporter.subclass", subClass?.name);
          foundry.utils.setProperty(item.flags, "ddbimporter.subclassId", subClass?.id);
          // add feature to all features list
          this.featureList.subClass.push(foundry.utils.duplicate(item));
          return item;
        });
      })
      .flat()
      .sort((a, b) => {
        return a.flags.ddbimporter.dndbeyond.displayOrder - b.flags.ddbimporter.dndbeyond.displayOrder;
      });

    // parse out duplicate features from class features
    subClassFeatureList.forEach((item) => {
      if (!DDBFeatures.isDuplicateFeature(this.featureList.class, item)) {
        const existingFeature = DDBFeatures.getNameMatchedFeature(subClassItems, item);
        const duplicateFeature = DDBFeatures.isDuplicateFeature(subClassItems, item);
        if (existingFeature && !duplicateFeature) {
          const levelAdjustment = `<h3>${subClassName}: At Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.system.description.value}`;
          existingFeature.system.description.value += levelAdjustment;
        } else if (!existingFeature) {
          subClassItems.push(item);
        }
      }
    });
    // add features to list to indicate processed
    this._processed.push(...this.featureList.subClass, ...subClassFeatureList);

    // now we take the unique subclass features and add to class
    subClassItems.forEach((item) => {
      const existingFeature = DDBFeatures.getNameMatchedFeature(this.data, item);
      const duplicateFeature = DDBFeatures.isDuplicateFeature(this.data, item);
      if (existingFeature && !duplicateFeature) {
        const levelAdjustment = `<h3>${subClassName}: At Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.system.description.value}`;
        existingFeature.system.description.value += levelAdjustment;
      } else if (!existingFeature) {
        this.data.push(item);
      }
    });

  }

  build() {

    // subclass features can often be duplicates of class features.
    this.ddbData.character.classes.forEach((klass) => {
      logger/* default.debug */.Z.debug(`Processing class features for ${klass.definition.name}`);
      this._generateClassFeatures(klass);
      // subclasses
      if (klass.subclassDefinition && klass.subclassDefinition.classFeatures) {
        logger/* default.debug */.Z.debug(`Processing subclass features for ${klass.subclassDefinition.name}`);
        this._generateSubClassFeatures(klass);
      }
      logger/* default.debug */.Z.debug(`ddbClassFeatures for ${klass.definition.name}`, { ddbClassFeatures: this });
    });
    // return this.data;
  }

}

// EXTERNAL MODULE: ./src/parser/features/fixes.js
var fixes = __webpack_require__(1278);
;// CONCATENATED MODULE: ./src/parser/features/DDBFeatures.js










class DDBFeatures {

  constructor({ ddbCharacter, ddbData, rawCharacter = null } = {}) {
    this.ddbCharacter = ddbCharacter;
    this.ddbData = ddbData;
    this.rawCharacter = rawCharacter;


    this.excludedOriginFeatures = this.ddbData.character.optionalOrigins
      .filter((f) => f.affectedRacialTraitId)
      .map((f) => f.affectedRacialTraitId);

    this.parsed = [];

    this.data = [];
  }

  static LEGACY_SKIPPED_FEATURES = [
    "Hit Points",
    "Languages",
    "Bonus Proficiency",
    "Bonus Proficiencies",
    "Speed",
    "Skills",
    "Feat",
    "Primal Knowledge",
    "Creature Type",
  ];

  static TASHA_VERSATILE = [
    "Martial Versatility",
    "Bardic Versatility",
    "Cantrip Versatility",
    "Sorcerous Versatility",
    "Eldritch Versatility",
  ];

  static SKIPPED_FEATURES = [
    "Expertise",
    "Darkvision",
  ];

  static isDuplicateFeature(items, item) {
    return items.some((dup) => dup.name === item.name && dup.system.description.value === item.system.description.value);
  }

  static getNameMatchedFeature(items, item) {
    return items.find((dup) => dup.name === item.name && item.flags.ddbimporter.type === dup.flags.ddbimporter.type);
  }

  static includedFeatureNameCheck(featName) {
    const includeTashaVersatile = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "character-update-include-versatile-features");

    const nameAllowed = !featName.startsWith("Proficiencies")
      && !featName.startsWith("Ability Score")
      && !featName.startsWith("Size")
      // && !featName.startsWith("Skills")
      && (includeTashaVersatile || (!includeTashaVersatile && !DDBFeatures.TASHA_VERSATILE.includes(featName)))
      && !DDBFeatures.LEGACY_SKIPPED_FEATURES.includes(featName)
      && !DDBFeatures.SKIPPED_FEATURES.includes(featName);

    return nameAllowed;
  }

  async getFeaturesFromDefinition(featDefinition, type) {
    const source = DDBHelper/* default.parseSource */.Z.parseSource(featDefinition);
    const ddbFeature = new DDBFeature/* default */.Z({
      ddbData: this.ddbData,
      ddbDefinition: featDefinition,
      rawCharacter: this.rawCharacter,
      type,
      source,
    });

    ddbFeature.build();
    logger/* default.debug */.Z.debug(`DDBFeatures.getFeaturesFromDefinition: ${ddbFeature.ddbDefinition.name}`, {
      ddbFeature,
      featDefinition,
      this: this,
    });
    // only background features get advancements for now
    if (type === "background") {
      await ddbFeature.generateAdvancements();
      await ddbFeature.buildBackgroundFeatAdvancements();
    }
    if (ddbFeature.isChoiceFeature) {
      return DDBChoiceFeature.buildChoiceFeatures(ddbFeature);
    } else {
      return [ddbFeature.data];
    }
  }

  async _buildRacialTraits() {
    logger/* default.debug */.Z.debug("Parsing racial traits");
    const traits = this.ddbData.character.race.racialTraits
      .filter(
        (trait) => DDBFeatures.includedFeatureNameCheck(trait.definition.name)
          && !trait.definition.hideInSheet
          && !this.excludedOriginFeatures.includes(trait.definition.id)
      );

    for (const feat of traits) {
      const features = await this.getFeaturesFromDefinition(feat, "race");
      features.forEach((item) => {
        const existingFeature = DDBFeatures.getNameMatchedFeature(this.parsed, item);
        const duplicateFeature = DDBFeatures.isDuplicateFeature(this.parsed, item);
        if (existingFeature && !duplicateFeature) {
          existingFeature.system.description.value += `<h3>Racial Trait Addition</h3>${item.system.description.value}`;
        } else if (!existingFeature) {
          this.parsed.push(item);
        }
      });
    };
  }

  async _buildOptionalClassFeatures({ requireLevel = true } = {}) {
    // optional class features
    logger/* default.debug */.Z.debug("Parsing optional class features");
    if (this.ddbData.classOptions) {
      const options = this.ddbData.classOptions
        .filter((feat) => {
          if (!requireLevel || !foundry.utils.hasProperty(feat, "requiredLevel")) return true;
          const requiredLevel = foundry.utils.getProperty(feat, "requiredLevel");
          const klass = this.ddbData.character.classes.find((cls) => cls.definition.id === feat.classId
            || cls.subclassDefinition?.id === feat.classId);
          if (!klass) {
            logger/* default.info */.Z.info(`Unable to determine class for optional feature ${feat.name}, you might not have a suitable subclass`, { feat, this: this, requiredLevel });
            return false;
          }
          return klass.level >= requiredLevel;
        })
        .filter((feat) => DDBFeatures.includedFeatureNameCheck(feat.name));
      for (const feat of options) {
        logger/* default.debug */.Z.debug(`Parsing Optional Feature ${feat.name}`);
        const feats = await this.getFeaturesFromDefinition(feat, "class");
        this.parsed.push(...feats);
      };
    }
  }

  async _buildClassFeatures() {
    logger/* default.debug */.Z.debug("Parsing class and subclass features");
    this._ddbClassFeatures = new DDBClassFeatures({
      ddbData: this.ddbData,
      rawCharacter: this.rawCharacter,
    });
    this._ddbClassFeatures.build();
    await this._buildOptionalClassFeatures();

    logger/* default.debug */.Z.debug("ddbClassFeatures._buildClassFeatures", {
      ddbClassFeature: this._ddbClassFeatures,
      this: this,
    });

    // now we loop over class features and add to list, removing any that match racial traits, e.g. Darkvision
    logger/* default.debug */.Z.debug("Removing matching traits");
    this._ddbClassFeatures.data
      .forEach((item) => {
        const existingFeature = DDBFeatures.getNameMatchedFeature(this.parsed, item);
        const duplicateFeature = DDBFeatures.isDuplicateFeature(this.parsed, item);
        if (existingFeature && !duplicateFeature) {
          const klassAdjustment = `<h3>${item.flags.ddbimporter.dndbeyond.class}</h3>${item.system.description.value}`;
          existingFeature.system.description.value += klassAdjustment;
        } else if (!existingFeature) {
          this.parsed.push(item);
        }
      });
  }

  async _addFeats() {
    // add feats
    logger/* default.debug */.Z.debug("Parsing feats");
    for (const feat of this.ddbData.character.feats) {
      const feats = await this.getFeaturesFromDefinition(feat, "feat");
      this.parsed.push(...feats);
    };
  }

  async _addBackground() {
    logger/* default.debug */.Z.debug("Parsing background");
    const backgroundFeature = this.ddbCharacter.getBackgroundData();
    const backgroundFeats = await this.getFeaturesFromDefinition(backgroundFeature, "background");
    this.parsed.push(...backgroundFeats);
  }

  _setLevelScales() {
    this.parsed.forEach((feature) => {
      const featureName = utils/* default.referenceNameString */.Z.referenceNameString(feature.name).toLowerCase();
      const scaleKlass = this.ddbCharacter.raw.classes.find((klass) =>
        klass.system.advancement
          .some((advancement) => advancement.type === "ScaleValue"
            && advancement.configuration.identifier === featureName
          ));

      if (scaleKlass) {
        const identifier = utils/* default.referenceNameString */.Z.referenceNameString(scaleKlass.system.identifier).toLowerCase();
        if (foundry.utils.hasProperty(feature, "system.damage.parts") && feature.system.damage.parts.length > 0) {
          feature.system.damage.parts[0][0] = `@scale.${identifier}.${featureName}`;
        } else {
          foundry.utils.setProperty(feature, "system.damage.parts", [[`@scale.${identifier}.${featureName}`]]);
        }
      }
    });
  }

  fixAcEffects() {
    for (const feature of this.parsed) {
      logger/* default.debug */.Z.debug(`Checking ${feature.name} for AC effects`);
      for (const effect of (feature.effects ?? [])) {
        if (
          !["Natural", "Unarmored Defense", "Custom", "Unarmored"].includes(this.ddbCharacter.armor.results.maxType)
          && (
            (effect.changes.length === 2
            && effect.changes.some((change) => change.key === "system.attributes.ac.formula")
            && effect.changes.some((change) => change.key === "system.attributes.ac.calc"))
            || (effect.changes.length === 1
              && effect.changes.some((change) => change.key === "system.attributes.ac.calc"))
          )
        ) {
          effect.disabled = true;
        }
      }
    }
  }

  async build() {
    await this._buildRacialTraits();
    await this._buildClassFeatures();
    await this._addFeats();
    await this._addBackground();

    this._setLevelScales();

    await (0,fixes/* fixFeatures */.t)(this.parsed);
    this.fixAcEffects();
    this.data = await (0,fixes/* addExtraEffects */.f)(this.ddbData, this.parsed, this.rawCharacter);
  }
}

;// CONCATENATED MODULE: ./src/parser/features/CharacterFeatureFactory.js








class CharacterFeatureFactory {

  constructor(ddbCharacter) {
    this.ddbCharacter = ddbCharacter;
    this.ddbData = ddbCharacter.source.ddb;
    this.rawCharacter = ddbCharacter.raw.character;

    this.parsed = {
      actions: [],
      features: [],
    };

    this.processed = {
      actions: [],
      features: [],
    };

    this.data = [];
  }


  _getCustomActions(displayedAsAttack) {
    const customActions = this.ddbData.character.customActions
      .filter((action) => action.displayAsAttack === displayedAsAttack)
      .map((action) => {
        action.dice = {
          diceString: action.diceCount && action.diceType ? `${action.diceCount}d${action.diceType}` : null,
          fixedValue: action.fixedValue,
        };

        const range = {
          aoeType: action.aoeType,
          aoeSize: action.aoeSize,
          range: action.range,
          long: action.longRange,
        };
        action.range = range;

        if (action.statId) action.abilityModifierStatId = action.statId;

        action.activation = {
          activationTime: action.activationTime,
          activationType: action.activationType,
        };

        action.isCustomAction = true;

        return action;
      });

    return customActions;
  }


  /**
   * Everyone has an Unarmed Strike
   */
  getUnarmedStrike(overrides = {}) {
    const unarmedStrikeMock = CONFIG.DDB.naturalActions[0];
    unarmedStrikeMock.displayAsAttack = true;
    const strikeMock = Object.assign(unarmedStrikeMock, overrides);

    const unarmedStrikeAction = new DDBAttackAction/* default */.Z({ ddbData: this.ddbData, ddbDefinition: strikeMock, rawCharacter: this.rawCharacter });
    unarmedStrikeAction.build();

    // console.warn(`unarmedStrikeAction for Unarmed strike`, unarmedStrikeAction);
    return unarmedStrikeAction.data;
  }

  _generateUnarmedStrikeAction(overrides = {}) {
    this.parsed.actions.push(this.getUnarmedStrike(overrides));
  }


  _generateAttackActions() {
    const attackActions = [
      // do class options here have a class id, needed for optional class features
      this.ddbData.character.actions.class
        .filter((action) => DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.ddbData, action.componentId))
        .map((t) => {
          t.actionSource = "class";
          return t;
        }),
      this.ddbData.character.actions.race.map((t) => {
        t.actionSource = "race";
        return t;
      }),
      this.ddbData.character.actions.feat.map((t) => {
        t.actionSource = "feat";
        return t;
      }),
      this._getCustomActions(true),
    ]
      .flat()
      .filter((action) => DDBHelper/* default.displayAsAttack */.Z.displayAsAttack(this.ddbData, action, this.rawCharacter))
      .map((action) => {
        const ddbAttackAction = new DDBAttackAction/* default */.Z({ ddbData: this.ddbData, ddbDefinition: action, rawCharacter: this.rawCharacter, type: action.actionSource });
        ddbAttackAction.build();

        // console.warn(`ddbAttackAction for ${action.name}`, ddbAttackAction);
        return ddbAttackAction.data;
      });
    logger/* default.debug */.Z.debug("attack actions", attackActions);
    this.parsed.actions = this.parsed.actions.concat(attackActions);
  }


  actionParsed(actionName) {
    // const attacksAsFeatures = game.settings.get("ddb-importer", "character-update-policy-use-actions-as-features");
    const exists = this.parsed.actions.some((attack) => attack.name === actionName);
    return exists;
    // return attacksAsFeatures && exists;
  }

  _generateOtherActions() {
    const otherActions = [
      // do class options here have a class id, needed for optional class features
      this.ddbData.character.actions.class.filter((action) => DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.ddbData, action.componentId)),
      this.ddbData.character.actions.race,
      this.ddbData.character.actions.feat,
      this._getCustomActions(false),
    ]
      .flat()
      .filter((action) => action.name && action.name !== "")
      .filter(
        (action) => {
          const name = DDBHelper/* default.getName */.Z.getName(this.ddbData, action, this.rawCharacter);
          // const displayAsAttack = DDBHelper.displayAsAttack(this.ddbData, action, this.rawCharacter);
          // lets grab other actions and add, make sure we don't get attack based ones that haven't parsed
          return !this.actionParsed(name);
        }
      )
      .map((action) => {
        logger/* default.debug */.Z.debug(`Getting Other Action ${action.name}`);

        const ddbAction = new DDBAction/* default */.Z({ ddbData: this.ddbData, ddbDefinition: action, rawCharacter: this.rawCharacter });
        ddbAction.build();
        // console.warn(`ddbAction for ${action.name}`, ddbAction);

        return ddbAction.data;
      });

    logger/* default.debug */.Z.debug("other actions", otherActions);
    this.parsed.actions = this.parsed.actions.concat(otherActions);
  }

  async processActions() {
    this._generateAttackActions();
    this._generateUnarmedStrikeAction();
    this._generateOtherActions();

    this.processed.actions = foundry.utils.duplicate(this.parsed.actions);

    this.processed.actions.sort().sort((a, b) => {
      if (!a.system.activation.activationType) {
        return 1;
      } else if (!b.system.activation.activationType) {
        return -1;
      } else {
        const aActionTypeID = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find(
          (type) => type.value === a.system.activation.activationType
        ).id;
        const bActionTypeID = dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find(
          (type) => type.value === b.system.activation.activationType
        ).id;
        if (aActionTypeID > bActionTypeID) {
          return 1;
        } else if (aActionTypeID < bActionTypeID) {
          return -1;
        } else {
          return 0;
        }
      }
    });

    await (0,fixes/* fixFeatures */.t)(this.processed.actions);
    this.processed.actions = await (0,fixes/* addExtraEffects */.f)(this.ddbData, this.processed.actions, this.rawCharacter);
    this.updateIds("actions");
    this.data.push(...this.processed.actions);
  }

  updateIds(type) {
    this.ddbCharacter.updateItemIds(this.processed[type]);
  }

  async processFeatures() {
    const ddbFeatures = new DDBFeatures({
      ddbCharacter: this.ddbCharacter,
      ddbData: this.ddbData,
      rawCharacter: this.rawCharacter,
    });

    await ddbFeatures.build();
    this.processed.features = ddbFeatures.data;
    this.updateIds("features");
    this.data.push(...ddbFeatures.data);
  }

  #itemGrantLink(feature, advancementIndex) {
    // "added": {
    //   "TlT20Gh1RofymIDY": "Compendium.dnd5e.classfeatures.Item.u4NLajXETJhJU31v",
    //   "2PZlmOVkOn2TbR1O": "Compendium.dnd5e.classfeatures.Item.hpLNiGq7y67d2EHA"
    // }
    const linkingData = foundry.utils.getProperty(feature, "flags.ddbimporter.advancementLink");
    const advancement = feature.system.advancement[advancementIndex];
    const dataLink = linkingData.find((d) => d._id === advancement._id);

    if (!dataLink || !linkingData || !advancement) {
      logger/* default.warn */.Z.warn(`Advancement for ${feature.name} (idx ${advancementIndex}) missing required data for linking`, {
        advancement,
        linkingData,
        dataLink,
      });
      return;
    }

    const added = {};
    for (const [advancementFeatureName, uuid] of Object.entries(dataLink.features)) {
      logger/* default.debug */.Z.debug(`Advancement ${advancement._id} searching for Feature ${advancementFeatureName} (${uuid})`, {
        advancement,
        advancementFeatureName,
        uuid,
      });

      const characterFeature = this.ddbCharacter.getDataFeature(advancementFeatureName);
      if (characterFeature) {
        logger/* default.debug */.Z.debug(`Advancement ${advancement._id} found Feature ${advancementFeatureName} (${uuid})`);
        added[characterFeature._id] = uuid;
        foundry.utils.setProperty(characterFeature, "flags.dnd5e.sourceId", uuid);
        foundry.utils.setProperty(characterFeature, "flags.dnd5e.advancementOrigin", `${feature._id}.${advancement._id}`);
      }
    }

    if (Object.keys(added).length > 0) {
      advancement.value = {
        added,
      };
      feature.system.advancement[advancementIndex] = advancement;
    }
  }

  #addGenericAdvancementOrigins(types = ["actions", "features"]) {
    for (const type of types) {
      for (const feature of this.ddbCharacter.data[type]) {
        // eslint-disable-next-line no-continue
        if (foundry.utils.hasProperty(feature, "flags.dnd5e.advancementOrigin")) continue;
        const typeFlag = foundry.utils.getProperty(feature, "flags.ddbimporter.type");
        if (typeFlag == "race" && foundry.utils.hasProperty(this.ddbCharacter, "data.race._id")) {
          foundry.utils.setProperty(feature, "flags.dnd5e.advancementOrigin", `${this.ddbCharacter.data.race._id}`);
        } else if (typeFlag === "background") {
          const background = this.ddbCharacter.data.features.find((b) => b.type === "background");
          if (background) {
            foundry.utils.setProperty(feature, "flags.dnd5e.advancementOrigin", `${background._id}`);
          }
        } else if (typeFlag === "class" && foundry.utils.hasProperty(feature, "flags.ddbimporter.class")) {
          const klass = this.ddbCharacter.data.classes.find((k) => k.name === foundry.utils.getProperty(feature, "flags.ddbimporter.class"));
          if (klass) {
            foundry.utils.setProperty(feature, "flags.dnd5e.advancementOrigin", `${klass._id}`);
          }
        }
      }
    }
  }

  linkFeatures(types = ["actions", "features"]) {
    logger/* default.debug */.Z.debug("Linking Feature Factory Advancements to Features", {
      CharacterFeatureFactory: this,
      types,
    });
    for (const type of types) {
      for (const feature of this.ddbCharacter.data[type]) {
        const linkingData = foundry.utils.getProperty(feature, "flags.ddbimporter.advancementLink");
        if (linkingData) {
          logger/* default.debug */.Z.debug("Linking Advancements to Features", {
            feature,
            linkingData,
          });
          for (let idx = 0; idx < feature.system.advancement.length; idx++) {
            const a = feature.system.advancement[idx];
            const dataLink = linkingData.find((d) => d._id === a._id);
            // eslint-disable-next-line max-depth
            if (a.type === "ItemGrant" && dataLink) {
              this.#itemGrantLink(feature, idx);
            }
          }
        }
      }
    }
    this.#addGenericAdvancementOrigins(types);
  }
}

// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects = __webpack_require__(5751);
// EXTERNAL MODULE: ./src/lib/DDBCompendiumFolders.js
var DDBCompendiumFolders = __webpack_require__(819);
// EXTERNAL MODULE: ./src/lib/DDBItemImporter.js
var DDBItemImporter = __webpack_require__(6968);
;// CONCATENATED MODULE: ./src/parser/features/DDBInfusion.js


// import CompendiumHelper from "../../lib/CompendiumHelper.js";










class DDBInfusion {

  _init() {
    logger/* default.debug */.Z.debug(`Generating Infusion Feature ${this.ddbInfusion.name}`);
  }

  _generateDataStub() {

    this.data = {
      _id: utils/* default.namedIDStub */.Z.namedIDStub(this.name, { postfix: this.nameIdPostfix }),
      name: utils/* default.nameString */.Z.nameString(`Infusion: ${this.name}`),
      type: this.documentType,
      system: utils/* default.getTemplate */.Z.getTemplate(this.documentType),
      effects: [],
      flags: {
        ddbimporter: {
          id: this.ddbInfusion.id,
          infusionId: this.ddbInfusion.id,
          class: "Artificer",
          infusionFeature: true,
          type: this.tagType,
          dndbeyond: {
            defintionKey: this.ddbInfusion.definitionKey,
            requiredLevel: this.ddbInfusion.level,
            modifierType: this.ddbInfusion.modifierDataType,
            type: this.ddbInfusion.type,
            requiresAttunement: this.ddbInfusion.requiresAttunement,
            allowDuplicates: this.ddbInfusion.allowDuplicates,
          },
        },
      }
    };

    this.requiredLevel = null;
    const requiredLevel = foundry.utils.getProperty(this.ddbInfusion, "level");
    if (Number.isInteger(Number.parseInt(requiredLevel))) {
      this.data.system.prerequisites = {
        level: Number.parseInt(requiredLevel),
      };
      this.requiredLevel = Number.parseInt(requiredLevel);
    }

    this.data.system.consume = {
      type: "charges",
      target: "",
      amount: "1",
      scale: false,
    };
    this.data.system.enchantment = {
      items: {
        max: "",
        period: "",
      },
      restrictions: {
        type: "",
        allowMagical: false
      },
      classIdentifier: "",
    };
    this.data.system.source = DDBHelper/* default.parseSource */.Z.parseSource(this.ddbInfusion);
    this.data.system.activation.type = "none";
    if (this.requiredLevel && this.requiredLevel > 1) {
      this.data.system.requirements = ` ${utils/* default.ordinalSuffixOf */.Z.ordinalSuffixOf(this.requiredLevel)}-level Artificer`;
    }
  }

  constructor({ ddbData, ddbInfusion, documentType = "feat", rawCharacter = null, noMods = false, addToCompendium = true, nameIdPostfix = null } = {}) {
    this.ddbData = ddbData;
    this.rawCharacter = rawCharacter;
    this.ddbInfusion = ddbInfusion;
    this.name = utils/* default.nameString */.Z.nameString(this.ddbInfusion.name);
    this.type = "feat";
    this.isAction = false;
    this.documentType = documentType;
    this.tagType = "infusion";
    this.data = {};
    this.actions = [];
    this.grantedItems = [];
    this.noMods = noMods;
    this.idNames = [];
    this.compendium = null;
    this.snippet = "";
    this._init();
    this._generateDataStub();
    this.addToCompendium = addToCompendium;
    this.nameIdPostfix = nameIdPostfix;
  }

  _buildDescription() {
    this.snippet = this.ddbInfusion.snippet ? this.ddbInfusion.snippet : "";
    const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");
    const itemText = foundry.utils.getProperty(this.ddbInfusion, "itemRuleData.text");
    const prerequisitesHeader = this.requiredLevel && this.requiredLevel > 1
      ? `<p><i>Prerequisites: ${utils/* default.ordinalSuffixOf */.Z.ordinalSuffixOf(this.requiredLevel)}-level Artificer</i></p>`
      : "";
    const itemHeader = itemText
      ? `<p><i>Item: ${itemText}</i></p>`
      : "";

    const valueDamageText = (0,DDBReferenceLinker/* parseDamageRolls */.IP)({ text: this.ddbInfusion.description, document: this.data, actor: null });
    const chatDamageText = chatAdd ? (0,DDBReferenceLinker/* parseDamageRolls */.IP)({ text: this.snippet, document: this.data, actor: null }) : "";
    this.data.system.description = {
      value: (0,DDBReferenceLinker/* parseTags */.RN)(prerequisitesHeader + itemHeader + valueDamageText),
      chat: chatAdd ? (0,DDBReferenceLinker/* parseTags */.RN)(chatDamageText) : "",
    };
  }

  _generateSystemType() {
    foundry.utils.setProperty(this.data, "system.type.value", "enchantment");
    foundry.utils.setProperty(this.data, "system.type.subtype", "artificerInfusion");
  }

  _generateEnchantmentType() {
    if (this.ddbInfusion.type === "replicate") {
      foundry.utils.setProperty(this.data, "system.enchantment.restrictions.allowMagical", true);
    }
    let type = "";
    const itemRule = foundry.utils.getProperty(this.ddbInfusion, "itemRuleData.text");
    if (!itemRule) return;
    if (itemRule.includes("weapon")) type = "weapon";
    else if (itemRule.includes("armor")) type = "equipment";
    else if (itemRule.includes("shield")) type = "equipment";
    else if (itemRule.includes("gem")) type = "loot";
    // tool, equipment, consumable, loot, container, weapon
    foundry.utils.setProperty(this.data, "system.enchantment.restrictions.type", type);
  }

  _generateActionType() {
    if (["augment", "replicate"].includes(this.ddbInfusion.type)) {
      this.data.system.actionType = "ench";
    } else if (this.ddbInfusion.type === "creature") {
      this.data.system.actionType = "summon";
      this.data.system.activation = {
        type: "action",
        cost: 1,
      };
    }
  }

  async compendiumInit() {
    this.compendiumFolders = new DDBCompendiumFolders/* DDBCompendiumFolders */.Z("features");
    await this.compendiumFolders.loadCompendium("features");
  }

  async addInfusionsToCompendium(documents) {
    const featureHandlerOptions = {
      chrisPremades: false,
      deleteBeforeUpdate: false,
      removeSRDDuplicates: false,
      filterDuplicates: false,
      matchFlags: ["infusionId"],
      useCompendiumFolders: true,
    };

    logger/* default.debug */.Z.debug(`Creating infusion compendium feature`, {
      documents,
      featureHandlerOptions,
      addToCompendium: this.addToCompendium,
      this: this,
    });
    const featureHandler = this.addToCompendium
      ? await DDBItemImporter/* default.buildHandler */.Z.buildHandler("features", documents, true, featureHandlerOptions)
      : new DDBItemImporter/* default */.Z("features", documents, featureHandlerOptions);
    await featureHandler.buildIndex({
      fields: [
        "name",
        "flags.ddbimporter.classId",
        "flags.ddbimporter.class",
        "flags.ddbimporter.subClass",
        "flags.ddbimporter.parentClassId",
        "flags.ddbimporter.featureName",
        "flags.ddbimporter.infusionId",
      ],
    });
    const compendiumFeatures = await featureHandler.compendiumIndex.filter((i) =>
      featureHandler.documents.some((orig) => i.name === orig.name)
    );
    return compendiumFeatures;
  }

  _buildActions() {
    // build actions fomr this.ddbInfusion.actions
    // for example radiant weapon reaction
    if (!this.ddbInfusion.actions) return;

    for (const actionData of this.ddbInfusion.actions) {
      // const itemLookup = ddb.infusions.item.find((mapping) => mapping.definitionKey === infusionDetail.definitionKey);
      if (!actionData.name) {
        const activationType = foundry.utils.getProperty(actionData, "activation.activationType");
        const postfix = [3, 4].includes(activationType)
          ? ` (${utils/* default.capitalize */.Z.capitalize(dictionary/* default.actions.activationTypes.find */.Z.actions.activationTypes.find((a) => a.id === activationType).value)})`
          : "";
        actionData.name = `${this.name}${postfix}`;
      }
      const action = DDBHelper/* default.displayAsAttack */.Z.displayAsAttack(this.ddbData, actionData, this.rawCharacter)
        ? new DDBAttackAction/* default */.Z({ ddbData: this.ddbData, ddbDefinition: actionData, rawCharacter: this.rawCharacter, type: actionData.actionSource })
        : new DDBAction/* default */.Z({ ddbData: this.ddbData, ddbDefinition: actionData, rawCharacter: this.rawCharacter });
      action.build();
      foundry.utils.setProperty(action.data, "flags.ddbimporter.class", "Artificer");
      foundry.utils.setProperty(action.data, "flags.ddbimporter.infusionFeature", true);
      foundry.utils.setProperty(action.data, "flags.ddbimporter.infusionId", actionData.id);
      action._id = utils/* default.namedIDStub */.Z.namedIDStub(actionData.name);
      this.actions.push(action.data);
    }
    logger/* default.debug */.Z.debug(`Generated Infusions Actions`, this.actions);
  }

  async _addActionsToEffects() {
    if (this.actions.length === 0) return;
    const cItems = await this.addInfusionsToCompendium(this.actions);
    if (cItems.length === 0) return;

    const descriptions = this.ddbInfusion.actions.map((i) => `[[/item ${i.name}]]`);

    const uuids = cItems.map((i) => i.uuid);
    this.data.effects.forEach((e) => {
      if (e.flags.ddbimporter?.infusion) e.flags.dnd5e.enchantment.riders.item.push(...uuids);
      e.changes.push({
        key: "system.description.value",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: `<hr> <br><h2>Infusion Actions</h2><p> ${descriptions.join(", ")} </p>`,
      });
    });
  }

  _specials() {
    // handle special cases
    // e.g. radiant weapon blindness effect

    switch (this.name) {
      // example
      case "Radiant Weapon": {
        break;
      }
      // case "Spell-Refueling Ring": {
      //   const macroText = `<br><p>[[/ddbifunc functionName="spellRefuelingRing" functionType="item"]]{Spell Refueling Macro}</div></p>`;
      //   this.data.system.description.value += macroText;
      //   if (this.data.system.description.chat !== "") this.data.system.description.chat += macroText;
      //   break;
      // }
      // no default
    }


    for (let action of this.actions) {
      const name = foundry.utils.getProperty(action, "flags.ddbimporter.originalName") ?? action.name;
      switch (name) {
        case "Radiant Weapon (Reaction)": {
          action = (0,effects/* addSimpleConditionEffect */.x8)(action, "Blinded", { transfer: false });
          break;
        }
        case "Spell-Refueling Ring (Reaction)": {
          const macroText = `<br><p>[[/ddbifunc functionName="spellRefuelingRing" functionType="item"]]{Spell Refueling Macro}</div></p>`;
          action.system.description.value += macroText;
          if (action.system.description.chat !== "") this.data.system.description.chat += macroText;
          break;
        }
        // no default
      }
    }

  }

  _getEnchantmentEffect(modifierData, { useModifierLabelName = false, useOrigin = false } = {}) {
    const label = modifierData.name ?? this.name;
    const foundryItem = foundry.utils.deepClone(this.data);
    foundryItem.effects = [];
    const effect = (0,effects/* baseEnchantmentEffect */.yN)(foundryItem, label, {
      origin: useOrigin ? `Item.${this.data._id}` : null,
    });
    effect.flags.ddbimporter.infusion = true;
    const modifiers = foundry.utils.deepClone(modifierData.modifiers) ?? [];
    const modifierItem = {
      definition: {
        name: this.name,
        grantedModifiers: modifiers.filter((mod) =>
          !(mod.type === "bonus" && mod.subType === "armor-class")
          && !(mod.type === "bonus" && mod.subType === "magic")
        ),
      },
    };

    const mockItem = (0,effects/* generateEffects */.K7)({
      ddb: this.ddbData,
      character: this.rawCharacter,
      ddbItem: modifierItem,
      foundryItem,
      isCompendiumItem: this.noMods,
      type: "infusion",
      description: this.snippet,
    });
    if (mockItem.effects.length > 0) effect.changes = mockItem.effects.map((e) => e.changes).flat(1);

    effect.changes.push(...this._getMagicBonusChanges(modifiers));

    if (this.ddbInfusion.requiresAttunement) {
      effect.changes.push({
        key: "system.attunement",
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: "required",
      });
    }

    const nameLabel = this.ddbInfusion.type === "replicate"
      ? `: Replicated [Infusion]`
      : `: ${useModifierLabelName ? label : this.name} [Infusion]`;
    effect.changes.push(
      {
        key: "name",
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        value: nameLabel,
        priority: 20,
      }
    );
    return effect;
  }

  _generateEnchantmentStubEffect() {
    const useModifierLabelName = ["damage-type-choice"].includes(this.ddbInfusion.modifierDataType);
    const effect = this._getEnchantmentEffect([], {
      useModifierLabelName,
    });
    this.data.effects.push(effect);
  }

  _addDescriptionToEffect(effect) {
    effect.changes.push({
      key: "system.description.value",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: `<hr> <br> ${this.ddbInfusion.description}`,
    });
  }

  _generateEnchantmentEffects() {
    const useModifierLabelName = ["damage-type-choice"].includes(this.ddbInfusion.modifierDataType);
    for (const [index, effectData] of this.ddbInfusion.modifierData.entries()) {
      const effect = this._getEnchantmentEffect(effectData, {
        useModifierLabelName,
      });

      switch (this.ddbInfusion.modifierDataType) {
        case "class-level": {
          const minLevel = effectData.value;
          const maxLevel = index < this.ddbInfusion.modifierData.length - 1
            ? (this.ddbInfusion.modifierData[index + 1].value ?? null)
            : null;
          const level = {
            min: minLevel,
            max: maxLevel,
          };
          foundry.utils.setProperty(effect, "flags.dnd5e.enchantment.level", level);
          effect.description = this.ddbInfusion.snippet;
          this._addDescriptionToEffect(effect);
          break;
        }
        case "granted": {
          effect.description = this.ddbInfusion.snippet;
          this._addDescriptionToEffect(effect);
          break;
        }
        case "damage-type-choice": {
          effect.description = this.ddbInfusion.snippet;
          this._addDescriptionToEffect(effect);
          break;
        }
        default: {
          this._addDescriptionToEffect(effect);
          logger/* default.debug */.Z.debug(`Infusion ${this.name} has no additional config`);
        }
      }

      this.data.effects.push(effect);
    }

  }

  _getMagicBonusChanges(modifiers) {
    const filteredModifiers = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "bonus", "magic");
    const magicBonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(filteredModifiers, this.rawCharacter);

    const acFilteredModifiers = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "bonus", "armor-class");
    const acMagicalBonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(acFilteredModifiers, this.rawCharacter);

    const changes = [];
    if (magicBonus && magicBonus !== 0 && magicBonus !== "") {
      changes.push(
        {
          key: "system.magicalBonus",
          mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
          value: magicBonus,
          priority: 20,
        },
      );
    }
    if (acMagicalBonus && acMagicalBonus !== 0 && acMagicalBonus !== "") {
      changes.push(
        {
          key: "system.armor.magicalBonus",
          mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
          value: acMagicalBonus,
          priority: 20,
        },
      );
    }

    // all items infused become magical
    changes.push({
      key: "system.properties",
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: "mgc",
      priority: 20,
    });
    return changes;
  }

  _generateEnchantments() {
    if ((this.data.system.actionType !== "ench")) return;

    this._generateEnchantmentEffects();

    switch (this.ddbInfusion.modifierDataType) {
      case "granted":
      default: {
        if (this.data.effects.length === 0) this._generateEnchantmentStubEffect();
      }
    }
  }

  async _addExtraEffects() {
    this.data = await (0,fixes/* addExtraEffects */.f)(this.ddbData, [this.data], this.rawCharacter)[0];
    this.actions = await (0,fixes/* addExtraEffects */.f)(this.ddbData, this.actions, this.rawCharacter);
  }

  // _generateSummons() {
  //   // summons are generated elsewhere and linked to the feature, not handled her.
  // }

  async build() {
    await this.compendiumInit();
    this._generateSystemType();
    this._generateEnchantmentType();
    this._generateActionType();
    this._buildDescription();
    this._generateEnchantments();
    this._buildActions();
    this._specials();
    // await this._addExtraEffects();
    await this._addActionsToEffects();

    await this.addInfusionsToCompendium([this.data]);

    logger/* default.debug */.Z.debug(`DDBInfusions for ${this.name}`, {
      data: foundry.utils.deepClone(this.data),
      actions: foundry.utils.deepClone(this.actions),
      this: this,
    });
  }

}

;// CONCATENATED MODULE: ./src/parser/features/DDBInfusionFactory.js





class DDBInfusionFactory {

  constructor(ddbCharacter) {
    this.ddbCharacter = ddbCharacter;
    this.ddbData = ddbCharacter.source.ddb;
    this.rawCharacter = ddbCharacter.raw.character;

    this.processed = {
      actions: [],
      infusions: [],
    };

    this.infusionCount = {

    };
  }


  _getInfusionCount(name) {
    if (!this.infusionCount[name]) {
      this.infusionCount[name] = 0;
    }
    return ++this.infusionCount[name];
  }

  updateIds(type) {
    this.ddbCharacter.updateItemIds(this.processed[type]);
  }

  async processInfusions() {
    logger/* default.debug */.Z.debug("Parsing infusions");
    for (const infusion of (foundry.utils.getProperty(this.ddbData, "infusions.infusions.definitionData") ?? [])) {
      const infusionNum = Number.parseInt(this._getInfusionCount(infusion.name));
      const addToCompendium = infusionNum === 1;
      // console.warn(`Infusion ${infusionNum}: ${infusion.name}`, {
      //   addToCompendium,
      // });
      const ddbInfusion = new DDBInfusion({
        ddbData: this.ddbData,
        ddbInfusion: infusion,
        rawCharacter: this.rawCharacter,
        nameIdPostfix: infusionNum > 1 ? infusionNum : null,
        addToCompendium,
      });
      await ddbInfusion.build();
      logger/* default.debug */.Z.debug(`DDBInfusion: ${ddbInfusion.ddbInfusion.name}`, {
        ddbInfusion,
        infusion,
        this: this,
      });
      this.processed.infusions.push(ddbInfusion.data);
      this.processed.actions.push(...ddbInfusion.actions);
    }
    this.updateIds("infusions");
    this.updateIds("actions");
  }


  _getInfusionItemMap(item) {
    const infusionDetails = foundry.utils.getProperty(this.ddbData, "infusions");
    if (!infusionDetails?.item) return undefined;
    return infusionDetails.item.find((mapping) =>
      mapping.itemId === item.flags.ddbimporter.definitionId
      && mapping.inventoryMappingId === item.flags.ddbimporter.id
      && mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId
    );
  }


  // adjust this to find the imported infusions
  _getInfusionDetail(definitionKey) {
    if (!this.ddbData.infusions?.infusions?.definitionData) return undefined;
    return this.ddbData.infusions.infusions.definitionData.find(
      (infusion) => infusion.definitionKey === definitionKey
    );
  }

  addInfusionsToItem(foundryItem, ddbItem) {
    // get item mapping
    const infusionItemMap = this.getInfusionItemMap(foundryItem);
    foundryItem.flags.infusions = { maps: [], applied: [], infused: false };
    // sometimes ddb keeps dead infusions around - notably homonculus
    const infusionDetail = infusionItemMap
      ? this._getInfusionDetail(this.ddbData, infusionItemMap.definitionKey)
      : undefined;

    if (infusionItemMap && infusionDetail) {
      logger/* default.debug */.Z.debug(`Infusion detected for ${foundryItem.name}`);

      // add infusion flags
      foundryItem.flags.infusions.infused = true;

      // set magic properties
      utils/* default.addToProperties */.Z.addToProperties(foundryItem.system.properties, "mgc");

      // adjust name for infused item
      if (!foundryItem.name.includes("[Infusion]")) foundryItem.name += " [Infusion]";
      // if item is loot, lets move it to equipment/trinket so effects will apply
      if (foundryItem.type === "loot") {
        foundryItem.type = "equipment";
        foundryItem.system.armor = {
          type: "trinket",
          value: 10,
          dex: null,
        };
        // infusions will over ride the can equip status, so just check for equipped
        foundryItem.system.equipped = ddbItem.equipped;
      }

      // TO DO: move this effect to the enchantment item
      // check to see if we need to fiddle attack modifiers on infused weapons
      if (foundryItem.type === "weapon") {
        const intSwap = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.ddbData, "bonus", {
          subType: "magic-item-attack-with-intelligence",
        }).length > 0;
        if (intSwap) {
          const characterAbilities = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities;
          const mockAbility = foundry.utils.getProperty(foundryItem, "flags.ddbimporter.dndbeyond.ability");
          if (characterAbilities.int.value > characterAbilities[mockAbility].value) {
            foundryItem.system.ability = "int";
          }
        }
      }

    } else if (infusionItemMap && !infusionDetail) {
      logger/* default.warn */.Z.warn(`${foundryItem.name} marked as infused but no infusion info found`);
    }
    return foundryItem;

  }


}

;// CONCATENATED MODULE: ./src/parser/DDBCharacter.js



















class DDBCharacter {
  constructor({ currentActor = null, characterId = null, selectResources = true, enableCompanions = false } = {}) {
    // the actor the data will be imported into/currently exists
    this.currentActor = currentActor;
    this.currentActorId = currentActor?.id;
    // DDBCharacter ID
    this.characterId = characterId;
    // show resource selection prompt?
    this.selectResources = selectResources;
    this.resourceChoices = currentActor && foundry.utils.hasProperty(currentActor, "flags.ddbimporter.resources.type")
      ? foundry.utils.getProperty(currentActor, "flags.ddbimporter.resources")
      : {
        ask: game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "show-resource-chooser-default"),
        type: "remove",
        primary: "",
        secondary: "",
        tertiary: "",
      };
    this.resources = [];
    // raw data received from DDB
    this.source = null;
    // this is the raw items processed before filtering
    this.raw = {};
    // the data to act on following initial parse
    this.data = {};

    // Character data
    this.abilities = {
      overrides: {},
      core: {},
      withEffects: {},
    };
    this.spellSlots = {};
    this.totalLevels = 0;
    this.companionFactories = [];
    this.enableCompanions = enableCompanions;

    this._currency = {
      pp: 0,
      gp: 0,
      ep: 0,
      sp: 0,
      cp: 0,
    };

    this._itemCurrency = {
      pp: 0,
      gp: 0,
      ep: 0,
      sp: 0,
      cp: 0,
    };

    this.itemCompendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("inventory");
    this.spellCompendium = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("spell");

    this.armor = {};

  }

  /**
   * Retrieves the character ID from a given URL, which can be one of the following:
   * - regular character sheet
   * - public sharing link
   * - direct link to the endpoint already
   * @returns {string|null} DDB CharacterId
   * @param {String} url
   */
  static getCharacterId(url) {
    const ddbNamePattern = /(?:https?:\/\/)?(?:www\.)?(?:dndbeyond\.com|ddb\.ac)(?:\/profile\/.+)?\/characters\/(\d+)\/?/;
    const matches = url.match(ddbNamePattern);
    return matches ? matches[1] : null;
  }

  /**
   * Creates the Character Endpoint URL from a given character ID
   * @returns {string|null} The API endpoint
   */
  getCharacterAPIEndpoint() {
    return this.characterId !== null ? `https://character-service.dndbeyond.com/character/v5/character/${this.characterId}` : null;
  }


  /**
   * Loads and parses character in the proxy
   * This will return an object containing the character, and items separated into arrays relating to their types
   * Additional processing is required after this step.
   * @param {String} syncId
   * @param {String} localCobaltPostFix
   * @returns {Object} Parsed Character Data and DDB data
   */

  async getCharacterData({ syncId = undefined, localCobaltPostFix = "" } = {}) {
    const cobaltCookie = (0,Secrets/* getCobalt */.HF)(localCobaltPostFix);
    const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
    const betaKey = game.settings.get("ddb-importer", "beta-key");
    const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
    const proxyCampaignId = campaignId === "" ? null : campaignId;
    let body = {
      cobalt: cobaltCookie,
      betaKey, characterId: this.characterId,
      campaignId: proxyCampaignId,
      filterModifiers: false,
    };
    if (syncId) {
      body["updateId"] = syncId;
    }

    try {
      const response = await fetch(`${parsingApi}/proxy/v5/character`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        redirect: "follow", // manual, *follow, error
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      });
      this.source = await response.json();
      if (!this.source.success) return;

      this.source.ddb = (0,filterModifiers/* fixCharacterLevels */.TP)(this.source.ddb);

      // load some required content
      await (0,DDBReferenceLinker/* importCacheLoad */.uB)();

      logger/* default.debug */.Z.debug("DDB Data to parse:", foundry.utils.duplicate(this.source.ddb));
      logger/* default.debug */.Z.debug("currentActorId", this.currentActorId);
      try {
        // this parses the json and sets the results as this.data
        await this._parseCharacter();
        logger/* default.debug */.Z.debug("finalParsedData", foundry.utils.duplicate({ source: this.source, data: foundry.utils.deepClone(this.data) }));
      } catch (error) {
        if (game.settings.get("ddb-importer", "debug-json")) {
          FileHelper/* default.download */.Z.download(JSON.stringify(this.source), `${this.characterId}-raw.json`, "application/json");
        }
        throw error;
      }
    } catch (error) {
      logger/* default.error */.Z.error("JSON Fetch and Parse Error");
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error(error.stack);
      throw error;
    }
  }

  /**
   * Removes duplicate features/actions based on import preferences
   */
  _filterActionFeatures() {
    const actionAndFeature = game.settings.get("ddb-importer", "character-update-policy-use-action-and-feature");

    this.data.actions = this.raw.actions.map((action) => {
      const featureMatch = this.raw.features.find((feature) => feature.name === action.name
        && foundry.utils.getProperty(feature, "flags.ddbimporter.type") === foundry.utils.getProperty(action, "flags.ddbimporter.type"));
      if (featureMatch) {
        // console.warn(`Removing duplicate feature ${featureMatch.name} from action ${action.name}`, {
        //   action,
        //   feature: featureMatch,
        // });
        if (action.system.description.value === "") {
          action.system.description.value = featureMatch.system.description.value;
        }

        if (action.system.description.chat === "") {
          action.system.description.chat = featureMatch.system.description.chat;
        }

        if (action.effects && action.effects.length === 0
          && featureMatch.effects && featureMatch.effects.length > 0
        ) {

          action.effects = featureMatch.effects;
          const newFlags = foundry.utils.duplicate(featureMatch.flags);

          delete newFlags.ddbimporter;
          foundry.utils.mergeObject(action.flags, newFlags, { overwrite: true, insertKeys: true, insertValues: true });
        }
      }
      return action;
    });

    this.data.features = this.raw.features
      .filter((feature) =>
        actionAndFeature
        || !this.data.actions.some((action) =>
          action.name.trim().toLowerCase() === feature.name.trim().toLowerCase()
          && foundry.utils.getProperty(action, "flags.ddbimporter.isCustomAction") !== true
          && foundry.utils.getProperty(feature, "flags.ddbimporter.type") === foundry.utils.getProperty(action, "flags.ddbimporter.type")
        )
      )
      .map((feature) => {
        const actionMatch = actionAndFeature && this.data.actions.some((action) => feature.name === action.name);
        if (actionMatch) feature.effects = [];
        return feature;
      });

  }

  /**
   * Parses the collected Character JSON data into various foundry features.
   * Additional steps are needed after this based on the settings in the character import, but this will give the "raw" items
   *
   * @returns Object containing various parsed Foundry features
   *
   */
  async _parseCharacter() {
    try {
      // prefetch compendium indexes for lookups
      await this.itemCompendium.getIndex();
      await this.spellCompendium.getIndex();

      if (game.settings.get("ddb-importer", "character-update-policy-add-spell-effects")) await DDBMacros/* default.createWorldMacros */.Z.createWorldMacros();
      logger/* default.debug */.Z.debug("Starting core character parse", { thisDDB: this.source.ddb });
      await this._generateCharacter();
      if (this.selectResources) {
        logger/* default.debug */.Z.debug("Character resources");
        await this.resourceSelectionDialog();
      }

      logger/* default.debug */.Z.debug("Character parse complete");
      await this._generateRace();
      logger/* default.debug */.Z.debug("Race parse complete");
      this._classParser = new CharacterClassFactory(this);
      this.raw.classes = await this._classParser.processCharacter();
      logger/* default.debug */.Z.debug("Classes parse complete");
      this._characterFeatureFactory = new CharacterFeatureFactory(this);
      await this._characterFeatureFactory.processFeatures();
      this.raw.features = this._characterFeatureFactory.processed.features;
      logger/* default.debug */.Z.debug("Feature parse complete");
      logger/* default.debug */.Z.debug("Parsing infusions");
      this._infusionFactory = new DDBInfusionFactory(this);
      await this._infusionFactory.processInfusions();
      this.raw.features.push(...this._infusionFactory.processed.infusions);
      logger/* default.debug */.Z.debug("Infusion parse complete");
      this._spellParser = new CharacterSpellFactory(this);
      this.raw.spells = await this._spellParser.getCharacterSpells();
      logger/* default.debug */.Z.debug("Character Spells parse complete");
      await this._characterFeatureFactory.processActions();
      this.raw.actions = this._characterFeatureFactory.processed.actions;
      logger/* default.debug */.Z.debug("Action parse complete");
      await this._generateInventory();
      logger/* default.debug */.Z.debug("Inventory generation complete");

      this.data = foundry.utils.deepClone({
        character: this.raw.character,
        features: this.raw.features,
        race: this.raw.race,
        classes: this.raw.classes,
        inventory: this.raw.inventory,
        spells: this.raw.spells,
        actions: this.raw.actions,
        itemSpells: this.raw.itemSpells,
      });

      this._filterActionFeatures();

      this._classParser.linkFeatures();
      this._ddbRace.linkFeatures(this);
      this._characterFeatureFactory.linkFeatures();

      // this adds extras like a Divine Smite spell to this.data
      this._addSpecialAdditions();

      // find supported companion blocks
      if (this.enableCompanions && game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "character-update-policy-create-companions")) {
        await this.generateCompanions();
      }

      this._addVision5eEffects();
      this._linkItemsToContainers();

    } catch (error) {
      logger/* default.error */.Z.error(error);
      logger/* default.error */.Z.error("Error during parse:", error.message);
      throw (error);
    }
  }

  getDataFeature(featureName, { featureTypes = ["actions", "features"], hints = [] } = {}) {
    for (const featureType of featureTypes) {
      const index = this.data[featureType].findIndex((f) => {
        const isCustomAction = f.flags.ddbimporter?.isCustomAction ?? false;
        if (isCustomAction) return false;
        const name = f.flags.ddbimporter?.originalName ?? f.name;
        for (const hint of hints) {
          if (utils/* default.nameString */.Z.nameString(`${name} (${hint})`) === utils/* default.nameString */.Z.nameString(featureName)) return true;
        }
        return utils/* default.nameString */.Z.nameString(name) === utils/* default.nameString */.Z.nameString(featureName);
      });
      if (index !== -1) {
        logger/* default.debug */.Z.debug(`Found ${featureType} : ${featureName}`);
        return this.data[featureType][index];
      }
    }
    return undefined;
  }

  async disableDynamicUpdates() {
    this.currentActor.flags.ddbimporter.activeUpdate = false;
    const activeUpdateData = { flags: { ddbimporter: { activeUpdate: false } } };
    await this.currentActor.update(activeUpdateData);
  }

  async enableDynamicUpdates() {
    this.currentActor.flags.ddbimporter.activeUpdate = true;
    const activeUpdateData = { flags: { ddbimporter: { activeUpdate: true } } };
    await this.currentActor.update(activeUpdateData);
  }

  async updateDynamicUpdates(state) {
    this.currentActor.flags.ddbimporter.activeUpdate = state;
    const activeUpdateData = { flags: { ddbimporter: { activeUpdate: state } } };
    await this.currentActor.update(activeUpdateData);
  }

  getCurrentDynamicUpdateState() {
    const activeUpdateState = this.currentActor.flags?.ddbimporter?.activeUpdate
      ? this.currentActor.flags.ddbimporter.activeUpdate
      : false;
    return activeUpdateState;
  }

  async setActiveSyncSpellsFlag(state) {
    this.currentActor.flags.ddbimporter.activeSyncSpells = state;
    const activeUpdateData = { flags: { ddbimporter: { activeSyncSpells: state } } };
    await this.currentActor.update(activeUpdateData);
  }

  _addVision5eEffects() {
    this.data.inventory = (0,vision5e/* addVision5eStubs */.j)(this.data.inventory);
    this.data.spells = (0,vision5e/* addVision5eStubs */.j)(this.data.spells);
    this.data.features = (0,vision5e/* addVision5eStubs */.j)(this.data.features);
    this.data.actions = (0,vision5e/* addVision5eStubs */.j)(this.data.actions);
  }

  isMartialArtist() {
    return this.source.ddb.character.classes.some((cls) =>
      cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts")
    );
  }

  updateItemIds(items) {
    if (!this.currentActor) return items;
    const possibleFeatures = this.currentActor.getEmbeddedCollection("Item");
    const matchedFeatures = [];
    items.forEach((item) => {
      const itemMatch = DDBHelper/* default.findMatchedDDBItem */.Z.findMatchedDDBItem(item, possibleFeatures, matchedFeatures);
      if (itemMatch) {
        item._id = itemMatch._id;
        matchedFeatures.push(itemMatch);
      }
    });
    return items;
  }

  _linkItemsToContainers() {
    const containerItems = this.data.inventory
      .filter((item) =>
        item.type === "container"
        && foundry.utils.hasProperty(item, "flags.ddbimporter.id")
        && foundry.utils.hasProperty(item, "flags.ddbimporter.containerEntityId")
        && parseInt(item.flags.ddbimporter.containerEntityId) === parseInt(this.source.ddb.character.id)
        && !foundry.utils.getProperty(item, "flags.ddbimporter.ignoreItemImport")
      );

    this.data.inventory.forEach((item) => {
      if (foundry.utils.hasProperty(item, "flags.ddbimporter.containerEntityId")
        && parseInt(item.flags.ddbimporter.containerEntityId) !== parseInt(this.source.ddb.character.id)
      ) {
        const containerItem = containerItems.find((container) =>
          parseInt(container.flags.ddbimporter.id) === parseInt(item.flags.ddbimporter.containerEntityId)
        );
        if (containerItem) {
          foundry.utils.setProperty(item, "system.container", containerItem._id);
        }
      }
    });
  }

}


/***/ }),

/***/ 3671:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": () => (/* binding */ generateCharacterExtras)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4029);
/* harmony import */ var _monster_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5371);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6451);
/* harmony import */ var _companions_DDBCompanionFactory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3972);
/* harmony import */ var _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7407);








function getCustomValue(ddbCharacter, typeId, valueId, valueTypeId) {
  const characterValues = ddbCharacter.characterValues;
  const customValue = characterValues.find(
    (value) => value.valueId == valueId && value.valueTypeId == valueTypeId && value.typeId == typeId
  );

  if (customValue) {
    return customValue.value;
  }
  return null;
}

function generateBeastCompanionEffects(extra, characterProficiencyBonus) {
  // beast master get to add proficiency bonus to current attacks, damage, ac
  // and saving throws and skills it is proficient in.
  // extra.system.details.cr = actor.system.flags.ddbimporter.dndbeyond.totalLevels;

  let effect = {
    changes: [
      {
        key: "data.bonuses.rwak.attack",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.rwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.attack",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: `+${characterProficiencyBonus}`,
        priority: 20,
      },
    ],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    tint: "",
    disabled: false,
    selectedKey: [],
  };
  effect.name = "Beast Companion Effects";
  _dictionary_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].character.abilities.filter */ .Z.character.abilities.filter((ability) => extra.system.abilities[ability.value].proficient >= 1).forEach((ability) => {
    const boost = {
      key: `data.abilities.${ability.value}.save`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: characterProficiencyBonus,
      priority: 20,
    };
    effect.selectedKey.push(`data.abilities.${ability.value}.save`);
    effect.changes.push(boost);
  });
  _dictionary_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].character.skills.filter */ .Z.character.skills.filter((skill) => extra.system.skills[skill.name].prof >= 1).forEach((skill) => {
    const boost = {
      key: `data.skills.${skill.name}.mod`,
      mode: CONST.ACTIVE_EFFECT_MODES.ADD,
      value: characterProficiencyBonus,
      priority: 20,
    };
    effect.selectedKey.push(`data.skills.${skill.name}.mod`);
    effect.changes.push(boost);
  });
  extra.effects = [effect];
  return extra;
}

function generateArtificerDamageEffect(actor, extra) {
  // artificer uses the actors spell attack bonus, so is a bit trickier
  // we remove damage bonus later, and will also have to calculate additional attack bonus for each attack
  extra.system.details.cr = actor.flags.ddbimporter.dndbeyond.totalLevels;

  let effect = {
    changes: [
      {
        key: "data.bonuses.rwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "+ @prof",
        priority: 20,
      },
      {
        key: "data.bonuses.mwak.damage",
        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,
        value: "+ @prof",
        priority: 20,
      },
    ],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    tint: "",
    disabled: false,
    selectedKey: [],
  };
  effect.name = "Artificer Extra Effects";
  extra.effects = [effect];
  return extra;
}

const creatureGroupMatrix = [
  {
    id: 1,
    name: "Wildshape",
    animation: "fourelements",
  },
  {
    id: 2,
    name: "Familiar",
    animation: "magic1",
  },
  {
    id: 3,
    name: "Beast Companion",
    animation: "fourelements",
  },
  {
    id: 4,
    name: "Mount",
    animation: "heart",
  },
  {
    id: 5,
    name: "Pet",
    animation: "heart",
  },
  {
    id: 6,
    name: "Summoned",
    animation: "magic1",
  },
  {
    id: 7,
    name: "Misc",
    animation: "magic1",
  },
  {
    id: 10,
    name: "Battle Smith Defender",
    animation: "energy1",
  },
  {
    id: 11,
    name: "Sidekick",
    animation: "energy1",
  },
  {
    id: 12,
    name: "Infusion",
    animation: "energy1",
  },
];

function getCreatureAnimationType(name, creatureGroup) {
  // "fire":
  // "air":
  // "lightning":
  // "water":
  // "energy1":
  // "magic1":
  // "heart":
  // "music":
  // "fourelements":
  const checkName = name.toLowerCase();
  let animation = "magic1";
  switch (name) {
    case checkName.includes("flame"):
    case checkName.includes("fire"):
      animation = "fire";
      break;
    case checkName.includes("air"):
    case checkName.includes("wind"):
      animation = "air";
      break;
    case checkName.includes("lightning"):
    case checkName.includes("thunder"):
      animation = "lightning";
      break;
    case checkName.includes("water"):
    case checkName.includes("aqua"):
      animation = "water";
      break;
    case checkName.includes("energy"):
    case checkName.includes("construct"):
      animation = "energy1";
      break;
    case checkName.includes("magic"):
    case checkName.includes("arcane"):
      animation = "magic1";
      break;
    default: {
      const match = creatureGroupMatrix.find((group) => group.id === creatureGroup.id);
      if (match) {
        animation = match.animation;
      }
    }
  }

  return animation;
}

function setExtraMunchDefaults() {
  let munchSettings = [];

  _settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MUNCH_DEFAULTS.forEach */ .Z.MUNCH_DEFAULTS.forEach((setting) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Loading extras munch settings ${setting.name}`);
    setting["chosen"] = game.settings.get("ddb-importer", setting.name);
    munchSettings.push(setting);
  });

  munchSettings.forEach((setting) => {
    game.settings.set("ddb-importer", setting.name, setting.needed);
  });

  return munchSettings;

}

function revertExtraMunchDefaults(munchSettings) {
  munchSettings.forEach((setting) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Returning ${setting.name} to ${setting.chosen}`);
    game.settings.set("ddb-importer", setting.name, setting.chosen);
  });
}

function addOwnerSkillProficiencies(ddbCharacter, mock) {
  let newSkills = [];
  const proficiencyBonus = CONFIG.DDB.challengeRatings.find(
    (cr) => cr.id == mock.challengeRatingId
  ).proficiencyBonus;

  _dictionary_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].character.skills.forEach */ .Z.character.skills.forEach((skill) => {
    const existingSkill = mock.skills.find((mockSkill) => skill.valueId === mockSkill.skillId);
    const characterProficient = ddbCharacter.data.character.system.skills[skill.name].value;
    const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ab) => ab.value === skill.ability);
    const stat = mock.stats.find((stat) => stat.statId === ability.id).value || 10;
    const mod = CONFIG.DDB.statModifiers.find((s) => s.value == stat).modifier;

    if (existingSkill && characterProficient === 2) {
      const doubleProf = proficiencyBonus * 2;
      newSkills.push({
        skillId: skill.valueId,
        value: mod + doubleProf,
        additionalBonus: null,
      });
    } else if (existingSkill) {
      newSkills.push(existingSkill);
    } else if (characterProficient === 1) {
      newSkills.push({
        skillId: skill.valueId,
        value: mod + proficiencyBonus,
        additionalBonus: null,
      });
    }
  });
  mock.skills = newSkills;

  return mock;
}

function addOwnerSaveProficiencies(ddbCharacter, mock) {
// add owner save profs
  let newSaves = [];
  _dictionary_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].character.abilities.forEach */ .Z.character.abilities.forEach((ability) => {
    const existingProficient = mock.savingThrows.find((stat) => stat.statId === ability.id) ? 1 : 0;
    const characterProficient = ddbCharacter.abilities.withEffects[ability.value].proficient;

    if (existingProficient || characterProficient) {
      const bonus = {
        bonusModifier: null,
        statId: ability.id,
      };
      newSaves.push(bonus);
    }
  });
  mock.savingThrows = newSaves;
  return mock;
}

function addAverageHitPoints(ddbCharacterData, actor, creature, mock) {
  // hp
  const hpMaxChange = getCustomValue(ddbCharacterData, 43, creature.id, creature.entityTypeId);
  if (hpMaxChange) mock.averageHitPoints = hpMaxChange;

  // assume this is beast master
  if (mock.creatureFlags.includes("HPLM")) {
    const ranger = ddbCharacterData.classes.find((klass) => klass.definition.id === 5);
    const level = ranger ? ranger.level : 0;
    mock.averageHitPoints = Math.max(mock.averageHitPoints, 4 * level);
  }

  // homunculus servant
  // Max Hit Points Base Artificer Level
  if (mock.creatureFlags.includes("MHPBAL")) {
    const artificer = ddbCharacterData.classes.find((klass) => klass.definition.name === "Artificer");
    if (artificer) {
      mock.averageHitPoints = parseInt(artificer.level);
      foundry.utils.setProperty(mock, "hitPointDice.diceCount", artificer.level);
      foundry.utils.setProperty(mock, "hitPointDice.diceString", `${artificer.level}d${mock.hitPointDice.diceValue}`);
    }
  }

  if (mock.creatureFlags.includes("AHM")) {
    const artificer = ddbCharacterData.classes.find((klass) => klass.definition.name === "Artificer");
    if (artificer) {
      mock.averageHitPoints = parseInt(5 * artificer.level);
    }
  }

  // Max Hit Points Add Int Modifier
  if (mock.creatureFlags.includes("MHPAIM")) {
    mock.averageHitPoints += parseInt(actor.system.abilities.int.mod);
  }

  // Max Hit Points Add Monster CON Modifier
  if (mock.creatureFlags.includes("MHPAMCM")) {
    const monsterConModifier = (0,_monster_helpers_js__WEBPACK_IMPORTED_MODULE_2__/* .getAbilityMods */ .T)(mock, CONFIG.DDB);
    mock.averageHitPoints += parseInt(monsterConModifier.con);
  }

  return mock;
}

function addCreatureStats(mock, actor) {
  const creatureStats = mock.stats.filter((stat) => !mock.creatureGroup.ownerStats.includes(stat.statId));
  const characterStats = mock.stats
    .filter((stat) => mock.creatureGroup.ownerStats.includes(stat.statId))
    .map((stat) => {
      const value = actor.system.abilities[_dictionary_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].character.abilities.find */ .Z.character.abilities.find((a) => a.id === stat.statId).value].value;
      return { name: null, statId: stat.statId, value: value };
    });

  mock.stats = creatureStats.concat(characterStats);
  return mock;
}

function addCreatureFlags(creature, mock) {
  const creatureGroup = CONFIG.DDB.creatureGroups.find((group) => group.id == creature.groupId);
  let creatureFlags = creatureGroup.flags;

  if (creature.definition.name === "Homunculus Servant") {
    // Max Hit Points Add Monster CON Modifier
    // Max Hit Points Add Int Modifier
    // Max Hit Points Base Artificer Level
    // Attack Rolls Add Proficiency Bonus
    // Proficient Skills Add Proficiency Bonus
    creatureFlags = creatureFlags.concat(["MHPAMCM", "MHPAIM", "MHPBAL", "ARPB", "PSPB"]);
  }
  mock.creatureFlags = creatureFlags;
  mock.creatureGroupId = creature.groupId;
  mock.creatureGroup = creatureGroup;

  return mock;

}

function transformExtraToMonsterData(ddbCharacter, actor, creature) {
  let ddbCharacterData = ddbCharacter.source.ddb.character;
  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Extra data", creature);
  let mock = foundry.utils.duplicate(creature.definition);
  mock.id = creature.id;
  mock.entityTypeId = creature.entityTypeId;
  mock = addCreatureFlags(creature, mock);

  if (creature.name) mock.name = creature.name;

  // creature group
  mock.automatedEvcoationAnimation = getCreatureAnimationType(mock.name, mock.creatureGroup);

  // size
  const sizeChange = getCustomValue(ddbCharacterData, 46, creature.id, creature.entityTypeId);
  if (sizeChange) mock.sizeId = sizeChange;

  // hp
  mock = addAverageHitPoints(ddbCharacterData, actor, creature, mock);
  mock.removedHitPoints = creature.removedHitPoints;
  mock.temporaryHitPoints = creature.temporaryHitPoints;

  // creature type
  const typeChange = getCustomValue(ddbCharacterData, 44, creature.id, creature.entityTypeId);
  if (typeChange) mock.typeId = typeChange;

  // ac
  const acChange = getCustomValue(ddbCharacterData, 42, creature.id, creature.entityTypeId);
  if (acChange) mock.armorClass = acChange;

  // alignment
  const alignmentChange = getCustomValue(ddbCharacterData, 45, creature.id, creature.entityTypeId);
  if (alignmentChange) mock.alignmentId = alignmentChange;

  // notes
  const extraNotes = getCustomValue(ddbCharacterData, 47, creature.id, creature.entityTypeId);
  if (extraNotes) mock.characteristicsDescription += `\n\n${extraNotes}`;

  // stats
  mock = addCreatureStats(mock, actor);

  // ownership the same as actor
  mock.ownership = actor.ownership;

  if (mock.creatureGroup.description !== "") {
    mock.characteristicsDescription = `${mock.creatureGroup.description}\n\n${mock.characteristicsDescription}`;
  }

  if (mock.creatureGroup.specialQualityTitle) {
    mock.specialTraitsDescription = `${mock.specialTraitsDescription} <p><em><strong>${mock.creatureGroup.specialQualityTitle}.</strong></em> ${mock.creatureGroup.specialQualityText}</p>`;
  }

  // Armor Add Proficiency Bonus
  if (mock.creatureFlags.includes("ACPB")) {
    mock.armorClass += actor.system.attributes.prof;
  }

  // Evaluate Owner Skill Proficiencies
  if (mock.creatureFlags.includes("EOSKP")) {
    mock = addOwnerSkillProficiencies(ddbCharacter, mock);
  }

  // Evaluate Owner Save Proficiencies
  if (mock.creatureFlags.includes("EOSVP")) {
    mock = addOwnerSaveProficiencies(ddbCharacter, mock);
  }

  // Cannot Use Legendary Actions
  if (mock.creatureFlags.includes("CULGA")) {
    mock.isLegendary = false;
    mock.legendaryActionsDescription = "";
  }

  // Cannot Use Lair Actions
  if (mock.creatureFlags.includes("CULRA")) {
    mock.hasLair = false;
    mock.lairDescription = "";
  }

  _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("mock creature", mock);
  return mock;

}

function enhanceParsedExtra(actor, extra) {
  const damageDiceExpression = /(\d*d\d+\s*\+*\s*)+/;
  const characterProficiencyBonus = actor.system.attributes.prof;
  const artificerBonusGroup = [10, 12];

  if (
    extra.flags?.ddbimporter?.creatureFlags?.includes("ARPB") // Attack Rolls Add Proficiency Bonus
    && extra.flags?.ddbimporter?.creatureFlags?.includes("PSPB") // Proficient Skills Add Proficiency Bonus
  ) {
    if (extra.flags?.ddbimporter?.creatureGroupId === 3) {
      extra = generateBeastCompanionEffects(extra, characterProficiencyBonus);
    } else if (artificerBonusGroup.includes(extra.flags?.ddbimporter?.creatureGroupId)) {
      // artificer uses the actors spell attack bonus, so is a bit trickier
      // we remove damage bonus later, and will also have to calculate additional attack bonus for each attack
      extra = generateArtificerDamageEffect(actor, extra, characterProficiencyBonus);
    } else {
      // who knows!
      extra.system.details.cr = actor.flags.ddbimporter.dndbeyond.totalLevels;
    }
  }

  if (
    // Damage Rolls Add Proficiency Bonus
    (extra.flags?.ddbimporter?.creatureFlags?.includes("DRPB") && extra.flags?.ddbimporter?.creatureGroupId !== 3)
    // is this a artificer infusion? the infusion call actually adds this creature group, but we don't fetch that yet.
    || extra.flags?.ddbimporter?.creatureGroupId === 12
  ) {
    extra.items = extra.items.map((item) => {
      if (item.type === "weapon") {
        let characterAbility;

        item.system.damage.parts = item.system.damage.parts.map((part) => {
          const match = part[0].match(damageDiceExpression);
          if (match) {
            let dice = match[0];
            // the artificer creatures have the initial prof built in, lets replace it
            if (artificerBonusGroup.includes(extra.flags?.ddbimporter?.creatureGroupId)) {
              characterAbility = "int";
              dice = match[1].trim().endsWith("+") ? match[1].trim().slice(0, -1) : match[1];
            }
            part[0] = `${dice.trim()}`;
          }

          return part;
        });

        if (characterAbility) {
          const ability = item.system.ability;
          const mod = parseInt(extra.system.abilities[ability].mod);
          const characterMod = parseInt(actor.system.abilities[characterAbility].mod);
          // eslint-disable-next-line no-eval
          const globalMod = parseInt(eval(actor.system.bonuses.rsak.attack || 0));
          item.system.attack.bonus = characterMod + globalMod - mod;
        }
      }
      return item;
    });
  }

  return extra;
}

async function generateCharacterExtras(html, ddbCharacter, actor) {
  const munchSettings = setExtraMunchDefaults();

  try {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("ddbCharacter", ddbCharacter);
    if (ddbCharacter.source.ddb.character.creatures.length === 0) return;

    const folder = await _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getOrCreateFolder */ .Z.getOrCreateFolder(actor.folder, "Actor", `[Extras] ${actor.name}`);

    const extractedCreatures = ddbCharacter.source.ddb.character.creatures
      .map((creature) => transformExtraToMonsterData(ddbCharacter, actor, creature))
      .map((creature) => {
        creature.folder = folder.id;
        return creature;
      });

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Extracted creatures", foundry.utils.duplicate(extractedCreatures));
    const monsterFactory = new _DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z({ ddbData: extractedCreatures, extra: true });
    const parsedExtras = await monsterFactory.parse();
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Parsed Extras:", foundry.utils.duplicate(parsedExtras.actors));

    const enhancedExtras = parsedExtras.actors.map((extra) => enhanceParsedExtra(actor, extra));
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Enhanced Parsed Extras:", foundry.utils.duplicate(enhancedExtras));

    const ddbCompanionFactory = new _companions_DDBCompanionFactory_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("", { actor, data: enhancedExtras, noCompendiums: true });
    await ddbCompanionFactory.init();
    await ddbCompanionFactory.updateOrCreateCompanions({ folderOverride: folder });

  } catch (err) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Failure parsing extra", err);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(err.stack);
  } finally {
    revertExtraMunchDefaults(munchSettings);
  }
}


/***/ }),

/***/ 3433:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ DDBMonster)
});

// EXTERNAL MODULE: ./src/parser/monster/templates/monster.js
var monster = __webpack_require__(1309);
;// CONCATENATED MODULE: ./src/parser/monster/special.js
// these are non-compliant monsters that currently don't meet parsing requirements
// these are temporary work arounds till parsing is fixed.
function specialCases(monster) {
  switch (monster.name) {
    case "Reduced-threat Aboleth":
    case "Aboleth": {
      monster.items.forEach(function (item, index) {
        if (item.name === "Tentacle") {
          this[index].system.formula = item.system.damage.parts[1][0];
          this[index].system.damage.parts.splice(1, 1);
        }
      }, monster.items);
      break;
    }
    case "Clay Golem": {
      monster.items.forEach(function (item, index) {
        if (item.name.startsWith("Haste")) {
          this[index].system.activation.type = "action";
        }
      }, monster.items);
      break;
    }
    case "Dullahan": {
      monster.items.forEach(function (item, index) {
        if (item.name === "Battleaxe") {
          this[index].system.damage.versatile += " + 2d10[necrotic]";
          this[index].system.damage.parts.push(["2d10[necrotic]", "necrotic"]);
        } else if (item.name === "Coordinated Assault") {
          this[index].system.activation.type = "legendary";
          this[index].system.consume = {
            type: "attribute",
            target: "resources.legact.value",
            amount: 1,
          };
          this[index].system.activation.cost = 1;
        } else if (item.name.startsWith("Headless Wail")) {
          this[index].system.activation.cost = 2;
          this[index].system.activation.type = "legendary";
          this[index].system.consume = {
            type: "attribute",
            target: "resources.legact.value",
            amount: 2,
          };
        }
      }, monster.items);
      break;
    }
    case "Duergar Warlord": {
      monster.items.forEach(function (item, index) {
        if (item.name === "Psychic-Attuned Hammer") {
          this[index].system.damage.parts.push(["1d10[psychic]", "psychic"]);
        }
      }, monster.items);
      break;
    }
    case "Autumn Eladrin (Legacy)":
    case "Autumn Eladrin": {
      monster.items.forEach(function (item, index) {
        if (item.name.startsWith("Cure Wounds")) {
          this[index].system.damage.parts[0][0] = "5d8[healing] + @mod";
        }
      }, monster.items);
      break;
    }
    // flumph tendrils have weird syntax for damage over time.
    case "Flumph": {
      monster.items.forEach(function (item, index) {
        if (item.name === "Tendrils") {
          if (item.system.damage.parts.length > 2) {
            this[index].system.formula = item.system.damage.parts[2][0];
            this[index].system.damage.parts.splice(2, 1);
          }
          this[index].system.save.ability = "";
        }
      }, monster.items);
      break;
    }
    case "Living Blade of Disaster": {
      monster.items.forEach(function (item, index) {
        if (item.name === "Force Blade") {
          this[index].system.critical.threshold = 18;
          this[index].system.critical.damage = "8d12";
          this[index].system.damage.parts.splice(1, 1);

        } else if (item.name === "Preemptive Strike" && game.modules.get("midi-qol")?.active) {
          this[index].system.activation.type = "reactionmanual";
        }
      }, monster.items);
      break;
    }
    case "Nilbog (Legacy)":
    case "Nilbog": {
      monster.items.forEach(function (item, index) {
        if (item.name === "Reversal of Fortune") {
          this[index].system.actionType = "heal";
        }
      }, monster.items);
      break;
    }
    case "Nosferatu": {
      monster.items.forEach(function (item, index) {
        if (item.name === "Bite") {
          this[index].system.damage.versatile = `${item.system.damage.parts[0][0]} + ${item.system.damage.parts[2][0]}`;
          this[index].system.damage.parts.splice(2, 1);
        }
      }, monster.items);
      break;
    }
    // no default
  }

  switch (monster.system.details.type.value) {
    case "dragon": {
      monster.items.forEach(function (item, index) {
        if (item.name === "Frightful Presence") {
          this[index].system.duration = {
            value: "1",
            units: "minute",
          };
          this[index].system.range.value = 120;
          this[index].system.range.units = "self";
          this[index].system.target = {
            value: 120,
            width: null,
            units: "",
            type: "enemy",
          };
        }
      }, monster.items);
      break;
    }
    // no default
  }

  monster.items.forEach(function (item, index) {
    if (item.name.startsWith("Sneak Attack")) {
      this[index].system.uses = {
        "value": null,
        "max": "",
        "per": null,
        "recovery": ""
      };
    } else if (item.name.startsWith("Soothing Word")) {
      this[index].system.target = {
        value: 1,
        width: null,
        units: "",
        type: "creature",
      };
    }
  }, monster.items);

  const magicWeapons = monster.items.some((item) => item.name === "Magic Weapons");
  if (magicWeapons) {
    monster.items.forEach(function (item, index) {
      if (item.type === "weapon") {
        this[index].system.properties.mgc = true;
      }
    }, monster.items);
  }

  return monster;
}

// EXTERNAL MODULE: ./src/effects/specialMonsters.js + 17 modules
var specialMonsters = __webpack_require__(6934);
// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
// EXTERNAL MODULE: ./src/parser/monster/features/DDBMonsterFeatureFactory.js
var DDBMonsterFeatureFactory = __webpack_require__(2676);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
// EXTERNAL MODULE: ./src/lib/PatreonHelper.js
var PatreonHelper = __webpack_require__(8636);
// EXTERNAL MODULE: ./src/effects/vision5e.js
var vision5e = __webpack_require__(5042);
// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/effects/external/ExternalAutomations.js
var ExternalAutomations = __webpack_require__(767);
;// CONCATENATED MODULE: ./src/parser/DDBMonster.js



















class DDBMonster {

  setProperty(name, value) {
    if (this.overrides["name"]) {
      this[name] = this.overrides["name"];
    } else {
      this[name] = value;
    }
  }

  constructor(ddbObject = null, { existingNpc = null, extra = false, useItemAC = true,
    legacyName = true, addMonsterEffects = false, addChrisPremades = false } = {}, overrides = {}
  ) {
    this.source = ddbObject;

    // processing options
    this.extra = extra;
    this.npc = existingNpc;
    this.useItemAC = useItemAC;
    this.legacyName = legacyName;
    this.addMonsterEffects = addMonsterEffects;
    this.addChrisPremades = addChrisPremades;

    // some of this data can be overwritten, useful for mangling new actions
    this.overrides = overrides;

    // used by extra processing
    this.removedHitPoints = this.setProperty("removedHitPoints", (this.source?.removedHitPoints ?? 0));
    this.temporaryHitPoints = this.setProperty("temporaryHitPoints", (this.source?.temporaryHitPoints ?? 0));

    this.characterDescription = "";
    this.unexpectedDescription = null;

    // processing info
    this.name = overrides["name"] ?? (existingNpc ? existingNpc.name : null);
    this.abilities = null;
    this.proficiencyBonus = null;
    this.cr = 0;
    this.typeName = "";
    this.items = [];
    this.img = null;
    if (existingNpc) {
      this.proficiencyBonus = this.setProperty("proficiencyBonus", existingNpc.system.attributes.prof);
      this.cr = this.setProperty("cr", existingNpc.system.details.cr);
      this.abilities = this.setProperty("abilities", existingNpc.system.abilities);
      this.items = foundry.utils.duplicate(existingNpc.items);
      this.img = existingNpc.img;
    }
    this.stockImage = false;

    this.featureFactory = new DDBMonsterFeatureFactory/* default */.Z({ ddbMonster: this });
  }

  static STOCK_TYPE_IMAGES = [
    "https://www.dndbeyond.com/avatars/4675/664/636747837303835953.jpeg",
    "https://www.dndbeyond.com/avatars/4675/665/636747837392078487.jpeg",
    "https://www.dndbeyond.com/avatars/4675/666/636747837434463638.jpeg",
    "https://www.dndbeyond.com/avatars/4675/667/636747837482013331.jpeg",
    "https://www.dndbeyond.com/avatars/4675/668/636747837521115242.jpeg",
    "https://www.dndbeyond.com/avatars/4675/669/636747837569942785.jpeg",
    "https://www.dndbeyond.com/avatars/4675/671/636747837638112910.jpeg",
    "https://www.dndbeyond.com/avatars/4675/672/636747837699453839.jpeg",
    "https://www.dndbeyond.com/avatars/4675/674/636747837751071918.jpeg",
    "https://www.dndbeyond.com/avatars/4675/675/636747837794884984.jpeg",
    "https://www.dndbeyond.com/avatars/4675/676/636747837839875603.jpeg",
    "https://www.dndbeyond.com/avatars/4675/678/636747837893364274.jpeg",
    "https://www.dndbeyond.com/avatars/4675/679/636747837952193011.jpeg",
    "https://www.dndbeyond.com/avatars/4675/680/636747837998336262.jpeg",
  ];

  _calculateImage() {
    if (this.source) {
      this.img = (this.source.basicAvatarUrl) ? this.source.basicAvatarUrl : this.source.largeAvatarUrl;
      // foundry doesn't support gifs
      if (this.img && this.img.match(/.gif$/)) {
        this.img = null;
      }
      if (DDBMonster.STOCK_TYPE_IMAGES.includes(this.source.avatarUrl)) {
        this.stockImage = true;
      }
    } else {
      this.img = null;
    }
  }

  _generateFlags() {
    this.npc.flags.monsterMunch = {
      url: this.source.url,
      img: (this.img) ? this.img : this.source.avatarUrl,
      tokenImg: this.source.avatarUrl,
      isStockImg: DDBMonster.STOCK_TYPE_IMAGES.includes(this.source.avatarUrl),
    };
    this.npc.flags.ddbimporter = {
      id: this.source.id,
      entityTypeId: this.source.entityTypeId,
      // creatureGroup: monster.creatureGroup ? monster.creatureGroup : null,
      creatureGroupId: this.source.creatureGroupId ? this.source.creatureGroupId : null,
      creatureFlags: this.source.creatureFlags ? this.source.creatureFlags : [],
      automatedEvcoationAnimation: this.source.automatedEvcoationAnimation ? this.source.automatedEvcoationAnimation : undefined,
      version: CONFIG.DDBI.version,
      isLegacy: this.source.isLegacy,
    };
  }


  async fetchMonsterSourceFromDDB(id) {
    if (!id && Number.isInteger(id) && Number.isInteger(Number.parseInt(id))) {
      throw new Error("Please provide a monster ID (number) to fetch");
    }
    const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
    const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
    const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();

    const body = {
      cobalt: cobaltCookie,
      betaKey: betaKey,
      ids: [Number.parseInt(id)],
    };

    const debugJson = game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/proxy/monsters/ids`, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            logger/* default.error */.Z.error(`API Failure:`, data.message);
            reject(data.message);
          }
          if (debugJson) {
            FileHelper/* default.download */.Z.download(JSON.stringify(data), `monsters-raw.json`, "application/json");
          }
          return data;
        })
        .then((data) => {
          logger/* default.info */.Z.info(`Retrieved monster`, { monster: data.data });
          this.source = data.data[0];
          return data.data[0];
        })
        .catch((error) => reject(error));
    });
  }

  _generateTaggerFlags() {
    // if (!CONFIG.DDBI.tagger) return;
    const tags = [
      "dndbeyond",
      "ddb-importer",
    ];

    const type = this.npc.system.details.type.value;
    const customType = this.npc.system.details.type.custom;
    const subType = this.npc.system.details.type.custom;
    for (const tagElement of [type, customType, subType]) {
      if (utils/* default.isString */.Z.isString(tagElement) && tagElement.trim() !== "") {
        tags.push(tagElement);
      }
    }

    foundry.utils.setProperty(this.npc.prototypeToken, "flags.tagger.tags", tags);
  }

  _generate3DModels() {
    if (!game.canvas3D?.CONFIG?.UI?.TokenBrowser) return;
    const matches = game.canvas3D.CONFIG.UI.TokenBrowser.findByName(this.name.replace("(Legacy)", "").trim());
    if (matches && matches.length > 0) {
      foundry.utils.setProperty(this.npc.prototypeToken, "flags.levels-3d-preview.model3d", matches[0].output);
    }
  }

  async parse() {
    if (!this.name) this.name = this.source.name;
    this.npc = foundry.utils.duplicate(await (0,monster/* newNPC */.N)(this.name, this.source.id));
    this._calculateImage();

    this.npc.prototypeToken.name = this.name;
    this._generateFlags();


    this.proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
    this.npc.system.attributes.prof = this.proficiencyBonus;
    this._generateAbilities();

    // skills are different with extras, because DDB
    if (utils/* default.isString */.Z.isString(this.source.skillsHtml) && this.source.skillsHtml.trim() !== "") {
      this._generateSkillsHTML();
    } else {
      this._generateSkills();
    }

    // Senses needed for actor and token
    this._generateSenses();
    this._generateTokenSenses();

    this._generateDamageImmunities();
    this._generateDamageResistances();
    this._generateDamageVulnerabilities();
    this._generateConditionImmunities();
    this._generateSize();
    this._generateLanguages();
    this._generateHitPoints();
    this._generateMovement();
    await this._generateAC();

    this.cr = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId);
    this._generateType();

    const alignment = CONFIG.DDB.alignments.find((c) => this.source.alignmentId == c.id);
    this.npc.system.details.alignment = alignment ? alignment.name : "";
    this.npc.system.details.cr = this.cr.value;
    this.npc.system.details.xp = { value: this.cr.xp };

    this._generateSource();
    this._generateEnvironments();
    this.npc.system.details.biography.value = this.source.characteristicsDescription;

    await this._generateFeatures();

    // Spellcasting
    this._generateSpells();
    await this.addSpells();

    const badItems = this.items.filter((i) => i.name === "" || !i.name);
    if (badItems.length > 0) {
      logger/* default.error */.Z.error(`${this.source.name} - ${badItems.length} items have no name.`, badItems);
      this.items = this.items.filter((i) => i.name && i.name !== "");
    }

    this.items = (0,vision5e/* addVision5eStubs */.j)(this.items);
    this.npc.items = this.items;

    if (this.legacyName) {
      if (this.source.isLegacy) {
        this.npc.name += " (Legacy)";
        this.npc.prototypeToken.name += " (Legacy)";
      }
    }

    this.npc = await CompendiumHelper/* default.existingActorCheck */.Z.existingActorCheck("monster", this.npc);
    this.npc = specialCases(this.npc);

    this.npc = await (0,specialMonsters/* monsterFeatureEffectAdjustment */.w1)(this, this.addMonsterEffects);

    if (this.addChrisPremades) {
      for (let item of this.npc.items) {
        await ExternalAutomations/* default.applyChrisPremadeEffect */.Z.applyChrisPremadeEffect({
          document: item,
          type: "monsterfeature",
          folderName: this.npc.name,
          isMonster: true
        });
      }
    }
    this.npc = (0,specialMonsters/* transferEffectsToActor */.Du)(this.npc);

    this._generateTaggerFlags();
    this._generate3DModels();

    logger/* default.debug */.Z.debug(`Generated ${this.name}`, this);
    return this.npc;

  }

}


/***/ }),

/***/ 4029:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBMonsterFactory)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _DDBMonster_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3433);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2397);
/* harmony import */ var _lib_Secrets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2048);
/* harmony import */ var _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(546);
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8636);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6451);
/* harmony import */ var _lib_DDBCompendiumFolders_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(819);
/* harmony import */ var _muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9633);
/* harmony import */ var _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(306);
/* harmony import */ var _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6968);









// targets for migration




class DDBMonsterFactory {

  static #noteStub(note, nameField = false, monsterNote = false) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(note, { nameField, monsterNote });
  }

  static defaultFetchOptions(ids, searchTerm = null) {
    const searchFilter = $("#monster-munch-filter")[0];
    const finalSearchTerm = searchTerm ?? (searchFilter?.value ?? "");
    const enableSources = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-use-source-filter");
    const sources = enableSources
      ? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-muncher-sources").flat()
      : [];
    const homebrew = sources.length > 0
      ? false
      : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew");
    const homebrewOnly = sources.length > 0
      ? false
      : game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-homebrew-only");
    const exactMatch = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-exact-match");
    const excludeLegacy = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-exclude-legacy");

    const options = {
      ids,
      searchTerm: finalSearchTerm.trim(),
      sources,
      homebrew,
      homebrewOnly,
      exactMatch,
      excludeLegacy,
    };
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Generated monster fetch options", options);
    return options;
  }

  constructor ({ ddbData = null, extra = false, munchNote = null, type = "monsters", forceUpdate = null } = {}) {
    this.extra = extra;
    this.npcs = [];
    this.source = ddbData;
    this.munchNote = munchNote ?? DDBMonsterFactory.#noteStub;
    this.type = type;
    this.compendiumFolders = new _lib_DDBCompendiumFolders_js__WEBPACK_IMPORTED_MODULE_7__/* .DDBCompendiumFolders */ .Z(type);
    this.update = forceUpdate ?? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing");
  }

  /**
   * Fetch monsters from DDB
   * @param {*} ids limit monsters fetched to specific ids
   * @returns
   */
  async fetchDDBMonsterSourceData({ ids = [], searchTerm = "", sources = [], homebrew = false,
    homebrewOnly = false, exactMatch = false, excludeLegacy = false }
  ) {
    const cobaltCookie = (0,_lib_Secrets_js__WEBPACK_IMPORTED_MODULE_3__/* .getCobalt */ .HF)();
    const betaKey = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getPatreonKey */ .Z.getPatreonKey();
    const parsingApi = _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getProxy */ .Z.getProxy();

    const body = {
      cobalt: cobaltCookie,
      betaKey: betaKey,
    };

    if (ids && !Array.isArray(ids)) {
      ids = [ids];
    }

    if (ids && ids.length > 0) {
      body.ids = [...new Set(ids)];
    } else {
      body.sources = sources;
      body.search = searchTerm;
      body.homebrew = homebrew;
      body.homebrewOnly = homebrewOnly;
      body.searchTerm = encodeURIComponent(searchTerm);
      body.exactMatch = exactMatch;
      body.excludeLegacy = excludeLegacy;
    }

    const debugJson = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "debug-json");

    const url = ids && ids.length > 0
      ? `${parsingApi}/proxy/monsters/ids`
      : `${parsingApi}/proxy/monster`;

    return new Promise((resolve, reject) => {
      fetch(url, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            this.munchNote(`API Failure: ${data.message}`);
            _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`API Failure:`, data.message);
            reject(data.message);
          }
          if (debugJson) {
            _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].download */ .Z.download(JSON.stringify(data), `monsters-raw.json`, "application/json");
          }
          return data;
        })
        .then((data) => {
          this.munchNote(`Retrieved ${data.data.length + 1} monsters, starting parse...`, true, false);
          _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Retrieved ${data.data.length + 1} monsters`);
          this.source = data.data;
          resolve(this.source);
        })
        .catch((error) => reject(error));
    });
  }

  /**
   * Processes the downloaded (or provided) DDB Source data for monsters and generates actors
   * Use this.fetchDDBMonsterSourceData() if you need to get monster data from ddb
   * @returns
   */
  async parse() {
    let foundryActors = [];
    let failedMonsterNames = [];

    const useItemAC = game.settings.get("ddb-importer", "munching-policy-monster-use-item-ac");
    const legacyName = game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    const addMonsterEffects = game.settings.get("ddb-importer", "munching-policy-add-monster-effects");
    const addChrisPremades = game.settings.get("ddb-importer", "munching-policy-use-chris-premades");

    const totalMonsters = this.source.length + 1;
    let i = 1;
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].time */ .Z.time("Monster Parsing");
    for (const monster of this.source) {
      const name = `${monster.name}${monster.isLegacy ? " legacy" : ""}`;
      try {
        this.munchNote(`Parsing ${i}/${totalMonsters} (${name})`, false, true);
        i++;
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Attempting to parse ${i}/${totalMonsters} ${monster.name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].time */ .Z.time(`Monster Parse ${name}`);
        const ddbMonster = new _DDBMonster_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(monster, { extra: this.extra, useItemAC, legacyName, addMonsterEffects, addChrisPremades });
        await ddbMonster.parse();
        foundryActors.push(foundry.utils.duplicate(ddbMonster.npc));
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].timeEnd */ .Z.timeEnd(`Monster Parse ${name}`);
      } catch (err) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Failed parsing ${name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(err);
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(err.stack);
        failedMonsterNames.push(name);
      }
    }

    const result = {
      actors: await Promise.all(foundryActors),
      failedMonsterNames: failedMonsterNames,
    };

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].timeEnd */ .Z.timeEnd("Monster Parsing");

    this.munchNote(
      `Parsed ${result.actors.length} monsters, failed ${result.failedMonsterNames.length} monsters`,
      false,
      true
    );
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info(`Parsed ${result.actors.length} monsters, failed ${result.failedMonsterNames.length} monsters`);
    if (result.failedMonsterNames && result.failedMonsterNames.length !== 0) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error(`Failed to parse`, result.failedMonsterNames);
    }

    this.npcs = result.actors;
    return result;
  }

  /**
   * Downloads, parses, prepares
   */
  async createMonsterDocuments(ids = null) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].time */ .Z.time("Monster Process Time");
    const updateBool = this.update;
    const updateImages = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-images");
    const uploadDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");

    // to speed up file checking we pregenerate existing files now.
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info("Checking for existing files...");
    this.munchNote(`Checking existing image files...`);
    CONFIG.DDBI.KNOWN.TOKEN_LOOKUPS.clear();
    CONFIG.DDBI.KNOWN.AVATAR_LOOKUPS.clear();
    await _lib_Iconizer_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].preFetchDDBIconImages */ .Z.preFetchDDBIconImages();
    await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles(uploadDirectory);
    await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].generateCurrentFiles */ .Z.generateCurrentFiles("[data] modules/ddb-importer/data");

    if (game.canvas3D?.CONFIG?.UI) {
      // generate 3d model cache
      await game.canvas3D.CONFIG.UI.TokenBrowser.preloadData();
    }

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].info */ .Z.info("Check complete getting monster data...");
    this.munchNote(`Getting monster data from DDB...`);
    await this.fetchDDBMonsterSourceData(DDBMonsterFactory.defaultFetchOptions(ids));
    this.munchNote("");
    const monsterResults = await this.parse();

    const itemHandler = new _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z(this.type, monsterResults.actors);
    await itemHandler.init();

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Item Importer Loaded");
    if (!updateBool || !updateImages) {
      this.munchNote(`Calculating which monsters to update...`, true);
      const existingMonsters = await itemHandler.loadPassedItemsFromCompendium(itemHandler.documents, "npc", { keepDDBId: true });
      const existingMonstersTotal = existingMonsters.length + 1;
      if (!updateBool) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Removing existing monsters from import list");
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Matched ${existingMonstersTotal}`);
        this.munchNote(`Removing ${existingMonstersTotal} from update...`);
        itemHandler.removeItems(existingMonsters, true);
      }
      if (!updateImages) {
        _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Copying monster images across...");
        this.munchNote(`Copying images for ${existingMonstersTotal} monsters...`);
        itemHandler.documents = (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_8__/* .copyExistingMonsterImages */ .ph)(itemHandler.documents, existingMonsters);
      }
    }
    this.munchNote("");
    this.munchNote(`Fiddling with the SRD data...`, true);
    await itemHandler.srdFiddling();
    await itemHandler.iconAdditions();
    this.munchNote(`Generating Icon Map..`, true);
    await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_8__/* .generateIconMap */ .NM)(itemHandler.documents);
    await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_8__/* .useSRDMonsterImages */ .K8)(itemHandler.documents);

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].timeEnd */ .Z.timeEnd("Monster Process Time");
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Monster Document Generation", {
      ids,
      itemHandler,
    });

    return itemHandler.documents;

  }

  /**
   * Downloads, parses and imports monsters into a compendium
   */
  async processIntoCompendium(ids = null) {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].time */ .Z.time("Monster Import Time");

    const documents = await this.createMonsterDocuments(ids);

    this.munchNote(`Checking compendium folders..`, true);
    await this.compendiumFolders.loadCompendium("monsters");
    this.munchNote("", true);

    let monstersParsed = [];
    let currentMonster = 1;
    const monsterCount = documents.length;
    this.munchNote(`Preparing dinner for ${monsterCount} monsters!`, true);
    for (const monster of documents) {
      this.munchNote(`[${currentMonster}/${monsterCount}] Importing ${monster.name} to compendium`, false, true);
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Preparing ${monster.name} data for import`);
      const munched = await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_8__/* .addNPC */ .Fx)(monster, "monster");
      monstersParsed.push(munched);
      currentMonster += 1;
    }
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug("Monsters Parsed", monstersParsed);
    this.munchNote("", false, true);

    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].timeEnd */ .Z.timeEnd("Monster Import Time");
    if (ids !== null) {
      return Promise.all(monstersParsed);
    }
    return monsterCount;
  }
}


/***/ }),

/***/ 333:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ AdvancementHelper)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _effects_effects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5751);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1438);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5259);






function htmlToText(html) {
  // keep html brakes and tabs
  return html.replace(/<\/td>/g, "\n")
    .replace(/<\/table>/g, "\n")
    .replace(/<\/tr>/g, "\n")
    .replace(/<\/p>/g, "\n")
    .replace(/<\/div>/g, "\n")
    .replace(/<\/h>/g, "\n")
    .replace(/<br>/g, "\n")
    .replace(/<br( )*\/>/g, "\n")
    .replace(/<[A-Za-z/][^<>]*>/g, "");
}

class AdvancementHelper {

  constructor({ ddbData, type, dictionary = null, noMods = false }) {
    this.ddbData = ddbData;
    this.type = type;
    this.noMods = noMods;
    this.dictionary = dictionary;
  }

  static stripDescription(description) {
    const descriptionReplaced = description
      .replaceAll(/<br \/>(?:\s*)*/g, "<br />\n")
      .replaceAll(/<\/p>(?:\s*)*/g, "</p>\n")
      .replaceAll(/<\/dt>(?:\s*)*<dt>/g, "</dt>\n<dt>");
    // console.warn(descriptionReplaced);
    return htmlToText(descriptionReplaced);
    // return utils.stripHtml(descriptionReplaced, true);
  }


  getSkillChoicesFromOptions(feature, level, proficiencyFeatures = []) {
    const skillsChosen = new Set();
    const skillChoices = new Set();

    const choiceDefinitions = this.ddbData.character.choices.choiceDefinitions;

    this.ddbData.character.choices[this.type].filter((choice) =>
      // check all features
      ((feature === null && proficiencyFeatures.some((f) => f.id === choice.componentId && f.requiredLevel === level))
      // check specific feature
       || (feature && feature.id === choice.componentId && feature.requiredLevel === level))
      && choice.subType === 1
      && choice.type === 2
    ).forEach((choice) => {
      const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
      if (!optionChoice) return;
      const option = optionChoice.options.find((option) => option.id === choice.optionValue);
      if (!option) return;
      const smallChosen = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((skill) => skill.label === option.label);
      if (smallChosen) skillsChosen.add(smallChosen.name);
      const optionNames = optionChoice.options.filter((option) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.some */ .Z.character.skills.some((skill) => skill.label === option.label)
        && choice.optionIds.includes(option.id)
      ).map((option) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((skill) => skill.label === option.label).name
      );
      optionNames.forEach((skill) => {
        skillChoices.add(skill);
      });
    });

    return {
      chosen: Array.from(skillsChosen),
      choices: Array.from(skillChoices),
    };
  }

  getToolChoicesFromOptions(feature, level) {
    const toolsChosen = new Set();
    const toolChoices = new Set();

    const choiceDefinitions = this.ddbData.character.choices.choiceDefinitions;

    this.ddbData.character.choices[this.type].filter((choice) =>
      feature.id === choice.componentId
      && feature.requiredLevel === level
      && choice.subType === 1
      && choice.type === 2
    ).forEach((choice) => {
      const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
      if (!optionChoice) return;
      const option = optionChoice.options.find((option) => option.id === choice.optionValue);
      if (!option) return;
      const smallChosen = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) => prof.type === "Tool" && prof.name === option.label);
      if (smallChosen) {
        const toolStub = smallChosen.toolType === ""
          ? smallChosen.baseTool
          : `${smallChosen.toolType}:${smallChosen.baseTool}`;
        toolsChosen.add(toolStub);
      }
      const optionNames = optionChoice.options
        .filter((option) =>
          _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.some */ .Z.character.proficiencies.some((prof) => prof.type === "Tool" && prof.name === option.label)
          && choice.optionIds.includes(option.id)
        )
        .map((option) =>
          _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) => prof.type === "Tool" && prof.name === option.label)
        );
      optionNames.forEach((tool) => {
        const toolStub = tool.toolType === ""
          ? tool.baseTool
          : `${tool.toolType}:${tool.baseTool}`;
        toolChoices.add(toolStub);
      });
    });

    return {
      chosen: Array.from(toolsChosen),
      choices: Array.from(toolChoices),
    };
  }

  getLanguageChoicesFromOptions(feature, level) {
    const languagesChosen = new Set();
    const languageChoices = new Set();

    const choiceDefinitions = this.ddbData.character.choices.choiceDefinitions;

    this.ddbData.character.choices[this.type].filter((choice) =>
      feature.id === choice.componentId
      && feature.requiredLevel === level
      && choice.subType === 3
      && choice.type === 2
    ).forEach((choice) => {
      const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
      if (!optionChoice) return;
      const option = optionChoice.options.find((option) => option.id === choice.optionValue);
      if (!option) return;
      const smallChosen = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((lang) => lang.name === option.label);
      if (smallChosen) languagesChosen.add(smallChosen.value);
      const optionNames = optionChoice.options.filter((option) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((lang) => lang.name === option.label)
        && choice.optionIds.includes(option.id)
      ).map((option) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((lang) => lang.name === option.label).value
      );
      optionNames.forEach((skill) => {
        languageChoices.add(skill);
      });
    });

    return {
      chosen: Array.from(languagesChosen),
      choices: Array.from(languageChoices),
    };
  }

  getChoicesFromOptions(feature, type, level) {
    const chosen = new Set();
    const choices = new Set();

    const choiceDefinitions = this.ddbData.character.choices.choiceDefinitions;

    this.ddbData.character.choices[this.type].filter((choice) => {
      return feature.id === choice.componentId
        && feature.requiredLevel === level
        && choice.subType === 1
        && choice.type === 2;
    }).forEach((choice) => {
      const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
      if (!optionChoice) return;
      const option = optionChoice.options.find((option) => option.id === choice.optionValue);
      if (!option) return;
      const smallChosen = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) => prof.type === type && prof.name === option.label);
      if (smallChosen) {
        const stub = smallChosen.advancement === ""
          ? smallChosen.foundryValue
          : `${smallChosen.advancement}:${smallChosen.foundryValue}`;
        chosen.add(stub);
      }
      const optionNames = optionChoice.options
        .filter((option) =>
          _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.some */ .Z.character.proficiencies.some((prof) => prof.type === type && prof.name === option.label)
          && choice.optionIds.includes(option.id)
        )
        .map((option) =>
          _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) => prof.type === type && prof.name === option.label)
        );
      optionNames.forEach((prof) => {
        const stub = prof.advancement === ""
          ? prof.foundryValue
          : `${prof.advancement}:${prof.foundryValue}`;
        choices.add(stub);
      });
    });

    return {
      chosen: Array.from(chosen),
      choices: Array.from(choices),
    };
  }

  getExpertiseChoicesFromOptions(feature, level) {
    const skillsChosen = new Set();
    const skillChoices = new Set();
    const toolsChosen = new Set();
    const toolChoices = new Set();

    const choiceDefinitions = this.ddbData.character.choices.choiceDefinitions;

    this.ddbData.character.choices[this.type].filter((choice) =>
      feature.id === choice.componentId
      && feature.requiredLevel === level
      && choice.subType === 2
      && choice.type === 2
    ).forEach((choice) => {
      const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);
      if (!optionChoice) return;
      const option = optionChoice.options.find((option) => option.id === choice.optionValue);
      if (!option) return;
      const smallChosenSkill = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((skill) => skill.label === option.label);
      if (smallChosenSkill) skillsChosen.add(smallChosenSkill.name);
      const smallChosenTool = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((p) => p.type === "Tool" && p.name === option.label);
      if (smallChosenTool) toolsChosen.add(smallChosenTool.baseTool);

      const skillOptionNames = optionChoice.options.filter((option) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.some */ .Z.character.skills.some((skill) => skill.label === option.label)
        && choice.optionIds.includes(option.id)
      ).map((option) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((skill) => skill.label === option.label).name
      );
      skillOptionNames.forEach((skill) => {
        skillChoices.add(skill);
      });

      const toolOptionNames = optionChoice.options.filter((option) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((p) => p.type === "Tool" && p.name === option.label)
        && choice.optionIds.includes(option.id)
      ).map((option) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((p) => p.type === "Tool" && p.name === option.label).baseTool
      );
      toolOptionNames.forEach((tool) => {
        toolChoices.add(tool);
      });
    });

    return {
      skills: {
        chosen: Array.from(skillsChosen),
        choices: Array.from(skillChoices),
      },
      tools: {
        chosen: Array.from(toolsChosen),
        choices: Array.from(toolChoices),
      },
    };
  }

  static advancementUpdate(advancement, { pool = [], chosen = [], count = 0, grants = [] } = {}) {
    if (grants.length > 0) {
      advancement.updateSource({
        configuration: {
          grants,
        }
      });
    }
    if (pool.length > 0) {
      advancement.updateSource({
        configuration: {
          choices: [{
            count: count === 0 ? undefined : count,
            pool,
          }],
        }
      });
    }

    if (chosen.length > 0) {
      advancement.updateSource({
        value: {
          chosen,
        },
      });
    }
  }

  static getSaveAdvancement(mods, availableToMulticlass, level) {
    const updates = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.filter */ .Z.character.abilities.filter((ability) => {
        return _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterModifiers */ .Z.filterModifiers(mods, "proficiency", { subType: `${ability.long}-saving-throws` }).length > 0;
      })
      .map((ability) => `saves:${ability.value}`);

    if (updates.length === 0) return null;

    const advancement = new game.dnd5e.documents.advancement.TraitAdvancement();
    advancement.updateSource({
      classRestriction: level > 1 ? "" : availableToMulticlass ? "secondary" : "primary",
      configuration: {
        grants: updates,
        allowReplacements: false,
      },
      level: level,
    });

    // add selection
    if (updates.length > 0) {
      advancement.updateSource({
        value: {
          chosen: updates,
        },
      });
    }

    return advancement;

  }

  getSkillAdvancement(mods, feature, availableToMulticlass, level) {
    const baseProficiency = feature.name === "Proficiencies";
    const skillsFromMods = mods
      .filter((mod) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((s) => s.label === mod.friendlySubtypeName)
      )
      .map((mod) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((s) => s.label === mod.friendlySubtypeName).name
      );

    const advancement = new game.dnd5e.documents.advancement.TraitAdvancement();

    const parsedSkills = AdvancementHelper.parseHTMLSkills(feature.description);
    const chosenSkills = this.noMods
      ? { chosen: [], choices: [] }
      : this.getSkillChoicesFromOptions(feature, level);

    const count = this.noMods || parsedSkills.number > 0 || parsedSkills.grants.length > 0
      ? parsedSkills.number
      : baseProficiency && availableToMulticlass
        ? this.dictionary.multiclassSkill
        : mods.length;

    // console.warn(`Parsing skill advancement for level ${level}`, {
    //   availableToMulticlass,
    //   level,
    //   feature,
    //   mods,
    //   parsedSkills,
    //   chosenSkills,
    //   count,
    //   skillsFromMods,
    // });

    if (count === 0 && parsedSkills.grants.length === 0) return null;

    const classRestriction = availableToMulticlass === undefined
      ? undefined
      : level > 1 ? "" : availableToMulticlass ? "secondary" : "primary";

    const title = feature.name !== "Proficiencies" && !feature.name.startsWith("Background:")
      ? feature.name
      : "Skills";

    advancement.updateSource({
      title,
      classRestriction,
      configuration: {
        allowReplacements: true,
      },
      level,
    });

    const pool = this.noMods || parsedSkills.choices.length > 0 || parsedSkills.grants.length > 0
      ? parsedSkills.choices.map((skill) => `skills:${skill}`)
      : skillsFromMods.map((choice) => `skills:${choice}`);

    const chosen = this.noMods || chosenSkills.chosen.length > 0
      ? chosenSkills.chosen.map((choice) => `skills:${choice}`)
        .concat(parsedSkills.grants.map((grant) => `skills:${grant}`))
      : skillsFromMods.map((choice) => `skills:${choice}`);

    AdvancementHelper.advancementUpdate(advancement, {
      pool,
      chosen,
      count,
      grants: parsedSkills.grants.map((grant) => `skills:${grant}`),
    });

    return advancement;
  }


  getLanguageAdvancement(mods, feature, level) {
    const languagesMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterModifiers */ .Z.filterModifiers(mods, "language");

    const advancement = new game.dnd5e.documents.advancement.TraitAdvancement();

    const parsedLanguages = AdvancementHelper.parseHTMLLanguages(feature.description);
    const chosenLanguages = this.noMods
      ? { chosen: [], choices: [] }
      : this.getLanguageChoicesFromOptions(feature, level);

    const languagesFromMods = languagesMods
      .filter((mod) => _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((lang) => lang.name === mod.friendlySubtypeName))
      .map((mod) => {
        const language = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((lang) => lang.name === mod.friendlySubtypeName);
        return language.advancement ? `${language.advancement}:${language.value}` : language.value;
      });

    const count = this.noMods || parsedLanguages.number > 0 || parsedLanguages.grants.length > 0
      ? parsedLanguages.number !== 0
        ? parsedLanguages.number
        : 1
      : languagesMods.length;

    // console.warn(`Languages`, {
    //   i: level,
    //   languageFeature: feature,
    //   mods,
    //   languagesMods,
    //   parsedLanguages,
    //   chosenLanguages,
    //   languagesFromMods,
    //   languageCount: count,
    // });

    if (count === 0 && parsedLanguages.grants.length === 0) return null;

    const pool = this.noMods || parsedLanguages.choices.length > 0 || parsedLanguages.grants.length > 0
      ? parsedLanguages.choices.map((choice) => `languages:${choice}`)
      : languagesFromMods.map((choice) => `languages:${choice}`);

    const chosen = this.noMods || chosenLanguages.chosen.length > 0
      ? chosenLanguages.chosen.map((choice) => `languages:${choice}`)
        .concat(parsedLanguages.grants.map((grant) => `languages:${grant}`))
      : languagesFromMods.map((choice) => `languages:${choice}`);

    advancement.updateSource({
      title: feature.name !== "Proficiencies" && !feature.name.startsWith("Background:") ? feature.name : "Languages",
      configuration: {
        allowReplacements: true,
      },
      level: level,
    });

    AdvancementHelper.advancementUpdate(advancement, {
      pool,
      chosen,
      count: count,
      grants: parsedLanguages.grants.map((grant) => `languages:${grant}`),
    });

    return advancement;
  }

  getToolAdvancement(mods, feature, level) {
    const proficiencyMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterModifiers */ .Z.filterModifiers(mods, "proficiency");
    const toolMods = proficiencyMods
      .filter((mod) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.some */ .Z.character.proficiencies.some((prof) => prof.type === "Tool" && prof.name === mod.friendlySubtypeName)
      );

    const advancement = new game.dnd5e.documents.advancement.TraitAdvancement();

    const parsedTools = AdvancementHelper.parseHTMLTools(feature.description);
    const chosenTools = this.noMods
      ? { chosen: [], choices: [] }
      : this.getToolChoicesFromOptions(feature, level);

    const toolsFromMods = toolMods.map((mod) => {
      const tool = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) => prof.type === "Tool" && prof.name === mod.friendlySubtypeName);
      return tool.toolType === ""
        ? tool.baseTool
        : `${tool.toolType}:${tool.baseTool}`;
    });

    const count = this.noMods || parsedTools.number > 0 || parsedTools.grants.length > 0
      ? parsedTools.number > 0
        ? parsedTools.number
        : 1
      : toolMods.length;

    // console.warn(`Tools`, {
    //   level,
    //   feature,
    //   mods,
    //   proficiencyMods,
    //   toolMods,
    //   parsedTools,
    //   chosenTools,
    //   toolsFromMods,
    //   count,
    // });

    if (count === 0 && parsedTools.grants.length === 0) return null;

    const pool = this.noMods || parsedTools.choices.length > 0 || parsedTools.grants.length > 0
      ? parsedTools.choices.map((choice) => `tool:${choice}`)
      : toolsFromMods.map((choice) => `tool:${choice}`);


    const chosen = this.noMods || chosenTools.chosen.length > 0
      ? chosenTools.chosen.map((choice) => `tool:${choice}`)
        .concat(parsedTools.grants.map((grant) => `tool:${grant}`))
      : toolsFromMods.map((choice) => `tool:${choice}`);

    advancement.updateSource({
      title: feature.name !== "Proficiencies" && !feature.name.startsWith("Background:") ? feature.name : "Tool Proficiencies",
      configuration: {
        allowReplacements: true,
      },
      level: level,
    });

    // console.warn("tools", {
    //   pool,
    //   chosen,
    //   count,
    //   grants: parsedTools.grants.map((grant) => `tool:${grant}`),
    // });

    AdvancementHelper.advancementUpdate(advancement, {
      pool,
      chosen,
      count,
      grants: parsedTools.grants.map((grant) => `tool:${grant}`),
    });

    return advancement;
  }

  getArmorAdvancement(mods, feature, availableToMulticlass, level) {
    const proficiencyMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterModifiers */ .Z.filterModifiers(mods, "proficiency");
    const armorMods = proficiencyMods
      .filter((mod) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.some */ .Z.character.proficiencies.some((prof) => prof.type === "Armor" && prof.name === mod.friendlySubtypeName)
      );

    const advancement = new game.dnd5e.documents.advancement.TraitAdvancement();

    const parsedArmors = AdvancementHelper.parseHTMLArmorProficiencies(feature.description);
    const chosenArmors = this.noMods
      ? { chosen: [], choices: [] }
      : this.getChoicesFromOptions(feature, "Armor", level);

    const armorsFromMods = armorMods.map((mod) => {
      const armor = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) => prof.type === "Armor" && prof.name === mod.friendlySubtypeName);
      return armor.advancement === ""
        ? armor.foundryValue
        : `${armor.advancement}:${armor.foundryValue}`;
    });

    const count = this.noMods || parsedArmors.number > 0 || parsedArmors.grants.length > 0
      ? parsedArmors.number > 0
        ? parsedArmors.number
        : 1
      : armorMods.length;

    // console.warn(`Armor`, {
    //   level,
    //   feature,
    //   mods,
    //   proficiencyMods,
    //   toolMods: armorMods,
    //   parsedArmors,
    //   chosenArmors,
    //   armorsFromMods,
    //   count,
    // });

    if (count === 0 && parsedArmors.grants.length === 0) return null;

    const classRestriction = availableToMulticlass === undefined
      ? undefined
      : level > 1 ? "" : availableToMulticlass ? "secondary" : "primary";

    const pool = this.noMods || parsedArmors.choices.length > 0 || parsedArmors.grants.length > 0
      ? parsedArmors.choices.map((choice) => `armor:${choice}`)
      : armorsFromMods.map((choice) => `armor:${choice}`);

    const chosen = this.noMods || chosenArmors.chosen.length > 0
      ? chosenArmors.chosen.map((choice) => `armor:${choice}`)
        .concat(parsedArmors.grants.map((grant) => `armor:${grant}`))
      : armorsFromMods.map((choice) => `armor:${choice}`);

    advancement.updateSource({
      title: feature.name !== "Proficiencies" && !feature.name.startsWith("Background:") ? feature.name : "Armor Proficiencies",
      classRestriction,
      configuration: {
        allowReplacements: false,
      },
      level: level,
    });

    // console.warn("tools", {
    //   pool,
    //   chosen,
    //   count,
    //   grants: parsedTools.grants.map((grant) => `tool:${grant}`),
    // });

    AdvancementHelper.advancementUpdate(advancement, {
      pool,
      chosen,
      count,
      grants: parsedArmors.grants.map((grant) => `armor:${grant}`),
    });

    return advancement;
  }

  getWeaponAdvancement(mods, feature, level) {
    const proficiencyMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterModifiers */ .Z.filterModifiers(mods, "proficiency");
    const weaponMods = proficiencyMods
      .filter((mod) =>
        _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.some */ .Z.character.proficiencies.some((prof) => prof.type === "Weapon" && prof.name === mod.friendlySubtypeName)
      );

    const advancement = new game.dnd5e.documents.advancement.TraitAdvancement();

    const parsedWeapons = AdvancementHelper.parseHTMLWeaponProficiencies(feature.description);
    const chosenWeapons = this.noMods
      ? { chosen: [], choices: [] }
      : this.getChoicesFromOptions(feature, "Weapon", level);

    const weaponsFromMods = weaponMods.map((mod) => {
      const weapon = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) => prof.type === "Weapon" && prof.name === mod.friendlySubtypeName);
      return weapon.advancement === ""
        ? weapon.foundryValue
        : `${weapon.advancement}:${weapon.foundryValue}`;
    });

    const count = this.noMods || parsedWeapons.number > 0 || parsedWeapons.grants.length > 0
      ? parsedWeapons.number > 0
        ? parsedWeapons.number
        : 1
      : weaponMods.length;

    // console.warn(`Weapon`, {
    //   level,
    //   feature,
    //   mods,
    //   proficiencyMods,
    //   armorMods: weaponMods,
    //   parsedArmors: parsedWeapons,
    //   chosenArmors: chosenWeapons,
    //   armorsFromMods: weaponsFromMods,
    //   count,
    // });

    if (count === 0 && parsedWeapons.grants.length === 0) return null;

    const pool = this.noMods || parsedWeapons.choices.length > 0 || parsedWeapons.grants.length > 0
      ? parsedWeapons.choices.map((choice) => `weapon:${choice}`)
      : weaponsFromMods.map((choice) => `weapon:${choice}`);


    const chosen = this.noMods || chosenWeapons.chosen.length > 0
      ? chosenWeapons.chosen.map((choice) => `weapon:${choice}`)
        .concat(parsedWeapons.grants.map((grant) => `weapon:${grant}`))
      : weaponsFromMods.map((choice) => `weapon:${choice}`);

    advancement.updateSource({
      title: feature.name !== "Proficiencies" && !feature.name.startsWith("Background:") ? feature.name : "Weapon Proficiencies",
      configuration: {
        allowReplacements: false,
      },
      level: level,
    });

    // console.warn("weapons", {
    //   pool,
    //   chosen,
    //   count,
    //   grants: parsedWeapons.grants.map((grant) => `weapon:${grant}`),
    // });

    AdvancementHelper.advancementUpdate(advancement, {
      pool,
      chosen,
      count,
      grants: parsedWeapons.grants.map((grant) => `weapon:${grant}`),
    });

    return advancement;
  }

  getExpertiseAdvancement(feature, level) {
    const advancement = new game.dnd5e.documents.advancement.TraitAdvancement();
    const expertiseOptions = this.noMods
      ? { chosen: [], choices: [] }
      : this.getExpertiseChoicesFromOptions(feature, level);

    // add HTML Parsing to improve this at a later date

    const pool = feature.name === "Survivalist"
      ? ["skills:prc", "skills:nat"]
      : feature.name === "Expertise"
        ? ["skills:*", "tool:thief"]
        : ["skills:*"];

    const grants = feature.name === "Survivalist"
      ? pool
      : [];

    const count = feature.name === "Survivalist"
      ? 0
      : expertiseOptions.length > 0
        ? expertiseOptions.length
        : 2;

    advancement.updateSource({
      title: feature.name === "Survivalist" ? `${feature.name} (Expertise)` : `${feature.name}`,
      configuration: {
        allowReplacements: false,
        mode: "expertise",
      },
      level: level,
    });

    const chosenSkills = expertiseOptions.skills.chosen.map((skill) => `skills:${skill}`);
    const chosenTools = expertiseOptions.tools.chosen.map((tool) => `tool:${tool}`);
    const chosen = [].concat(chosenSkills, chosenTools, grants);

    AdvancementHelper.advancementUpdate(advancement, {
      chosen,
      pool,
      count,
      grants,
    });

    return advancement;

  }

  static CONDITION_ID_MAPPING = {
    1: "dr",
    2: "di",
    3: "dv",
    4: "ci",
  };

  getConditionAdvancement(mods, feature, level) {
    const conditionsFromMods = [];
    ["resistance", "immunity", "vulnerability", "immunity"].forEach((condition, i) => {
      const proficiencyMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterModifiers */ .Z.filterModifiers(mods, condition, { restriction: null });
      const conditionId = i + 1;
      const conditionData = (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_1__/* .getGenericConditionAffectData */ .OJ)(proficiencyMods, condition, conditionId, true);
      const conditionValues = new Set(conditionData.map((result) => `${AdvancementHelper.CONDITION_ID_MAPPING[conditionId]}:${result.value}`));
      // console.warn("Individual Parse", {
      //   proficiencyMods,
      //   condition,
      //   conditionId,
      //   conditionData,
      //   conditionValues,
      // });
      conditionsFromMods.push(...conditionValues);
    });

    const advancement = new game.dnd5e.documents.advancement.TraitAdvancement();

    const parsedConditions = AdvancementHelper.parseHTMLConditions(feature.description);

    const count = this.noMods || parsedConditions.number > 0 || parsedConditions.grants.length > 0
      ? parsedConditions.number > 0
        ? parsedConditions.number
        : 1
      : conditionsFromMods.length;

    // console.warn(`Conditions`, {
    //   level,
    //   feature,
    //   mods,
    //   conditionsFromMods,
    //   parsedConditions,
    //   count,
    // });

    if (count === 0 && parsedConditions.grants.length === 0) return null;

    const pool = this.noMods || parsedConditions.choices.length > 0 || parsedConditions.grants.length > 0
      ? parsedConditions.choices.map((choice) => choice)
      : conditionsFromMods.map((choice) => choice);

    const chosen = this.noMods
      ? parsedConditions.grants.map((grant) => grant)
      : conditionsFromMods.map((choice) => choice);

    advancement.updateSource({
      title: feature.name !== "Proficiencies" && !feature.name.startsWith("Background:") ? feature.name : "",
      configuration: {
        allowReplacements: false,
        hint: parsedConditions.hint,
      },
      level: level,
    });

    // console.warn("conditions", {
    //   pool,
    //   chosen,
    //   count,
    //   grants: parsedConditions.grants.map((grant) => grant),
    // });

    AdvancementHelper.advancementUpdate(advancement, {
      pool,
      chosen,
      count,
      grants: parsedConditions.grants.map((grant) => grant),
    });

    return advancement;
  }

  // Feats with multichoices
  // You gain proficiency in any combination of three skills or tools of your choice.

  static convertToSingularDie(advancement) {
    advancement.title += ` (Die)`;
    for (const key of Object.keys(advancement.configuration.scale)) {
      advancement.configuration.scale[key].n = 1;
    }
    return advancement;
  }

  static renameTotal(advancement) {
    advancement.title += ` (Total)`;
    return advancement;
  }

  static addAdditionalUses(advancement) {
    const adv = new game.dnd5e.documents.advancement.ScaleValueAdvancement();
    const update = {
      configuration: {
        identifier: `${advancement.configuration.identifier}-uses`,
        type: "number",
        scale: {},
      },
      title: `${advancement.title} (Uses)`,
    };

    for (const [key, value] of Object.entries(advancement.configuration.scale)) {
      // console.warn("key", {key, value});
      update.configuration.scale[key] = {
        value: value.number,
      };
    }
    adv.updateSource(update);

    return adv.toObject();
  }

  static addSingularDie(advancement) {
    const scaleValue = AdvancementHelper.convertToSingularDie(foundry.utils.duplicate(advancement));

    scaleValue._id = foundry.utils.randomID();
    scaleValue.configuration.identifier = `${advancement.configuration.identifier}-die`;

    return scaleValue;
  }

  static generateScaleValueAdvancement(feature) {
    // distance, number, dice, anything
    let type = "string";
    const die = feature.levelScales[0]?.dice
      ? feature.levelScales[0]?.dice
      : feature.levelScales[0]?.die
        ? feature.levelScales[0]?.die
        : undefined;

    if (die?.diceString && (!die.fixedValue || die.fixedValue === "")) {
      type = "dice";
    } else if (feature.levelScales[0].fixedValue
      && feature.levelScales[0].fixedValue !== ""
      && Number.isInteger(feature.levelScales[0].fixedValue)
    ) {
      type = "number";
    }

    const advancement = new game.dnd5e.documents.advancement.ScaleValueAdvancement();

    const update = {
      configuration: {
        identifier: _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].referenceNameString */ .Z.referenceNameString(feature.name).toLowerCase(),
        type,
        scale: {},
      },
      value: {},
      title: feature.name,
    };

    feature.levelScales.forEach((scale) => {
      const die = scale.dice ? scale.dice : scale.die ? scale.die : undefined;
      if (type === "dice") {
        update.configuration.scale[scale.level] = {
          n: die.diceCount,
          die: die.diceValue,
        };
      } else if (type === "number") {
        update.configuration.scale[scale.level] = {
          value: scale.fixedValue,
        };
      } else {
        let value = (die.diceString && die.diceString !== "")
          ? die.diceString
          : "";
        if (die.fixedValue && die.fixedValue !== "") {
          value += ` + ${die.fixedValue}`;
        }
        if (value === "") {
          value = scale.description;
        }
        update.configuration.scale[scale.level] = {
          value,
        };
      }
    });

    advancement.updateSource(update);

    return advancement.toObject();
  }

  static parseHTMLSaves(description) {
    const results = [];

    const textDescription = AdvancementHelper.stripDescription(description);

    // get class saves
    const savingText = textDescription.toLowerCase().split("saving throws:").pop().split("\n")[0].split("The")[0].split(".")[0].split("skills:")[0].trim();
    const saveRegex = /(.*)(?:$|The|\.$|\w+:)/im;
    const saveMatch = savingText.match(saveRegex);

    if (saveMatch) {
      const saveNames = saveMatch[1].replace(' and ', ',').split(',').map((ab) => ab.trim());
      const saves = saveNames
        .filter((name) => _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.some */ .Z.character.abilities.some((ab) => ab.long.toLowerCase() === name.toLowerCase()))
        .map((name) => {
          const dictAbility = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ab) => ab.long.toLowerCase() === name.toLowerCase());
          return dictAbility.value;
        });
      results.push(...saves);
    }
    return results;
  }

  static parseHTMLSkills(description) {
    const parsedSkills = {
      choices: [],
      grants: [],
      number: 0,
      allowReplacements: true,
    };
    const textDescription = AdvancementHelper.stripDescription(description).replace(/\s/g, " ");

    // Choose any three e.g. bard
    const anySkillRegex = /Skills:\sChoose any (\w+)(.*)($|\.$|\w+:)/im;
    const anyMatch = textDescription.match(anySkillRegex);

    if (anyMatch) {
      // const skills = DICTIONARY.character.skills.map((skill) => skill.name);
      const numberSkills = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => anyMatch[1].toLowerCase() === num.natural);
      // eslint-disable-next-line require-atomic-updates
      parsedSkills.number = numberSkills ? numberSkills.num : 2;
      parsedSkills.choices = ["*"];
      return parsedSkills;
    }

    // Skill Proficiencies: Nature, Survival
    const backgroundSkillRegex = /Skill Proficiencies:\s(.*?)($|\.$|\w+:)/im;
    const backgroundMatch = textDescription.match(backgroundSkillRegex);

    if (backgroundMatch) {
      const skills = backgroundMatch[1].replace(" and ", ",").split(",").map((skill) => skill.trim());
      skills.forEach((grant) => {
        const dictSkill = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((skill) => skill.label.toLowerCase() === grant.toLowerCase().split(" ")[0]);
        if (dictSkill) parsedSkills.grants.push(dictSkill.name);
      });
      return parsedSkills;
    }

    // most other class profs
    // Skills: Choose two from Arcana, Animal Handling, Insight, Medicine, Nature, Perception, Religion, and Survival
    const skillText = textDescription.toLowerCase().split("skills:").pop().split("\n")[0].split("the")[0].split(".")[0].trim();
    const skillRegex = /choose (\w+)(?:\sskills)* from (.*)($|The|\.|\w+:)/im;
    const skillMatch = skillText.match(skillRegex);

    // common feature choice
    // you gain proficiency in one of the following skills of your choice: Deception, Performance, or Persuasion.
    // you gain proficiency with two of the following skills of your choice: Deception, Insight, Intimidation
    const oneOffRegex = /you gain proficiency (?:in|with) (\w+) of the following skills of your choice:\s(.*?)(\.|$)/im;
    const oneOffMatch = textDescription.match(oneOffRegex);

    // You also become proficient in your choice of two of the following skills: Arcana, History, Nature, or Religion.
    const twoRegex = /also become proficient in your choice of (\w+) of the following skills:\s(.*?)(\.|$)/im;
    const twoMatch = textDescription.match(twoRegex);

    if (skillMatch || oneOffMatch || twoMatch) {
      const match = skillMatch ?? oneOffMatch ?? twoMatch;
      const skillNames = match[2].replace(' and ', ',').replace(" or ", " ").split(',').map((skill) => skill.trim());
      const skills = skillNames
        .filter((name) => _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.some */ .Z.character.skills.some((skill) => skill.label.toLowerCase() === name.toLowerCase()))
        .map((name) => {
          const dictSkill = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((skill) => skill.label.toLowerCase() === name.toLowerCase());
          return dictSkill.name;
        });
      const numberSkills = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => match[1].toLowerCase() === num.natural);
      parsedSkills.number = numberSkills ? numberSkills.num : 2;
      parsedSkills.choices = skills;
      return parsedSkills;
    }

    // no more matches, return.
    if (!textDescription.includes("proficiency")) return parsedSkills;

    // You gain proficiency in one skill of your choice.
    // You gain proficiency in an additional skill or learn a new language of your choice.
    // You gain one skill proficiency of your choice, one tool proficiency of your choice, and fluency in one language of your choice.
    const additionalMatchRegex = /You gain (?:one skill proficiency of your choice|proficiency in (?:an additional skill|one skill of your choice))/im;
    const additionalMatch = textDescription.match(additionalMatchRegex);

    if (additionalMatch) {
      parsedSkills.number = 1;
      parsedSkills.choices = ["*"];
      return parsedSkills;
    }

    // You gain proficiency in the Intimidation skill.
    // You gain proficiency in the Insight and Medicine skills, and you
    // you gain proficiency in the Performance skill if you dont already have it.
    const explicitSkillGrantRegex = /You gain proficiency in the (.*) skill( if you dont already have it)?/i;
    const explicitSkillGrantMatch = textDescription.match(explicitSkillGrantRegex);

    if (explicitSkillGrantMatch) {
      const skills = explicitSkillGrantMatch[1].replace(" and ", ",").split(",").map((skill) => skill.trim());
      skills.forEach((grant) => {
        const dictSkill = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((skill) => skill.label.toLowerCase() === grant.toLowerCase());
        if (dictSkill) parsedSkills.grants.push(dictSkill.name);
      });
      return parsedSkills;
    }

    // not matches, so return empty parsed set
    return parsedSkills;
  }

  static parseHTMLLanguages(description) {
    const parsedLanguages = {
      grants: [],
      choices: [],
      number: 0,
    };
    const textDescription = AdvancementHelper.stripDescription(description);

    // Background languages
    const languagesRegex = /Languages:\s(.*?)($|\.$|\w+:)/im;
    const languagesMatch = textDescription.match(languagesRegex);

    // Languages: Giant and one other language of your choice
    // Languages: Any one of your choice
    // Languages: one of your choice
    // Languages: One of your choice of Elvish, Gnomish, Goblin, or Sylvan
    // Languages: Two of your choice
    if (languagesMatch) {
      const choiceRegexComplex = /(?:(\w+)?(?: and))?\s?(?:(\w+)(?: other language)*)\sof\syour\schoice(?: of (.*))*/im;
      const complexMatch = languagesMatch[1].match(choiceRegexComplex);
      if (complexMatch) {
        if (complexMatch[1]) {
          const dictMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((l) =>
            l.name.toLowerCase() === complexMatch[1].split(" ")[0].toLowerCase().trim()
          );
          if (dictMatch) {
            const language = dictMatch.advancement ? `${dictMatch.advancement}:${dictMatch.value}` : dictMatch.value;
            parsedLanguages.grants.push(language);
          }
        }
        if (complexMatch[2]) {
          const number = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => complexMatch[2].toLowerCase().trim() === num.natural);
          parsedLanguages.number = number ? number.num : 1;
          if (complexMatch[3]) {
            const languages = complexMatch[3].replace(" or ", ",").split(",").map((skill) => skill.trim());
            languages.forEach((choice) => {
              const dictMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((l) =>
                l.name.toLowerCase() === choice.toLowerCase().split(" ")[0]
              );
              if (dictMatch) {
                const language = dictMatch.advancement ? `${dictMatch.advancement}:${dictMatch.value}` : dictMatch.value;
                parsedLanguages.choices.push(language);
              }
            });
          } else {
            parsedLanguages.choices = ["*"];
          }
        }
        return parsedLanguages;
      }

      // Languages: Choose one of Draconic, Goblin, or Vedalken
      const choiceOfRegex = /choose (\w+)(?: of (.*))*/im;
      const simpleChoice = textDescription.match(choiceOfRegex);
      if (simpleChoice) {
        const number = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => simpleChoice[1].toLowerCase().trim() === num.natural);
        parsedLanguages.number = number ? number.num : 1;
        if (simpleChoice[2]) {
          const languages = simpleChoice[2].replace(" or ", ",").split(",").map((skill) => skill.trim());
          languages.forEach((choice) => {
            const dictMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((l) =>
              l.name.toLowerCase() === choice.toLowerCase().split(" ")[0]
            );
            // console.warn("lang check", {
            //   simple: simpleChoice[2],
            //   choice,
            //   languages,
            //   matchVal: choice.toLowerCase().split(" ")[0],
            //   dictMatch,
            // });
            if (dictMatch) {
              const language = dictMatch.advancement ? `${dictMatch.advancement}:${dictMatch.value}` : dictMatch.value;
              parsedLanguages.choices.push(language);
            }
          });
        } else {
          parsedLanguages.choices = ["*"];
        }

        return parsedLanguages;
      }

      // Languages: Draconic or Elven
      parsedLanguages.number = 1;
      if (languagesMatch[1]) {
        const languages = languagesMatch[1].replace(" or ", ",").split(",").map((skill) => skill.trim());
        languages.forEach((choice) => {
          const dictMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((l) => l.name.toLowerCase() === choice.toLowerCase());
          if (dictMatch) {
            const language = dictMatch.advancement ? `${dictMatch.advancement}:${dictMatch.value}` : dictMatch.value;
            parsedLanguages.choices.push(language);
          }
        });
        return parsedLanguages;
      }
    }

    // you learn one language of your choice.
    // You also learn two languages of your choice.
    // You gain proficiency in an additional skill or learn a new language of your choice.
    // learn one language of your choice that is spoken by your
    const ofYourChoiceRegex = /learn (\w+?|a new) language(?:s)? of your choice/im;
    const ofYourChoiceMatch = textDescription.match(ofYourChoiceRegex);

    if (ofYourChoiceMatch) {
      const number = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => ofYourChoiceMatch[1].toLowerCase() === num.natural);
      parsedLanguages.number = number ? number.num : 2;
      parsedLanguages.choices = ["*"];
      return parsedLanguages;
    }

    // You can speak, read, and write Common and Dwarvish.
    // You can speak, read, and write Common and Elvish.
    // You can speak, read, and write Common and one extra language of your choice
    // Your character can speak, read, and write Common and one other language that
    // You learn to speak, read, and write Sylvan.
    // You gain proficiency with smiths tools, and you learn to speak, read, and write Giant.
    const speakReadAndWriteRegex = /speak, read, and write (.*?)(?:\.|$)/im;
    const speakReadAndWriteMatch = textDescription.match(speakReadAndWriteRegex);

    if (speakReadAndWriteMatch) {
      const languages = speakReadAndWriteMatch[1].replace(" and ", ",").split(",").map((skill) => skill.trim());
      parsedLanguages.number = 0;
      languages.forEach((grant) => {
        if (grant.includes("other language") || grant.includes("of your choice")) {
          parsedLanguages.number++;
          parsedLanguages.choices = ["*"];
        } else {
          const dictMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.languages.find */ .Z.character.languages.find((l) => l.name.toLowerCase() === grant.toLowerCase());
          if (dictMatch) {
            const language = dictMatch.advancement ? `${dictMatch.advancement}:${dictMatch.value}` : dictMatch.value;
            parsedLanguages.grants = [language];
          }
        }

      });
      return parsedLanguages;
    }

    // You gain one skill proficiency of your choice, one tool proficiency of your choice, and fluency in one language of your choice.
    const featMatchRegex = /fluency in (\w+) language(?:s)? of your choice/i;
    const featMatch = textDescription.match(featMatchRegex);

    if (featMatch) {
      const number = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => featMatch[1].toLowerCase() === num.natural);
      parsedLanguages.number = number ? number.num : 1;
      parsedLanguages.number = 1;
      parsedLanguages.choices = ["*"];
      return parsedLanguages;
    }

    return parsedLanguages;
  }

  static TOOL_GROUPS = {
    "musical instrument": "music",
    "gaming set": "game",
    "artisan's tools": "art",
    "vehicle": "vehicle",
  };

  static getToolGroup(text) {
    for (const [key, value] of Object.entries(AdvancementHelper.TOOL_GROUPS)) {
      if (_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(text).toLowerCase().includes(key)) return value;
    }
    return null;
  }

  static getDictionaryTool(name) {
    const directMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((tool) =>
      tool.type === "Tool"
      && tool.name.toLowerCase() === _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(name).toLowerCase()
    );
    if (directMatch) return directMatch;

    const dictionaryTools = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.filter */ .Z.character.proficiencies.filter((tool) => tool.type === "Tool");
    for (const tool of dictionaryTools) {
      if (_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(name).toLowerCase().includes(tool.name.toLowerCase())) return tool;
    }
    return null;
  }

  static getToolAdvancementValue(text) {
    const match = AdvancementHelper.getDictionaryTool(text);
    if (match) {
      const stub = match.toolType === ""
        ? match.baseTool
        : `${match.toolType}:${match.baseTool}`;
      return stub;
    }
    return null;
  }

  // eslint-disable-next-line complexity
  static parseHTMLTools(description) {
    const parsedTools = {
      choices: [],
      grants: [],
      number: 0,
    };

    const textDescription = AdvancementHelper.stripDescription(description);

    // Tools: None
    if (textDescription.includes("Tools: None")) return parsedTools;

    // Tools: Choose one type of artisans tools or one musical instrument
    const anyToolsRegex = /^Tools:\sChoose (\w+) type of (.*)($|\.|\w+:)/im;
    const anyMatch = textDescription.match(anyToolsRegex);
    // Tools: Three musical instruments of your choice
    const anyToolsRegex2 = /^Tools:\s(\w+)\s(.*) of your choice($|\.|\w+:)/im;
    const anyMatch2 = textDescription.match(anyToolsRegex2);

    if (anyMatch || anyMatch2) {
      const match = anyMatch ?? anyMatch2;
      // const skills = DICTIONARY.character.skills.map((skill) => skill.name);
      const numberTools = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => match[1].toLowerCase() === num.natural);
      parsedTools.number = numberTools ? numberTools.num : 2;
      const toolArray = match[2].split(" or ");
      for (const toolString of toolArray) {
        const toolGroup = AdvancementHelper.getToolGroup(toolString);
        if (toolGroup) {
          parsedTools.choices.push(`${toolGroup}:*`);
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error(`Could not find tool group for ${toolString}, please log an issue`);
        }
      }
      return parsedTools;
    }

    // Tools: Thieves' tools, tinker's tools, one type of artisan's tools of your choice
    // Tools: Herbalism kit
    // Tool Proficiencies: Disguise Kit, one type of Gaming Set or Musical Instrument
    const toolGrantsRegex = /^(?:Tools|Tool Proficiencies):\s(.*?)($|\.|\w+:)/im;
    const toolGrantsMatch = textDescription.match(toolGrantsRegex);

    const toolChoiceRegex = /(\w+) type of (.*)($|\.|\w+:)/i;
    if (toolGrantsMatch) {
      const grantsArray = toolGrantsMatch[1].split(",").map((grant) => grant.trim());
      for (const toolString of grantsArray) {
        const toolChoiceMatch = toolString.match(toolChoiceRegex);
        if (toolChoiceMatch) {
          const numberTools = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => toolChoiceMatch[1].toLowerCase() === num.natural);
          parsedTools.number = numberTools ? numberTools.num : 1;
          toolChoiceMatch[2].split(" or ").forEach((toolGroupMatch) => {
            const toolGroup = AdvancementHelper.getToolGroup(toolGroupMatch.trim());
            if (toolGroup) {
              parsedTools.choices.push(`${toolGroup}:*`);
            }
          });
        } else {
          const stub = AdvancementHelper.getToolAdvancementValue(toolString);
          if (stub) {
            parsedTools.grants.push(stub);
          }
        }
      }
      return parsedTools;
    }

    // no more matches, return.
    if (!textDescription.includes("proficiency")) return parsedTools;


    // You gain proficiency with alchemists supplies. If you already have this proficiency, you gain proficiency with one other type of artisans tools of your choice.
    // You also gain proficiency with smiths tools.
    // You gain proficiency with woodcarvers tools.
    // you gain proficiency with heavy armor and smiths tools
    // you gain proficiency with one type of artisans tools of your choice.
    // You gain proficiency with smiths tools, and you learn to speak, read, and write Giant.
    // and you gain proficiency with the herbalism kit.
    // You also gain proficiency with brewers supplies if you dont already have it.
    // you gain proficiency with the disguise kit and the poisoners kit.
    // you gain proficiency with the disguise kit, the forgery kit, and one gaming set of your choice.
    // you gain proficiency with Tinkers Tools

    const additionalMatchRegex = /You gain proficiency with (.*?)($|\.|\w+:)/im;
    const additionalMatch = textDescription.match(additionalMatchRegex);

    if (additionalMatch) {
      const additionalMatches = additionalMatch[2].replace(" and ", ",").split(",").map((skill) => skill.trim());
      for (const match of additionalMatches) {
        const toolChoiceRegex = /(\w+) (.*?) of your choice($|\.|\w+:)/i;
        const choiceMatch = textDescription.match(toolChoiceRegex);
        if (choiceMatch) {
          const numberTools = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => choiceMatch[1].toLowerCase() === num.natural);
          parsedTools.number = numberTools ? numberTools.num : 1;
          const toolGroup = AdvancementHelper.getToolGroup(choiceMatch[2]);
          if (toolGroup) {
            parsedTools.choices.push(`${toolGroup}:*`);
          }
        } else {
          const stub = AdvancementHelper.getToolAdvancementValue(match);
          if (stub) {
            parsedTools.grants.push(stub);
          }
        }
      }

      return parsedTools;
    }

    // You gain one skill proficiency of your choice, one tool proficiency of your choice, and fluency in one language of your choice.
    const featMatchRegex = /(\w*) tool proficiency of your choice/i;
    const featMatch = textDescription.match(featMatchRegex);

    if (featMatch) {
      parsedTools.number = 1;
      parsedTools.choices = ["*"];
      return parsedTools;
    }

    return parsedTools;
  }

  static ARMOR_GROUPS = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.filter */ .Z.character.proficiencies.filter((prof) => prof.type === "Armor" && foundry.utils.hasProperty(prof, "foundryValue") && prof.advancement === "")
    .reduce((acc, prof) => {
      acc[prof.name.toLowerCase()] = prof.foundryValue;
      return acc;
    }, {});

  static getArmorGroup(text) {
    for (const [key, value] of Object.entries(AdvancementHelper.ARMOR_GROUPS)) {
      if (_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(text).toLowerCase().includes(key)) return value;
    }
    return null;
  }

  static getDictionaryArmor(name) {
    const directMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) =>
      prof.type === "Armor" && foundry.utils.hasProperty(prof, "foundryValue")
      && prof.name.toLowerCase() === _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(name).toLowerCase()
    );
    if (directMatch) return directMatch;

    const dictionaryProfs = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.filter */ .Z.character.proficiencies.filter((prof) =>
      prof.type === "Armor" && foundry.utils.hasProperty(prof, "foundryValue")
    );
    for (const prof of dictionaryProfs) {
      if (_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(name).toLowerCase().includes(prof.name.toLowerCase())) return prof;
    }
    return null;
  }

  static getArmorAdvancementValue(text) {
    const match = AdvancementHelper.getDictionaryArmor(text);
    if (match) {
      const stub = match.advancement === ""
        ? match.foundryValue
        : `${match.advancement}:${match.foundryValue}`;
      return stub;
    }
    return null;
  }

  static parseHTMLArmorProficiencies(description) {
    const parsedArmorProficiencies = {
      choices: [],
      grants: [],
      number: 0,
    };
    const textDescription = AdvancementHelper.stripDescription(description);

    // Armor: None
    if (textDescription.includes("Armor: None")) return parsedArmorProficiencies;

    // Armor: Light armor, medium armor, shields
    // Armor: Light armor, medium armor, shields
    // Armor: All armor, shields
    const grantsRegex = /^Armor:\s(.*?)($|\.|\w+:)/im;
    const grantsMatch = textDescription.match(grantsRegex);

    if (grantsMatch) {
      const grantsArray = grantsMatch[1].split(",").map((grant) => grant.trim());
      for (const grant of grantsArray) {
        const stub = AdvancementHelper.getArmorAdvancementValue(grant);
        if (stub === "all") {
          parsedArmorProficiencies.grants.push("lgt", "med", "hvy");
        } else if (stub) {
          parsedArmorProficiencies.grants.push(stub);
        }
      }
      return parsedArmorProficiencies;
    }

    // no more matches, return.
    if (!textDescription.includes("proficiency")) return parsedArmorProficiencies;

    // You gain proficiency with heavy armor.
    // you gain proficiency with heavy armor and smiths tools
    // You gain proficiency with light armor, and you gain proficiency with one type of one-handed melee weapon of your choice.

    const additionalMatchRegex = /You gain proficiency with (.*?)($|\.|\w+:)/im;
    const additionalMatch = textDescription.match(additionalMatchRegex);

    if (additionalMatch) {
      const additionalMatches = additionalMatch[2].replace(" and ", ",").split(",").map((m) => m.trim());
      for (const grant of additionalMatches) {
        const stub = AdvancementHelper.getArmorAdvancementValue(grant);
        if (stub) {
          parsedArmorProficiencies.grants.push(stub);
        }
      }
    }

    return parsedArmorProficiencies;
  }

  static WEAPON_GROUPS = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.filter */ .Z.character.proficiencies.filter((prof) =>
      prof.type === "Weapon"
      && foundry.utils.getProperty(prof, "foundryValue") !== ""
      && prof.advancement === ""
    )
    .reduce((acc, prof) => {
      acc[prof.name.toLowerCase()] = prof.foundryValue;
      return acc;
    }, {});

  static getWeaponGroup(text) {
    for (const [key, value] of Object.entries(AdvancementHelper.WEAPON_GROUPS)) {
      if (_lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(text).toLowerCase().includes(key)) return value;
    }
    return null;
  }

  static getDictionaryWeapon(name) {
    const match = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.find */ .Z.character.proficiencies.find((prof) =>
      prof.type === "Weapon"
      && foundry.utils.getProperty(prof, "foundryValue") !== ""
      && (prof.name.toLowerCase() === _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(name).toLowerCase()
        || `${prof.name.toLowerCase()}s` === _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(name).toLowerCase()
        || `the ${prof.name.toLowerCase()}` === _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(name).toLowerCase())
    );
    if (match) return match;
    return null;
  }

  static getWeaponAdvancementValue(text) {
    const match = AdvancementHelper.getDictionaryWeapon(text);
    if (match) {
      const stub = match.advancement === ""
        ? match.foundryValue
        : `${match.advancement}:${match.foundryValue}`;
      return stub;
    }
    return null;
  }

  // eslint-disable-next-line complexity
  static parseHTMLWeaponProficiencies(description) {
    const parsedWeaponsProficiencies = {
      choices: [],
      grants: [],
      number: 0,
    };


    const textDescription = AdvancementHelper.stripDescription(description);

    // Weapons: None
    if (textDescription.includes("Weapons: None")) return parsedWeaponsProficiencies;

    // Weapons: Simple weapons, martial weapons
    // Weapons: Simple weapons
    // Weapons: Simple weapons, hand crossbows, longswords, rapiers, shortswords
    const weaponGrantsRegex = /^Weapons:\s(.*?)($|\.|\w+:)/im;
    const weaponGrantsMatch = textDescription.match(weaponGrantsRegex);

    const weaponChoiceRegex = /(\w+) type of (.*)($|\.|\w+:)/i;
    if (weaponGrantsMatch) {
      const grantsArray = weaponGrantsMatch[1].split(",").map((grant) => grant.trim());
      for (const toolString of grantsArray) {
        const weaponChoiceMatch = toolString.match(weaponChoiceRegex);
        if (weaponChoiceMatch) {
          const number = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => weaponChoiceMatch[1].toLowerCase() === num.natural);
          parsedWeaponsProficiencies.number = number ? number.num : 1;
          const group = AdvancementHelper.getWeaponGroup(weaponChoiceMatch[2]);
          if (group) {
            parsedWeaponsProficiencies.choices.push(`${group}:*`);
          }
        } else {
          const stub = AdvancementHelper.getWeaponAdvancementValue(toolString);
          if (stub) {
            parsedWeaponsProficiencies.grants.push(stub);
          }
        }
      }
      return parsedWeaponsProficiencies;
    }

    // no more matches, return.
    if (!textDescription.includes("proficiency")) return parsedWeaponsProficiencies;

    // you gain proficiency with medium armor and the scimitar.
    // You gain proficiency with martial weapons.
    // At 1st level, you gain proficiency with martial weapons and heavy armor.
    // You gain proficiency with light armor, and you gain proficiency with one type of one-handed melee weapon of your choice.
    // You gain proficiency with four weapons of your choice. Each one must be a simple or a martial weapon.
    const additionalMatchRegex = /You gain proficiency with (.*?)($|\.|\w+:)/im;
    const additionalMatch = textDescription.match(additionalMatchRegex);

    if (additionalMatch) {
      const additionalMatches = additionalMatch[2].replace(" and ", ",").split(",").map((skill) => skill.trim());
      for (const match of additionalMatches) {
        const toolChoiceRegex = /(\w+) (.*?) of your choice($|\.|\w+:)/i;
        const choiceMatch = textDescription.match(toolChoiceRegex);
        if (choiceMatch) {
          const numberTools = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((num) => choiceMatch[1].toLowerCase() === num.natural);
          parsedWeaponsProficiencies.number = numberTools ? numberTools.num : 1;
          const toolGroup = AdvancementHelper.getWeaponGroup(choiceMatch[2]);
          if (toolGroup) {
            parsedWeaponsProficiencies.choices.push(`${toolGroup}:*`);
            // eslint-disable-next-line max-depth
          } else if (choiceMatch[2].toLowerCase().includes("one-handed melee weapon")) {
            const weapons = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.filter */ .Z.character.proficiencies.filter((prof) =>
              prof.type === "Weapon"
              && foundry.utils.getProperty(prof, "foundryValue") !== ""
              && foundry.utils.getProperty(prof, "properties.two") !== true
              && foundry.utils.getProperty(prof, "melee") === true
            ).map((prof) => {
              const stub = prof.advancement === ""
                ? prof.foundryValue
                : `${prof.advancement}:${prof.foundryValue}`;
              return stub;
            });
            parsedWeaponsProficiencies.choices.push(...weapons);
          } else {
            _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn(`unknown weapon group choices ${choiceMatch[2]}`);
          }
        } else {
          const stub = AdvancementHelper.getWeaponAdvancementValue(match);
          if (stub) {
            parsedWeaponsProficiencies.grants.push(stub);
          }
        }
      }

      return parsedWeaponsProficiencies;
    }

    // Choose two types of weapons to be your kensei weapons: one melee weapon and one ranged weapon.
    const kenseiRegex = /Choose two types of weapons to be your kensei weapons/im;
    if (kenseiRegex.test(textDescription)) {
      parsedWeaponsProficiencies.number = 2;
      const weapons = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.proficiencies.filter */ .Z.character.proficiencies.filter((prof) =>
        prof.type === "Weapon"
        && foundry.utils.getProperty(prof, "foundryValue") !== ""
        && foundry.utils.getProperty(prof, "properties.spc") !== true
        && (foundry.utils.getProperty(prof, "properties.hvy") !== true || prof.name === "Longbow")
      ).map((prof) => {
        const stub = prof.advancement === ""
          ? prof.foundryValue
          : `${prof.advancement}:${prof.foundryValue}`;
        return stub;
      });
      parsedWeaponsProficiencies.choices.push(...weapons);
    }

    return parsedWeaponsProficiencies;
  }

  // static parseHTMLExpertises(description) {
  //   const parsedExpertises = {
  //     choices: [],
  //     grants: [],
  //     number: 2,
  //   };

  //   const dom = utils.htmlToDocumentFragment(description);

  //   // At 1st level, choose two of your skill proficiencies, or one of your skill proficiencies and your proficiency with thieves tools. Your proficiency bonus is doubled for any ability check you make that uses either of the chosen proficiencies.
  //   // At 6th level, you can choose two more of your proficiencies (in skills or with thieves tools) to gain this benefit.
  //   // At 3rd level, choose two of your skill proficiencies. Your proficiency bonus is doubled for any ability check you make that uses either of the chosen proficiencies.
  //   // At 6th level, choose two more of your skill proficiencies, or one more of your skill proficiencies and your proficiency with thieves tools. Your proficiency bonus is doubled for any ability check you make that uses either of the chosen proficiencies.
  // // Choose one skill in which you have proficiency. You gain expertise with that skill,
  // Your proficiency bonus is doubled for any check you make with the chosen skills.

  // parse expertises

  //   return parsedExpertises;
  // }

  static CONDITION_MAPPING = {
    "resistance": "dr",
    "immunity": "di",
    "immune": "di",
    "vulnerability": "dv",
    // "condition": "ci",
  };

  // eslint-disable-next-line complexity
  static parseHTMLConditions(description) {
    const grants = new Set();
    const choices = new Set();
    const parsedConditions = {
      choices: [],
      grants: [],
      number: 0,
      hint: "",
    };

    const textDescription = AdvancementHelper.stripDescription(description).toLowerCase();

    // quick and dirty damage matches, 90 % of use cases
    const isObviousDamage = textDescription.includes("damage");
    const adjustedText = textDescription.replaceAll(" damage", "");

    if (isObviousDamage) {
      // You have resistance to psychic damage
      // You have resistance to necrotic damage and radiant damage.
      // you gain resistance to lightning and thunder damage
      // You gain immunity to fire damage.
      // you gain immunity to lightning and thunder damage.
      // You also have resistance to psychic damage
      // and you have resistance to poison damage.
      // You have resistance to poison damage and immunity to disease, and you have advantage on saving throws against being paralyzed or poisoned.
      // you gain resistance to bludgeoning, piercing, and slashing damage from nonmagical attacks.
      // the paladin gains resistance to bludgeoning, piercing, and slashing damage from nonmagical weapons.
      // You gain resistance to acid damage and poison damage,
      // You also have resistance to poison damage.
      // You are immune to poison damage and the poisoned condition.
      // You have resistance to acid and poison damage, and you have advantage on saving throws against being poisoned.
      const damageRegex = /(?:you|the paladin) (?:also have|have|gains*|are) ([^advantage].*) to (.*?)($|\.|and you have advantage|\w+:)/im;
      const damageMatch = adjustedText.match(damageRegex);
      if (damageMatch) {
        const additionalMatches = damageMatch[2]
          .replace(" and ", ",").split(",")
          .map((dmg) => dmg.trim().toLowerCase());
        for (const match of additionalMatches) {
          const conditionKind = damageMatch[1].toLowerCase().trim();
          const damageMapping = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.damageAdjustments.find */ .Z.character.damageAdjustments.find((a) =>
            a.kind === conditionKind // only match the kind
            && a.type !== 4 // don't include conditions
            && match === a.name.toLowerCase()
          );
          if (damageMapping) {
            const type = AdvancementHelper.CONDITION_MAPPING[conditionKind];
            const valueData = foundry.utils.hasProperty(damageMapping, "foundryValues")
              ? foundry.utils.getProperty(damageMapping, "foundryValues")
              : foundry.utils.hasProperty(damageMapping, "foundryValue")
                ? { value: damageMapping.foundryValue }
                : undefined;
            // eslint-disable-next-line max-depth, no-continue
            if (!valueData) continue;
            const midiValues = game.modules.get("midi-qol")?.active && valueData.midiValues
              ? valueData.midiValues
              : [];
            const mappingValueArray = midiValues.concat(valueData.value).map((value) => value.toLowerCase());
            mappingValueArray.forEach((value) => {
              if (type) grants.add(`${type}:${value}`);
              if (type === "di" && value === "poison") {
                grants.add("ci:poisoned");
              }
            });
          }
        }
      }
    }

    const isImmunity = textDescription.includes("immunity") || textDescription.includes("immune");
    // You have resistance to poison damage and immunity to disease,
    // You are immune to being charmed,
    // you makes you immune to disease.
    // you makes you immune to disease and poison.
    // and you are immune to the poisoned condition.
    // You are immune to poison damage and the poisoned condition.
    // You are immune to disease.
    if (isImmunity) {
      const immuneRegex = /(?:you have|and|you are|makes you) (?:immune|immunity) to (.*?)($|\.|and you have advantage|\w+:)/im;
      const immuneMatch = textDescription.match(immuneRegex);
      if (immuneMatch) {
        let addPoisonDI = false;
        const additionalMatches = immuneMatch[1]
          .replace(" and ", ",")
          .split(",")
          .map((dmg) => {
            const result = dmg.trim().toLowerCase();
            if (dmg === "poison") {
              addPoisonDI = true;
              return "poisoned";
            } else if (dmg === "disease") return "diseased";
            else return result;
          });
        for (const match of additionalMatches) {
          const conditionMapping = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.damageAdjustments.find */ .Z.character.damageAdjustments.find((a) =>
            a.kind === "immunity" // only match the immunity kind
            && a.type === 4 // dont include damage adjustments
            && match === a.name.toLowerCase()
          );
          if (conditionMapping) {
            grants.add(`ci:${conditionMapping.foundryValue}`);
            // eslint-disable-next-line max-depth
            if (addPoisonDI && conditionMapping.foundryValue === "poisoned") grants.add("di:poison");
          }
        }
      }

    }

    // These are special types
    // You have resistance to the damage type associated with your * Ancestry.
    const dragonMatch = textDescription.match(/resistance to the damage type associated with your (\w*) Ancestry/mi);
    if (dragonMatch) {
      parsedConditions.count = 1;
      parsedConditions.hint = textDescription;
      switch (dragonMatch[1].toLowerCase()) {
        case "metallic": {
          ["fire", "lightning", "acid", "cold"].forEach((dr) => {
            if (textDescription.includes(dr)) {
              choices.add(`dr:${dr}`);
            }
          });
          break;
        }
        case "chromatic": {
          ["acid", "lightning", "poison", "fire", "cold"].forEach((dr) => {
            if (textDescription.includes(dr)) {
              choices.add(`dr:${dr}`);
            }
          });
          break;
        }
        case "gem": {
          ["force", "radiant", "psychic", "thunder", "necrotic"].forEach((dr) => {
            if (textDescription.includes(dr)) {
              choices.add(`dr:${dr}`);
            }
          });
          break;
        }
        default: {
          ["acid", "lightning", "poison", "fire", "acid", "cold"].forEach((dr) => {
            if (textDescription.includes(dr)) {
              choices.add(`dr:${dr}`);
            }
          });
          break;
        }
      }
    }

    // You now have resistance to a damage type determined by your patrons kind:
    if (textDescription.includes("resistance to a damage type determined by your patrons kind:")) {
      parsedConditions.count = 1;
      parsedConditions.hint = textDescription;
      ["bludgeoning", "thunder", "fire", "cold"].forEach((dr) => {
        if (textDescription.includes(dr)) {
          choices.add(`dr:${dr}`);
        }
      });
    }

    // You have resistance to all damage dealt by other creatures (their attacks, spells, and other effects).
    if (textDescription.includes("resistance to all damage dealt by other creatures")) {
      grants.add("dr:all");
      Object.keys(CONFIG.DND5E.damageTypes).forEach((dr) => {
        grants.add(`dr:${dr}`);
      });
    }

    // NOT IMPLEMENTED: Foundry doesn't support these kind of things they are not really condition resistances etc
    // and you have advantage on saving throws against being poisoned.
    // You and friendly creatures within 10 feet of you have resistance to damage from spells.
    // You have advantage on Intelligence, Wisdom, and Charisma saving throws against spells.
    // You have advantage on saving throws you make to avoid or end the poisoned condition on yourself.
    // You have advantage on saving throws against spells and other magical effects.
    // and you have advantage on saving throws against being paralyzed or poisoned.

    parsedConditions.grants = Array.from(grants);
    parsedConditions.choices = Array.from(choices);
    return parsedConditions;
  }

  // static parseHTMLEquipment(description) {
  //   const parsedEquipment = {
  //     choices: [],
  //     grants: [],
  //     number: 0,
  //   };
  //   const textDescription = AdvancementHelper.stripDescription(description);

  //   // You start with the following equipment, in addition to the equipment granted by your background:
  //   // any two simple weapons of your choice
  //   // a light crossbow and 20 bolts
  //   // your choice of studded leather armor or scale mail
  //   // thieves tools and a dungeoneers pack

  //   // You start with the following equipment, in addition to the equipment granted by your background:

  //   // (a) a greataxe or (b) any martial melee weapon
  //   // (a) two handaxes or (b) any simple weapon
  //   // An explorers pack and four javelins

  //   // parse equipment here

  //   return parsedEquipment;
  // }


  // static getEquipmentAdvancement(parts) {

  // }

}


/***/ }),

/***/ 2331:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "E": () => (/* binding */ generateBackground)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7669);
/* harmony import */ var _DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3163);




_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype.getBackgroundName */ .Z.prototype.getBackgroundName = function getBackgroundName() {
  if (this.source.ddb.character.background.hasCustomBackground === false) {
    if (this.source.ddb.character.background.definition !== null) {
      return this.source.ddb.character.background.definition.name || "";
    } else {
      return "";
    }
  } else {
    return this.source.ddb.character.background.customBackground.name || "";
  }
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateTrait */ .Z.prototype._generateTrait = function _generateTrait() {
  this.raw.character.system.details.trait = this.source.ddb.character.traits.personalityTraits ?? "";
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateIdeal */ .Z.prototype._generateIdeal = function _generateIdeal() {
  this.raw.character.system.details.ideal = this.source.ddb.character.traits.ideals ?? "";
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateBond */ .Z.prototype._generateBond = function _generateBond() {
  this.raw.character.system.details.bond = this.source.ddb.character.traits.bonds ?? "";
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateFlaw */ .Z.prototype._generateFlaw = function _generateFlaw() {
  this.raw.character.system.details.flaw = this.source.ddb.character.traits.flaws ?? "";
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype.getCharacteristics */ .Z.prototype.getCharacteristics = function getCharacteristics() {
  let characteristicBlurb = "";
  if (this.source.ddb.character.gender) characteristicBlurb += `Gender: ${this.source.ddb.character.gender}\n`;
  if (this.source.ddb.character.eyes) characteristicBlurb += `Eyes: ${this.source.ddb.character.eyes}\n`;
  if (this.source.ddb.character.height) characteristicBlurb += `Height: ${this.source.ddb.character.height}\n`;
  if (this.source.ddb.character.faith) characteristicBlurb += `Faith: ${this.source.ddb.character.faith}\n`;
  if (this.source.ddb.character.hair) characteristicBlurb += `Hair: ${this.source.ddb.character.hair}\n`;
  if (this.source.ddb.character.skin) characteristicBlurb += `Skin: ${this.source.ddb.character.skin}\n`;
  if (this.source.ddb.character.age) characteristicBlurb += `Age: ${this.source.ddb.character.age}\n`;
  if (this.source.ddb.character.weight) characteristicBlurb += `Weight: ${this.source.ddb.character.weight}\n`;
  return characteristicBlurb;
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateAppearance */ .Z.prototype._generateAppearance = function _generateAppearance() {
  let result = this.getCharacteristics();
  if (result && result !== "") result += "\n";
  if (this.source.ddb.character.traits.appearance) result += this.source.ddb.character.traits.appearance;
  this.raw.character.system.details.appearance = result ?? "";
};

/**
 * Gets the character's alignment
 * Defaults to Neutral, if not set in DDB
 * @todo: returns .name right now, should switch to .value once the DND5E options are fully implemented
 */
_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateAlignment */ .Z.prototype._generateAlignment = function _generateAlignment() {
  const alignmentID = this.source.ddb.character.alignmentId || 5;
  const alignment = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.alignments.find */ .Z.character.alignments.find((alignment) => alignment.id === alignmentID);
  if (alignment) this.raw.character.system.details.alignment = alignment.name;
};

function getBackgroundTemplate() {
  return {
    name: "Background",
    description: "",
    id: null,
    entityTypeId: null,
    featuresId: null,
    featuresEntityTypeId: null,
    characteristicsId: null,
    characteristicsEntityTypeId: null,
    definition: {
      name: "Background",
      description: "",
      id: null,
      entityTypeId: null,
    },
  };
}

function generateBackground(bg) {
  let result = getBackgroundTemplate();

  // console.warn(bg)

  if (bg.id) result.id = bg.id;
  if (bg.entityTypeId) result.entityTypeId = bg.entityTypeId;

  if (bg.name) {
    result.name = `Background: ${bg.name}`;
    result.description = `<h1>Background: ${bg.name}</h1>`;
  }

  if (bg.description) {
    result.description += `<p>${bg.description}</p>`;
  } else if (bg.shortDescription) {
    result.description += bg.shortDescription.replace("\r\n", "");
  }
  if (bg.definition) result.definition = bg.definition;
  if (bg.sources) result.definition.sources = bg.sources;

  if (bg.isHomebrew === true) {
    if (bg.featuresBackground) {
      result.description += `<h2>${bg.featuresBackground.name}</h2>`;
      result.description += bg.featuresBackground.shortDescription.replace("\r\n", "");
      result.description += `<h3>${bg.featuresBackground.featureName}</h3>`;
      result.description += bg.featuresBackground.featureDescription.replace("\r\n", "");
      result.featuresId = bg.featuresBackground.id;
      result.id = bg.featuresBackground.id;
      result.featuresEntityTypeId = bg.featuresBackground.entityTypeId;
      result.definition = bg.featuresBackground;
    }
    if (
      bg.characteristicsBackground
      && bg.featuresBackground
      && bg.featuresBackground.entityTypeId != bg.characteristicsBackground.entityTypeId
    ) {
      result.description += `<h2>${bg.characteristicsBackground.name}</h2>`;
      result.description += bg.characteristicsBackground.shortDescription.replace("\r\n", "");
      result.description += `<h3>${bg.characteristicsBackground.featureName}</h3>`;
      result.description += bg.characteristicsBackground.featureDescription.replace("\r\n", "");
      result.characteristicsId = bg.characteristicsBackground.id;
      result.characteristicsEntityTypeId = bg.characteristicsBackground.entityTypeId;
    }
  }

  if (bg.featureName) {
    result.description += `<h2>${bg.featureName}</h2>`;
    result.description += bg.featureDescription.replace("\r\n", "");
  }
  if (bg.spellListIds) result.spellListIds = bg.spellListIds;

  // update definition
  result.definition.name = result.name;
  result.description = _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].replaceHtmlSpaces */ .Z.replaceHtmlSpaces(result.description);
  result.definition.description = result.description;
  result.definition.id = result.id;
  result.definition.spellListIds = result.spellListIds;
  return result;
}

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype.getBackgroundData */ .Z.prototype.getBackgroundData = function getBackgroundData() {
  let bg = null;
  if (this.source.ddb.character.background.hasCustomBackground === true) {
    bg = this.source.ddb.character.background.customBackground;
    bg.isHomebrew = true;
  } else if (this.source.ddb.character.background.definition !== null) {
    bg = this.source.ddb.character.background.definition;
  } else {
    bg = this.source.ddb.character.background.customBackground;
    let result = getBackgroundTemplate();
    if (bg.id) {
      result.id = bg.id;
      result.definition.id = bg.id;
    }
    if (bg.entityTypeId) {
      result.entityTypeId = bg.entityTypeId;
      result.definition.entityTypeId = bg.entityTypeId;
    }
    return result;
  }

  return generateBackground(bg);
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateBiography */ .Z.prototype._generateBiography = function _generateBiography() {
  const backstory = this.source.ddb.character.notes.backstory
    ? "<h1>Backstory</h1><p>" + this.source.ddb.character.notes.backstory + "</p>"
    : "";

  this.raw.character.system.details.biography = {
    public: backstory,
    value: backstory,
  };
};

_DDBCharacter_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].prototype._generateDescription */ .Z.prototype._generateDescription = function _generateDescription() {
  this.raw.character.system.details["gender"] = this.source.ddb.character.gender || "";
  this.raw.character.system.details["age"] = this.source.ddb.character.age || "";
  this.raw.character.system.details["height"] = this.source.ddb.character.height || "";
  this.raw.character.system.details["weight"] = this.source.ddb.character.weight || "";
  this.raw.character.system.details["eyes"] = this.source.ddb.character.eyes || "";
  this.raw.character.system.details["skin"] = this.source.ddb.character.skin || "";
  this.raw.character.system.details["hair"] = this.source.ddb.character.hair || "";
};


/***/ }),

/***/ 2187:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PJ": () => (/* binding */ getAllClassFeatures),
/* harmony export */   "TP": () => (/* binding */ fixCharacterLevels)
/* harmony export */ });
/* unused harmony export getClassFeatures */
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);


/**
 * UTILITY
 * Returns a string representation of friendlyTypename and friendlySubtypeName for an obj[]
 * @param {object[]} arr array of objects
 */
function extractInfo(arr) {
  return arr.map((e) => `${e.friendlyTypeName} (${e.friendlySubtypeName})`);
}

/**
 * Extracts basic character information
 * @param {object} data Character JSON
 * returns information about the classes this character chose, including
 * - {string} name
 * - {number} level
 * - {boolean} isStartingClass
 * - {object[]} modifiers (empty, will be filled later)
 * }
 */
function getClassInfo(data) {
  return data.classes.map((cls) => {
    return {
      name:
        cls.subclassDefinition && cls.subclassDefinition.name
          ? `${cls.definition.name} (${cls.subclassDefinition.name})`
          : cls.definition.name,
      level: cls.level,
      isStartingClass: cls.isStartingClass,
      modifiers: [],
    };
  });
}

/**
 * Gets all class features up to a certain class level
 * @param {obj} cls character.classes[] entry
 * @param {*} classLevel level requirement up to which the class features should be extracted
 */
function getClassFeatures(cls, classLevel = 20) {
  if (
    cls.subclassDefinition
    && cls.subclassDefinition.classFeatures
    && Array.isArray(cls.subclassDefinition.classFeatures)
  ) {
    const subclassFeatures = cls.subclassDefinition.classFeatures.map((subclassFeature) => {
      subclassFeature.className = cls.definition.name;
      subclassFeature.subclassName = cls.subclassDefinition.name;
      return subclassFeature;
    });
    const result = cls.classFeatures
      .map((feature) => {
        const f = feature.definition;
        f.className = cls.definition.name;
        f.subclassName = null;
        return f;
      })
      .concat(subclassFeatures)
      .filter((classFeature) => classFeature.requiredLevel <= classLevel)
      .sort((a, b) => a.requiredLevel - b.requiredLevel);
    return result;
  } else {
    const result = cls.classFeatures
      .map((feature) => {
        const f = feature.definition;
        f.className = cls.definition.name;
        f.subclassName = null;
        return f;
      })
      .filter((classFeature) => classFeature.requiredLevel <= classLevel)
      .sort((a, b) => a.requiredLevel - b.requiredLevel);
    return result;
  }
}


/**
 * Checks if a given class is the starting class of this character
 * @param {object} data character data
 * @param {string} className name of the class to check
 * @returns {boolean} true of the class is a starting class, false otherwise
 */
function isStartingClass(data, className) {
  return data.classes.find((cls) => cls.definition.name === className && cls.isStartingClass);
}

/**
 * Gets all class modifiers for a given character
 * This filters out all modifiers that do not have an entry in the class features passed in
 * For multiclassing characters, it checks if the given class is the starting class or a multiclass,
 *    then the `.availableToMulticlass` is queried if this modifier is enabled or not
 * @param {obj} cls character.classes[] entry
 * @param {*} classLevel level requirement up to which the class features should be extracted
 */
function getClassModifiers(data, classFeatures, isStartingClass = false) {
  const modifiers = data.modifiers.class.filter((classModifier) => {
    // check the class from which this modifier came
    const feature = classFeatures.find((feature) => feature.id === classModifier.componentId);
    if (feature !== undefined) {
      const isFeatureAvailable = classModifier.availableToMulticlass ? true : isStartingClass;
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(
        `${isFeatureAvailable ? "  [  AVAIL]" : "  [UNAVAIL]"} Modifier found: ${classModifier.friendlyTypeName} (${
          classModifier.friendlySubtypeName
        })`
      );
      return isFeatureAvailable;
    }
    return false;
  });

  return modifiers;
}

function getAllClassFeatures(data) {
  return data.classes
    .map((cls) => {
      return getClassFeatures(cls, cls.level);
    })
    .flat();
}

function getClassOptionModifiers(data) {
  const classFeatures = getAllClassFeatures(data);

  const modifiers = data.modifiers.class.filter((classModifier) => {
    const componentId = classModifier.componentId;
    const feature = classFeatures.find((feature) => feature.id === componentId);

    if (feature === undefined) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Modifier found: ${classModifier.friendlyTypeName} (${classModifier.friendlySubtypeName})`);
      return true;
    }
    return false;
  });

  return modifiers;
}

/**
 * Filters the modifiers with the utility functions above
 * @param {object} data character data
 * @returns {[object[]]} an array containing an array of filtered modifiers, grouped by class
 */
function filterModifiers(data, classInfo) {
  // get the classFeatures for all classes
  data.classes.forEach((cls, index) => {
    const features = getClassFeatures(cls, cls.level);
    classInfo[index].modifiers = getClassModifiers(data, features, isStartingClass(data, cls.definition.name));
  });
  return classInfo;
}

function fixCharacterLevels(data) {
  data.unfilteredModifiers = foundry.utils.deepClone(data.character.modifiers);
  const classInfo = getClassInfo(data.character);
  const filteredClassInfo = filterModifiers(data.character, classInfo);
  let classModifiers = getClassOptionModifiers(data.character, classInfo);

  filteredClassInfo.forEach((cls) => {
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`${cls.isStartingClass ? "Starting Class" : "Multiclass"}: [lvl${cls.level}] ${cls.name} `);
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(
      extractInfo(cls.modifiers)
        .map((s) => `    ${s}`)
        .join("\n")
    );
    classModifiers = classModifiers.concat(cls.modifiers);
  });
  data.character.modifiers.class = classModifiers;
  return data;
}


/***/ }),

/***/ 1126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBCompanion)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(546);
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8636);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5259);
/* harmony import */ var _DDBMonster_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3433);
/* harmony import */ var _DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4029);
/* harmony import */ var _monster_features_DDBMonsterFeatureFactory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2676);
/* harmony import */ var _monster_templates_monster_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1309);









class DDBCompanion {

  constructor(block, options = {}) {
    // console.warn("DDBCompanion", { block });
    this.options = options;
    this.block = block;
    this.blockDatas = this.block.querySelectorAll("p.Stat-Block-Styles_Stat-Block-Data");
    this.npc = null;
    this.data = {};
    this.parsed = false;
    this.type = this.options.type;

    this.useItemAC = false; // game.settings.get("ddb-importer", "munching-policy-monster-use-item-ac");
    this.legacyName = false; // game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    this.addMonsterEffects = true; // game.settings.get("ddb-importer", "munching-policy-add-monster-effects");
    this.removeSplitCreatureActions = true;
    this.removeCreatureOnlyNames = true;
    this.addChrisPremades = true;

    this.summons = {
      match: {
        proficiency: false,
        attacks: false,
        saves: false,
      },
      bonuses: {
        ac: "",
        hp: "",
        attackDamage: "",
        saveDamage: "",
        healing: "",
      },
      profiles: [],
      prompt: true,
    };
  }

  static async addEnrichedImageData(document) {
    const tier = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getPatreonTier */ .Z.getPatreonTier();
    const tiers = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].calculateAccessMatrix */ .Z.calculateAccessMatrix(tier);
    if (!tiers.all || _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].isCustom */ .Z.isCustom()) return document;
    const name = document.name;
    // this endpoint is not supported in custom proxies
    if (!CONFIG.DDBI.EXTRA_IMAGES) {
      const path = "/proxy/enriched/actor/images";
      const parsingApi = _lib_DDBProxy_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getProxy */ .Z.getProxy();
      const response = await fetch(`${parsingApi}${path}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        }
      });

      const j = await response.json();
      if (!j.success) return document;
      foundry.utils.setProperty(CONFIG, "DDBI.EXTRA_IMAGES", j.data);
    }

    if (!foundry.utils.hasProperty(CONFIG, "DDBI.EXTRA_IMAGES.summons")) return document;
    const data = CONFIG.DDBI.EXTRA_IMAGES.summons[name]
      ?? CONFIG.DDBI.EXTRA_IMAGES.summons[name.split("(")[0].trim()];

    if (!data) return document;

    if (data.monsterIDs && data.monsterIDs.length > 0) {
      const monsterFactory = new _DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z({ type: "summons" });

      await monsterFactory.fetchDDBMonsterSourceData(_DDBMonsterFactory_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defaultFetchOptions */ .Z.defaultFetchOptions(data.monsterIDs));

      for (const monsterSource of monsterFactory.source) {
        const img = monsterSource.basicAvatarUrl ?? monsterSource.largeAvatarUrl ?? monsterSource.avatarUrl;
        const tokenImg = monsterSource.avatarUrl;
        foundry.utils.setProperty(document, "flags.monsterMunch.tokenImg", tokenImg);
        foundry.utils.setProperty(document, "flags.monsterMunch.img", img);
        return document;
      }
    }
    if (data.actor) {
      foundry.utils.setProperty(document, "flags.monsterMunch.img", data.actor);
    }
    if (data.token) {
      foundry.utils.setProperty(document, "flags.monsterMunch.tokenImg", data.token);
    }

    // future enhancement loop through the downloaded compendium monsters for image
    return document;
  }

  #generateAbilities() {
    const abilityNodes = this.block.querySelector("div.stat-block-ability-scores");

    abilityNodes.querySelectorAll("div.stat-block-ability-scores-stat").forEach((aNode) => {
      const ability = aNode.querySelector("div.stat-block-ability-scores-heading").innerText.toLowerCase();

      const getFallbackAbility = () => {
        const clone = aNode.querySelector("div.stat-block-ability-scores-data").cloneNode(true);
        clone.getElementsByTagName("span")[0].innerHTML = "";
        return clone.innerText.trim();
      };

      const abilityScore = aNode.querySelector("span.stat-block-ability-scores-score")?.innerText
        ?? getFallbackAbility();

      const value = Number.parseInt(abilityScore);
      const mod = CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;

      this.npc.system.abilities[ability]['value'] = value;
      this.npc.system.abilities[ability]['mod'] = mod;
    });
  }

  getBlockData(type) {
    const block = Array.from(this.blockDatas).find((el) => {
      const elementName = el.innerText.trim();
      const elementStartsWith = elementName.startsWith(type);
      const isOnly = elementName.toLowerCase().includes("only")
        ? elementName.toLowerCase().includes(this.options.subType.toLowerCase())
        : true;
      return elementStartsWith && isOnly;
    });
    if (!block) return undefined;

    const header = block.getElementsByTagName("strong")[0].innerText.toLowerCase();
    if (header.includes("only") && !header.includes(this.options.subType.toLowerCase())) {
      return undefined;
    }

    const clone = block.cloneNode(true);
    clone.getElementsByTagName("strong")[0].innerHTML = "";
    return clone.innerText.trim();
  }

  // savings throws
  #generateSavingThrows() {
    const saveString = this.getBlockData("Saving Throws");
    if (!saveString) return;

    const saves = saveString.split(",");

    saves.forEach((save) => {
      const ability = save.trim().split(" ")[0].toLowerCase();
      if (save.includes("plus PB") || save.includes("+ PB")) {
        this.npc.system.abilities[ability]['proficient'] = 1;
      }
    });
  }

  #generateArmorClass() {
    const acString = this.getBlockData("Armor Class");
    if (!acString) return;

    const ac = Number.parseInt(acString.split(",")[0]);

    if (Number.isInteger(ac)) {
      this.npc.system.attributes.ac = {
        flat: ac,
        calc: "natural",
        formula: "",
      };

      if (acString.includes("plus PB") || acString.includes("+ PB")) {
        this.summons.bonuses.ac = "@prof";
      } else if (acString.includes("+ the level of the spell")) {
        this.summons.bonuses.ac = "@item.level";
      }
    }
  }

  #generateProficiencyBonus() {
    const profString = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Data-Last")
      ?? this.getBlockData("Challenge");

    if (profString && profString.innerText.includes("equals your bonus")) {
      this.summons.match.proficiency = true;
    }
  }


  #getBaseHitPoints(hpString) {
    const baseString = this.options.subType && hpString.includes(" or ")
      ? hpString.split("or").find((s) => s.toLowerCase().includes(this.options.subType.toLowerCase()))
      : hpString.trim();

    const hpFind = baseString.trim().match(/(\d*)/);
    const hpInt = Number.parseInt(hpFind);
    return Number.isInteger(hpInt) ? hpInt : 0;
  }

  #generateHitPoints() {
    const hpString = this.getBlockData("Hit Points");
    if (!hpString) return;

    const hpInt = this.#getBaseHitPoints(hpString);
    this.npc.system.attributes.hp.max = hpInt;
    this.npc.system.attributes.hp.value = hpInt;

    // conditions
    // 5 + five times your druid level
    // 5 + five times your ranger level (the beast has a number of Hit Dice [d8s] equal to your ranger level)
    // 1 + your Intelligence modifier + your artificer level (the homunculus has a number of Hit Dice [d4s] equal to your artificer level)
    // 40 + 15 for each spell level above 4th
    // 20 (Air only) or 30 (Land and Water only) + 5 for each spell level above 2nd
    // 50 (Demon only) or 40 (Devil only) or 60 (Yugoloth only) + 15 for each spell level above 6th
    // 30 (Ghostly and Putrid only) or 20 (Skeletal only) + 10 for each spell level above 3rd

    // additional summon points
    const hpAdjustments = [];
    const modMatch = hpString.match(/\+ your (\w+) modifier/);

    if (modMatch) hpAdjustments.push(`@abilities.${modMatch[1].toLowerCase().substring(0, 3)}.mod`);

    // class level
    const klassMultiMatch = hpString.match(/\+ (\w+)?( times? )?your (\w+) level/);
    if (klassMultiMatch) {
      const klass = klassMultiMatch[3].trim().toLowerCase();
      const multiplier = klassMultiMatch[1]
        ? _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].numbers.find */ .Z.numbers.find((d) => d.natural === klassMultiMatch[1].trim().toLowerCase()).num
        : null;
      const multiplierString = multiplier ? ` * ${multiplier}` : "";
      hpAdjustments.push(`(@classes.${klass}.levels${multiplierString})`);
    }

    // spell level
    const spellLevelMatch = hpString.match(/\+ (\d+) for each spell level above (\d)/);
    if (spellLevelMatch) {
      hpAdjustments.push(`(${spellLevelMatch[1]} * (@item.level - ${spellLevelMatch[2]}))`);
    }

    if (hpAdjustments.length > 0) {
      this.summons.bonuses.hp = hpAdjustments.join(" + ");
    }

  }

  #generateHitDie() {
    // (the beast has a number of Hit Dice [d8s] equal to your ranger level)
    // (the homunculus has a number of Hit Dice [d4s] equal to your artificer level)
    const hpString = this.getBlockData("Hit Points");
    if (!hpString || !hpString.includes("number of Hit Dice")) return;

    const hitDice = hpString.match(/Hit Dice \[d(\d)s\] equal to your (\w+) level/);
    if (hitDice) {
      const hitDiceAdjustment = {
        "key": "system.attributes.hp.formula",
        "value": `(@classes.${hitDice[2]}.levels)[d${hitDice[1]}]`
      };
      this.npc.flags.ddbimporter.summons.changes.push(hitDiceAdjustment);
    }
  }

  #generateSkills() {
    const skillString = this.getBlockData("Skills");
    if (!skillString) return;
    //  "History + 12, Perception +0 plus PB &times; 2"
    const skillsMaps = skillString.split(",").filter((str) => str != '').map((str) => {
      const skillMatch = str.trim().match(/(\w+ *\w* *\w*)(?: *)([+-])(?: *)(\d+) *(plus PB)? *(&times;|x|times)? *(\d*)?/);
      let result = {};
      if (skillMatch) {
        result = {
          name: skillMatch[1].trim(),
          value: skillMatch[2] + skillMatch[3],
          proficient: skillMatch[4] !== undefined,
          expertise: Number.isInteger(skillMatch[5]?.trim()),
          pbMultiplier: skillMatch[5],
        };
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(`Found skill for companion ${this.npc.name}`, result);
      } else {
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error(`Skill Parsing failed for ${this.npc.name}`);
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(skillString);
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(str);
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(skillMatch);
      }
      return result;
    });

    const keys = Object.keys(this.npc.system.skills);
    const validSkills = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.map */ .Z.character.skills.map((skill) => skill.name);
    keys
      .filter((key) => validSkills.includes(key))
      .forEach((key) => {
        let skill = this.npc.system.skills[key];
        const lookupSkill = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.find */ .Z.character.skills.find((s) => s.name == key);
        const skillData = skillsMaps.find((skl) => skl.name == lookupSkill.label);

        if (skillData) {
          skill.value = skillData.expertise ? 2 : skillData.proficient ? 1 : 0;
          const ability = this.npc.system.abilities[skill.ability];
          if (parseInt(ability.mod) !== parseInt(skillData.value.trim())) {
            skill.bonuses.check = parseInt(skillData.value.trim()) - parseInt(ability.mod);
            skill.bonuses.passive = parseInt(skillData.value.trim()) - parseInt(ability.mod);
          }

          this.npc.system.skills[key] = skill;
        }

      });
  }

  #generateSize() {
    const data = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Metadata").innerHTML;

    if (!data) return;
    const size = data.split(" ")[0];
    const sizeData = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].sizes.find */ .Z.sizes.find((s) => size.toLowerCase() == s.name.toLowerCase())
      ?? { name: "Medium", value: "med", size: 1 };

    this.npc.system.traits.size = sizeData.value;
    this.npc.prototypeToken.width = sizeData.size >= 1 ? sizeData.size : 1;
    this.npc.prototypeToken.height = sizeData.size >= 1 ? sizeData.size : 1;
    this.npc.prototypeToken.scale = sizeData.size >= 1 ? 1 : sizeData.size;
  }

  #generateType() {
    const data = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Metadata").innerHTML;
    if (!data) return;
    const typeName = data.split(",")[0].split(" ").pop().toLowerCase();

    if (CONFIG.DND5E.creatureTypes[typeName]) {
      this.npc.system.details.type.value = typeName;
    } else {
      this.npc.system.details.type.value = "Unknown";
    }
  }

  #generateAlignment() {
    const data = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Metadata").innerHTML;
    if (!data) return;
    const alignment = data.split(",").pop().toLowerCase().trim();

    if (alignment && alignment !== "") this.npc.system.details.alignment = alignment;
  }

  static getDamageAdjustments(data) {
    const values = [];
    const custom = [];
    const bypasses = [];
    const damageTypes = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].actions.damageType.filter */ .Z.actions.damageType.filter((d) => d.name !== null).map((d) => d.name);

    data.forEach((adj) => {
      if (damageTypes.includes(adj.toLowerCase())) {
        values.push(adj.toLowerCase());
      } else if (adj.includes("physical")) {
        values.push("bludgeoning", "piercing", "slashing");
        bypasses.push("mgc");
      } else {
        custom.push(adj);
      }
    });

    const adjustments = {
      value: values,
      bypasses,
      custom: custom.join("; "),
    };

    return adjustments;
  }

  filterDamageConditions(data) {
    const onlyFiltered = data.split(/[;,]/).filter((state) => {
      if (state.includes("only")) {
        if (state.toLowerCase().includes(this.options.subType.toLowerCase())) {
          return true;
        } else {
          return false;
        }
      } else {
        return true;
      }
    });

    const conditions = [];

    onlyFiltered.forEach((state) => {
      const results = state
        .split("and")
        .map((s) => {
          if (s.includes("determined by the")) {
            return this.options.subType.toLowerCase();
          } else {
            return s.split("(")[0].trim().toLowerCase();
          }
        });
      conditions.push(...results);
    });

    return conditions;
  }

  // Damage Resistances acid (Water only); lightning and thunder (Air only); piercing and slashing (Earth only)
  // Damage Immunities poison; fire (Fire only)
  // Damage Immunities necrotic, poison
  // Condition Immunities exhaustion, frightened, paralyzed, poisoned
  #generateImmunities() {
    const data = this.getBlockData("Damage Immunities");
    if (!data) return;

    this.npc.system.traits.di = DDBCompanion.getDamageAdjustments(this.filterDamageConditions(data));
  }

  #generateResistances() {
    const data = this.getBlockData("Damage Resistances");
    if (!data) return;

    this.npc.system.traits.dr = DDBCompanion.getDamageAdjustments(this.filterDamageConditions(data));
  }

  #generateVulnerabilities() {
    const data = this.getBlockData("Damage Vulnerabilities");
    if (!data) return;

    this.npc.system.traits.dv = DDBCompanion.getDamageAdjustments(this.filterDamageConditions(data));
  }

  // Condition Immunities exhaustion, frightened, paralyzed, poisoned
  #generateConditions() {
    const data = this.getBlockData("Condition Immunities");
    if (!data) return;

    let values = [];
    let custom = [];

    data.split(",").forEach((adj) => {
      const valueAdjustment = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].conditions.find */ .Z.conditions.find((condition) => condition.label.toLowerCase() == adj.trim().toLowerCase());
      if (valueAdjustment) {
        values.push(valueAdjustment.foundry);
      } else {
        custom.push(adj);
      }
    });

    // Condition Immunities charmed, exhaustion, frightened, incapacitated, paralyzed, petrified, poisoned
    this.npc.system.traits.ci = {
      value: values,
      custom: custom.join("; "),
    };
  }

  #generateSenses() {
    const data = this.getBlockData("Senses");
    if (!data) return;

    // darkvision 60 ft., passive Perception 10 + (PB &times; 2)
    // darkvision 60 ft., passive Perception 10 + (PB  2)

    data.split(",").forEach((sense) => {
      const match = sense.match(/(darkvision|blindsight|tremorsense|truesight)\s+(\d+)/i);

      if (match) {
        const value = parseInt(match[2]);
        this.npc.system.attributes.senses["units"] = "ft";
        this.npc.system.attributes.senses[match[1].toLowerCase()] = value;

        const senseType = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].senseMap */ .Z.senseMap()[match[1].toLowerCase()];

        if (value > 0 && value > this.npc.prototypeToken.sight.range && foundry.utils.hasProperty(CONFIG.Canvas.visionModes, senseType)) {
          foundry.utils.setProperty(this.npc.prototypeToken.sight, "visionMode", senseType);
          foundry.utils.setProperty(this.npc.prototypeToken.sight, "range", value);
          this.npc.prototypeToken.sight = foundry.utils.mergeObject(this.npc.prototypeToken.sight, CONFIG.Canvas.visionModes[senseType].vision.defaults);
        }
        if (value > 0 && foundry.utils.hasProperty(_dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].detectionMap */ .Z.detectionMap, match[1].toLowerCase())) {
          const detectionMode = {
            id: _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].detectionMap */ .Z.detectionMap[match[1].toLowerCase()],
            range: value,
            enabled: true,
          };

          // only add duplicate modes if they don't exist
          if (!this.npc.prototypeToken.detectionModes.some((mode) => mode.id === detectionMode.id)) {
            this.npc.prototypeToken.detectionModes.push(detectionMode);
          }
        }
      }
    });
  }

  #generateLanguages() {
    const data = this.getBlockData("Languages");
    if (!data) return;

    // loop back to add small chance they have non-custom language support
    this.npc.system.traits.languages.custom = data;
  }

  #generateSpeed() {
    const data = this.getBlockData("Speed");
    if (!data) return;

    // 30 ft.; fly 40 ft. (hover) (Ghostly only)
    // 40 ft.; climb 40 ft. (Demon only); fly 60 ft. (Devil only)
    // 30 ft., fly 40 ft.

    const onlyFiltered = data.split(/[;,]/).filter((speed) => {
      if (speed.includes("only")) {
        if (speed.toLowerCase().includes(this.options.subType.toLowerCase())) {
          return true;
        } else {
          return false;
        }
      } else {
        return true;
      }
    });

    const speeds = [];
    onlyFiltered.forEach((state) => {
      const results = state
        .split("and")
        .map((s) => {
          return s.trim().toLowerCase();
        });
      speeds.push(...results);
    });

    speeds.forEach((speed) => {
      const match = speed.match(/(\w+ )*(\d+)/i);
      if (match) {
        const type = match[1]?.trim() ?? "walk";
        this.npc.system.attributes.movement[type] = parseInt(match[2]);
        if (speed.includes("hover")) this.npc.system.attributes.movement["hover"] = true;
      }
    });
  }


  async getFeature(text, type) {
    const options = { extra: true, useItemAC: this.useItemAC, legacyName: this.legacyName, addMonsterEffects: this.addMonsterEffects, addChrisPremades: this.addChrisPremades };
    const ddbMonster = new _DDBMonster_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(null, options);
    ddbMonster.name = this.name;
    ddbMonster.npc = foundry.utils.duplicate(this.npc);
    ddbMonster.abilities = ddbMonster.npc.system.abilities;
    ddbMonster.proficiencyBonus = 0;
    const featureFactory = new _monster_features_DDBMonsterFeatureFactory_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z({ ddbMonster, hideDescription: false, updateExisting: false });
    await featureFactory.generateActions(text, type);
    _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug("Generating companion feature", { text, type, featureFactory });
    const toHitRegex = /(your spell attack modifier to hit)/i;
    if (toHitRegex.test(text)) {
      this.summons.match.attacks = true;
    }
    const spellSaveRegex = /(against your spell save DC)/i;
    if (spellSaveRegex.test(text)) {
      this.summons.match.saves = true;
    }
    return featureFactory.getFeatures(type);
  }


  async #processFeatureElement(element, featType) {
    let next = element.nextElementSibling;

    if (!next) return { next, featType };

    switch (next.innerText.trim().toLowerCase()) {
      case "action":
      case "actions":
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug("Companion parsing switching to actions");
        return { next, featType: "action" };
      case "reaction":
      case "reactions":
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug("Companion parsing switching to reactions");
        return { next, featType: "reaction" };
      case "bonus actions":
      case "bonus":
      case "bonus action":
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug("Companion parsing switching to bonus actions");
        return { next, featType: "bonus" };
      // no default
    }

    const features = await this.getFeature(next.outerHTML, featType);
    features.forEach((feature) => {
      if (this.removeSplitCreatureActions && feature.name.toLowerCase().includes("only")
        && feature.name.toLowerCase().includes(this.options.subType.toLowerCase())
      ) {
        if (this.removeCreatureOnlyNames) feature.name = feature.name.split("only")[0].split("(")[0].trim();
        this.npc.items.push(feature);
      } else if (!this.removeSplitCreatureActions || !feature.name.toLowerCase().includes("only")) {
        this.npc.items.push(feature);
      }
      if (foundry.utils.getProperty(feature, "flags.ddbimporter.levelBonus")) {
        this.summons.bonuses.attackDamage = "@item.level";
        this.summons.bonuses.saveDamage = "@item.level";
      }
    });
    return { next, featType };
  }

  async #generateFeatures() {

    const data = this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Data-Last");
    if (!data) {
      _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error(`Unable to parse ${this.npc.name} features and actions`, { this: this });
      return;
    }

    let now = data;
    let featType = "special";
    while (now !== null) {
      const result = await this.#processFeatureElement(now, featType);
      now = result.next;
      featType = result.featType;
    }
  }

  // #extraFeatures() {
  // if (this.name === "Drake Companion") {
  //   this.npc.flags["arbron-summoner"].config.actorChanges.push(
  //     {
  //       "key": "system.traits.size",
  //       "value": `@classes.ranger.levels > 6 ? "med" : "${sizeData.value}"`,
  //     },
  //     {
  //       "key": "prototypeToken.width",
  //       "value": `@classes.ranger.levels > 6 ? 1 : ${this.npc.prototypeToken.width}`,
  //     },
  //     {
  //       "key": "prototypeToken.height",
  //       "value": `@classes.ranger.levels > 6 ? 1 : ${this.npc.prototypeToken.height}`,
  //     },
  //     {
  //       "key": "prototypeToken.scale",
  //       "value": `@classes.ranger.levels > 6 ? 1 : ${this.npc.prototypeToken.scale}`,
  //     },
  //   );
  // }
  // }

  async parse() {
    // console.warn("PARSE COMPANION", { block: this.block, aThis: this });
    const name = this.options.name ?? this.block.querySelector("p.Stat-Block-Styles_Stat-Block-Title").innerHTML;
    const namePostfix = this.options.subType
      ? `(${this.options.subType})`
      : "";

    if (!name) return;
    this.name = name;
    _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(`Beginning companion parse for ${name}`, { name, block: this.block });

    const actorName = `${name} ${namePostfix}`.trim();
    this.npc = await (0,_monster_templates_monster_js__WEBPACK_IMPORTED_MODULE_7__/* .newNPC */ .N)(actorName);
    foundry.utils.setProperty(this.npc, "flags.ddbimporter.companion.modifiers", {});
    this.npc.prototypeToken.name = actorName;

    foundry.utils.setProperty(this.npc, "flags.ddbimporter.summons.changes", []);
    foundry.utils.setProperty(this.npc, "flags.ddbimporter.summons.name", `${name}`);
    foundry.utils.setProperty(this.npc, "flags.ddbimporter.id", `companion-${actorName}`);
    foundry.utils.setProperty(this.npc, "flags.ddbimporter.entityTypeId", `companion-${this.type}`);

    this.#generateSize();
    this.#generateType();
    this.#generateAbilities();
    this.#generateSavingThrows();
    this.#generateArmorClass();
    this.#generateProficiencyBonus();
    this.#generateHitPoints();
    this.#generateHitDie();
    this.#generateSkills();
    this.#generateImmunities();
    this.#generateResistances();
    this.#generateVulnerabilities();
    this.#generateConditions();
    this.#generateAlignment();
    this.#generateSenses();
    this.#generateLanguages();
    this.#generateSpeed();
    await this.#generateFeatures();

    // make friendly
    foundry.utils.setProperty(this.npc, "prototypeToken.disposition", 1);

    const data = await DDBCompanion.addEnrichedImageData(foundry.utils.duplicate(this.npc));

    this.data = data;
    this.parsed = true;

    _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(`Finished companion parse for ${name}`, { name, block: this.block, data: this.data, npc: this.npc });
  }

}


/***/ }),

/***/ 3972:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBCompanionFactory)
/* harmony export */ });
/* harmony import */ var _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7407);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5259);
/* harmony import */ var _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6968);
/* harmony import */ var _muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9633);
/* harmony import */ var _DDBCompanion_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1126);
/* harmony import */ var _vendor_lowdash_isequal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(846);
/* harmony import */ var _DDBSummonsManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6843);









class DDBCompanionFactory {

  constructor(html, options = {}) {
    // console.warn("html", html);
    this.options = options;
    this.html = html;
    this.doc = new DOMParser().parseFromString(html.replaceAll("\n", ""), 'text/html');
    this.companions = [];
    this.actor = this.options.actor;
    this.folderIds = new Set();
    this.updateCompanions = true; //  game.settings.get("ddb-importer", "munching-policy-update-existing");
    this.updateImages = false; // game.settings.get("ddb-importer", "munching-policy-update-images");
    this.results = {
      created: [],
      updated: [],
    };
    this.originDocument = options.originDocument;
    this.summons = null;
    this.badSummons = false;
    this.noCompendiums = options.noCompendiums ?? false;
    this.indexFilter = { fields: [
      "name",
      "flags.ddbimporter.compendiumId",
      "flags.ddbimporter.id",
      "flags.ddbimporter.summons",
    ] };
    this.summonsManager = new _DDBSummonsManager_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z();
    this.itemHandler = null;
  }

  async init() {
    await this.summonsManager.init();
    this.itemHandler = this.summonsManager.itemHandler;
  }

  get data() {
    return this.options.data ?? this.companions.map((c) => c.data);
  }

  static MULTI = {
    "Aberrant Spirit": ["Slaad", "Beholderkin", "Star Spawn"],
    "Bestial Spirit": ["Air", "Land", "Water"],
    "Celestial Spirit": ["Avenger", "Defender"],
    "Construct Spirit": ["Clay", "Metal", "Stone"],
    "Elemental Spirit": ["Air", "Earth", "Fire", "Water"],
    "Fey Spirit": ["Fuming", "Mirthful", "Tricksy"],
    "Fiendish Spirit": ["Demon", "Devil", "Yugoloth"],
    "Shadow Spirit": ["Fury", "Despair", "Fear"],
    "Undead Spirit": ["Ghostly", "Putrid", "Skeletal"],
    "Drake Companion": ["Acid", "Cold", "Fire", "Lightning", "Poison"],
    "Draconic Spirit": ["Chromatic", "Gem", "Metallic"],
    // "Primal Companion": ["Beast of the Land", "Beast of the Sea", "Beast of the Sky"],
  };

  async #buildCompanion(block, options = {}) {
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Beginning companion parse", { block });
    const ddbCompanion = new _DDBCompanion_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z(block, foundry.utils.mergeObject(options, { type: this.options.type }));
    await ddbCompanion.parse();
    if (ddbCompanion.parsed) {
      this.companions.push(ddbCompanion);
      const companionSummons = foundry.utils.deepClone(ddbCompanion.summons);
      const existingSummons = this.summons
        ? foundry.utils.deepClone(this.summons)
        : null;
      const summonMatch = (0,_vendor_lowdash_isequal_js__WEBPACK_IMPORTED_MODULE_6__/* .isEqual */ .X)(existingSummons, existingSummons);
      if (this.summons === null) {
        this.summons = foundry.utils.deepClone(ddbCompanion.summons);
      } else if (!summonMatch) {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].error */ .Z.error("Companion has different summons", {
          existingSummons,
          companionSummons,
          factory: this,
          ddbCompanion,
          equal: (0,_vendor_lowdash_isequal_js__WEBPACK_IMPORTED_MODULE_6__/* .isEqual */ .X)(existingSummons, existingSummons),
          summonMatch,
        });
        this.badSummons = false;
      }

    }
  }

  async parse() {

    await this.init();

    // console.warn(this.doc);
    const statBlockDivs = this.doc.querySelectorAll("div.stat-block-background, div.stat-block-finder, div.basic-text-frame");

    // console.warn("statblkc divs", { statBlockDivs, athis: this });
    for (const block of statBlockDivs) {
      const name = block
        .querySelector("p.Stat-Block-Styles_Stat-Block-Title")
        .textContent
        .trim()
        .toLowerCase()
        .split(/\s/)
        .map((w) => _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].capitalize */ .Z.capitalize(w.trim()))
        .join(" ");

      // console.warn("Processing Companion", { name, block });
      if (name && name in DDBCompanionFactory.MULTI) {
        for (const subType of DDBCompanionFactory.MULTI[name]) {
          await this.#buildCompanion(block, { name, subType });
        }
      } else {
        await this.#buildCompanion(block, { name, subType: null });
      }

    }

    return this.data;
  }

  async #generateCompanionFolders(rootFolderName = "DDB Companions") {
    const rootFolder = await _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getOrCreateFolder */ .Z.getOrCreateFolder(null, "Actor", rootFolderName);
    for (const companion of this.companions) {
      const folder = await _lib_FolderHelper_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getOrCreateFolder */ .Z.getOrCreateFolder(rootFolder, "Actor", _lib_utils_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].capitalize */ .Z.capitalize(companion.type ?? "other"));
      companion.data.folder = folder._id;
      this.folderIds.add(folder._id);
    }
  }

  async getExistingCompendiumCompanions() {
    await this.itemHandler.buildIndex(this.indexFilter);

    const existingCompanions = await Promise.all(this.itemHandler.compendiumIndex
      .filter((companion) => foundry.utils.hasProperty(companion, "flags.ddbimporter.id")
        && this.companions.some((c) => foundry.utils.getProperty(c, "data.flags.ddbimporter.id") === companion.flags.ddbimporter.id)
      )
      .map(async (companion) => this.itemHandler.compendium.getDocument(companion._id))
    );

    return existingCompanions;
  }

  async getExistingWorldCompanions({ folderOverride = null, rootFolderNameOverride = undefined, limitToFactory = false } = {}) {
    if (game.user.isGM && !this.noCompendiums) return [];
    if (!folderOverride) await this.#generateCompanionFolders(rootFolderNameOverride);

    const companionNames = limitToFactory ? this.data.map((c) => c.name) : [];
    _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Matched companion names", companionNames);

    const existingCompanions = await game.actors.contents
      .filter((companion) => foundry.utils.hasProperty(companion, "folder.id")
        && ((!folderOverride && this.folderIds.has(companion.folder.id))
          || folderOverride?.id === companion.folder.id)
        && (!limitToFactory || (limitToFactory && companionNames.includes(companion.name)))
      )
      .map((companion) => companion);
    return existingCompanions;
  }

  static async addToWorld(companion, update) {
    const results = [];
    if (!game.user.can("ITEM_CREATE")) return results;
    const npc = await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .buildNPC */ .ln)(companion, "monster", false, update, true);
    results.push(npc);
    return results;
  }

  async #updateCompanions(companions, existingCompanions) {
    const updateCompanions = companions.filter((companion) =>
      existingCompanions.some(
        (exist) =>
          exist.flags?.ddbimporter?.id === companion.flags.ddbimporter.id
          && companion.flags?.ddbimporter?.entityTypeId === companion.flags.ddbimporter.entityTypeId
      ));

    const results = [];

    for (const companion of updateCompanions) {
      const existingCompanion = await existingCompanions.find((exist) =>
        exist.flags?.ddbimporter?.id === companion.flags.ddbimporter.id
        && companion.flags?.ddbimporter?.entityTypeId === companion.flags.ddbimporter.entityTypeId
      );
      companion.folder = existingCompanion.folder?.id;
      companion._id = existingCompanion._id;
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(`Updating companion ${companion.name}`);
      _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].copySupportedItemFlags */ .Z.copySupportedItemFlags(existingCompanion, companion);
      const npc = game.user.isGM && !this.noCompendiums
        ? await this.summonsManager.addToCompendium(companion)
        : await DDBCompanionFactory.addToWorld(companion, true);
      results.push(npc);
    }

    return results;
  }

  async #createCompanions(companions, existingCompanions, folderId) {
    if (!game.user.can("ITEM_CREATE")) {
      ui.notifications.warn(`User is unable to create world items, and cannot create companions`);
      return [];
    }
    const newCompanions = companions.filter((companion) =>
      !existingCompanions.some(
        (exist) =>
          exist.flags?.ddbimporter?.id === companion.flags.ddbimporter.id
          && companion.flags?.ddbimporter?.entityTypeId === companion.flags.ddbimporter.entityTypeId
      ));

    const results = [];
    for (const companion of newCompanions) {
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].info */ .Z.info(`Creating Companion ${companion.name}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug(`Companion data:`, {
        companion,
        folderId,
      });

      if (folderId) companion.folder = folderId;
      const importedCompanion = game.user.isGM && !this.noCompendiums
        ? await this.summonsManager.addToCompendium(companion)
        : await DDBCompanionFactory.addToWorld(companion, false);
      results.push(importedCompanion);
    }
    return results;
  }

  async updateOrCreateCompanions({ folderOverride = null, rootFolderNameOverride = undefined } = {}) {
    const existingCompanions = game.user.isGM
      ? await this.getExistingCompendiumCompanions()
      : await this.getExistingWorldCompanions({ folderOverride, rootFolderNameOverride });

    let companionData = this.data;

    if (!this.updateCompanions || !this.updateImages) {
      if (!this.updateImages) {
        _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Copying monster images across...");
        companionData = (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .copyExistingMonsterImages */ .ph)(companionData, existingCompanions);
      }
    }

    this.itemHandler.documents = companionData;
    await this.itemHandler.srdFiddling();
    await this.itemHandler.iconAdditions();

    await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .generateIconMap */ .NM)(this.itemHandler.documents);

    if (this.updateCompanions) {
      this.results.updated = await this.#updateCompanions(this.itemHandler.documents, existingCompanions);
    }
    this.results.created = await this.#createCompanions(this.itemHandler.documents, existingCompanions, folderOverride?.id);

  }


  static COMPANION_REMAP = {
    "Artificer Infusions": "Infusion: Homunculus Servant",
  };

  async addCompanionsToDocuments(otherDocuments) {
    const summonActors = game.user.isGM
      ? await this.getExistingCompendiumCompanions()
      : await this.getExistingWorldCompanions({ limitToFactory: true });
    const profiles = summonActors
      .map((actor) => {
        return {
          _id: actor._id,
          name: actor.name,
          uuid: actor.uuid,
          count: null,
        };
      });
    if (this.originDocument) {
      const alternativeDocument = DDBCompanionFactory.COMPANION_REMAP[this.originDocument.name];
      const updateDocument = alternativeDocument
        ? (otherDocuments.find((s) =>
          s.name === alternativeDocument || s.flags.ddbimporter?.originalName === alternativeDocument
        ) ?? this.originDocument)
        : this.originDocument;

      _logger_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].debug */ .Z.debug("Companion Data Load", {
        originDocument: updateDocument,
        profiles,
        worldActors: summonActors,
        factory: this,
        summons: this.summons,
      });
      foundry.utils.setProperty(updateDocument, "system.summons", foundry.utils.deepClone(this.summons));
      foundry.utils.setProperty(updateDocument, "system.summons.profiles", profiles);
      foundry.utils.setProperty(updateDocument, "system.actionType", "summ");
    }
  }

}


/***/ }),

/***/ 6843:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBSummonsManager)
/* harmony export */ });
/* harmony import */ var _lib_DDBCompendiumFolders_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(819);
/* harmony import */ var _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6968);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5259);
/* harmony import */ var _muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9633);






const SUMMONS_ACTOR_STUB = {
  "type": "npc",
  "system": {
    "abilities": {
      "str": {
        "value": 100,
      },
      "dex": {
        "value": 100,
      },
      "con": {
        "value": 100,
      },
      "int": {
        "value": 100,
      },
      "wis": {
        "value": 100,
      },
      "cha": {
        "value": 100,
      }
    },
    "attributes": {
      "movement": {
        "burrow": null,
        "climb": null,
        "fly": null,
        "swim": null,
        "walk": null,
        "units": null,
        "hover": true
      },
      "ac": {
        "flat": 1000,
        "calc": "flat"
      },
      "hp": {
        "value": 1000,
        "max": 1000,
        "temp": 0,
        "tempmax": 0,
        "bonuses": {}
      },
    },
    "traits": {
      "size": "tiny",
    },
  },
  "items": [],
  "effects": [],
  "folder": null,
  "prototypeToken": {
    "actorLink": false,
    "appendNumber": true,
    "prependAdjective": false,
    "width": 0.5,
    "height": 0.5,
    "texture": {
      "anchorX": 0.5,
      "anchorY": 0.5,
      "offsetX": 0,
      "offsetY": 0,
      "fit": "contain",
      "scaleX": 1,
      "scaleY": 1,
      "rotation": 0,
      "tint": "#ffffff",
      "alphaThreshold": 0.75
    },
    "hexagonalShape": 0,
    "lockRotation": false,
    "rotation": 0,
    "alpha": 1,
    "disposition": CONST.TOKEN_DISPOSITIONS.SECRET,
    "displayBars": 0,
    "bar1": {
      "attribute": null
    },
    "bar2": {
      "attribute": null
    },
    "ring": {
      "enabled": false,
    },
    "randomImg": false,
  },
};

const DANCING_LIGHTS_BASE = {
  "name": "Dancing Lights",
  "img": "modules/ddb-importer/img/jb2a/DancingLights_01_Yellow_Thumb.webp",
  "system": {
    "attributes": {
      "movement": {
        "fly": 60,
      },
    },
  },

  "prototypeToken": {
    "name": "Dancing Lights",
    "width": 0.5,
    "height": 0.5,
    "texture": {
      "src": "modules/ddb-importer/img/jb2a/DancingLights_01_Yellow_200x200.webm",
    },
    "light": {
      "negative": false,
      "priority": 0,
      "alpha": 0.5,
      "angle": 360,
      "bright": 0,
      "color": null,
      "coloration": 1,
      "dim": 10,
      "attenuation": 0.5,
      "luminosity": 0.5,
      "saturation": 0,
      "contrast": 0,
      "shadows": 0,
      "animation": {
        "type": "torch",
        "speed": 3,
        "intensity": 3,
        "reverse": false
      },
      "darkness": {
        "min": 0,
        "max": 1
      }
    },
  },
};


async function getSRDActors() {
  const results = {};
  const pack = game.packs.get("dnd5e.monsters");
  if (!pack) return results;

  const jb2aMod = game.modules.get('jb2a_patreon')?.active
    ? "jb2a_patreon"
    : "JB2A_DnD5e";

  const arcaneHand = await pack.getDocument("iHj5Tkm6HRgXuaWP");
  if (arcaneHand) {
    results["ArcaneHandRed"] = {
      name: "Arcane Hand (Red)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: false,
      folderName: "Arcane Hand",
      data: foundry.utils.mergeObject(arcaneHand.toObject(), {
        "name": "Arcane Hand (Red)",
        "prototypeToken.texture.src": "modules/ddb-importer/img/jb2a/ArcaneHand_Human_01_Idle_Red_400x400.webm",
        "img": "modules/ddb-importer/img/jb2a/ArcaneHand_Human_01_Idle_Red_Thumb.webp",
      }),
    };
    results["ArcaneHandPurple"] = {
      name: "Arcane Hand (Purple)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Arcane Hand",
      data: foundry.utils.mergeObject(arcaneHand.toObject(), {
        "name": "Arcane Hand (Purple)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Purple_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Purple_Thumb.webp`,
      }),
    };
    results["ArcaneHandGreen"] = {
      name: "Arcane Hand (Green)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Arcane Hand",
      data: foundry.utils.mergeObject(arcaneHand.toObject(), {
        "name": "Arcane Hand (Green)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Green_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Green_Thumb.webp`,
      }),
    };
    results["ArcaneHandBlue"] = {
      name: "Arcane Hand (Blue)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Arcane Hand",
      data: foundry.utils.mergeObject(arcaneHand.toObject(), {
        "name": "Arcane Hand (Blue)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Blue_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Blue_Thumb.webp`,
      }),
    };
    results["ArcaneHandRock"] = {
      name: "Arcane Hand (Rock)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      needsJB2APatreon: true,
      folderName: "Arcane Hand",
      data: foundry.utils.mergeObject(arcaneHand.toObject(), {
        "name": "Arcane Hand (Rock)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Rock01_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Rock01_Thumb.webp`,
      }),
    };
    results["ArcaneHandRainbow"] = {
      name: "Arcane Hand (Rainbow)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      needsJB2APatreon: true,
      folderName: "Arcane Hand",
      data: foundry.utils.mergeObject(arcaneHand.toObject(), {
        "name": "Arcane Hand (Rainbow)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Rainbow_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Rainbow_Thumb.webp`,
      }),
    };
  }

  const arcaneSword = await pack.getDocument("Tac7eq0AXJco0nml");
  if (arcaneHand) {
    results["ArcaneSwordSpectralGreen"] = {
      name: "Arcane Sword (Spectral Green)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: false,
      folderName: "Arcane Sword",
      data: foundry.utils.mergeObject(arcaneSword.toObject(), {
        "name": "Arcane Sword (Spectral Green)",
        "prototypeToken.texture.src": "modules/ddb-importer/img/jb2a/SpiritualWeapon_Shortsword01_02_Spectral_Green_400x400.webm",
        "img": "modules/ddb-importer/img/jb2a/SpiritualWeapon_Shortsword01_02_Spectral_Green_Thumb.webp",
      }),
    };

    results["ArcaneSwordAstralBlue"] = {
      name: "Arcane Sword (Astral Blue)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      needsJB2APatreon: true,
      folderName: "Arcane Sword",
      data: foundry.utils.mergeObject(arcaneSword.toObject(), {
        "name": "Arcane Sword (Astral Blue)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/2nd_Level/Spiritual_Weapon/SpiritualWeapon_Shortsword01_01_Astral_Blue_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/2nd_Level/Spiritual_Weapon/SpiritualWeapon_Shortsword01_01_Astral_Blue_Thumb.webp`,
      }),
    };
  }

  return results;
}

async function getSummonActors() {
  const jb2aMod = game.modules.get('jb2a_patreon')?.active
    ? "jb2a_patreon"
    : "JB2A_DnD5e";

  const dancingLightsBase = foundry.utils.mergeObject(foundry.utils.deepClone(SUMMONS_ACTOR_STUB), foundry.utils.deepClone(DANCING_LIGHTS_BASE));
  const localActors = {
    ArcaneEye: {
      name: "Arcane Eye",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: false,
      folderName: "Arcane Eye",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(SUMMONS_ACTOR_STUB), {
        "name": "Arcane Eye",
        "prototypeToken.name": "Arcane Eye",
        "prototypeToken.texture.src": "modules/ddb-importer/img/jb2a/Marker_01_Regular_BlueYellow_400x400.webm",
        "img": "modules/ddb-importer/img/jb2a/Marker_01_Regular_BlueYellow_Thumb.webp",
        "system": {
          "attributes": {
            "movement": {
              "fly": 30,
            },
          },
        },
        "effects": [
          (await ActiveEffect.implementation.fromStatusEffect("invisible")).toObject(),
        ],
      }),
    },
    DancingLightsYellow: {
      name: "Dancing Lights (Yellow)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: false,
      folderName: "Dancing Lights",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(dancingLightsBase), {
        "name": "Dancing Lights (Yellow)",
        "prototypeToken.texture.src": "modules/ddb-importer/img/jb2a/DancingLights_01_Yellow_200x200.webm",
        "prototypeToken.light": {
          "color": "#ffed7a",
          "alpha": 0.25,
        },
        "img": "modules/ddb-importer/img/jb2a/DancingLights_01_Yellow_Thumb.webp",
      }),
    },
    DancingLightsGreen: {
      name: "Dancing Lights (Green)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Dancing Lights",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(dancingLightsBase), {
        "name": "Dancing Lights (Green)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_Green_200x200.webm`,
        "prototypeToken.light": {
          "color": "#a7ff7a",
          "alpha": 0.25,
        },
        "img": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_Green_Thumb.webp`,
      }),
    },
    DancingLightsBlueTeal: {
      name: "Dancing Lights (Blue Teal)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Dancing Lights",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(dancingLightsBase), {
        "name": "Dancing Lights (Blue Teal)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_BlueTeal_200x200.webm`,
        "prototypeToken.light": {
          "color": "#80ffff",
          "alpha": 0.25,
        },
        "img": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_BlueTeal_Thumb.webp`,
      }),
    },
    DancingLightsBlueYellow: {
      name: "Dancing Lights (Blue Yellow)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Dancing Lights",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(dancingLightsBase), {
        "name": "Dancing Lights (Blue Yellow)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_BlueYellow_200x200.webm`,
        "prototypeToken.light": {
          "color": "#c1e6e6",
          "alpha": 0.25,
        },
        "img": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_BlueYellow_Thumb.webp`,
      }),
    },
    DancingLightsPink: {
      name: "Dancing Lights (Pink)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Dancing Lights",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(dancingLightsBase), {
        "name": "Dancing Lights (Pink)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_Pink_200x200.webm`,
        "prototypeToken.light": {
          "color": "#f080ff",
          "alpha": 0.25,
        },
        "img": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_Pink_Thumb.webp`,
      }),
    },
    DancingLightsPurpleGreen: {
      name: "Dancing Lights (Purple Green)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Dancing Lights",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(dancingLightsBase), {
        "name": "Dancing Lights (Purple Green)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_PurpleGreen_200x200.webm`,
        "prototypeToken.light": {
          "color": "#a66bff",
          "alpha": 0.25,
        },
        "img": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_PurpleGreen_Thumb.webp`,
      }),
    },
    DancingLightsRed: {
      name: "Dancing Lights (Red)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Dancing Lights",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(dancingLightsBase), {
        "name": "Dancing Lights (Red)",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_Red_200x200.webm`,
        "prototypeToken.light": {
          "color": "#ff817a",
          "alpha": 0.25,
        },
        "img": `modules/${jb2aMod}/Library/Cantrip/Dancing_Lights/DancingLights_01_Red_Thumb.webp`,
      }),
    },
    MageHandRed: {
      name: "Mage Hand (Red)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: false,
      folderName: "Mage Hand",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(SUMMONS_ACTOR_STUB), {
        "name": "Mage Hand (Red)",
        "prototypeToken.name": "Mage Hand",
        "prototypeToken.texture.src": "modules/ddb-importer/img/jb2a/ArcaneHand_Human_01_Idle_Red_400x400.webm",
        "img": "modules/ddb-importer/img/jb2a/ArcaneHand_Human_01_Idle_Red_Thumb.webp",
        "system": {
          "attributes": {
            "movement": {
              "fly": 30,
            },
          },
        },
      }),
    },
    MageHandPurple: {
      name: "Mage Hand (Purple)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Mage Hand",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(SUMMONS_ACTOR_STUB), {
        "name": "Mage Hand (Purple)",
        "prototypeToken.name": "Mage Hand",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Purple_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Purple_Thumb.webp`,
        "system": {
          "attributes": {
            "movement": {
              "fly": 30,
            },
          },
        },
      }),
    },
    MageHandGreen: {
      name: "Mage Hand (Green)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Mage Hand",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(SUMMONS_ACTOR_STUB), {
        "name": "Mage Hand (Green)",
        "prototypeToken.name": "Mage Hand",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Green_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Green_Thumb.webp`,
        "system": {
          "attributes": {
            "movement": {
              "fly": 30,
            },
          },
        },
      }),
    },
    MageHandBlue: {
      name: "Mage Hand (Blue)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      folderName: "Mage Hand",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(SUMMONS_ACTOR_STUB), {
        "name": "Mage Hand (Blue)",
        "prototypeToken.name": "Mage Hand",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Blue_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Blue_Thumb.webp`,
        "system": {
          "attributes": {
            "movement": {
              "fly": 30,
            },
          },
        },
      }),
    },
    MageHandRock: {
      name: "Mage Hand (Rock)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      needsJB2APatreon: true,
      folderName: "Mage Hand",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(SUMMONS_ACTOR_STUB), {
        "name": "Mage Hand (Rock)",
        "prototypeToken.name": "Mage Hand",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Rock01_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Rock01_Thumb.webp`,
        "system": {
          "attributes": {
            "movement": {
              "fly": 30,
            },
          },
        },
      }),
    },
    MageHandRainbow: {
      name: "Mage Hand (Rainbow)",
      version: "1",
      required: null,
      isJB2A: true,
      needsJB2A: true,
      needsJB2APatreon: true,
      folderName: "Mage Hand",
      data: foundry.utils.mergeObject(foundry.utils.deepClone(SUMMONS_ACTOR_STUB), {
        "name": "Mage Hand (Rainbow)",
        "prototypeToken.name": "Mage Hand",
        "prototypeToken.texture.src": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Rainbow_400x400.webm`,
        "img": `modules/${jb2aMod}/Library/5th_Level/Arcane_Hand/ArcaneHand_Human_01_Idle_Rainbow_Thumb.webp`,
        "system": {
          "attributes": {
            "movement": {
              "fly": 30,
            },
          },
        },
      }),
    },
  };

  const srdActors = await getSRDActors();
  return foundry.utils.mergeObject(srdActors, localActors);
}

const JB2A_LICENSE = `<p>The assets in this actor are kindly provided by JB2A and are licensed by <a href="https://creativecommons.org/licenses/by-nc-sa/4.0">Attribution-NonCommercial-ShareAlike 4.0 International</a>.</p>
<p>Check them out at <a href="https://jb2a.com">https://jb2a.com</a> they have a free and patreon supported Foundry module providing wonderful animations and assets for a variety of situations.</p>
<p>You can learn more about their Foundry modules <a href="https://jb2a.com/home/install-instructions/">here</a>.</p>`;


class DDBSummonsManager {

  constructor() {
    this.indexFilter = { fields: [
      "name",
      "flags.ddbimporter.compendiumId",
      "flags.ddbimporter.id",
      "flags.ddbimporter.summons",
    ] };
    this.itemHandler = null;
  }

  async init() {
    this.compendiumFolders = new _lib_DDBCompendiumFolders_js__WEBPACK_IMPORTED_MODULE_0__/* .DDBCompendiumFolders */ .Z("summons");
    await this.compendiumFolders.loadCompendium("summons");

    this.itemHandler = new _lib_DDBItemImporter_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("summons", [], {
      indexFilter: this.indexFilter,
    });
    await this.itemHandler.init();
  }

  async addToCompendium(companion) {
    const results = [];
    if (!game.user.isGM) return results;
    const compendiumCompanion = foundry.utils.deepClone(companion);
    delete compendiumCompanion.folder;
    const folderName = this.compendiumFolders.getSummonFolderName(compendiumCompanion);
    const folder = await this.compendiumFolders.createSummonsFolder(folderName.name);
    compendiumCompanion.folder = folder._id;
    const npc = await (0,_muncher_importMonster_js__WEBPACK_IMPORTED_MODULE_4__/* .addNPC */ .Fx)(compendiumCompanion, "summons");
    results.push(npc);
    return results;
  }

  static async generateFixedSummons() {
    if (!game.user.isGM) return;
    const manager = new DDBSummonsManager();
    await manager.init();
    _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug("Generating Fixed summons");

    const generatedSummonedActors = await getSummonActors();
    for (const [key, value] of Object.entries(generatedSummonedActors)) {
      // check for JB2A modules
      if (value.needsJB2A
        && !game.modules.get('jb2a_patreon')?.active
        && !game.modules.get('JB2A_DnD5e')?.active
      ) continue;
      if (value.needsJB2APatreon && !game.modules.get('jb2a_patreon')?.active) continue;
      const existingSummons = manager.itemHandler.compendium.index.find((i) =>
        i.flags?.ddbimporter?.summons?.summonsKey === key
      );

      if (existingSummons && existingSummons.flags.ddbimporter.summons.version >= value.version) continue;

      // set summons data
      const companion = foundry.utils.deepClone(value.data);
      foundry.utils.setProperty(companion, "flags.ddbimporter.summons", {
        summonsKey: key,
        version: value.version,
        folder: value.folderName,
      });
      companion._id = _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].namedIDStub */ .Z.namedIDStub(value.name, { prefix: "ddbSum" });

      if (value.isJB2A) {
        foundry.utils.setProperty(companion, "system.details.biography", {
          value: JB2A_LICENSE,
          public: JB2A_LICENSE,
        });
      }

      _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(`Creating ${key}`, companion);

      await manager.addToCompendium(companion);
    }
  }


}


/***/ }),

/***/ 3164:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBAction)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1438);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5259);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6451);
/* harmony import */ var _DDBBaseFeature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5025);








class DDBAction extends _DDBBaseFeature_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z {

  static LEVEL_SCALE_EXCLUSION = [
    "Fire Rune",
    "Cloud Rune",
    "Stone Rune",
    "Frost Rune",
    "Hill Rune",
    "Storm Rune",
    "Drake Companion: Summon",
    "Drake Companion: Command",
    "Drake Companion",
  ];

  static LEVEL_SCALE_INFUSIONS = [
    "Unarmed Strike",
    "Arms of the Astral Self (WIS)",
    "Arms of the Astral Self (DEX)",
    "Arms of the Astral Self (DEX/STR)",
    "Body of the Astral Self",
    "Starry Form: Archer",
    "Sneak Attack",
  ];

  _init() {
    this.isAction = true;
    _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(`Generating Action ${this.ddbDefinition.name}`);
  }

  _prepare() {
    if (this.ddbDefinition.infusionFlags) {
      foundry.utils.setProperty(this.data, "flags.infusions", this.ddbDefinition.infusionFlags);
    }

    this._actionType = {
      class: this.ddbData.character.actions.class
        .filter((ddbAction) => _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findClassByFeatureId */ .Z.findClassByFeatureId(this.ddbData, ddbAction.componentId))
        .find((ddbAction) => {
          const name = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getName */ .Z.getName(this.ddbData, ddbAction, this.rawCharacter);
          return name === this.data.name;
        }),
      race: this.ddbData.character.actions.race
        .some((ddbAction) => {
          const name = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getName */ .Z.getName(this.ddbData, ddbAction, this.rawCharacter);
          return name === this.data.name;
        }),
      feat: this.ddbData.character.actions.feat
        .some((ddbAction) => {
          const name = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getName */ .Z.getName(this.ddbData, ddbAction, this.rawCharacter);
          return name === this.data.name;
        }),
    };
  }

  displayAsAttack() {
    const customDisplay = this.rawCharacter
      ? _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCustomValueFromCharacter */ .Z.getCustomValueFromCharacter(this.ddbDefinition, this.rawCharacter, 16)
      : _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCustomValue */ .Z.getCustomValue(this.ddbDefinition, this.ddbData, 16);
    if (typeof customDisplay == "boolean") {
      return customDisplay;
    } else if (foundry.utils.hasProperty(this.ddbDefinition, "displayAsAttack")) {
      return this.ddbDefinition.displayAsAttack;
    } else {
      return false;
    }
  }

  build() {
    try {
      this._generateSystemType();
      this._generateSystemSubType();
      this._generateActivation();
      this._generateDescription();
      this._generateLimitedUse();
      this._generateResourceConsumption();
      this._generateRange();
      this._generateAttackType();

      if (this.data.system.damage.parts.length === 0) {
        _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug("Running level scale parser");
        this._generateLevelScaleDice();
      }

      this._generateFlagHints();
      this._generateResourceFlags();

      this._addEffects();
      this._addCustomValues();
    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].warn */ .Z.warn(
        `Unable to Generate Action: ${this.name}, please log a bug report. Err: ${err.message}`,
        "extension"
      );
      _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].error */ .Z.error("Error", err);
    }
  }

  _generateSystemType(typeNudge = null) {
    // if (this.documentType === "weapon") return;
    if (this.ddbData.character.actions.class.some((a) =>
      a.name === this.ddbDefinition.name
      || (foundry.utils.hasProperty(a, "definition.name") && a.definition.name === this.ddbDefinition.name)
    )) {
      this.data.system.type.value = "class";
    } else if (this.ddbData.character.actions.race.some((a) =>
      a.name === this.ddbDefinition.name
      || (foundry.utils.hasProperty(a, "definition.name") && a.definition.name === this.ddbDefinition.name)
    )) {
      this.data.system.type.value = "race";
    } else if (this.ddbData.character.actions.feat.some((a) =>
      a.name === this.ddbDefinition.name
      || (foundry.utils.hasProperty(a, "definition.name") && a.definition.name === this.ddbDefinition.name)
    )) {
      this.data.system.type.value = "feat";
    } else if (typeNudge) {
      this.data.system.type.value = typeNudge;
      foundry.utils.setProperty(this.data, "flags.ddbimporter.type", typeNudge);
    }
  }

  // eslint-disable-next-line complexity
  _generateDamage() {
    const damageType = this.ddbDefinition.damageTypeId
      ? _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].actions.damageType.find */ .Z.actions.damageType.find((type) => type.id === this.ddbDefinition.damageTypeId).name
      : null;

    // when the action type is not set to melee or ranged we don't apply the mod to damage
    const meleeOrRangedAction = this.ddbDefinition.attackTypeRange || this.ddbDefinition.rangeId;
    const modBonus = (this.ddbDefinition.statId || this.ddbDefinition.abilityModifierStatId) && !this.ddbDefinition.isOffhand && meleeOrRangedAction ? " + @mod" : "";
    const die = this.ddbDefinition.dice ? this.ddbDefinition.dice : this.ddbDefinition.die ? this.ddbDefinition.die : undefined;
    // const fixedBonus = die?.fixedValue ? ` + ${die.fixedValue}` : "";
    const fixedBonus = die?.fixedValue
      ? (this.ddbDefinition.snippet ?? this.ddbDefinition.description ?? "").includes("{{proficiency#signed}}")
        ? " + @prof"
        : ` + ${die.fixedValue}`
      : "";
    const globalDamageHints = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-damage-hints");
    const scaleValueLink = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getScaleValueString */ .Z.getScaleValueString(this.ddbData, this.ddbDefinition).value;
    const excludedScale = DDBAction.LEVEL_SCALE_EXCLUSION.includes(this.data.name);
    const useScaleValueLink = !excludedScale && scaleValueLink && scaleValueLink !== "{{scalevalue-unknown}}";

    if (die || useScaleValueLink) {
      const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
      if (useScaleValueLink) {
        this.data.system.damage = {
          parts: [[`${scaleValueLink}${damageTag}${modBonus}${fixedBonus}`, damageType]],
          versatile: "",
        };
      } else if (die.diceString) {
        const profBonus = CONFIG.DDB.levelProficiencyBonuses.find((b) => b.level === this.ddbData.character.classes.reduce((p, c) => p + c.level, 0))?.bonus;
        const replaceProf = this.ddbDefinition.snippet?.includes("{{proficiency#signed}}")
          && Number.parseInt(die.fixedValue) === Number.parseInt(profBonus);
        const diceString = replaceProf
          ? die.diceString.replace(`+ ${profBonus}`, "")
          : die.diceString;
        const mods = replaceProf ? `${modBonus} + @prof` : modBonus;
        const damageString = _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].parseDiceString */ .Z.parseDiceString(diceString, mods, damageTag).diceString;
        this.data.system.damage = {
          parts: [[damageString, damageType]],
          versatile: "",
        };
      } else if (fixedBonus) {
        this.data.system.damage = {
          parts: [[fixedBonus + modBonus, damageType]],
          versatile: "",
        };
      }
    }
  }

  _generateSaveAttack() {
    this.data.system.actionType = "save";
    this._generateDamage();

    const fixedDC = this.ddbDefinition.fixedSaveDc ? this.ddbDefinition.fixedSaveDc : null;
    const scaling = fixedDC ? "flat" : (this.ddbDefinition.abilityModifierStatId) ? _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((stat) => stat.id === this.ddbDefinition.abilityModifierStatId).value : "spell";

    const saveAbility = (this.ddbDefinition.saveStatId)
      ? _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((stat) => stat.id === this.ddbDefinition.saveStatId).value
      : "";

    this.data.system.save = {
      ability: saveAbility,
      dc: fixedDC,
      scaling: scaling,
    };
    if (this.ddbDefinition.abilityModifierStatId) {
      this.data.system.ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((stat) => stat.id === this.ddbDefinition.abilityModifierStatId).value;
    }
  }

  _generateMartialArtsDamage() {
    const damageType = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].actions.damageType.find */ .Z.actions.damageType.find((type) => type.id === this.ddbDefinition.damageTypeId).name;
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");

    let damageBonus = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].filterBaseModifiers */ .Z.filterBaseModifiers(this.ddbData, "damage", { subType: "unarmed-attacks" }).reduce((prev, cur) => prev + cur.value, 0);
    if (damageBonus === 0) {
      damageBonus = "";
    } else {
      damageBonus = ` + ${damageBonus}`;
    }
    const actionDie = this.ddbDefinition.dice ? this.ddbDefinition.dice : this.ddbDefinition.die ? this.ddbDefinition.die : undefined;

    // are we dealing with martial arts?
    if (this.isMartialArtist()) {
      const dies = this.ddbData.character.classes
        .filter((klass) => this.isMartialArtist(klass))
        .map((klass) => {
          const feature = klass.classFeatures.find((feature) => feature.definition.name === "Martial Arts");
          const levelScaleDie = feature?.levelScale?.dice ? feature.levelScale.dice : feature?.levelScale.die ? feature.levelScale.die : undefined;

          if (levelScaleDie?.diceString) {

            const scaleValueLink = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getScaleValueLink */ .Z.getScaleValueLink(this.ddbData, feature);
            const scaleString = scaleValueLink && scaleValueLink !== "{{scalevalue-unknown}}"
              ? scaleValueLink
              : levelScaleDie.diceString;

            if (actionDie?.diceValue > levelScaleDie.diceValue) {
              return actionDie.diceString;
            }
            return scaleString;
          } else if (actionDie !== null && actionDie !== undefined) {
            // On some races bite is considered a martial art, damage
            // is different and on the action itself
            return actionDie.diceString;
          } else {
            return "1";
          }
        });
      const die = dies.length > 0 ? dies[0] : "";
      const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
      const damageString = die.includes("@")
        ? `${die}${damageTag}${damageBonus} + @mod`
        : _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].parseDiceString */ .Z.parseDiceString(die, `${damageBonus} + @mod`, damageTag).diceString;

      // set the weapon damage
      this.data.system.damage = {
        parts: [[damageString, damageType]],
        versatile: "",
      };
    } else if (actionDie !== null && actionDie !== undefined) {
      // The Lizardfolk jaws have a different base damage, its' detailed in
      // dice so lets capture that for actions if it exists
      const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : "";
      const damageString = _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].parseDiceString */ .Z.parseDiceString(actionDie.diceString, `${damageBonus} + @mod`, damageTag).diceString;
      this.data.system.damage = {
        parts: [[damageString, damageType]],
        versatile: "",
      };
    } else {
      // default to basics
      this.data.system.damage = {
        parts: [[`1${damageBonus} + @mod`, damageType]],
        versatile: "",
      };
    }
  }

  _calculateActionAttackAbilities() {
    let defaultAbility = this.ddbDefinition.abilityModifierStatId
      ? _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find(
        (stat) => stat.id === this.ddbDefinition.abilityModifierStatId
      ).value
      : "";

    if (this.ddbDefinition.abilityModifierStatId
      && !([1, 2].includes(this.ddbDefinition.abilityModifierStatId) && this.ddbDefinition.isMartialArts)
    ) {
      this.data.system.ability = defaultAbility;
    } else if (this.ddbDefinition.isMartialArts) {
      this.data.system.ability
        = this.ddbDefinition.isMartialArts && this.isMartialArtist()
          ? this.rawCharacter.flags.ddbimporter.dndbeyond.effectAbilities.dex.value >= this.rawCharacter.flags.ddbimporter.dndbeyond.effectAbilities.str.value
            ? "dex"
            : "str"
          : defaultAbility !== "" ? defaultAbility : "str";
    } else {
      this.data.system.ability = "";
    }
    if (this.ddbDefinition.isMartialArts) {
      this._generateMartialArtsDamage();
      this.data.system.attack.bonus = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].filterBaseModifiers */ .Z.filterBaseModifiers(this.ddbData, "bonus", { subType: "unarmed-attacks" }).reduce((prev, cur) => prev + cur.value, 0);
    } else {
      this._generateDamage();
    }
    return this.data;
  }


  _generateAttackType() {
    // lets see if we have a save stat for things like Dragon born Breath Weapon
    if (typeof this.ddbDefinition.saveStatId === "number") {
      this._generateSaveAttack();
    } else if (this.ddbDefinition.actionType === 1) {
      if (this.ddbDefinition.attackTypeRange === 2) {
        this.data.system.actionType = "rwak";
      } else {
        this.data.system.actionType = "mwak";
      }
      this._calculateActionAttackAbilities();
    } else {
      if (this.ddbDefinition.rangeId && this.ddbDefinition.rangeId === 1) {
        this.data.system.actionType = "mwak";
      } else if (this.ddbDefinition.rangeId && this.ddbDefinition.rangeId === 2) {
        this.data.system.actionType = "rwak";
      } else {
        this.data.system.actionType = "other";
      }
      this._calculateActionAttackAbilities();
    }
  }

  /**
   * Some features have actions that use dice and mods that are defined on the character class feature
   * this attempts to parse out the damage dice and any ability modifier.
   * This relies on the parsing of templateStrings for the ability modifier detection.
   */
  _generateLevelScaleDice(useScale = true) {
    if (useScale) return;
    const excludedScale = DDBAction.LEVEL_SCALE_EXCLUSION.includes(this.ddbDefinition.name);
    const parts = this.ddbData.character.classes
      .filter((cls) => cls.classFeatures.some((feature) =>
        feature.definition.id == this.ddbDefinition.componentId
        && feature.definition.entityTypeId == this.ddbDefinition.componentTypeId
        && feature.levelScale?.dice?.diceString
      ))
      .map((cls) => {
        const feature = cls.classFeatures.find((feature) =>
          feature.definition.id == this.ddbDefinition.componentId
          && feature.definition.entityTypeId == this.ddbDefinition.componentTypeId
        );
        const parsedString = this.rawCharacter.flags.ddbimporter.dndbeyond.templateStrings.find((templateString) =>
          templateString.id == this.ddbDefinition.id
          && templateString.entityTypeId == this.ddbDefinition.entityTypeId
        );
        const die = feature.levelScale.dice ? feature.levelScale.dice : feature.levelScale.die ? feature.levelScale.die : undefined;
        const scaleValueLink = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getScaleValueString */ .Z.getScaleValueString(this.ddbData, this.ddbDefinition).value;
        let part = useScale && !excludedScale && scaleValueLink && scaleValueLink !== "{{scalevalue-unknown}}"
          ? scaleValueLink
          : die.diceString;
        if (parsedString) {
          const modifier = parsedString.definitions.find((definition) => definition.type === "modifier");
          if (modifier) {
            this.data.system.ability = modifier.subType;
            part = `${part} + @mod`;
          }
        }
        return [part, ""];
      });

    if (parts.length > 0 && useScale) {
      this.data.system.damage.parts = parts;
    } else if (parts.length > 0 && !DDBAction.LEVEL_SCALE_INFUSIONS.includes(this.ddbDefinition.name)) {
      const combinedParts = foundry.utils.hasProperty(this.data, "data.damage.parts") && this.data.system.damage.parts.length > 0
        ? this.data.system.damage.parts.concat(parts)
        : parts;
      this.data.system.damage = {
        parts: combinedParts,
        versatile: "",
      };
    }
  }

  _generateWeaponType() {
    if (this.documentType === "weapon") {
      const entry = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].actions.attackTypes.find */ .Z.actions.attackTypes.find((type) => type.attackSubtype === this.ddbDefinition.attackSubtype);
      const range = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].weapon.weaponRange.find */ .Z.weapon.weaponRange.find((type) => type.attackType === this.ddbDefinition.attackTypeRange);
      this.data.system.type.value = entry
        ? entry.value
        : range
          ? `simple${range.value}`
          : "simpleM";
    }
  }

  _generateProperties() {

    const kiEmpowered = this.ddbData.character.classes
      // is a martial artist
      .some((cls) =>
        cls.classFeatures.some((feature) =>
          feature.definition.name === "Ki-Empowered Strikes"
          && cls.level >= feature.definition.requiredLevel
        ));

    if (kiEmpowered && foundry.utils.getProperty(this.data, "flags.ddbimporter.originalName") == "Unarmed Strike") {
      _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].addToProperties */ .Z.addToProperties(this.data.system.properties, "mgc");
    }

  }

  _generateFlagHints() {
    // obsidian and klass names (used in effect enrichment)
    if (this._actionType.class) {
      const klass = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findClassByFeatureId */ .Z.findClassByFeatureId(this.ddbData, this._actionType.class.componentId);
      foundry.utils.setProperty(this.data.flags, "obsidian.source.type", "class");
      foundry.utils.setProperty(this.data.flags, "ddbimporter.type", "class");
      foundry.utils.setProperty(this.data.flags, "obsidian.source.text", klass.definition.name);
      foundry.utils.setProperty(this.data.flags, "ddbimporter.class", klass.definition.name);
      foundry.utils.setProperty(this.data.flags, "ddbimporter.classId", klass.definition.id);
      const subKlass = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findSubClassByFeatureId */ .Z.findSubClassByFeatureId(this.ddbData, this._actionType.class.componentId);
      const subClass = foundry.utils.getProperty(subKlass, "subclassDefinition");
      foundry.utils.setProperty(this.data.flags, "ddbimporter.subclass", subClass?.name);
      foundry.utils.setProperty(this.data.flags, "ddbimporter.subclassId", subClass?.id);
    } else if (this._actionType.race) {
      foundry.utils.setProperty(this.data.flags, "obsidian.source.type", "race");
      foundry.utils.setProperty(this.data.flags, "ddbimporter.type", "race");
    } else if (this._actionType.feat) {
      foundry.utils.setProperty(this.data.flags, "obsidian.source.type", "feat");
      foundry.utils.setProperty(this.data.flags, "ddbimporter.type", "feat");
    }

    // scaling details
    const klassActionComponent = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findComponentByComponentId */ .Z.findComponentByComponentId(this.ddbData, this.ddbDefinition.id)
      ?? _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].findComponentByComponentId */ .Z.findComponentByComponentId(this.ddbData, this.ddbDefinition.componentId);
    if (klassActionComponent) {
      foundry.utils.setProperty(this.data.flags, "ddbimporter.dndbeyond.levelScale", klassActionComponent.levelScale);
      foundry.utils.setProperty(this.data.flags, "ddbimporter.dndbeyond.levelScales", klassActionComponent.definition?.levelScales);
      foundry.utils.setProperty(this.data.flags, "ddbimporter.dndbeyond.limitedUse", klassActionComponent.definition?.limitedUse);
    }
  }

}


/***/ }),

/***/ 5345:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBAttackAction)
/* harmony export */ });
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5259);
/* harmony import */ var _DDBAction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3164);




class DDBAttackAction extends _DDBAction_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z {

  static FORCE_WEAPON_FEATURES = [
    "Unarmed Strike",
    "Psychic Blades: Attack (DEX)",
    "Psychic Blades: Attack (STR)",
    "Psychic Blades: Bonus Attack (DEX)",
    "Psychic Blades: Bonus Attack (STR)",
    "Thunder Gauntlets",
    "Lightning Launcher",
    "Guardian Armor: Thunder Gauntlets",
    "Guardian Armor: Thunder Gauntlets (STR)",
    "Infiltrator Armor: Lightning Launcher",
    "Infiltrator Armor: Lightning Launcher (DEX)",
    "Arms of the Astral Self (WIS)",
    "Arms of the Astral Self (DEX/STR)",
  ];

  _init() {
    this.isAction = true;
    this.documentType = DDBAttackAction.FORCE_WEAPON_FEATURES.includes(this.ddbDefinition.name)
      ? "weapon"
      : "feat";
    _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].debug */ .Z.debug(`Generating Attack Action ${this.ddbDefinition.name}`);
  }

  build() {
    try {
      if (this.ddbData.isMartialArts) {
        foundry.utils.setProperty(this.data, "flags.ddbimporter.dndbeyond.type", "Martial Arts");
      };
      this.data.system.proficient = this.ddbDefinition.isProficient ? 1 : 0;
      this._generateDescription();
      this.data.system.equipped = true;
      this.data.system.rarity = "";
      this.data.system.identified = true;
      this._generateActivation();
      this._generateRange();
      this._generateAttackType();
      this._generateWeaponType();
      this._generateLimitedUse();
      this._generateResourceConsumption();
      this._generateProperties();
      this._generateSystemType(this.type);
      this._generateSystemSubType();

      if (["line", "cone"].includes(this.data.system.target?.type)) {
        foundry.utils.setProperty(this.data, "system.duration.units", "inst");
      }

      this._generateFlagHints();
      this._generateResourceFlags();
      this._addEffects();
      this._generateLevelScaleDice();

      this._addCustomValues();

    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].warn */ .Z.warn(
        `Unable to Generate Attack Action: ${this.name}, please log a bug report. Err: ${err.message}`,
        "extension"
      );
      _logger_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].error */ .Z.error("Error", err);
    }
  }

}


/***/ }),

/***/ 5025:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBBaseFeature)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1438);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5259);
/* harmony import */ var _lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(258);
/* harmony import */ var _effects_effects_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5751);
/* harmony import */ var _effects_DDBSimpleMacro_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4536);









class DDBBaseFeature {

  _init() {
    _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(`Generating Base Feature ${this.ddbDefinition.name}`);
  }

  _generateDataStub() {
    this.data = {
      _id: foundry.utils.randomID(),
      name: _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getName */ .Z.getName(this.ddbData, this.ddbDefinition, this.rawCharacter),
      type: this.documentType,
      system: _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getTemplate */ .Z.getTemplate(this.documentType),
      flags: {
        ddbimporter: {
          id: this.ddbDefinition.id,
          entityTypeId: this.ddbDefinition.entityTypeId,
          action: this.isAction,
          componentId: this.ddbDefinition.componentId,
          componentTypeId: this.ddbDefinition.componentTypeId,
          originalName: this.originalName,
          type: this.tagType,
          isCustomAction: this.ddbDefinition.isCustomAction,
        },
        infusions: { infused: false },
        obsidian: {
          source: {
            type: this.tagType,
          },
        }
      },
    };
  }

  _prepare() {
    if (this.ddbDefinition.infusionFlags) {
      foundry.utils.setProperty(this.data, "flags.infusions", this.ddbDefinition.infusionFlags);
    }
  }

  constructor({ ddbData, ddbDefinition, type, source, documentType = "feat", rawCharacter = null, noMods = false } = {}) {
    this.ddbData = ddbData;
    this.rawCharacter = rawCharacter;
    this.ddbFeature = ddbDefinition;
    this.ddbDefinition = ddbDefinition.definition ?? ddbDefinition;
    this.name = _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].nameString */ .Z.nameString(this.ddbDefinition.name);
    this.originalName = this.ddbData
      ? _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getName */ .Z.getName(this.ddbData, this.ddbDefinition, this.rawCharacter, false)
      : this.ddbDefinition.name;
    this.type = type;
    this.source = source;
    this.isAction = false;
    this.documentType = documentType;
    this.tagType = "other";
    this.data = {};
    this.noMods = noMods;
    this._init();
    this.snippet = "";
    this.description = "";
    this._resourceCharges = null;

    // this._attacksAsFeatures = game.settings.get(SETTINGS.MODULE_ID, "character-update-policy-use-actions-as-features");

    this._generateDataStub();

    // Grim Hollow puts points in names. WHY
    const namePointRegex = /(.*) \((\d) points?\)/i;
    const nameMatch = this.name.match(namePointRegex);
    if (nameMatch) {
      this.data.name = nameMatch[1];
      this._resourceCharges = Number.parseInt(nameMatch[2]);
    }

    this._prepare();
    this.data.system.source = this.source;
  }


  static _getParsedAction(description) {
    // foundry doesn't support mythic actions pre 1.6
    const actionAction = description.match(/(?:as|spend|use) (?:a|an|your) action/ig);
    if (actionAction) return "action";
    const bonusAction = description.match(/(?:as|use|spend) (?:a|an|your) bonus action/ig);
    if (bonusAction) return "bonus";
    const reAction = description.match(/(?:as|use|spend) (?:a|an|your) reaction/ig);
    if (reAction) return "reaction";

    return undefined;
  }

  _generateParsedActivation() {
    const description = this.ddbDefinition.description && this.ddbDefinition.description !== ""
      ? this.ddbDefinition.description
      : this.ddbDefinition.snippet && this.ddbDefinition.snippet !== ""
        ? this.ddbDefinition.snippet
        : null;

    // console.warn(`Generating Parsed Activation for ${this.name}`, {description});

    if (!description) return;
    const actionType = DDBBaseFeature._getParsedAction(description);
    if (!actionType) return;
    _logger_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].debug */ .Z.debug(`Parsed manual activation type: ${actionType} for ${this.name}`);
    this.data.system.activation = {
      type: actionType,
      cost: 1,
      condition: "",
    };
  }

  _generateActivation() {
    // console.warn(`Generating Activation for ${this.name}`);
    if (!this.ddbDefinition.activation) {
      this._generateParsedActivation();
      return;
    }
    const actionType = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].actions.activationTypes.find */ .Z.actions.activationTypes.find((type) => type.id === this.ddbDefinition.activation.activationType);
    if (!actionType) {
      this._generateParsedActivation();
      return;
    }

    this.data.system.activation = {
      type: actionType.value,
      cost: this.ddbDefinition.activation.activationTime || 1,
      condition: "",
    };
  }

  _getClassFeatureDescription() {
    if (!this.ddbData) return "";
    const componentId = this.ddbDefinition.componentId;
    const componentTypeId = this.ddbDefinition.componentTypeId;

    const findFeatureKlass = this.ddbData.character.classes
      .find((cls) => cls.classFeatures.find((feature) =>
        feature.definition.id == componentId
        && feature.definition.entityTypeId == componentTypeId
      ));

    if (findFeatureKlass) {
      const feature = findFeatureKlass.classFeatures
        .find((feature) =>
          feature.definition.id == componentId
          && feature.definition.entityTypeId == componentTypeId
        );
      if (feature) {
        return (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this.ddbData, this.rawCharacter, feature.definition.description, this.ddbFeature).text;
      }
    }
    return "";
  }


  _getRaceFeatureDescription() {
    const componentId = this.ddbDefinition.componentId;
    const componentTypeId = this.ddbDefinition.componentTypeId;

    const feature = this.ddbData.character.race.racialTraits
      .find((trait) =>
        trait.definition.id == componentId
        && trait.definition.entityTypeId == componentTypeId
      );

    if (feature) {
      return (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this.ddbData, this.rawCharacter, feature.definition.description, this.ddbFeature).text;
    }
    return "";

  }

  static buildFullDescription(main, summary, title) {
    let result = "";

    if (summary && !_lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].stringKindaEqual */ .Z.stringKindaEqual(main, summary) && summary.trim() !== "" && main.trim() !== "") {
      result += summary.trim();
      result += `<br>
  <details>
    <summary>
      ${title ? title : "More Details"}
    </summary>
    <p>
      ${main.trim()}
    </p>
  </details>`;
    } else if (main.trim() === "") {
      result += summary.trim();
    } else {
      result += main.trim();
    }

    return result;
  }

  _generateDescription(forceFull = false) {
    // for now none actions probably always want the full text
    const useFullSetting = game.settings.get("ddb-importer", "character-update-policy-use-full-description");
    const useFull = forceFull || useFullSetting;
    const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");

    this.snippet = this.ddbDefinition.snippet && this.ddbDefinition.snippet !== ""
      ? (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this.ddbData, this.rawCharacter, this.ddbDefinition.snippet, this.ddbFeature).text
      : "";
    const rawSnippet = this.ddbDefinition.snippet
      ? this.snippet
      : "";

    this.description = this.ddbDefinition.description && this.ddbDefinition.description !== ""
      ? (0,_lib_DDBTemplateStrings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this.ddbData, this.rawCharacter, this.ddbDefinition.description, this.ddbFeature).text
      : this.type === "race"
        ? this._getRaceFeatureDescription()
        : this._getClassFeatureDescription();

    const macroHelper = _effects_DDBSimpleMacro_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getDescriptionAddition */ .Z.getDescriptionAddition(this.originalName, "feat");
    if (!chatAdd) {
      const snippet = _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].stringKindaEqual */ .Z.stringKindaEqual(this.description, rawSnippet) ? "" : rawSnippet;
      const fullDescription = DDBBaseFeature.buildFullDescription(this.description, snippet);
      const value = !useFull && snippet.trim() !== "" ? snippet : fullDescription;

      this.data.system.description = {
        value: value + macroHelper,
        chat: chatAdd ? snippet + macroHelper : "",
      };
    } else {
      const snippet = this.description !== "" && _lib_utils_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].stringKindaEqual */ .Z.stringKindaEqual(this.description, rawSnippet) ? "" : rawSnippet;

      this.data.system.description = {
        value: this.description,
        chat: snippet + macroHelper,
      };
    }

  }

  // eslint-disable-next-line complexity
  _generateLimitedUse() {
    if (
      this.ddbDefinition.limitedUse
      && (this.ddbDefinition.limitedUse.maxUses || this.ddbDefinition.limitedUse.statModifierUsesId || this.ddbDefinition.limitedUse.useProficiencyBonus)
    ) {
      const resetType = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].resets.find */ .Z.resets.find((type) => type.id === this.ddbDefinition.limitedUse.resetType);
      let maxUses = (this.ddbDefinition.limitedUse.maxUses && this.ddbDefinition.limitedUse.maxUses !== -1) ? this.ddbDefinition.limitedUse.maxUses : 0;
      let intMaxUses = maxUses;
      const statModifierUsesId = foundry.utils.getProperty(this.ddbDefinition, "limitedUse.statModifierUsesId");
      if (statModifierUsesId) {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === statModifierUsesId).value;

        if (maxUses === 0) {
          maxUses = `@abilities.${ability}.mod`;
          intMaxUses = this.rawCharacter.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
        } else {
          switch (this.ddbDefinition.limitedUse.operator) {
            case 2:
              maxUses = `${maxUses} * @abilities.${ability}.mod`;
              intMaxUses *= this.rawCharacter.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
              break;
            case 1:
            default:
              maxUses = `${maxUses} + @abilities.${ability}.mod`;
              intMaxUses += this.rawCharacter.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
          }
        }
      }

      const useProficiencyBonus = foundry.utils.getProperty(this.ddbDefinition, "limitedUse.useProficiencyBonus");
      if (useProficiencyBonus) {
        if (maxUses === 0) {
          maxUses = `@prof`;
          intMaxUses = this.rawCharacter.flags.ddbimporter.dndbeyond.profBonus;
        } else {
          switch (this.ddbDefinition.limitedUse.proficiencyBonusOperator) {
            case 2:
              maxUses = `${maxUses} * @prof`;
              intMaxUses *= this.rawCharacter.flags.ddbimporter.dndbeyond.profBonus;
              break;
            case 1:
            default:
              maxUses = `${maxUses} + @prof`;
              intMaxUses += this.rawCharacter.flags.ddbimporter.dndbeyond.profBonus;
          }
        }
      }

      const finalMaxUses = (maxUses)
        ? Number.isInteger(maxUses)
          ? parseInt(maxUses)
          : maxUses
        : null;

      intMaxUses = Number.isInteger(intMaxUses) ? parseInt(intMaxUses) : null;

      this.data.system.uses = {
        value: (intMaxUses !== null && intMaxUses != 0) ? intMaxUses - this.ddbDefinition.limitedUse.numberUsed : null,
        max: (finalMaxUses != 0) ? finalMaxUses : null,
        per: resetType ? resetType.value : "",
      };
    }
  }

  _generateResourceConsumption() {
    if (!this.rawCharacter) return;

    Object.keys(this.rawCharacter.system.resources).forEach((resource) => {
      const detail = this.rawCharacter.system.resources[resource];
      if (this.ddbDefinition.name === detail.label) {
        this.data.system.consume = {
          type: "attribute",
          target: `resources.${resource}.value`,
          amount: 1,
        };
      }
    });

    const kiPointRegex = /(?:spend|expend) (\d) ki point/;
    const match = this.data.system.description.value.match(kiPointRegex);
    if (match) {
      foundry.utils.setProperty(this.data, "system.consume.amount", match[1]);
    } else if (this._resourceCharges !== null) {
      foundry.utils.setProperty(this.data, "system.consume.amount", this._resourceCharges);
    }

  }

  _generateRange() {
    if (this.ddbDefinition.range && this.ddbDefinition.range.aoeType && this.ddbDefinition.range.aoeSize) {
      this.data.system.range = { value: null, units: "self", long: "" };
      this.data.system.target = {
        value: this.ddbDefinition.range.aoeSize,
        type: _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].actions.aoeType.find */ .Z.actions.aoeType.find((type) => type.id === this.ddbDefinition.range.aoeType)?.value,
        units: "ft",
      };
    } else if (this.ddbDefinition.range && this.ddbDefinition.range.range) {
      this.data.system.range = {
        value: this.ddbDefinition.range.range,
        units: "ft",
        long: this.ddbDefinition.range.long || "",
      };
    } else {
      this.data.system.range = { value: 5, units: "ft", long: "" };
    }
  }

  isMartialArtist(klass = null) {
    if (klass) {
      return klass.classFeatures.some((feature) => feature.definition.name === "Martial Arts");
    } else {
      return this.ddbData.character.classes.some((k) => k.classFeatures.some((feature) => feature.definition.name === "Martial Arts"));
    }

  }

  _generateResourceFlags() {
    const linkItems = game.modules.get("link-item-resource-5e")?.active;
    const resourceType = foundry.utils.getProperty(this.rawCharacter, "flags.ddbimporter.resources.type");
    if (resourceType !== "disable" && linkItems) {
      const hasResourceLink = foundry.utils.getProperty(this.data.flags, "link-item-resource-5e.resource-link");
      Object.keys(this.rawCharacter.system.resources).forEach((resource) => {
        const detail = this.rawCharacter.system.resources[resource];
        if (this.ddbDefinition.name === detail.label) {
          foundry.utils.setProperty(this.data.flags, "link-item-resource-5e.resource-link", resource);
          this.rawCharacter.system.resources[resource] = { value: 0, max: 0, sr: false, lr: false, label: "" };
        } else if (hasResourceLink === resource) {
          foundry.utils.setProperty(this.data.flags, "link-item-resource-5e.resource-link", undefined);
        }
      });
    }
  }

  _getFeatModifierItem(choice, type) {
    if (this.ddbDefinition.grantedModifiers) return this.ddbDefinition;
    let modifierItem = foundry.utils.duplicate(this.ddbDefinition);
    const modifiers = [
      _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getChosenClassModifiers */ .Z.getChosenClassModifiers(this.ddbData, { includeExcludedEffects: true, effectOnly: true }),
      _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, "race", true, true),
      _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, "background", true, true),
      _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, "feat", true, true),
    ].flat();

    if (!modifierItem.definition) modifierItem.definition = {};
    modifierItem.definition.grantedModifiers = modifiers.filter((mod) => {
      if (mod.componentId === this.ddbDefinition?.id && mod.componentTypeId === this.ddbDefinition?.entityTypeId)
        return true;
      if (choice && this.ddbData.character.options[type]?.length > 0) {
        // if it is a choice option, try and see if the mod matches
        const choiceMatch = this.ddbData.character.options[type].some(
          (option) =>
            // id match
            choice.componentId == option.componentId // the choice id matches the option componentID
            && option.definition.id == mod.componentId // option id and mod id match
            && (choice.componentTypeId == option.componentTypeId // either the choice componenttype and optiontype match or
              || choice.componentTypeId == option.definition.entityTypeId) // the choice componentID matches the option definition entitytypeid
            && option.definition.entityTypeId == mod.componentTypeId // mod componentId matches option entity type id
            && choice.id == mod.componentId // choice id and mod id match
        );
        // console.log(`choiceMatch ${choiceMatch}`);
        if (choiceMatch) return true;
      } else if (choice) {
        // && choice.parentChoiceId
        const choiceIdSplit = choice.choiceId.split("-").pop();
        if (mod.id == choiceIdSplit) return true;
      }

      if (mod.componentId === this.ddbDefinition.id) {
        if (type === "class") {
          // logger.log("Class check - feature effect parsing");
          const classFeatureMatch = this.ddbData.character.classes.some((klass) =>
            klass.classFeatures.some(
              (f) => f.definition.entityTypeId == mod.componentTypeId && f.definition.id == this.ddbDefinition.id
            )
          );
          if (classFeatureMatch) return true;
        } else if (type === "feat") {
          const featMatch = this.ddbData.character.feats.some(
            (f) => f.definition.entityTypeId == mod.componentTypeId && f.definition.id == this.ddbDefinition.id
          );
          if (featMatch) return true;
        } else if (type === "race") {
          const traitMatch = this.ddbData.character.race.racialTraits.some(
            (t) =>
              t.definition.entityTypeId == mod.componentTypeId
              && t.definition.id == mod.componentId
              && t.definition.id == this.ddbDefinition.id
          );
          if (traitMatch) return true;
        }
      }
      return false;
    });
    // console.warn("Modifier Item", modifierItem);
    return modifierItem;
  }

  _addEffects(choice, type) {
    // can we apply any auto-generated effects to this feature
    const compendiumItem = this.rawCharacter.flags.ddbimporter.compendium;
    const modifierItem = this._getFeatModifierItem(choice, type);
    this.data = (0,_effects_effects_js__WEBPACK_IMPORTED_MODULE_5__/* .generateEffects */ .K7)({
      ddb: this.ddbData,
      character: this.rawCharacter,
      ddbItem: modifierItem,
      foundryItem: this.data,
      isCompendiumItem: compendiumItem,
      type: "feat",
      description: this.snippet !== "" ? this.snippet : this.description,
    });
  }


  _addCustomValues() {
    _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].addCustomValues */ .Z.addCustomValues(this.ddbData, this.data);
  }

  _generateSystemSubType() {
    if (this.type === "class") {
      let subType = null;
      if (this.data.name.startsWith("Ki:")) subType = "Ki";
      // many ki abilities do not start with ki
      else if (this.data.name.startsWith("Channel Divinity:")) subType = "channelDivinity";
      else if (this.data.name.startsWith("Artificer Infusion:")) subType = "artificerInfusion";
      else if (this.data.name.startsWith("Invocation:")) subType = "eldritchInvocation";
      else if (this.data.name.startsWith("Fighting Style:")) subType = "fightingStyle";
      else if (this.data.name.startsWith("Battle Master Maneuver:")) subType = "maneuver";
      else if (this.data.name.startsWith("Metamagic:")) subType = "metamagic";
      else if (this.data.name.startsWith("Pact of the")) subType = "pact";
      else if (this.data.name.startsWith("Rune Carver:")) subType = "rune";
      else if (this.data.name.startsWith("Psionic Power:")) subType = "psionicPower";
      else if (this.data.name.startsWith("Hunter's Prey:")) subType = "huntersPrey";
      else if (this.data.name.startsWith("Defensive Tactics:")) subType = "defensiveTactic";
      else if (this.data.name.startsWith("Superior Hunter's Defense:")) subType = "superiorHuntersDefense";
      else if (this.data.name.startsWith("Arcane Shot Options:")) subType = "arcaneShot";
      else if (this.data.name.startsWith("Elemental Disciplines:")) subType = "elementalDiscipline";
      // missing: Arcane Shot : arcaneShot
      // missing: multiattack

      if (subType) foundry.utils.setProperty(this.data, "system.type.subtype", subType);
    }
  }

  _generateSystemType() {
    foundry.utils.setProperty(this.data, "system.type.value", this.type);
  }

  // eslint-disable-next-line class-methods-use-this
  build() {
    // override this feature
    return false;
  }

}


/***/ }),

/***/ 4074:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBFeature)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3893);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1438);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5259);
/* harmony import */ var _advancements_AdvancementHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(333);
/* harmony import */ var _DDBAttackAction_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5345);
/* harmony import */ var _DDBBaseFeature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5025);










class DDBFeature extends _DDBBaseFeature_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z {

  static FORCE_UNARMED = [
    "Trunk",
    "Claws",
  ];

  static DOC_TYPE = {
    class: "feat", // class feature
    subclass: "feat", // subclass feature
    race: "feat",
    background: "background",
    feat: "feat",
  };

  _init() {
    this.documentType = DDBFeature.DOC_TYPE[this.type];
    this.tagType = this.type;
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Generating Feature ${this.ddbDefinition.name}`);
    this._class = this.noMods
      ? null
      : this.ddbData.character.classes.find((klass) =>
        (this.ddbDefinition.classId
          && (klass.definition.id === this.ddbDefinition.classId || klass.subclassDefinition?.id === this.ddbDefinition.classId))
        || (this.ddbDefinition.className && klass.definition.name === this.ddbDefinition.className
          && ((!this.ddbDefinition.subclassName || this.ddbDefinition.subclassName === "")
            || (this.ddbDefinition.subclassName && klass.subclassDefinition?.name === this.ddbDefinition.subclassName))
        )
      );
    this._choices = this.noMods ? [] : _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getChoices */ .Z.getChoices(this.ddbData, this.type, this.ddbDefinition);
    this.isChoiceFeature = this._choices.length > 0;
    this.include = !this.isChoiceFeature;
    this.hasRequiredLevel = !this._class || (this._class && this._class.level >= this.ddbDefinition.requiredLevel);

    this.advancementHelper = new _advancements_AdvancementHelper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z({
      ddbData: this.ddbData,
      type: this.type,
      noMods: this.noMods,
    });
  }

  _generateDataStub() {
    this.data = {
      _id: foundry.utils.randomID(),
      name: _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].nameString */ .Z.nameString(this.ddbDefinition.name),
      type: this.documentType,
      system: _lib_utils_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getTemplate */ .Z.getTemplate(this.documentType),
      flags: {
        ddbimporter: {
          id: this.ddbDefinition.id,
          type: this.tagType,
          entityTypeId: this.ddbDefinition.entityTypeId,
          dndbeyond: {
            requiredLevel: this.ddbDefinition.requiredLevel,
            displayOrder: this.ddbDefinition.displayOrder,
            featureType: this.ddbDefinition.featureType,
            classId: this.ddbDefinition.classId,
            entityId: this.ddbDefinition.entityId,
            entityRaceId: this.ddbDefinition.entityRaceId,
            entityType: this.ddbDefinition.entityType,
          },
        },
        obsidian: {
          source: {
            type: this.tagType,
          },
        },
      }
    };

    const requiredLevel = foundry.utils.getProperty(this.ddbDefinition, "requiredLevel");
    if (Number.isInteger(Number.parseInt(requiredLevel))) {
      this.data.system.prerequisites = {
        level: Number.parseInt(requiredLevel),
      };
    }
  }

  // eslint-disable-next-line class-methods-use-this
  _prepare() {
    // override this feature
  }

  _buildUnarmed() {
    const override = {
      name: this.data.name,
      description: this.ddbDefinition.description,
      snippet: this.ddbDefinition.snippet,
      id: this.ddbDefinition.id,
      entityTypeId: this.ddbDefinition.entityTypeId,
      componentId: this.ddbDefinition.componentId,
      componentTypeId: this.ddbDefinition.componentTypeId,
    };

    const unarmedStrikeMock = foundry.utils.deepClone(CONFIG.DDB.naturalActions[0]);
    unarmedStrikeMock.displayAsAttack = true;
    const strikeMock = Object.assign(unarmedStrikeMock, override);

    const ddbAttackAction = new _DDBAttackAction_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z({
      ddbData: this.ddbData,
      ddbDefinition: strikeMock,
      rawCharacter: this.rawCharacter,
      type: this.type,
      documentType: "weapon",
    });
    ddbAttackAction.build();

    this.data = ddbAttackAction.data;
  }

  _buildBasic() {
    this._generateSystemType();
    this._generateSystemSubType();

    // this._generateLimitedUse();
    // this._generateRange();
    // this._generateResourceConsumption();
    // this._generateActivation();
    // this._generateLevelScaleDice();

    this.data.system.source = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].parseSource */ .Z.parseSource(this.ddbDefinition);

    this._generateDescription(true);
    this._addEffects(undefined, this.type);

    // this._generateFlagHints();
    // this._generateResourceFlags();
    // this._addCustomValues();
  }

  async _generateFeatureAdvancements() {
    // STUB
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info(`Generating feature advancements for ${this.ddbDefinition.name} are not yet supported`);
  }

  _addAdvancement(advancement) {
    if (!advancement) return;
    const advancementData = advancement.toObject();
    if (
      advancementData.configuration.choices.length !== 0
      || advancementData.configuration.grants.length !== 0
      || (advancementData.value && Object.keys(advancementData.value).length !== 0)
    ) {
      // console.warn(advancementData)
      // console.warn("ADVANCEMENT", {
      //   advancement,
      //   advancementData,
      //   choicebool: advancementData.configuration.choices.length !== 0,
      //   grantbool: advancementData.configuration.grants.length !== 0,
      //   valuebool: (advancementData.value && Object.keys(advancementData.value).length !== 0),
      // });
      this.data.system.advancement.push(advancementData);
    }
  }

  _generateSkillAdvancements() {
    const mods = this.advancementHelper.noMods
      ? []
      : _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, this.type);
    const skillExplicitMods = mods.filter((mod) =>
      mod.type === "proficiency"
      && _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.skills.map */ .Z.character.skills.map((s) => s.subType).includes(mod.subType)
    );
    const advancement = this.advancementHelper.getSkillAdvancement(skillExplicitMods, this.ddbDefinition, undefined, 0);
    this._addAdvancement(advancement);
  }

  _generateLanguageAdvancements() {
    const mods = this.advancementHelper.noMods
      ? []
      : _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, this.type);

    const advancement = this.advancementHelper.getLanguageAdvancement(mods, this.ddbDefinition, 0);
    this._addAdvancement(advancement);
  }

  _generateToolAdvancements() {
    const mods = this.advancementHelper.noMods
      ? []
      : _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, this.type);
    const advancement = this.advancementHelper.getToolAdvancement(mods, this.ddbDefinition, 0);
    this._addAdvancement(advancement);
  }

  _generateSkillOrLanguageAdvancements() {
    // STUB
    _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].info */ .Z.info(`Generating skill or language advancements for ${this.ddbDefinition.name} are not yet supported`);
  }

  async generateAdvancements() {
    await this._generateFeatureAdvancements();
    this._generateSkillAdvancements();
    this._generateLanguageAdvancements();
    this._generateToolAdvancements();
    // FUTURE: Equipment?  needs better handling in Foundry
    this._generateSkillOrLanguageAdvancements();
  }

  async buildBackgroundFeatAdvancements(extraFeatIds = []) {
    const characterFeatIds = foundry.utils.getProperty(this.ddbData, "character.background.definition.featList.featIds") ?? [];
    const featIds = extraFeatIds.concat(characterFeatIds);
    if (featIds.length === 0) return;

    const advancement = new game.dnd5e.documents.advancement.ItemGrantAdvancement();
    const indexFilter = {
      fields: [
        "name",
        "flags.ddbimporter.featId",
      ],
    };
    const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getCompendiumType */ .Z.getCompendiumType("feats");
    await compendium.getIndex(indexFilter);

    const feats = compendium.index.filter((f) => featIds.includes(foundry.utils.getProperty(f, "flags.ddbimporter.featId")));

    advancement.updateSource({
      configuration: {
        items: feats.map((f) => {
          return { uuid: f.uuid };
        }),
      },
      title: "Feat",
    });
    this.data.system.advancement.push(advancement.toObject());

    const advancementLinkData = foundry.utils.getProperty(this.data, "flags.ddbimporter.advancementLink") ?? [];
    const advancementData = {
      _id: advancement._id,
      features: {}
    };
    advancementData[advancement._id] = {};
    feats.forEach((f) => {
      advancementData.features[f.name] = f.uuid;
    });
    advancementLinkData.push(advancementData);
    foundry.utils.setProperty(this.data, "flags.ddbimporter.advancementLink", advancementLinkData);
  }

  _buildBackground() {
    try {
      this._generateSystemType();
      this._generateSystemSubType();

      this.data.system.source = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].parseSource */ .Z.parseSource(this.ddbDefinition);

      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Found background ${this.ddbDefinition.name}`);
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`Found ${this._choices.map((c) => c.label).join(",")}`);

      this._generateDescription(true);
      this.data.system.description.value += `<h3>Proficiencies</h3><ul>`;
      this._choices.forEach((choice) => {
        this._addEffects(choice, this.type);
        this.data.system.description.value += `<li>${choice.label}</li>`;
      });
      this.data.system.description.value += `</ul>`;
      this.data.img = "icons/skills/trades/academics-book-study-purple.webp";
      this.data.name = this.data.name.split("Background: ").pop();

    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn(
        `Unable to Generate Background Feature: ${this.name}, please log a bug report. Err: ${err.message}`,
        "extension"
      );
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error("Error", err);
    }
  }


  build() {
    try {
      if (DDBFeature.FORCE_UNARMED.includes(this.data.name)) {
        this._buildUnarmed();
      } else if (this.type === "background") {
        // work around till background parsing support advancements
        this.isChoiceFeature = false;
        this._buildBackground();
      } else if (this.isChoiceFeature) {
        _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].debug */ .Z.debug(`${this.name} has multiple choices and you  need to pass this instance to DDBChoiceFeature`);
        //  DDBChoiceFeature.buildChoiceFeatures(this);
      } else {
        this._buildBasic();
      }
    } catch (err) {
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].warn */ .Z.warn(
        `Unable to Generate Basic Feature: ${this.name}, please log a bug report. Err: ${err.message}`,
        "extension"
      );
      _logger_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].error */ .Z.error("Error", err);
    }
  }

}


/***/ }),

/***/ 1278:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "f": () => (/* binding */ addExtraEffects),
/* harmony export */   "t": () => (/* binding */ fixFeatures)
/* harmony export */ });
/* harmony import */ var _lib_DDBTable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5366);
/* harmony import */ var _effects_specialFeats_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6696);



/**
 * Some features we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} features
 */
// eslint-disable-next-line complexity
async function fixFeatures(features) {
  for (let feature of features) {
    const name = foundry.utils.getProperty(feature, "flags.ddbimporter.originalName") ?? feature.name;
    // eslint-disable-next-line no-continue
    if (foundry.utils.getProperty(feature, "flags.ddbimporter.isCustomAction") === true) continue;
    switch (name) {
      case "Action Surge": {
        feature.system.damage = { parts: [], versatile: "", value: "" };
        break;
      }
      case "Arcane Propulsion Armor Gauntlet": {
        feature.system.damage.parts[0][0] += " + @mod";
        break;
      }
      case "Arms of the Astral Self: Summon": {
        feature.system.target.type = "enemy";
        feature.system.target.units = "all";
        feature.system.range.value = 10;
        feature.system.range.units = "ft";
        break;
      }
      case "Arms of the Astral Self (DEX/STR)": {
        feature.system.properties.push("fin");
        feature.system.ability = "";
        break;
      }
      case "Bardic Inspiration": {
        feature.system.actionType = "util";
        feature.system.duration = {
          value: 10,
          units: "minute",
        };
        feature.system.target = {
          value: 1,
          width: null,
          units: "",
          type: "creature",
        };
        feature.system.range.value = 60;
        feature.system.range.units = "ft";
        break;
      }
      case "Blessed Healer": {
        feature.system.activation.type = "special";
        feature.system.activation.cost = null;
        feature.system.actionType = "heal";
        feature.system["target"]["type"] = "self";
        feature.system.range = { value: null, units: "self", long: null };
        feature.system.uses = { value: null, max: "0", per: "", type: "" };
        break;
      }
      case "Celestial Revelation": {
        feature.system.activation.type = "";
        feature.system.actionType = "";
        feature.system.uses = {
          value: null,
          max: null,
          per: "",
        };
        break;
      }
      case "Channel Divinity: Radiance of the Dawn":
        feature.system.damage = {
          parts: [["2d10[radiant] + @classes.cleric.levels", "radiant"]],
          versatile: "",
          value: "",
        };
        break;
      case "Channel Divinity: Sacred Weapon":
        feature.system["target"]["type"] = "self";
        feature.system.duration = {
          value: 1,
          units: "minute",
        };
        break;
      case "Daunting Roar": {
        feature.system.target = {
          value: 10,
          units: "ft",
          type: "radius",
        };
        feature.system.range.units = "self";
        break;
      }
      case "Dark Ones Blessing":
      case "Dark One's Blessing": {
        feature.system.damage = { parts: [["@classes.warlock.level + @mod", "temphp"]], versatile: "", value: "" };
        feature.system.actionType = "heal";
        feature.system.ability = "cha";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        feature.system.activation.condition = "Reduce a hostile creature to 0 HP";
        break;
      }
      case "Deflect Missiles": {
        feature.system.damage = { parts: [["1d10 + @mod + @classes.monk.levels"]], versatile: "", value: "" };
        break;
      }
      case "Divine Intervention":
        feature.system.damage = { parts: [["1d100", ""]], versatile: "", value: "" };
        feature.system.actionType = "other";
        break;
      case "Draconic Resilience": {
        if (feature.effects.length === 1) {
          const toKeepChanges = feature.effects[0].changes.filter((change) => !change.key.includes("system.attributes.ac"));
          feature.effects[0].changes = [
            ...toKeepChanges,
            {
              key: "system.attributes.ac.calc",
              value: "draconic",
              mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
              priority: 15,
            },
          ];
        }
        break;
      }
      case "Eldritch Cannon: Force Ballista":
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range.value = 120;
        feature.system.range.units = "ft";
        feature.system.ability = "int";
        feature.system.actionType = "rsak";
        feature.system.chatFlavor = "On hit pushed 5 ft away.";
        feature.system.damage = { parts: [["2d8[force]", "force"]], versatile: "", value: "" };
        break;
      case "Eldritch Cannon: Flamethrower":
        feature.system.damage = { parts: [["2d8[fire]", "fire"]], versatile: "", value: "" };
        break;
      case "Eldritch Cannon: Protector":
        feature.system.target.units = "any";
        feature.system.target.type = "ally";
        feature.system.range.value = 10;
        feature.system.ability = "int";
        feature.system.actionType = "heal";
        feature.system.damage = { parts: [["1d8 + @mod", "temphp"]], versatile: "", value: "" };
        break;
      case "Extra Attack": {
        feature.system.activation = { type: "", cost: 0, condition: "" };
        feature.system.actionType = "";
        feature.system.range.value = null;
        break;
      }
      case "Fighting Style: Interception":
        feature.system.damage = { parts: [["1d10 + @prof", ""]], versatile: "", value: "" };
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        break;
      case "Form of the Beast: Tail (reaction)":
        feature.system.actionType = "other";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        break;
      case "Guardian Armor: Defensive Field": {
        feature.system.damage = { parts: [["@classes.artificer.levels", "temphp"]], versatile: "", value: "" };
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        feature.system.actionType = "heal";
        break;
      }
      case "Genie's Vessel: Genie's Wrath (Dao)": {
        feature.system.activation.type = "special";
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range.units = "spec";
        feature.system.actionType = "util";
        feature.system.duration.units = "inst";
        feature.system.damage = { parts: [["@prof", "bludgeoning"]], versatile: "", value: "" };
        break;
      }
      case "Giant's Might": {
        feature.system["target"]["type"] = "self";
        feature.system.range = { value: null, units: "self", long: null };
        feature.system.duration = {
          value: 1,
          units: "minute",
        };
        break;
      }
      case "Ghostly Gaze": {
        feature.system.duration = {
          value: 1,
          units: "minute",
        };
        break;
      }
      case "Hand of Healing": {
        feature.system.actionType = "heal";
        break;
      }
      case "Harness Divine Power": {
        feature.system.damage = { parts: [], versatile: "", value: "" };
        break;
      }
      case "Healing Hands": {
        feature.system.damage = {
          parts: [["@details.level[healing]", "healing"]],
          versatile: "",
          value: "",
        };
        feature.system.actionType = "heal";
        feature.system.target.type = "creature";
        feature.system.range = {
          type: "touch",
          value: null,
          long: null,
          units: "touch"
        };
        break;
      }
      case "Healing Light": {
        feature.system.actionType = "heal";
        feature.system.damage = { parts: [["1d6", "healing"]], versatile: "", value: "" };
        break;
      }
      case "Hold Breath": {
        feature.system.duration = { value: 1, units: "hour" };
        feature.system["target"]["type"] = "self";
        feature.system.range = { value: null, units: "self", long: null };
        break;
      }
      case "Hound of Ill Omen": {
        feature.system.consume.amount = 3;
        break;
      }
      case "Intimidating Presence": {
        feature.system.duration = { value: 2, units: "turns" };
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range = { value: 30, units: "ft", long: null };
        feature.system.actionType = "save";
        feature.system.save.ability = "wis";
        feature.system.save.scaling = "cha";
        break;
      }
      case "Hypnotic Gaze": {
        feature.system.uses = {
          value: null,
          max: null,
          per: "",
        };
        break;
      }
      case "Lay on Hands": {
        feature.system.activation = { type: "action", cost: 1, condition: "" };
        feature.system.range = {
          type: "touch",
          value: null,
          long: null,
          units: "touch"
        };
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.actionType = "other";
        feature.system.duration.units = "inst";
        feature.system.consume.amount = 0;
        feature.system.uses.prompt = false;
        break;
      }
      case "Mantle of Inspiration": {
        feature.system.damage.parts[0][1] = "temphp";
        break;
      }
      case "Metamagic - Heightened Spell": {
        feature.system.consume.amount = 3;
        break;
      }
      case "Metamagic - Quickened Spell": {
        feature.system.consume.amount = 2;
        break;
      }
      case "Mind Link Response": {
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.duration = { value: 1, units: "hour" };
        feature.system.range.units = "spec";
        break;
      }
      case "Momentary Stasis": {
        feature.system.actionType = "save";
        feature.system.save.ability = "con";
        break;
      }
      case "Polearm Master - Bonus Attack": {
        feature.system.actionType = "mwak";
        feature.system.range = { value: 10, long: null, units: "ft" };
        break;
      }
      case "Psionic Power: Recovery": {
        feature.system.damage = { parts: [], versatile: "", value: "" };
        foundry.utils.setProperty(feature, "system.consume.amount", -1);
        break;
      }
      case "Psychic Blades: Attack (DEX)":
      case "Psychic Blades: Attack (STR)":
      case "Psychic Blades: Bonus Attack (DEX)":
      case "Psychic Blades: Bonus Attack (STR)":
      case "Psychic Blades: Bonus Attack":
      case "Psychic Blades: Attack": {
        feature.system.actionType = "mwak";
        feature.system.properties.push("fin");
        feature.system.properties.push("thr");
        break;
      }
      case "Quickened Healing": {
        feature.system.actionType = "heal";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        feature.system.damage.parts[0][0] += " + @prof[healing]";
        feature.system.damage.parts[0][1] = "healing";
        break;
      }
      case "Celestial Revelation (Radiant Soul)":
      case "Radiant Soul": {
        if (foundry.utils.getProperty(feature, "flags.ddbimporter.type") == "race") {
          feature.system.uses = {
            value: 1,
            max: 1,
            per: "lr",
          };
        } else if (foundry.utils.getProperty(feature, "flags.ddbimporter.type") == "class") {
          feature.system.activation.type = "special";
        }
        break;
      }
      case "Rage": {
        feature.system.duration = {
          value: 1,
          units: "minute",
        };
        break;
      }
      case "Raging Storm: Desert": {
        feature.system.duration.units = "inst";
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range.value = 10;
        feature.system.damage.parts = [["floor(@classes.barbarian.levels / 2)", "fire"]];
        feature.system.save.scaling = "con";
        break;
      }
      case "Raging Storm: Sea": {
        feature.system.activation = { type: "special", cost: 0, condition: "" };
        feature.system.duration.units = "perm";
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range = { value: null, long: null, units: "" };
        feature.system.save.scaling = "con";
        break;
      }
      case "Raging Storm: Tundra": {
        feature.system.activation = { type: "special", cost: 0, condition: "" };
        feature.system.actionType = "save";
        feature.system.save = { ability: "str", dc: null, scaling: "con" };
        feature.system.duration.units = "perm";
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range.value = 10;
        break;
      }
      case "Second Wind":
        feature.system.damage = {
          parts: [["1d10[healing] + @classes.fighter.levels", "healing"]],
          versatile: "",
          value: "",
        };
        feature.system.actionType = "heal";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        break;
      case "Storm Aura: Desert": {
        feature.system.target = { value: 10, units: "ft", type: "creature" };
        feature.system.range = { value: null, long: null, units: "spec" };
        feature.system.duration.units = "inst";
        feature.system.damage.parts = [["@scale.path-of-the-storm-herald.storm-aura-desert", "fire"]];
        break;
      }
      case "Storm Aura: Sea": {
        feature.system.target = { value: 1, units: "", type: "creature" };
        feature.system.range = { value: 10, long: null, units: "ft" };
        feature.system.duration.units = "inst";
        feature.system.damage.parts = [["@scale.path-of-the-storm-herald.storm-aura-sea", "lightning"]];
        break;
      }
      case "Storm Aura: Tundra": {
        feature.system.actionType = "heal";
        feature.system.target = { value: 10, units: "ft", type: "ally" };
        feature.system.range = { value: null, long: null, units: "self" };
        feature.system.duration.units = "inst";
        feature.system.damage.parts = [["@scale.path-of-the-storm-herald.storm-aura-tundra", "temphp"]];
        break;
      }
      case "Shifting": {
        feature.system.actionType = "heal";
        feature.system.target.type = "self";
        feature.system.range = { value: null, long: null, units: "self" };
        feature.system.duration.units = "inst";
        feature.system.ability = "con";
        feature.system.actionType = "heal";
        feature.system.damage = { parts: [["@details.level + max(1,@mod)", "temphp"]], versatile: "", value: "" };
        break;
      }
      case "Shift": {
        feature.system.actionType = "heal";
        feature.system.target.type = "self";
        feature.system.range = { value: null, long: null, units: "self" };
        feature.system.duration = {
          value: 1,
          units: "minute",
        };
        feature.system.ability = "con";
        feature.system.actionType = "heal";
        feature.system.damage = { parts: [["2 * @prof", "temphp"]], versatile: "", value: "" };
        break;
      }
      case "Sneak Attack": {
        if (!foundry.utils.getProperty(feature, "flags.ddbimporter.action")) {
          feature.system.actionType = "other";
          feature.system.activation = { type: "special", cost: 0, condition: "" };
        }
        break;
      }
      case "Song of Rest": {
        feature.system.activation = { type: "hour", cost: 1, condition: "" };
        feature.system.actionType = "heal";
        feature.system.target.type = "creature";
        feature.system.range = { value: null, long: null, units: "spec" };
        feature.system.damage.parts[0][1] = "healing";
        foundry.utils.setProperty(feature, "flags.midiProperties.magicdam", true);
        foundry.utils.setProperty(feature, "flags.midiProperties.magiceffect", true);
        break;
      }
      case "Surprise Attack":
        feature.system.damage = { parts: [["2d6", ""]], versatile: "", value: "" };
        feature.system.activation.type = "special";
        break;
      case "Starry Form: Archer":
        feature.system.actionType = "rsak";
        feature.system.target.value = 1;
        feature.system.target.type = "creature";
        feature.system.range.units = "ft";
        feature.system.consume = { type: "", target: "", amount: null };
        break;
      case "Starry Form: Chalice":
        feature.system.damage.parts[0][1] = "healing";
        feature.system.actionType = "heal";
        feature.system.target.value = 1;
        feature.system.target.type = "ally";
        feature.system.range.value = 30;
        feature.system.range.units = "ft";
        feature.system.activation.type = "special";
        feature.system.consume = { type: "", target: "", amount: null };
        break;
      case "Starry Form: Dragon":
        break;
      case "Stone's Endurance":
      case "Stones Endurance":
        feature.system.damage = { parts: [["1d12 + @mod", ""]], versatile: "", value: "" };
        feature.system.actionType = "other";
        feature.system.ability = "con";
        feature.system.target.type = "self";
        feature.system.range.units = "self";
        feature.system.consume = { type: "", target: "", amount: null };
        break;
      case "Stunning Strike":
        feature.system.actionType = "save";
        feature.system.save = { ability: "con", dc: null, scaling: "wis" };
        feature.system.target = { value: null, width: null, units: "touch", type: "creature" };
        feature.system.range.units = "ft";
        break;
      case "Superiority Dice": {
        foundry.utils.setProperty(feature.system, "damage.parts", [["@scale.battle-master.combat-superiority-die"]]);
        break;
      }
      case "Summon Wildfire Spirit": {
        foundry.utils.setProperty(document, "system.target.value", 1);
        foundry.utils.setProperty(document, "system.target.type", "space");
        foundry.utils.setProperty(document, "system.range.units", "ft");
        foundry.utils.setProperty(document, "system.range.value", 30);
        foundry.utils.setProperty(document, "system.duration", {
          value: 1,
          units: "hour",
        });
        feature.system.damage = { parts: [["2d6", "fire"]], versatile: "", value: "" };
        feature.system.ability = "wis";
        feature.system.save = { ability: "dex", dc: null, scaling: "spell" };
        break;
      }
      case "Unarmored Defense": {
        if (feature.effects.length === 1) {
          const klass = foundry.utils.getProperty(feature, "flags.ddbimporter.class");
          if (klass == "Barbarian") {
            feature.effects[0].changes = [
              {
                key: "system.attributes.ac.calc",
                value: "unarmoredBarb",
                mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
                priority: 15,
              },
            ];
          } else if (klass === "Monk") {
            feature.effects[0].changes = [
              {
                key: "system.attributes.ac.calc",
                value: "unarmoredMonk",
                mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
                priority: 15,
              },
            ];
          }
        }
        break;
      }
      case "Wrath of the Storm": {
        feature.system.damage = { parts: [["2d8", "lightning"]], versatile: "", value: "" };
        break;
      }
      // no default
    }

    if (name.endsWith(" Breath Weapon") && feature.system.target?.type === "line") {
      feature.system.target.value = 30;
    } else if (name.endsWith("[Infusion] Spell-Refueling Ring")) {
      feature.system.activation.type = "action";
    }
    const tableDescription = await (0,_lib_DDBTable_js__WEBPACK_IMPORTED_MODULE_0__/* .generateTable */ .p)(feature.name, feature.system.description.value, true, feature.type);
    feature.system.description.value = tableDescription;
    const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");
    if (chatAdd && feature.system.description.chat !== "") {
      feature.system.description.chat = await (0,_lib_DDBTable_js__WEBPACK_IMPORTED_MODULE_0__/* .generateTable */ .p)(feature.name, feature.system.description.chat, true, feature.type);
    }
  }
}

async function addExtraEffects(ddb, documents, character) {
  const compendiumItem = character.flags.ddbimporter.compendium;
  const addCharacterEffects = compendiumItem
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-character-effects");

  const results = await Promise.all(documents.map((document) => {
    return (0,_effects_specialFeats_js__WEBPACK_IMPORTED_MODULE_1__/* .featureEffectAdjustment */ .M)(ddb, character, document, addCharacterEffects);
  }));
  return results;

}


/***/ }),

/***/ 9695:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ fixItems)
/* harmony export */ });
// import DICTIONARY from "../../dictionary.js";
// import logger from "../../logger.js";

function prepItem(item) {
  if (item.name.startsWith("Potion of")) {
    if (!item.system.duration) item.system.duration = { units: "", value: null };
    if (!item.system.target) item.system.target = { value: null, width: null, units: "", type: "creature" };
    if (!item.system.range) item.system.range = { value: null, long: null, units: "", type: "touch" };
  } else if (item.name.startsWith("Vicious")) {
    foundry.utils.setProperty(item, "system.critical", { damage: "+ 7", threshold: null });
  }
}

function tattoos(item) {
  if (!item.name.toLowerCase().includes("tattoo")) return;
  const name = item.flags.ddbimporter?.originalName ?? item.name;
  if (name.startsWith("Absorbing")) {
    item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: false, autoUse: true };
    // foundry.utils.setProperty(item, "flags.ddbimporter.effectLabelOverride", `${item.name}`);
    item.effects.map((effect) => {
      effect.name = item.name;
      return item;
    });
    item.system.activation.type = "reaction";
    item.system.activation.cost = 1;
    item.system.activation.condition = `When you take ${name.split(',').pop().trim().toLowerCase()} damage`;
    item.system.actionType = "heal";
    item.system.target = {
      value: null,
      width: null,
      units: "",
      type: "self",
    };
  } else if (name.includes("Blood Fury")) {
    item.system.activation.type = "special";
    item.system.actionType = "util";
  }

}

/**
 * Some items we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} items
 */
function fixItems(items) {
  // eslint-disable-next-line complexity
  items.forEach((item) => {
    prepItem(item);
    tattoos(item);
    const name = item.flags.ddbimporter?.originalName ?? item.name;
    switch (name) {
      case "Waterskin":
        item.system.activation.type = "special";
        item.system.uses = { value: 4, max: 4, per: "charges", autoDestroy: false, autoUse: true };
        break;
      case "Potion of Healing":
        item.system.damage = { parts: [["2d4 + 2", "healing"]], versatile: "", value: "" };
        item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.system["duration"]["value"] = 0;
        item.system.actionType = "heal";
        item.system["target"]["type"] = "creature";
        item.system["range"]["type"] = "touch";
        break;
      case "Potion of Healing (Greater)":
      case "Potion of Greater Healing":
        item.system.damage = { parts: [["4d4 + 4", "healing"]], versatile: "", value: "" };
        item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.system["duration"]["value"] = 0;
        item.system.actionType = "heal";
        item.system["target"]["type"] = "creature";
        item.system["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = ["Potion of Greater Healing"];
        break;
      case "Potion of Healing (Superior)":
      case "Potion of Superior Healing":
        item.system.damage = { parts: [["8d4 + 8", "healing"]], versatile: "", value: "" };
        item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.system["duration"]["value"] = 0;
        item.system.actionType = "heal";
        item.system["target"]["type"] = "creature";
        item.system["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = [
          "Potion of Superior Healing",
          "potion of superior healing",
        ];
        break;
      case "Potion of Healing (Supreme)":
      case "Potion of Supreme Healing":
        item.system.damage = { parts: [["10d4 + 20", "healing"]], versatile: "", value: "" };
        item.system.uses = { value: 1, max: 1, per: "charges", autoDestroy: true, autoUse: true };
        item.system["duration"]["value"] = 0;
        item.system.actionType = "heal";
        item.system["target"]["type"] = "creature";
        item.system["range"]["type"] = "touch";
        item.flags["ddbimporter"]["dndbeyond"]["alternativeNames"] = ["Potion of Supreme Healing"];
        break;
      case "Iron Bands of Binding":
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.uses = { value: 1, max: "1", per: "day" };
        item.system.range = { value: 60, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.save = { ability: "str", dc: 20, scaling: "flat" };
        item.system.target = { value: 1, width: null, units: "any", type: "creature" };
        break;
      case "Far Realm Shard": {
        item.system.activation.type = "special";
        item.system.actionType = "save";
        item.system.damage = { parts: [["3d6[psychic]", "psychic"]], versatile: "", value: "" };
        item.system.save = {
          ability: "cha",
          dc: null,
          scaling: "spell",
        };
        break;
      }
      case "Acid (vial)": {
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 1, width: null, units: "any", type: "creature" };
        item.system.range = { value: 20, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["2d6[acid]", "acid"]], versatile: "", value: "" };
        break;
      }
      case "Bead of Force": {
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 10, width: null, units: "ft", type: "radius" };
        item.system.range = { value: 60, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.duration = { units: "minute", value: 1 };
        item.system.uses = { value: 1, max: "1", per: "" };
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["5d4[force]", "force"]], versatile: "", value: "" };
        item.system.save = {
          ability: "dex",
          dc: 15,
          scaling: "flat",
        };
        break;
      }
      case "Alchemist's Fire (flask)":
      case "Alchemist's Fire": {
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 1, width: null, units: "any", type: "creature" };
        item.system.range = { value: 20, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["1d4[fire]", "fire"]], versatile: "", value: "" };
        item.system.save = {
          ability: "dex",
          dc: 10,
          scaling: "flat",
        };
        break;
      }
      case "Bomb": {
        item.type = "consumable";
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 5, width: null, units: "ft", type: "radius" };
        item.system.range = { value: 60, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["3d6[fire]", "fire"]], versatile: "", value: "" };
        item.system.save = {
          ability: "dex",
          dc: 12,
          scaling: "flat",
        };
        break;
      }
      case "Canaith Mandolin": {
        foundry.utils.setProperty(item, "flags.magicitems.charges", "1");
        foundry.utils.setProperty(item, "flags.magicitems.chargeType", "c2");
        foundry.utils.setProperty(item, "flags.magicitems.recharge", "1");
        foundry.utils.setProperty(item, "flags.magicitems.rechargeType", "t1");
        break;
      }
      case "Grenade, Fragmentation": {
        item.type = "consumable";
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 20, width: null, units: "ft", type: "radius" };
        item.system.range = { value: 60, long: null, units: "ft" };
        item.system.ability = "dex";
        item.system.actionType = "rwak";
        item.system.chatFlavor = "improvised weapon";
        item.system.damage = { parts: [["5d6[piercing]", "piercing"]], versatile: "", value: "" };
        item.system.save = {
          ability: "dex",
          dc: 15,
          scaling: "flat",
        };
        break;
      }
      case "Healer's Kit": {
        item.system.activation = { type: "action", cost: 1, condition: "" };
        item.system.target = { value: 1, width: null, units: "any", type: "creature" };
        item.system.range = { value: 20, long: null, units: "ft" };
        item.system.uses = { value: 10, max: "10", per: "charge" };
        foundry.utils.setProperty(item, "flags.ddbimporter.retainResourceConsumption", true);
        break;
      }
      case "Wand of Fireballs": {
        if (!game.modules.get("magicitems")?.active
          && !game.modules.get("magic-items-2")?.active
          && !game.modules.get("items-with-spells-5e")?.active
        ) {
          item.system.damage = { parts: [["8d6", "fire"]], versatile: "1d6", value: "" };
          item.system.save = {
            ability: "dex",
            dc: 15,
            scaling: "flat",
          };
          item.system.range = { value: 150, long: null, units: "ft" };
          item.system.target = { value: 20, width: null, units: "ft", type: "sphere" };
          item.system.uses.per = "charges";
        }
        break;
      }
      case "Wand of Magic Missiles": {
        if (!game.modules.get("magicitems")?.active
          && !game.modules.get("magic-items-2")?.active
          && !game.modules.get("items-with-spells-5e")?.active
        ) {
          item.system.damage = { parts: [["3d4 + 3", "force"]], versatile: "1d4 + 1", value: "" };
          item.system.range = { value: 120, long: null, units: "ft" };
        }
        break;
      }
      // no default
    }
  });
}


/***/ }),

/***/ 512:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBMonsterFeature)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _lib_DDBTable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5366);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6451);
/* harmony import */ var _lib_DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7162);







class DDBMonsterFeature {

  #generateAdjustedName() {
    this.originalName = `${this.name}`;
    if (!this.stripName) return;
    const regex = /(.*)\s*\((:?costs? \d actions|Recharges after a (Short or Long|Long) Rest|(?!Spell;|Psionics;).*\d\/day|recharge \d ?- ?\d|Recharge \d)\)/i;
    const nameMatch = this.name.replace(/[-]/g, "-").match(regex);
    if (nameMatch) {
      this.feature.name = nameMatch[1].trim();
      this.nameSplit = nameMatch[2];
    } else {
      const regex2 = /(.*)\s*\((.*); (:?costs \d actions|Recharges after a (Short or Long|Long) Rest|(?!Spell;|Psionics;).*\d\/day|recharge \d-\d|Recharge \d)\)/i;
      const nameMatch2 = this.name.replace(/[-]/g, "-").match(regex2);
      if (nameMatch2) {
        this.feature.name = `${nameMatch2[1].trim()} (${nameMatch2[2].trim()})`;
        this.nameSplit = nameMatch2[3];
      }
    }
  }

  createBaseFeature() {
    this.feature = {
      _id: foundry.utils.randomID(),
      name: this.name,
      type: this.templateType,
      system: _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].getTemplate */ .Z.getTemplate(this.templateType),
      effects: [],
      flags: {
        ddbimporter: {
          levelBonus: false,
          dndbeyond: {
          },
        },
        monsterMunch: {
          titleHTML: this.titleHTML,
          fullName: this.fullName,
          actionCopy: this.actionCopy,
          type: this.type,
        }
      },
    };
    // these templates not good
    this.feature.system.duration.value = "";
    this.feature.system.requirements = "";
    this.levelBonus = false;
  }

  // prepare the html in this.html for a parse, runs some checks and pregen to calculate values
  prepare() {
    this.strippedHtml = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].stripHtml */ .Z.stripHtml(`${this.html}`).trim();

    const matches = this.strippedHtml.match(
      /(Melee|Ranged|Melee\s+or\s+Ranged)\s+(|Weapon|Spell)\s*Attack:\s*([+-]\d+|your (?:\w+\s*)*)\s+(plus PB\s|\+ PB\s)?to\s+hit/i
    );

    const healingRegex = /(regains|regain)\s+?(?:([0-9]+))?(?: *\(?([0-9]*d[0-9]+(?:\s*[-+]\s*[0-9]+)??)\)?)?\s+hit\s+points/i;
    const healingMatch = healingRegex.test(this.strippedHtml);

    // set calc flags
    this.isAttack = matches ? matches[1] !== undefined : false;
    this.pbToAttack = matches ? matches[4] !== undefined : false;
    this.weaponAttack = matches
      ? (matches[2].toLowerCase() === "weapon" || matches[2] === "")
      : false;
    this.spellAttack = matches ? matches[2].toLowerCase() === "spell" : false;
    this.meleeAttack = matches ? matches[1].indexOf("Melee") !== -1 : false;
    this.rangedAttack = matches ? matches[1].indexOf("Ranged") !== -1 : false;
    this.healingAction = healingMatch;
    this.toHit = matches
      ? Number.isInteger(parseInt(matches[3]))
        ? parseInt(matches[3])
        : 0
      : 0;
    this.isRecharge = this.#matchRecharge();
    this.templateType = this.isAttack && this.isRecharge === null ? "weapon" : "feat";
    this.yourSpellAttackModToHit = matches ? matches[3]?.startsWith("your spell") : false;

    if (!this.feature) this.createBaseFeature();
    this.#generateAdjustedName();

    // if not attack set to a monster type action
    if (!this.isAttack) foundry.utils.setProperty(this.feature, "system.type.value", "monster");

  }

  constructor(name, { ddbMonster, html, type, titleHTML, fullName, actionCopy, updateExisting, hideDescription } = {}) {

    this.name = name.trim();
    this.ddbMonster = ddbMonster;
    this.type = type;
    this.html = html ?? "";
    this.titleHTML = titleHTML ?? undefined;
    this.fullName = fullName ?? this.name;
    this.actionCopy = actionCopy ?? false;

    this.hideDescription = hideDescription ?? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-hide-description");
    this.updateExisting = updateExisting ?? game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-update-existing");
    this.stripName = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-monster-strip-name");

    this.prepare();

    // copy source details from parent
    if (this.ddbMonster) this.feature.system.source = this.ddbMonster.npc.system.details.source;

    this.actionInfo = {
      baseItem: null,
      baseTool: null,
      damage: {
        parts: [],
        versatile: ""
      },
      formula: "",
      damageSave: {
        dc: null,
        ability: null
      },
      target: {
        "value": null,
        "width": null,
        "units": "",
        "type": ""
      },
      duration: {
        "value": "",
        "units": "inst"
      },
      extraAttackBonus: 0,
      baseAbility: null,
      proficient: false,
      properties: {
        "amm": false,
        "fin": false,
        "fir": false,
        "foc": false,
        "hvy": false,
        "lgt": false,
        "lod": false,
        "rch": false,
        "rel": false,
        "ret": false,
        "spc": false,
        "thr": false,
        "two": false,
        "ver": false,
        "mgc": false
      },
      reach: "",
      range: {
        value: null,
        long: null,
        units: "",
      },
      recharge: { value: null, charged: true },
      activation: {
        type: "",
        cost: null,
        condition: ""
      },
      save: {
        dc: null,
        ability: "",
        scaling: "flat",
      },
      uses: {
        value: null,
        max: "",
        per: null,
        recovery: "",
      },
    };

  }

  damageModReplace(text, damageType) {
    let result;
    const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
    const damageHint = globalDamageHints && damageType ? `[${damageType}]` : "";
    const diceParse = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].parseDiceString */ .Z.parseDiceString(text, null, damageHint);
    if (this.actionInfo.baseAbility) {
      const baseAbilityMod = this.ddbMonster.abilities[this.actionInfo.baseAbility].mod;
      const bonusMod = (diceParse.bonus && diceParse.bonus !== 0) ? diceParse.bonus - baseAbilityMod : "";
      const useMod = (diceParse.bonus && diceParse.bonus !== 0) ? " + @mod " : "";
      const reParse = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].diceStringResultBuild */ .Z.diceStringResultBuild(diceParse.diceMap, diceParse.dice, bonusMod, useMod, damageHint);
      result = reParse.diceString;
    } else {
      result = diceParse.diceString;
    }

    return result;
  }

  // eslint-disable-next-line complexity
  generateExtendedDamageInfo() {
    const hitIndex = this.strippedHtml.indexOf("Hit:");
    let hit = (hitIndex > 0) ? this.strippedHtml.slice(hitIndex) : `${this.strippedHtml}`;
    hit = hit.split("At the end of each")[0].split("At the start of each")[0];
    hit = hit.replace(/[-]/g, "-");
    // console.warn(hit);
    // Using match with global modifier then map to regular match because RegExp.matchAll isn't available on every browser
    // eslint-disable-next-line no-useless-escape
    const damageExpression = new RegExp(/((?:takes|saving throw or take\s+)|(?:[\w]*\s+))(?:([0-9]+))?(?:\s*\(?([0-9]*d[0-9]+(?:\s*[-+]\s*(?:[0-9]+|PB|the spell[']s level))*(?:\s+plus [^\)]+)?)\)?)?\s*([\w ]*?)\s*damage(?: when used with | if (?:used|wielded) with )?(\s?two hands|\s?at the start of|\son a failed save)?/gi);

    const matches = [...hit.matchAll(damageExpression)];
    const regainExpression = new RegExp(/(regains|regain)\s+?(?:([0-9]+))?(?: *\(?([0-9]*d[0-9]+(?:\s*[-+]\s*[0-9]+)??)\)?)?\s+hit\s+points/);
    const regainMatch = hit.match(regainExpression);

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`${this.name} Damage matches`, { hit, matches, regainMatch });
    let versatile = false;
    for (const dmg of matches) {
      let other = false;
      let thisVersatile = false;
      let thisOther = false;
      if (dmg[1] == "DC " || dmg[4] == "hit points by this") {
        continue; // eslint-disable-line no-continue
      }
      // check for versatile
      if (dmg[1] == "or " || dmg[5] == "two hands") {
        versatile = true;
      }
      // check for other
      if (dmg[5] && dmg[5].trim() == "at the start of") other = true;
      const profBonus = dmg[3]?.includes(" + PB") || dmg[3]?.includes(" plus PB") ? "@prof" : "";
      const levelBonus = dmg[3] && (/the spell[']s level/i).test(dmg[3]); // ? "@item.level" : "";
      if (levelBonus) {
        this.levelBonus = true;
        foundry.utils.setProperty(this, "flags.ddbimporter.levelBonus", true);
      }
      const damage = profBonus !== "" || levelBonus
        ? `${dmg[2]}${dmg[3].replace(" + PB", "").replace(" plus PB", "").replace(" + the spells level", "").replace(" + the spell's level", "")}`
        : dmg[3] ?? dmg[2];

      // Make sure we did match a damage
      if (damage) {
        const includesDiceRegExp = /[0-9]*d[0-9]+/;
        const includesDice = includesDiceRegExp.test(damage);
        const parsedDiceDamage = (this.actionInfo && includesDice)
          ? this.damageModReplace(damage.replace("plus", "+"), dmg[4])
          : damage.replace("plus", "+");

        const finalDamage = [parsedDiceDamage, profBonus].filter((t) => t !== "").join(" + ");

        // if this is a save based attack, and multiple damage entries, we assume any entry beyond the first is going into
        // versatile for damage
        // ignore if dmg[1] is and as it likely indicates the whole thing is a save
        if ((((dmg[5] ?? "").trim() == "on a failed save" && (dmg[1] ?? "").trim() !== "and")
            || (dmg[1] && dmg[1].includes("saving throw")))
          && this.actionInfo.damage.parts.length >= 1
        ) {
          other = true;
          thisOther = true;
        }
        // assumption here is that there is just one field added to versatile. this is going to be rare.
        if (other) {
          if (this.actionInfo.formula == "") this.actionInfo.formula = finalDamage;
          else this.actionInfo.formula += ` + ${finalDamage}`;

          if (!thisOther && dmg[1].trim() == "plus") {
            this.actionInfo.damage.versatile += ` + ${finalDamage}`;
            this.actionInfo.damage.parts.push([finalDamage, dmg[4]]);
          }
        } else if (versatile) {
          if (this.actionInfo.damage.versatile == "") this.actionInfo.damage.versatile = finalDamage;
          // so things like the duergar mind master have oddity where we might want to use a different thing
          // } else {
          //   result.damage.versatile += ` + ${finalDamage}`;
          // }
          if (!thisVersatile && dmg[1].trim() == "plus") {
            this.actionInfo.damage.versatile += ` + ${finalDamage}`;
            this.actionInfo.damage.parts.push([finalDamage, dmg[4]]);
          }
        } else {
          this.actionInfo.damage.parts.push([finalDamage, dmg[4]]);
        }
      }
    }

    if (regainMatch) {
      const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
      const damageHint = globalDamageHints ? `[healing]` : "";
      const damageValue = regainMatch[3] ? regainMatch[3] : regainMatch[2];
      this.actionInfo.damage.parts.push([_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].parseDiceString */ .Z.parseDiceString(damageValue, null, damageHint).diceString, 'healing']);
      this.feature.system.actionType = "heal";
    }

    const save = hit.match(/DC ([0-9]+) (.*?) saving throw|\(save DC ([0-9]+)\)/);
    if (save) {
      this.actionInfo.damageSave.dc = save[1];
      this.actionInfo.damageSave.ability = save[2] ? save[2].toLowerCase().substr(0, 3) : "";
    } else {
      const escape = hit.match(/escape DC ([0-9]+)/);
      if (escape) {
        this.actionInfo.damageSave.dc = escape[1];
        this.actionInfo.damageSave.ability = "Escape";
      }
    }
  }

  getAction() {
    let action = this.type;
    // foundry doesn't support mythic actions pre 1.6
    if (this.type === "mythic") action = "mythic";
    if (this.type === "villain") action = "special";
    const actionAction = this.strippedHtml.toLowerCase().match(/as (a|an) action/);
    const bonusAction = this.strippedHtml.toLowerCase().match(/as a bonus action/);
    const reAction = this.strippedHtml.toLowerCase().match(/as a reaction/);
    // e.g. mephit death
    const specialDie = this.strippedHtml.toLowerCase().match(/dies/);
    if (bonusAction) {
      action = "bonus";
    } else if (reAction) {
      action = "reaction";
    } else if (specialDie) {
      action = "special";
    } else if (actionAction) {
      action = "action";
    }
    return action;
  }

  getUses(name = false) {
    let uses = {
      value: null,
      max: "",
      per: null,
      recovery: "",
    };

    const usesSearch = name ? /(\d+)\/(\w+)\)/ : /\((\d+)\/(\w+)\)/;
    const matchString = name
      ? this.titleHTML
        ? this.titleHTML
        : this.name
      : this.strippedHtml;
    const usesMatch = matchString.match(usesSearch);
    // console.log(usesMatch);
    if (usesMatch && usesMatch[2].toLowerCase() !== "turn") {
      uses.value = Number.parseInt(usesMatch[1]);
      uses.max = usesMatch[1];
      uses.per = "day";
      const perMatch = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].monsters.resets.find */ .Z.monsters.resets.find((reset) => reset.id === usesMatch[2]);
      if (perMatch) uses.per = perMatch.value;
    } else {
      const shortLongRegex = (/Recharges after a (Short or Long|Long) Rest/i);
      const rechargeMatch = matchString.match(shortLongRegex);
      if (rechargeMatch) {
        uses.per = rechargeMatch[1] === "Long" ? "lr" : "sr";
        uses.value = 1;
        uses.max = 1;
      }
    }

    return uses;
  }

  #matchRecharge() {
    const matches = this.fullName.toLowerCase().match(/(?:\(|; )recharge ([0-9-]+)\)/);
    return matches;
  }

  getRecharge() {
    const matches = this.isRecharge;
    if (matches) {
      const value = matches[1].replace(/[-]/, "-").split("-").shift();
      return {
        value: parseInt(value),
        charged: true
      };
    }

    return {
      value: null,
      charged: false
    };
  }

  getActivation() {
    const matches = this.strippedHtml.match(/\(costs ([0-9]+) actions\)/i);
    if (matches) return parseInt(matches[1]);
    const nameMatch = this.name.match(/\(costs ([0-9]+) actions\)/i);
    if (nameMatch) return parseInt(nameMatch[1]);
    return null;
  }

  getFeatSave() {
    const saveSearch = /DC (\d+) (\w+) (saving throw|check)/i;
    const match = this.strippedHtml.match(saveSearch);
    if (match) {
      this.actionInfo.save.dc = parseInt(match[1]);
      this.actionInfo.save.ability = match[2].toLowerCase().substr(0, 3);
      this.actionInfo.save.scaling = "flat";
    } else {
      const saveSelfSearch = /(\w+) saving throw against your spell save DC/i;
      const selfMatch = this.strippedHtml.match(saveSelfSearch);
      if (selfMatch) {
        this.feature.system.actionType = "save";
        this.actionInfo.save.dc = 10;
        this.actionInfo.save.ability = selfMatch[1].toLowerCase().substr(0, 3);
        this.actionInfo.save.scaling = "flat";
      }
    }

    const halfSaveSearch = /or half as much damage on a successful one/i;
    const halfMatch = this.strippedHtml.match(halfSaveSearch);
    if (halfMatch) {
      if (this.isAttack) {
        foundry.utils.setProperty(this.feature, "flags.midiProperties.otherSaveDamage", "halfdam");
      } else {
        // foundry.utils.setProperty(this.feature, "flags.midiProperties.halfdam", true);
        foundry.utils.setProperty(this.feature, "flags.midiProperties.saveDamage", "halfdam");
      }
    }

    return this.actionInfo.save;
  }

  getReach() {
    const reachSearch = /reach\s*(\s*\d+\s*)\s*ft/;
    const match = this.strippedHtml.match(reachSearch);
    if (match) {
      return match[1];
    }
    return "";
  }

  getRange() {
    let range = {
      value: null,
      long: null,
      units: "",
    };

    const rangeSearch1 = /range\s*(\d+)\s*\/\s*(\d+)\s*ft/;
    const rangeSearch2 = /range\s*(\d+)\s*ft[.]*\s*\/\s*(\d+)\s*ft/;
    const rangeSearch3 = /range\s*(\d+)\s*(:?ft|feet)/;
    const reachSearch = /reach\s*(\d+)\s*(:?ft|feet)/;
    const withinSearch = /within\s*(\d+)\s*(:?ft|feet)/;

    const matches1 = this.strippedHtml.match(rangeSearch1);
    const matches2 = this.strippedHtml.match(rangeSearch2);
    const matches3 = this.strippedHtml.match(rangeSearch3);
    const reachMatch = this.strippedHtml.match(reachSearch);
    const withinMatch = this.strippedHtml.match(withinSearch);

    if (matches1) {
      range.value = parseInt(matches1[1]);
      range.long = parseInt(matches1[2]);
      range.units = "ft";
    } else if (matches2) {
      range.value = parseInt(matches2[1]);
      range.long = parseInt(matches2[2]);
      range.units = "ft";
    } else if (matches3) {
      range.value = parseInt(matches3[1]);
      range.units = "ft";
    } else if (reachMatch) {
      range.value = parseInt(reachMatch[1]);
      range.units = "ft";
    } else if (withinMatch) {
      range.value = parseInt(withinMatch[1]);
      range.units = "ft";
    }

    return range;
  }

  checkAbility(abilitiesToCheck) {
    let result = {
      success: false,
      ability: null,
      proficient: null
    };

    for (const ability of abilitiesToCheck) {
      if (this.toHit == this.ddbMonster.proficiencyBonus + this.ddbMonster.abilities[ability].mod) {
        result.success = true;
        result.ability = ability;
        result.proficient = true;
        break;
      } else if (result.toHit == this.ddbMonster.abilities[ability].mod) {
        result.success = true;
        result.ability = ability;
        result.proficient = false;
        break;
      }
    }

    return result;
  }

  checkAbilities(abilitiesToCheck, negatives = false) {
    const results = abilitiesToCheck.map((ability) => {
      let result = {
        success: false,
        ability,
        proficient: null,
        bonus: 0
      };
      if (this.toHit > this.ddbMonster.proficiencyBonus + this.ddbMonster.abilities[ability].mod) {
        result.success = true;
        result.proficient = true;
        result.bonus = this.toHit - this.ddbMonster.proficiencyBonus - this.ddbMonster.abilities[ability].mod;
      } else if (result.toHit > this.ddbMonster.abilities[ability].mod) {
        result.success = true;
        result.proficient = false;
        result.bonus = this.toHit - this.ddbMonster.abilities[ability].mod;
      } else if (negatives) {
        result.success = true;
        result.proficient = false;
        result.bonus = this.toHit - this.ddbMonster.abilities[ability].mod;
      }
      return result;
    });

    return results;
  }

  // eslint-disable-next-line complexity
  generateWeaponAttackInfo() {
    const abilities = ["str", "dex", "int", "wis", "cha", "con"];
    let initialAbilities = [];
    let weaponAbilities = ["str", "dex"];
    let spellAbilities = ["cha", "wis", "int"];

    const lookup = _dictionary_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].monsters.weapons.find */ .Z.monsters.weapons.find((weapon) => this.name.startsWith(weapon.name));
    // we have a weapon name match so we can infer a bit more
    if (lookup) {
      for (const [key, value] of Object.entries(lookup.properties)) {
        // logger.info(`${key}: ${value}`);
        this.actionInfo.properties[key] = value;
      }
      const versatileWeapon = this.actionInfo.properties.ver && this.ddbMonster.abilities['dex'].mod > this.ddbMonster.abilities['str'].mod;
      if (versatileWeapon || lookup.actionType == "rwak") {
        weaponAbilities = ["dex"];
      } else if (lookup.actionType == "mwak") {
        weaponAbilities = ["str"];
      }
      this.actionInfo.weaponType = lookup.weaponType;
    } else if (this.meleeAttack) {
      this.actionInfo.weaponType = "simpleM";
    } else if (this.rangedAttack) {
      this.actionInfo.weaponType = "simpleR";
    }

    if (this.strippedHtml.includes("is a magic weapon attack")) {
      this.actionInfo.properties["mgc"] = true;
      foundry.utils.setProperty(this.feature, "flags.midiProperties.magicdam", true);
    }

    if (this.spellAttack) {
      initialAbilities = spellAbilities;
    } else if (this.weaponAttack) {
      initialAbilities = weaponAbilities;
    } else {
      initialAbilities = abilities;
    }

    // force companions to null and proficient
    if (this.yourSpellAttackModToHit) {
      this.actionInfo.baseAbility = null;
      this.actionInfo.proficient = true;
    } else if (this.weaponAttack || this.spellAttack) {
      // check most likely initial attacks - str and dex based weapon, mental for spell
      const checkInitialAbilities = this.checkAbility(initialAbilities);
      if (checkInitialAbilities.success) {
        this.actionInfo.baseAbility = checkInitialAbilities.ability;
        this.actionInfo.proficient = checkInitialAbilities.proficient;
      }

      // okay lets see if its one of the others then!
      if (!this.actionInfo.baseAbility) {
        const checkAllAbilities = this.checkAbility(abilities);
        if (checkAllAbilities.success) {
          this.actionInfo.baseAbility = checkAllAbilities.ability;
          this.actionInfo.proficient = checkAllAbilities.proficient;
        }
      }

      // okay, some oddity, maybe magic bonus, lets calculate one!
      // we are going to assume it's dex or str based.
      if (!this.actionInfo.baseAbility) {
        const magicAbilities = this.checkAbilities(initialAbilities);

        const filteredAbilities = magicAbilities.filter((ab) => ab.success == true).sort((a, b) => {
          if (a.proficient == !b.proficient) return -1;
          if (b.proficient == !a.proficient) return 1;
          if (a.proficient == b.proficient) {
            if (a.bonus > b.bonus) return 1;
            if (b.bonus > a.bonus) return -1;
          }
          return 0;
        });

        // fine lets use the first hit
        if (filteredAbilities.length >= 1 && filteredAbilities[0].success) {
          this.actionInfo.baseAbility = filteredAbilities[0].ability;
          this.actionInfo.proficient = filteredAbilities[0].proficient;
          this.actionInfo.extraAttackBonus = filteredAbilities[0].bonus;
        }
      }

      // negative mods!
      if (!this.actionInfo.baseAbility) {
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].info */ .Z.info(`Negative ability parse for ${this.ddbMonster.npc.name}, to hit ${this.toHit} with ${this.name}`);

        const magicAbilities = this.checkAbilities(initialAbilities, true);

        const filteredAbilities = magicAbilities.filter((ab) => ab.success == true).sort((a, b) => {
          if (a.proficient == !b.proficient) return -1;
          if (b.proficient == !a.proficient) return 1;
          if (a.proficient == b.proficient) {
            if (a.bonus < b.bonus) return 1;
            if (b.bonus < a.bonus) return -1;
          }
          return 0;
        });
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug("Filtered abilities", { filteredAbilities, html: this.strippedHtml });
        // fine lets use the first hit
        if (filteredAbilities.length >= 1 && filteredAbilities[0].success) {
          this.actionInfo.baseAbility = filteredAbilities[0].ability;
          this.actionInfo.proficient = filteredAbilities[0].proficient;
          this.actionInfo.extraAttackBonus = filteredAbilities[0].bonus;
        } else {
          _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error("Unable to calculate attack!", { filteredAbilities, html: this.strippedHtml, ddbFeature: this });
        }
      }
    }
  }

  getTarget() {
    let target = {
      value: null,
      width: null,
      units: "",
      type: ""
    };

    // 90-foot line that is 10 feet wide
    // in a 90-foot cone
    const matchText = this.strippedHtml.replace(/[-]/gu, "-").replace(/-+/g, "-");
    // console.warn(matchText);
    const lineSearch = /(\d+)-foot line|line that is (\d+) feet/;
    const coneSearch = /(\d+)-foot cone/;
    const cubeSearch = /(\d+)-foot cube/;
    const sphereSearch = /(\d+)-foot-radius sphere/;

    const coneMatch = matchText.match(coneSearch);
    const lineMatch = matchText.match(lineSearch);
    const cubeMatch = matchText.match(cubeSearch);
    const sphereMatch = matchText.match(sphereSearch);

    if (coneMatch) {
      target.value = parseInt(coneMatch[1]);
      target.units = "ft";
      target.type = "cone";
    } else if (lineMatch) {
      target.value = parseInt(lineMatch[1] ?? lineMatch[2]);
      target.units = "ft";
      target.type = "line";
    } else if (cubeMatch) {
      target.value = parseInt(cubeMatch[1]);
      target.units = "ft";
      target.type = "cube";
    } else if (sphereMatch) {
      target.value = parseInt(sphereMatch[1]);
      target.units = "ft";
      target.type = "sphere";
    }

    if (target.type === "" && this.healingAction) {
      target.type = "self";
    }

    return target;
  }

  #getHiddenDescription() {
    const nameChoice = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-hide-description-choice");
    const hideItemName = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "munching-policy-hide-item-name");
    let actorDescriptor = `[[lookup @name]]`;

    if (nameChoice === "TYPE") {
      actorDescriptor = `[[lookup @details.type.config.label]]`;
    } else if (nameChoice === "MONSTER") {
      actorDescriptor = "Monster";
    } else if (nameChoice === "NPC") {
      actorDescriptor = "NPC";
    }

    let description = `<section class="secret">\n${this.html}`;
    if (["rwak", "mwak"].includes(this.feature.system.actionType)) {
      const featureName = hideItemName ? "" : ` with its [[lookup @item.name]]`;
      description += `\n</section>\nThe ${actorDescriptor} attacks${featureName}.`;
    } else if (["rsak", "msak"].includes(this.feature.system.actionType)) {
      const featureName = hideItemName ? "a spell" : "[[lookup @item.name]]";
      description += `\n</section>\nThe ${actorDescriptor} casts ${featureName}.`;
    } else if (["save"].includes(this.feature.system.actionType)) {
      const featureName = hideItemName ? "a feature" : "[[lookup @item.name]]";
      description += `\n</section>\nThe ${actorDescriptor} uses ${featureName} and a save is required.`;
    } else {
      description += `\n</section>\nThe ${actorDescriptor} uses ${hideItemName ? "a feature" : "[[lookup @item.name]]"}.`;
    }
    return description;
  }

  async #generateDescription() {
    let description = this.hideDescription ? this.#getHiddenDescription() : `${this.html}`;
    description = description.replaceAll("<em><strong></strong></em>", "");
    description = (0,_lib_DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_5__/* .parseDamageRolls */ .IP)({ text: description, document: this.feature, actor: this.ddbMonster.npc });
    // description = parseToHitRoll({ text: description, document: this.feature });
    description = (0,_lib_DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_5__/* .parseTags */ .RN)(description);
    this.feature.system.description.value = await (0,_lib_DDBTable_js__WEBPACK_IMPORTED_MODULE_3__/* .generateTable */ .p)(this.ddbMonster.npc.name, description, this.updateExisting);
    this.feature.system.description.value = `<div class="ddb">
${this.feature.system.description.value}
</div>`;
  }

  #buildAction() {
    if (Number.isInteger(this.actionInfo.activation)) {
      this.feature.system.activation.cost = this.actionInfo.activation;
      this.feature.system.consume.amount = this.actionInfo.activation;
    } else {
      this.feature.system.activation.cost = 1;
    }
    this.feature.system.activation.type = this.getAction();

    this.feature.system.recharge = this.actionInfo.recharge;
    this.feature.system.save = this.actionInfo.save;
    // assumption - if we have parsed a save dc set action type to save
    if (this.feature.system.save.dc && !this.isAttack) {
      this.feature.system.actionType = "save";
    }

    this.feature.system.damage = this.actionInfo.damage;
    this.feature.system.formula = this.actionInfo.formula;
    for (const [key, value] of Object.entries(this.actionInfo.properties)) {
      if (value) this.feature.system.properties.push(key);
    }
    this.feature.system.proficient = this.actionInfo.proficient;
    this.feature.system.ability = this.actionInfo.baseAbility;
    this.feature.system.attack.bonus = `${this.actionInfo.extraAttackBonus}`;

    if (this.weaponAttack) {
      if (this.templateType !== "feat") {
        this.feature.system.type.value = this.actionInfo.weaponType;
        this.feature.system.equipped = true;
      }
      // console.log(actionInfo.weaponAttack);
      // console.log(actionInfo.meleeAttack);
      // console.log(actionInfo.rangedAttack);
      if (this.meleeAttack) {
        this.feature.system.actionType = "mwak";
      } else if (this.rangedAttack) {
        this.feature.system.actionType = "rwak";
      }
    } else if (this.spellAttack) {
      if (this.meleeAttack) {
        this.feature.system.actionType = "msak";
      } else if (this.rangedAttack) {
        this.feature.system.actionType = "rsak";
      } else {
        this.feature.system.actionType = "save";
      }
      if (this.templateType === "feat") {
        this.feature.system.equipped = true;
      }
      foundry.utils.setProperty(this.feature, "flags.midiProperties.magicdam", true);
      foundry.utils.setProperty(this.feature, "flags.midiProperties.magiceffect", true);
      this.feature.system.properties.mgc = true;
    } else if (this.actionInfo.save.dc) {
      this.feature.system.actionType = "save";
    }

    this.feature.system.range = this.actionInfo.range;
    this.feature.system.target = this.actionInfo.target;
    this.feature.system.duration = this.actionInfo.duration;
    this.feature.system.uses = this.actionInfo.uses;

    if (this.name.includes("/Day")) {
      this.feature.system.uses = this.getUses(true);
    }

    return this.feature;
  }

  #buildLair() {
    if (this.feature.name.trim() === "Lair Actions") {
      this.feature.system.activation.cost = 1;
    }
    return this.feature;
  }

  #buildLegendary() {
    // for the legendary actions feature itself we don't want to do most processing
    if (this.name === "Legendary Actions") {
      this.feature.system.activation.type = "";
      return;
    }

    this.feature.system.activation.type = "legendary";

    this.feature.system.consume = {
      type: "attribute",
      target: "resources.legact.value",
      amount: 1
    };

    if (Number.isInteger(this.actionInfo.activation)) {
      this.feature.system.activation.cost = this.actionInfo.activation;
      this.feature.system.consume.amount = this.actionInfo.activation;
    } else {
      this.feature.system.activation.cost = 1;
    }

    // only attempt to update these if we don't parse an action
    // most legendary actions are just do x thing, where thing is an existing action
    // these have been copied from the existing actions so we don't change
    if (!this.feature.flags.monsterMunch.actionCopy) {
      this.feature.system.recharge = this.actionInfo.recharge;
      this.feature.system.save = this.actionInfo.save;
      // assumption - if we have parsed a save dc set action type to save
      if (this.feature.system.save.dc) {
        this.feature.system.actionType = "save";
      // action.type = "weapon";
      }
      this.feature.system.range = this.actionInfo.range;
      this.feature.system.target = this.actionInfo.target;
      this.feature.system.damage = this.actionInfo.damage;

      if (!this.feature.system.actionType && !this.isAttack && this.feature.system.damage.parts.length > 0) {
        this.feature.system.actionType = "other";
      }
    }

  }

  #buildSpecial() {
    this.feature.system.activation.type = this.getAction();
    if (Number.isInteger(this.actionInfo.activation)) {
      this.feature.system.activation.cost = this.actionInfo.activation;
      this.feature.system.consume.amount = this.actionInfo.activation;
    } else if (this.feature.system.activation.type !== "") {
      this.feature.system.activation.cost = 1;
    }

    this.feature.system.uses = this.actionInfo.uses;
    this.feature.system.recharge = this.actionInfo.recharge;
    this.feature.system.save = this.actionInfo.save;
    this.feature.system.target = this.actionInfo.target;
    // assumption - if we have parsed a save dc set action type to save
    if (this.feature.system.save.dc) {
      this.feature.system.actionType = "save";
    }
    this.feature.system.damage = this.actionInfo.damage;
    // assumption - if the action type is not set but there is damage, the action type is other
    if (!this.feature.system.actionType && this.feature.system.damage.parts.length != 0) {
      this.feature.system.actionType = "other";
    }

    // legendary resistance check
    const resistanceMatch = this.name.match(/Legendary Resistance \((\d+)\/Day/i);
    if (resistanceMatch) {
      this.feature.system.activation.type = "special";
      this.feature.system.activation.cost = null;
      this.feature.system.consume = {
        type: "attribute",
        target: "resources.legres.value",
        amount: 1
      };
    }

    // if this special action has nothing to do, then we remove the activation type
    if (this.feature.system.actionType === null
      && (this.feature.system.uses.value === null || this.feature.system.uses.value === 0)
      && this.feature.system.recharge.value === null
    ) {
      this.feature.system.activation = {
        cost: null,
        type: "",
        condition: "",
      };
    }
  }

  #buildVillain() {
    this.feature.system.activation.type = this.getAction();

    if (this.name !== "Villain Actions") {
      this.feature.system.uses = {
        value: 1,
        max: "1",
        per: "sr",
        recovery: "",
      };
    }

    this.feature.system.save = this.actionInfo.save;
    this.feature.system.target = this.actionInfo.target;
    // assumption - if we have parsed a save dc set action type to save
    if (this.feature.system.save.dc) {
      this.feature.system.actionType = "save";
    }
    this.feature.system.damage = this.actionInfo.damage;
    // assumption - if the action type is not set but there is damage, the action type is other
    if (!this.feature.system.actionType && this.feature.system.damage.parts.length != 0) {
      this.feature.system.actionType = "other";
    }

  }

  #generateActionInfo() {
    if (this.weaponAttack || this.spellAttack) {
      this.generateWeaponAttackInfo();
    }
    this.generateExtendedDamageInfo();

    this.actionInfo.reach = this.getReach();
    this.actionInfo.range = this.getRange();
    // On hindsight, reach is a weapon property, and probably shouldn't be present on most features
    // it gets copied over to weapons elsewhere.
    // if (this.actionInfo.reach != "" && Number.parseInt(this.actionInfo.reach) > 5) {
    //   this.actionInfo.properties.rch = true;
    // }
    this.actionInfo.recharge = this.getRecharge();
    this.actionInfo.activation = this.getActivation();
    this.actionInfo.save = this.getFeatSave();
    this.actionInfo.target = this.getTarget();
    this.actionInfo.uses = this.getUses();
  }

  #linkResourcesConsumption() {
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Resource linking for ${this.name}`);

    if (foundry.utils.getProperty(this.feature, "system.recharge.value")) {
      foundry.utils.setProperty(this.feature, "system.consume.type", "charges");
      foundry.utils.setProperty(this.feature, "system.consume.target", this.feature._id);
      foundry.utils.setProperty(this.feature, "system.consume.amount", null);
    }
  }

  async parse() {
    this.#generateActionInfo();
    switch (this.type) {
      case "action":
      case "mythic":
      case "reaction":
      case "bonus":
        this.#buildAction();
        break;
      case "lair":
        this.#buildLair();
        break;
      case "legendary":
        this.#buildLegendary();
        break;
      case "villain":
        this.#buildVillain();
        break;
      case "special":
        this.#buildSpecial();
        break;
      default:
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unknown action parsing type ${this.type}`, { DDBFeature: this });
        throw new Error(`Unknown action parsing type ${this.type}`);
    }

    foundry.utils.setProperty(this.feature, "flags.monsterMunch.actionInfo.damage", this.actionInfo.damage);
    foundry.utils.setProperty(this.feature, "flags.monsterMunch.actionInfo.baseAbility", this.actionInfo.baseAbility);
    foundry.utils.setProperty(this.feature, "flags.monsterMunch.actionInfo.toHit", this.toHit);
    foundry.utils.setProperty(this.feature, "flags.monsterMunch.actionInfo.baseAbility", this.actionInfo.baseAbility);
    foundry.utils.setProperty(this.feature, "flags.monsterMunch.actionInfo.proficient", this.actionInfo.proficient);
    foundry.utils.setProperty(this.feature, "flags.monsterMunch.actionInfo.extraAttackBonus", this.actionInfo.extraAttackBonus);

    await this.#generateDescription();
    this.#linkResourcesConsumption();

    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Parsed Feature ${this.name} for ${this.ddbMonster.name}`, { feature: this });

  }

}


/***/ }),

/***/ 2676:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBMonsterFeatureFactory)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _DDBMonsterFeature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(512);




class DDBMonsterFeatureFactory {

  // some monsters now have [rollable] tags - if these exist we need to parse them out
  // in the future we may be able to use them, but not consistent yet
  static replaceRollable(text) {
    const rollableRegex = new RegExp(/(\[rollable\])([^;]*);(.*)(\[\/rollable\])/g);
    return text.replaceAll(rollableRegex, "$2");
  }

  constructor({ ddbMonster, hideDescription, updateExisting } = {}) {
    this.ddbMonster = ddbMonster;

    this.hideDescription = hideDescription;
    this.updateExisting = updateExisting;

    this.featureBlocks = {
      action: [],
      reaction: [],
      bonus: [],
      mythic: [],
      lair: [],
      legendary: [],
      special: [],
      villain: [],
    };

    this.features = {
      action: [],
      reaction: [],
      bonus: [],
      mythic: [],
      lair: [],
      legendary: [],
      special: [],
      villain: [],
    };

    this.characterDescription = {
      action: "",
      reaction: "",
      bonus: "",
      mythic: "",
      lair: "",
      legendary: "",
      special: "",
      villain: "",
      unexpected: null,
    };

    this.html = {
      action: "",
      reaction: "",
      bonus: "",
      mythic: "",
      lair: "",
      legendary: "",
      special: "",
      villain: "",
    };

    this.resources = {
      legendary: {
        value: 3,
        max: 3
      },
      lair: {
        value: false,
        initiative: null
      },
      resistance: {
        value: 0,
        max: 0
      },
    };

    this.resistance = {};
  }

  getFeatures(type) {
    return this.features[type].map((feature) => foundry.utils.deepClone(feature.feature));
  }

  get actions() {
    return this.getFeatures("action");
  }

  get reactions() {
    return this.getFeatures("reaction");
  }

  get bonus() {
    return this.getFeatures("bonus");
  }

  get mythic() {
    return this.getFeatures("mythic");
  }

  get lair() {
    return this.getFeatures("lair");
  }

  get legendary() {
    return this.getFeatures("legendary");
  }

  get special() {
    return this.getFeatures("special");
  }

  get villain() {
    return this.getFeatures("villain");
  }

  #buildDom(type) {
    const dom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(this.html[type]);
    dom.childNodes.forEach((node) => {
      if (node.textContent == "\n" || node.textContent == "\r\n") {
        dom.removeChild(node);
      }
    });
    return dom;
  }

  static EM_STRONG_EXCEPTIONS = [
    "Yeenoghu",
  ];

  #generateActionActions(type) {
    let splitActions1 = this.html[type].split("<h3>Roleplaying Information</h3>");
    if (splitActions1.length > 1) {
      this.characterDescription[type] = `<h3>Roleplaying Information</h3>${splitActions1[1]}`;
    }
    const splitActions2 = splitActions1[0].split("<h3>Villain Actions</h3>");
    if (splitActions2.length > 1) {
      this.html.villain = splitActions2[1];
    }

    this.html[type] = splitActions2[0];

    let dom = this.#buildDom(type);

    // build out skeleton actions
    dom.querySelectorAll("p").forEach((node) => {
      const pDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(node.outerHTML);
      const query = pDom.querySelector("em strong") ?? pDom.querySelector("strong em");
      if (!query) return;
      let name = query.textContent.trim().replace(/\./g, '');
      name = DDBMonsterFeatureFactory.splitName(name, node.textContent);
      const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
      this.featureBlocks[type].push(action);
    });

    // there is inconsistent formatting
    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("p").forEach((node) => {
        const pDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(node.outerHTML);
        const query = pDom.querySelector("strong");
        if (!query) return;
        let name = query.textContent.trim().replace(/\./g, '');
        name = DDBMonsterFeatureFactory.splitName(name, node.textContent);
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
        this.featureBlocks[type].push(action);
      });
    }

    // there is inconsistent formatting
    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("p").forEach((node) => {
        const pDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(node.outerHTML);
        const query = pDom.querySelector("b");
        if (!query) return;
        let name = query.textContent.trim().replace(/\./g, '');
        name = DDBMonsterFeatureFactory.splitName(name, node.textContent);
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
        this.featureBlocks[type].push(action);
      });
    }


    // there is inconsistent formatting
    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("p").forEach((node) => {
        const pDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(node.outerHTML);
        const title = pDom.textContent.split('.')[0];
        const name = title.trim();
        if (name && name.length > 0) {
          const titleHTML = pDom.outerHTML ? pDom.outerHTML.split('.')[0] : undefined;
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    // homebrew fun
    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("div").forEach((node) => {
        const pDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(node.outerHTML);
        const title = pDom.textContent.split('.')[0];
        const name = title.trim();
        if (name && name.length > 0) {
          const titleHTML = pDom.outerHTML ? pDom.outerHTML.split('.')[0] : undefined;
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    let action = this.featureBlocks[type][0];

    dom.childNodes.forEach((node) => {
      const nodeContextSplit = node.textContent.split('.');
      const nodeName = nodeContextSplit[0].trim();
      const longNodeName = (nodeContextSplit.length > 2 && nodeContextSplit[1].trim().startsWith('('))
        ? `${nodeName} ${nodeContextSplit[1].trim()}`
        : nodeName;
      let switchAction = this.featureBlocks[type].find((act) => nodeName === act.name || longNodeName === act.name);

      if (!switchAction) {
        switchAction = this.featureBlocks[type].find((act) =>
          act.options?.fullName
          && node.textContent.startsWith(act.options.fullName)
        );
      }
      let startFlag = false;
      if (switchAction) {
        action = switchAction;
        if (action.options.html === "") {
          startFlag = true;
        }
      }

      if (!action) return;

      if (node.outerHTML) {
        let outerHTML = `${node.outerHTML}`;
        if (switchAction && startFlag) {
          const replaceName = foundry.utils.getProperty(action, "fullName") ?? nodeName;
          outerHTML = outerHTML.replace(replaceName, "");
          const titleDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(outerHTML);
          if (titleDom.textContent.startsWith(".")) outerHTML = outerHTML.replace(".", "");
        }
        action.options.html += outerHTML;
      }
    });
  }

  #generateLairActions(type = "lair") {
    let dom = this.#buildDom(type);

    const defaultAction = { name: "Lair Actions", options: { html: "", ddbMonster: this.ddbMonster, type } };
    this.featureBlocks[type].push(defaultAction);

    dom.querySelectorAll("h4").forEach((node) => {
      const name = node.textContent.trim();
      if (name !== "") {
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type } };
        if (node.textContent == "Lair Actions" || node.textContent == "") {
          return;
        }
        this.featureBlocks[type].push(action);
      }
    });

    dom.querySelectorAll("h3").forEach((node) => {
      const name = node.textContent.trim();
      if (name !== "") {
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type } };
        if (node.textContent == "Lair Actions" || action.name == "") {
          return;
        }
        this.featureBlocks[type].push(action);
      }
    });

    let actionType = "Lair Actions";
    let action = this.featureBlocks[type].find((act) => act.name == actionType);

    if (!action) {
      action = this.featureBlocks[type][0];
    }

    dom.childNodes.forEach((node) => {
      // const switchAction = dynamicActions.find((act) => act.name == node.textContent);
      const nodeName = node.textContent.split('.')[0].trim();
      const switchAction = this.featureBlocks[type].find((act) => nodeName === act.name);
      let startFlag = false;
      if (switchAction) {
        actionType = node.textContent;
        action = switchAction;
        if (action.options.html === "") startFlag = true;
      }
      if (node.outerHTML) {
        let outerHTML = node.outerHTML;
        if (switchAction && startFlag) {
          outerHTML = outerHTML.replace(`${nodeName}.`, "");
        }
        action.options.html += outerHTML;
      }

      const initiativeMatch = node.textContent.match(/initiative count (\d+)/);
      if (initiativeMatch) {
        this.resources.lair = {
          value: true,
          initiative: parseInt(initiativeMatch[1]),
        };
      }
    });
  }

  #generateLegendaryActions(type) {
    let dom = this.#buildDom(type);

    // Base feat
    const feat = { name: "Legendary Actions", options: { html: "", ddbMonster: this.ddbMonster, type, actionCopy: false } };
    feat.options.html = `${this.html[type]}`;
    this.featureBlocks[type].push(feat);


    // build out skeleton actions
    dom.querySelectorAll("strong").forEach((node) => {
      const name = node.textContent.trim().replace(/\.$/, '').trim();
      const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, actionCopy: false } };

      const actionMatch = this.features["action"].concat(
        this.features.reaction,
        this.features.reaction,
        this.features.bonus,
      ).find((mstAction) =>
        name == mstAction.name
        || name == `${mstAction.name} Attack`
        || name == `${mstAction.name}`.split('(', 1)[0].trim()
        || name == `${mstAction.name} Attack`.split('(', 1)[0].trim()
      );

      if (actionMatch) {
        const dupFeature = new _DDBMonsterFeature_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(name, { ddbMonster: this.ddbMonster, html: actionMatch.html, type, actionCopy: true });
        dupFeature.feature = foundry.utils.duplicate(actionMatch.feature);
        dupFeature.feature._id = foundry.utils.randomID();
        dupFeature.feature.name = action.name; // fix up name to make sure things like Attack are included
        this.features[type].push(dupFeature);
        action.options.actionCopy = true;
      }
      this.featureBlocks[type].push(action);

    });

    let action = this.featureBlocks[type].find((act) => act.name == "Legendary Actions");

    dom.childNodes
      .forEach((node) => {
      // check for action numbers
      // can take 3 legendary actions
        let startFlag = false;
        const actionMatch = node.textContent.match(/can take (d+) legendary actions/);
        if (actionMatch) {
          this.resource.legendary.value = parseInt(actionMatch[1]);
          this.resource.legendary.max = parseInt(actionMatch[1]);
        }

        const nodeName = node.textContent.split('.')[0].trim();
        const switchAction = this.featureBlocks[type].find((act) => nodeName === act.name);
        if (action.name !== "Legendary Actions" || switchAction) {

          if (switchAction) {
            action = switchAction;
            if (action.options.html === "") {
              startFlag = true;
            }
          }

          if (action.options.actionCopy) return;
          if (node.outerHTML) {
            let outerHTML = node.outerHTML;
            if (switchAction && startFlag) {
              outerHTML = outerHTML.replace(`${nodeName}.`, "");
            }
            action.options.html += outerHTML;
          }
        }
      });
  }

  #generateVillainActions(type = "villain") {
    let dom = this.#buildDom(type);

    // Base feat
    const feat = { name: "Villain Actions", options: { html: "", ddbMonster: this.ddbMonster, type, actionCopy: false } };
    feat.options.html = `${this.html[type]}`;
    this.featureBlocks[type].push(feat);

    // build out skeleton actions
    dom.querySelectorAll("strong").forEach((node) => {
      const name = node.textContent.trim().replace(/\.$/, '').trim();
      const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, actionCopy: false } };

      this.featureBlocks[type].push(action);
    });

    let action = this.featureBlocks[type].find((act) => act.name == "Villain Actions");

    dom.childNodes
      .forEach((node) => {
        let startFlag = false;

        const nameRegex = /^Action (.)+?[.!?]/;
        const actionMatch = node.textContent.match(nameRegex);
        const nodeName = actionMatch ? actionMatch[0].split('.')[0].trim() : node.textContent.split('.')[0].trim();
        const switchAction = this.featureBlocks[type].find((act) => nodeName === act.name);

        if (action.name !== "Villain Actions" || switchAction) {

          if (switchAction) {
            action = switchAction;
            if (action.options.html === "") {
              startFlag = true;
            }
          }

          if (node.outerHTML) {
            let outerHTML = node.outerHTML;
            if (switchAction && startFlag) {
              outerHTML = outerHTML.replace(`${nodeName}.`, "").replace(`${nodeName}`, "");
            }
            action.options.html += outerHTML;
          }
        }
      });
  }

  static splitName(name, nodeText) {
    if (!name.includes("Spell;") && !name.includes("Psionics;") && !name.includes("Mythic Trait;")) {
      const split = name.split(";");
      if (split.length > 1 && split[0].includes("(") && !split[0].includes(")")) {
        return name.trim();
      } else if (split.length > 1) {
        return split.pop().trim();
      } else {
        return name.trim();
      }
    } else if (name.includes("Spell;")) {
      return nodeText.trim().split(".")[0];
    } else {
      return name.trim();
    }
  }

  #generateSpecialActions(type) {
    let splitActions = this.html[type].split("<h3>Roleplaying Information</h3>");
    if (splitActions.length > 1) {
      this.characterDescription[type] = `<h3>Roleplaying Information</h3>${splitActions[1]}`;
    }

    this.html[type] = splitActions[0];
    let dom = this.#buildDom(type);

    // build out skeleton actions
    dom.querySelectorAll("p").forEach((node) => {
      const pDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(node.outerHTML);
      const query = pDom.querySelector("em");
      if (!query) return;
      let name = query.textContent.trim().replace(/\./g, '');
      name = DDBMonsterFeatureFactory.splitName(name, node.textContent);
      if (name) {
        const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
        this.featureBlocks[type].push(action);
      }
    });

    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("p").forEach((node) => {
        const pDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(node.outerHTML);
        const query = pDom.querySelector("strong");
        if (!query) return;
        let name = query.textContent.trim().replace(/\./g, '');
        name = DDBMonsterFeatureFactory.splitName(name, node.textContent);
        if (name) {
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: query.outerHTML, fullName: query.textContent } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("em").forEach((node) => {
        const name = node.textContent.trim().replace(/\.$/, '').trim();
        if (name) {
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: node.outerHTML, fullName: node.textContent } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    if (this.featureBlocks[type].length == 0) {
      dom.querySelectorAll("strong").forEach((node) => {
        const name = node.textContent.trim().replace(/\.$/, '').trim();
        if (name) {
          const action = { name, options: { html: "", ddbMonster: this.ddbMonster, type, titleHTML: node.outerHTML, fullName: node.textContent } };
          this.featureBlocks[type].push(action);
        }
      });
    }

    if (this.featureBlocks[type].length == 0) {
      const action = { name: "Special Traits", options: { html: "", ddbMonster: this.ddbMonster, type } };
      this.featureBlocks[type].push(action);
    }

    if (this.featureBlocks[type].length === 0) return;

    let action = this.featureBlocks[type][0];

    dom.childNodes.forEach((node) => {
      const nodeName = node.textContent.split('.')[0].trim();
      let switchAction = this.featureBlocks[type].find((act) => nodeName === act.name);
      if (action.name.includes("; Recharges after a Short or Long Rest")) action.name = action.name.replace("; Recharges after a Short or Long Rest", "");
      if (action.name.includes("; Recharges after a Long Rest")) action.name = action.name.replace("; Recharges after a Long Rest", "");
      if (!switchAction) {
        switchAction = this.featureBlocks[type].find((act) => node.textContent.startsWith(act.options.fullName));
      }
      let startFlag = false;
      if (switchAction) {
        action = switchAction;
        if (action.options.html === "") {
          startFlag = true;
        }
      }

      if (node.outerHTML) {
        let outerHTML = node.outerHTML;
        if (switchAction && startFlag) {
          if (action.options.fullName) {
            outerHTML = outerHTML.replace(action.fullName, "");
          } else {
            outerHTML = outerHTML.replace(nodeName, "");
          }
        }
        const titleDom = _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].htmlToDocumentFragment */ .Z.htmlToDocumentFragment(outerHTML);
        if (titleDom.textContent.startsWith(". ")) outerHTML = outerHTML.replace(". ", "");
        action.options.html += outerHTML;
      }

      const resistanceMatch = node.textContent.match(/Legendary Resistance \((\d+)\/Day/i);
      if (resistanceMatch) {
        this.resources.resistance.value = parseInt(resistanceMatch[1]);
        this.resources.resistance.max = parseInt(resistanceMatch[1]);
      }
    });
  }

  // possible regular types:
  // action, reaction, bonus, mythic
  // this.ddbMonster.source.actionsDescription
  // this.ddbMonster.source.reactionsDescription
  // this.ddbMonster.source.bonusActionsDescription
  // this.ddbMonster.source.mythicActionsDescription

  async generateActions(html, type = "action") {
    if (!html || html.trim() == "") return;

    this.html[type] = DDBMonsterFeatureFactory.replaceRollable(_lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].replaceHtmlSpaces */ .Z.replaceHtmlSpaces(`${html}`))
      .replace(/<\/strong> <strong>/g, "")
      .replace(/<\/strong><strong>/g, "")
      .replace(/<strong>\.<\/strong>/g, ".")
      .replace(/<em>\.<\/em>/g, ".")
      .replace(/&shy;/g, "");

    switch (type) {
      case "action":
      case "bonus":
      case "mythic":
      case "reaction":
        this.#generateActionActions(type);
        break;
      case "lair":
        this.#generateLairActions(type);
        break;
      case "legendary":
        this.#generateLegendaryActions(type);
        break;
      case "special":
        this.#generateSpecialActions(type);
        break;
      case "villain":
        this.#generateVillainActions(type);
        break;
      default:
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].error */ .Z.error(`Unknown action parsing type ${this.type}`, { DDBFeatureFactory: this });
        throw new Error(`Unknown action parsing type ${this.type}`);
    }

    // some features are duplicated and we parse these first
    for (const feature of this.features[type]) {
      await feature.parse();
    }

    // parse remaining feature blocks
    for (const feature of this.featureBlocks[type].filter((feature) => !feature.options.actionCopy)) {
      feature.options["hideDescription"] = this.hideDescription;
      feature.options["updateExisting"] = this.updateExisting;
      const ddbFeature = new _DDBMonsterFeature_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(feature.name, feature.options);
      await ddbFeature.parse();
      this.features[type].push(ddbFeature);
    }
  }

}



/***/ }),

/***/ 5371:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": () => (/* binding */ getAbilityMods)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);


function getAbilityMods(monster) {
  let abilities = {};

  _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.forEach */ .Z.character.abilities.forEach((ability) => {
    const value = monster.stats.find((stat) => stat.statId === ability.id).value || 0;
    const mod = CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;
    abilities[ability.value] = mod;
  });

  return abilities;

}


/***/ }),

/***/ 1309:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": () => (/* binding */ newNPC)
/* harmony export */ });
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7669);


async function newNPC(name, ddbId = null) {
  const options = {
    temporary: true,
    displaySheet: false,
  };
  const npcClass = await Actor.create({ name, type: "npc" }, options);
  let npc = npcClass.toObject();
  npc._id = ddbId === null
    ? foundry.utils.randomID()
    : _lib_utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].namedIDStub */ .Z.namedIDStub(npc.name, { postfix: ddbId });
  const flags = {
    dnd5e: {},
    monsterMunch: {},
    ddbimporter: {
      compendiumId: npc._id,
      dndbeyond: {},
    },
  };
  foundry.utils.setProperty(npc, "flags", flags);
  // delete npc._id;
  return npc;
};


/***/ }),

/***/ 1434:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ DDBRace)
/* harmony export */ });
/* harmony import */ var _lib_DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7162);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1438);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3893);
/* harmony import */ var _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2397);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6451);
/* harmony import */ var _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7669);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5259);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(37);
/* harmony import */ var _advancements_AdvancementHelper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(333);











class DDBRace {

  static getGroupName(ids, baseRaceName) {
    const ddbGroup = CONFIG.DDB.raceGroups.find((r) => ids.includes(r.id));
    if (ddbGroup) {
      return ddbGroup.name;
    }
    const lowercaseName = baseRaceName.toLowerCase().trim();
    if ((lowercaseName.includes("elf") && !lowercaseName.includes("half")) || ["eladrin"].includes(lowercaseName)) {
      return "Elf";
    }
    if (["githzerai", "githyanki"].includes(lowercaseName)) return "Gith";
    if (lowercaseName.includes("genasi")) return "Genasi";
    if (lowercaseName.includes("gnome")) return "Gnome";
    if (lowercaseName.includes("human")) return "Human";
    if (lowercaseName.includes("yuan-ti")) return "Yuan-ti";
    return baseRaceName;
  }

  _generateDataStub() {
    this.data = {
      _id: foundry.utils.randomID(),
      name: "",
      type: "race",
      system: _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getTemplate */ .Z.getTemplate("race"),
      flags: {
        ddbimporter: {
          type: "race",
        },
        obsidian: {
          source: {
            type: "race"
          },
        },
      },
      img: null,
    };
  }

  #fixups() {
    // fixup
    if (this.race.baseName === "Harengon") {
      this.race.sizeId = 10;
    }
  }

  constructor(ddbData, race, compendiumRacialTraits, noMods = false) {
    this.ddbData = ddbData;
    this.race = race;
    this.#fixups();
    this.compendiumRacialTraits = compendiumRacialTraits;
    this._generateDataStub();
    this.type = "humanoid";
    this._compendiumLabel = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumLabel */ .Z.getCompendiumLabel("traits");

    this.data.name = (this.race.fullName) ? _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].nameString */ .Z.nameString(this.race.fullName) : _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].nameString */ .Z.nameString(this.race.name);
    this.data.system.description.value += `${this.race.description}\n\n`;

    this.fullName = this.race.fullName;
    this.isLegacy = this.race.isLegacy;
    this.baseRaceName = this.race.baseRaceName;
    this.groupName = DDBRace.getGroupName(this.race.groupIds, this.baseRaceName);
    this.isSubRace = this.race.isSubRace || this.groupName !== this.raceName;

    this.data.flags.ddbimporter = {
      type: "race",
      entityRaceId: this.race.entityRaceId,
      version: CONFIG.DDBI.version,
      sourceId: this.race.sources.length > 0 ? [0].sourceId : -1, // is homebrew
      baseName: this.race.baseName,
      baseRaceId: this.race.baseRaceId,
      baseRaceName: this.race.baseRaceName,
      fullName: this.race.fullName,
      fullRaceName: this.race.fullName,
      subRaceShortName: this.race.subRaceShortName,
      isHomebrew: this.race.isHomebrew,
      isLegacy: this.race.isLegacy,
      isSubRace: this.isSubRace,
      moreDetailsUrl: this.race.moreDetailsUrl,
      featIds: this.race.featIds,
      groupIds: this.race.groupIds,
      groupName: this.groupName,
    };

    if (this.race.moreDetailsUrl) {
      this.data.flags.ddbimporter['moreDetailsUrl'] = this.race.moreDetailsUrl;
    }

    this.data.system.source = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].parseSource */ .Z.parseSource(this.race);

    if (this.race.isSubRace && this.race.baseRaceName) this.data.system.requirements = this.race.baseRaceName;
    const legacyName = game.settings.get("ddb-importer", "munching-policy-legacy-postfix");
    if (legacyName && this.race.isLegacy) {
      this.data.name += " (Legacy)";
    }

    this.#addWeightSpeeds();
    this.#addSizeAdvancement();

    this.abilityAdvancement = new game.dnd5e.documents.advancement.AbilityScoreImprovementAdvancement();

    this.noMods = noMods || ddbData === null;

    this.advancementHelper = new _advancements_AdvancementHelper_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z({
      ddbData: this.ddbData,
      type: "race",
      noMods: this.noMods,
    });

    this.featLink = {
      advancementId: null,
      name: null,
      uuid: null,
    };
  }

  async _generateRaceImage() {
    let avatarUrl;
    let largeAvatarUrl;
    let portraitAvatarUrl;

    const targetDirectory = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "other-image-upload-directory").replace(/^\/|\/$/g, "");
    const useDeepPaths = game.settings.get(_settings_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].MODULE_ID */ .Z.MODULE_ID, "use-deep-file-paths");

    if (this.race.portraitAvatarUrl) {
      const imageNamePrefix = useDeepPaths ? "" : "race-portrait";
      const pathPostfix = useDeepPaths ? `/race/portrait` : "";
      const downloadOptions = { type: "race-portrait", name: this.race.fullName, targetDirectory, imageNamePrefix, pathPostfix };
      portraitAvatarUrl = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getImagePath */ .Z.getImagePath(this.race.portraitAvatarUrl, downloadOptions);
      this.data.img = portraitAvatarUrl;
      this.data.flags.ddbimporter['portraitAvatarUrl'] = this.race.portraitAvatarUrl;
    }

    if (this.race.avatarUrl) {
      const imageNamePrefix = useDeepPaths ? "" : "race-avatar";
      const pathPostfix = useDeepPaths ? `/race/avatar` : "";
      const downloadOptions = { type: "race-avatar", name: this.race.fullName, targetDirectory, imageNamePrefix, pathPostfix };
      avatarUrl = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getImagePath */ .Z.getImagePath(this.race.avatarUrl, downloadOptions);
      this.data.flags.ddbimporter['avatarUrl'] = this.race.avatarUrl;
      if (!this.data.img) {
        this.data.img = avatarUrl;
      }
    }

    if (this.race.largeAvatarUrl) {
      const imageNamePrefix = useDeepPaths ? "" : "race-large";
      const pathPostfix = useDeepPaths ? `/race/large` : "";
      const downloadOptions = { type: "race-large", name: this.race.fullName, targetDirectory, imageNamePrefix, pathPostfix };
      largeAvatarUrl = await _lib_FileHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getImagePath */ .Z.getImagePath(this.race.largeAvatarUrl, downloadOptions);
      // eslint-disable-next-line require-atomic-updates
      this.data.flags.ddbimporter['largeAvatarUrl'] = this.race.largeAvatarUrl;
      if (!this.data.img) {
        this.data.img = largeAvatarUrl;
      }
    }

    const image = (avatarUrl) ? `<img src="${avatarUrl}">\n\n` : (largeAvatarUrl) ? `<img src="${largeAvatarUrl}">\n\n` : "";
    this.data.system.description.value += image;
    return image;
  }

  #typeCheck(trait) {
    if (trait.name.trim() !== "Creature Type") return;
    const typeRegex = /You are a (\S*)\./i;
    const typeMatch = trait.description.match(typeRegex);
    if (typeMatch) {
      _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].debug */ .Z.debug(`Explicit type detected: ${typeMatch[1]}`, typeMatch);
      this.type = typeMatch[1].toLowerCase();
    }
  }

  #addFeatureDescription(trait) {
    const featureMatch = this.compendiumRacialTraits.find((match) =>
      foundry.utils.hasProperty(match, "flags.ddbimporter.baseName") && foundry.utils.hasProperty(match, "flags.ddbimporter.entityRaceId")
      && _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].nameString */ .Z.nameString(trait.name) === _lib_utils_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].nameString */ .Z.nameString(match.flags.ddbimporter.baseName)
      && match.flags.ddbimporter.entityRaceId === trait.entityRaceId
    );
    const title = (featureMatch) ? `<p><b>@Compendium[${this._compendiumLabel}.${featureMatch._id}]{${trait.name}}</b></p>` : `<p><b>${trait.name}</b></p>`;
    this.data.system.description.value += `${title}\n${trait.description}\n\n`;
  }

  #addWeightSpeeds() {
    if (this.race.weightSpeeds?.normal) {
      this.data.system.movement = {
        burrow: this.race.weightSpeeds.normal.burrow ?? 0,
        climb: this.race.weightSpeeds.normal.climb ?? 0,
        fly: this.race.weightSpeeds.normal.fly ?? 0,
        swim: this.race.weightSpeeds.normal.swim ?? 0,
        walk: this.race.weightSpeeds.normal.walk ?? 0,
        units: "ft",
        hover: false,
      };
    }
  }

  #addSizeAdvancement() {
    const advancement = new game.dnd5e.documents.advancement.SizeAdvancement();

    const ddbSizeData = CONFIG.DDB.creatureSizes.find((s) => s.id === this.race.sizeId);
    if (ddbSizeData.id === 10) {
      advancement.updateSource({ configuration: { sizes: ["med", "sm"] } });
    } else if (ddbSizeData !== 4) {
      const size = _dictionary_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].character.actorSizes.find */ .Z.character.actorSizes.find((s) => s.id === this.race.sizeId);
      advancement.updateSource({ configuration: { sizes: [size.value] } });
    }

    this.data.system.advancement.push(advancement.toObject());
  }

  #flightCheck(trait) {
    if (trait.name.trim() === "Flight" && foundry.utils.getProperty(this.race, "weightSpeeds.normal.fly") === 0) {
      const typeRegex = /you have a flying speed equal to your walking speed/i;
      const flightMatch = trait.description.match(typeRegex);
      if (flightMatch) {
        _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].debug */ .Z.debug(`Missing flight detected: ${flightMatch[1]}`, flightMatch);
        this.data.system.movement.fly = this.data.system.movement.walk;
      }
    }
  }

  #addAbilityScoreAdvancement(trait) {
    if (!["Ability Score Increase", "Ability Score Increases"].includes(trait.name.trim())) return;
    const pointMatchRegex = /Your ability scores each increase by 1|or increase three different scores by 1/i;
    if (pointMatchRegex.test(trait.description)) {
      this.abilityAdvancement.configuration.points = 3;
      this.abilityAdvancement.updateSource({ configuration: { points: 3 } });
    } else {
      // Your Intelligence score increases by 2, and your Wisdom score increases by 1.
      // Your Wisdom score increases by 2, and your Constitution score increases by 1.
      // Your Strength score increases by 1.
      // Your Constitution score increases by 2.
      // Your Charisma score increases by 2, and          two other ability scores of your choice increase by 1.
      // Your Charisma score increases by 2. In addition, one other ability score of your choice increases by 1.
      // Your Constitution score increases by 2, and      one other ability score of your choice increases by 1.

      const update = this.abilityAdvancement.configuration.toObject();
      const fixedRegex = /Your (\w+) score increases by (\d)/i;
      const fixedMatch = trait.description.match(fixedRegex);
      if (fixedMatch) {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].character.abilities.find */ .Z.character.abilities.find((a) => a.long === fixedMatch[1].toLowerCase());
        if (ability) {
          update.fixed[ability.value] = parseInt(fixedMatch[2]);
        }
      }

      const extraFixedRegex = /and your (\w+) score increases by (\d)/i;
      const extraFixedMatch = trait.description.match(extraFixedRegex);
      if (extraFixedMatch) {
        const ability = _dictionary_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].character.abilities.find */ .Z.character.abilities.find((a) => a.long === extraFixedMatch[1].toLowerCase());
        if (ability) {
          update.fixed[ability.value] = parseInt(extraFixedMatch[2]);
        }
      }
      const wildCardRegex = /(\w+) other ability score of your choice increases by (\d)/i;
      const wildCardMatch = trait.description.match(wildCardRegex);
      if (wildCardMatch) {
        const numb = _dictionary_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].numbers.find */ .Z.numbers.find((n) => n.natural === wildCardMatch[1].toLowerCase());
        const value = parseInt(wildCardMatch[2]);
        if (numb && Number.isInteger(value)) {
          update.points = (update.points ?? 0) + (value * numb.num);
          update.cap = Math.max(value, (update.cap ?? 0));
        }
      }

      this.abilityAdvancement.updateSource({ configuration: update });
    }
  }

  #generateAbilityAdvancement() {
    this.race.racialTraits.forEach((t) => {
      const trait = t.definition;
      if (!["Ability Score Increase", "Ability Score Increases"].includes(trait.name.trim())) return;
      this.#addAbilityScoreAdvancement(trait);
    });
    this.data.system.advancement.push(this.abilityAdvancement.toObject());
  }

  // skills, e.g. variant human
  #generateSkillAdvancement(trait) {
    if (!["Skills"].includes(trait.name.trim())) return;

    const mods = this.advancementHelper.noMods
      ? []
      : _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, "race");
    const skillExplicitMods = mods.filter((mod) =>
      mod.type === "proficiency"
      && _dictionary_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].character.skills.map */ .Z.character.skills.map((s) => s.subType).includes(mod.subType)
    );
    const advancement = this.advancementHelper.getSkillAdvancement(skillExplicitMods, trait, undefined, 0);

    if (advancement) this.data.system.advancement.push(advancement.toObject());
  }

  #generateLanguageAdvancement(trait) {
    if (!["Languages"].includes(trait.name.trim())) return;

    const mods = this.advancementHelper.noMods
      ? []
      : _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, "race");

    const advancement = this.advancementHelper.getLanguageAdvancement(mods, trait, 0);
    if (advancement) this.data.system.advancement.push(advancement.toObject());
  }

  #geneateToolAdvancement(trait) {
    if (!["Tools"].includes(trait.name.trim())) return;

    const mods = this.advancementHelper.noMods
      ? []
      : _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].getModifiers */ .Z.getModifiers(this.ddbData, "race");

    const advancement = this.advancementHelper.getToolAdvancement(mods, trait, 0);
    if (advancement) this.data.system.advancement.push(advancement.toObject());
  }

  async #generateFeatAdvancement(trait) {
    if (!["Feats", "Feat"].includes(trait.name.trim())) return;

    const advancement = new game.dnd5e.documents.advancement.ItemChoiceAdvancement();

    const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumType */ .Z.getCompendiumType("feats");
    const index = await compendium.getIndex();

    advancement.updateSource({
      title: "Feat",
      configuration: {
        allowDrops: true,
        pool: index.map((i) => i.uuid),
        choices: {
          "0": 1,
        },
        restriction: {
          type: "feat"
        },
      },
    });

    this.data.system.advancement.push(advancement.toObject());

    const feat = this.ddbData?.character?.feats?.find((f) =>
      f.componentId === trait.id
      && f.componentTypeId === trait.entityTypeId
    );
    if (!feat) {
      _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].warn */ .Z.warn(`Unable to link advancement to feat`, { advancement, trait, this: this });
      return;
    };
    const featMatch = index.find((i) => i.name === feat.definition.name);
    if (!featMatch) {
      _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].warn */ .Z.warn(`Unable to link advancement to feat ${feat.definition.name}, this is probably because the feats have not been munched to the compendium`, { feat });
      return;
    }

    this.featLink.advancementId = advancement._id;
    this.featLink.name = feat.definition.name;
    this.featLink.uuid = featMatch.uuid;

    // this update is done later, once everything is built
    // we just add the hints to the feat here
    // const update = {
    //   value: {
    //     added: {
    //       "0": {
    //         // "IRs6OOXQk3AvK3GW": "Compendium.world.ddb-test2-ddb-feats.Item.cHie2wNgxBG9m62F"
    //       },
    //     },
    //   },
    // };

    // advancement.updateSource(update);


  }


  linkFeatures(ddbCharacter) {
    _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].debug */ .Z.debug("Linking Advancements to Feats for Race", {
      DDBRace: this,
      ddbCharacter,
    });

    ddbCharacter.data.race.system.advancement.forEach((a, idx, advancements) => {
      if (a.type === "ItemChoice") {
        const addedFeats = {};

        for (const type of ["actions", "features"]) {
          for (const feat of ddbCharacter.data[type]) {
            const isMatch = feat.type === "feat"
              && feat.system.type.value === "feat"
              && feat.flags.ddbimporter.type === "feat"
              && feat.name.startsWith(this.featLink.name);

            // eslint-disable-next-line no-continue
            if (!isMatch) continue;

            _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].debug */ .Z.debug(`Advancement Race ${a._id} found Feature ${feat.name} (${this.featLink.uuid})`);
            addedFeats[feat._id] = this.featLink.uuid;
            foundry.utils.setProperty(feat, "flags.dnd5e.sourceId", this.featLink.uuid);
            foundry.utils.setProperty(feat, "flags.dnd5e.advancementOrigin", `${this.data._id}.${a._id}`);
          }


          if (Object.keys(addedFeats).length > 0) {
            const added = {
              "0": addedFeats,
              // {
              //   "IRs6OOXQk3AvK3GW": "Compendium.world.ddb-test2-ddb-feats.Item.cHie2wNgxBG9m62F"
              // },
            };

            a.value = {
              added,
            };
            advancements[idx] = a;
          }
        }
      }
    });
    _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].debug */ .Z.debug("Processed race advancements", ddbCharacter.data.race.system.advancement);

  }

  #generateHTMLSenses() {
    const textDescription = _advancements_AdvancementHelper_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].stripDescription */ .Z.stripDescription(this.data.system.description.value);

    // You can see in dim light within 60 feet of you as if it were bright light, and in darkness as if it were dim light
    // You can see in dim light within 120 feet of you as if it were bright light and in darkness as if it were dim light.
    const darkVisionRegex = /you can see in dim light within (\d+) feet of you as if it were bright light/im;
    const darkVisionMatch = textDescription.match(darkVisionRegex);

    if (darkVisionMatch) {
      this.data.system.senses.darkvision = parseInt(darkVisionMatch[1]);
    }

  }

  #generateSenses() {
    if (this.noMods) {
      this.#generateHTMLSenses();
      return;
    }
    for (const senseName in this.data.system.senses) {
      const basicOptions = {
        subType: senseName,
      };
      _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].filterModifiers */ .Z.filterModifiers((this.ddbData?.character?.modifiers?.race ?? []), "set-base", basicOptions).forEach((sense) => {
        if (Number.isInteger(sense.value) && sense.value > this.data.system.senses[senseName]) {
          this.data.system.senses[senseName] = parseInt(sense.value);
        }
      });
    }
  }

  async build() {
    try {
      await this._generateRaceImage();
    } catch (e) {
      _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].error */ .Z.error("Error generating race image, probably because you don't have permission to browse the host file system.", { e });
    }


    this.race.racialTraits.forEach((t) => {
      const trait = t.definition;
      this.#addFeatureDescription(trait);
      this.#typeCheck(trait);
      this.#flightCheck(trait);

      this.#generateSkillAdvancement(trait);
      this.#generateLanguageAdvancement(trait);
      this.#geneateToolAdvancement(trait);
      this.#generateFeatAdvancement(trait);
      // FUTURE, spells (at various levels, when supported)
    });

    this.#generateAbilityAdvancement();
    this.#generateSenses();

    // set final type
    foundry.utils.setProperty(this.data, "system.type.value", this.type);

    // finally a tag parse to update the description
    this.data.system.description.value = (0,_lib_DDBReferenceLinker_js__WEBPACK_IMPORTED_MODULE_0__/* .parseTags */ .RN)(this.data.system.description.value);

    _logger_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].debug */ .Z.debug("Race generated", { DDBRace: this });
  }

  static async getRacialTraitsLookup(racialTraits, fail = true) {
    const compendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCompendiumType */ .Z.getCompendiumType("traits", fail);
    if (compendium) {
      const flags = ["name", "flags.ddbimporter.entityRaceId", "flags.ddbimporter.baseName"];
      const index = await compendium.getIndex({ fields: flags });
      const traitIndex = await index.filter((i) => racialTraits.some((orig) => i.name === orig.name));
      return traitIndex;
    } else {
      return [];
    }
  }

}



/***/ }),

/***/ 2352:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eO": () => (/* binding */ hasSpellCastingAbility),
/* harmony export */   "f5": () => (/* binding */ convertSpellCastingAbilityId),
/* harmony export */   "sX": () => (/* binding */ getSpellCastingAbility)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);


// is there a spell casting ability?
function hasSpellCastingAbility(spellCastingAbilityId) {
  return _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId) !== undefined;
}

// convert spellcasting ability id to string used by foundry
function convertSpellCastingAbilityId(spellCastingAbilityId) {
  return _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId).value;
}

// search through classinfo and determine spellcasting ability
function getSpellCastingAbility(classInfo, checkSubclass = true, onlySubclass = false) {
  let spellCastingAbility = undefined;
  if (!onlySubclass && hasSpellCastingAbility(classInfo.definition.spellCastingAbilityId)) {
    spellCastingAbility = convertSpellCastingAbilityId(classInfo.definition.spellCastingAbilityId);
  } else if (
    checkSubclass
    && classInfo.subclassDefinition
    && hasSpellCastingAbility(classInfo.subclassDefinition.spellCastingAbilityId)
  ) {
    // e.g. Arcane Trickster has spellcasting ID granted here
    spellCastingAbility = convertSpellCastingAbilityId(classInfo.subclassDefinition.spellCastingAbilityId);
  } else {
    // special cases: No spellcaster, but can cast spells like totem barbarian, default to wis
    spellCastingAbility = "wis";
  }
  return spellCastingAbility;
}


/***/ }),

/***/ 6721:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "t": () => (/* binding */ getLookups)
/* harmony export */ });
/**
 * Generates some meta data for a character to use to determine what to do
 * with a spell.
 * We use this like a quick lookup table
 * @param {*} character
 */
function getLookups(character) {
  // racialTraits
  let lookups = {
    race: [],
    feat: [],
    class: [],
    classFeature: [],
    item: [],
  };
  character.race.racialTraits.forEach((trait) => {
    lookups.race.push({
      id: trait.definition.id,
      name: trait.definition.name,
    });
  });

  character.classes.forEach((playerClass) => {
    lookups.class.push({
      id: playerClass.definition.id,
      name: playerClass.definition.name,
    });

    if (playerClass.subclassDefinition) {
      lookups.class.push({
        id: playerClass.subclassDefinition.id,
        name: playerClass.subclassDefinition.name,
      });
    }

    if (playerClass.classFeatures) {
      playerClass.classFeatures.forEach((trait) => {
        lookups.classFeature.push({
          id: trait.definition.id,
          name: trait.definition.name,
          classId: trait.definition.classId,
          componentId: trait.definition.componentId,
        });
      });
    }
  });

  character.options.class.forEach((trait) => {
    lookups.classFeature.push({
      id: trait.definition.id,
      name: trait.definition.name,
      componentId: trait.componentId,
    });
  });

  character.feats.forEach((trait) => {
    lookups.feat.push({
      id: trait.definition.id,
      name: trait.definition.name,
      componentId: trait.componentId,
    });
  });

  character.inventory.forEach((trait) => {
    lookups.item.push({
      id: trait.definition.id,
      name: trait.definition.name,
      limitedUse: trait.limitedUse,
      equipped: trait.equipped,
      isAttuned: trait.isAttuned,
      canAttune: trait.definition.canAttune,
      canEquip: trait.definition.canEquip,
    });
  });

  return lookups;
}


/***/ }),

/***/ 1702:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "T": () => (/* binding */ parseSpell)
});

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
;// CONCATENATED MODULE: ./src/parser/spells/components.js
function getComponents (data) {
  const properties = [];

  if (data.definition.components.includes(1)) properties.push("vocal");
  if (data.definition.components.includes(2)) properties.push("somatic");
  if (data.definition.components.includes(3)
    || foundry.utils.getProperty(data, "flags.ddbimporter.dndbeyond.forceMaterial")
  ) {
    properties.push("material");
  }
  if (data.definition.ritual) properties.push("ritual");
  if (data.definition.concentration) properties.push("concentration");
  return {
    value: data.definition.componentsDescription,
    vocal: data.definition.components.includes(1),
    somatic: data.definition.components.includes(2),
    material: data.definition.components.includes(3) || foundry.utils.getProperty(data, "flags.ddbimporter.dndbeyond.forceMaterial"),
    ritual: data.definition.ritual,
    concentration: data.definition.concentration,
    properties,
  };
}

function getMaterials(data) {
  // this is mainly guessing
  if (data.definition.componentsDescription && data.definition.componentsDescription.length > 0) {
    let cost = 0;
    let matches = data.definition.componentsDescription.toLowerCase().match(/([\d.,]+)\s*gp/);
    if (matches) {
      cost = parseInt(matches[1].replace(/,|\./g, ""));
    }

    return {
      value: data.definition.componentsDescription,
      consumed: data.definition.componentsDescription.toLowerCase().indexOf("consume") !== -1,
      cost: cost,
      supply: 0,
    };
  } else {
    return {
      value: "",
      consumed: false,
      cost: 0,
      supply: 0,
    };
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/prepartion.js




function classSpell(data, result) {
  const classPrepMode = utils/* default.findByProperty */.Z.findByProperty(
    dictionary/* default.spell.preparationModes */.Z.spell.preparationModes,
    "name",
    data.flags.ddbimporter.dndbeyond.class
  );

  if (data.restriction === "As Ritual Only" || data.castOnlyAsRitual || data.ritualCastingType !== null) {
    result.mode = "ritual";
    result.prepared = false;
  } else if (!data.usesSpellSlot && data.definition.level !== 0) {
    // some class features such as druid circle of stars grants x uses of a spell
    // at the lowest level. for these we add as an innate.
    result.mode = "innate";
  } else if (data.alwaysPrepared) {
    result.mode = "always";
  } else if (result.mode && classPrepMode) {
    result.mode = classPrepMode.value;
  }
  // Warlocks should use Pact spells
  // but lets mark level 0 as regular spells so they show up as cantrips
  if (result.mode === "pact" && data.definition.level === 0) {
    result.mode = "prepared";
    result.prepared = true;
  } else if (result.mode === "pact" && game.settings.get("ddb-importer", "pact-spells-prepared")) {
    result.prepared = true;
  }
  return result;
}

/**
 * Retrieves the spell preparation mode, depending on the location this spell came from
 *
 */
function getSpellPreparationMode(data) {
  // default values
  let result = {
    mode: "prepared",
    // If always prepared mark as such, if not then check to see if prepared
    prepared: data.alwaysPrepared || data.prepared,
  };

  // handle classSpells
  const featureClass = data.flags.ddbimporter.dndbeyond.lookup === "classFeature"
    && data.flags.ddbimporter.dndbeyond.class;

  if (data.flags.ddbimporter.dndbeyond.lookup === "classSpell" || featureClass) {
    result = classSpell(data, result);
  } else if (data.flags.ddbimporter.dndbeyond.lookup === "race" && data.definition.level !== 0) {
    // set race spells as innate
    result.mode = "innate";
    if (data.usesSpellSlot) {
      // some racial spells allow the spell to also be added to spell lists
      result.mode = "always";
    }
  } else if (
    // Warlock Mystic Arcanum are passed in as Features
    data.flags.ddbimporter.dndbeyond.lookupName.startsWith("Mystic Arcanum")
  ) {
    // these have limited uses (set with getUses())
    result.mode = "pact";
    result.prepared = false;
  } else if (data.flags.ddbimporter.dndbeyond.lookup === "item " && data.definition.level !== 0) {
    result.mode = "prepared";
    result.prepared = false;
  } else {
    // If spell doesn't use a spell slot and is not a cantrip, mark as always preped
    let always = !data.usesSpellSlot && data.definition.level !== 0;
    let ritaulOnly = data.ritualCastingType !== null || data.castOnlyAsRitual; // e.g. Book of ancient secrets & totem barb
    if (always && ritaulOnly) {
      // in this case we want the spell to appear in the spell list unprepared
      result.mode = "ritual";
      result.prepared = false;
    } else if (always) {
      // these spells are always prepared, and have a limited use that's
      // picked up by getUses() later
      // this was changed to "atwill"
      result.mode = "atwill";
    }
    if (data.flags.ddbimporter.dndbeyond.lookup === "classFeature") {
      if (data.alwaysPrepared) {
        result.mode = "always";
      }
    }
  }

  return result;
}

;// CONCATENATED MODULE: ./src/parser/spells/uses.js


const DEFAULT_USE = {
  value: null,
  max: null,
  per: "",
};

/**
 * Get the reset condition of the spell, if uses restricted
 * @param {*} data Spell data
 * @param {*} character Character data
 */
function getUses(data, character) {
  // we check this, as things like items have useage attached to the item, not spell
  const limitedUse = foundry.utils.getProperty(data, "flags.ddbimporter.dndbeyond.limitedUse") ?? data.limitedUse;

  if (!limitedUse) return DEFAULT_USE;
  const resetType = dictionary/* default.resets.find */.Z.resets.find((reset) => reset.id == limitedUse.resetType);
  if (!resetType) return DEFAULT_USE;

  if (limitedUse.maxUses || limitedUse.statModifierUsesId || limitedUse.useProficiencyBonus) {
    let maxUses = (limitedUse.maxUses && limitedUse.maxUses !== -1) ? limitedUse.maxUses : 0;

    if (limitedUse.statModifierUsesId) {
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
        (ability) => ability.id === limitedUse.statModifierUsesId
      ).value;

      switch (limitedUse.operator) {
        case 2: {
          maxUses *= character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
          break;
        }
        case 1:
        default:
          maxUses += character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
      }
    }

    if (limitedUse.useProficiencyBonus) {
      switch (limitedUse.proficiencyBonusOperator) {
        case 2: {
          maxUses *= character.system.attributes.prof;
          break;
        }
        case 1:
        default:
          maxUses += character.system.attributes.prof;
      }
    }

    const finalMaxUses = (maxUses) ? parseInt(maxUses) : null;

    return {
      value: (finalMaxUses !== null && finalMaxUses != 0) ? maxUses - limitedUse.numberUsed : null,
      max: (finalMaxUses != 0) ? finalMaxUses : null,
      per: resetType ? resetType.value : "",
    };
  } else {
    return DEFAULT_USE;
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/activation.js


/**
 * Gets the activation information of this spell
 */
function getActivation(data) {
  // for newer override spells, activation is at higher level
  const activation = data.activation ? data.activation : data.definition.activation;
  const activationType = dictionary/* default.spell.activationTypes.find */.Z.spell.activationTypes.find(
    (type) => type.activationType === activation.activationType
  );
  if (activationType && activation.activationTime) {
    return {
      type: activationType.value,
      cost: activation.activationTime,
      condition: data.definition.castingTimeDescription || "",
    };
  } else {
    return {
      type: "action",
      cost: 1,
      condition: data.definition.castingTimeDescription || "",
    };
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/duration.js
/**
 * Retrieves the spell duration
 */
function getDuration(data) {
  if (data.definition.duration) {
    let units = "";
    if (data.definition.duration.durationUnit !== null) {
      units = data.definition.duration.durationUnit.toLowerCase();
    } else {
      units = data.definition.duration.durationType.toLowerCase().substring(0, 4);
    }
    return {
      value: data.definition.duration.durationInterval || "",
      units: units,
    };
  } else {
    return {};
  }
}

;// CONCATENATED MODULE: ./src/parser/spells/target.js


/**
 * Does the spell target creatures?
 * @param {*} data
 */
let doesTargetCreature = (data) => {
  const creature = /You touch a creature|You touch a willing creature|affecting one creature|creature you touch|a creature you|creature( that)? you can see|interrupt a creature|would strike a creature|creature of your choice|creature or object within range|cause a creature|creature must be within range/gi;
  const creaturesRange = /(humanoid|monster|creature|target)(s)? (or loose object )?(of your choice )?(that )?(you can see )?within range/gi;
  return data.definition.description.match(creature) || data.definition.description.match(creaturesRange);
};

/**
 * Get Target Values
 * Uses regex magic to try and determine the number of creatures affected
 * @param {*} data
 */
let getTargetValues = (data) => {
  const numCreatures = /(?!At Higher Levels.*)(\w*) (falling )?(willing )?(creature|target|monster|celestial|fiend|fey|corpse(s)? of|humanoid)(?!.*you have animated)/gim;
  const targets = [...data.definition.description.matchAll(numCreatures)];
  const targetValues = targets
    .filter((target) => {
      const matches = dictionary/* default.numbers.filter */.Z.numbers.filter((n) => n.natural === target[1].toLowerCase());
      return Array.isArray(matches) && !!matches.length;
    })
    .map((target) => dictionary/* default.numbers.find */.Z.numbers.find((n) => n.natural === target[1].toLowerCase()).num);

  if (Array.isArray(targetValues) && !!targetValues.length) {
    return Math.max(...targetValues);
  } else {
    return null;
  }
};

/**
 * Spell targets
 */
// eslint-disable-next-line complexity
function getTarget(data) {
  const result = {
    value: null,
    units: null,
    type: null,
    width: null,
  };

  // if spell is an AOE effect get some details
  if (data.definition.range.aoeType && data.definition.range.aoeValue) {
    result.value = parseInt(data.definition.range.aoeValue);
    result.type = data.definition.range.aoeType.toLowerCase();
    result.units = "ft";
    return result;
  }

  // does the spell target a creature?
  const creatures = doesTargetCreature(data);

  if (creatures) {
    result.value = getTargetValues(data);
  }

  const rangeValue = foundry.utils.getProperty(data, "definition.range.rangeValue");

  switch (data.definition.range.origin) {
    case "Touch":
      if (creatures) {
        result.units = "1";
        result.type = "creature";
      }
      break;
    case "Self": {
      const dmgSpell = data.definition.modifiers.some((mod) => mod.type === "damage");
      if (dmgSpell && rangeValue) {
        result.value = rangeValue;
        result.units = "ft";
        result.type = "radius";
      } else if (dmgSpell) {
        result.type = "creature";
      } else {
        result.type = "self";
      }
      break;
    }
    case "None":
      result.type = "none";
      break;
    case "Ranged":
      if (creatures) result.type = "creature";
      break;
    case "Feet":
      if (creatures) result.type = "creature";
      break;
    case "Miles":
      if (creatures) result.type = "creature";
      break;
    case "Sight":
    case "Special":
      result.units = "special";
      break;
    case "Any":
      result.units = "any";
      break;
    case undefined:
      result.type = null;
      break;
    // no default
  }

  // wall type spell?
  if (data.definition.name.includes("Wall")) {
    result.type = "wall";
    result.units = "ft";

    if (data.definition.description.includes("ten 10-foot-")) {
      result.value = 100;
    } else {
      const wallReg = new RegExp(/ (\d*) feet long/);
      const matches = data.definition.description.match(wallReg);
      if (matches) {
        result.value = parseInt(matches[1]);
      }
    }
    const thickReg = new RegExp(/ (\d*) foot (thick|wide)/);
    const thickMatch = data.definition.description.match(thickReg);
    if (thickMatch && thickMatch[1] > 5) {
      result.width = parseInt(thickMatch[1]);
    }
  }

  return result;
}

;// CONCATENATED MODULE: ./src/parser/spells/range.js
/** Spell range */
function getRange(data) {
  // else lets try and fill in some target details
  let value = data.definition.range.rangeValue ? data.definition.range.rangeValue : null;
  let units = "ft";
  let long = null;

  switch (data.definition.range.origin) {
    case "Touch":
      value = null;
      units = "touch";
      break;
    case "Self":
      value = null;
      units = "self";
      break;
    case "None":
      units = "none";
      break;
    case "Ranged":
      units = "ft";
      break;
    case "Feet":
      units = "ft";
      break;
    case "Miles":
      units = "ml";
      break;
    case "Sight":
    case "Special":
      units = "special";
      break;
    case "Any":
      units = "any";
      break;
    case undefined:
      units = null;
      break;
    // no default
  }

  return {
    value: value,
    long: long,
    units: units,
  };
}

;// CONCATENATED MODULE: ./src/parser/spells/action.js
function getActionType(data) {
  if (data.definition.requiresSavingThrow && !data.definition.requiresAttackRoll) {
    return "save";
  }

  if (
    data.definition.tags.includes("Damage")
    && data.definition.range.rangeValue
    && data.definition.range.rangeValue > 0
  ) {
    return "rsak";
  }

  if (data.definition.tags.includes("Damage")) {
    return "msak";
  }

  if (data.definition.tags.includes("Healing")) {
    return "heal";
  }

  if (data.definition.tags.includes("Buff")) {
    return "util";
  }

  return "other";
}

;// CONCATENATED MODULE: ./src/parser/spells/damage.js


let getAlternativeFormula = (data) => {
  // this might be specificially for Toll the Dead only, but it's better than nothing

  let description = data.definition.description;
  let match = description.match(/instead[\w\s]+(\d+d\d+) (\w+) damage/);
  if (match) {
    return match[1];
  } else {
    return "";
  }
};

function getDamage(data, spell) {
  let result = {
    parts: [],
    versatile: "",
  };
  let chatFlavor = [];

  const globalDamageHints = game.settings.get("ddb-importer", "use-damage-hints");
  const spellEffects = foundry.utils.getProperty(data, "flags.ddbimporter.addSpellEffects");
  const damageRestrictionHints = game.settings.get("ddb-importer", "add-damage-restrictions-to-hints") && !spellEffects;
  const hintOrRestriction = globalDamageHints || damageRestrictionHints;

  // damage
  const attacks = data.definition.modifiers.filter((mod) => mod.type === "damage");
  if (attacks.length !== 0) {
    const cantripBoost = data.definition.level === 0 && !!data.flags.ddbimporter.dndbeyond.cantripBoost;
    attacks.forEach((attack) => {
      const restrictionText = attack.restriction && attack.restriction !== "" ? attack.restriction : "";
      const restriction = damageRestrictionHints && restrictionText !== "" ? restrictionText : "";
      const damageHintText = attack.subType || "";
      if (!damageRestrictionHints && restrictionText !== "") {
        const damageText = attack.die.diceString ? `${attack.die.diceString} - ` : "";
        chatFlavor.push(`[${damageText}${damageHintText}] ${restrictionText}`);
      }
      const hintAndRestriction = globalDamageHints && restriction !== "" ? " - " : "";
      const damageHint = globalDamageHints ? damageHintText : "";
      const damageTag = hintOrRestriction ? `[${damageHint}${hintAndRestriction}${restriction}]` : "";
      const addMod = attack.usePrimaryStat || cantripBoost ? " + @mod" : "";
      let diceString = utils/* default.parseDiceString */.Z.parseDiceString(attack.die.diceString, addMod, damageTag).diceString;
      if (diceString && diceString.trim() !== "" && diceString.trim() !== "null") result.parts.push([diceString, attack.subType]);
    });

    // This is probably just for Toll the dead.
    const alternativeFormula = getAlternativeFormula(data);
    result.versatile = cantripBoost && alternativeFormula && alternativeFormula != "" ? `${alternativeFormula} + @mod` : alternativeFormula;
  }

  // healing
  const heals = data.definition.modifiers.filter((mod) => mod.type === "bonus" && mod.subType === "hit-points");
  if (heals.length !== 0) {
    const healingBonus = (spell.flags.ddbimporter.dndbeyond.healingBoost) ? ` + ${spell.flags.ddbimporter.dndbeyond.healingBoost} + @item.level` : "";
    heals.forEach((heal) => {
      const restrictionText = heal.restriction && heal.restriction !== "" ? heal.restriction : "";
      const restriction = damageRestrictionHints && restrictionText !== "" ? restrictionText : "";
      if (!damageRestrictionHints && restrictionText !== "") {
        const damageText = heal.die.diceString ? `${heal.die.diceString} - ` : "";
        chatFlavor.push(`[${damageText}healing] ${restrictionText}`);
      }
      const hintAndRestriction = globalDamageHints && restriction !== "" ? " - " : "";
      const damageHint = globalDamageHints ? "healing" : "";
      const damageTag = hintOrRestriction ? `[${damageHint}${hintAndRestriction}${restriction}]` : "";
      const healValue = (heal.die.diceString) ? `${heal.die.diceString}${damageTag}` : heal.die.fixedValue;
      const diceString = heal.usePrimaryStat
        ? `${healValue} + @mod${healingBonus}`
        : `${healValue}${healingBonus}`;
      if (diceString && diceString.trim() !== "" && diceString.trim() !== "null") result.parts.push([diceString, "healing"]);
    });
  }

  return [result, chatFlavor.join(", ")];
}

;// CONCATENATED MODULE: ./src/parser/spells/save.js


function getSave(data) {
  if (data.definition.requiresSavingThrow && data.definition.saveDcAbilityId) {
    const saveAbility = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === data.definition.saveDcAbilityId)
      .value;
    if (data.overrideSaveDc) {
      return {
        ability: saveAbility,
        dc: data.overrideSaveDc,
        scaling: "flat",
      };
    } else {
      return {
        ability: saveAbility,
        dc: null,
        scaling: "spell",
      };
    }
  } else {
    return {
      ability: "",
      dc: null,
    };
  }
}

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
;// CONCATENATED MODULE: ./src/parser/spells/scaling.js


/**
 * Get the scaling type for a spell mod
 * This is complex logic and is broken out to help simplify
 * @param {*} name
 * @param {*} mod
 */
let getScaleType = (name, data, mod) => {
  // scaleTypes:
  // SPELLSCALE - typical spells that scale
  // SPELLLEVEL - these spells have benefits that come in at particular levels e.g. bestow curse, hex. typically  duration changes
  // CHARACTERLEVEL - typical cantrip based levelling, some expections (eldritch blast)
  let scaleType = null;
  const modScaleType = mod.atHigherLevels.scaleType ? mod.atHigherLevels.scaleType : data.definition.scaleType;
  const isHigherLevelDefinitions
    = mod.atHigherLevels.higherLevelDefinitions
    && Array.isArray(mod.atHigherLevels.higherLevelDefinitions)
    && mod.atHigherLevels.higherLevelDefinitions.length >= 1;

  if (isHigherLevelDefinitions && modScaleType === "spellscale") {
    const definition = mod.atHigherLevels.higherLevelDefinitions[0];
    if (definition) {
      scaleType = modScaleType;
    } else {
      logger/* default.warn */.Z.warn("No spell definition found for " + name);
    }
  } else if (modScaleType === "spellscale") {
    // lets handle cases where there is a spellscale type but no damage
    // increase/ higherleveldefinitins e.g. chain lighting
    // these type of spells typically increase targets so we set the
    // scaling to null as we don't want to increase damage when upcast.
    // this also deals with cases like Ice Knife where the upscale damage
    // is in one of the two mods provided.
    // we are capturing this else because we don't want to trigger
    // an update to scaleType or a warning.
  } else if (modScaleType === "characterlevel") {
    // lets handle odd cantrips like Eldritch Blast
    // (in fact this might be the only case)
    if (mod.atHigherLevels.higherLevelDefinitions.length === 0) {
      // if this array is empty it does not contain levelling information
      // the only case found is Eldritch Blast.
      // this does have some info around multiple beams in
      // data.atHigherLevels but we ignore this. we will set the scaling
      // to null as each beam is best modelled by "casting" the cantrip again/
      // pressing the attack/damage buttons in FVTT
      scaleType = null;
    } else {
      scaleType = modScaleType;
    }
  } else if (modScaleType === "spelllevel") {
    // spells that have particular level associated benefits
    // these seem to be duration increases or target increases for
    // the most part we can't handle these in FVTT right now (we could
    // in theory create a new spell at a higher level).
    // some duration upcasting (like bestow curse) affects concentration
    // for now we will do nothing with these spells.
    // examples include: hex, shadowblade, magic weapon, bestow curse
    scaleType = modScaleType;
  } else {
    logger/* default.warn */.Z.warn(`${name} parse failed: `, modScaleType);
    scaleType = modScaleType; // if this is new/unknow will use default
  }

  return scaleType;
};

function getSpellScaling(data) {
  let baseDamage = "";
  let scaleDamage = "";
  let scaleType = null; // defaults to null, so will be picked up as a None scaling spell.

  // spell scaling
  if (data.definition.canCastAtHigherLevel) {
    // iterate over each spell modifier
    data.definition.modifiers
      .filter((mod) => mod.type === "damage" || (mod.type === "bonus" && mod.subType === "hit-points"))
      // eslint-disable-next-line complexity
      .forEach((mod) => {
        // if the modifier has a die for damage, lets use the string or fixed value
        // for the base damage
        if (mod && mod.die) {
          if (mod.die.diceString !== null) {
            baseDamage = mod.die.diceString;
          }

          if (mod.die.fixedValue !== null && baseDamage === "") {
            baseDamage = mod.die.fixedValue;
          }
        }

        // defines some details about higher level casting
        if (mod.atHigherLevels) {
          // scaleTypes:
          // SPELLSCALE - typical spells that scale
          // SPELLLEVEL - these spells have benefits that come in at particular levels e.g. bestow curse, hex. typically  duration changes
          // CHARACTERLEVEL - typical cantrip based levelling, some expections (eldritch blast)

          // mod.atHigherLevels.higherLevelDefinitions contains info about the
          // spells damage die at higher levels, but we can't use this for cantrips as
          // FVTT use a formula to work out the scaling (ddb has a fixed value structure)
          const isHigherLevelDefinitions
            = mod.atHigherLevels.higherLevelDefinitions
            && Array.isArray(mod.atHigherLevels.higherLevelDefinitions)
            && mod.atHigherLevels.higherLevelDefinitions.length >= 1;

          // lets handle normal spell leveling first
          const modScaleType = mod.atHigherLevels.scaleType ? mod.atHigherLevels.scaleType : data.definition.scaleType;
          if (isHigherLevelDefinitions && modScaleType === "spellscale") {
            const definition = mod.atHigherLevels.higherLevelDefinitions[0];
            if (definition) {
              const die = definition.dice ? definition.dice : definition.die ? definition.die : undefined;
              const modScaleDamage
                = die?.diceString // if dice string
                  ? die.diceString // use dice string
                  : die?.fixedValue // else if fixed value
                    ? die.fixedValue // use fixed value
                    : definition.value; // else use value

              // some spells have multiple scaling damage (e.g. Wall of Ice,
              // Glyph of warding, Acid Arrow, Arcane Hand, Dragon's Breath,
              // Chromatic Orb, Absorb Elements, Storm Sphere, Spirit Guardians)
              // it's hard to model most of these in FVTT, and for some it makes
              // no difference. so...
              // lets optimistically use the highest
              // assumptions: these are going to be dice strings, and we don't care
              // about dice value, just number of dice
              const diceFormula = /(\d*)d\d*/;
              const existingMatch = diceFormula.exec(scaleDamage);
              const modMatch = diceFormula.exec(modScaleDamage);

              const modMatchValue = modMatch
                ? modMatch.length > 1 ? modMatch[1] : modMatch[0]
                : undefined;

              if (!existingMatch && !modMatch) {
                scaleDamage = modScaleDamage;
              } else if (!existingMatch || modMatchValue > existingMatch[1]) {
                scaleDamage = modScaleDamage;
              }
            } else {
              logger/* default.warn */.Z.warn("No definition found for " + data.definition.name);
            }
          } else if (isHigherLevelDefinitions && modScaleType === "characterlevel") {
            // cantrip support, important to set to a fixed value if using abilities like potent spellcasting
            scaleDamage = baseDamage;
          }

          scaleType = getScaleType(data.definition.name, data, mod);
        }
      });
  }

  switch (scaleType) {
    case "characterlevel":
      return {
        mode: "cantrip",
        formula: scaleDamage,
      };
    case "spellscale":
      return {
        mode: "level",
        formula: scaleDamage,
      };
    case "spelllevel":
    case null:
      return {
        mode: "none",
        formula: "",
      };
    default:
      return {
        mode: "level",
        formula: "",
      };
  }
}

// EXTERNAL MODULE: ./src/lib/DDBTable.js + 2 modules
var DDBTable = __webpack_require__(5366);
// EXTERNAL MODULE: ./src/effects/specialSpells.js + 124 modules
var specialSpells = __webpack_require__(3137);
;// CONCATENATED MODULE: ./src/parser/spells/name.js


function getCustomName(data, character) {
  if (!character || (character && !foundry.utils.hasProperty(character, "flags.ddbimporter.dndbeyond.characterValues"))) return null;
  const characterValues = character.flags.ddbimporter.dndbeyond.characterValues;
  const customValue = characterValues.filter((value) => value.valueId == data.id && value.valueTypeId == data.entityTypeId);

  if (customValue) {
    const customName = customValue.find((value) => value.typeId == 8);

    if (customName) {
      data.name = customName.vale;
      return customName.value;
    }
    if (customName) return customName.value;
  }
  return null;
}


function getName(data, character) {
  // spell name
  const customName = getCustomName(data, character);
  if (customName) {
    return utils/* default.nameString */.Z.nameString(customName);
  } else if (data.flags.ddbimporter.dndbeyond.nameOverride !== undefined) {
    return utils/* default.nameString */.Z.nameString(data.flags.ddbimporter.dndbeyond.nameOverride);
  } else {
    return utils/* default.nameString */.Z.nameString(data.definition.name);
  }
}

// EXTERNAL MODULE: ./src/lib/DDBReferenceLinker.js
var DDBReferenceLinker = __webpack_require__(7162);
// EXTERNAL MODULE: ./src/settings.js
var settings = __webpack_require__(6451);
// EXTERNAL MODULE: ./src/parser/companions/DDBCompanionFactory.js
var DDBCompanionFactory = __webpack_require__(3972);
;// CONCATENATED MODULE: ./src/parser/spells/parseSpell.js




// Import parsing functions



















async function parseSpell(data, character, { namePostfix = null } = {}) {
  const name = getName(data, character);
  let spell = {
    _id: utils/* default.namedIDStub */.Z.namedIDStub(name, { postfix: namePostfix }),
    type: "spell",
    system: utils/* default.getTemplate */.Z.getTemplate("spell"),
    name: name,
    flags: {
      ddbimporter: {
        id: data.id,
        definitionId: data.definition.id,
        entityTypeId: data.entityTypeId,
        dndbeyond: data.flags.ddbimporter.dndbeyond,
        originalName: utils/* default.nameString */.Z.nameString(data.definition.name),
        sources: data.definition.sources,
        tags: data.definition.tags,
        version: CONFIG.DDBI.version,
      },
      "midi-qol": {
        removeAttackDamageButtons: "default",
      },
      midiProperties: {
        confirmTargets: "default",
        magicdam: true,
        magiceffect: true,
      },
      // "spellbook-assistant-manager": data.flags["spellbook-assistant-manager"],
      "spell-class-filter-for-5e": data.flags["spell-class-filter-for-5e"],
      "tidy5e-sheet-kgar": data.flags["tidy5e-sheet-kgar"],
    },
  };

  const isGeneric = foundry.utils.getProperty(data, "flags.ddbimporter.generic");
  const addSpellEffects = isGeneric
    ? game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-add-spell-effects")
    : game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "character-update-policy-add-spell-effects");
  foundry.utils.setProperty(data, "flags.ddbimporter.addSpellEffects", addSpellEffects);

  // spell level
  spell.system.level = data.definition.level;

  // get the spell school
  const school = dictionary/* default.spell.schools.find */.Z.spell.schools.find((s) => s.name === data.definition.school.toLowerCase());
  spell.system.school = (school) ? school.id : null;

  /**
   * Gets the necessary spell components VSM + material
   */
  spell.system.properties = getComponents(data)?.properties ?? [];
  spell.system.materials = getMaterials(data);
  spell.system.preparation = getSpellPreparationMode(data);

  const updateExisting = data.flags.ddbimporter.generic
    ? game.settings.get("ddb-importer", "munching-policy-update-existing")
    : false;
  // eslint-disable-next-line require-atomic-updates
  data.definition.description = await (0,DDBTable/* generateTable */.p)(spell.name, data.definition.description, updateExisting);

  spell.system.description = {
    value: (0,DDBReferenceLinker/* parseTags */.RN)(data.definition.description),
    chat: "",
  };

  spell.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  spell.system.activation = getActivation(data);
  spell.system.duration = getDuration(data);
  spell.system.target = getTarget(data);
  spell.system.range = getRange(data);
  spell.system.actionType = getActionType(data);
  const [damage, chatFlavor] = getDamage(data, spell);
  spell.system.damage = damage;
  spell.system.chatFlavor = chatFlavor;
  spell.system.save = getSave(data);
  spell.system.scaling = getSpellScaling(data);
  spell.system.uses = getUses(data, character);
  spell.system.consume.target = "";

  // attach the spell ability id to the spell data so VTT always uses the
  // correct one, useful if multi-classing and spells have different
  // casting abilities
  if (character && character.system.attributes.spellcasting !== data.flags.ddbimporter.dndbeyond.ability) {
    spell.system.ability = data.flags.ddbimporter.dndbeyond.ability;
    if (spell.system.save.scaling == "spell") {
      spell.system.save.scaling = data.flags.ddbimporter.dndbeyond.ability;
    }
  }
  if (spell.system.ability === null) spell.system.ability = "";

  await (0,specialSpells/* spellEffectAdjustment */.x)(spell, addSpellEffects);
  foundry.utils.setProperty(spell, "flags.ddbimporter.effectsApplied", true);

  if (isGeneric || game.settings.get(settings/* default.MODULE_ID */.Z.MODULE_ID, "character-update-policy-create-companions")) {
    if (settings/* default.COMPANIONS.COMPANION_SPELLS.includes */.Z.COMPANIONS.COMPANION_SPELLS.includes(data.definition.name)) {
      const ddbCompanionFactory = new DDBCompanionFactory/* default */.Z(data.definition.description, {
        type: "spell",
        originDocument: spell,
      });
      await ddbCompanionFactory.parse();
      await ddbCompanionFactory.updateOrCreateCompanions();
      await ddbCompanionFactory.addCompanionsToDocuments([]);

      logger/* default.debug */.Z.debug(`parsed companions for ${spell.name}`, {
        factory: ddbCompanionFactory,
        parsed: ddbCompanionFactory.companions,
      });
    }

  }

  return spell;
}


/***/ }),

/***/ 1838:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": () => (/* binding */ fixSpells)
/* harmony export */ });
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5259);
/* harmony import */ var _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1438);
/* harmony import */ var _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3893);





let getEldritchInvocations = (ddb) => {
  let damage = "";
  let range = 0;

  const eldritchBlastMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterBaseModifiers */ .Z.filterBaseModifiers(ddb, "eldritch-blast").filter((modifier) => modifier.isGranted);

  eldritchBlastMods.forEach((mod) => {
    switch (mod.subType) {
      case "bonus-damage": {
        // almost certainly CHA :D
        const abilityModifierLookup = _dictionary_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].character.abilities.find */ .Z.character.abilities.find((ability) => ability.id === mod.statId);
        if (abilityModifierLookup) {
          if (damage !== "") damage += " + ";
          damage += `@abilities.${abilityModifierLookup.value}.mod`;
        } else if (mod.fixedValue) {
          if (damage !== "") damage += " + ";
          damage += `${mod.fixedValue}`;
        }
        break;
      }
      case "bonus-range":
        range = mod.value;
        break;
      default:
        _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].warn */ .Z.warn(`Not yet able to process ${mod.subType}, please raise an issue.`);
    }
  });

  return {
    damage: damage,
    range: range,
  };
};

function getRangeAdjustmentMultiplier(ddb) {
  const rangeAdjustmentMods = _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].filterBaseModifiers */ .Z.filterBaseModifiers(ddb, "bonus", { subType: "spell-attack-range-multiplier" }).filter((modifier) => modifier.isGranted);

  const multiplier = rangeAdjustmentMods.reduce((current, mod) => {
    if (Number.isInteger(mod.fixedValue) && mod.fixedValue > current) {
      current = mod.fixedValue;
    } else if (Number.isInteger(mod.value) && mod.value > current) {
      current = mod.value;
    }
    return current;
  }, 1);

  return multiplier;
}

function adjustRange(multiplier, spell) {
  if (spell.system.actionType === "rsak" && Number.isInteger(spell.system.range?.value)) {
    foundry.utils.setProperty(spell, "system.range.value", spell.system.range.value * multiplier);
  }
  return spell;
}

const CR_DATA = {
  "Conjure Animals": {
    profiles: [
      {
        "count": "1 * min(3, floor((@item.level - 1) / 2))",
        "cr": "2",
        "types": ["beast"],
      },
      {
        "count": "2 * min(3, floor((@item.level - 1) / 2))",
        "cr": "1",
        "types": ["beast"],
      },
      {
        "count": "4 * min(3, floor((@item.level - 1) / 2))",
        "cr": "0.5",
        "types": ["beast"],
      },
      {
        "count": "8 * min(3, floor((@item.level - 1) / 2))",
        "cr": "0.25",
        "types": ["beast"],
      }
    ],
    creatureTypes: ["beast"],
  },
  "Conjure Celestial": {
    profiles: [
      {
        "count": "1",
        "cr": "4",
        "level": {
          "min": null,
          "max": 8
        },
        "types": ["celestial"],
      },
      {
        "count": "1",
        "cr": "5",
        "level": {
          "min": 9,
          "max": null,
        },
        "types": ["celestial"],
      }
    ],
    creatureTypes: [],
  },
  "Conjure Elemental": {
    profiles: [
      {
        "count": "1",
        "cr": "@item.level",
        "types": ["elemental"],
      }
    ],
    creatureTypes: ["elemental"],
  },
  "Conjure Fey": {
    profiles: [
      {
        "count": "1",
        "cr": "@item.level",
        "types": ["fey"],
      }
    ],
    creatureTypes: ["fey"],
  },
  "Conjure Minor Elementals": {
    profiles: [
      {
        "count": "1 * min(3, floor((@item.level - 2) / 2))",
        "cr": "2",
        "types": ["elemental"],
      },
      {
        "count": "2 * min(3, floor((@item.level - 2) / 2))",
        "cr": "1",
        "types": ["elemental"],
      },
      {
        "count": "4 * min(3, floor((@item.level - 2) / 2))",
        "cr": "0.5",
        "types": ["elemental"],
      },
      {
        "count": "8 * min(3, floor((@item.level - 2) / 2))",
        "cr": "0.25",
        "types": ["elemental"],
      }
    ],
    creatureTypes: [],
  },
  "Conjure Woodland Beings": {
    profiles: [
      {
        "count": "1 * min(3, floor((@item.level - 2) / 2))",
        "cr": "2",
        "types": ["fey"],
      },
      {
        "count": "2 * min(3, floor((@item.level - 2) / 2))",
        "cr": "1",
        "types": ["fey"],
      },
      {
        "count": "4 * min(3, floor((@item.level - 2) / 2))",
        "cr": "0.5",
        "types": ["fey"],
      },
      {
        "count": "8 * min(3, floor((@item.level - 2) / 2))",
        "cr": "0.25",
        "types": ["fey"],
      },
    ],
    creatureTypes: ["fey"],
  },
  "Summon Greater Demon": {
    profiles: [
      {
        "count": "1",
        "cr": "@item.level + 1",
        "types": ["fiend"],
      }
    ],
    creatureTypes: [],
  },
  "Summon Lesser Demons": {
    profiles: [
      {
        "count": "2 * min(3, floor((@item.level - 2) / 2))",
        "cr": "1",
        "types": ["fiend"],
      },
      {
        "count": "4 * min(3, floor((@item.level - 2) / 2))",
        "cr": "0.5",
        "types": ["fiend"],
      },
      {
        "count": "8 * min(3, floor((@item.level - 2) / 2))",
        "cr": "0.25",
        "types": ["fiend"],
      },
    ],
    creatureTypes: [],
  },
  "Infernal Calling": {
    profiles: [
      {
        "count": "1",
        "cr": "@item.level + 1",
        "types": ["fiend"],
      }
    ],
    creatureTypes: [],
  }
};

async function addCRSummoning(documents) {
  if (game.release.generation < 12) return documents;
  _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking spells for cr summoning..`);
  for (const spell of documents) {
    const name = spell.flags.ddbimporter?.originalName ?? spell.name;
    switch (name) {
      case "Conjure Animals":
      case "Conjure Celestial":
      case "Conjure Elemental":
      case "Conjure Fey":
      case "Conjure Minor Elementals":
      case "Conjure Woodland Beings":
      case "Summon Greater Demon":
      case "Infernal Calling":
      case "Summon Lesser Demons": {
        spell.system.actionType = "summ";
        spell.system.summons = {
          prompt: true,
          mode: "cr",
          profiles: CR_DATA[name].profiles,
          creatureTypes: CR_DATA[name].creatureTypes,
        };
        break;
      }
      // no default
    }
  };

  return documents;
}

async function findFamiliar(spell) {
  const ddbCompendium = _lib_CompendiumHelper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getCompendiumType */ .Z.getCompendiumType("monster", false);
  await ddbCompendium?.getIndex();

  spell.system.actionType = "summ";
  spell.system.summons = {
    "prompt": true,
    "creatureTypes": [
      "celestial",
      "fey",
      "fiend"
    ],
    "profiles": [
      {
        "name": "Bat",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Bat")?.uuid ?? "Compendium.dnd5e.monsters.Actor.qav2dvMIUiMQCCsy",
      },
      {
        "name": "Cat",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Cat")?.uuid ?? "Compendium.dnd5e.monsters.Actor.hIf83RD3ZVW4Egfi",
      },
      {
        "name": "Crab",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Crab")?.uuid ?? "Compendium.dnd5e.monsters.Actor.8RgUhb31VvjUNZU1",
      },
      {
        "name": "Fish",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Quipper")?.uuid ?? "Compendium.dnd5e.monsters.Actor.nkyCGJ9wXeAZkyyz",
      },
      {
        "name": "Frog",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Frog")?.uuid ?? "Compendium.dnd5e.monsters.Actor.EZgiprHXA2D7Uyb3",
      },
      {
        "name": "Hawk",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Hawk")?.uuid ?? "Compendium.dnd5e.monsters.Actor.fnkPNfIpS62LqOu4",
      },
      {
        "name": "Lizard",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Lizard")?.uuid ?? "Compendium.dnd5e.monsters.Actor.I2x01hzOjVN4NUjf",
      },
      {
        "name": "Octopus",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Octopus")?.uuid ?? "Compendium.dnd5e.monsters.Actor.3UUNbGiG2Yf1ZPxM",
      },
      {
        "name": "Owl",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Owl")?.uuid ?? "Compendium.dnd5e.monsters.Actor.d0prpsGSAorDadec",
      },
      {
        "name": "Poisonous Snake",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Poisonous Snake")?.uuid ?? "Compendium.dnd5e.monsters.Actor.D5rwVIxmfFrdyyxT",
      },
      {
        "name": "Rat",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Rat")?.uuid ?? "Compendium.dnd5e.monsters.Actor.pozQUPTnLZW8epox",
      },
      {
        "name": "Raven",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Raven")?.uuid ?? "Compendium.dnd5e.monsters.Actor.LPdX5YLlwci0NDZx",
      },
      {
        "name": "Sea Horse",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Sea Horse")?.uuid ?? "Compendium.dnd5e.monsters.Actor.FWSDiq9SZsdiBAa8",
      },
      {
        "name": "Spider",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Spider")?.uuid ?? "Compendium.dnd5e.monsters.Actor.28gU50HtG8Kp7uIz",
      },
      {
        "name": "Weasel",
        "uuid": ddbCompendium?.index.find((i) => i.name === "Weasel")?.uuid ?? "Compendium.dnd5e.monsters.Actor.WOdeacKCYVhgLDuN",
      }
    ],
    "creatureSizes": [],
    "match": {
      "attacks": false,
      "proficiency": false,
      "saves": false
    },
    "mode": ""
  };
  return spell;
}

/**
 * Some spells we need to fix up or massage because they are modified
 * in interesting ways
 * @param {*} ddb
 * @param {*} documents
 */
/* eslint-disable complexity */
async function fixSpells(ddb, documents) {
  // because the effect parsing happens before this, we need to fix some of the spell changes here
  const usingEffects = ddb === null
    ? game.settings.get("ddb-importer", "munching-policy-add-spell-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-spell-effects");

  const rangeMultiplier = ddb ? getRangeAdjustmentMultiplier(ddb) : 1;

  for (let spell of documents) {
    const name = spell.flags.ddbimporter?.originalName ?? spell.name;
    _logger_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].debug */ .Z.debug(`Checking spell ${name} for corrections...`);
    switch (name) {
      case "Melf's Acid Arrow":
      case "Acid Arrow": {
        if (spell.system.damage?.parts.length > 1) {
          const baseDamage = foundry.utils.duplicate(spell.system.damage.parts[0]);
          const otherDamage = foundry.utils.duplicate(spell.system.damage.parts[1]);
          spell.system.damage.parts = [baseDamage];
          spell.system.formula = otherDamage[0];
        }
        break;
      }
      case "Aid": {
        spell.system.scaling = { mode: "level", formula: "(@item.level - 2) * 5" };
        break;
      }
      case "Armor of Agathys": {
        spell.system.actionType = "util";
        spell.system.target.type = "self";
        spell.system.damage.parts[0] = ["5", "temphp"];
        spell.system.scaling = { mode: "level", formula: "((@item.level - 1) * 5)" };
        break;
      }
      case "Arms of Hadar": {
        spell.system.target.type = "special";
        break;
      }
      case "Absorb Elements":
        if (!usingEffects) {
          spell.system.damage = { parts: [["1d6", ""]], versatile: "", value: "" };
          spell.system.target["value"] = 1;
        }
        spell.system.chatFlavor = "Uses the damage type of the triggered attack: Acid, Cold, Fire, Lightning, or Poison.";
        break;
      case "Booming Blade":
        if (!usingEffects) {
          spell.system.damage = { parts: [["0", "thunder"]], versatile: "1d8", value: "" };
        }
        spell.system.scaling = { mode: "cantrip", formula: "1d8" };
        spell.system.actionType = "other";
        spell.system.target.type = "creature";
        spell.system.target.value = 1;
        spell.system.target.units = "";
        break;
      case "Bones of the Earth": {
        spell.system.target.value = 2.5;
        break;
      }
      case "Catapult": {
        foundry.utils.setProperty(spell, "flags.midiProperties.nodam", true);
        break;
      }
      case "Call Lightning": {
        if (usingEffects) {
          spell.system.damage = { parts: [], versatile: "", value: "" };
          spell.system.save.ability = "";
        }
        break;
      }
      // dnd beyond lists a damage for each type
      case "Chaos Bolt":
        spell.system.damage = { parts: [["2d8", ""], ["1d6", ""]], versatile: "", value: "", };
        break;
      // dnd beyond lists a damage for each type
      case "Chromatic Orb":
        spell.system.damage = { parts: [["3d8", ""]], versatile: "", value: "" };
        spell.system.chatFlavor = "Choose from Acid, Cold, Fire, Lightning, Poison, Thunder, or Acid";
        break;
      case "Color Spray": {
        if (!usingEffects) {
          spell.system.damage = { parts: [["6d10", ""]], versatile: "", value: "" };
        }
        spell.system.scaling = { mode: "level", formula: "2d10" };
        break;
      }
      case "Control Weather": {
        spell.system.target.type = "self";
        spell.system.range = { value: 5, units: "mi", long: null };
        break;
      }
      case "Cloud of Daggers":
        spell.system.actionType = "other";
        break;
      case "Darkvision": {
        spell.system.target.type = "creature";
        break;
      }
      case "Divine Favor": {
        spell.system.actionType = "util";
        spell.system.target.type = "self";
        break;
      }
      case "Dragon's Breath":
        spell.system.damage = { parts: [["3d6", ""]], versatile: "", value: "" };
        spell.system.chatFlavor = "Choose one of Acid, Cold, Fire, Lightning, or Poison.";
        break;
      // Eldritch Blast is a special little kitten and has some fun Eldritch
      // Invocations which can adjust it.
      case "Eldritch Blast": {
        if (!ddb) break;
        const eldritchBlastMods = getEldritchInvocations(ddb);
        if (eldritchBlastMods["damage"] && eldritchBlastMods["damage"] !== "") {
          spell.system.damage.parts[0][0] += " + " + eldritchBlastMods["damage"];
        }
        spell.system.range.value += eldritchBlastMods["range"];
        break;
      }
      case "False Life": {
        spell.system.actionType = "heal";
        spell.system.target.type = "self";
        spell.system.damage.parts[0] = ["1d4 + 4", "temphp"];
        spell.system.scaling = { mode: "level", formula: "(@item.level - 1) * 5" };
        break;
      }
      case "Find Familiar": {
        await findFamiliar(spell);
        break;
      }
      case "Guidance": {
        spell.system.target = { value: 1, units: "", type: "creature" };
        break;
      }
      case "Green-Flame Blade":
        if (!usingEffects) {
          spell.system.damage = { parts: [["0", "fire"]], versatile: "@mod", value: "" };
        }
        spell.system.scaling = { mode: "cantrip", formula: "1d8" };
        spell.system.actionType = "other";
        spell.system.target.type = "creature";
        spell.system.target.value = 1;
        spell.system.target.units = "";
        break;
      case "Gust of Wind":
        spell.system.target = { value: 60, units: "ft", type: "line", width: 10 };
        break;
      case "Goodberry":
        spell.system.damage = { parts: [["1", "healing"]], versatile: "", value: "" };
        break;
      case "Heat Metal":
        spell.system.actionType = "save";
        break;
      case "Hex": {
        spell.system.actionType = "other";
        if (usingEffects) {
          spell.system.damage = { parts: [], versatile: "", value: "" };
        }
        break;
      }
      case "Heroe's Feast":
      case "Heroes Feast":
      case "Heroes Feast": {
        spell.system.duration = { value: 1, units: "day" };
        break;
      }
      case "Heroism": {
        spell.system.damage.parts[0] = ["@mod", "temphp"];
        break;
      }
      case "Hunter's Mark":
      case "Hunters Mark": {
        spell.system.actionType = "other";
        if (usingEffects) {
          spell.system.damage = { parts: [], versatile: "", value: "" };
        } else {
          spell.system.damage = { parts: [["1d6", ""]], versatile: "", value: "" };
        }
        break;
      }
      case "Ice Storm":
        spell.system.damage.parts[0][0] = "(@item.level - 2)d8[bludgeoning]";
        spell.system.scaling = { mode: "", formula: "" };
        break;
      case "Flaming Sphere":
        spell.system.target["value"] = 2.5;
        break;
      case "Light": {
        spell.system.target = { value: 1, width: null, units: "", type: "object" };
        break;
      }
      case "Magic Missile":
        spell.system.actionType = "other";
        break;
      case "Produce Flame":
        spell.system.range = { value: 30, units: "ft", long: null };
        break;
      case "Primal Savagery":
        spell.system.target = { value: 1, width: null, units: "", type: "creature" };
        spell.system.range = { value: 5, units: "ft", long: null };
        break;
      case "Pyrotechnics":
        spell.system.target["value"] = 15;
        break;
      case "Protection from Energy": {
        spell.system.target.type = "creature";
        break;
      }
      case "Ray of Enfeeblement":
        spell.system.actionType = "rsak";
        break;
      case "Shadow of Moil":
        spell.system.actionType = "other";
        break;
      case "Searing Smite": {
        if (spell.system.damage.parts.length > 1) {
          spell.system.formula = spell.system.damage.parts[1][0];
          spell.system.damage.parts = [spell.system.damage.parts[0]];
        }
        spell.system.scaling = { mode: "level", formula: "1d6" };
        break;
      }
      case "Spirit Guardians": {
        if (!ddb) break;
        const radiantAlignments = [1, 2, 3, 4, 5, 6, 10, 14];
        const necroticAlignments = [7, 8, 9, 11];
        if (radiantAlignments.includes(ddb.character.alignmentId)) {
          foundry.utils.setProperty(spell, "flags.ddbimporter.damageType", "radiant");
          spell.system.damage = { parts: [["3d8", "radiant"]], versatile: "", value: "" };
        } else if (necroticAlignments.includes(ddb.character.alignmentId)) {
          foundry.utils.setProperty(spell, "flags.ddbimporter.damageType", "necrotic");
          spell.system.damage = { parts: [["3d8", "necrotic"]], versatile: "", value: "" };
        }
        break;
      }
      case "Spiritual Weapon":
      case "Spirit Shroud": {
        spell.system.damage.parts = [["(floor(@item.level / 2))d8 + @mod"]["radiant"]];
        spell.system.scaling = { mode: "none", formula: "" };
        // spell.system.scaling = { mode: "level", formula: "(floor((@item.level - 1)/2))d8" };
        break;
      }
      case "Spike Growth": {
        spell.system.actionType = "other";
        break;
      }
      case "Sleep": {
        if (!usingEffects) {
          spell.system.damage = { parts: [["5d8", ""]], versatile: "", value: "" };
        }
        spell.system.scaling = { mode: "level", formula: "2d8" };
        break;
      }
      case "Tidal Wave":
        spell.system.target = {
          "value": "30",
          "units": "ft",
          "type": "line",
          "width": 10,
          "prompt": true
        };
        break;
      case "Thorn Whip": {
        spell.system.actionType = "msak";
        break;
      }
      // The target/range input data are incorrect on some AOE spells centred
      // on self.
      // Range is self with an AoE target of 15 ft cube
      // i.e. affects all creatures within 5 ft of caster
      case "Thunderclap":
      case "Word of Radiance":
        spell.system.range = { value: null, units: "spec", long: null };
        spell.system.target = { value: 15, units: "ft", type: "cube" };
        break;
      case "Thunder Step":
        spell.system.range = { value: null, units: "spec", long: null };
        break;
      case "Toll the Dead":
        spell.system.scaling = { mode: "cantrip", formula: "" };
        break;
      case "Vitriolic Sphere": {
        spell.system.scaling = { mode: "level", formula: "2d4" };
        break;
      }
      // no default
    }

    if (rangeMultiplier != 1) {
      spell = adjustRange(rangeMultiplier, spell);
    }
    if (ddb) _lib_DDBHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].addCustomValues */ .Z.addCustomValues(ddb, spell);
  };

  await addCRSummoning(documents);
}
/* eslint-enable complexity */


/***/ }),

/***/ 6451:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4222);
/* harmony import */ var _dictionary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8636);




const COMPENDIUMS = [
  {
    title: "Backgrounds",
    setting: "entity-background-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/86797d176a398d9f2f05b75b2f54b6dd.jpg",
    auto: true,
    types: ["feat"],
  },
  {
    title: "Classes",
    setting: "entity-class-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/b778ff3ca3f18e5f75ad4b348615cab5.jpg",
    auto: true,
    types: ["class"],
  },
  {
    title: "Subclasses",
    setting: "entity-subclass-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/b778ff3ca3f18e5f75ad4b348615cab5.jpg",
    auto: true,
    types: ["subclass"],
  },
  {
    title: "Class Features",
    setting: "entity-feature-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/b778ff3ca3f18e5f75ad4b348615cab5.jpg",
    auto: true,
    types: ["feat", "weapon"],
  },
  {
    title: "Feats",
    setting: "entity-feat-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/a69ab5bf67b03308893b582dbef700e9.jpg",
    auto: true,
    types: ["feat"],
  },
  {
    title: "Items",
    setting: "entity-item-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/c06b79eae8ee234d1cea4688e117152b.jpg",
    auto: true,
    types: [
      "weapon",
      "equipment",
      "consumable",
      "tool",
      "loot",
      "feat",
      "container",
    ],
  },
  {
    title: "Monsters",
    setting: "entity-monster-compendium",
    type: "Actor",
    image: "https://media.dndbeyond.com/mega-menu/36ee49066331fc36e3b37147d123463a.jpg",
    auto: true,
    types: ["npc"],
  },
  {
    title: "Vehicles",
    setting: "entity-vehicle-compendium",
    type: "Actor",
    image: "https://media.dndbeyond.com/mega-menu/e95485e82519aa807da5011d42b8c9d3.jpg",
    auto: true,
    types: ["npc", "vehicle"],
  },
  {
    title: "Races",
    setting: "entity-race-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/bfe65858aaa13919ce3d86d938bcb05b.jpg",
    auto: true,
    types: ["race"],
  },
  {
    title: "Racial Traits",
    setting: "entity-trait-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/bfe65858aaa13919ce3d86d938bcb05b.jpg",
    auto: true,
    types: ["race", "feat"],
  },
  {
    title: "Spells",
    setting: "entity-spell-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/8894f93deeca83cdf0a6df3f36ffb52e.jpg",
    auto: true,
    types: ["spell"],
  },
  {
    title: "Tables",
    setting: "entity-table-compendium",
    type: "RollTable",
    image: "https://media.dndbeyond.com/mega-menu/f1a2343aee786f21827daf763c60d30f.jpg",
    auto: true,
    types: [],
  },
  {
    title: "Override",
    setting: "entity-override-compendium",
    type: "Item",
    image: "https://media.dndbeyond.com/mega-menu/e116466f43544117a34ed5f642c680f7.jpg",
    auto: true,
    types: [
      "weapon",
      "equipment",
      "consumable",
      "tool",
      "loot",
      "feat",
      "container",
      "spell",
      "feat",
      "class",
      "subclass",
    ],
  },
  {
    title: "Adventures",
    setting: "entity-adventure-compendium",
    type: "Adventure",
    image: "https://media.dndbeyond.com/mega-menu/4af3d4c196428ab0809cf71d332d540d.png",
    auto: false,
    types: [],
  },
  {
    title: "Journals",
    setting: "entity-journal-compendium",
    type: "JournalEntry",
    image: "https://media.dndbeyond.com/mega-menu/4af3d4c196428ab0809cf71d332d540d.png",
    auto: false,
    types: [],
  },
  {
    title: "Summons",
    setting: "entity-summons-compendium",
    type: "Actor",
    image: "https://media.dndbeyond.com/mega-menu/4af3d4c196428ab0809cf71d332d540d.png",
    auto: true,
    types: ["npc"],
  },
];

const SRD_COMPENDIUM_LOOKUPS = [
  { type: "inventory", name: "dnd5e.items" },
  { type: "spells", name: "dnd5e.spells" },
  { type: "features", name: "dnd5e.classfeatures" },
  { type: "races", name: "dnd5e.races" },
  { type: "traits", name: "dnd5e.races" },
  { type: "features", name: "dnd5e.classfeatures" },
  { type: "feat", name: "dnd5e.classfeatures" },
  { type: "feats", name: "dnd5e.classfeatures" },
  { type: "classes", name: "dnd5e.classes" },
  { type: "subclasses", name: "dnd5e.subclasses" },
  { type: "weapon", name: "dnd5e.items" },
  { type: "consumable", name: "dnd5e.items" },
  { type: "tool", name: "dnd5e.items" },
  { type: "loot", name: "dnd5e.items" },
  { type: "container", name: "dnd5e.items" },
  { type: "spell", name: "dnd5e.spells" },
  { type: "equipment", name: "dnd5e.items" },
  { type: "monsters", name: "dnd5e.monsters" },
  { type: "monsterfeatures", name: "dnd5e.monsterfeatures" },
  { type: "backgrounds", name: "dnd5e.backgrounds" },
];

const FOUNDRY_COMPENDIUM_MAP = {
  "classes": [
    "dnd5e.classes",
    "dnd-tashas-cauldron.tcoe-character-options",
  ],
  "spells": [
    "dnd5e.spells",
  ],
  "items": [
    "dnd5e.items",
    "dnd-tashas-cauldron.tcoe-magic-items",
  ],
};

const SUPPORTED_FLAG_GROUPS = [
  "advancedspelleffects",
  "arbron-summoner",
  "autoanimations",
  "automated-evocations",
  "automated-polymorpher",
  "boomingBladeChoice",
  "cf",
  "dae",
  "enhancedcombathud",
  "favtab",
  "forien-unidentified-items",
  "gm-notes",
  "gng",
  "greenFlameBladeChoice",
  "GritNGlory",
  "inventory-plus",
  "itemacro",
  "itemmacro",
  "levels-3d-preview",
  "maestro",
  "mess",
  "midi-qol",
  "obsidian",
  "siftoolkit",
  "spell-class-filter-for-5e",
  "tidy5e-sheet-kgar",
  "spellbook-assistant-manager",
  "tagger",
  "tidy5e-sheet",
];

const EFFECTS_IGNORE_FLAG_GROUPS = [
  "dae",
  "midi-qol",
  "itemacro",
  "itemmacro",
];

const GAME_FOLDER_LOOKUPS = [
  {
    type: "itemSpells",
    folder: "magic-item-spells",
    itemType: "spell",
  },
  {
    type: "magicItems",
    folder: "magic-items",
    itemType: "item",
  },
  {
    type: "spells",
    folder: "spell",
    itemType: "spell",
  },
  {
    type: "monsters",
    folder: "npc",
    itemType: "actor",
  },
];

const COMPENDIUM_REMOVE_FLAGS = [
  "flags.ddbimporter.overrideId",
  "flags.ddbimporter.ignoreItemImport",
  "flags.ddbimporter.retainResourceConsumption",
  "flags.ddbimporter.ignoreIcon",
];

const URLS = {
  BASE: "ddb.mrprimate.co.uk",
  PROXY: "https://proxy.ddb.mrprimate.co.uk",
  CORS: "https://images.ddb.mrprimate.co.uk/",
  DYNAMIC: "https://dynamic.ddb.mrprimate.co.uk",
};

const MUNCH_DEFAULTS = [
  { name: "munching-policy-update-existing", needed: true },
  { name: "munching-policy-use-srd", needed: false },
  { name: "munching-policy-use-inbuilt-icons", needed: true },
  { name: "munching-policy-use-srd-icons", needed: false },
  { name: "munching-policy-use-srd-monster-images", needed: false },
  { name: "munching-policy-download-images", needed: true },
  { name: "munching-policy-remote-images", needed: false },
  { name: "munching-policy-hide-description", needed: false },
  { name: "munching-policy-monster-items", needed: false },
  { name: "munching-policy-update-images", needed: false },
];

const FILTER_SECTIONS = ["classes", "race", "features", "actions", "inventory", "spells"];

const COMPANION_SPELLS = [
  "Summon Aberration",
  "Summon Beast",
  "Summon Celestial",
  "Summon Construct",
  "Summon Elemental",
  "Summon Fey",
  "Summon Fiend",
  "Summon Shadowspawn",
  "Summon Undead",
  "Summon Draconic Spirit",
  // "Spirit of Death",
];
const COMPANION_FEATURES = [
  "Steel Defender",
  "Artificer Infusions",
  "Summon Wildfire Spirit",
  // "Primal Companion",
  "Drake Companion",
  "Drake Companion: Summon",
];
const COMPANION_OPTIONS = {
  "Primal Companion": [
    "Beast of the Land",
    "Beast of the Sea",
    "Beast of the Sky",
  ],
};

const DISABLE_FOUNDRY_UPGRADE = {
  applyFeatures: false,
  addFeatures: false,
  promptAddFeatures: false,
};

// reference to the D&D Beyond popup
const POPUPS = {
  json: null,
  web: null,
};

const MODULE_ID = "ddb-importer";

function activeUpdate() {
  const tiers = _lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].calculateAccessMatrix */ .Z.calculateAccessMatrix(_lib_PatreonHelper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getPatreonTier */ .Z.getPatreonTier());
  const available = tiers.god || tiers.undying || tiers.experimentalMid;
  if (!available) return false;
  const dynamicSync = game.settings.get(MODULE_ID, "dynamic-sync");
  const updateUser = game.settings.get(MODULE_ID, "dynamic-sync-user");
  const gmSyncUser = game.user.isGM && game.user.id == updateUser;
  return dynamicSync && gmSyncUser;
}

const SETTINGS = {
  MODULE_ID: "ddb-importer",
  FLAG_NAME: "ddbimporter",
  MODULE_NAME: "D&D Beyond Importer",
  DICTIONARY: _dictionary_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z,
  COMPENDIUMS: COMPENDIUMS,
  SRD_COMPENDIUMS: SRD_COMPENDIUM_LOOKUPS,
  FOUNDRY_COMPENDIUM_MAP,
  EFFECTS_IGNORE_FLAG_GROUPS,
  SUPPORTED_FLAG_GROUPS,
  GAME_FOLDER_LOOKUPS,
  COMPENDIUM_REMOVE_FLAGS,
  ADVENTURE_FLAG: "isDDBAdventure",
  ADVENTURE_CSS: "ddbAdventure",
  COMPANIONS: {
    COMPANION_FEATURES,
    COMPANION_SPELLS,
    COMPANION_OPTIONS,
  },
  URLS,
  POPUPS,
  DISABLE_FOUNDRY_UPGRADE,
  FILTER_SECTIONS,
  MUNCH_DEFAULTS,
  DEFAULT_SETTINGS: {
    // these settigs are loaded during renderSidebarTab
    EARLY: {
      "log-level": {
        name: "ddb-importer.settings.log-level.name",
        hint: "ddb-importer.settings.log-level.hint",
        scope: "world",
        config: true,
        type: String,
        choices: {
          DEBUG: "DEBUG",
          INFO: "INFO",
          WARN: "WARN",
          ERR: "ERROR ",
          OFF: "OFF",
        },
        default: "INFO",
      },
      "show-munch-top": {
        name: "ddb-importer.settings.show-munch-top.name",
        hint: "ddb-importer.settings.show-munch-top.hint",
        scope: "world",
        config: true,
        type: Boolean,
        default: true,
      },
      "patreon-tier": {
        scope: "world",
        config: false,
        type: String,
        default: null,
      },
      "custom-proxy": {
        name: "ddb-importer.settings.custom-proxy.name",
        hint: "ddb-importer.settings.custom-proxy.hint",
        scope: "world",
        config: false,
        type: Boolean,
        default: false,
        requiresReload: true,
      },
      "encounter-muncher-enabled": {
        scope: "world",
        config: false,
        type: Boolean,
        default: true,
        requiresReload: true,
      },
      "developer-mode": {
        scope: "world",
        config: false,
        type: Boolean,
        default: false,
      },
      "add-ddb-languages": {
        name: "ddb-importer.settings.add-ddb-languages.name",
        hint: "ddb-importer.settings.add-ddb-languages.hint",
        scope: "world",
        config: true,
        type: Boolean,
        default: true,
      },
    },
    // ready settings
    READY: {
      // settings for settings management
      SETTINGS: {
        "auto-create-compendium": {
          type: Boolean,
          default: true,
        },
      },
      COMPENDIUMS: Object.fromEntries(
        COMPENDIUMS.map((comp) => [comp.setting, {
          name: comp.title,
          type: String,
          default: `DDB ${comp.title}`,
        }])
      ),
      // dir locations
      DIRECTORIES: {
        "image-upload-directory": {
          name: "ddb-importer.settings.image-upload-directory.name",
          hint: "ddb-importer.settings.image-upload-directory.hint",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
          default: "[data] ddb-images/characters",
        },
        "other-image-upload-directory": {
          name: "ddb-importer.settings.other-image-upload-directory.name",
          hint: "ddb-importer.settings.other-image-upload-directory.hint",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
          default: "[data] ddb-images/other",
        },
        "frame-image-upload-directory": {
          name: "ddb-importer.settings.frame-image-upload-directory.name",
          hint: "ddb-importer.settings.frame-image-upload-directory.hint",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
          default: "[data] ddb-images/frames",
        },
        "adventure-import-path": {
          name: "ddb-importer.settings.adventure-import-path.name",
          hint: "ddb-importer.settings.adventure-import-path.hint",
          default: "[data] adventures/import",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
        },
        "adventure-upload-path": {
          name: "ddb-importer.settings.adventure-upload-path.name",
          hint: "ddb-importer.settings.adventure-upload-path.hint",
          default: "[data] ddb-images/adventures",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
        },
        "adventure-misc-path": {
          name: "ddb-importer.settings.adventure-misc-path.name",
          hint: "ddb-importer.settings.adventure-misc-path.hint",
          default: "[data] ddb-images/adventures/misc",
          type: _lib_DirectoryPicker_js__WEBPACK_IMPORTED_MODULE_0__/* .DirectoryPicker.Directory */ .B.Directory,
        },
      },
      UI: {
        "monster-link-title": {
          name: "ddb-importer.settings.monster-link-title.name",
          hint: "ddb-importer.settings.monster-link-title.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "character-link-title": {
          name: "ddb-importer.settings.character-link-title.name",
          hint: "ddb-importer.settings.character-link-title.hint",
          config: true,
          type: Boolean,
          default: false,
        },
        "link-title-colour-white": {
          name: "ddb-importer.settings.link-title-colour-white.name",
          hint: "ddb-importer.settings.link-title-colour-white.hint",
          config: true,
          type: Boolean,
          default: false,
        },
        "show-munch-top": {
          name: "ddb-importer.settings.show-munch-top.name",
          hint: "ddb-importer.settings.show-munch-top.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "show-image-to-players": {
          name: "ddb-importer.settings.show-image-to-players.name",
          hint: "ddb-importer.settings.show-image-to-players.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "show-read-alouds-button": {
          name: "ddb-importer.settings.show-read-alouds-button.name",
          hint: "ddb-importer.settings.show-read-alouds-button.hint",
          config: true,
          type: Boolean,
          default: true,
        },
      },
      PERMISSIONS: {
        "restrict-to-trusted": {
          name: "ddb-importer.settings.restrict-to-trusted.name",
          hint: "ddb-importer.settings.restrict-to-trusted.hint",
          config: true,
          type: Boolean,
          default: false,
        },
        "allow-all-sync": {
          name: "ddb-importer.settings.allow-all-sync.name",
          hint: "ddb-importer.settings.allow-all-sync.hint",
          config: true,
          type: Boolean,
          default: false,
        },
      },
      PARSING: {
        "show-resource-chooser-default": {
          name: "ddb-importer.settings.show-resource-chooser-default.name",
          hint: "ddb-importer.settings.show-resource-chooser-default.hint",
          config: true,
          type: Boolean,
          default: false,
        },
        "use-full-source": {
          name: "ddb-importer.settings.use-full-source.name",
          hint: "ddb-importer.settings.use-full-source.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "use-damage-hints": {
          name: "ddb-importer.settings.use-damage-hints.name",
          hint: "ddb-importer.settings.use-damage-hints.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "add-damage-restrictions-to-hints": {
          name: "ddb-importer.settings.add-damage-restrictions-to-hints.name",
          hint: "ddb-importer.settings.add-damage-restrictions-to-hints.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "embed-macros": {
          name: "ddb-importer.settings.embed-macros.name",
          hint: "ddb-importer.settings.embed-macros.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "no-item-macros": {
          name: "ddb-importer.settings.no-item-macros.name",
          hint: "ddb-importer.settings.no-item-macros.hint",
          config: true,
          type: Boolean,
          default: false,
        },
        "add-description-to-chat": {
          name: "ddb-importer.settings.add-description-to-chat.name",
          hint: "ddb-importer.settings.add-description-to-chat.hint",
          type: Boolean,
          default: false,
        },
        "use-loose-srd-reference-matching": {
          name: "ddb-importer.settings.use-loose-srd-reference-matching.name",
          hint: "ddb-importer.settings.use-loose-srd-reference-matching.hint",
          config: true,
          type: Boolean,
          default: true,
        },
        "use-super-loose-srd-reference-matching": {
          // name: "ddb-importer.settings.use-super-loose-srd-reference-matching.name",
          // hint: "ddb-importer.settings.use-super-loose-srd-reference-matching.hint",
          config: false,
          type: Boolean,
          default: false,
        },
        "append-chris-premade-effect-description": {
          name: "ddb-importer.settings.append-chris-premade-effect-description.name",
          hint: "ddb-importer.settings.append-chris-premade-effect-description.hint",
          config: true,
          type: Boolean,
          default: false,
        }
      },
      // ????
      MISC: {
        "use-webp": {
          name: "ddb-importer.settings.use-webp.name",
          hint: "ddb-importer.settings.use-webp.hint",
          type: Boolean,
          default: false,
        },
        "webp-quality": {
          name: "ddb-importer.settings.webp-quality.name",
          hint: "ddb-importer.settings.webp-quality.hint",
          type: Number,
          default: 0.9,
        },
        "settings-call-muncher": {
          type: Boolean,
          default: false,
        },
        "update-check": {
          name: "ddb-importer.settings.update-check.name",
          config: true,
          type: Boolean,
          default: true,
        },
        "use-deep-file-paths": {
          name: "ddb-importer.settings.use-deep-file-paths.name",
          hint: "ddb-importer.settings.use-deep-file-paths.hint",
          type: Boolean,
          default: false,
          // requiresReload: true,
        },
      },
      // character settings
      CHARACTER: {
        IMPORT: {
          "character-update-policy-use-hp-max-for-rolled-hp": {
            type: Boolean,
            default: false,
          },
          "character-update-policy-create-companions": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "pact-spells-prepared": {
            type: Boolean,
            default: false,
          },
          "character-update-policy-add-character-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-add-item-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-add-spell-effects": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-existing": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-ignore-non-ddb-items": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-override": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-srd": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-name": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-hp": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-hit-die": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-class": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-feat": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-weapon": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-equipment": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-bio": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-xp": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-spell-use": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-languages": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-import-extras": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-inventory": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-currency": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-spell": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-image": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-ddb-spell-icons": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-ddb-generic-item-icons": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-ddb-item-icons": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-inbuilt-icons": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-srd-icons": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-full-description": {
            scope: "player",
            type: Boolean,
            default: true,
          },
          "character-update-policy-use-action-and-feature": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          // "character-update-policy-use-actions-as-features": {
          //   scope: "player",
          //   type: Boolean,
          //   default: true,
          // },
          "character-update-policy-dae-effect-copy": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-active-effect-copy": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-active-effect-character-copy": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-policy-use-chris-premades": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "character-update-include-versatile-features": {
            scope: "player",
            type: Boolean,
            default: false,
          },
        },
        SYNC: {
          "sync-policy-currency": {
            name: "ddb-importer.settings.sync-policy-currency.name",
            hint: "ddb-importer.settings.sync-policy-currency.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-hitpoints": {
            name: "ddb-importer.settings.sync-policy-hitpoints.name",
            hint: "ddb-importer.settings.sync-policy-hitpoints.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-hitdice": {
            name: "ddb-importer.settings.sync-policy-hitdice.name",
            hint: "ddb-importer.settings.sync-policy-hitdice.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-action-use": {
            name: "ddb-importer.settings.sync-policy-action-use.name",
            hint: "ddb-importer.settings.sync-policy-action-use.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-inspiration": {
            name: "ddb-importer.settings.sync-policy-inspiration.name",
            hint: "ddb-importer.settings.sync-policy-inspiration.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-condition": {
            name: "ddb-importer.settings.sync-policy-condition.name",
            hint: "ddb-importer.settings.sync-policy-condition.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-deathsaves": {
            name: "ddb-importer.settings.sync-policy-deathsaves.name",
            hint: "ddb-importer.settings.sync-policy-deathsaves.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-spells-prepared": {
            name: "ddb-importer.settings.sync-policy-spells-prepared.name",
            hint: "ddb-importer.settings.sync-policy-spells-prepared.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-spells-slots": {
            name: "ddb-importer.settings.sync-policy-spells-slots.name",
            hint: "ddb-importer.settings.sync-policy-spells-slots.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-spells-sync": {
            name: "ddb-importer.settings.sync-policy-spells-sync.name",
            hint: "ddb-importer.settings.sync-policy-spells-sync.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-equipment": {
            name: "ddb-importer.settings.sync-policy-equipment.name",
            hint: "ddb-importer.settings.sync-policy-equipment.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
          "sync-policy-xp": {
            name: "ddb-importer.settings.sync-policy-xp.name",
            hint: "ddb-importer.settings.sync-policy-xp.hint",
            scope: "player",
            type: Boolean,
            default: true,
          },
        },
        DYNAMIC_SYNC: {
          "dynamic-sync-policy-currency": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-hitpoints": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-hitdice": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-action-use": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-inspiration": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-condition": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-deathsaves": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-spells-prepared": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-spells-slots": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-spells-sync": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-equipment": {
            type: Boolean,
            default: true,
          },
          "dynamic-sync-policy-xp": {
            type: Boolean,
            default: true,
          },
        },
      },
      // muncher settings
      MUNCHER: {
        COMPENDIUM_FOLDERS: {
          "top-level-compendium-folder": {
            name: "ddb-importer.settings.top-level-compendium-folder.name",
            hint: "ddb-importer.settings.top-level-compendium-folder.hint",
            config: true,
            type: Boolean,
            default: true,
          },
          "munching-selection-compendium-folders-monster": {
            name: "ddb-importer.settings.munching-selection-compendium-folders-monster.name",
            hint: "ddb-importer.settings.munching-selection-compendium-folders-monster.hint",
            config: true,
            type: String,
            choices: {
              TYPE: "Creature type, e.g. Undead",
              CR: "Challenge Rating",
              ALPHA: "Alphabetical",
            },
            default: "TYPE",
          },
          "munching-selection-compendium-folders-spell": {
            name: "ddb-importer.settings.munching-selection-compendium-folders-spell.name",
            hint: "ddb-importer.settings.munching-selection-compendium-folders-spell.hint",
            config: true,
            type: String,
            choices: {
              SCHOOL: "School of Magic",
              LEVEL: "Level",
            },
            default: "SCHOOL",
          },
          "munching-selection-compendium-folders-item": {
            name: "ddb-importer.settings.munching-selection-compendium-folders-item.name",
            hint: "ddb-importer.settings.munching-selection-compendium-folders-item.hint",
            config: true,
            type: String,
            choices: {
              TYPE: "Item Type",
              RARITY: "Rarity",
            },
            default: "TYPE",
          },
        },
        ADVENTURE: {
          "adventure-policy-all-scenes": {
            type: Boolean,
            default: true,
          },
          "adventure-policy-all-actors-into-world": {
            type: Boolean,
            default: false,
          },
          "adventure-policy-journal-world-actors": {
            type: Boolean,
            default: false,
          },
          "adventure-policy-add-to-compendiums": {
            type: Boolean,
            default: false,
          },
        },
        MUNCH: {
          "munching-policy-update-existing": {
            type: Boolean,
            default: false,
          },
          "munching-policy-delete-during-update": {
            type: Boolean,
            default: false,
          },
          "munching-policy-use-srd": {
            scope: "player",
            type: Boolean,
            default: false,
          },
          "munching-policy-exclude-legacy": {
            type: Boolean,
            default: false,
          },
          "munching-policy-legacy-postfix": {
            type: Boolean,
            default: true,
          },
          "munching-policy-use-srd-icons": {
            name: "ddb-importer.settings.munching-policy-use-srd-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-srd-icons.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-inbuilt-icons": {
            name: "ddb-importer.settings.munching-policy-use-inbuilt-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-inbuilt-icons.hint",
            type: Boolean,
            default: true,
          },
          "munching-policy-use-ddb-item-icons": {
            name: "ddb-importer.settings.munching-policy-use-ddb-item-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-ddb-item-icons.hint",
            type: Boolean,
            default: true,
          },
          "munching-policy-use-ddb-spell-icons": {
            name: "ddb-importer.settings.munching-policy-use-ddb-spell-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-ddb-spell-icons.hint",
            type: Boolean,
            default: true,
          },
          "munching-policy-use-ddb-generic-item-icons": {
            name: "ddb-importer.settings.munching-policy-use-ddb-generic-item-icons.name",
            hint: "ddb-importer.settings.munching-policy-use-ddb-generic-item-icons.hint",
            type: Boolean,
            default: true,
          },
          "munching-policy-use-full-token-image": {
            name: "ddb-importer.settings.munching-policy-use-full-token-image.name",
            hint: "ddb-importer.settings.munching-policy-use-full-token-image.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-token-avatar-image": {
            name: "ddb-importer.settings.munching-policy-use-token-avatar-image.name",
            hint: "ddb-importer.settings.munching-policy-use-token-avatar-image.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-remote-images": {
            name: "ddb-importer.settings.munching-policy-remote-images.name",
            hint: "ddb-importer.settings.munching-policy-remote-images.hint",
            type: Boolean,
            default: true,
          },
          "munching-policy-add-effects": {
            name: "ddb-importer.settings.munching-policy-add-effects.name",
            hint: "ddb-importer.settings.munching-policy-add-effects.hint",
            type: Boolean,
            default: true,
          },
          "munching-policy-add-spell-effects": {
            type: Boolean,
            default: false,
          },
          "munching-policy-add-monster-effects": {
            type: Boolean,
            default: false,
          },
          "munching-policy-download-images": {
            name: "ddb-importer.settings.munching-policy-download-images.name",
            hint: "ddb-importer.settings.munching-policy-download-images.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-use-chris-premades": {
            type: Boolean,
            default: false,
          },
          "munching-policy-hide-description": {
            name: "ddb-importer.settings.munching-policy-hide-description.name",
            hint: "ddb-importer.settings.munching-policy-hide-description.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-hide-item-name": {
            name: "ddb-importer.settings.munching-policy-hide-item-name.name",
            hint: "ddb-importer.settings.munching-policy-hide-item-name.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-hide-description-choice": {
            name: "ddb-importer.settings.munching-policy-hide-description-choice.name",
            hint: "ddb-importer.settings.munching-policy-hide-description-choice.hint",
            type: String,
            choices: {
              NAME: "Monster's name e.g. Goblin",
              TYPE: "Monster's type e.g. Abomination",
              MONSTER: `The word "Monster"`,
              NPC: `The word "NPC"`,
            },
            default: "NAME",
          },
          "munching-policy-monster-items": {
            name: "ddb-importer.settings.munching-policy-monster-items.name",
            hint: "ddb-importer.settings.munching-policy-monster-items.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-homebrew": {
            name: "ddb-importer.settings.munching-policy-monster-homebrew.name",
            hint: "ddb-importer.settings.munching-policy-monster-homebrew.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-homebrew-only": {
            name: "ddb-importer.settings.munching-policy-monster-homebrew-only.name",
            hint: "ddb-importer.settings.munching-policy-monster-homebrew-only.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-tokenize": {
            type: Boolean,
            default: false,
          },
          "munching-policy-use-srd-monster-images": {
            type: Boolean,
            default: false,
          },
          "munching-policy-update-images": {
            name: "ddb-importer.settings.munching-policy-update-images.name",
            hint: "ddb-importer.settings.munching-policy-update-images.hint",
            type: Boolean,
            default: true,
          },
          "munching-policy-monster-exact-match": {
            name: "ddb-importer.settings.munching-policy-monster-match.name",
            hint: "ddb-importer.settings.munching-policy-monster-match.hint",
            type: Boolean,
            default: false,
          },
          "munching-policy-size-flat-scale": {
            type: Boolean,
            default: true,
          },
          "munching-policy-use-source-filter": {
            type: Boolean,
            default: false,
          },
          "munching-policy-muncher-sources": {
            type: Array,
            default: [],
          },
          "munching-policy-monster-use-item-ac": {
            type: Boolean,
            default: true,
          },
          "munching-policy-monster-retain-biography": {
            type: Boolean,
            default: false,
          },
          "munching-policy-monster-set-legendary-resource-bar": {
            type: Boolean,
            default: true,
          },
          "munching-policy-update-world-monster-update-images": {
            type: Boolean,
            default: true,
          },
          "munching-policy-update-world-monster-retain-biography": {
            type: Boolean,
            default: true,
          },
          "munching-policy-monster-strip-name": {
            type: Boolean,
            default: true,
          },
          "munching-policy-item-homebrew": {
            type: Boolean,
            default: false,
          },
          "munching-policy-item-homebrew-only": {
            type: Boolean,
            default: false,
          },
          "munching-policy-spell-homebrew": {
            type: Boolean,
            default: false,
          },
          "munching-policy-spell-homebrew-only": {
            type: Boolean,
            default: false,
          },
          "munching-policy-use-generic-items": {
            type: Boolean,
            default: false,
          }
        },
        ENCOUNTER: {
          "encounter-import-policy-create-scene": {
            type: Boolean,
            default: true,
          },
          "encounter-import-policy-existing-scene": {
            type: Boolean,
            default: false,
          },
          "encounter-import-policy-missing-characters": {
            type: Boolean,
            default: true,
          },
          "encounter-import-policy-missing-monsters": {
            type: Boolean,
            default: true,
          },
          "encounter-import-policy-create-journal": {
            type: Boolean,
            default: true,
          },
          "encounter-import-policy-roll-monster-initiative": {
            type: Boolean,
            default: false,
          },
          "encounter-import-policy-use-ddb-save": {
            type: Boolean,
            default: false,
          },
        },
      },
      DYNAMIC_SYNC: {
        "dynamic-sync": {
          type: Boolean,
          default: false,
          requiresReload: true,
        },
        "dynamic-sync-user": {
          type: String,
          default: "",
          requiresReload: true,
        },
      },
      PROXY: {
        "api-endpoint": {
          type: String,
          default: "http://localhost:3000",
          requiresReload: true,
        },
        "cors-endpoint": {
          type: String,
          default: URLS.CORS,
          requiresReload: true,
        },
        "dynamic-api-endpoint": {
          type: String,
          default: URLS.DYNAMIC,
          requiresReload: true,
        },
        "cors-encode": {
          type: Boolean,
          default: false,
        },
        "cors-strip-protocol": {
          type: Boolean,
          default: true,
        },
        "cors-path-prefix": {
          type: String,
          default: "ddb/",
        },
        "beta-key": {
          type: String,
          default: "",
        },
        "patreon-user": {
          type: String,
          default: null,
        },
        "cobalt-cookie": {
          name: "ddb-importer.settings.cobalt-cookie.name",
          hint: "ddb-importer.settings.cobalt-cookie.hint",
          type: String,
          default: "",
        },
        "cobalt-cookie-local": {
          name: "ddb-importer.settings.cobalt-cookie-local.name",
          hint: "ddb-importer.settings.cobalt-cookie-local.hint",
          type: Boolean,
          default: true,
        },
        "campaign-id": {
          name: "ddb-importer.settings.campaign-id.name",
          hint: "ddb-importer.settings.campaign-id.hint",
          type: String,
          default: "",
        },
      },
      // dev settings
      DEV: {
        "add-features-to-compendiums": {
          type: Boolean,
          default: false,
        },
        "update-add-features-to-compendiums": {
          type: Boolean,
          default: false,
        },
        "allow-scene-download": {
          type: Boolean,
          default: false,
        },
        "allow-third-party-scene-download": {
          type: Boolean,
          default: false,
        },
        "third-party-scenes-partial": {
          type: Boolean,
          default: false,
        },
        "third-party-scenes-notes-merged": {
          type: Boolean,
          default: true,
        },
        "allow-note-generation": {
          type: Boolean,
          default: false,
        },
        "debug-json": {
          scope: "player",
          type: Boolean,
          default: false,
        },
        "adventure-muncher-full-config": {
          type: Boolean,
          default: false,
        },
      },
    },
  },
  APPLY_GLOBAL_DEFAULTS(settings) {
    for (const [name, data] of Object.entries(settings)) {
      settings[name] = foundry.utils.mergeObject({ scope: "world", config: false }, data);
    }
    return settings;
  },
  GET_DEFAULT_SETTINGS(early = false) {
    const clone = foundry.utils.deepClone(SETTINGS.DEFAULT_SETTINGS);
    const defaultLocationSource = !early && typeof ForgeVTT !== "undefined" && ForgeVTT?.usingTheForge
      ? "[forgevtt]"
      : "[data]";

    for (const [name, data] of Object.entries(clone.READY.DIRECTORIES)) {
      clone.READY.DIRECTORIES[name].default = data.default.replace("[data]", defaultLocationSource);
    }
    let defaultSettings = early
      ? clone.EARLY
      : {
        ...clone.READY.DEV,
        ...clone.READY.SETTINGS,
        ...clone.READY.PROXY,
        ...clone.READY.COMPENDIUMS,
        ...clone.READY.DIRECTORIES,
        ...clone.READY.UI,
        ...clone.READY.PERMISSIONS,
        ...clone.READY.PARSING,
        ...clone.READY.MISC,
        ...clone.READY.CHARACTER.IMPORT,
        ...clone.READY.CHARACTER.SYNC,
        ...clone.READY.DYNAMIC_SYNC,
        ...clone.READY.CHARACTER.DYNAMIC_SYNC,
        ...clone.READY.MUNCHER.COMPENDIUM_FOLDERS,
        ...clone.READY.MUNCHER.ADVENTURE,
        ...clone.READY.MUNCHER.MUNCH,
        ...clone.READY.MUNCHER.ENCOUNTER,
      };

    return SETTINGS.APPLY_GLOBAL_DEFAULTS(defaultSettings);
  },
  STATUS: {
    activeUpdate,
  },
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SETTINGS);


/***/ }),

/***/ 846:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* binding */ isEqual)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXTERNAL MODULE: ./src/parser/DDBMonster.js + 1 modules
var DDBMonster = __webpack_require__(3433);
// EXTERNAL MODULE: ./src/dictionary.js
var dictionary = __webpack_require__(37);
;// CONCATENATED MODULE: ./src/parser/monster/abilities.js



//     "abilities": {
// "str": {
//   "value": 27,
//   "proficient": 0,
//   "min": 3,
//   "mod": 8,
//   "save": 8,
//   "prof": 0,
//   "saveBonus": 0,
//   "checkBonus": 0,
//   "dc": 23
// },
// "dex": {
//   "value": 14,
//   "proficient": 1,
//   "min": 3,
//   "mod": 2,
//   "save": 9,
//   "prof": 7,
//   "saveBonus": 0,
//   "checkBonus": 0,
//   "dc": 17
// },
/**
 * Retrieves character abilities, including proficiency on saving throws
 */
DDBMonster/* default.prototype._generateAbilities */.Z.prototype._generateAbilities = function _generateAbilities() {
  // go through every ability
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    const value = this.source.stats.find((stat) => stat.statId === ability.id).value || 0;
    const proficient = this.source.savingThrows.find((stat) => stat.statId === ability.id) ? 1 : 0;
    const proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
    const mod = CONFIG.DDB.statModifiers.find((s) => s.value == value).modifier;

    this.npc.system.abilities[ability.value]['value'] = value;
    this.npc.system.abilities[ability.value]['proficient'] = proficient;
    this.npc.system.abilities[ability.value]['mod'] = mod;

    if (proficient) {
      this.npc.system.abilities[ability.value]['prof'] = proficiencyBonus;
      this.npc.system.abilities[ability.value]['saveBonus'] = this.source.savingThrows.find((stat) => stat.statId === ability.id).bonusModifier || 0;
      this.npc.system.abilities[ability.value]['save'] = mod + proficiencyBonus + this.npc.system.abilities[ability.value]['saveBonus'];
    }

    this.npc.system.abilities[ability.value]['dc'] = mod + proficiencyBonus + 8;
  });

  this.abilities = this.npc.system.abilities;
};

// EXTERNAL MODULE: ./src/logger.js
var logger = __webpack_require__(5259);
// EXTERNAL MODULE: ./src/lib/DDBItemImporter.js
var DDBItemImporter = __webpack_require__(6968);
;// CONCATENATED MODULE: ./src/parser/monster/ac.js




DDBMonster/* default.prototype.BAD_AC_MONSTERS */.Z.prototype.BAD_AC_MONSTERS = [
  "arkhan the cruel"
];

DDBMonster/* default.prototype._generateAC */.Z.prototype._generateAC = async function _generateAC() {

  const ac = {
    "flat": this.source.armorClass,
    "calc": "",
    "formula": "",
    "label": this.source.armorClassDescription ? this.source.armorClassDescription.replace("(", "").replace(")", "") : "",
  };

  let flatAC = true;

  const stat = this.source.stats.find((stat) => stat.statId === 2).value || 10;
  const dexBonus = CONFIG.DDB.statModifiers.find((s) => s.value == stat).modifier;

  let acItems = [];

  const lowerDescription = this.source.armorClassDescription
    ? this.source.armorClassDescription.toLowerCase()
    : "";
  const descriptionItems = this.source.armorClassDescription
    ? lowerDescription.replace("(", "").replace(")", "")
      .split(";")[0]
      .split(",").map((item) => item.trim())
    : [];

  // arkhan the cruel has Armor Class 23 (obsidian flint dragon plate, shield)

  // archmage 12 (15 with mage armor)

  // Jarlaxle Baenre 24 (+3 leather armor, Suave Defense)
  // Suave Defense. While Jarlaxle is wearing light or no armor and wielding no shield, his AC includes his Charisma modifier.

  // Eternal flame guardian 17 (breastplate, shield; 15 while using a crossbow)

  let itemsToCheck = [];
  if (descriptionItems.length > 0) {
    descriptionItems.forEach((item) => {
      if (item == "natural" || item == "natural armor") {
        ac.calc = "natural";
        flatAC = false;

        if (lowerDescription.includes("shield")) ac.flat = parseInt(ac.flat) - 2;
        if (lowerDescription.includes("ring of protection")) ac.flat = parseInt(ac.flat) - 1;
        if (lowerDescription.includes("cloak of protection")) ac.flat = parseInt(ac.flat) - 1;
        if (lowerDescription.includes("+1") || lowerDescription.includes("+ 1")) ac.flat = parseInt(ac.flat) - 1;
        if (lowerDescription.includes("+2") || lowerDescription.includes("+ 2")) ac.flat = parseInt(ac.flat) - 2;
        if (lowerDescription.includes("+3") || lowerDescription.includes("+ 3")) ac.flat = parseInt(ac.flat) - 3;
      } else if (!item.includes("with mage armor")) {
        item = item.replace("leather armor", "leather").replace("hide armor", "hide").replace("plate mail", "plate");
        if (item.startsWith("+")) {
          const bonusRegex = /(\+\d+)(?:\s+)(.*)/;
          const matches = item.match(bonusRegex);
          if (matches) {
            item = `${matches[2]}, ${matches[1]}`;
          }
        }
        // const type = item.includes("ring") || item.includes("cloak") ? "trinket" : "equipment";
        const itemsToIgnore = this.addMonsterEffects ? ["suave defense"] : [];
        if (!itemsToIgnore.includes(item)) {
          itemsToCheck.push({ name: item, type: "equipment", flags: {}, system: { equipped: true } });
        }
      };
    });
  }

  logger/* default.debug */.Z.debug("Checking for items", itemsToCheck);
  const unAttunedItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(itemsToCheck, "inventory", { monsterMatch: true });
  const attunedItems = unAttunedItems.map((item) => {
    if (item.system.attunement === 1) item.system.attunement = 2;
    return item;
  });

  logger/* default.debug */.Z.debug("Found items", { unAttunedItems, attunedItems });
  const allItemsMatched = attunedItems.length > 0 && attunedItems.length == itemsToCheck.length;
  const badACMonster = this.BAD_AC_MONSTERS.includes(this.source.name.toLowerCase());

  if (allItemsMatched && this.useItemAC && ac.calc !== "natural" && !badACMonster) {
    ac.flat = null;
    ac.calc = "default";
    ac.formula = "";
    flatAC = false;
  } else if ((!this.useItemAC && ac.calc !== "natural") || attunedItems.length === 0) {
    // default monsters with no ac equipment to natural
    ac.calc = "natural";
    flatAC = false;
  }

  this.ac = {
    ac,
    flatAC,
    acItems,
    dexBonus,
    ddbItems: this.useItemAC ? attunedItems : [], // only add items if we are told too
    attunedItems,
    allItemsMatched,
    badACMonster,
  };

  logger/* default.debug */.Z.debug(`${this.source.name} ac calcs`, this.ac);
  this.npc.system.attributes.ac = ac;
  this.npc.flags.ddbimporter.flatAC = flatAC;
  if (this.useItemAC) this.items.push(...attunedItems);

};

;// CONCATENATED MODULE: ./src/parser/monster/conditions.js



DDBMonster/* default.prototype.getAdjustmentsConfig */.Z.prototype.getAdjustmentsConfig = function getAdjustmentsConfig(type) {
  const damageAdjustments = CONFIG.DDB.damageAdjustments;

  switch (type) {
    case "resistances":
      return damageAdjustments.filter((adj) => adj.type == 1);
    case "immunities":
      return damageAdjustments.filter((adj) => adj.type == 2);
    case "vulnerabilities":
      return damageAdjustments.filter((adj) => adj.type == 3);
    case "conditions":
      return CONFIG.DDB.conditions.map((condition) => {
        return {
          id: condition.definition.id,
          name: condition.definition.name,
          type: condition.definition.type,
          slug: condition.definition.slug,
        };
      });
    default:
      return null;
  }
};

DDBMonster/* default.prototype.getDamageAdjustments */.Z.prototype.getDamageAdjustments = function getDamageAdjustments(type) {
  const config = this.getAdjustmentsConfig(type);
  let values = new Set();
  let custom = [];
  let bypass = new Set();
  const midiQolInstalled = game.modules.get("midi-qol")?.active;

  this.source.damageAdjustments.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    if (!adjustment) return;
    const ddbValue = dictionary/* default.character.damageAdjustments.find */.Z.character.damageAdjustments.find((d) => d.id === adjustment.id);
    if (ddbValue?.foundryValues) {
      if (ddbValue.foundryValues.value.length > 0) ddbValue.foundryValues.value.forEach(values.add, values);
      if (ddbValue.foundryValues.bypass.length > 0) ddbValue.foundryValues.bypass.forEach(bypass.add, bypass);
      if (midiQolInstalled && ddbValue.midiValues) {
        values.add(ddbValue.midiValues);
      }
    } else {
      custom.push(adjustment.name);
    }

    if (midiQolInstalled) {
      if (adjustment.slug.toLowerCase().includes("bludgeoning-piercing-and-slashing-from-nonmagical")) values.add("physical");
      if (adjustment.slug.toLowerCase().includes("silvered")) values.add("silver");
      if (adjustment.slug.toLowerCase().includes("adamantine")) values.add("adamant");
      // if (adjustment.slug.toLowerCase().includes("magic")) values.add("magic");
      // if (adjustment.slug.toLowerCase().includes("nonmagical")) values.add("non-magic");
    }
  });

  const adjustments = {
    value: Array.from(values),
    bypasses: Array.from(bypass),
    custom: custom.join("; "),
  };

  return adjustments;
};

DDBMonster/* default.prototype._generateDamageImmunities */.Z.prototype._generateDamageImmunities = function _generateDamageImmunities() {
  this.npc.system.traits.di = this.getDamageAdjustments("immunities");
};

DDBMonster/* default.prototype._generateDamageResistances */.Z.prototype._generateDamageResistances = function _generateDamageResistances() {
  this.npc.system.traits.dr = this.getDamageAdjustments("resistances");
};

DDBMonster/* default.prototype._generateDamageVulnerabilities */.Z.prototype._generateDamageVulnerabilities = function _generateDamageVulnerabilities() {
  this.npc.system.traits.dv = this.getDamageAdjustments("vulnerabilities");
};

DDBMonster/* default.prototype._generateConditionImmunities */.Z.prototype._generateConditionImmunities = function _generateConditionImmunities() {
  const config = this.getAdjustmentsConfig("conditions");

  let values = new Set();
  let custom = [];

  this.source.conditionImmunities.forEach((adj) => {
    const adjustment = config.find((cadj) => adj === cadj.id);
    const valueAdjustment = dictionary/* default.conditions.find */.Z.conditions.find((condition) => condition.label.toLowerCase() == adjustment.name.toLowerCase());
    if (adjustment && valueAdjustment) {
      values.add(valueAdjustment.foundry);
    } else if (adjustment) {
      custom.push(adjustment.name);
    }
  });

  this.npc.system.traits.ci = {
    value: Array.from(values),
    custom: custom.join("; "),
  };

};

// EXTERNAL MODULE: ./src/settings.js
var src_settings = __webpack_require__(6451);
;// CONCATENATED MODULE: ./src/parser/monster/size.js
// "creatureSizes": [{
//   "id": 2,
//   "entityTypeId": 127108918,
//   "name": "Tiny",
//   "weightType": 1
// }, {


//   "traits": {
//     "size": "grg",


//     "sizeId": 7,






DDBMonster/* default.prototype.getSizeFromId */.Z.prototype.getSizeFromId = function getSizeFromId(sizeId) {
  const size = CONFIG.DDB.creatureSizes.find((s) => s.id == sizeId).name;
  const sizeData = dictionary/* default.sizes.find */.Z.sizes.find((s) => size == s.name);

  if (!sizeData) {
    logger/* default.warn */.Z.warn(`No size found for, using medium`, size);
    return { name: "Medium", value: "med", size: 1 };
  }
  return sizeData;
};

DDBMonster/* default.prototype._generateSize */.Z.prototype._generateSize = function _generateSize () {
  const sizeData = this.getSizeFromId(this.source.sizeId);
  const flatScale = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-size-flat-scale");
  const token = {
    scale: flatScale ? 1 : (sizeData.size >= 1 ? 1 : sizeData.size),
    value: flatScale ? sizeData.size : (sizeData.size >= 1 ? sizeData.size : 1),
  };

  this.npc.system.traits.size = sizeData.value;
  this.npc.prototypeToken.width = token.value;
  this.npc.prototypeToken.height = token.value;
  this.npc.prototypeToken.texture.scaleX = token.scale;
  this.npc.prototypeToken.texture.scaleY = token.scale;

};

;// CONCATENATED MODULE: ./src/parser/monster/type.js


//   "value": "",
//   "subtype": "",
//   "swarm": {
//     "isSwarm": false,
//     "size": ""
//   },
//   "custom": ""


DDBMonster/* default.prototype._generateType */.Z.prototype._generateType = function _generateType() {

  if (this.source.swarm) {
    // result.swarm.isSwarm = true;
    // result.swarm.size = getSizeFromId(monster.swarm.sizeId).value;
    this.npc.system.details.type.swarm = this.getSizeFromId(this.source.swarm.sizeId).value;
  }

  const type = CONFIG.DDB.monsterTypes.find((c) => this.source.typeId == c.id);
  if (!type) {
    this.npc.system.details.type.custom = "Unknown";
    this.typeName = "Unknown Monster";
  } else {
    this.typeName = type.name;
    const typeName = type.name.toLowerCase();

    if (CONFIG.DND5E.creatureTypes[typeName]) this.npc.system.details.type.value = typeName;
  }

  this.npc.system.details.type.subtype = CONFIG.DDB.monsterSubTypes
    .filter((c) => this.source.subTypes.includes(c.id))
    .map((c) => c.name)
    .join(", ");

};

// EXTERNAL MODULE: ./src/lib/utils.js
var utils = __webpack_require__(7669);
;// CONCATENATED MODULE: ./src/parser/monster/skills.js





// skills: [
//   { skillId: 5, value: 9, additionalBonus: null },
//   { skillId: 14, value: 9, additionalBonus: null }
// ],

// "skills": [{
//   "skillId": 7, # History
//   "value": 8,
//   "additionalBonus": null
// }, {
//   "skillId": 14, # Perception
//   "value": 6,
//   "additionalBonus": null
// }],

// "ste": {
//   "value": 1,
//   "ability": "dex",
//   "bonus": 0,
//   "mod": 2,
//   "passive": 19,
//   "prof": 7,
//   "total": 9
// },
DDBMonster/* default.prototype._generateSkills */.Z.prototype._generateSkills = function _generateSkills () {
  const proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
  const validSkills = dictionary/* default.character.skills.map */.Z.character.skills.map((skill) => skill.name);

  const keys = Object.keys(this.npc.system.skills);
  keys
    .filter((key) => validSkills.includes(key))
    .forEach((key) => {
      let skill = this.npc.system.skills[key];
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ab) => ab.value === skill.ability);
      const stat = this.source.stats.find((stat) => stat.statId === ability.id).value || 10;
      const mod = CONFIG.DDB.statModifiers.find((s) => s.value == stat).modifier;
      const lookupSkill = dictionary/* default.character.skills.find */.Z.character.skills.find((s) => s.name == key);
      const monsterSkill = this.source.skills.find((s) => s.skillId == lookupSkill.valueId);

      this.npc.system.skills[key].mod = mod;

      const calculatedScore = proficiencyBonus + mod;

      if (monsterSkill) {
        this.npc.system.skills[key].value = 1;
        this.npc.system.skills[key].prof = proficiencyBonus;
        this.npc.system.skills[key].bonus = monsterSkill.additionalBonus || 0;
      }

      this.npc.system.skills[key].total = calculatedScore;
      this.npc.system.skills[key].passive = 10 + calculatedScore;

      if (monsterSkill && monsterSkill.value != calculatedScore) {
        if (monsterSkill.value == calculatedScore + proficiencyBonus) {
          this.npc.system.skills[key].passive += proficiencyBonus;
          this.npc.system.skills[key].value = 2;
          this.npc.system.skills[key].total += proficiencyBonus;
          this.npc.system.skills[key].prof += proficiencyBonus;
          this.npc.system.skills[key].bonus = 0;
        } else if (monsterSkill.value > calculatedScore + proficiencyBonus) {
          this.npc.system.skills[key].passive += proficiencyBonus;
          this.npc.system.skills[key].value = 2;
          this.npc.system.skills[key].total += proficiencyBonus;
          this.npc.system.skills[key].prof += proficiencyBonus;
        }
      }

    });

  return this.npc.system.skills;
};


DDBMonster/* default.prototype._generateSkillsHTML */.Z.prototype._generateSkillsHTML = function _generateSkillsHTML () {
  const proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
  //  "skillsHtml": "History + 12, Perception + 10"
  const skillsHTML = utils/* default.stripHtml */.Z.stripHtml(this.source.skillsHtml).split(',');
  const skillsMaps = skillsHTML.filter((str) => str != '').map((str) => {
    const skillMatch = str.match(/(\w+\s*\w*\s*\w*)(?:\s*)([+-])(?:\s*)(\d+)/);
    let result = {};
    if (skillMatch) {
      result = {
        name: skillMatch[1].trim(),
        value: skillMatch[2] + skillMatch[3],
      };
    } else {
      logger/* default.error */.Z.error(`Skill Parsing failed for ${this.source.name}`);
      logger/* default.debug */.Z.debug(skillsHTML);
      logger/* default.debug */.Z.debug(str);
      logger/* default.debug */.Z.debug(skillMatch);
    }
    return result;
  });

  const keys = Object.keys(this.npc.system.skills);
  const validSkills = dictionary/* default.character.skills.map */.Z.character.skills.map((skill) => skill.name);
  keys
    .filter((key) => validSkills.includes(key))
    .forEach((key) => {
      let skill = this.npc.system.skills[key];
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ab) => ab.value === skill.ability);
      const stat = this.source.stats.find((stat) => stat.statId === ability.id).value || 10;
      const mod = CONFIG.DDB.statModifiers.find((s) => s.value == stat).modifier;
      const lookupSkill = dictionary/* default.character.skills.find */.Z.character.skills.find((s) => s.name == key);
      const monsterSkill = this.source.skills.find((s) => s.skillId == lookupSkill.valueId);

      this.npc.system.skills[key].mod = mod;

      if (monsterSkill) {
        this.npc.system.skills[key].value = 1;
        this.npc.system.skills[key].prof = proficiencyBonus;
        this.npc.system.skills[key].bonus = monsterSkill.additionalBonus || 0;
      }
      const calculatedScore = this.npc.system.skills[key].prof + mod + this.npc.system.skills[key].bonus;
      this.npc.system.skills[key].total = calculatedScore;
      this.npc.system.skills[key].passive = 10 + calculatedScore;

      const htmlSkill = skillsMaps.find((skl) => skl.name == lookupSkill.label);

      if (htmlSkill) {
        if (htmlSkill.value > calculatedScore) {
          this.npc.system.skills[key].passive += proficiencyBonus;
          this.npc.system.skills[key].value = 2;
          this.npc.system.skills[key].total += proficiencyBonus;
          this.npc.system.skills[key].prof += proficiencyBonus;
        }
      }

    });

  return this.npc.system.skills;
};

;// CONCATENATED MODULE: ./src/parser/monster/senses.js



DDBMonster/* default.prototype.getTextSenses */.Z.prototype.getTextSenses = function getTextSenses() {
  return this.source.sensesHtml;
};

//   "senses": [{
//   "id": 1,
//   "entityTypeId": 668550506,
//   "name": "Blindsight"
// }, {
//   "id": 2,
//   "entityTypeId": 668550506,
//   "name": "Darkvision"
// }, {
//   "id": 3,
//   "entityTypeId": 668550506,
//   "name": "Tremorsense"
// }, {
//   "id": 4,
//   "entityTypeId": 668550506,
//   "name": "Truesight"
// }, {
//   "id": 5,
//   "entityTypeId": 668550506,
//   "name": "Unknown"
// }],

DDBMonster/* default.prototype._generateTokenSenses */.Z.prototype._generateTokenSenses = function _generateTokenSenses() {
  const senseLookup = CONFIG.DDB.senses;

  this.source.senses.forEach((sense) => {
    const senseMatch = senseLookup.find((l) => l.id == sense.senseId);
    if (senseMatch && sense.notes) {
      const senseType = dictionary/* default.senseMap */.Z.senseMap()[senseMatch.name.toLowerCase()];
      const rangeMatch = sense.notes.trim().match(/^(\d+)/);
      const blindBeyondMatch = sense.notes.trim().match(/blind beyond this radius/i);
      const vision5eInstalled = game.modules.get("vision-5e")?.active ?? false;
      if (rangeMatch) {
        const value = parseInt(rangeMatch[1]);
        if (value > 0 && value > this.npc.prototypeToken.sight.range && foundry.utils.hasProperty(CONFIG.Canvas.visionModes, senseType)) {
          foundry.utils.setProperty(this.npc.prototypeToken.sight, "visionMode", senseType);
          foundry.utils.setProperty(this.npc.prototypeToken.sight, "range", value);
          this.npc.prototypeToken.sight = foundry.utils.mergeObject(this.npc.prototypeToken.sight, CONFIG.Canvas.visionModes[senseType].vision.defaults);
        }
        if (value > 0 && foundry.utils.hasProperty(dictionary/* default.detectionMap */.Z.detectionMap, senseMatch.name.toLowerCase())) {
          const detectionMode = {
            id: dictionary/* default.detectionMap */.Z.detectionMap[senseMatch.name.toLowerCase()],
            range: value,
            enabled: true,
          };
          // only add duplicate modes if they don't exist
          // don't add if vision 5e is installed, as it can handle these detection modes.
          if (!vision5eInstalled && !this.npc.prototypeToken.detectionModes.some((mode) => mode.id === detectionMode.id)) {
            this.npc.prototypeToken.detectionModes.push(detectionMode);
          }
        }
        // add these modes if supported by vision 5e
        if (vision5eInstalled && blindBeyondMatch) {
          this.npc.prototypeToken.detectionModes.push(
            {
              "id": "lightPerception",
              "range": value,
              "enabled": true
            }
          );
        }
      }
    }
  });
};


DDBMonster/* default.prototype._generateSenses */.Z.prototype._generateSenses = function _generateSenses() {
  let senses = {
    darkvision: 0,
    blindsight: 0,
    tremorsense: 0,
    truesight: 0,
    units: "ft",
    special: ""
  };
  const senseLookup = CONFIG.DDB.senses;

  this.source.senses.forEach((sense) => {
    const senseMatch = senseLookup.find((l) => l.id == sense.senseId);
    if (senseMatch && sense.notes && senseMatch.name.toLowerCase() in senses) {
      const rangeMatch = sense.notes.trim().match(/^(\d+)/);
      if (rangeMatch) {
        senses[senseMatch.name.toLowerCase()] = parseInt(rangeMatch[1]);
      } else {
        senses.special += `${senseMatch.name}: ${sense.notes}; `;
      }
    } else {
      senses.special += `${senseMatch.name}: ${sense.notes}; `;
    }
  });

  this.npc.system.attributes.senses = senses;

};

// "senses": [
//   {
//       "senseId": 1,
//       "notes": "60 ft."
//   },
//   {
//       "senseId": 2,
//       "notes": "120 ft."
//   }
// ],

// "senses": [{
//   "senseId": 1,
//   "notes": " 60 ft. (blind beyond this radius)"
// }],


;// CONCATENATED MODULE: ./src/parser/monster/environments.js


DDBMonster/* default.prototype._generateEnvironments */.Z.prototype._generateEnvironments = function _generateEnvironments() {
  this.npc.system.details.environment = this.source.environments.filter((env) =>
    CONFIG.DDB.environments.some((c) => env == c.id)
  ).map((env) => {
    return CONFIG.DDB.environments.find((c) => env == c.id).name;
  }).join(", ");
};

;// CONCATENATED MODULE: ./src/parser/monster/languages.js



//      "languages": {
//   "value": [
//     "common",
//     "draconic"
//   ],
//   "custom": ""
// },

DDBMonster/* default.prototype._generateLanguages */.Z.prototype._generateLanguages = function _generateLanguages () {
  const config = CONFIG.DDB.languages;

  let values = [];
  let custom = [];

  this.source.languages.forEach((lng) => {
    const language = config.find((cfg) => lng.languageId == cfg.id);
    const foundryLanguage = dictionary/* default.character.languages.find */.Z.character.languages.find((lang) => lang.name == language.name);
    if (foundryLanguage && lng.notes == '') {
      values.push(foundryLanguage.value);
    } else if (language) {
      const notes = (lng.notes !== '') ? ` ${lng.notes}` : "";
      custom.push(language.name + notes);
    }
  });

  if (this.source.languageNote && !this.source.languageNote.includes("--")) custom.push(this.source.languageNote);

  this.npc.system.traits.languages = {
    value: values,
    custom: custom.join("; "),
  };
};

;// CONCATENATED MODULE: ./src/parser/monster/hp.js


// "hp": {
//   "value": 367,
//   "min": 0,
//   "max": 367,
//   "temp": 0,
//   "tempmax": 0,
//   "formula": "21d20 + 147"
// },

// "hitPointDice": {
//   "diceCount": 21,
//   "diceValue": 20,
//   "diceMultiplier": 0,
//   "fixedValue": 147,
//   "diceString": "21d20 + 147"
// },

DDBMonster/* default.prototype._generateHitPoints */.Z.prototype._generateHitPoints = function _generateHitPoints () {
  this.npc.system.attributes.hp = {
    value: this.source.averageHitPoints - (this.removedHitPoints ?? 0),
    min: 0,
    max: this.source.averageHitPoints,
    temp: this.temporaryHitPoints ?? 0,
    tempmax: 0,
    formula: this.source.hitPointDice.diceString,
  };
};

;// CONCATENATED MODULE: ./src/parser/monster/movement.js


// "movements": [
//   {
//     "movementId": 1,
//     "speed": 40,
//     "notes": null
// },
// {
//     "movementId": 4,
//     "speed": 80,
//     "notes": null
// },
// {
//     "movementId": 5,
//     "speed": 40,
//     "notes": null
// }
// ],

// "speed": {
//   "value": "40 ft.",
//   "special": "Fly 80 ft., Swim 40 ft."
// },
DDBMonster/* default.prototype._generateMovement */.Z.prototype._generateMovement = function () {
  let special = [];

  this.npc.system.attributes.movement.units = "ft";

  this.source.movements.forEach((monsterMovement) => {
    const movement = CONFIG.DDB.movements.find((mv) => mv.id == monsterMovement.movementId);
    this.npc.system.attributes.movement[movement.name.toLowerCase()] = monsterMovement.speed;

    if (monsterMovement.notes && monsterMovement.notes.toLowerCase().includes('hover')) {
      this.npc.system.attributes.movement.hover = true;
    }

    if (monsterMovement.notes?.trim() !== "") {
      const specialMovement = `${monsterMovement.speed}ft ${movement.description} (${monsterMovement.notes})`;
      special.push(specialMovement);
    }
  });

  this.movement = {
    movement: this.npc.system.attributes.movement,
    special,
  };

};

;// CONCATENATED MODULE: ./src/parser/monster/source.js


DDBMonster/* default.prototype._generateSource */.Z.prototype._generateSource = function _generateSource() {
  const fullSource = game.settings.get("ddb-importer", "use-full-source");
  const sourceObject = CONFIG.DDB.sources.find((cnf) => cnf.id == this.source.sourceId);
  const sourceBook = (sourceObject)
    ? (fullSource) ? sourceObject.description : sourceObject.name
    : "Homebrew";
  this.npc.system.details.source = {
    book: sourceBook,
    page: this.source.sourcePageNumber,
    custom: "",
    license: "",
  };
};

;// CONCATENATED MODULE: ./src/parser/monster/features.js




// extracts various attacks and features (not spells)
// generates and extra descriptions found in these fields
// feature parsing is handled in a separate class, the DDBFeatureFactory
// that class breaks down the html into possible actions which it passes to the
// DDBFeature class which tries to parse the feature for details
DDBMonster/* default.prototype._generateFeatures */.Z.prototype._generateFeatures = async function () {

  await this.featureFactory.generateActions(this.source.actionsDescription, "action");

  if (this.source.hasLair && this.source.lairDescription != "") {
    await this.featureFactory.generateActions(this.source.lairDescription, "lair");
    this.npc.system.resources["lair"] = this.featureFactory.resources["lair"];
  }

  if (this.source.legendaryActionsDescription != "") {
    await this.featureFactory.generateActions(this.source.legendaryActionsDescription, "legendary");
    this.npc.system.resources["legact"] = this.featureFactory.resources["legendary"];
    if (game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "munching-policy-monster-set-legendary-resource-bar")) {
      this.npc.prototypeToken.bar2 = { attribute: "resources.legact" };
    }
  }

  if (this.source.specialTraitsDescription != "") {
    await this.featureFactory.generateActions(this.source.specialTraitsDescription, "special");
    this.npc.system.resources["legres"] = this.featureFactory.resources["resistance"];
  }

  await this.featureFactory.generateActions(this.source.reactionsDescription, "reaction");
  await this.featureFactory.generateActions(this.source.bonusActionsDescription, "bonus");
  await this.featureFactory.generateActions(this.source.mythicActionsDescription, "mythic");
  // special MCDM actions
  await this.featureFactory.generateActions(`${this.featureFactory.html.villain}`, "villain");

  this.items.push(
    ...this.featureFactory.actions,
    ...this.featureFactory.lair,
    ...this.featureFactory.legendary,
    ...this.featureFactory.special,
    ...this.featureFactory.reactions,
    ...this.featureFactory.bonus,
    ...this.featureFactory.mythic,
    ...this.featureFactory.villain,
  );

  // add any actor descriptions found in action blocks into the biography
  if (this.featureFactory.characterDescription.unexpected) {
    logger/* default.warn */.Z.warn(`Unexpected description for ${this.source.name}`, { description: this.featureFactory.characterDescription });
  }
  this.characterDescription += this.featureFactory.characterDescription.action;
  this.characterDescription += this.featureFactory.characterDescription.reaction;
  this.characterDescription += this.featureFactory.characterDescription.special;
  this.npc.system.details.biography.value += this.characterDescription;
};

// EXTERNAL MODULE: ./src/parser/monster/helpers.js
var helpers = __webpack_require__(5371);
// EXTERNAL MODULE: ./src/lib/CompendiumHelper.js
var CompendiumHelper = __webpack_require__(3893);
;// CONCATENATED MODULE: ./src/parser/monster/spells.js









DDBMonster/* default.prototype.getSpellcasting */.Z.prototype.getSpellcasting = function(text) {
  let spellcasting = "";
  const abilitySearch = /((?:spellcasting ability) (?:is|uses|using) (\w+)| (\w+)(?: as \w+ spellcasting ability))/;
  const match = text.match(abilitySearch);
  if (match) {
    const abilityMatch = match[2] || match[3];
    spellcasting = abilityMatch.toLowerCase().substr(0, 3);
  }
  return spellcasting;
};

DDBMonster/* default.prototype._generateSpellcasting */.Z.prototype._generateSpellcasting = function(text) {
  let spellcasting = this.getSpellcasting(text);
  this.spellcasting.spellcasting = spellcasting;
  this.npc.system.attributes.spellcasting = spellcasting;
};

DDBMonster/* default.prototype._generateSpellLevel */.Z.prototype._generateSpellLevel = function(text) {
  let spellLevel = 0;
  const levelSearch = /is (?:a|an) (\d+)(?:th|nd|rd|st)(?:-| )level spellcaster/;
  const match = text.match(levelSearch);
  if (match) {
    spellLevel = parseInt(match[1]);
  }
  this.spellcasting.spellLevel = spellLevel;
  this.npc.system.attributes.spellLevel = spellLevel;
  this.npc.system.details.spellLevel = spellLevel;
};

DDBMonster/* default.prototype._generateSpelldc */.Z.prototype._generateSpelldc = function(text) {
  let dc = 10;
  const dcSearch = "spell\\s+save\\s+DC\\s*(\\d+)(?:,|\\)|\\s)";
  const match = text.match(dcSearch);
  // console.log("")
  // console.log(match);
  if (match) {
    dc = parseInt(match[1]);
  }
  this.spellcasting.spelldc = dc;
  this.npc.system.attributes.spelldc = dc;
};

DDBMonster/* default.prototype._generateSpellAttackBonus */.Z.prototype._generateSpellAttackBonus = function(text) {
  let spellAttackBonus = 0;
  const dcSearch = "([+-]\\d+)\\s+to\\s+hit\\s+with\\s+spell\\s+attacks";
  const match = text.match(dcSearch);
  if (match) {
    const toHit = match[1];
    const proficiencyBonus = CONFIG.DDB.challengeRatings.find((cr) => cr.id == this.source.challengeRatingId).proficiencyBonus;
    const abilities = (0,helpers/* getAbilityMods */.T)(this.source);
    const castingAbility = this.getSpellcasting(text);
    spellAttackBonus = toHit - proficiencyBonus - abilities[castingAbility];
  }
  this.spellcasting.spellAttackBonus = spellAttackBonus;
};


DDBMonster/* default.prototype.parseOutInnateSpells */.Z.prototype.parseOutInnateSpells = function(text) {
  // handle innate style spells here
  // 3/day each: charm person (as 5th-level spell), color spray, detect thoughts, hold person (as 3rd-level spell)
  // console.log(text);
  const innateSearch = /^(\d+)\/(\w+)(?:\s+each)?:\s+(.*$)/;
  const innateMatch = text.match(innateSearch);
  // console.log(innateMatch);
  if (innateMatch) {
    const spellArray = innateMatch[3].split(",").map((spell) => spell.trim());
    spellArray.forEach((spell) => {
      this.spellList.innate.push({ name: spell, type: innateMatch[2], value: innateMatch[1], innate: this.spellList.innateMatch });
    });
  }

  // At will: dancing lights
  const atWillSearch = /^At (?:Will|will):\s+(.*$)/;
  const atWillMatch = text.match(atWillSearch);
  if (atWillMatch) {
    const spellArray = atWillMatch[1].split(",").map((spell) => spell.trim());
    spellArray.forEach((spell) => {
      if (this.spellList.innateMatch) {
        this.spellList.innate.push({ name: spell, type: "atwill", value: null, innate: this.spellList.innateMatch });
      } else {
        this.spellList.atwill.push(spell);
      }

    });
  }

  // last ditch attempt, mephits have some weird formating
  if (!innateMatch && !atWillMatch) {
    const mephitMatch = text.match(/(\d+)\/(\w+)(?:.*)?cast (.*),/);
    if (mephitMatch) {
      const spell = mephitMatch[3].trim();
      this.spellList.innate.push({ name: spell, type: mephitMatch[2], value: mephitMatch[1], innate: this.spellList.innateMatch });
    }
  }
};


// e.g. The archmage can cast disguise self and invisibility at will and has the following wizard spells prepared:
DDBMonster/* default.prototype.parseAdditionalAtWillSpells */.Z.prototype.parseAdditionalAtWillSpells = function(text) {
  const atWillSearch = /can cast (.*?) at will/;
  const atWillMatch = text.match(atWillSearch);
  let atWillSpells = [];
  if (atWillMatch) {
    atWillSpells = atWillMatch[1].replace(" and", ",").split(",").map((spell) => spell.split('(', 1)[0].trim());
  }

  this.spellList.atwill.push(...atWillSpells);
};


/**
 * First pass at breaking out spells to cast
 * @param text spell text block
 * @returns
 */
// eslint-disable-next-line complexity
DDBMonster/* default.prototype.parseOutSpells */.Z.prototype.parseOutSpells = function(text, { pactText = null } = {}) {
  // console.log(text);
  const spellLevelSearch = /^(Cantrip|\d)(?:st|th|nd|rd)?(?:\s*(?:Level|level))?(?:s)?\s+\((at will|at-will|\d)\s*(?:slot|slots)?\):\s+(.*$)/;
  const match = text.match(spellLevelSearch);

  const warlockLevelSearch = /^1st(\d)(?:st|th|nd|rd)\s+level\s+\((\d)\s+(\d)(?:st|th|nd|rd)?\s*(?:Level|level|-level)\s*(?:slot|slots)?\):\s+(.*$)/;
  const warlockMatch = text.match(warlockLevelSearch);

  const otherWarlockSearch = /^(\d)\s*(?:st|th|nd|rd)?\s*(?:Level|level|-level):\s+(.*$)/i;
  const otherWarlockMatch = text.match(otherWarlockSearch);

  const pactSearchRegex = /has\s(\w*)\s(\d)(?:st|th|nd|rd)\s*(?:level|-level)\s+spell\s+slot/i;
  const pactTextSlotsMatch = (otherWarlockMatch && pactText) ? pactText.match(pactSearchRegex) : null;

  // console.warn("info", {
  //   match,
  //   warlockMatch,
  //   otherWarlockMatch,
  //   pactTextSlotsMatch,
  //   expression: !match && (!warlockMatch || !pactTextSlotsMatch),
  //   expression2: !match && !warlockMatch && !pactTextSlotsMatch,
  //   warlock: !(warlockMatch || pactTextSlotsMatch),
  //   expression3: !match && !(warlockMatch || pactTextSlotsMatch),
  // });

  if (!match && !(warlockMatch || pactTextSlotsMatch)) {
    this.parseOutInnateSpells(text);
    return;
  }

  const spellLevel = (match) ? match[1] : 'pact';
  const slots = (match)
    ? match[2]
    : (warlockMatch)
      ? warlockMatch[2]
      : dictionary/* default.numbers.find */.Z.numbers.find((n) => n.natural === pactTextSlotsMatch[1])?.num;
  const spellMatches = (match)
    ? match[3]
    : (warlockMatch)
      ? warlockMatch[4]
      : otherWarlockMatch[2];

  // console.warn("Processing spells", {
  //   spellLevel,
  //   slots,
  //   spellMatches,
  // });
  if (Number.isInteger(parseInt(spellLevel)) && Number.isInteger(parseInt(slots))) {
    logger/* default.debug */.Z.debug("Spell level parsing");
    this.npc.system.spells[`spell${spellLevel}`]['value'] = parseInt(slots);
    this.npc.system.spells[`spell${spellLevel}`]['max'] = slots ?? "";
    this.npc.system.spells[`spell${spellLevel}`]['override'] = parseInt(slots) ?? null;
    const spellArray = spellMatches.split(",").map((spell) => spell.trim());
    this.spellList.class.push(...spellArray);
  } else if (spellLevel === 'pact' && Number.isInteger(parseInt(slots))) {
    logger/* default.debug */.Z.debug("Spell pact parsing");
    this.npc.system.spells[spellLevel]['value'] = parseInt(slots);
    this.npc.system.spells[spellLevel]['max'] = slots ?? "";
    this.npc.system.spells[spellLevel]['override'] = parseInt(slots) ?? null;
    this.npc.system.spells[spellLevel]['level'] = warlockMatch ? warlockMatch[3] : pactTextSlotsMatch[2];
    const spellArray = spellMatches.split(",").map((spell) => spell.trim());
    this.spellList.pact.push(...spellArray);
  } else if (["at will", "at-will"].includes(slots)) {
    logger/* default.debug */.Z.debug("Spell at-will parsing");
    // at will spells
    const spellArray = spellMatches.replace(/\*/g, '').split(",").map((spell) => spell.trim());
    this.spellList.atwill.push(...spellArray);
  }

};


function splitEdgeCase(spell) {
  let result = {
    name: spell,
    edge: null,
  };

  const splitSpell = spell.split("(");
  if (splitSpell.length > 1) {
    result.name = splitSpell[0].trim();
    result.edge = splitSpell[1].split(")")[0].trim();
  }

  return result;
}

DDBMonster/* default.prototype._generateSpellEdgeCases */.Z.prototype._generateSpellEdgeCases = function() {
  ["pact", "class", "atwill"].forEach((spellType) => {
    this.spellList[spellType].forEach((spellName) => {
      const edgeCheck = splitEdgeCase(`${spellName}`);
      if (edgeCheck.edge) {
        const edgeEntry = {
          name: edgeCheck.name,
          type: spellType,
          edge: edgeCheck.edge,
        };
        this.spellList.edgeCases.push(edgeEntry);
      }
      spellName = edgeCheck.name;
    });
  });

  // innate
  this.spellList.innate.forEach((spellMap) => {
    const edgeCheck = splitEdgeCase(spellMap.name);
    spellMap.name = edgeCheck.name;
    if (edgeCheck.edge) {
      const edgeEntry = {
        name: edgeCheck.name,
        type: "innate",
        edge: edgeCheck.edge,
      };
      this.spellList.edgeCases.push(edgeEntry);
    }
  });
};


// <p><em><strong>Innate Spellcasting.</strong></em> The oblex&rsquo;s innate spellcasting ability is Intelligence (spell save DC 15). It can innately cast the following spells, requiring no components:</p>\r\n<p>3/day each: charm person (as 5th-level spell), color spray, detect thoughts, hold person (as 3rd-level spell)</p>

DDBMonster/* default.prototype._generateSpells */.Z.prototype._generateSpells = function() {

  this.spellcasting = {
    spelldc: 10,
    spellcasting: "", // ability associated
    spellLevel: 0,
    spellAttackBonus: 0,
  };
  this.spellList = {
    class: [],
    pact: [],
    atwill: [],
    // {name: "", type: "srt/lng/day", value: 0} // check these values
    innate: [],
    edgeCases: [], // map { name: "", type: "", edge: "" }
    material: true,
    innateMatch: false,
  };

  // some monsters have poor spell formating, reported and might be able to remove in future
  // https://www.dndbeyond.com/forums/d-d-beyond-general/bugs-support/91228-sir-godfrey-gwilyms-spell-statblock
  const possibleSpellSources = this.source.specialTraitsDescription + this.source.actionsDescription;
  let specialTraits = possibleSpellSources.replace(/<br \/>/g, "</p><p>");

  const dom = utils/* default.htmlToDocumentFragment */.Z.htmlToDocumentFragment(specialTraits);

  dom.childNodes.forEach((node) => {
    if (node.textContent == "\n") {
      dom.removeChild(node);
    }
  });

  const pactText = specialTraits.includes("knows the following warlock spells")
    ? specialTraits
    : null;

  dom.childNodes.forEach((node) => {
    const spellText = utils/* default.nameString */.Z.nameString(node.textContent);
    const trimmedText = spellText.trim();

    const spellCastingRegEx = new RegExp(/^Spellcasting/);
    const innateSpellCastingRegEx = new RegExp(/^Innate Spellcasting/);
    const spellcastingMatch = spellCastingRegEx.test(trimmedText);
    const innateSpellcastingMatch = innateSpellCastingRegEx.test(trimmedText);

    if (spellcastingMatch || innateSpellcastingMatch) {
      this._generateSpellcasting(spellText);
      this._generateSpelldc(spellText);
      this._generateSpellLevel(spellText);
      this._generateSpellAttackBonus(spellText);
    }

    const noMaterialSearch = new RegExp(/no material component|no component/);
    const noMaterialMatch = noMaterialSearch.test(trimmedText);

    if (noMaterialMatch) {
      this.spellList.material = false;
    }

    // lets see if the spell block is innate
    if (innateSpellcastingMatch) {
      this.spellList.innateMatch = true;
    } else if (spellcastingMatch) {
      this.spellList.innateMatch = false;
    }

    this.parseOutSpells(spellText, { pactText });
    this.parseAdditionalAtWillSpells(spellText);
  });

  this._generateSpellEdgeCases();

  logger/* default.debug */.Z.debug("Parsed spell list", this.spellList);

  // this.spellcasting = {
  //   spelldc,
  //   spellcasting,
  //   spellLevel,
  //   spells,
  //   spellList,
  //   spellAttackBonus,
  // };

  this.npc.flags.monsterMunch['spellList'] = this.spellList;

};

/**
 *
 * @param {[items]} spells Array of Strings or items
 */
DDBMonster/* default.prototype.retrieveCompendiumSpells */.Z.prototype.retrieveCompendiumSpells = async function(spells) {
  const compendiumName = await game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "entity-spell-compendium");
  const compendiumItems = await CompendiumHelper/* default.retrieveMatchingCompendiumItems */.Z.retrieveMatchingCompendiumItems(spells, compendiumName);
  const itemData = compendiumItems.map((i) => {
    let spell = i.toObject();
    delete spell._id;
    return spell;
  });

  return itemData;
};

DDBMonster/* default.prototype.getSpellEdgeCase */.Z.prototype.getSpellEdgeCase = function(spell, type, spellList) {
  const edgeCases = spellList.edgeCases;
  const edgeCase = edgeCases.find((edge) => edge.name.toLowerCase() === spell.name.toLowerCase() && edge.type === type);

  if (edgeCase) {
    logger/* default.debug */.Z.debug(`Spell edge case for ${spell.name}`);
    switch (edgeCase.edge.toLowerCase()) {
      case "self":
      case "self only":
        spell.system.target.type = "self";
        logger/* default.debug */.Z.debug("spell target changed to self");
        break;
      // no default
    }
    spell.name = `${spell.name} (${edgeCase.edge})`;
    spell.system.description.value = `<p><b>Special Notes: ${edgeCase.edgeDescription ?? edgeCase.edge}.</b></p>\n\n${spell.system.description.value}`;

    if (spell.system.description.chat !== "") {
      spell.system.description.chat = `<p><b>Special Notes: ${edgeCase.edgeDescription ?? edgeCase.edge}.</b></p>\n\n${spell.system.description.chat}`;
    }

    const diceSearch = /(\d+)d(\d+)/;
    const diceMatch = edgeCase.edge.match(diceSearch);
    if (diceMatch) {
      if (spell.system.damage.parts[0] && spell.system.damage.parts[0][0]) {
        spell.system.damage.parts[0][0] = diceMatch[0];
      } else if (spell.system.damage.parts[0]) {
        spell.system.damage.parts[0] = [diceMatch[0]];
      } else {
        spell.system.damage.parts = [[diceMatch[0]]];
      }
    }

    // save DC 12
    const saveSearch = /save DC (\d+)/;
    const saveMatch = edgeCase.edge.match(saveSearch);
    if (saveMatch) {
      spell.system.save.dc = parseInt(saveMatch[1]);
      spell.system.save.scaling = "flat";
    }

  }

  // remove material components?
  if (!spellList.material) {
    spell.system.materials = {
      value: "",
      consumed: false,
      cost: 0,
      supply: 0
    };
    spell.system.properties = utils/* default.removeFromProperties */.Z.removeFromProperties(spell.system.properties, "material");
  }

};

// temporary spell hints
// these covercurrent gaps in teh parser, or blocks that are impossible to parse
DDBMonster/* default.prototype._addSpellHints */.Z.prototype._addSpellHints = function() {
  switch (this.name) {
    case "Faerie Dragon (Younger)":
    case " Faerie Dragon (Younger)": {
      this.spellList.innate = [
        { name: "Dancing Lights", type: "day", edge: "Red", value: 1, edgeDescription: "Available to Red, Orange, Yellow" },
        { name: "Mage Hand", type: "day", edge: "Red", value: 1, edgeDescription: "Available to Red, Orange, Yellow" },
        { name: "Minor Illusion", type: "day", edge: "Red", value: 1, edgeDescription: "Available to Red, Orange, Yellow" },
        { name: "Color Spray", type: "day", edge: "Orange", value: 1, edgeDescription: "Available to Orange, Yellow" },
        { name: "Mirror Image", type: "day", edge: "Yellow", value: 1, edgeDescription: "Available to Yellow" },
      ];
      this.spellList.edgeCases = foundry.utils.deepClone(this.spellList.innate).map((s) => {
        s.type = "innate";
        return s;
      });
      this.spellList.material = false;
      break;
    }
    case "Faerie Dragon (Older)":
    case " Faerie Dragon (Older)":
    case "Otto": {
      this.spellList.innate = [
        { name: "Dancing Lights", type: "day", edge: "Red", value: 1, edgeDescription: "Available to Red, Orange, Yellow, Green, Blue, Indigo and Violet" },
        { name: "Mage Hand", type: "day", edge: "Red", value: 1, edgeDescription: "Available to Red, Orange, Yellow, Green, Blue, Indigo and Violet" },
        { name: "Minor Illusion", type: "day", edge: "Red", value: 1, edgeDescription: "Available to Red, Orange, Yellow, Green, Blue, Indigo and Violet" },
        { name: "Color Spray", type: "day", edge: "Orange", value: 1, edgeDescription: "Available to Orange, Yellow, Green, Blue, Indigo and Violet" },
        { name: "Mirror Image", type: "day", edge: "Yellow", value: 1, edgeDescription: "Available to Yellow, Green, Blue, Indigo and Violet" },
        { name: "Suggestion", type: "day", edge: "Green", value: 1, edgeDescription: "Available to Green, Blue, Indigo and Violet" },
        { name: "Major Image", type: "day", edge: "Blue", value: 1, edgeDescription: "Available to Blue, Indigo and Violet" },
        { name: "Hallucinatory Terrain", type: "day", edge: "Indigo", value: 1, edgeDescription: "Available to Indigo and Violet" },
        { name: "Polymorph", type: "day", edge: "Violet", value: 1, edgeDescription: "Available to Indigo" },
      ];
      this.spellList.edgeCases = foundry.utils.deepClone(this.spellList.innate).map((s) => {
        s.type = "innate";
        return s;
      });
      this.spellList.material = false;
      break;
    }
    case "Fathomer": {
      //   this.spellList.pact = [
      //     { name: "armor of agathys", type: "" },
      //     { name: "expeditious retreat", type: "" },
      //     { name: "hex", type: "" },
      //     { name: "invisibility", type: "" },
      //     { name: "vampiric touch", type: "" },
      // ];
      this.spellList.atwill.push("Mage Armor");
      break;
    }
    case "Hypnos Magen": {
      this.spellList.atwill = ["Suggestion"];
      this.spellList.material = false;
      this.spellcasting.spellcasting = "int";
      break;
    }
    case "Puppeteer Parasite": {
      this.spellList.innate = [{ name: "Suggestion", type: "day", value: 1 }];
      this.spellList.material = false;
      break;
    }
    case "Sephek Kaltro": {
      this.spellList.innate = [{ name: "Misty Step", type: "day", value: 3 }];
      this.spellList.material = false;
      break;
    }
    // case "Priest of Osybus (Deathly)": {
    //   this.spellList.innate = [{ name: "Circle of Death", type: "charge", value: 1, recharge: "5" }];
    //   break;
    // }
    // no default
  }
};

DDBMonster/* default.prototype.addSpells */.Z.prototype.addSpells = async function() {
  this._addSpellHints();
  // check to see if we have munched flags to work on
  if (!this.spellList) return;

  logger/* default.debug */.Z.debug(`Adding Spell List`, this.spellList);
  const atWill = this.spellList.atwill;
  const klass = this.spellList.class;
  const innate = this.spellList.innate;
  const pact = this.spellList.pact;

  if (atWill.length !== 0) {
    logger/* default.debug */.Z.debug("Retrieving at Will spells:", atWill);
    let spells = await this.retrieveCompendiumSpells(atWill);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      if (spell.system.level == 0) {
        spell.system.preparation = {
          mode: "prepared",
          prepared: false,
        };
      } else {
        spell.system.preparation = {
          mode: "atwill",
          prepared: false,
        };
        spell.system.uses = {
          value: null,
          max: "",
          per: null,
          recovery: "",
        };
      }
      this.getSpellEdgeCase(spell, "atwill", this.spellList);
      return spell;
    });
    this.items.push(...spells);
  }

  // class spells
  if (klass.length !== 0) {
    logger/* default.debug */.Z.debug("Retrieving class spells:", klass);
    let spells = await this.retrieveCompendiumSpells(klass);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      spell.system.preparation = {
        mode: "prepared",
        prepared: true,
      };
      this.getSpellEdgeCase(spell, "class", this.spellList);
      return spell;
    });
    this.items.push(...spells);
  }

  // pact spells
  if (pact.length !== 0) {
    logger/* default.debug */.Z.debug("Retrieving pact spells:", pact);
    let spells = await this.retrieveCompendiumSpells(pact);
    spells = spells.filter((spell) => spell !== null).map((spell) => {
      spell.system.preparation = {
        mode: "pact",
        prepared: true,
      };
      this.getSpellEdgeCase(spell, "pact", this.spellList);
      return spell;
    });
    this.items.push(...spells);
  }

  // innate spells
  if (innate.length !== 0) {
    // innate:
    // {name: "", type: "srt/lng/day", value: 0}
    logger/* default.debug */.Z.debug("Retrieving innate spells:", innate);
    const spells = await this.retrieveCompendiumSpells(innate);
    const innateSpells = spells.filter((spell) => spell !== null)
      .map((spell) => {
        const spellInfo = innate.find((w) => w.name.toLowerCase() == spell.name.toLowerCase());
        if (spellInfo) {
          const isAtWill = foundry.utils.hasProperty(spellInfo, "innate") && !spellInfo.innate;
          if (spell.system.level == 0) {
            spell.system.preparation = {
              mode: "prepared",
              prepared: false,
            };
          } else {
            spell.system.preparation = {
              mode: isAtWill ? "atwill" : "innate",
              prepared: !isAtWill,
            };
          }
          if (isAtWill && spellInfo.type === "atwill") {
            spell.system.uses = {
              value: null,
              max: "",
              per: null,
              recovery: "",
            };
          } else {
            const perLookup = dictionary/* default.resets.find */.Z.resets.find((d) => d.id == spellInfo.type);
            const per = spellInfo.type === "atwill"
              ? null
              : (perLookup && perLookup.type)
                ? perLookup.type
                : "day";
            spell.system.uses = {
              value: parseInt(spellInfo.value),
              max: spellInfo.value ?? "",
              per,
              recovery: "",
            };
          }
          this.getSpellEdgeCase(spell, "innate", this.spellList);
        }
        return spell;
      });
    this.items.push(...innateSpells);
  }
};

// EXTERNAL MODULE: ./src/parser/DDBCharacter.js + 10 modules
var DDBCharacter = __webpack_require__(3163);
;// CONCATENATED MODULE: ./src/parser/character/index.js


// import { fixCharacterLevels } from "./filterModifiers.js";

DDBCharacter/* default.prototype._newPCSkeleton */.Z.prototype._newPCSkeleton = async function _newPCSkeleton() {
  const name = (this.source.ddb.character.name === "") ? "Hero With No Name" : this.source.ddb.character.name;

  this.raw.character = {
    system: utils/* default.getTemplate */.Z.getTemplate("character"),
    type: "character",
    effects: [],
    name: name,
    // items: [],  // modified to check inventory analysis on update
    flags: {
      ddbimporter: {
        compendium: false,
        acEffects: [],
        baseAC: 10,
        dndbeyond: {
          totalLevels: null,
          proficiencies: null,
          proficienciesIncludingEffects: null,
          roUrl: this.source.ddb.character.readonlyUrl,
          characterValues: this.source.ddb.character.characterValues,
          templateStrings: [],
          campaign: this.source.ddb.character.campaign,
        },
      },
    },
  };

  // generate a prototype token
  this._generateToken();

  return this.raw.character;
};

DDBCharacter/* default.prototype._generateCharacter */.Z.prototype._generateCharacter = async function _generateCharacter() {
  // *************************************
  // PARSING THE CHARACTER
  // **************************************
  //
  // ddb = fixCharacterLevels(ddb);

  // build skeleton this.raw.character
  await this._newPCSkeleton();

  this.totalLevels = this.source.ddb.character.classes.reduce((prev, cur) => prev + cur.level, 0);
  this.raw.character.flags.ddbimporter.dndbeyond.totalLevels = this.totalLevels;
  // prettier-ignore
  this.profBonus = Math.ceil(1 + (0.25 * this.totalLevels));
  this.raw.character.flags.ddbimporter.dndbeyond.profBonus = this.profBonus;
  this._generateProficiencies();

  // proficiency
  this.raw.character.system.attributes.prof = this.profBonus;

  // Get supported 5e feats and abilities
  // We do this first so we can check for them later
  this._setSpecialTraitFlags();

  this._generateAbilities();
  this._generateHitDice();
  this._generateDeathSaves();
  this._generateExhaustion();
  this.raw.character.system.attributes.inspiration = this.source.ddb.character.inspiration;
  this._generateArmorClass();
  this._generateHitPoints();
  this._generateInitiative();
  this._generateSpeed();
  this._generateSenses();
  this._generateSpellCasting();
  this._generateSpellDC();
  // resources
  this._generateResources();
  this._generateMaxPreparedSpells();
  this.raw.character.system.details.xp.value = this.source.ddb.character.currentXp;
  this._generateTrait();
  this._generateIdeal();
  this._generateFlaw();
  this._generateBond();
  this._generateAppearance();
  this._generateDescription();
  this._generateAlignment();
  this._generateBiography();
  this._generateSize();
  // immunities, resistances, vuls and condition immunities
  this._generateConditions();
  this._generateCurrency();
  await this._generateSkills();
  this._generateSpellSlots();

  // Extra global bonuses
  this._generateBonusAbilities();
  this._generateBonusSpellAttacks();
  this._generateBonusSpellDC();
  this._generateBonusWeaponAttacks();
};


;// CONCATENATED MODULE: ./src/parser/character/token.js




DDBCharacter/* default.prototype._generateToken */.Z.prototype._generateToken = function _generateToken() {
  try {
    // Default to the most basic token setup.
    // everything else can be handled by the user / Token Mold
    const existingData = foundry.utils.deepClone(this.currentActor.prototypeToken);
    let tokenData = foundry.utils.mergeObject(existingData, {
      actorLink: true,
      name: this.source.ddb.character.name,
      sight: {
        enabled: true,
        range: 0,
        visionMode: "basic",
      },
      detectionModes: [],
    });
    const senses = this.getSenses();
    // darkvision: 0,
    // blindsight: 0,
    // tremorsense: 0,
    // truesight: 0,

    for (const [key, value] of Object.entries(senses)) {
      if (value > 0 && value > tokenData.sight.range && foundry.utils.hasProperty(dictionary/* default.senseMap */.Z.senseMap(), key)) {
        const visionMode = dictionary/* default.senseMap */.Z.senseMap()[key];
        foundry.utils.setProperty(tokenData, "sight.visionMode", visionMode);
        foundry.utils.setProperty(tokenData, "sight.range", value);
        tokenData.sight = foundry.utils.mergeObject(tokenData.sight, CONFIG.Canvas.visionModes[visionMode].vision.defaults);
      }
      if (!game.modules.get("vision-5e")?.active
        && value > 0
        && foundry.utils.hasProperty(dictionary/* default.detectionMap */.Z.detectionMap, key)
      ) {
        const detectionMode = {
          id: dictionary/* default.detectionMap */.Z.detectionMap[key],
          range: value,
          enabled: true,
        };

        // only add duplicate modes if they don't exist
        if (!tokenData.detectionModes.some((mode) => mode.id === detectionMode.id)) {
          tokenData.detectionModes.push(detectionMode);
        }
      }
    }

    // devilsight? we set the vision mode back to basic
    const devilSight = senses.special.includes("You can see normally in darkness");
    if (devilSight && game.modules.get("vision-5e")?.active) {
      foundry.utils.setProperty(tokenData, "sight.visionMode", "devilsSight");
      tokenData.sight = foundry.utils.mergeObject(tokenData.sight, CONFIG.Canvas.visionModes.devilsSight.vision.defaults);
    } else if (devilSight) {
      foundry.utils.setProperty(tokenData, "sight.visionMode", "basic");
      tokenData.sight = foundry.utils.mergeObject(tokenData.sight, CONFIG.Canvas.visionModes.basic.vision.defaults);
    }

    this.raw.character.prototypeToken = tokenData;
  } catch (err) {
    logger/* default.error */.Z.error(err);
    logger/* default.error */.Z.error(err.stack);
    throw new Error("Please update your D&D 5e system to a newer version");
  }
};

// EXTERNAL MODULE: ./src/lib/DDBHelper.js
var DDBHelper = __webpack_require__(1438);
// EXTERNAL MODULE: ./src/effects/acEffects.js
var acEffects = __webpack_require__(2877);
// EXTERNAL MODULE: ./src/parser/character/filterModifiers.js
var filterModifiers = __webpack_require__(2187);
;// CONCATENATED MODULE: ./src/parser/character/ac.js







/**
 * This excludes shields
 */
DDBCharacter/* default.prototype.isArmored */.Z.prototype.isArmored = function isArmored() {
  return (
    this.source.ddb.character.inventory.filter(
      (item) => item.equipped && item.definition.armorClass && item.definition.armorTypeId !== 4
    ).length >= 1
  );
};

/**
 * This excludes shields
 */
DDBCharacter/* default.prototype.isUnArmored */.Z.prototype.isUnArmored = function isUnArmored() {
  return !this.isArmored();
};

function getMinimumBaseAC(modifiers) {
  let hasBaseArmor = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "minimum-base-armor" && modifier.isGranted
  );
  let baseAC = [];
  hasBaseArmor.forEach((base) => {
    baseAC.push(base.value);
  });
  return baseAC;
}

function getBaseArmor(ac, armorType, name = "Racial", formula = null) {
  return {
    definition: {
      name: `Base Armor - ${name}`,
      type: armorType,
      armorClass: ac,
      armorTypeId: dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((id) => id.name === armorType)?.id ?? 0,
      grantedModifiers: [],
      canAttune: false,
      filterType: "Armor",
      formula,
    },
    isAttuned: false,
  };
}

function getEquippedAC(equippedGear) {
  return equippedGear.reduce((prev, item) => {
    let ac = 0;
    // regular armor
    if (item.definition.armorClass) {
      ac += item.definition.armorClass;
    }

    // magical armor
    const itemEffects = item.equipped && item.definition.filterType !== "Armor";

    if (!itemEffects && item.definition.grantedModifiers) {
      let isAvailable = false;
      // does an item need attuning
      if (item.definition.canAttune === true) {
        if (item.isAttuned === true) {
          isAvailable = true;
        }
      } else {
        isAvailable = true;
      }

      if (isAvailable) {
        item.definition.grantedModifiers.forEach((modifier) => {
          if (modifier.type === "bonus" && modifier.subType === "armor-class") {
            // add this to armor AC
            ac += modifier.value;
          }
        });
      }
    }
    return prev + ac;
  }, 0);
}

// returns an array of ac values from provided array of modifiers
function getUnarmoredAC(modifiers, character) {
  let unarmoredACValues = [];
  let isUnarmored = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "unarmored-armor-class" && modifier.isGranted
  );
  // if (isUnarmored.length === 0) {
  //   // Some items will have an unarmoured bonus, but won't set a base, so if we are in this
  //   // situation, we add a default base ac
  //   isUnarmored.push({
  //     statId: 2,
  //     value: 0,
  //   });
  // }

  const ignoreDex = modifiers.some((modifier) => modifier.type === "ignore" && modifier.subType === "unarmored-dex-ac-bonus");

  const maxUnamoredDexMods = modifiers.filter(
    (modifier) => modifier.type === "set" && modifier.subType === "ac-max-dex-modifier" && modifier.isGranted
  ).map((mods) => mods.value);
  const maxUnamoredDexMod = ignoreDex ? 0 : Math.min(...maxUnamoredDexMods, 20);

  // console.log(`Max Dex: ${maxUnamoredDexMod}`);
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;

  isUnarmored.forEach((unarmored) => {
    let unarmoredACValue = 10;
    // +DEX
    // for a case of setting unarmoured ac, the dex won't detract
    unarmoredACValue += Math.max(0, Math.min(characterAbilities.dex.mod, maxUnamoredDexMod));
    // +WIS or +CON, if monk or barbarian, draconic resilience === null

    // console.log(`Unarmoured AC Value: ${unarmoredACValue}`);
    // console.log(unarmored);

    if (unarmored.statId !== null) {
      let ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === unarmored.statId);
      unarmoredACValue += characterAbilities[ability.value].mod;
    }
    if (unarmored.value) unarmoredACValue += unarmored.value;
    unarmoredACValues.push(unarmoredACValue);
  });
  // console.warn(unarmoredACValues);
  return unarmoredACValues;
}

function getDualWieldAC(data, modifiers) {
  const dualWielding = data.character.characterValues.some((cv) => {
    const equipped = data.character.inventory.some((item) => item.equipped && item.id == cv.valueId);
    const dualWielding = cv.typeId === 18;
    return equipped && dualWielding;
  });
  let dualWieldBonus = 0;

  if (dualWielding) {
    DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "bonus", "dual-wield-armor-class", ["", null], true).forEach((bonus) => {
      dualWieldBonus += bonus.value;
    });
  }

  return dualWieldBonus;
}

// To Do: Rework AC functions as class functions to help reduce complexity in calculation.
// eslint-disable-next-line complexity
function calculateACOptions(data, character, calculatedArmor) {
  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  let actorBase = 10 + characterAbilities.dex.mod;
  // generated AC effects
  let effects = [];
  // array to assemble possible AC values
  let armorClassValues = [];
  // max holders
  let maxType = "Unarmored";
  let maxValue = actorBase;
  let maxData = {};

  // the presumption here is that you can only wear a shield and a single
  // additional 'armor' piece. in DDB it's possible to equip multiple armor
  // types and it works out the best AC for you
  // we also want to handle unarmored for monks etc.
  // we might have multiple shields "equipped" by accident, so work out
  // the best one
  for (let armor = 0; armor < calculatedArmor.armors.length; armor++) {
    // getEquippedAC fetches any magical AC boost on the items passed
    let armorAC = getEquippedAC([calculatedArmor.armors[armor]]);
    let shieldMod = 0;

    if (calculatedArmor.shields.length !== 0) {
      let maxAC = armorAC;
      for (let shield = 0; shield < calculatedArmor.shields.length; shield++) {
        const combinedAC = getEquippedAC([calculatedArmor.armors[armor], calculatedArmor.shields[shield]]);
        if (combinedAC > maxAC) {
          shieldMod = combinedAC - armorAC;
          maxAC = combinedAC;
        }
      }
      armorAC = maxAC;
    }

    // Determine final AC values based on AC Type
    // Light Armor: AC + DEX
    // Medium Armor: AC + DEX (max 2)
    // Heavy Armor: AC only
    // Unarmored Defense: Dex mod already included in calculation

    // sometimes the type field can be blank in DDB
    if (!calculatedArmor.armors[armor].definition.type || calculatedArmor.armors[armor].definition.type === "") {
      const armourTypeId = calculatedArmor.armors[armor].definition.armorTypeId;
      const acType = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((a) => a.id === armourTypeId);
      if (acType) calculatedArmor.armors[armor].definition.type = acType.name;
    }
    let effect = null;
    let acValue;

    switch (calculatedArmor.armors[armor].definition.type) {
      case "Natural Armor": {
        let acCalc = 0;
        // Tortles don't get to add an unarmored ac bonus for their shell
        const ignoreUnarmouredACBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "ignore", { subType: "unarmored-dex-ac-bonus" });
        if (ignoreUnarmouredACBonus) {
          acCalc = armorAC + calculatedArmor.miscACBonus;
          // console.log(armorAC);
          // console.log(gearAC);
          // console.log(miscACBonus);
        } else {
          acCalc = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        }
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Natural",
          acCalc,
          shieldMod,
          calculatedArmor,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Natural): ${acValue.value}`, true);
        break;
      }
      case "Unarmored Defense": {
        const acCalc = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Unarmored Defense",
          acCalc,
          shieldMod,
          calculatedArmor,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Unarmored Defense): ${acValue.value}`);
        break;
      }
      case "Unarmored": {
        const base = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;
        const acCalc = base + characterAbilities.dex.mod;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + calculatedArmor.gearAC,
          type: "Unarmored",
          acCalc,
          shieldMod,
          calculatedArmor,
        };
        if (acCalc > actorBase) actorBase = acCalc - shieldMod;
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acValue.value} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name} (Unarmored): ${acValue.value}`, true, 15);
        break;
      }
      case "Heavy Armor": {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc,
          type: "Heavy",
          acCalc,
          shieldMod,
          calculatedArmor,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Heavy): ${acValue.value}`);
        break;
      }
      case "Medium Armor": {
        const maxDexMedium = Math.max(
          ...DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "set", { subType: "ac-max-dex-armored-modifier", includeExcludedEffects: true }).map((mod) => mod.value),
          // ...DDBHelper.filterBaseModifiers(data, "set", { subType: "ac-max-dex-modifier", includeExcludedEffects: true }).map((mod) => mod.value),
          2,
        );
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + Math.min(maxDexMedium, characterAbilities.dex.mod),
          type: "Medium",
          acCalc,
          shieldMod,
          calculatedArmor,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + {@abilities.dex.mod, ${maxDexMedium}}kl`, `AC ${calculatedArmor.armors[armor].definition.name} (Medium): ${acValue.value}`);
        break;
      }
      case "Light Armor": {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + characterAbilities.dex.mod,
          type: "Light",
          acCalc,
          shieldMod,
          calculatedArmor,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name} (Light): ${acValue.value}`);
        break;
      }
      case "Custom": {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc,
          type: "Custom",
          acCalc,
          shieldMod,
          formula: calculatedArmor.armors[armor].definition.formula,
          calculatedArmor,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(acValue.formula, `AC ${acValue.name}: ${acValue.value}`, false, 22);
        break;
      }
      default: {
        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;
        acValue = {
          name: calculatedArmor.armors[armor].definition.name,
          value: acCalc + characterAbilities.dex.mod,
          type: "Other",
          acCalc,
          shieldMod,
          calculatedArmor,
        };
        effect = (0,acEffects/* generateFixedACEffect */.LY)(`${acCalc} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name}: ${acValue.value}`, false, 22);
        break;
      }
    }
    if (effect) {
      effect.flags.ddbimporter.itemId = calculatedArmor.armors[armor].id;
      effect.flags.ddbimporter.entityTypeId = calculatedArmor.armors[armor].entityTypeId;
      effects.push(effect);
    }
    armorClassValues.push(acValue);
    if (acValue.value > maxValue || (acValue.value === "Unarmored Defense" && acValue.value >= maxValue)) {
      maxType = acValue.type;
      maxValue = acValue.value;
      maxData = foundry.utils.deepClone(acValue);
    }
  }

  logger/* default.debug */.Z.debug("Final AC Choices:", armorClassValues);
  return {
    actorBase,
    armorClassValues,
    effects,
    maxType,
    maxValue,
    maxData,
  };
}


DDBCharacter/* default.prototype._generateOverrideArmorClass */.Z.prototype._generateOverrideArmorClass = function _generateOverrideArmorClass(overRideAC) {
  const overRideEffect = (0,acEffects/* generateFixedACEffect */.LY)(overRideAC.value, `AC Override: ${overRideAC.value}`);

  this.raw.character.system.attributes.ac = {
    flat: overRideAC.value,
    calc: "flat",
    formula: "",
  };
  this.raw.character.effects = this.raw.character.effects.concat(overRideEffect);
  this.raw.character.flags.ddbimporter.acEffects = [overRideEffect];
  this.raw.character.flags.ddbimporter.baseAC = overRideAC.value;
  this.raw.character.flags.ddbimporter.autoAC = foundry.utils.deepClone(this.raw.character.system.attributes.ac);
  this.raw.character.flags.ddbimporter.overrideAC = {
    flat: overRideAC.value,
    calc: "flat",
    formula: "",
  };
  this.raw.character.flags.ddbimporter.fixedAC = {
    type: "Number",
    label: "Armor Class",
    value: overRideAC.value,
  };

  this.armor.results = {
    maxValue: overRideAC.value,
    maxType: "override",
    // actorBase,
    // armorClassValues,
    // effects,
    // maxType,
    // maxValue,
    // maxData,
  };
};


DDBCharacter/* default.prototype._generateArmorClass */.Z.prototype._generateArmorClass = function _generateArmorClass() {
  const overRideAC = this.source.ddb.character.characterValues.find((val) => val.typeId === 1);

  if (overRideAC) {
    this._generateOverrideArmorClass(overRideAC);
    return;
  }

  // get a list of equipped armor
  // we make a distinction so we can loop over armor
  this.armor.equippedArmor = this.source.ddb.character.inventory.filter(
    (item) => item.equipped && item.definition.filterType === "Armor"
  );
  this.armor.baseAC = 10;
  // for things like fighters fighting style
  this.armor.miscACBonus = 0;
  this.armor.bonusEffects = [];
  // lets get equipped gear
  this.armor.equippedGear = this.source.ddb.character.inventory.filter(
    (item) => item.equipped && item.definition.filterType !== "Armor"
  );
  this.armor.unarmoredACBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: "unarmored-armor-class" })
    .reduce((prev, cur) => prev + cur.value, 0);

  // lets get the AC for all our non-armored gear, we'll add this later
  this.armor.gearAC = getEquippedAC(this.armor.equippedGear);

  // While not wearing armor, lets see if we have special abilities
  if (this.isUnArmored()) {
    // unarmored abilities from Class/Race?
    const unarmoredSources = [
      DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb),
      this.source.ddb.character.modifiers.race,
      this.source.ddb.character.modifiers.feat,
      DDBHelper/* default.getActiveItemModifiers */.Z.getActiveItemModifiers(this.source.ddb, true),
    ];
    unarmoredSources.forEach((modifiers) => {
      const unarmoredAC = Math.max(getUnarmoredAC(modifiers, this.raw.character));
      if (unarmoredAC) {
        // we add this as an armored type so we can get magical item bonuses
        // e.g. ring of protection
        this.armor.equippedArmor.push(getBaseArmor(unarmoredAC, "Unarmored Defense", "Unarmored defense"));
      }
    });
  } else {
    // check for things like fighters fighting style defense
    const armorBonusSources = [DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb), this.source.ddb.character.modifiers.race].flat();
    const armoredBonuses = armorBonusSources.filter(
      (modifier) => modifier.subType === "armored-armor-class" && modifier.isGranted
    );
    const effect = (0,acEffects/* generateBonusACEffect */.AD)(armoredBonuses, "AC: Armored Misc Bonuses", "armored-armor-class", null);
    if (effect.changes.length > 0) this.armor.bonusEffects.push(effect);
  }

  // Generic AC bonuses like Warforfed Integrated Protection
  // item modifiers are loaded by ac calcs
  this.armor.miscModifiers = [
    DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb),
    DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "race"),
    DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "background"),
    DDBHelper/* default.getModifiers */.Z.getModifiers(this.source.ddb, "feat")
  ];

  DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(this.armor.miscModifiers, "bonus", "armor-class", ["", null], true).forEach((bonus) => {
    const component = DDBHelper/* default.findComponentByComponentId */.Z.findComponentByComponentId(this.source.ddb, bonus.componentId);
    const name = component ? component.definition?.name ?? component.name : `AC: Misc (${bonus.friendlySubtypeName})`;
    const effect = (0,acEffects/* generateBonusACEffect */.AD)([bonus], name, "armor-class", null);
    if (effect.changes.length > 0) this.armor.bonusEffects.push(effect);
  });

  this.source.ddb.character.characterValues.filter((value) =>
    (value.typeId === 3 || value.typeId === 2)
    && value.value !== 0
  ).forEach((custom) => {
    const name = custom.notes && custom.notes.trim() !== "" ? custom.notes : "AC: Custom Bonus";
    const effect = (0,acEffects/* generateBonusACEffect */.AD)([], name, "custom", null);
    if (custom.value && ((Number.isInteger(custom.value) && Number.parseInt(custom.value) !== 0) || `${custom.value}`.trim() !== "")) {
      effect.changes.push({
        key: "system.attributes.ac.bonus",
        value: `+ ${custom.value}`,
        mode: CONST.ACTIVE_EFFECT_MODES.ADD,
        priority: 30,
      });
    }
    if (effect.changes.length > 0) this.armor.bonusEffects.push(effect);
  });

  this.armor.miscACBonus += getDualWieldAC(this.source.ddb, this.armor.miscModifiers);

  // Each racial armor appears to be slightly different!
  // We care about Tortles and Lizardfolk here as they can use shields, but their
  // modifier is set differently
  switch (this.source.ddb.character.race.fullName) {
    case "Lizardfolk":
      this.armor.baseAC = Math.max(getUnarmoredAC(this.source.ddb.character.modifiers.race, this.raw.character));
      this.armor.equippedArmor.push(
        getBaseArmor(this.armor.baseAC, "Natural Armor", this.source.ddb.character.race.fullName)
      );
      break;
    case "Autognome":
    case "Thri-kreen":
    case "Loxodon":
    case "Tortle":
      this.armor.baseAC = Math.max(
        getMinimumBaseAC(this.source.ddb.character.modifiers.race, this.raw.character),
        getUnarmoredAC(this.source.ddb.character.modifiers.race, this.raw.character)
      );
      this.armor.equippedArmor.push(
        getBaseArmor(this.armor.baseAC, "Natural Armor", this.source.ddb.character.race.fullName)
      );
      break;
    default:
      this.armor.equippedArmor.push(getBaseArmor(this.armor.baseAC, "Unarmored"));
  }

  if (this.source.ddb.character.feats.some((f) => f.definition.name === "Dragon Hide")) {
    this.armor.baseAC = Math.max(getUnarmoredAC(this.source.ddb.character.modifiers.feat, this.raw.character));
    this.armor.equippedArmor.push(getBaseArmor(this.armor.baseAC, "Custom", "Dragon Hide", "13 + @abilities.dex.mod"));
  }

  this.armor.shields = this.armor.equippedArmor.filter((shield) => shield.definition.armorTypeId === 4);
  this.armor.armors = this.armor.equippedArmor.filter((armour) => armour.definition.armorTypeId !== 4);

  logger/* default.debug */.Z.debug("Calculated GearAC: " + this.armor.gearAC);
  logger/* default.debug */.Z.debug("Unarmoured AC Bonus:" + this.armor.unarmoredACBonus);
  logger/* default.debug */.Z.debug("Calculated MiscACBonus: " + this.armor.miscACBonus);
  logger/* default.debug */.Z.debug("Equipped AC Options: ", this.armor.equippedArmor);
  logger/* default.debug */.Z.debug("Armors: ", this.armor.armors);
  logger/* default.debug */.Z.debug("Shields: ", this.armor.shields);

  this.armor.calculatedArmor = {
    gearAC: this.armor.gearAC,
    unarmoredACBonus: this.armor.unarmoredACBonus,
    miscACBonus: this.armor.miscACBonus,
    equippedArmor: this.armor.equippedArmor,
    armors: this.armor.armors,
    shields: this.armor.shields,
  };
  this.armor.results = calculateACOptions(this.source.ddb, this.raw.character, this.armor.calculatedArmor);

  logger/* default.debug */.Z.debug("Calculated AC Results:", {
    calculatedArmor: this.armor.calculatedArmor,
    results: this.armor.results,
  });
  // get the max AC we can use from our various computed values
  // const max = Math.max(...results.armorClassValues.map((type) => type.value));

  //
  // DND5E.armorClasses = {
  //   "default": {


  // const draconic = ddb.classes[0].classFeatures[1].definition
  const classFeatures = (0,filterModifiers/* getAllClassFeatures */.PJ)(this.source.ddb.character);
  logger/* default.debug */.Z.debug("Class features", classFeatures);

  let calc = "default";
  let flat = null;
  let formula = "";
  if (classFeatures.some((kf) =>
    kf.className === "Sorcerer"
    && kf.subclassName === "Draconic Bloodline"
    && kf.name === "Draconic Resilience"
  )) calc = "draconic";

  if (classFeatures.some((kf) =>
    kf.className === "Monk"
    && kf.subclassName === null
    && kf.name === "Unarmored Defense"
  )) calc = "unarmoredMonk";

  if (classFeatures.some((kf) =>
    kf.className === "Barbarian"
    && kf.subclassName === null
    && kf.name === "Unarmored Defense"
  )) calc = "unarmoredBarb";

  if (this.armor.results.maxType === "Natural") {
    calc = "natural";
    flat = this.armor.results.actorBase;
  }

  if (this.armor.results.maxType === "Custom") {
    calc = "custom";
    formula = this.armor.results.maxData.formula;
  }

  logger/* default.debug */.Z.debug("AC Results:", {
    fixed: {
      type: "Number",
      label: "Armor Class",
      value: this.armor.results.maxValue,
    },
    base: this.armor.results.actorBase,
    effects: this.armor.results.effects,
    bonusEffects: this.armor.bonusEffects,
    override: {
      flat: this.armor.results.maxValue,
      calc: "flat",
      formula: "",
    },
    auto: {
      flat,
      calc,
      formula,
    },
  });

  // this.raw.character.system.attributes.ac = {
  //   flat,
  //   calc,
  //   formula,
  // };

  this.raw.character.effects = this.raw.character.effects.concat(this.armor.bonusEffects);

  this.raw.character.flags.ddbimporter.acEffects = this.armor.results.effects;
  this.raw.character.flags.ddbimporter.baseAC = this.armor.results.actorBase;
  this.raw.character.flags.ddbimporter.autoAC = foundry.utils.deepClone(this.raw.character.system.attributes.ac);
  this.raw.character.flags.ddbimporter.overrideAC = {
    flat: this.armor.results.maxValue,
    calc: "flat",
    formula: "",
  };

};

;// CONCATENATED MODULE: ./src/parser/character/specialTraits.js



DDBCharacter/* default.prototype._setSpecialTraitFlags */.Z.prototype._setSpecialTraitFlags = function _setSpecialTraitFlags() {
  this.raw.character.flags.dnd5e = {
    powerfulBuild: false,
    savageAttacks: false,
    elvenAccuracy: false,
    halflingLucky: false,
    initiativeAdv: false,
    initiativeAlert: false,
    jackOfAllTrades: false,
    weaponCriticalThreshold: 20,
    observantFeat: false,
    remarkableAthlete: false,
    reliableTalent: false,
    diamondSoul: false,
    meleeCriticalDamageDice: 0,
    wildMagic: false,
    spellSniper: false,
    tavernBrawlerFeat: false,
  };

  // powerful build/equine build
  this.raw.character.flags.dnd5e.powerfulBuild = this.source.ddb.character.race.racialTraits.some((trait) =>
    ["Equine Build", "Powerful Build, Hippo Build", "Little Giant"].includes(trait.definition.name)
  );

  // tavern brawler feat
  this.raw.character.flags.dnd5e.tavernBrawlerFeat = this.source.ddb.character.feats.some(
    (trait) => trait.definition.name === "Tavern Brawler"
  );

  // savage attacks
  const savageAttacks = this.source.ddb.character.race.racialTraits.some(
    (trait) => trait.definition.name === "Savage Attacks"
  );
  this.raw.character.flags.dnd5e.savageAttacks = savageAttacks;
  if (savageAttacks) this.raw.character.flags.dnd5e.meleeCriticalDamageDice += 1;

  // halfling lucky
  this.raw.character.flags.dnd5e.halflingLucky = this.source.ddb.character.race.racialTraits.some(
    (trait) => trait.definition.name === "Lucky"
  );

  // elven accuracy
  this.raw.character.flags.dnd5e.elvenAccuracy = this.source.ddb.character.feats.some(
    (feat) => feat.definition.name === "Elven Accuracy"
  );

  // alert feat
  this.raw.character.flags.dnd5e.initiativeAlert = this.source.ddb.character.feats.some(
    (feat) => feat.definition.name === "Alert"
  );

  // advantage on initiative
  this.raw.character.flags.dnd5e.initiativeAdv
    = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "advantage", { subType: "initiative" }).length > 0;

  // initiative half prof
  this.raw.character.flags.dnd5e.initiativeHalfProf
    = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "half-proficiency", { subType: "initiative" }).length > 0;

  // observant
  // we now just add this to the skill
  // this.raw.character.flags.dnd5e.observantFeat = this.source.ddb.character.feats.some(
  //   (feat) => feat.definition.name === "Observant"
  // );

  // weapon critical threshold
  // fighter improved crit
  // remarkable athlete
  this.source.ddb.character.classes.forEach((cls) => {
    if (cls.subclassDefinition) {
      // Improved Critical
      const improvedCritical = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Improved Critical" && cls.level >= feature.requiredLevel
      );
      const superiorCritical = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Superior Critical" && cls.level >= feature.requiredLevel
      );

      if (superiorCritical) {
        this.raw.character.flags.dnd5e.weaponCriticalThreshold = 18;
      } else if (improvedCritical && this.raw.character.flags.dnd5e.weaponCriticalThreshold > 19) {
        this.raw.character.flags.dnd5e.weaponCriticalThreshold = 19;
      }

      // Remarkable Athlete
      this.raw.character.flags.dnd5e.remarkableAthlete = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Remarkable Athlete" && cls.level >= feature.requiredLevel
      );

      // wild magic surge for 5e Helpers
      this.raw.character.flags.dnd5e.wildMagic = cls.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Wild Magic Surge" && cls.level >= feature.requiredLevel
      );
    }

    // Brutal Critical
    this.raw.character.flags.dnd5e.meleeCriticalDamageDice += cls.definition.classFeatures.filter(
      (feature) => feature.name === "Brutal Critical" && cls.level >= feature.requiredLevel
    ).length;

    // Diamond Soul
    this.raw.character.flags.dnd5e.diamondSoul = cls.definition.classFeatures.some(
      (feature) => feature.name === "Diamond Soul" && cls.level >= feature.requiredLevel
    );

    // Jack of All Trades
    this.raw.character.flags.dnd5e.jackOfAllTrades = cls.definition.classFeatures.some(
      (feature) => feature.name === "Jack of All Trades" && cls.level >= feature.requiredLevel
    );

    // Reliable Talent
    this.raw.character.flags.dnd5e.reliableTalent = cls.definition.classFeatures.some(
      (feature) => feature.name === "Reliable Talent" && cls.level >= feature.requiredLevel
    );
  });
};

;// CONCATENATED MODULE: ./src/parser/character/proficiencies.js





DDBCharacter/* default.prototype._isHalfProficiencyRoundedUp */.Z.prototype._isHalfProficiencyRoundedUp = function _isHalfProficiencyRoundedUp(skill, modifiers = null) {
  const longAbility = dictionary/* default.character.abilities.filter */.Z.character.abilities.filter((ability) => skill.ability === ability.value)
    .map((ability) => ability.long)[0];

  const roundUp = (modifiers)
    ? DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(modifiers, "half-proficiency-round-up", `${longAbility}-ability-checks`)
    : DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source?.ddb, "half-proficiency-round-up", { subType: `${longAbility}-ability-checks`, includeExcludedEffects: true });
  return Array.isArray(roundUp) && roundUp.length;
};

DDBCharacter/* default.prototype._getCustomProficiencies */.Z.prototype._getCustomProficiencies = function _getCustomProficiencies(type) {
  const profGroup = CONFIG.DDB.proficiencyGroups.find((group) => group.label == type);
  const profCharacterValues = this.source.ddb.character.characterValues.filter(
    (value) =>
      profGroup.customAdjustments.includes(parseInt(value.typeId))
      && profGroup.entityTypeIds.includes(parseInt(value.valueTypeId))
      && value.value == 3
  );
  const customProfs = CONFIG.DDB[type.toLowerCase()]
    .filter((prof) => profCharacterValues.some((value) => value.valueId == prof.id))
    .map((prof) => prof.name);

  return customProfs;
};

DDBCharacter/* default.prototype._getCoreProficiencies */.Z.prototype._getCoreProficiencies = function _getCoreProficiencies(includeItemEffects = false) {
  return DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "proficiency", { restriction: null, includeExcludedEffects: includeItemEffects })
    .map((proficiency) => {
      return { name: proficiency.friendlySubtypeName };
    });
};


DDBCharacter/* default.prototype.getArmorProficiencies */.Z.prototype.getArmorProficiencies = function getArmorProficiencies(proficiencyArray) {
  const values = new Set();
  const custom = [];

  // lookup the characters's proficiencies in the DICT
  const allProficiencies = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.type === "Armor" && foundry.utils.hasProperty(prof, "foundryValue"));

  const processArmorProficiency = (prof) => {
    if (prof.name === "Light Armor") values.add("lgt");
    else if (prof.name === "Medium Armor") values.add("med");
    else if (prof.name === "Heavy Armor") values.add("hvy");
    else if (prof.name === "Shields") values.add("shl");
    else {
      const entry = allProficiencies.find((p) => p.name === prof.name);
      if (entry) values.add(entry.foundryValue);
    }
  };
  proficiencyArray.forEach((prof) => {
    processArmorProficiency(prof);
  });

  if (this.source?.ddb) {
    // load custom proficiencies in characterValues
    const customProfs = this._getCustomProficiencies("Armor");
    customProfs.forEach((prof) => {
      processArmorProficiency({ name: prof });
    });
  }
  return {
    value: [...values],
    custom: [...new Set(custom)].join(";"),
  };
};

//
// DND5E.toolProficiencies = {
// "art": "Artisan's Tools",
// "disg": "Disguise Kit",
// "forg": "Forgery Kit",
// "game": "Gaming Set",
// "herb": "Herbalism Kit",
// "music": "Musical Instrument",
// "navg": "Navigator's Tools",
// "pois": "Poisoner's Kit",
// "thief": "Thieves' Tools",
// "vehicle": "Vehicle (Land or Water)"
// };
//
DDBCharacter/* default.prototype.getToolProficiencies */.Z.prototype.getToolProficiencies = function getToolProficiencies(proficiencyArray) {
  const results = {};

  // lookup the characters's proficiencies in the DICT
  const allToolProficiencies = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.type === "Tool");

  const mods = this.source?.ddb ? DDBHelper/* default.getAllModifiers */.Z.getAllModifiers(this.source.ddb, { includeExcludedEffects: true }) : [];

  const toolExpertise = this.source?.ddb
    ? this.source.ddb.character.classes.some((cls) =>
      cls.classFeatures.some((feature) => feature.definition.name === "Tool Expertise" && cls.level >= feature.definition.requiredLevel)
    )
      ? 2
      : 1
    : 1;

  proficiencyArray.forEach((prof) => {
    const profMatch = allToolProficiencies.find((allProf) => allProf.name === prof.name);
    if (profMatch && profMatch.baseTool) {
      const modifiers = mods
        .filter((modifier) => modifier.friendlySubtypeName === profMatch.name)
        .map((mod) => mod.type);

      const defaultAbility = profMatch?.ability ?? "dex";

      const halfProficiency = this.source?.ddb
        ? DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb).find(
          (modifier) =>
            // Jack of All trades/half-rounded down
            (modifier.type === "half-proficiency" && modifier.subType === "ability-checks")
            // e.g. champion for specific ability checks
            || this._isHalfProficiencyRoundedUp({ ability: defaultAbility })
        ) !== undefined
          ? 0.5
          : 0
        : 0;

      const proficient = modifiers.includes("expertise") ? 2 : modifiers.includes("proficiency") ? toolExpertise : halfProficiency;

      results[profMatch.baseTool] = {
        value: proficient,
        ability: profMatch.ability,
        bonuses: {
          check: ""
        }
      };
    }
  });

  return results;

  // tools no longer support easily modifiable custom tools, see
  // https://github.com/foundryvtt/dnd5e/issues/2372
  // use toolIds
  // if (this.source?.ddb) {
  //   // Custom proficiencies!
  //   this.source.ddb.character.customProficiencies.forEach((proficiency) => {
  //     if (proficiency.type === 2) {
  //       // type 2 is TOOL, 1 is SKILL, 3 is LANGUAGE
  //       processToolProficiency(proficiency);
  //     }
  //   });

  //   // load custom proficiencies in characterValues
  //   const customProfs = this._getCustomProficiencies("Tools");
  //   for (const prof of customProfs) {
  //     processToolProficiency({ name: prof });
  //   }
  // }

};

DDBCharacter/* default.prototype.getWeaponProficiencies */.Z.prototype.getWeaponProficiencies = function getWeaponProficiencies(proficiencyArray) {
  const values = new Set();
  const custom = [];

  // lookup the characters's proficiencies in the DICT
  const allProficiencies = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.type === "Weapon");

  const processWeaponProficiency = (prof) => {
    if (prof.name === "Simple Weapons") {
      values.add("sim");
    } else if (prof.name === "Martial Weapons") {
      values.add("mar");
    } else {
      const systemWeaponIds = CONFIG.DND5E.weaponIds;
      const dnd5eNameArray = prof.name.toLowerCase().split(",");
      const dnd5eName = dnd5eNameArray.length === 2
        ? `${dnd5eNameArray[1].trim()}${dnd5eNameArray[0].trim()}`
        : prof.name.toLowerCase();
      if (systemWeaponIds && dnd5eName in systemWeaponIds) {
        values.add(dnd5eName);
      } else if (allProficiencies.some((p) => p.name === prof.name) && !custom.includes(prof.name)) {
        custom.push(prof.name);
      }
    }
  };

  proficiencyArray.forEach((prof) => {
    processWeaponProficiency(prof);
  });

  if (this.source?.ddb) {
    // load custom proficiencies in characterValues
    const customProfs = this._getCustomProficiencies("Weapons");
    customProfs.forEach((prof) => {
      processWeaponProficiency({ name: prof });
    });
  }

  return {
    value: Array.from(values),
    custom: [...new Set(custom)].join("; "),
  };
};

DDBCharacter/* default.prototype.getLanguagesFromModifiers */.Z.prototype.getLanguagesFromModifiers = function getLanguagesFromModifiers(modifiers) {
  const languages = new Set();
  const custom = new Set();

  modifiers
    .filter((mod) => mod.type === "language")
    .forEach((language) => {
      const result = dictionary/* default.character.languages.find */.Z.character.languages.find((lang) => lang.name === language.friendlySubtypeName);
      if (result) {
        languages.add(result.value);
      } else if (language.friendlySubtypeName !== "Choose a Language") {
        custom.add(language.friendlySubtypeName);
      }
    });

  if (this.source?.ddb) {
    this.source.ddb.character.customProficiencies.forEach((proficiency) => {
      if (proficiency.type === 3) {
        // type 3 is LANGUAGE, 1 is SKILL, 2 is TOOL
        const result = dictionary/* default.character.languages.find */.Z.character.languages.find((lang) => lang.name === proficiency.name);
        if (result) {
          languages.add(result.value);
        } else {
          custom.add(proficiency.name);
        }
      }
    });

    // load custom proficiencies in characterValues
    const customProfs = this._getCustomProficiencies("Languages");
    for (const prof of customProfs) {
      const result = dictionary/* default.character.languages.find */.Z.character.languages.find((lang) => lang.name === prof);
      if (result) {
        languages.add(result.value);
      } else {
        custom.add(prof);
      }
    }
  }

  return {
    value: Array.from(languages),
    custom: Array.from(custom).map((entry) => utils/* default.capitalize */.Z.capitalize(entry)).join(";"),
  };
};

DDBCharacter/* default.prototype._generateLanguages */.Z.prototype._generateLanguages = function _generateLanguages() {
  const modifiers = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "language");
  this.raw.character.system.traits.languages = this.getLanguagesFromModifiers(modifiers);
};

DDBCharacter/* default.prototype._generateProficiencies */.Z.prototype._generateProficiencies = function _generateProficiencies() {
  const customProficiencies = [
    ...this._getCustomProficiencies("Armor"),
    ...this._getCustomProficiencies("Tools"),
    ...this._getCustomProficiencies("Weapons"),
    ...this._getCustomProficiencies("Languages"),
  ].map((proficiency) => {
    return { name: proficiency };
  });

  this.proficiencies = this._getCoreProficiencies(false).concat(customProficiencies);
  this.proficienciesIncludingEffects = this._getCoreProficiencies(true).concat(customProficiencies);

  this.raw.character.flags.ddbimporter.dndbeyond.proficiencies = this.proficiencies;
  this.raw.character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects = this.proficienciesIncludingEffects;

  this.raw.character.system.traits.weaponProf = this.getWeaponProficiencies(this.proficiencies);
  this.raw.character.system.traits.armorProf = this.getArmorProficiencies(this.proficiencies);
  this.raw.character.system.tools = this.getToolProficiencies(this.proficiencies);
  this._generateLanguages();
};

// EXTERNAL MODULE: ./src/effects/effects.js + 1 modules
var effects_effects = __webpack_require__(5751);
;// CONCATENATED MODULE: ./src/parser/character/skills.js






DDBCharacter/* default.prototype.getSkillProficiency */.Z.prototype.getSkillProficiency = function getSkillProficiency (skill, modifiers = null) {
  if (!modifiers) {
    modifiers = DDBHelper/* default.getAllModifiers */.Z.getAllModifiers(this.source.ddb, { includeExcludedEffects: true });
  }

  const skillMatches = modifiers
    .filter((modifier) => modifier.friendlySubtypeName === skill.label)
    .map((mod) => mod.type);

  const halfProficiency = modifiers.find(
    (modifier) =>
    // Jack of All trades/half-rounded down
      (modifier.type === "half-proficiency" && modifier.subType === "ability-checks")
        // e.g. champion for specific ability checks
        || this._isHalfProficiencyRoundedUp(skill, modifiers)
  ) !== undefined
    ? 0.5
    : 0;

  const proficient = skillMatches.includes("expertise") ? 2 : skillMatches.includes("proficiency") ? 1 : halfProficiency;

  return proficient;
};

DDBCharacter/* default.prototype.getCustomSkillProficiency */.Z.prototype.getCustomSkillProficiency = function getCustomSkillProficiency(skill) {
  // Overwrite the proficient value with any custom set over rides
  if (this.source.ddb.character.characterValues) {
    const customProficiency = this.source.ddb.character.characterValues.find(
      (value) => value.typeId === 26 && value.valueId == skill.valueId && value.value
    );
    if (customProficiency) {
      return dictionary/* default.character.customSkillProficiencies.find */.Z.character.customSkillProficiencies.find((prof) => prof.value === customProficiency.value)
        .proficient;
    }
  }
  return undefined;
};

DDBCharacter/* default.prototype.getCustomSkillAbility */.Z.prototype.getCustomSkillAbility = function getCustomSkillAbility(skill) {
  // Overwrite the proficient value with any custom set over rides
  let mod;
  if (this.source.ddb.character.characterValues) {
    const customAbility = this.source.ddb.character.characterValues.find(
      (value) => value.typeId === 27 && value.valueId == skill.valueId
    );
    if (customAbility) {
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id == customAbility.value);
      if (ability)
        mod = ability.value;
    }
  }
  return mod;
};

DDBCharacter/* default.prototype.getCustomSkillBonus */.Z.prototype.getCustomSkillBonus = function getCustomSkillBonus(skill) {
  // Get any custom skill bonuses
  if (this.source.ddb.character.characterValues) {
    const customBonus = this.source.ddb.character.characterValues.filter(
      (value) => (value.typeId == 24 || value.typeId == 25) && value.valueId == skill.valueId
    ).reduce((total, bonus) => {
      return total + bonus.value;
    }, 0);

    if (customBonus) {
      return customBonus;
    }
  }
  return 0;
};

DDBCharacter/* default.prototype._setSpecialSkills */.Z.prototype._setSpecialSkills = function _setSpecialSkills() {
  this.source.ddb.character.classes.forEach((klass) => {
    if (klass.subclassDefinition) {
      const silverTongue = klass.subclassDefinition.classFeatures.some(
        (feature) => feature.name === "Silver Tongue" && klass.level >= feature.requiredLevel
      );
      if (silverTongue) {
        this.raw.character.system.skills["per"].roll.min = 10;
        this.raw.character.system.skills["dec"].roll.min = 10;
      }
    }
  });
};

DDBCharacter/* default.prototype._generateCustomSkills */.Z.prototype._generateCustomSkills = async function _generateCustomSkills() {
  if (!game.modules.get("dnd5e-custom-skills")?.active) return;
  const version = game.modules.get("dnd5e-custom-skills")?.version;
  const newEnough = foundry.utils.isNewerVersion(version, "1.1.2");
  if (!newEnough) return;

  const customSkillData = this.source.ddb.character.customProficiencies
    .filter((prof) => prof.type === 1 && Number.isInteger(prof.statId))
    .map((prof) => {
      const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id == prof.statId);
      return {
        ability: ability.value,
        label: prof.name,
        proficiencyLevel: prof.proficiencyLevel,
        miscBonus: prof.miscBonus,
        magicBonus: prof.magicBonus,
        override: prof.override,
      };
    });

  const skillData = {};

  for (let i = 0; i < customSkillData.length; i++) {
    skillData[i] = customSkillData[i];
  }

  const customSkills = await window.dnd5eCustomSkills("add", { skills: skillData });

  for (const [key, value] of Object.entries(customSkills.skills.list)) {
    if (value.applied || value.applied === 1) {
      const customSkillMatch = customSkillData.find((customSkill) => customSkill.label === value.label);
      if (customSkillMatch) {
        logger/* default.debug */.Z.debug(`Adding custom skill ${value.label}`, { key, value, customSkillMatch });
        const prof = dictionary/* default.character.customSkillProficiencies.find */.Z.character.customSkillProficiencies.find((proficiency) =>
          proficiency.value === customSkillMatch.proficiencyLevel
        ).proficient;
        const miscBonus = customSkillMatch.miscBonus && customSkillMatch.miscBonus !== "" && customSkillMatch.miscBonus !== 0
          ? `+ ${customSkillMatch.miscBonus}`
          : "";
        const magicBonus = customSkillMatch.magicBonus && customSkillMatch.magicBonus !== "" && customSkillMatch.magicBonus !== 0
          ? ` + ${customSkillMatch.magicBonus}`
          : "";
        if (customSkillMatch) {
          const checkBonus = (miscBonus + magicBonus).trim();
          this.raw.character.system.skills[key] = {
            ability: value.ability,
            value: prof,
            bonuses: {
              "check": `${parseInt(checkBonus) === 0 ? "" : checkBonus}`,
              "passive": "",
            },
            roll: {
              min: null,
              max: null,
              mode: 0
            },
          };
        }
      }
    }
  }
};

DDBCharacter/* default.prototype._generateSkills */.Z.prototype._generateSkills = async function _generateSkills() {
  const addEffects = game.modules.get("dae")?.active;

  if (!addEffects) this.raw.character.flags['skill-customization-5e'] = {};
  dictionary/* default.character.skills.forEach */.Z.character.skills.forEach((skill) => {
    const customProficient = this.getCustomSkillProficiency(skill);
    // we use !== undefined because the return value could be 0, which is falsey
    const proficient = customProficient !== undefined ? customProficient : this.getSkillProficiency(skill);

    // Skill bonuses
    const skillModifierBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: skill.subType })
      .map((skl) => skl.value)
      .reduce((a, b) => a + b, 0) ?? "";
    const passiveBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: `passive-${skill.subType}` })
      .map((skl) => skl.value)
      .reduce((a, b) => a + b, 0) ?? "";
    const customSkillBonus = this.getCustomSkillBonus(skill);
    const skillBonus = skillModifierBonus + customSkillBonus;
    const customAbility = this.getCustomSkillAbility(skill);
    const ability = customAbility !== undefined ? customAbility : skill.ability;

    // custom skill ability over ride effects
    if (customAbility) {
      const label = "Skill Ability Changes";
      const change = {
        key: `system.skills.${skill.name}.ability`,
        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,
        value: `${customAbility}`,
        priority: "20"
      };

      const changeIndex = this.raw.character.effects.findIndex((effect) => effect.name === label);
      if (changeIndex >= 0) {
        this.raw.character.effects[changeIndex].changes.push(change);
      } else {
        let skillEffect = (0,effects_effects/* generateBaseSkillEffect */.Tb)(this.source.ddb.character.id, label);
        skillEffect.changes.push(change);
        this.raw.character.effects.push(skillEffect);
      }
    }

    this.raw.character.system.skills[skill.name] = {
      value: proficient,
      ability: ability,
      bonuses: {
        check: `${parseInt(skillBonus) === 0 ? "" : skillBonus}`,
        passive: `${parseInt(passiveBonus) === 0 ? "" : passiveBonus}`,
      },
      roll: {
        min: null,
        max: null,
        mode: 0
      },
    };
  });

  await this._generateCustomSkills();
  this._setSpecialSkills();

};

;// CONCATENATED MODULE: ./src/parser/character/abilities.js

// import logger from "../../logger.js";




DDBCharacter/* default.prototype._generateAbilitiesOverrides */.Z.prototype._generateAbilitiesOverrides = function _generateAbilitiesOverrides() {
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    this.abilities.overrides[ability.value]
      = this.source.ddb.character.overrideStats.find((stat) => stat.id === ability.id).value || 0;
  });
  this.raw.character.flags.ddbimporter.dndbeyond.abilityOverrides = this.abilities.overrides;
};

DDBCharacter/* default.prototype._getCustomSaveProficiency */.Z.prototype._getCustomSaveProficiency = function _getCustomSaveProficiency(ability) {
  // Overwrite the proficient value with any custom set over rides
  if (this.source.ddb.character.characterValues) {
    const customProficiency = this.source.ddb.character.characterValues.find(
      (value) => value.typeId === 41 && value.valueId == ability.id && value.value
    );
    if (customProficiency) {
      if (customProficiency.value === 1) {
        return 0;
      }
      // Foundry does not support half proficiencies or expertise here
      return 1;
    }
  }
  return undefined;
};

DDBCharacter/* default.prototype._getCustomSaveBonus */.Z.prototype._getCustomSaveBonus = function _getCustomSaveBonus(ability) {
  // Get any custom skill bonuses
  if (this.source.ddb.character.characterValues) {
    const customBonus = this.source.ddb.character.characterValues
      .filter((value) => (value.typeId == 40 || value.typeId == 39) && value.valueId == ability.id)
      .reduce((total, bonus) => {
        return total + bonus.value;
      }, 0);

    if (customBonus) {
      return customBonus;
    }
  }
  return 0;
};

/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} includeExcludedEffects Include effects from dae added items?
 */
DDBCharacter/* default.prototype._getAbilities */.Z.prototype._getAbilities = function _getAbilities(includeExcludedEffects = false) {
  let result = {};
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    result[ability.value] = {
      value: 0,
      min: 3,
      max: 20,
      proficient: 0,
    };

    const stat = this.source.ddb.character.stats.find((stat) => stat.id === ability.id).value || 0;
    const abilityScoreMaxBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: "ability-score-maximum", restriction: ["", null], includeExcludedEffects })
      .filter((mod) => mod.statId === ability.id)
      .reduce((prev, cur) => prev + cur.value, 0);
    const bonusStatRestrictions = [
      null,
      "",
      "+2 to score maximum",
      "+4 to score maximum",
      "+2 to maximum score",
      "+4 to maximum score",
      "Can't be an Ability Score you already increased with this trait.",
    ];
    const bonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: `${ability.long}-score`, restriction: bonusStatRestrictions, includeExcludedEffects })
      .filter((mod) => mod.entityId === ability.id)
      .reduce((prev, cur) => prev + cur.value, 0);
    const setAbilities = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "set", { subType: `${ability.long}-score`, restriction: [null, "", "if not already higher"], includeExcludedEffects })
      .map((mod) => mod.value);
    const modRestrictions = ["Your maximum is now ", "Maximum of "];
    const cappedBonusExp = new RegExp(`(?:${modRestrictions.join("|")})(\\d*)`);
    const cappedBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: `${ability.long}-score`, restriction: false, includeExcludedEffects })
      .filter(
        (mod) =>
          mod.entityId === ability.id
          && mod.restriction
          && modRestrictions.some((m) => mod.restriction.startsWith(m))
      )
      .reduce(
        (prev, cur) => {
          const restricted = cur.restriction ? cappedBonusExp.exec(cur.restriction) : undefined;
          const max = restricted ? restricted[1] : 20;
          return {
            value: prev.value + cur.value,
            cap: Math.max(prev.cap, max),
          };
        },
        { value: 0, cap: 20 + abilityScoreMaxBonus }
      );
    // applied regardless of cap
    const bonusStat = this.source.ddb.character.bonusStats.find((stat) => stat.id === ability.id).value || 0;
    // over rides all other calculations if present
    const overrideStat = this.source.ddb.character.overrideStats.find((stat) => stat.id === ability.id).value || 0;

    const setAbility = Math.max(...[0, ...setAbilities]);
    const calculatedStat = stat + bonus + cappedBonus.value;
    // bonus gets added regardlesss of normal caps
    const maxAdjustedStat = Math.min(cappedBonus.cap, calculatedStat) + bonusStat;
    // some items will set the ability score if lower
    const setAbilityState = maxAdjustedStat > setAbility ? maxAdjustedStat : setAbility;
    // Is there a hard over ride?
    const overRiddenStat = overrideStat === 0 ? setAbilityState : overrideStat;
    const customProficiency = this._getCustomSaveProficiency(ability);

    const proficient = customProficiency
      ? customProficiency
      : DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "proficiency", { subType: `${ability.long}-saving-throws`, includeExcludedEffects }).length > 0
        ? 1
        : 0;

    // update value, mod and proficiency
    result[ability.value].value = overRiddenStat;
    result[ability.value].mod = utils/* default.calculateModifier */.Z.calculateModifier(result[ability.value].value);
    result[ability.value].proficient = proficient;
    result[ability.value].max = Math.max(cappedBonus.cap, overRiddenStat);
  });

  return result;
};

DDBCharacter/* default.prototype._getAbilitiesBonuses */.Z.prototype._getAbilitiesBonuses = function (includeExcludedEffects = false) {

  let result = {};
  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    result[ability.value] = {
      bonuses: {
        check: "",
        save: "",
        checkMinimum: null,
        saveMinimum: null,
      },
    };

    const checkBonusModifiers = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: `${ability.long}-ability-checks`, includeExcludedEffects });
    const checkBonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(checkBonusModifiers, this.raw.character);
    if (checkBonus && checkBonus !== "") {
      result[ability.value].bonuses.check = `+ ${checkBonus}`;
    }

    const saveBonusModifiers = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: `${ability.long}-saving-throws`, includeExcludedEffects });
    const modifiersSaveBonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(saveBonusModifiers, this.raw.character);
    const customSaveBonus = this._getCustomSaveBonus(ability);

    if (modifiersSaveBonus && modifiersSaveBonus !== "" && parseInt(modifiersSaveBonus)) {
      if (customSaveBonus) {
        const totalSave = parseInt(customSaveBonus) + parseInt(modifiersSaveBonus);
        // console.warn("totalSave", totalSave);
        result[ability.value].bonuses.save = `+ ${totalSave}`;
      } else {
        result[ability.value].bonuses.save = `+ ${modifiersSaveBonus}`;
      }
    } else if (modifiersSaveBonus && modifiersSaveBonus !== "") {
      if (customSaveBonus) {
        result[ability.value].bonuses.save = `+ ${modifiersSaveBonus} + ${customSaveBonus}`;
      } else {
        result[ability.value].bonuses.save = `+ ${modifiersSaveBonus}`;
      }
    } else if (customSaveBonus) {
      result[ability.value].bonuses.save = `+ ${customSaveBonus}`;
    }
  });

  return result;
};

/**
 * Retrieves character abilities, including proficiency on saving throws
 * @param {obj} includeExcludedEffects Include effects from dae added items?
 */
DDBCharacter/* default.prototype._generateBaseAbilities */.Z.prototype._generateBaseAbilities = function (includeExcludedEffects = false) {
  this.raw.character.system.abilities = this._getAbilities(includeExcludedEffects);
};


/**
 * Generates character abilities, including proficiency on saving throws
 */
DDBCharacter/* default.prototype._generateAbilities */.Z.prototype._generateAbilities = function _generateAbilities() {
  // go through every ability

  // we need to populate some base abilities to work out bonuses
  this._generateBaseAbilities(false);

  this.abilities.core = foundry.utils.mergeObject(this._getAbilities(false), this._getAbilitiesBonuses(false));
  this.abilities.withEffects = foundry.utils.mergeObject(this._getAbilities(true), this._getAbilitiesBonuses(true));
  this.raw.character.system.abilities = this.abilities.core;
  this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities = this.abilities.withEffects;

  this._generateAbilitiesOverrides();

};

;// CONCATENATED MODULE: ./src/parser/character/hp.js



DDBCharacter/* default.prototype._generateHitPoints */.Z.prototype._generateHitPoints = function _generateHitPoints() {
  const constitutionHP = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities.con.mod * this.raw.character.flags.ddbimporter.dndbeyond.totalLevels;
  const baseHitPoints = this.source.ddb.character.baseHitPoints || 0;
  const tempMaxHitPoints = this.source.ddb.character.bonusHitPoints || 0;
  const overrideHitPoints = this.source.ddb.character.overrideHitPoints || 0;
  const removedHitPoints = this.source.ddb.character.removedHitPoints || 0;
  const temporaryHitPoints = this.source.ddb.character.temporaryHitPoints || 0;

  // get allvalues hit points features
  const bonusHitPointFeatures = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: "hit-points-per-level" });
  const bonusHitPointFeaturesWithEffects = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: "hit-points-per-level", includeExcludedEffects: true });

  // get their
  const bonusHitPointValues = bonusHitPointFeatures.map((bonus) => {
    const cls = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.source.ddb, bonus.componentId);
    if (cls) {
      return cls.level * bonus.value;
    } else {
      return this.raw.character.flags.ddbimporter.dndbeyond.totalLevels * bonus.value;
    }
  });

  const bonusHitPointValuesWithEffects = bonusHitPointFeaturesWithEffects.map((bonus) => {
    const cls = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.source.ddb, bonus.componentId);
    if (cls) {
      return cls.level * bonus.value;
    } else {
      return this.raw.character.flags.ddbimporter.dndbeyond.totalLevels * bonus.value;
    }
  });

  // sum up the bonus HP per class level
  const totalBonusHitPoints = bonusHitPointValues.reduce((prev, cur) => prev + cur, 0);
  const totalBonusHPWithEffects = bonusHitPointValuesWithEffects.reduce((prev, cur) => prev + cur, 0);

  const bonusPerLevelValue = bonusHitPointFeatures.map((bonus) => {
    const cls = DDBHelper/* default.findClassByFeatureId */.Z.findClassByFeatureId(this.source.ddb, bonus.componentId);
    // console.warn("cls hp", { bonus, cls});
    if (!cls) {
      return bonus.value;
    } else {
      return 0;
    }
  }).reduce((prev, cur) => prev + cur, 0);

  // const bonusHPEffectDiff = totalBonusHPWithEffects - totalBonusHitPoints - bonusPerLevelValue;
  const overallBonus = totalBonusHitPoints - (bonusPerLevelValue * this.raw.character.flags.ddbimporter.dndbeyond.totalLevels);

  const maxHitPoints = overrideHitPoints === 0
    ? constitutionHP + baseHitPoints + totalBonusHPWithEffects
    : overrideHitPoints;

  const rolledHP = foundry.utils.getProperty(this.source, "ddb.character.preferences.hitPointType") === 2;

  // console.warn("hp data", {
  //   bonusHitPointValues,
  //   bonusHitPointValuesWithEffects,
  //   totalBonusHPWithEffects,
  //   totalBonusHitPoints,
  //   bonusPerLevelValue,
  //   overallBonus,
  //   maxHitPoints,
  //   rolledHP,
  // });

  this.raw.character.system.attributes.hp = {
    value: maxHitPoints + tempMaxHitPoints - removedHitPoints,
    max: overrideHitPoints !== 0
      ? overrideHitPoints
      : rolledHP && game.settings.get("ddb-importer", "character-update-policy-use-hp-max-for-rolled-hp")
        ? maxHitPoints
        : null,
    temp: temporaryHitPoints ?? 0,
    tempmax: tempMaxHitPoints ?? 0,
    bonuses: {
      level: bonusPerLevelValue !== 0 ? bonusPerLevelValue : "",
      overall: overallBonus !== 0 ? overallBonus : "",
    },
  };

  this.raw.character.flags.ddbimporter.rolledHP = rolledHP;
  this.raw.character.flags.ddbimporter.baseHitPoints = baseHitPoints;

  // "hp": {
  //   "value": 23,
  //   "max": null,
  //   "temp": null,
  //   "tempmax": null,
  //   "bonuses": {
  //     "level": "1",
  //     "overall": "2"
  //   }
  // },
};

DDBCharacter/* default.prototype._generateHitDice */.Z.prototype._generateHitDice = function _generateHitDice() {
  const used = this.source.ddb.character.classes.reduce((prev, cls) => prev + cls.hitDiceUsed, 0);
  const total = this.source.ddb.character.classes.reduce((prev, cls) => prev + cls.level, 0);
  this.raw.character.system.attributes.hd = total - used;
};

;// CONCATENATED MODULE: ./src/parser/character/initiative.js



DDBCharacter/* default.prototype._generateInitiative */.Z.prototype._generateInitiative = function _generateInitiative() {
  const initMods = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: "initiative" });
  // const initiativeBonus = DDBHelper.getModifierSum(initMods, this.raw.character);

  let initiativeBonus = DDBHelper/* default.getValueFromModifiers */.Z.getValueFromModifiers(initMods, "initiative", "initiative", "bonus");

  // if (initiativeBonus && this.raw.character.flags.dnd5e.initiativeAlert) {
  //   if (initiativeBonus.includes("+ 5")) {
  //     initiativeBonus = initiativeBonus.replace("+ 5", "");
  //   } else if ([5].includes(Number.parseInt(initiativeBonus))) {
  //     initiativeBonus = "";
  //   }
  // }
  if (Number.parseInt(initiativeBonus) === 0) {
    initiativeBonus = "";
  }

  // If we have the alert Feat set, lets sub 5 so it's correct
  this.raw.character.system.attributes.init = {
    ability: "dex",
    bonus: initiativeBonus ?? "",
  };

};

;// CONCATENATED MODULE: ./src/parser/character/effects.js






DDBCharacter/* default.prototype._generateDeathSaves */.Z.prototype._generateDeathSaves = function _generateDeathSaves () {
  this.raw.character.system.attributes.death = {
    success: this.source.ddb.character.deathSaves.successCount || 0,
    failure: this.source.ddb.character.deathSaves.failCount || 0,
  };
};

DDBCharacter/* default.prototype._generateExhaustion */.Z.prototype._generateExhaustion = function _generateExhaustion() {
  const condition = this.source.ddb.character.conditions.find((condition) => parseInt(condition.id) === 4);
  this.raw.character.system.attributes.exhaustion = condition
    ? parseInt(condition.level)
    : 0;
};

DDBCharacter/* default.prototype.getCharacterGenericConditionAffectData */.Z.prototype.getCharacterGenericConditionAffectData = function getCharacterGenericConditionAffectData(condition, typeId) {

  const modifiers = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, condition);
  const standardResults = (0,effects_effects/* getGenericConditionAffectData */.OJ)(modifiers, condition, typeId);

  const customResults = this.source.ddb.character.customDefenseAdjustments
    .filter((adjustment) => adjustment.type === (typeId === 4 ? 1 : 2))
    .map((adjustment) => {
      const entry = dictionary/* default.character.damageAdjustments.find */.Z.character.damageAdjustments.find((type) =>
        type.id === adjustment.adjustmentId
        && type.type === typeId
      );
      if (!entry) return undefined;
      const valueData = foundry.utils.hasProperty(entry, "foundryValues")
        ? foundry.utils.getProperty(entry, "foundryValues")
        : foundry.utils.hasProperty(entry, "foundryValue")
          ? { value: entry.foundryValue }
          : undefined;
      return valueData;
    })
    .filter((adjustment) => adjustment !== undefined);

  const results = customResults.concat(standardResults).map((result) => {
    if (game.modules.get("midi-qol")?.active && result.midiValues) {
      return {
        value: result.value.concat(result.midiValues),
        bypass: result.bypass,
      };
    } else {
      return result;
    }
  });

  logger/* default.debug */.Z.debug(`Condition generation: ${condition}, typeId: ${typeId}`, {
    modifiers,
    standardResults,
    customResults,
    results,
    customDefenseAdjustments: this.source.ddb.character.customDefenseAdjustments,
  });

  return {
    custom: "",
    value: [...new Set(results.map((result) => result.value).flat())],
    bypasses: [...new Set(results.map((result) => result.bypass).flat())],
  };
};

DDBCharacter/* default.prototype._generateConditions */.Z.prototype._generateConditions = function _generateConditions() {
  this.raw.character.system.traits.di = this.getCharacterGenericConditionAffectData("immunity", 2);
  this.raw.character.system.traits.dr = this.getCharacterGenericConditionAffectData("resistance", 1);
  this.raw.character.system.traits.dv = this.getCharacterGenericConditionAffectData("vulnerability", 3);
  this.raw.character.system.traits.ci = this.getCharacterGenericConditionAffectData("immunity", 4);
};

;// CONCATENATED MODULE: ./src/parser/character/currency.js


DDBCharacter/* default.prototype._generateCurrency */.Z.prototype._generateCurrency = function _generateCurrency() {
  this.raw.character.system.currency = {
    pp: this.source.ddb.character.currencies.pp,
    gp: this.source.ddb.character.currencies.gp,
    ep: this.source.ddb.character.currencies.ep,
    sp: this.source.ddb.character.currencies.sp,
    cp: this.source.ddb.character.currencies.cp,
  };

  this._currency = foundry.utils.deepClone(this.raw.character.system.currency);
};

;// CONCATENATED MODULE: ./src/parser/character/senses.js




DDBCharacter/* default.prototype.getSenses */.Z.prototype.getSenses = function getSenses({ includeEffects = false } = {}) {
  let senses = {
    darkvision: 0,
    blindsight: 0,
    tremorsense: 0,
    truesight: 0,
    units: "ft",
    special: ""
  };

  // custom senses
  if (this.source.ddb.character.customSenses) {
    this.source.ddb.character.customSenses
      .filter((sense) => sense.distance)
      .forEach((sense) => {
        const s = dictionary/* default.character.senses.find */.Z.character.senses.find((s) => s.id === sense.senseId);
        if (s && sense.distance && Number.isInteger(sense.distance)) {
          senses[s.name.toLowerCase()] = parseInt(sense.distance);
        } else {
          senses.special += `${sense.distance}; `;
        }
      });
  }

  // Base senses
  for (const senseName in senses) {
    const basicOptions = { subType: senseName, includeExcludedEffects: includeEffects };
    DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "set-base", basicOptions).forEach((sense) => {
      if (Number.isInteger(sense.value) && sense.value > senses[senseName]) {
        senses[senseName] = parseInt(sense.value);
      }
    });
  }

  // Devils Sight gives bright light to 120 foot instead of normal darkvision
  const devilsSightFilters = {
    subType: "darkvision",
    restriction: [
      "You can see normally in darkness, both magical and nonmagical",
    ],
    includeExcludedEffects: includeEffects,
  };
  DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "set-base", devilsSightFilters)
    .forEach((sense) => {
      if (Number.isInteger(sense.value) && sense.value > senses['darkvision']) {
        senses['darkvision'] = parseInt(sense.value);
        senses.special += "You can see normally in darkness, both magical and nonmagical.";
      }
    });

  // Magical bonuses and additional, e.g. Gloom Stalker
  const magicalBonusFilters = {
    subType: "darkvision",
    restriction: ["", null, "plus 60 feet if wearer already has Darkvision"],
    includeExcludedEffects: includeEffects,
  };
  DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "sense", magicalBonusFilters)
    .forEach((mod) => {
      const hasSense = mod.subType in senses;
      if (hasSense && mod.value && Number.isInteger(mod.value)) {
        senses[mod.subType] += parseInt(mod.value);
      } else {
        senses.special += ` ${mod.value},`;
      }
    });

  return senses;

};

DDBCharacter/* default.prototype._generateSenses */.Z.prototype._generateSenses = function _generateSenses() {
  this.raw.character.system.attributes.senses = this.getSenses();
};

;// CONCATENATED MODULE: ./src/parser/character/speed.js




DDBCharacter/* default.prototype._generateSpeed */.Z.prototype._generateSpeed = function _generateSpeed() {

  // For all processing, we take into account the regular movement types of this character
  let movementTypes = {};
  let setToWalking = {};
  for (const type in this.source.ddb.character.race.weightSpeeds.normal) {
    // if (data.character.race.weightSpeeds.normal[type] !== 0) {
    movementTypes[type] = this.source.ddb.character.race.weightSpeeds.normal[type];
    setToWalking[type] = false;
    // }
  }


  // get bonus speed mods
  let restriction = ["", null, "unless your speed is already higher"];
  // Check for equipped Heavy Armor
  const wearingHeavy = this.source.ddb.character.inventory.some((item) => item.equipped && item.definition.type === "Heavy Armor");
  // Accounts for Barbarian Class Feature - Fast Movement
  if (!wearingHeavy) restriction.push("while you arent wearing heavy armor");

  // build base speeds
  for (let type in movementTypes) {
    // is there a 'inntate-speed-[type]ing' race/class modifier?
    const innateType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.type === type).innate;
    let innateSpeeds = this.source.ddb.character.modifiers.race.filter(
      (modifier) => modifier.type === "set" && modifier.subType === `innate-speed-${innateType}`
    );
    let base = movementTypes[type];

    innateSpeeds.forEach((speed) => {
      // take the highest value
      if (speed.value === null && speed.modifierSubTypeId == 182 && speed.modifierTypeId == 9) {
        setToWalking[type] = true;
      } else if (speed.value > base) {
        base = speed.value;
      }
    });

    // overwrite the (perhaps) changed value
    movementTypes[type] = base;
  }

  const bonusSpeed = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: "speed", restriction })
    .reduce((speed, feat) => speed + feat.value, 0);

  // speed bonuses
  for (let type in movementTypes) {
    let innateBonus = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: `speed-${type}ing`, restriction })
      .reduce((speed, feat) => speed + feat.value, 0);

    // overwrite the (perhaps) changed value
    if (movementTypes[type] !== 0) movementTypes[type] += bonusSpeed + innateBonus;
  }

  // unarmored movement for barbarians and monks
  if (this.isUnArmored()) {
    DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(this.source.ddb)
      .filter((modifier) => modifier.type === "bonus" && modifier.subType === "unarmored-movement")
      .forEach((bonusSpeed) => {
        for (let type in movementTypes) {
          if (movementTypes[type] !== 0) movementTypes[type] += bonusSpeed.value;
        }
      });
  }

  // new ranger deft explorer sets speeds, leaves value null, use walking
  for (let type in movementTypes) {
    const innateType = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.type === type).innate;
    // is there a 'inntate-speed-[type]ing' race/class modifier?
    let innateSpeeds = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "set", { subType: `innate-speed-${innateType}`, restriction });
    let base = movementTypes[type];

    innateSpeeds.forEach((speed) => {
      // take the highest value
      if (speed.value > base) {
        base = speed.value;
      } else if (!speed.value && movementTypes['walk']) {
        base = movementTypes['walk'];
      }
    });

    // overwrite the (perhaps) changed value
    movementTypes[type] = base;
  }


  // is there a custom seed over-ride?
  if (this.source.ddb.character.customSpeeds) {
    this.source.ddb.character.customSpeeds.forEach((speed) => {
      const type = dictionary/* default.character.speeds.find */.Z.character.speeds.find((s) => s.id === speed.movementId).type;
      if (speed.distance) {
        movementTypes[type] = speed.distance;
      }
    });
  }

  for (let type in setToWalking) {
    if (setToWalking[type] && movementTypes["walk"] > movementTypes[type]) {
      movementTypes[type] = movementTypes["walk"];
    }
  }

  this.raw.character.system.attributes.movement = {
    burrow: movementTypes['burrow'] || 0,
    climb: movementTypes['climb'] || 0,
    fly: movementTypes['fly'] || 0,
    swim: movementTypes['swim'] || 0,
    walk: movementTypes['walk'] || 0,
    units: "ft",
    hover: false,
  };

};

// EXTERNAL MODULE: ./src/parser/character/bio.js
var bio = __webpack_require__(2331);
;// CONCATENATED MODULE: ./src/parser/character/size.js




DDBCharacter/* default.prototype._generateSize */.Z.prototype._generateSize = function _generateSize() {
  const sizeMods = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(this.source.ddb.character.modifiers.race, "size");
  const size = (sizeMods.length > 0)
    ? dictionary/* default.character.actorSizes.find */.Z.character.actorSizes.find((size) => sizeMods.some((mod) => mod.subType === size.name.toLowerCase()))
    : dictionary/* default.character.actorSizes.find */.Z.character.actorSizes.find((size) =>
      size.name === this.source.ddb.character.race.size
      || size.id === this.source.ddb.character.race.sizeId);

  this.raw.character.system.traits.size = size ? size.value : "med";
};

;// CONCATENATED MODULE: ./src/parser/character/spellCasting.js





// convert spellcasting ability id to string used by foundry
function convertSpellCastingAbilityId(spellCastingAbilityId) {
  return dictionary/* default.character.abilities.find */.Z.character.abilities.find((ability) => ability.id === spellCastingAbilityId)?.value;
};

function getSpellCastingAbility(klass) {
  const subClassAbilityId = foundry.utils.getProperty(klass, "subclassDefinition.spellCastingAbilityId");
  const subClassAbility = subClassAbilityId ? convertSpellCastingAbilityId(subClassAbilityId) : undefined;
  if (subClassAbility) return subClassAbility;

  const classAbilityId = foundry.utils.getProperty(klass, "definition.spellCastingAbilityId");
  const classAbility = classAbilityId ? convertSpellCastingAbilityId(classAbilityId) : undefined;

  if (classAbility) return classAbility;

  return undefined;
}

DDBCharacter/* default.prototype._generateSpellCasting */.Z.prototype._generateSpellCasting = function _generateSpellCasting() {
  let result = [];
  this.source.ddb.character.classSpells.forEach((playerClass) => {
    let classInfo = this.source.ddb.character.classes.find((cls) => cls.id === playerClass.characterClassId);
    const spellCastingAbility = getSpellCastingAbility(classInfo);
    if (spellCastingAbility !== undefined) {
      const characterAbilities = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities;
      let abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);
      result.push({ label: spellCastingAbility, value: abilityModifier });
    }
  });
  // we need to decide on one spellcasting ability, so we take the one with the highest modifier
  if (result.length === 0) {
    this.raw.character.system.attributes.spellcasting = "";
  } else {
    this.raw.character.system.attributes.spellcasting = result
      .sort((a, b) => {
        if (a.value > b.value) return -1;
        if (a.value < b.value) return 1;
        return 0;
      })
      .map((entry) => entry.label)[0];
  }
};

DDBCharacter/* default.prototype._generateSpellDC */.Z.prototype._generateSpellDC = function _generateSpellDC() {
  if (this.raw.character.system.attributes.spellcasting === "") {
    this.raw.character.system.attributes.spelldc = 10;
  } else {
    const characterAbilities = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities;
    const dc = 8 + characterAbilities[this.raw.character.system.attributes.spellcasting].mod + this.raw.character.system.attributes.prof;
    this.raw.character.system.attributes.spelldc = dc;
  }
};

DDBCharacter/* default.prototype.getCasterInfo */.Z.prototype.getCasterInfo = function getCasterInfo() {
  return this.source.ddb.character.classes
    .filter((cls) => {
      return cls.definition.canCastSpells || (cls.subclassDefinition && cls.subclassDefinition.canCastSpells);
    })
    .map((cls) => {
      // the class total level
      let casterLevel = cls.level;
      // class name
      const name = cls.definition.name;

      // get the casting level if the character is a multiclassed spellcaster
      if (cls.definition.spellRules && cls.definition.spellRules.multiClassSpellSlotDivisor) {
        casterLevel = Math.floor(casterLevel / cls.definition.spellRules.multiClassSpellSlotDivisor);
      } else {
        casterLevel = 0;
      }
      // Blood hunters are weird
      if (["Blood Hunter"].includes(name)) {
        casterLevel = cls.level;
      }

      const cantrips
        = cls.definition.spellRules
        && cls.definition.spellRules.levelCantripsKnownMaxes
        && Array.isArray(cls.definition.spellRules.levelCantripsKnownMaxes)
          ? cls.definition.spellRules.levelCantripsKnownMaxes[casterLevel + 1]
          : 0;

      if (["Warlock", "Blood Hunter"].includes(name)) {
        // pact casting doesn't count towards multiclass spells casting
        // we still add an entry to get cantrip info
        const levelSpellSlots = cls.definition.spellRules.levelSpellSlots[casterLevel];
        const maxLevel = levelSpellSlots.indexOf(Math.max(...levelSpellSlots)) + 1;
        const maxSlots = Math.max(...levelSpellSlots);
        const currentSlots = this.source.ddb.character.pactMagic.find((pact) => pact.level === maxLevel).used;
        if (["Blood Hunter"].includes(name)) {
          this.spellSlots.pact = { value: maxSlots - currentSlots, max: maxSlots, override: maxSlots };
        } else {
          this.spellSlots.pact = { value: maxSlots - currentSlots, max: maxSlots };
        }
        return {
          name,
          casterLevel: 0,
          slots: cls.definition.spellRules.levelSpellSlots[0],
          cantrips,
        };
      } else {
        return {
          name,
          casterLevel,
          slots: cls.definition.spellRules.levelSpellSlots[cls.level],
          cantrips,
        };
      }
    });
};

DDBCharacter/* default.prototype._generateSpellSlots */.Z.prototype._generateSpellSlots = function _generateSpellSlots() {
  // get the caster information from all classes and subclasses
  const casterInfo = this.getCasterInfo();

  let result = null;
  if (casterInfo.length !== 1) {
    const multiClassSpellSlots = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0], // 0
      [2, 0, 0, 0, 0, 0, 0, 0, 0], // 1
      [3, 0, 0, 0, 0, 0, 0, 0, 0], // 2
      [4, 2, 0, 0, 0, 0, 0, 0, 0], // 3
      [4, 3, 0, 0, 0, 0, 0, 0, 0], // 4
      [4, 3, 2, 0, 0, 0, 0, 0, 0], // 5
      [4, 3, 3, 0, 0, 0, 0, 0, 0], // 6
      [4, 3, 3, 1, 0, 0, 0, 0, 0], // 7
      [4, 3, 3, 2, 0, 0, 0, 0, 0], // 8
      [4, 3, 3, 3, 1, 0, 0, 0, 0], // 9
      [4, 3, 3, 3, 2, 0, 0, 0, 0], // 10
      [4, 3, 3, 3, 2, 1, 0, 0, 0], // 11
      [4, 3, 3, 3, 2, 1, 0, 0, 0], // 12
      [4, 3, 3, 3, 2, 1, 1, 0, 0], // 13
      [4, 3, 3, 3, 2, 1, 1, 0, 0], // 14
      [4, 3, 3, 3, 2, 1, 1, 1, 0], // 15
      [4, 3, 3, 3, 2, 1, 1, 1, 0], // 16
      [4, 3, 3, 3, 2, 1, 1, 1, 1], // 17
      [4, 3, 3, 3, 3, 1, 1, 1, 1], // 18
      [4, 3, 3, 3, 3, 2, 1, 1, 1], // 19
      [4, 3, 3, 3, 3, 2, 2, 1, 1], // 20
    ];
    const casterLevelTotal = casterInfo.reduce((prev, cur) => prev + cur.casterLevel, 0);
    const cantripsTotal = casterInfo.reduce((prev, cur) => prev + cur.cantrips, 0);
    result = [cantripsTotal, ...multiClassSpellSlots[casterLevelTotal]];
  } else {
    result = [casterInfo[0].cantrips, ...casterInfo[0].slots];
  }

  for (let i = 1; i < result.length; i++) {
    const currentSlots = this.source.ddb.character.spellSlots.filter((slot) => slot.level === i).map((slot) => slot.used) || 0;
    this.spellSlots["spell" + i] = {
      value: (result[i] - currentSlots) ?? 0,
      max: result[i] ?? 0,
    };
  }
  this.raw.character.system.spells = this.spellSlots;
};

DDBCharacter/* default.prototype._generateMaxPreparedSpells */.Z.prototype._generateMaxPreparedSpells = function _generateMaxPreparedSpells() {
  let max = 0;

  this.source.ddb.character.classes
    .filter((klass) => {
      return (klass.definition.canCastSpells || (klass.subclassDefinition?.canCastSpells));
    })
    .forEach((klass) => {
      const spellCastingAbility = getSpellCastingAbility(klass);
      if (spellCastingAbility !== undefined) {
        const characterAbilities = this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities;
        const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(characterAbilities[spellCastingAbility].value);
        if (klass.definition.spellPrepareType === 1 || klass.subclassDefinition?.spellPrepareType === 1) {
          max += abilityModifier + klass.level;
        } else if (klass.definition.spellPrepareType === 2 || klass.subclassDefinition?.spellPrepareType === 2) {
          max += abilityModifier + Math.floor(klass.level / 2);
        }

      }
    });

  this.raw.character.system.details.maxPreparedSpells = max;
  foundry.utils.setProperty(this.raw.character, "flags.tidy5e-sheet.maxPreparedSpells", max);
  foundry.utils.setProperty(this.raw.character, "flags.tidy5e-sheet-kgar.maxPreparedSpells", max);
};

// EXTERNAL MODULE: ./src/parser/race/DDBRace.js
var DDBRace = __webpack_require__(1434);
;// CONCATENATED MODULE: ./src/parser/character/race.js





DDBCharacter/* default.prototype._generateRace */.Z.prototype._generateRace = async function _generateRace() {
  const traits = this.source.ddb.character.race.racialTraits.map((r) => r.definition);
  const compendiumRacialTraits = await DDBRace/* default.getRacialTraitsLookup */.Z.getRacialTraitsLookup(traits, false);
  this._ddbRace = new DDBRace/* default */.Z(this.source.ddb, this.source.ddb.character.race, compendiumRacialTraits);
  await this._ddbRace.build();
  this.raw.race = (this.updateItemIds([this._ddbRace.data]))[0];
  delete this.raw.race.sort;

  // update character race value with race type
  foundry.utils.setProperty(this.raw.character, "system.details.type.value", this.raw.race.type);

  // console.warn("Race Advancement", JSON.parse(JSON.stringify(this.raw.race.system.advancement)));
  this.raw.race.system.advancement.forEach((a) => {
    switch (a.type) {
      case "AbilityScoreImprovement": {
        a.value = {
          type: "asi",
          assignments: {},
        };
        dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
          const bonus = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(this.source.ddb.character.modifiers.race, "bonus", `${ability.long}-score`, [null, ""])
            .filter((mod) => mod.entityId === ability.id)
            .reduce((prev, cur) => prev + cur.value, 0);
          a.value.assignments[ability.value] = bonus;
        });
        break;
      }
      case "Size": {
        const modSize = DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(this.source.ddb.character.modifiers.race, "size");
        const size = a.configuration.sizes.length === 1
          ? a.configuration.sizes[0]
          : modSize && modSize.length === 1
            ? dictionary/* default.character.actorSizes.find */.Z.character.actorSizes.find((s) => modSize.subType === s.name.toLowerCase())?.value ?? `${this.raw.character.system.traits.size}`
            : `${this.raw.character.system.traits.size}`;
        a.value = {
          size,
        };
        break;
      }
      // no default
    }
  });
};

;// CONCATENATED MODULE: ./src/parser/character/resources.js




DDBCharacter/* default.prototype.resourceList */.Z.prototype.resourceList = function resourceList() {
  const resources = [this.source.ddb.character.actions.race, this.source.ddb.character.actions.class, this.source.ddb.character.actions.feat]
    .flat()
    .filter((action) =>
      action.limitedUse
        && (action.limitedUse.maxUses || action.limitedUse.statModifierUsesId || action.limitedUse.useProficiencyBonus)
        && !["Hypnotic Gaze"].includes(action.name));

  return resources;
};

DDBCharacter/* default.prototype.getSortedByUsedResourceList */.Z.prototype.getSortedByUsedResourceList = function getSortedByUsedResourceList() {
  // get all resources
  const allResources = this.resourceList();
  const resources = allResources
    .map((action) => {
      let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;

      if (action.limitedUse.statModifierUsesId) {
        const ability = dictionary/* default.character.abilities.find */.Z.character.abilities.find(
          (ability) => ability.id === action.limitedUse.statModifierUsesId
        ).value;

        switch (action.limitedUse.operator) {
          case 2: {
            maxUses *= this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
            break;
          }
          case 1:
          default:
            maxUses += this.raw.character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;
        }
      }

      if (action.limitedUse.useProficiencyBonus) {
        switch (action.limitedUse.proficiencyBonusOperator) {
          case 2: {
            maxUses *= this.raw.character.system.attributes.prof;
            break;
          }
          case 1:
          default:
            maxUses += this.raw.character.system.attributes.prof;
        }
      }

      return {
        label: action.name,
        value: maxUses - action.limitedUse.numberUsed,
        max: maxUses,
        sr: action.limitedUse.resetType === 1,
        lr: action.limitedUse.resetType === 1 || action.limitedUse.resetType === 2 || action.limitedUse.resetType === 3,
      };
    })
    // sort by maxUses, I guess one wants to track the most uses first, because it's used more often
    .sort((a, b) => {
      if (a.max > b.max) return -1;
      if (a.max < b.max) return 1;
      return 0;
    });
  return resources;
};

const sheetResources = [
  "primary",
  "secondary",
  "tertiary",
  "fourth",
  "fifth",
  "sixth",
  "seventh",
  "eighth",
  "ninth",
  "tenth",
  "eleventh",
  "twelfth",
  "thirteenth",
  "fourteenth",
  "fifteenth",
  "sixteenth",
  "seventeenth",
  "eighteenth",
  "nineteenth",
  "twentieth",
];

DDBCharacter/* default.prototype._generateResources */.Z.prototype._generateResources = function _generateResources(numberOfResources = 3) {
  // get all resources
  const allResources = this.getSortedByUsedResourceList();

  let result = {};

  switch (this.resourceChoices.type) {
    case "custom": {
      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {
        const resourceLookupName = this.resourceChoices[sheetResources[i]];

        const resource = resourceLookupName && resourceLookupName !== ""
          ? allResources.find((r) => r.label === resourceLookupName)
          : { value: 0, max: 0, sr: false, lr: false, label: "" };
        result[sheetResources[i]] = resource || { value: 0, max: 0, sr: false, lr: false, label: "" };
      };
      break;
    }
    case "disable": {
      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {
        result[sheetResources[i]] = { value: 0, max: 0, sr: false, lr: false, label: "" };
      };
      break;
    }
    case "remove": {
      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {
        result[sheetResources[i]] = { value: 0, max: 0, sr: false, lr: false, label: "" };
      };
      break;
    }
    default: {
      const usedResources = allResources.slice(0, numberOfResources);
      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {
        const resource = usedResources.length > i ? usedResources[i] : { value: 0, max: 0, sr: false, lr: false, label: "" };
        result[sheetResources[i]] = resource;
      };
      break;
    }
  }

  this.resources = result;
  foundry.utils.setProperty(this.raw.character, "flags.ddbimporter.resources", this.resourceChoices);
  foundry.utils.setProperty(this.raw.character, "system.resources", result);
};

DDBCharacter/* default.prototype.getResourceList */.Z.prototype.getResourceList = function getResourceList() {
  return this.getSortedByUsedResourceList();
};

DDBCharacter/* default.prototype._generateResourceSelectionFromForm */.Z.prototype._generateResourceSelectionFromForm = function _generateResourceSelectionFromForm(formData, type) {
  const primary = formData.find((r) => r.name === "primary-select" && r.value !== "");
  const secondary = formData.find((r) => r.name === "secondary-select" && r.value !== "");
  const tertiary = formData.find((r) => r.name === "tertiary-select" && r.value !== "");
  const ask = formData.find((r) => r.name === "ask-resources")?.value === "on";

  const resourceSelection = {
    type: type,
    primary: type === "custom" && primary ? primary.value : "",
    secondary: type === "custom" && secondary ? secondary.value : "",
    tertiary: type === "custom" && tertiary ? tertiary.value : "",
    ask: type === "remove" ? false : ask,
  };

  this.resourceChoices = resourceSelection;
};

DDBCharacter/* default.prototype.setDefaultResources */.Z.prototype.setDefaultResources = function setDefaultResources(sortedResources) {
  if (sortedResources.length >= 1) {
    this.resourceChoices.primary = sortedResources[0].label;
  }
  if (sortedResources.length >= 2) {
    this.resourceChoices.secondary = sortedResources[1].label;
  }
  if (sortedResources.length >= 3) {
    this.resourceChoices.tertiary = sortedResources[2].label;
  }
};

// this.source.ddb, this.raw.character
DDBCharacter/* default.prototype.resourceSelectionDialog */.Z.prototype.resourceSelectionDialog = async function resourceSelectionDialog() {
  return new Promise((resolve) => {
    const sortedResources = this.getSortedByUsedResourceList();

    if (this.resourceChoices.type === "default") {
      this.setDefaultResources(sortedResources);
    }

    if (this.resourceChoices.ask || !foundry.utils.hasProperty(this.resourceChoices, "ask")) {
      const resources = sortedResources.map((resource) => {
        let resourceArray = [];
        if (resource.sr) resourceArray.push("SR");
        if (resource.lr) resourceArray.push("LR");
        if (!resource.sr && !resource.lr) resourceArray.push("Other");
        resource.resetString = resourceArray.join(", ");
        switch (resource.label) {
          case this.resourceChoices.primary:
            resource.primary = true;
            break;
          case this.resourceChoices.secondary:
            resource.secondary = true;
            break;
          case this.resourceChoices.tertiary:
            resource.tertiary = true;
            break;
          // no default
        }
        return resource;
      });

      const dialog = new Dialog({
        title: `Choose Resources for ${this.raw.character.name}`,
        content: {
          "resources": resources,
          "character": this.raw.character.name,
          "img": this.source.ddb.character.decorations?.avatarUrl
            ? this.source.ddb.character.decorations.avatarUrl
            : CONST.DEFAULT_TOKEN,
          "cssClass": "character-resource-selection sheet"
        },
        buttons: {
          default: {
            // icon: '<i class="fas fa-list-ol"></i>',
            // label: "Auto",
            callback: async () => {
              const formData = $('.character-resource-selection').serializeArray();
              this._generateResourceSelectionFromForm(formData, "default");
              this.setDefaultResources(sortedResources);
              this._generateResources();
              resolve(this.raw.character);
            }
          },
          custom: {
            // icon: '<i class="fas fa-sort"></i>',
            // label: "Custom",
            callback: async () => {
              const formData = $('.character-resource-selection').serializeArray();
              this._generateResourceSelectionFromForm(formData, "custom");
              resolve(this.raw.character);
            }
          },
          disable: {
            callback: async () => {
              const formData = $('.character-resource-selection').serializeArray();
              this._generateResourceSelectionFromForm(formData, "disable");
              this._generateResources();
              resolve(this.raw.character);
            }
          },
          remove: {
            callback: async () => {
              const formData = $('.character-resource-selection').serializeArray();
              this._generateResourceSelectionFromForm(formData, "remove");
              this._generateResources();
              resolve(this.raw.character);
            }
          },
        },
        default: "default",
        close: () => resolve(this.raw.character),
      },
      {
        width: 400,
        classes: ["dialog", "character-resource-selection"],
        template: "modules/ddb-importer/handlebars/resources.hbs",
      });
      dialog.render(true);
    } else {
      this._generateResources();
      resolve(this.raw.character);
    }
  });
};

const resourceFeatureLinkMap = {
  "Channel Divinity": ["Channel Divinity:"],
  "Superiority Dice": ["Manoeuvres:", "Maneuvers:"],
  "Sorcery Points": ["Metamagic - ", "Metamagic:", "Hound of Ill Omen"],
  "Bardic Inspiration": [
    "Mote of Potential", "Unsettling Words", "Mantle of Inspiration",
    "Cutting Words", "Peerless Skill", "Tales from Beyond", "Blade Flourish",
    "Defensive Flourish", "Slashing Flourish", "Mobile Flourish",
    "Psychic Blades",
  ],
  "Wild Shape": ["Symbiotic Entity", "Starry Form", "Wild Companion", "Summon Wildfire Spirit"],
  "Grit Points": [
    "Trick Shots:", "Bullying Shot", "Dazing Shot", "Deadeye Shot", "Disarming Shot",
    "Forceful Shot", "Piercing Shot", "Violent Shot", "Winging Shot",
  ],
  "Adept Marksman": [
    "Trick Shots:", "Bullying Shot", "Deadeye Shot", "Disarming Shot", "Piercing Shot", "Rapid Repair",
    "Dazing Shot", "Forceful Shot", "Winging Shot", "Violent Shot"
  ],
  "Psionic Power: Psionic Energy": [
    "Psionic Power: Psionic Strike", "Psionic Power: Protective Field", "Guarded Mind",
    "Psionic Power: Psi-Bolstered Knack", "Soul Blades: Homing Strikes", "Soul Blades: Psychic Teleportation",
    "Psionic Power: Recovery",
  ],
  "Ki Points": [
    "Ki-Fueled Attack", "Flurry of Blows", "Patient Defense", "Step of the Wind",
    "Deflect Missiles Attack", "Arms of the Astral Self: Summon", "Stunning Strike",
    "Empty Body", "Diamond Soul", "Visage of the Astral Self", "Quickened Healing",
    "Focused Aim", "Sharpen the Blade", "Deft Strike", "Shadow Arts",
    "Extort Truth", "Mind of Mercury", "Debilitating Barrage", "Tipsy Sway",
    "Drunkards Luck", "Drunkard's Luck", "Touch of the Long Death",
    "Quivering Palm", "Radiant Sun Bolt", "Searing Arc Strike",
    "Breath of Winter", "Clench of the North Wind", "Eternal Mountain Defense",
    "Fangs of the Fire Snake", "Fist of Four Thunders", "Fist of Unbroken Air",
    "Flames of the Phoenix", "Gong of the Summit", "Mist Stance",
    "Ride the Wind", "River of Hungry Flame", "Rush of the Gale Spirits",
    "Shape the Flowing River", "Sweeping Cinder Strike", "Water Whip",
    "Wave of Rolling Earth", "Hand of Healing", "Hand of Harm", "Hand of Ultimate Mercy",
  ],
  "Infuse Item": ["Infusion:"],
  // "Lay on Hands Pool": ["Lay on Hands"],
  "Maneuver Points": [
    "Carrion Raven Martial Maneuvers:", "Slippery Otter: Activate", "Blade Breaker Maneuvers:"
  ],
  "Jinx Points": ["Misfortunes:", "Curse Caster"]
};

const chargeTypeMap = {
  "Lay on Hands": {
    "type": "none",
  },
};

const resourceSpellLinkMap = {
  "Ki Points": [
    { name: "Astral Projection", cost: 8, lookupName: "Empty Body" },
    { name: "Darkness", cost: 2, lookupName: "Shadow Arts" },
    { name: "Darkvision", cost: 2, lookupName: "Shadow Arts" },
    { name: "Pass Without Trace", cost: 2, lookupName: "Shadow Arts" },
    { name: "Silence", cost: 2, lookupName: "Shadow Arts" },
    { name: "Burning Hands", cost: 2, lookupName: "Searing Arc Strike" },
    { name: "Cone of Cold", cost: 6, lookupName: "Breath of Winter" },
    { name: "Hold Person", cost: 3, lookupName: "Clench of the North Wind" },
    { name: "Stoneskin", cost: 5, lookupName: "Eternal Mountain Defense" },
    { name: "Thunderwave", cost: 2, lookupName: "Fist of Four Thunders" },
    { name: "Fireball", cost: 4, lookupName: "Flames of the Phoenix" },
    { name: "Shatter", cost: 3, lookupName: "Gong of the Summit" },
    { name: "Gaseous Form", cost: 4, lookupName: "Mist Stance" },
    { name: "Fly", cost: 4, lookupName: "Ride the Wind" },
    { name: "Wall of Fire", cost: 5, lookupName: "River of Hungry Flame" },
    { name: "Gust of Wind", cost: 2, lookupName: "Rush of the Gale Spirits" },
    { name: "Burning Hands", cost: 2, lookupName: "Sweeping Cinder Strike" },
    { name: "Wall of Stone", cost: 6, lookupName: "Wave of Rolling Earth" },
  ],
  "Maneuver Points": [
    { name: "Polymorph", cost: 8, lookupName: "Bestial Transformation (8 points)" },
  ],
};

const notReplace = {
  "Starry Form": ["Starry Form: Archer", "Starry Form: Chalice", "Starry Form: Dragon"],
};


DDBCharacter/* default.prototype.fixItemSpellResources */.Z.prototype.fixItemSpellResources = async function fixItemSpellResources() {
  const possibleItems = this.currentActor.items.toObject();
  let toUpdate = [];

  for (const spell of possibleItems) {
    if (spell.type !== "spell") continue;
    if (!foundry.utils.getProperty(spell, "flags.ddbimporter.isItemCharge")) continue;
    if (foundry.utils.getProperty(spell, "flags.ddbimporter.dndbeyond.lookup") !== "item") continue;
    const spellLookupId = foundry.utils.getProperty(spell, "flags.ddbimporter.dndbeyond.lookupId");
    if (!spellLookupId) continue;
    const parentDoc = possibleItems.find((item) =>
      spellLookupId === item.flags?.ddbimporter?.definitionId
    );
    if (!parentDoc) continue;
    toUpdate.push({
      _id: spell._id,
      "system.consume.target": parentDoc._id,
      "system.uses.prompt": false,
    });
  }

  logger/* default.debug */.Z.debug("itemSpellsToUpdate", toUpdate);

  const results = await this.currentActor.updateEmbeddedDocuments("Item", toUpdate);
  logger/* default.debug */.Z.debug("itemSpellsToUpdate results", results);

};


DDBCharacter/* default.prototype.autoLinkResources */.Z.prototype.autoLinkResources = async function autoLinkResources() {
  // loop over resourceFeatureLinkMap
  const possibleItems = this.currentActor.items.toObject();
  let toUpdate = [];

  for (const [resourceDocName, consumingDocs] of Object.entries(resourceFeatureLinkMap)) {
    logger/* default.debug */.Z.debug(`Generic Resource Linking: Checking ${resourceDocName}`, consumingDocs);
    const parent = possibleItems.find((doc) => {
      const name = doc.flags.ddbimporter?.originalName ?? doc.name;
      return name === resourceDocName;
    });

    if (parent) {
      logger/* default.debug */.Z.debug("parent", parent);
      consumingDocs.forEach((consumingDocName) => {
        logger/* default.debug */.Z.debug(`Checking ${consumingDocName}`);
        const children = possibleItems.filter((doc) => {
          const name = doc.flags.ddbimporter?.originalName ?? doc.name;
          const dontReplace = notReplace[consumingDocName]?.includes(name);
          return name.startsWith(consumingDocName) && !dontReplace;
        });

        if (children) {
          logger/* default.debug */.Z.debug(`Found children`, children);
          children.forEach((child) => {
            if (foundry.utils.getProperty(child, "flags.ddbimporter.retainResourceConsumption")) return;
            logger/* default.debug */.Z.debug("child", child);
            const update = {
              _id: child._id
            };
            const charge = foundry.utils.getProperty(child, "system.consume.amount") ?? 1;
            foundry.utils.setProperty(update, "system.consume", {
              type: chargeTypeMap[consumingDocName]?.type ?? "charges",
              target: parent._id,
              amount: charge,
            });
            toUpdate.push(update);
          });
        }
      });
    }
  }

  for (const [key, values] of Object.entries(resourceSpellLinkMap)) {
    logger/* default.debug */.Z.debug(`Resource Spells: Checking ${key}`, values);
    const parent = possibleItems.find((doc) => {
      const name = doc.flags.ddbimporter?.originalName ?? doc.name;
      return name === key;
    });
    if (parent) {
      logger/* default.debug */.Z.debug("parent", parent);
      values.forEach((value) => {
        logger/* default.debug */.Z.debug(`Checking ${value.name}`, value);
        const child = possibleItems.find((doc) => {
          const name = doc.flags.ddbimporter?.originalName ?? doc.name;
          const lookupName = doc.flags.ddbimporter?.dndbeyond?.lookupName ?? "NO_LOOKUP_NAME";
          return name === value.name && value.lookupName === lookupName;
        });

        if (child) {
          if (foundry.utils.getProperty(child, "flags.ddbimporter.retainResourceConsumption")) return;
          logger/* default.debug */.Z.debug("child", child);
          const update = {
            _id: child._id
          };
          foundry.utils.setProperty(update, "system.consume", {
            type: "charges",
            target: parent._id,
            amount: value.cost,
          });
          toUpdate.push(update);
        }
      });
    }
  }

  logger/* default.debug */.Z.debug("toUpdate", toUpdate);

  const results = await this.currentActor.updateEmbeddedDocuments("Item", toUpdate);
  logger/* default.debug */.Z.debug("resource Update results", results);
};

// EXTERNAL MODULE: ./src/parser/spells/metadata.js
var metadata = __webpack_require__(6721);
// EXTERNAL MODULE: ./src/parser/spells/special.js
var special = __webpack_require__(1838);
// EXTERNAL MODULE: ./src/parser/spells/parseSpell.js + 12 modules
var parseSpell = __webpack_require__(1702);
// EXTERNAL MODULE: ./src/parser/spells/ability.js
var ability = __webpack_require__(2352);
;// CONCATENATED MODULE: ./src/parser/spells/getItemSpells.js
/* eslint-disable no-continue */


// Import parsing functions






function getSpellCount(dict, name) {
  if (!dict[name]) {
    dict[name] = 0;
  }
  return ++dict[name];
}

async function getItemSpells(ddb, character) {
  let items = [];
  const proficiencyModifier = character.system.attributes.prof;
  const lookups = (0,metadata/* getLookups */.t)(ddb.character);

  const spellCountDict = {};

  // feat spells are handled slightly differently
  for (const spell of ddb.character.spells.item) {
    if (!spell.definition) continue;

    const itemInfo = lookups.item.find((it) => it.id === spell.componentId);
    if (!itemInfo) continue;

    const active
      = (!itemInfo.canEquip && !itemInfo.canAttune) // if item just gives a thing
      || itemInfo.isAttuned // if it is attuned (assume equipped)
      || (!itemInfo.canAttune && itemInfo.equipped); // can't attune but is equipped
    // for item spells the spell dc is often on the item spell
    let spellDC = 8;
    if (spell.overrideSaveDc) {
      spellDC = spell.overrideSaveDc;
    } else if (spell.spellCastingAbilityId) {
      // If the spell has an ability attached, use that
      // if there is no ability on spell, we default to wis
      let spellCastingAbility = "wis";
      if ((0,ability/* hasSpellCastingAbility */.eO)(spell.spellCastingAbilityId)) {
        spellCastingAbility = (0,ability/* convertSpellCastingAbilityId */.f5)(spell.spellCastingAbilityId);
      }

      const abilityModifier = utils/* default.calculateModifier */.Z.calculateModifier(character.flags.ddbimporter.dndbeyond.effectAbilities[spellCastingAbility].value);
      spellDC = 8 + proficiencyModifier + abilityModifier;
    } else {
      spellDC = null;
    }

    // add some data for the parsing of the spells into the data structure
    spell.flags = {
      ddbimporter: {
        dndbeyond: {
          lookup: "item",
          lookupName: itemInfo.name,
          lookupId: itemInfo.id,
          level: spell.castAtLevel,
          dc: spellDC,
          limitedUse: itemInfo.limitedUse,
          nameOverride: `${spell.definition.name} (${itemInfo.name})`,
          overrideDC: !!spell.overrideSaveDc,
          spellLimitedUse: spell.limitedUse,
          castAtLevel: spell.castAtLevel,
          active: active,
        },
      },
    };
    const namePostfix = `It${getSpellCount(spellCountDict, spell.definition.name)}`;
    items.push(await (0,parseSpell/* parseSpell */.T)(spell, character, { namePostfix: namePostfix }));
  }

  if (items) {
    await (0,special/* fixSpells */.F)(ddb, items);
  }

  return items;
}

;// CONCATENATED MODULE: ./src/parser/character/inventory.js




DDBCharacter/* default.prototype._generateInventory */.Z.prototype._generateInventory = async function _generateInventory() {
  this.raw.itemSpells = await getItemSpells(this.source.ddb, this.raw.character);
  logger/* default.debug */.Z.debug("Item Spells parse complete");
  this.raw.inventory = await this.getInventory();
  logger/* default.debug */.Z.debug("Inventory parse complete");
};

;// CONCATENATED MODULE: ./src/parser/character/globalBonuses.js



/**
 * Gets global bonuses to attacks and damage
 * Supply a list of maps that have the fvtt tyoe and ddb sub type, e,g,
 * { fvttType: "attack", ddbSubType: "magic" }
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} lookupTable
 */
DDBCharacter/* default.prototype.getGlobalBonusAttackModifiers */.Z.prototype.getGlobalBonusAttackModifiers = function(lookupTable) {
  let result = {
    attack: "",
    damage: "",
  };
  const diceFormula = /\d*d\d*/;

  let lookupResults = {
    attack: {
      sum: 0,
      diceString: "",
    },
    damage: {
      sum: 0,
      diceString: "",
    },
  };

  lookupTable.forEach((b) => {
    const lookupResult = DDBHelper/* default.getModifierSum */.Z.getModifierSum(DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: b.ddbSubType }), this.raw.character);
    const lookupMatch = diceFormula.test(lookupResult);

    // if a match then a dice string
    if (lookupMatch || !Number.isInteger(parseInt(lookupResult))) {
      lookupResults[b.fvttType].diceString += lookupResult === "" ? lookupResult : " + " + lookupResult;
    } else {
      lookupResults[b.fvttType].sum += parseInt(lookupResult);
    }
  });

  // loop through outputs from lookups and build a response
  ["attack", "damage"].forEach((fvttType) => {
    if (lookupResults[fvttType].diceString === "") {
      if (lookupResults[fvttType].sum !== 0) {
        result[fvttType] = `${lookupResults[fvttType].sum}`;
      }
    } else {
      result[fvttType] = lookupResults[fvttType].diceString;
      if (lookupResults[fvttType].sum !== 0) {
        result[fvttType] += " + " + lookupResults[fvttType].sum;
      }
    }
  });

  return result;
};

/**
 * Gets global bonuses to spell attacks and damage
 * Most likely from items such as wand of the warmage
 * supply type as 'ranged' or 'melee'
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} type
 */
DDBCharacter/* default.prototype.getBonusSpellAttacks */.Z.prototype.getBonusSpellAttacks = function(type) {
  // I haven't found any matching global spell damage boosting mods in ddb
  const bonusLookups = [
    { fvttType: "attack", ddbSubType: "spell-attacks" },
    { fvttType: "attack", ddbSubType: `${type}-spell-attacks` },
    { fvttType: "attack", ddbSubType: "warlock-spell-attacks" },
  ];

  return this.getGlobalBonusAttackModifiers(bonusLookups);
};

DDBCharacter/* default.prototype._generateBonusSpellAttacks */.Z.prototype._generateBonusSpellAttacks = function() {
  this.raw.character.system.bonuses.rsak = this.getBonusSpellAttacks("ranged");
  this.raw.character.system.bonuses.msak = this.getBonusSpellAttacks("melee");
};


/**
 * Gets global bonuses to weapon attacks and damage
 * Most likely from items such as wand of the warmage
 * supply type as 'ranged' or 'melee'
  {
    "attack": "",
    "damage": "",
  },
 * @param {*} type
 */
DDBCharacter/* default.prototype.getBonusWeaponAttacks */.Z.prototype.getBonusWeaponAttacks = function(type) {
  // global melee damage is not a ddb type, in that it's likely to be
  // type specific. The only class one I know of is the Paladin Improved Smite
  // which will be handled in the weapon import later.
  const bonusLookups = [
    { fvttType: "attack", ddbSubType: `${type}-attacks` },
    { fvttType: "attack", ddbSubType: "weapon-attacks" },
    { fvttType: "attack", ddbSubType: `${type}-weapon-attacks` },
  ];

  return this.getGlobalBonusAttackModifiers(bonusLookups);
};

DDBCharacter/* default.prototype._generateBonusWeaponAttacks */.Z.prototype._generateBonusWeaponAttacks = function() {
  this.raw.character.system.bonuses.mwak = this.getBonusWeaponAttacks("melee");
  this.raw.character.system.bonuses.rwak = this.getBonusWeaponAttacks("ranged");
};

/**
 * Gets global bonuses to ability checks, saves and skills
 * These can come from Paladin auras or items etc
  "abilities": {
    "check": "",
    "save": "",
    "skill": ""
  },
 * @param {*} this.raw.character
 */
DDBCharacter/* default.prototype._generateBonusAbilities */.Z.prototype._generateBonusAbilities = function() {
  let result = {
    "check": "",
    "save": "",
    "skill": "",
  };
  const bonusLookup = [
    { fvttType: "check", ddbSubType: "ability-checks" },
    { fvttType: "save", ddbSubType: "saving-throws" },
    { fvttType: "skill", ddbSubType: "skill-checks" },
  ];

  bonusLookup.forEach((b) => {
    const mods = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: b.ddbSubType });
    const bonus = DDBHelper/* default.getModifierSum */.Z.getModifierSum(mods, this.raw.character);
    if (bonus !== 0 && bonus !== "") result[b.fvttType] = `+ ${bonus}`.trim().replace(/\+\s*\+/, "+");
  });
  this.raw.character.system.bonuses.abilities = result;
};

DDBCharacter/* default.prototype._generateBonusSpellDC */.Z.prototype._generateBonusSpellDC = function() {
  let result = {
    "dc": "",
  };
  const bonusLookup = [
    { fvttType: "dc", ddbSubType: "spell-save-dc" },
    { fvttType: "dc", ddbSubType: "warlock-spell-save-dc" },
  ];

  const bonus = bonusLookup.map((b) => {
    return DDBHelper/* default.getModifierSum */.Z.getModifierSum(DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(this.source.ddb, "bonus", { subType: b.ddbSubType }), this.raw.character);
  })
    .filter((b) => b && b !== 0 && String(b).trim() !== "")
    .reduce((previous, current) => {
      return previous !== "" ? [previous, current].join(" + ") : current;
    }, "");

  if (bonus && String(bonus).trim() !== "") {
    result["dc"] = bonus;
  }

  this.raw.character.system.bonuses.spell = result;
};

;// CONCATENATED MODULE: ./src/parser/special/additions/divineSmite.js
// import DICTIONARY from '../dictionary.js';



function getDivineSmiteSpell(feature) {
  const restriction = "Against undead or fiends";

  const damageTagInfo = DDBHelper/* default.getDamageTag */.Z.getDamageTag({ subType: "radiant", restriction: "" });
  const regularDamage = utils/* default.parseDiceString */.Z.parseDiceString("2d8", "", damageTagInfo.damageTag).diceString;
  const extraDamageTagInfo = DDBHelper/* default.getDamageTag */.Z.getDamageTag({ subType: "radiant", restriction });
  const extraDamage = utils/* default.parseDiceString */.Z.parseDiceString("1d8", "", extraDamageTagInfo.damageTag).diceString;

  let result = {
    flags: {
      ddbimporter: {
        ignoreItemUpdate: true,
      },
    },
    midiProperties: {
      critOther: true,
      magicdam: true,
      magiceffect: true,
    },
    "midi-qol": {
      otherCondition: `["fiend", "undead"].includes(raceOrType)`,
    },
    name: "Divine Smite",
    type: "spell",
    img: "icons/skills/melee/weapons-crossed-swords-yellow-teal.webp",
    system: {
      description: {
        value: feature.system.description.value,
        chat: "",
      },
      source: "PHB PG. 85",
      activation: {
        type: "special",
        cost: null,
        condition: "",
      },
      duration: {
        value: null,
        units: "",
      },
      target: {
        value: 1,
        units: "",
        type: "enemy",
      },
      range: {
        value: null,
        long: null,
        units: "",
      },
      uses: {
        value: 0,
        max: 0,
        per: "",
      },
      consume: {
        type: "",
        target: "",
        amount: null,
      },
      ability: "",
      actionType: "other",
      attack: {
        bonus: 0,
      },
      chatFlavor: "",
      critical: null,
      damage: {
        parts: [
          [`${regularDamage}`, "radiant"],
        ],
        versatile: "",
      },
      formula: "",
      save: {
        ability: "",
        dc: null,
        scaling: "spell",
      },
      level: 1,
      school: "",
      properties: ["mgc"],
      materials: {
        value: "",
        consumed: false,
        cost: 0,
        supply: 0,
      },
      preparation: {
        mode: "always",
        prepared: true,
      },
      scaling: {
        mode: "level",
        formula: "1d8",
      },
    },
  };

  result.system.formula = `${regularDamage} + ${extraDamage}`;
  result.system.chatFlavor = `Use Other damage ${restriction.toLowerCase()}`;
  if (game.modules.get("midi-qol")?.active) {
    // result.system.activation.condition = `["undead", "fiend"].includes("@raceOrType")`;
    foundry.utils.setProperty(document, "flags.midi-qol.effectCondition", `["undead", "fiend"].includes("@raceOrType")`);
  }

  return result;
}


;// CONCATENATED MODULE: ./src/parser/special/character.js



DDBCharacter/* default.prototype._addSpecialAdditions */.Z.prototype._addSpecialAdditions = function _addSpecialAdditions() {
  const checkList = this.data.features.concat(this.data.actions);
  const divineSmite = checkList.find((f) => f.name === "Divine Smite" && f.type === "feat");
  if (divineSmite) {
    this.data.spells.push(getDivineSmiteSpell(divineSmite));
  }

  const feyAncestry = checkList.find((f) => f.name === "Fey Ancestry" && f.type === "feat");
  if (feyAncestry && (foundry.utils.getProperty(feyAncestry, "system.description.value") ?? "").includes("sleep")) {
    const ci = ["Sleep"];
    if (this.data.character.system.traits.ci.custom && this.data.character.system.traits.ci.custom.trim() !== "")
      ci.push(this.data.character.system.traits.ci.custom);
    this.data.character.system.traits.ci.custom = ci.join(";");
  }
};

// EXTERNAL MODULE: ./src/lib/DDBReferenceLinker.js
var DDBReferenceLinker = __webpack_require__(7162);
;// CONCATENATED MODULE: ./src/parser/item/common.js



function getDescription(data, document) {
  const chatSnippet = data.definition.snippet ? data.definition.snippet : "";
  const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");

  const attunementText = data.definition.canAttune && data.definition.attunementDescription && data.definition.attunementDescription !== ""
    ? `<div class="item-attunement"><i>(Requires attunement by a ${data.definition.attunementDescription})</i></div>`
    : "";

  const valueDamageText = (0,DDBReferenceLinker/* parseDamageRolls */.IP)({ text: data.definition.description, document, actor: null });
  const chatDamageText = chatAdd ? (0,DDBReferenceLinker/* parseDamageRolls */.IP)({ text: chatSnippet, document, actor: null }) : "";
  return {
    value: (0,DDBReferenceLinker/* parseTags */.RN)(attunementText + valueDamageText),
    chat: chatAdd ? (0,DDBReferenceLinker/* parseTags */.RN)(chatDamageText) : "",
  };
}

function getCurrency(data) {
  return {
    cp: data.currency?.cp ?? 0,
    sp: data.currency?.sp ?? 0,
    ep: data.currency?.ep ?? 0,
    gp: data.currency?.gp ?? 0,
    pp: data.currency?.pp ?? 0,
  };
}

function getPrice(data) {
  const value = data.definition.cost ? Number.parseFloat(data.definition.cost) : 0;
  const price = {
    "value": Number.isInteger(value) ? value : (value * 10),
    "denomination": Number.isInteger(value) ? "gp" : "sp"
  };

  return price;
}

function getItemRarity(data) {
  const tmpRarity = data.definition.rarity;
  const isMundaneItem = data.definition?.rarity === "Common" && !data.definition.magic;
  const rarity = data.definition.rarity && !isMundaneItem
    ? tmpRarity.charAt(0).toLowerCase() + tmpRarity.slice(1).replace(/\s/g, "")
    : "";
  return rarity;
}

/**
 * Checks if the character can attune to an item and if yes, if he is attuned to it.
 */
function getAttuned(data) {
  if (data.definition.canAttune !== undefined && data.definition.canAttune === true) {
    return data.isAttuned;
  } else {
    return false;
  }
}

/**
 * Checks if the character can equip an item and if yes, if he is has it currently equipped.
 */
function getEquipped(data) {
  if (data.definition.canEquip !== undefined && data.definition.canEquip === true) {
    return data.equipped;
  } else {
    return false;
  }
}

function getRechargeFormula(description, maxCharges) {
  if (description === "" || !description) {
    return `${maxCharges}`;
  }

  let chargeMatchFormula = /regains (\dd\d* \+ \d) expended charges/i;
  let chargeMatchFixed = /regains (\d*) /i;
  let chargeMatchLastDitch = /(\dd\d* \+ \d)/i;
  let chargeNextDawn = /can't be used this way again until the next/i;

  let matchFormula = chargeMatchFormula.exec(description);
  let matchFixed = chargeMatchFixed.exec(description);
  let matchLastDitch = chargeMatchLastDitch.exec(description);

  let match = maxCharges;
  if (matchFormula && matchFormula[1]) {
    match = matchFormula[1];
  } else if (matchFixed && matchFixed[1]) {
    match = matchFixed[1];
  } else if (matchLastDitch && matchLastDitch[1]) {
    match = matchLastDitch[1];
  } else if (description.search(chargeNextDawn) !== -1) {
    match = maxCharges;
  }

  return `${match}`;
}

/**
 * Gets Limited uses information, if any
 * uses: { value: 0, max: 0, per: null }
 */
function getUses(data, prompt = false) {
  if (data.limitedUse !== undefined && data.limitedUse !== null && data.limitedUse.resetTypeDescription !== null) {
    let resetType = dictionary/* default.resets.find */.Z.resets.find((reset) => reset.id == data.limitedUse.resetType);

    const recovery = getRechargeFormula(data.limitedUse.resetTypeDescription, data.limitedUse.maxUses);
    return {
      max: data.limitedUse.maxUses,
      value: data.limitedUse.numberUsed
        ? data.limitedUse.maxUses - data.limitedUse.numberUsed
        : data.limitedUse.maxUses,
      per: resetType ? resetType.value : "",
      description: data.limitedUse.resetTypeDescription,
      recovery,
      prompt,
    };
  } else {
    return { value: 0, max: 0, per: null, prompt };
  }
}

function getConsumableUses(data) {
  if (data.limitedUse) {
    let uses = getUses(data, true);
    if (uses.per === "") uses.per = "charges";
    uses.autoDestroy = true;
    return uses;
  } else {
    // default
    return { value: 1, max: 1, per: "charges", autoUse: false, autoDestroy: true };
  }
}

/**
 * Checks the proficiency of the character with this specific weapon
 * @param {obj} data Item data
 * @param {string} weaponType The DND5E weaponType
 * @param {array} proficiencies The character's proficiencies as an array of `{ name: 'PROFICIENCYNAME' }` objects
 */
function getWeaponProficient(data, weaponType, proficiencies) {
  // if it's a simple weapon and the character is proficient in simple weapons:
  if (
    proficiencies.some((proficiency) => proficiency.name === "Simple Weapons")
    && weaponType.indexOf("simple") !== -1
  ) {
    return true;
  } else if (
    proficiencies.some((proficiency) => proficiency.name === "Martial Weapons")
    && weaponType.indexOf("martial") !== -1
  ) {
    return true;
  } else {
    const proficient = proficiencies.some((proficiency) => proficiency.name.toLowerCase() === data.definition.type.toLowerCase());
    if (proficient) return proficient;
  }
  return null;
};

/**
 * Searches for a magical attack bonus granted by this weapon
 * @param {obj} data item data
 */
function getMagicalBonus(data, returnZero = false) {
  const boni = data.definition.grantedModifiers.filter(
    (mod) => mod.type === "bonus" && mod.subType === "magic" && mod.value && mod.value !== 0
  );
  const bonus = boni.reduce((prev, cur) => prev + cur.value, 0);
  return bonus === 0 && !returnZero ? "" : bonus;
}

function getAttunement(item) {
  if (item.isAttuned || item.definition.canAttune) {
    if (item.definition.name.startsWith("Spell Gem")) {
      return "optional";
    }
    return "required";
  } else {
    return "";
  }
}

/**
 * Retrieves the base item and tool type based on the provided data definition.
 *
 * @param {Object} data - The data definition object
 * @return {Object} An object containing the base item and tool type
 */
function getBaseItem(data) {
  let baseItem;
  let toolType;

  if (data.definition.filterType === "Weapon") {
    baseItem = data.definition.type.toLowerCase().split(",").reverse().join("").replace(/\s/g, "");
  } else if (data.definition.filterType === "Armor" && data.definition.baseArmorName) {
    baseItem = data.definition.baseArmorName.toLowerCase().split(",").reverse().join("").replace(/\s/g, "");
  } else if (data.definition.filterType === "Other Gear"
    && ((data.definition.gearTypeId === 1 && data.definition.subType === "Tool")
      || (data.definition.gearTypeId === 11))) {
    const toolProficiencies = dictionary/* default.character.proficiencies.filter */.Z.character.proficiencies.filter((prof) => prof.type === "Tool")
      .map((prof) => {
        return prof;
      });

    const baseTool = toolProficiencies.find((allProf) => allProf.name.toLowerCase() === data.definition.name.toLowerCase());
    if (baseTool && baseTool.baseTool) {
      baseItem = baseTool.baseTool;
      toolType = baseTool.toolType;
    }
  } else if (data.definition.filterType === "Staff") {
    baseItem = "quarterstaff";
  }


  return { baseItem, toolType };
}

function getQuantity(data) {
  return data.definition.quantity
    ? data.definition.quantity
    : data.quantity
      ? data.quantity
      : 1;
}

function getSingleItemWeight(data) {
  const bundleSize = data.definition?.bundleSize ? data.definition.bundleSize : 1;
  const totalWeight = data.definition?.weight ? data.definition.weight : 0;
  const weight = totalWeight / bundleSize;
  return {
    value: weight,
    units: "lb"
  };
}

function getWeightless(data) {
  return data.definition.weightMultiplier === 0;
}

function getCapacity(data) {

  const capacity = (data.definition.capacityWeight !== null)
    ? {
      "type": "weight",
      "value": data.definition.capacityWeight,
    }
    : {};

  return capacity;
}

;// CONCATENATED MODULE: ./src/parser/item/magicify.js




const MAGICITEMS = {
  DAILY: "r1",
  SHORT_REST: "r4",
  LONG_REST: "r5",
  CHARGE_TYPE_WHOLE_ITEM: "c1",
  CHARGE_TYPE_PER_SPELL: "c2",
  NUMERIC_RECHARGE: "t1",
  FORMULA_RECHARGE: "t2",
  DestroyCheckAlways: "d1",
  DestroyCheck1D20: "d2",
};

// const ITEM_CONSUME_CORRECTIONS = {
//   "Staff of Defense": 1,
// };

function getPerSpell(useDescription, itemDescription) {
  if (useDescription === "") {
    // some times 1 use per day items, like circlet of blasting have nothing in
    // the limited use description, fall back to this
    let limitedUse = /can't be used this way again until the next|cant be used to cast that spell again until the next/i;
    if (itemDescription.replace("", "'").search(limitedUse) !== -1) {
      return true;
    }
    return false;
  }

  let perSpell = /each ([A-z]*|\n*) per/i;
  let match = perSpell.exec(useDescription);
  if (match) {
    match = dictionary/* default.magicitems.nums.find */.Z.magicitems.nums.find((num) => num.id == match[1]).value;
  } else {
    match = false;
  }
  return match;
}

function checkDestroy(description) {
  let destroy = /expend the .* last charge/i;
  if (description.search(destroy) !== -1) {
    return true;
  } else {
    return false;
  }
}

function checkD20Destroy(description) {
  let destroy = /roll a d20.*destroyed/i;
  if (description.search(destroy) !== -1) {
    return MAGICITEMS.DestroyCheck1D20;
  } else {
    return MAGICITEMS.DestroyCheckAlways;
  }
}

// returns the default magicitem flags
function buildMagicItemSpell(chargeType, itemSpell) {
  let consumption = chargeType == MAGICITEMS.CHARGE_TYPE_PER_SPELL ? 1 : itemSpell.system.level;
  let castLevel = itemSpell.system.level;
  let upcast = itemSpell.system.level;

  // Do we have charge use data on spell?
  if (itemSpell.flags.ddbimporter.dndbeyond.spellLimitedUse) {
    const limitedUse = itemSpell.flags.ddbimporter.dndbeyond.spellLimitedUse;

    if (
      chargeType == MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM
      && !!limitedUse.minNumberConsumed
      && itemSpell.system.level !== 0
    ) {
      consumption = limitedUse.minNumberConsumed;
      if (limitedUse.maxNumberConsumed) {
        upcast = itemSpell.system.level - limitedUse.minNumberConsumed + limitedUse.maxNumberConsumed;
      }
    }

    if (itemSpell.flags.ddbimporter.dndbeyond.castAtLevel) {
      castLevel = itemSpell.flags.ddbimporter.dndbeyond.castAtLevel;
    }
  }
  const spellName = foundry.utils.hasProperty(itemSpell, "flags.ddbimporter.originalName")
    ? itemSpell.flags.ddbimporter.originalName
    : itemSpell.name;

  return {
    id: "",
    name: spellName,
    img: "",
    pack: "",
    baseLevel: itemSpell.system.level,
    level: castLevel,
    consumption,
    upcast,
    upcastCost: 1,
  };
}

function getMagicItemSpells(itemId, chargeType, itemSpells) {
  let spells = {};

  for (let spellIndex = 0, i = 0; i < itemSpells.length; i++) {
    if (itemSpells[i].flags.ddbimporter.dndbeyond.lookupId === itemId) {
      spells[spellIndex] = buildMagicItemSpell(chargeType, itemSpells[i]);
      spellIndex++;
    }
  }

  return spells;
}

function createDefaultMagicItemFlags() {
  return {
    enabled: true,
    charges: 0,
    chargeType: MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM, // c1 charge whole item, c2 charge per spells
    rechargeable: false,
    recharge: "0", // recharge amount/formula
    rechargeType: MAGICITEMS.FORMULA_RECHARGE, // t1 fixed amount, t2 formula
    rechargeUnit: "", // r1 daily, r2 dawn, r3 sunset, r4vshort rest, r5 long rest
    destroy: false, // destroy on depleted?
    destroyCheck: MAGICITEMS.DestroyCheckAlways, // d1 always, 1d20
    spells: {},
    feats: {},
    tables: {},
    equipped: true,
    attuned: false,
    destroyFlavorText: game.modules.get("magicitems")?.active
      ? game.i18n.localize("MAGICITEMS.MagicItemDestroy")
      : "reaches 0 charges: it crumbles into ashes and is destroyed.",
    sorting: "l"
  };
}

function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function getMagicItemResetType(description) {
  let resetType = null;

  const chargeMatchFormula = /expended charges (?:\w+|each day) at (\w+)/i;
  const usedAgainFormula = /(?:until|when) you (?:take|finish) a (short|long|short or long) rest/i;
  const chargeNextDawnFormula = /can't be used this way again until the next (dawn|dusk)/i;

  const chargeMatch = chargeMatchFormula.exec(description);
  const untilMatch = usedAgainFormula.exec(description);
  const dawnMatch = chargeNextDawnFormula.exec(description);

  if (chargeMatch && chargeMatch[1] && ["dawn", "dusk"].includes(chargeMatch[1].toLowerCase())) {
    resetType = chargeMatch[1].toLowerCase();
  } else if (chargeMatch && chargeMatch[1] && ["sunset"].includes(chargeMatch[1].toLowerCase())) {
    resetType = "dusk";
  } else if (dawnMatch && dawnMatch[1]) {
    resetType = capitalize(dawnMatch[1].toLowerCase());
  } else if (chargeMatch && chargeMatch[1]) {
    resetType = "day";
  } else if (untilMatch && untilMatch[1]) {
    switch (untilMatch[1]) {
      case "short or long":
        resetType = "sr";
        break;
      default:
        resetType = capitalize(`${untilMatch[1]}Rest`);
    }
  }

  // console.warn("reset type", {
  //   chargeMatch,
  //   untilMatch,
  //   dawnMatch,
  //   description,
  //   resetType,
  // });

  return resetType;
}

//
// Attempts to parse information from ddb about items to build a magicitems
// compatible set of metadata.
//
// https://gitlab.com/riccisi/foundryvtt-magic-items/
//
// Wand of Entangle Target example
//
// flags": {
// "magicitems": {
//       "enabled": true,
//       "charges": "7",
//       "chargeType": "c1",
//       "destroy": true,
//       "destroyCheck": "d1",
//       "rechargeable": true,
//       "recharge": "1d6+1",
//       "rechargeType": "t2",
//       "rechargeUnit": "r2",
//       "spells": {
//           "0": {
//               "id": "af8QUpphSZMoi2yb",
//               "name": "Entangle",
//               "pack": "world.spellsdndbeyond",
//               "img": "iconizer/Spell_Nature_StrangleVines.png",
//               "baseLevel": "1",
//               "level": "1",
//               "consumption": "1",
//               "upcast": "1",
//               "upcastCost": "1"
//           }
//       }
// "feats": {},
// "tables": {},
// "equipped": true,
// "attuned": true,
// "destroyFlavorText": "reaches 0 charges: it crumbles into ashes and is destroyed.",
// "sorting": "l"

// }
function parseMagicItemsModule(data, itemSpells, isCompendiumItem) {
  // this builds metadata for the magicitems module to use
  // https://gitlab.com/riccisi/foundryvtt-magic-items/

  if (data.definition.magic) {
    // default magicitem data
    let magicItem = createDefaultMagicItemFlags();
    magicItem.equipped = data.definition.canEquip;

    const resetType = getMagicItemResetType(data.definition.description);

    if (isCompendiumItem) {
      const maxUses = /has (\d*) charges/i;
      const maxUsesMatches = maxUses.exec(data.definition.description);
      const limitedUse = {
        maxUses: (maxUsesMatches && maxUsesMatches[1]) ? maxUsesMatches[1] : null,
        numberUsed: 0,
        resetType,
        resetTypeDescription: data.definition.description,
      };

      if (limitedUse.maxUses || limitedUse.resetType) data.limitedUse = limitedUse;
    }

    if (data.limitedUse) {
      // if the item is x per spell
      const perSpell = getPerSpell(data.limitedUse.resetTypeDescription, data.definition.description);
      if (perSpell) {
        magicItem.charges = 1;
        magicItem.recharge = `1`;
        magicItem.rechargeUnit = MAGICITEMS.DAILY;
        magicItem.rechargeable = true;
        magicItem.rechargeType = MAGICITEMS.NUMERIC_RECHARGE;
        magicItem.chargeType = MAGICITEMS.CHARGE_TYPE_PER_SPELL;
      } else {
        magicItem.charges = data.limitedUse.maxUses;
        magicItem.recharge = getRechargeFormula(data.limitedUse.resetTypeDescription, magicItem.charges);

        if (data.limitedUse.resetType) {
          magicItem.rechargeUnit = dictionary/* default.magicitems.rechargeUnits.find */.Z.magicitems.rechargeUnits.find(
            (reset) => reset.id == data.limitedUse.resetType
          )?.value ?? "";
        } else {
          magicItem.rechargeUnit = dictionary/* default.magicitems.rechargeUnits.find */.Z.magicitems.rechargeUnits.find(
            (reset) => reset.id == resetType
          )?.value ?? "";
        }
        magicItem.rechargeable = true;
      }

      magicItem.destroy = checkDestroy(data.limitedUse.resetTypeDescription);
      magicItem.destroyCheck = checkD20Destroy(data.limitedUse.resetTypeDescription);
    }

    magicItem.spells = getMagicItemSpells(data.definition.id, magicItem.chargeType, itemSpells);

    return magicItem;
  } else {
    return {
      enabled: false,
    };
  }
}

function parseItemsWithSpellsModule(item, data, itemSpells, isCompendiumItem) {

  if (isCompendiumItem) {
    logger/* default.debug */.Z.debug("Non character item magic item additions are not supported");
  }

  const thisItemSpells = itemSpells.filter((spell) =>
    spell.flags.ddbimporter.dndbeyond.lookup === "item"
    && spell.flags.ddbimporter.dndbeyond.lookupId === item.flags.ddbimporter.definitionId
  );

  if (thisItemSpells.length === 0) return item;

  const perSpell = getPerSpell(data.limitedUse?.resetTypeDescription ?? "", data.definition.description);

  if (!perSpell && foundry.utils.getProperty(item, "system.uses.value") === null) {
    item.system.uses = getUses(data);
  }

  const iSpells = thisItemSpells.map((itemSpell) => {
    const isPerSpell = Number.isInteger(perSpell);
    const chargeType = isPerSpell
      ? MAGICITEMS.CHARGE_TYPE_PER_SPELL
      : MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM;

    // c1 charge whole item, c2 charge per spells
    const spellData = buildMagicItemSpell(chargeType, itemSpell);

    const resetType = data.limitedUse?.resetType
      ? dictionary/* default.resets.find */.Z.resets.find((reset) =>
        reset.id == data.limitedUse.resetType
      )?.value ?? undefined
      : undefined;

    const uses = isPerSpell
      ? { max: spellData.charges, per: resetType ?? "" }
      : { max: "", per: "" };
    const consume = isPerSpell
      ? { amount: null }
      : { amount: spellData.consumption };

    const save = foundry.utils.getProperty(itemSpell, "flags.ddbimporter.dndbeyond.overrideDC")
      ? { scaling: "flat", dc: itemSpell.flags.ddbimporter.dndbeyond?.dc }
      : { scaling: "spell" };
    const preparation = isPerSpell
      ? { mode: "atwill" }
      : undefined;

    return {
      uuid: "",
      changes: {
        system: {
          level: Number.parseInt(spellData.level),
          uses,
          consume,
          save,
          preparation,
        },
      },
      flags: {
        ddbimporter: {
          spellName: spellData.name,
        },
        // "items-with-spells-5e": {
        //   "parent-item": "",
        // },
      },
    };
  });

  item.flags["items-with-spells-5e"] = {
    "item-spells": iSpells,
  };
  return item;
}

function basicMagicItem(item, data, itemSpells, isCompendiumItem) {
  if (!data.definition.magic) return item;

  if (isCompendiumItem) {
    const maxUses = /has (\d*) charges/i;
    const maxUsesMatches = maxUses.exec(data.definition.description);
    const limitedUse = {
      maxUses: (maxUsesMatches && maxUsesMatches[1]) ? maxUsesMatches[1] : null,
      numberUsed: 0,
      resetType: getMagicItemResetType(data.definition.description),
      resetTypeDescription: data.definition.description,
    };

    if (limitedUse.maxUses) {
      foundry.utils.setProperty(item, "system.uses.value", parseInt(limitedUse.maxUses));
      foundry.utils.setProperty(item, "system.uses.max", `${limitedUse.maxUses}`);
      foundry.utils.setProperty(item, "system.uses.per", (limitedUse.resetType ?? "charges"));

      const recharge = getRechargeFormula(data.definition.description, limitedUse.maxUses);
      foundry.utils.setProperty(item, "system.uses.recovery", recharge);
    }
    return item;
  }


  // if the item is x per spell
  const isPerSpell = data.limitedUse
    ? getPerSpell(data.limitedUse.resetTypeDescription, data.definition.description)
    : false;

  const chargeType = isPerSpell
    ? MAGICITEMS.CHARGE_TYPE_PER_SPELL
    : MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM;

  itemSpells.forEach((spell) => {
    const isItemSpell = spell.flags.ddbimporter.dndbeyond.lookup === "item"
      && spell.flags.ddbimporter.dndbeyond.lookupId === item.flags.ddbimporter.definitionId;
    if (isItemSpell) {
      logger/* default.debug */.Z.debug(`Adding spell ${spell.name} to item ${item.name}`);
      const spellData = buildMagicItemSpell(chargeType, spell);

      const resetType = data.limitedUse?.resetType
        ? dictionary/* default.resets.find */.Z.resets.find((reset) =>
          reset.id == data.limitedUse.resetType
        )?.value ?? undefined
        : undefined;

      const uses = isPerSpell
        ? { max: spellData.charges, per: resetType ?? "" }
        : { max: "", per: "" };
      const consume = isPerSpell
        ? { amount: null }
        : {
          amount: spellData.consumption,
          type: "charges",
          target: item._id,
        };

      foundry.utils.setProperty(spell, "flags.ddbimporter.isItemCharge", !isPerSpell);

      const save = foundry.utils.getProperty(spell, "flags.ddbimporter.dndbeyond.overrideDC")
        ? { scaling: "flat", dc: spell.flags.ddbimporter.dndbeyond?.dc }
        : { scaling: "spell" };

      // console.warn("Setting Magic Item Properties for Spell", {
      //   level: spellData.level,
      //   uses,
      //   consume,
      //   save,
      // });

      foundry.utils.setProperty(spell, "system.level", Number.parseInt(spellData.level));
      foundry.utils.setProperty(spell, "system.uses", uses);
      foundry.utils.setProperty(spell, "system.consume", consume);
      foundry.utils.setProperty(spell, "system.save", save);
    }

  });

  return item;
}

function parseMagicItem(item, data, itemSpells, isCompendiumItem = false) {
  if (game.modules.get("magicitems")?.active || game.modules.get("magic-items-2")?.active) {
    item.flags.magicitems = parseMagicItemsModule(data, itemSpells, !isCompendiumItem, true);
  } else if (game.modules.get("items-with-spells-5e")?.active) {
    item = parseItemsWithSpellsModule(item, data, itemSpells, !isCompendiumItem);
  } else {
    logger/* default.debug */.Z.debug(`$Item.name} Parsing basic magic item data`, {
      item: foundry.utils.deepClone(item),
      data,
      itemSpells,
      isCompendiumItem,
    });
    item = basicMagicItem(item, data, itemSpells, isCompendiumItem);

    const uses = foundry.utils.getProperty(item, "system.uses.value");
    const activation = foundry.utils.getProperty(item, "system.activation.type");

    if (activation === "" && uses > 0) {
      item.system.activation.type = "special";
    }
  }

  // console.warn(`Parsed ${item.name}`, {
  //   item: deepClone(item),
  //   itemSpells: deepClone(itemSpells),
  // });

  return item;
}

// EXTERNAL MODULE: ./src/parser/item/special.js
var item_special = __webpack_require__(9695);
;// CONCATENATED MODULE: ./src/parser/item/infusions.js




function getInfusionItemMap(ddb, item) {
  if (!ddb.infusions?.item) return undefined;
  return ddb.infusions.item.find((mapping) =>
    mapping.itemId === item.flags.ddbimporter.definitionId
    && mapping.inventoryMappingId === item.flags.ddbimporter.id
    && mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId
  );
}

function getInfusionDetail(ddb, definitionKey) {
  if (!ddb.infusions?.infusions?.definitionData) return undefined;
  return ddb.infusions.infusions.definitionData.find(
    (infusion) => infusion.definitionKey === definitionKey
  );
}

function parseInfusion(ddb, character, foundryItem, ddbItem) {
  // get item mapping
  const infusionItemMap = getInfusionItemMap(ddb, foundryItem);
  foundryItem.flags.infusions = { maps: [], applied: [], infused: false };

  const infusionDetail = infusionItemMap
    ? getInfusionDetail(ddb, infusionItemMap.definitionKey)
    : undefined;

  if (infusionItemMap && infusionDetail) {
    logger/* default.debug */.Z.debug(`Infusion detected for ${foundryItem.name}`);

    // add infusion flags
    foundryItem.flags.infusions.infused = true;

    // if item is loot, lets move it to equipment/trinket so effects will apply
    if (foundryItem.type === "loot") {
      foundryItem.type = "equipment";
      foundryItem.system.armor = {
        type: "trinket",
        value: 10,
        dex: null,
      };
      // infusions will over ride the can equip status, so just check for equipped
      foundryItem.system.equipped = ddbItem.equipped;
    }

    // check to see if we need to fiddle attack modifiers on infused weapons
    // this still needs to be moved to an enchantment effect
    if (foundryItem.type === "weapon") {
      const intSwap = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", { subType: "magic-item-attack-with-intelligence" }).length > 0;
      if (intSwap) {
        const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
        const mockAbility = foundry.utils.getProperty(foundryItem, "flags.ddbimporter.dndbeyond.ability");
        if (characterAbilities.int.value > characterAbilities[mockAbility].value) {
          foundryItem.system.ability = "int";
        }
      }
    }
  } else if (infusionItemMap && !infusionDetail) {
    logger/* default.warn */.Z.warn(`${foundryItem.name} marked as infused but no infusion info found`);
  }
  return foundryItem;

}


async function createInfusedItems(ddb, actor) {
  if (!ddb.infusions?.item || !ddb.infusions?.infusions?.definitionData) return;

  const rollData = actor.getRollData();

  for (const item of actor.getEmbeddedCollection("Item")) {

    const infusedItem = ddb.infusions.item.find((mapping) =>
      mapping.itemId === item.flags?.ddbimporter?.definitionId
      && mapping.inventoryMappingId === item.flags?.ddbimporter?.id
      && mapping.itemTypeId === item.flags?.ddbimporter?.definitionEntityTypeId
    );
    if (infusedItem) {
      // add infused item effect
      const infusionFeature = actor.items.find((i) =>
        foundry.utils.getProperty(i, "flags.ddbimporter.dndbeyond.defintionKey") === infusedItem.definitionKey
      );
      if (infusionFeature) {
        const infusionEffectCount = infusionFeature.effects.size;
        const infusionEffects = infusionFeature.getEmbeddedCollection("ActiveEffect")
          .filter((e) => {
            const enchantment = foundry.utils.getProperty(e, "flags.dnd5e.type") === "enchantment";
            if (!enchantment) return false;
            if (infusionEffectCount === 1) return true;
            const enchantmentLevel = foundry.utils.getProperty(e, "flags.dnd5e.enchantment.level");
            const appropriateLevel = (rollData.classes.artificer?.levels ?? 0) >= enchantmentLevel.min
              && ((rollData.classes.artificer?.levels ?? 0) <= enchantmentLevel.max || enchantmentLevel.max === null);
            return appropriateLevel;
          });
        if (infusionEffects) {
          // eslint-disable-next-line max-depth
          for (const infusionEffect of infusionEffects) {
            const effectData = infusionEffect.toObject();
            effectData.origin = infusionFeature.uuid;
            const applied = await ActiveEffect.create(effectData, {
              parent: item,
              keepOrigin: true,
            });
            logger/* default.debug */.Z.debug(`Applied infusion effect from ${infusionFeature.name} to ${item.name}`, {
              effect: effectData,
              applied,
            });
          }
        }
      }
    }
  }

}

// EXTERNAL MODULE: ./src/effects/DDBMacros.js
var DDBMacros = __webpack_require__(6516);
;// CONCATENATED MODULE: ./src/effects/restrictions.js




async function woundingWeaponEffect(document) {
  let effect = (0,effects_effects/* baseItemEffect */.uT)(document, document.name);

  effect.transfer = false;
  effect.flags.dae.macroRepeat = "startEveryTurn";
  effect.flags.dae.stackable = "count";
  effect.flags.dae.transfer = false;
  effect.duration = {
    startTime: null,
    seconds: null,
    rounds: 400,
    turns: null,
    startRound: null,
    startTurn: null,
  };

  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "item", "wounding.js");
  effect.changes.push(DDBMacros/* default.generateMacroChange */.Z.generateMacroChange({ macroType: "item", macroName: "wounding.js" }));
  document.effects.push(effect);

  return document;
}

async function lifeStealingEffect(document) {
  let effect = (0,effects_effects/* baseItemEffect */.uT)(document, document.name);
  await DDBMacros/* default.setItemMacroFlag */.Z.setItemMacroFlag(document, "item", "lifeStealing.js");
  DDBMacros/* default.setMidiOnUseMacroFlag */.Z.setMidiOnUseMacroFlag(document, "item", "lifeStealing.js", ["postActiveEffects"]);
  document.effects.push(effect);
  return document;
}

const RESTRICTION_MAPPINGS = [
  {
    // name: "Extra Critical",
    ddb: ["20 on the Attack Roll"],
    restriction: `@workflow.diceRoll === 20`,
  },
  {
    name: "of Life Stealing",
    ddb: ["20 on the Attack Roll, Not Construct or Undead"],
    restriction: `@workflow.diceRoll === 20 && !(["construct", "undead"].includes("@raceOrType"))`,
    effect: true,
    effectFunction: lifeStealingEffect,
  },
  {
    name: "Bloodaxe",
    ddb: ["to creatures that arent constructs or undead"],
    restriction: `!(["construct", "undead"].includes("@raceOrType"))`,
  },
  {
    // name: "Plants",
    ddb: ["against a plant (an ordinary plant or a creature with the Plant type) or a wooden object that isnt being worn or carried"],
    restriction: `["plant"].includes("@raceOrType")`
  },
  //  "Javelin of Lightning"
  {
    name: "Javelin of Lightning",
    ddb: ["On Hit or DC 13 Dexterity Save for Half Damage"],
    restriction: ``,
    save: true,
    macro: true,
  },
  {
    name: "Zariel",
    ddb: ["3d10 radiant if youre wielding the weapon with two hands"],
    restriction: ``,
  },
  {
    // name: "Undead",
    ddb: [
      "Against Undead Targets",
      "Against undead targets.",
      "(Against undead)",
      "An undead creature hit by the weapon takes an extra 1d8 radiant damage."
    ],
    restriction: `["undead"].includes("@raceOrType")`,
  },
  {
    // name: "Dragon",
    ddb: ["When you hit a dragon with this weapon"],
    restriction: `["dragon"].includes("@raceOrType")`,
  },
  {
    name: "of Wounding",
    ddb: ["Per Wound, DC 15 Constitution Save Ends Effect"],
    restriction: "",
    effect: true,
    effectFunction: woundingWeaponEffect,
  },
  {
    name: "Markovia",
    ddb: ["Against Fiends or Undead", "Against a fiend or an undead"],
    restriction: `["fiend", "undead"].includes("@raceOrType")`,
  },
  {
    name: "Riteknife",
    ddb: ["For each soul imprisoned in the dagger"],
    restriction: `false`,
  },
  {
    name: "Oathbow",
    ddb: ["Against Sworn Enemy"],
    restriction: `false`,
  },
  {
    name: "Matalotok",
    ddb: ["30-foot-radius sphere"],
    restriction: `false`,
  },
  {
    name: "Mastix",
    ddb: ["regain hit points equal to half the amount of necrotic damage dealt"],
    restriction: "",
    macro: true,
  },
  {
    name: "Mace of Disruption",
    ddb: ["Special"],
    nameMatch: "Mace of Disruption",
    restriction: `["fiend", "undead"].includes("@raceOrType")`,
  },
  {
    name: "Gurt",
    ddb: ["plus an extra 2d12 slashing damage if the target is human"],
    restriction: `["human"].includes("@raceOrType")`,
  },
  {
    name: "Grovelthrash",
    ddb: ["If you do, you take 1d6 psychic damage"],
    restriction: `false`,
  },
  {
    // name: "Giants",
    ddb: ["Against Giants"],
    restriction: `["giant"].includes("@raceOrType")`,
  },
  {
    name: "Flame Tongue",
    ddb: ["While Flaming"],
    restriction: "",
    removeOther: true,
    damageParts: [["2d6[fire]", "fire"]],
    replaceFlavor: "Extra damage only whilst flaming",
  },
  {
    name: "Dwarven Thrower",
    ddb: ["On hit with a ranged attack against Giants", "When Thrown (+2d8 against Giants)"],
    restriction: `["giant"].includes("@raceOrType")`,
  },
  {
    name: "Dragon's Wrath",
    ddb: [
      "On a hit, the weapon deals an extra damage of the type dealt by the dragons breath weapon. (Wakened)",
      "On a hit, the weapon deals an extra damage of the type dealt by the dragons breath weapon. (Stirring)",
      "On a hit, the weapon deals an extra damage of the type dealt by the dragons breath weapon. (Ascendant)",

    ],
    restriction: ``,
  },
  {
    name: "Dagger of Venom",
    ddb: ["DC 15 Constitution Save Negates"],
    restriction: `false`,
  },
  {
    name: "Yagas Pestle",
    ddb: ["Per Charge (Max 3)"],
    restriction: `false`,
  },
];

async function addRestrictionFlags(document, addEffects) {

  const restrictions = foundry.utils.getProperty(document, "flags.ddbimporter.dndbeyond.restrictions");
  if (!restrictions || restrictions.length == 0) return document;
  const name = document.flags.ddbimporter?.originalName ?? document.name;

  const nameMatch = RESTRICTION_MAPPINGS.find((r) => {
    return r.name && name.toLowerCase()[0].includes(r.name.toLowerCase());
  });
  const restriction = nameMatch
    ? nameMatch
    : RESTRICTION_MAPPINGS.find((r) => {
      return r.ddb.map((m) => m.toLowerCase())[0].includes(restrictions[0].toLowerCase());
    });

  if (restriction) {
    if (restriction.removeOther) {
      foundry.utils.setProperty(document, "system.formula", "");
    }
    if (restriction.replaceFlavor) {
      foundry.utils.setProperty(document, "system.chatFlavor", restriction.replaceFlavor);
    }
    if (restriction.damageParts) {
      document.system.damage.parts.push(...restriction.damageParts);
    }

    if (!game.modules.get("midi-qol")?.active || !addEffects) return document;

    let restrictionText = restriction.restriction;

    if (document.system.attunement > 0 && !["", "false"].includes(restriction.restriction)) {
      restrictionText += ` && @item.attunement !== 1`;
    }
    // foundry.utils.setProperty(document, "system.activation.condition", restrictionText);
    foundry.utils.setProperty(document, "flags.midi-qol.effectCondition", restrictionText);

    if (restriction.effectRestrictionActivation) {
      foundry.utils.setProperty(document, "flags.midi-qol.effectActivation", true);
    }

    if (restriction.effect) {
      document = await restriction.effectFunction(document);
    }
  }

  // effects needed for:
  // mace of disruption
  // oathbow
  // sharpness - needs light effect
  // sunswords
  // "Javelin of Lightning"
  // dwarven thrower
  // axe of dwarfish lords

  return document;
}

// EXTERNAL MODULE: ./src/effects/specialEquipment.js + 6 modules
var specialEquipment = __webpack_require__(7309);
// EXTERNAL MODULE: ./src/lib/DDBTable.js + 2 modules
var DDBTable = __webpack_require__(5366);
;// CONCATENATED MODULE: ./src/parser/item/weapon.js





/**
 * Gets the DND5E weapontype (simpleM, martialR etc.) as string
 * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)
 * @param {obj} data item data
 */
function getWeaponType(data) {
  const type = dictionary/* default.weapon.weaponType.find */.Z.weapon.weaponType.find(
    (type) => type.categoryId === data.definition.categoryId
  );
  const range = dictionary/* default.weapon.weaponRange.find */.Z.weapon.weaponRange.find(
    (type) => type.attackType === data.definition.attackType
  );

  if (type && range) {
    return `${type.value}${range.value}`;
  } else {
    return "simpleM";
  }
}

/**
 * Gets the weapons's properties (Finesse, Reach, Heavy etc.)
 * @param {obj} data Item data
 */
function getProperties(data) {
  return dictionary/* default.weapon.properties.filter */.Z.weapon.properties.filter((property) => {
      // if it is a weapon property
      if (data.definition.properties
        && Array.isArray(data.definition.properties)
        && data.definition.properties.some((prop) => prop.name === property.name)
      ) {
        return true;
      }
      // if it is a granted property
      if (data.definition.grantedModifiers
        && Array.isArray(data.definition.grantedModifiers)
        && data.definition.grantedModifiers.some((prop) =>
          prop.type === "weapon-property"
          && prop.friendlySubtypeName === property.name
        )
      ) {
        return true;
      }
      // else not a property
      return false;
    })
    .map((property) => property.value);
}

/**
 * Gets the range(s) of a given weapon
 */
function getRange(data, weaponProperties) {
  // range: { value: null, long: null, units: '' },
  // sometimes reach weapons have their range set as 5. it's not clear why.
  const shortRange = data.definition.range ? data.definition.range : 5;
  const reach = weaponProperties.includes("rch") && data.definition.range == 5 ? 5 : 0;
  return {
    value: shortRange + reach,
    long: (data.definition.longRange && data.definition.longRange != data.definition.range)
      ? data.definition.longRange + reach
      : "",
    units: "ft",
  };
};

/**
 * Gets the ability which the to hit modifier is baed on
 * Melee: STR
 * Ranged: DEX
 * Finesse: STR || DEX
 * Thrown: STR, unless Finesse, then STR || DEX
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * @param {obj} weaponRange weapon range information
 * @param {obj} abilities character abilities (scores)
 */
function getAbility(weaponProperties, weaponRange) {
  // finesse weapons can choose freely, so we choose the higher one
  if (weaponProperties.includes("fin")) {
    return null;
  }

  // thrown, but not finesse weapon: STR
  if (weaponProperties.includes("thr")) {
    return "str";
  }

  // if it's a ranged weapon, and not a reach weapon (long = 10 (?))
  if (weaponRange.long > 5 && !weaponProperties.includes("rch")) {
    return "dex";
  }
  // the default is STR
  return null;
}

/**
 * Searches for a magical attack bonus granted by this weapon
 * @param {obj} data item data
 * @param {obj} flags
 */
function getWeaponMagicalBonus(data, flags, returnZero = false) {
  const bonus = getMagicalBonus(data, returnZero);
  if (flags.classFeatures.includes("Improved Pact Weapon") && bonus === 0) {
    return 1;
  } else {
    return bonus;
  }
};

/**
 *
 * @param {obj} data item data
 * @param {obj} flags
 * /* damage: { parts: [], versatile: '' }, * /
 */
function getDamage(data, flags) {
  // const magicalDamageBonus = getWeaponMagicalBonus(data, flags, true);
  // we can safely make these assumptions about GWF and Dueling because the
  // flags are only added for melee attacks
  const greatWeaponFighting = flags.classFeatures.includes("greatWeaponFighting") ? "r<=2" : "";
  const offHand = flags.classFeatures.includes("OffHand");
  const twoWeapon = flags.classFeatures.includes("Two-Weapon Fighting");
  const twoHanded = data.definition.properties.find((property) => property.name === "Two-Handed");
  const mod = (offHand && !twoWeapon) ? "" : " + @mod";

  const baseDamageTagData = DDBHelper/* default.getDamageTagForItem */.Z.getDamageTagForItem(data);
  const damageTag = baseDamageTagData.damageTag;
  const damageType = baseDamageTagData.damageType;

  const versatile = data.definition.properties
    .filter((property) => property.name === "Versatile")
    .map((versatile) => {
      if (versatile && versatile.notes) {
        return (
          utils/* default.parseDiceString */.Z.parseDiceString(versatile.notes, null, damageTag, greatWeaponFighting).diceString + mod
        );
      } else {
        return "";
      }
    })[0];

  let parts = [];

  // if we have greatweapon fighting style and this is two handed, add the roll tweak
  // else if we have duelling we add the bonus here (assumption- if you have dueling
  // you're going to use it! (DDB also makes this assumption))
  const fightingStyleDiceMod = twoHanded ? greatWeaponFighting : "";

  // if we are a martial artist and the weapon is eligable we may need to use a bigger dice type.
  // this martial arts die info is addedd to the weapon flags before parse weapon is called
  const martialArtsDie = flags.martialArtsDie;

  if (Number.isInteger(data.definition.fixedDamage)) {
    parts.push([
      utils/* default.parseDiceString */.Z.parseDiceString(data.definition.fixedDamage, `${mod}`, damageTag, fightingStyleDiceMod)
        .diceString,
      damageType,
    ]);
  } else if (data.definition.damage && data.definition.damage.diceString && damageType) {
    let diceString = data.definition.damage.diceString;
    if (martialArtsDie.diceValue && data.definition.damage.diceValue && martialArtsDie.diceValue > data.definition.damage.diceValue) {
      diceString = martialArtsDie.diceString;
    }

    // if there is a magical damage bonus, it probably should only be included into the first damage part.
    parts.push([
      utils/* default.parseDiceString */.Z.parseDiceString(diceString, `${mod}`, damageTag, fightingStyleDiceMod)
        .diceString,
      damageType,
    ]);
  }

  // additional damage parts with no restrictions
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && (!mod.restriction || mod.restriction === ""))
    .forEach((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      const damagePart = die ? die.diceString : mod.value;
      if (damagePart) {
        const subDamageTagData = DDBHelper/* default.getDamageTagForMod */.Z.getDamageTagForMod(mod);
        const damageParsed = utils/* default.parseDiceString */.Z.parseDiceString(damagePart, "", subDamageTagData.damageTag).diceString;
        parts.push([`${damageParsed}`, subDamageTagData.damageType]);
      }
    });


  let chatFlavors = [];
  let otherFormulas = [];
  let restrictions = [];
  // loop over restricted damage types
  // we do this so we can either break this out for midi users
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && mod.restriction && mod.restriction !== "")
    .forEach((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      const damagePart = die ? die.diceString : `${mod.value}`;
      if (damagePart) {
        const subDamageTagData = DDBHelper/* default.getDamageTagForMod */.Z.getDamageTagForMod(mod);
        const damageParsed = utils/* default.parseDiceString */.Z.parseDiceString(damagePart, "", subDamageTagData.damageTag).diceString;
        restrictions.push(mod.restriction);
        otherFormulas.push(damageParsed);
        chatFlavors.push(`[${damagePart}] ${mod.restriction}`);
      }
    });

  const otherFormula = otherFormulas.join(" + ");
  const chatFlavor = chatFlavors.length === 0 ? "" : `Roll Other damage: ${chatFlavors.join(", ")}`;

  // add damage modifiers from other sources like improved divine smite
  if (flags.damage.parts) {
    flags.damage.parts.forEach((part) => {
      parts.push(part);
    });
  }

  const result = {
    parts,
    versatile,
  };

  return [result, otherFormula, chatFlavor, restrictions];
}

function getActionType(data) {
  if (data.definition.attackType === 1) {
    return "mwak";
  } else {
    return "rwak";
  }
}

function parseWeapon(data, character, flags) {
  let weapon = {
    _id: foundry.utils.randomID(),
    name: data.definition.name,
    type: "weapon",
    system: utils/* default.getTemplate */.Z.getTemplate("weapon"),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
          damage: flags.damage,
          classFeatures: flags.classFeatures,
        },
      },
    },
  };

  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;
  const characterProficiencies = character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects;

  weapon.system.type.value = getWeaponType(data);
  weapon.system.properties = getProperties(data);

  const proficientFeatures = ["pactWeapon", "kensaiWeapon"];
  if (flags.classFeatures.some((feat) => proficientFeatures.includes(feat))) {
    weapon.system.proficient = true;
  } else {
    weapon.system.proficient = getWeaponProficient(data, weapon.system.type.value, characterProficiencies);
  }

  weapon.system.description = getDescription(data, weapon);
  weapon.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  weapon.system.quantity = getQuantity(data);
  weapon.system.weight = getSingleItemWeight(data);
  weapon.system.equipped = getEquipped(data);
  weapon.system.rarity = getItemRarity(data);
  weapon.system.identified = true;
  weapon.system.activation = { type: "action", cost: 1, condition: "" };
  if (flags.classFeatures.includes("OffHand")) weapon.system.activation.type = "bonus";

  weapon.system.range = getRange(data, weapon.system.properties);
  weapon.system.uses = getUses(data, false);
  // force weapons to always not use prompt
  weapon.system.uses.prompt = false;
  weapon.system.ability = "";
  const ability = getAbility(weapon.system.properties, weapon.system.range);
  const mockAbility = ability === null
    ? weapon.system.properties.includes("fin") ? "dex" : "str"
    : ability;

  // warlocks can use cha for their Hex weapon
  if (flags.classFeatures.includes("hexWarrior")) {
    if (characterAbilities.cha.value >= characterAbilities[mockAbility].value) {
      weapon.system.ability = "cha";
    }
  }
  // kensai monks
  if (flags.classFeatures.includes("kensaiWeapon") || flags.classFeatures.includes("monkWeapon")) {
    if (characterAbilities.dex.value >= characterAbilities[mockAbility].value) {
      weapon.system.ability = "dex";
    }
  }
  if (flags.magicItemAttackInt && (data.definition.magic || weapon.system.properties.includes("mgc"))) {
    if (characterAbilities.int.value > characterAbilities[mockAbility].value) {
      weapon.system.ability = "int";
    }
  }
  const setAbility = weapon.system.ability && weapon.system.ability !== ""
    ? weapon.system.ability
    : mockAbility;
  foundry.utils.setProperty(weapon, "flags.ddbimporter.dndbeyond.ability", setAbility);

  weapon.system.actionType = getActionType(data);
  const magicalBonus = getWeaponMagicalBonus(data, flags, true);

  if (magicalBonus > 0) {
    weapon.system.magicalBonus = magicalBonus;
    weapon.system.properties = utils/* default.addToProperties */.Z.addToProperties(weapon.system.properties, "mgc");
  }

  [
    weapon.system.damage,
    weapon.system.formula,
    weapon.system.chatFlavor,
    weapon.flags.ddbimporter.dndbeyond.restrictions,
  ] = getDamage(data, flags);


  return weapon;
}

;// CONCATENATED MODULE: ./src/parser/item/ammunition.js




/**
 * Gets the range(s) of a given weapon
 */
function ammunition_getRange(data) {
  // range: { value: null, long: null, units: '' },
  return {
    value: data.definition.range ? data.definition.range : null,
    long: data.definition.longRange ? data.definition.longRange : null,
    units: (data.definition.range || data.definition.range) ? "ft." : "",
  };
}

/**
 *
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * /* damage: { parts: [], versatile: '' }, * /
 */
let ammunition_getDamage = (data, magicalDamageBonus) => {
  let parts = [];

  // first damage part
  // blowguns and other weapons rely on ammunition that provides the damage parts
  if (data.definition.damage && data.definition.damage.diceString && data.definition.damageType) {
    // if there is a magical damage bonus, it probably should only be included into the first damage part.
    parts.push([
      utils/* default.parseDiceString */.Z.parseDiceString(data.definition.damage.diceString + `+${magicalDamageBonus}`).diceString,
      data.definition.damageType.toLowerCase(),
    ]);
  }

  // additional damage parts
  // Note: For the time being, restricted additional bonus parts are not included in the damage
  //       The Saving Throw Freature within Foundry is not fully implemented yet, to this will/might change
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && mod.restriction && mod.restriction.length === 0)
    .forEach((mod) => {
      const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
      if (die) {
        parts.push([die.diceString, mod.subType]);
      } else if (mod.value) {
        parts.push([mod.value, mod.subType]);
      }
    });

  let result = {
    // label: utils.parseDiceString(parts.map(part => part[0]).join(' + ')).diceString,
    parts: parts,
    versatile: "",
  };

  return result;
};

function parseAmmunition(data, itemType) {
  /**
   * MAIN parseWeapon
   */
  let template = utils/* default.getTemplate */.Z.getTemplate("consumable");
  let ammunition = {
    _id: foundry.utils.randomID(),
    name: data.definition.name,
    type: "consumable",
    system: template,
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  ammunition.system.description = getDescription(data, ammunition);
  ammunition.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  ammunition.system.properties = [];
  ammunition.system.quantity = getQuantity(data);
  ammunition.system.weight = getSingleItemWeight(data);
  ammunition.system.equipped = getEquipped(data);
  ammunition.system.rarity = getItemRarity(data);
  ammunition.system.identified = true;
  ammunition.system.activation = { type: "action", cost: 1, condition: "" };
  ammunition.system.range = ammunition_getRange(data);
  ammunition.system.ability = "";
  ammunition.system.actionType = "rwak";
  const magicalBonus = getMagicalBonus(data, true);
  if (magicalBonus > 0) {
    ammunition.system.properties.push("mgc");
    ammunition.system.magicalBonus = magicalBonus;
  }
  ammunition.system.damage = ammunition_getDamage(data);
  ammunition.system.type.value = "ammo";

  return ammunition;
}

;// CONCATENATED MODULE: ./src/parser/item/staves.js





/**
 * Gets the DND5E weapontype (simpleM, martialR etc.) as string
 * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)
 * @param {obj} data item data
 */
function staves_getWeaponType(data) {
  const weaponBehavior = data.definition.weaponBehaviors[0];
  const type = dictionary/* default.weapon.weaponType.find */.Z.weapon.weaponType.find((type) => type.categoryId === weaponBehavior.categoryId);
  const range = dictionary/* default.weapon.weaponRange.find */.Z.weapon.weaponRange.find((type) => type.attackType === weaponBehavior.attackType);

  if (type && range) {
    return `${type.value}${range.value}`;
  } else {
    return "simpleM";
  }
}

/**
 * Gets the weapons's properties (Finesse, Reach, Heavy etc.)
 * @param {obj} data Item data
 */
function staves_getProperties(data) {
  let weaponBehavior = data.definition.weaponBehaviors[0];
  if (!weaponBehavior.properties || !Array.isArray(weaponBehavior.properties)) return [];
  let result = {};
  dictionary/* default.weapon.properties.forEach */.Z.weapon.properties.forEach((property) => {
    if (weaponBehavior.properties && Array.isArray(weaponBehavior.properties)) {
      result[property.value] = weaponBehavior.properties.find((prop) => prop.name === property.name) !== undefined;
    }
  });

  result = dictionary/* default.weapon.properties.filter */.Z.weapon.properties.filter((p) =>
    weaponBehavior.properties.find((prop) => prop.name === p.name) !== undefined
  ).map((p) => p.value);
  return result;
}


/**
 * Gets the range(s) of a given weapon
 */
function staves_getRange(data) {
  // range: { value: null, long: null, units: '' },
  let weaponBehavior = data.definition.weaponBehaviors[0];
  return {
    value: weaponBehavior.range ? weaponBehavior.range : 5,
    long: weaponBehavior.longRange ? weaponBehavior.longRange : 5,
    units: "ft.",
  };
}

/**
 * Gets the ability which the to hit modifier is baed on
 * Melee: STR
 * Ranged: DEX
 * Finesse: STR || DEX
 * Thrown: STR, unless Finesse, then STR || DEX
 * @param {obj} weaponProperties weapon properties
 * @param {obj} weaponRange weapon range information
 * @param {obj} abilities character abilities (scores)
 */
function staves_getAbility(weaponProperties, weaponRange, abilities) {
  // finesse weapons can choose freely, so we choose the higher one
  if (weaponProperties.fin) {
    return abilities.str.value > abilities.dex.value ? "str" : "dex";
  }

  // thrown, but not finesse weapon: STR
  if (weaponProperties.thr) {
    return "str";
  }

  // if it's a ranged weapon, and hot a reach weapon (long = 10 (?))
  if (weaponRange.long !== 5 && !weaponProperties.rch) {
    return "dex";
  }

  // the default is STR
  return "str";
}

/**
 *
 * @param {obj} data item data
 * @param {obj} weaponProperties weapon properties
 * /* damage: { parts: [], versatile: '' }, * /
 */
function staves_getDamage(data, magicalDamageBonus) {
  let weaponBehavior = data.definition.weaponBehaviors[0];
  let versatile = weaponBehavior.properties.find((property) => property.name === "Versatile");
  if (versatile && versatile.notes) {
    versatile = utils/* default.parseDiceString */.Z.parseDiceString(versatile.notes + `+${magicalDamageBonus}`).diceString;
  } else {
    versatile = "";
  }

  let parts = [];

  // first damage part
  // blowguns and other weapons rely on ammunition that provides the damage parts
  if (weaponBehavior.damage && weaponBehavior.damage.diceString && weaponBehavior.damageType) {
    const diceString = utils/* default.parseDiceString */.Z.parseDiceString(weaponBehavior.damage.diceString + `+${magicalDamageBonus}`).diceString;

    parts.push([
      `${diceString} +@mod`,
      weaponBehavior.damageType.toLowerCase(),
    ]);
  }

  // additional damage parts
  data.definition.grantedModifiers
    .filter((mod) => mod.type === "damage")
    .forEach((mod) => {
      const die = mod.dice
        ? mod.dice
        : mod.die
          ? mod.die
          : undefined;
      if (die?.diceString) {
        parts.push([die.diceString, mod.subType]);
      } else if (mod.value) {
        parts.push([`${mod.value}`, mod.subType]);
      }
    });

  let result = {
    // label: utils.parseDiceString(parts.map(part => part[0]).join(' + ')).diceString,
    parts: parts,
    versatile: versatile,
  };

  return result;
}

function parseStaff(data, character) {
  let template = utils/* default.getTemplate */.Z.getTemplate("weapon");
  let staff = {
    _id: foundry.utils.randomID(),
    name: data.definition.name,
    type: "weapon",
    system: template,
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  staff.system.type.value = staves_getWeaponType(data);
  staff.system.properties = staves_getProperties(data);
  staff.system.proficient = getWeaponProficient(data, staff.system.type.value, character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects);
  staff.system.description = getDescription(data, staff);
  staff.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  staff.system.quantity = getQuantity(data);
  staff.system.weight = getSingleItemWeight(data);
  staff.system.equipped = getEquipped(data);
  staff.system.rarity = getItemRarity(data);
  staff.system.identified = true;
  staff.system.activation = { type: "action", cost: 1, condition: "" };
  staff.system.range = staves_getRange(data);
  staff.system.ability = staves_getAbility(staff.system.properties, staff.system.range, character.flags.ddbimporter.dndbeyond.effectAbilities);
  staff.system.actionType = staff.system.range.long === 5 ? "mwak" : "rwak";
  staff.system.attack.bonus = getMagicalBonus(data);
  staff.system.damage = staves_getDamage(data, getMagicalBonus(data, true));

  if (!game.modules.get("magicitems")?.active && !game.modules.get("items-with-spells-5e")?.active) {
    staff.system.uses = getUses(data);
  }

  return staff;
}

;// CONCATENATED MODULE: ./src/parser/item/armor.js






/**
 * Get the armor type, armor class, and max dex modifier based on the provided data, character, and flags.
 *
 * @param {Object} data - The data object containing armor information.
 * @param {Object} character - The character object.
 * @param {Object} flags - The flags object for additional options.
 * @return {Object} An object containing the armor type, combined armor class, and max dex modifier.
 */
function getArmorType(data, character, flags) {
  // get the generic armor type
  const nameEntry = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((type) => type.name === data.definition.type);
  const idEntry = dictionary/* default.equipment.armorType.find */.Z.equipment.armorType.find((type) => type.id === data.definition.armorTypeId);

  // get the armor class
  const baseArmorClass = data.definition.armorClass;
  const bonusArmorClass = data.definition.grantedModifiers.reduce((prev, cur) => {
    if (cur.type === "bonus" && cur.subType === "armor-class" && Number.isInteger(cur.value)) {
      return prev + cur.value;
    } else {
      return prev;
    }
  }, 0);

  // console.warn("datadefinition",data.definition)
  // console.warn("baseArmorClass",baseArmorClass)
  // console.warn("bonusArmorClass",bonusArmorClass)

  // get the max dex modifier (Medium Armor: 2, Heavy: 0)
  let maxDexModifier;
  const armorType = nameEntry !== undefined
    ? nameEntry.value
    : idEntry !== undefined
      ? idEntry.value
      : "medium";

  switch (armorType) {
    case "heavy":
      maxDexModifier = 0;
      break;
    case "medium":
      maxDexModifier = flags.maxMediumArmorDex ?? 2;
      break;
    default:
      maxDexModifier = null;
      break;
  }

  const itemDexMaxAdjustment = DDBHelper/* default.getModifierSum */.Z.getModifierSum(DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(data.definition.grantedModifiers, "set", "ac-max-dex-modifier"), character);
  if (maxDexModifier !== null && Number.isInteger(itemDexMaxAdjustment) && itemDexMaxAdjustment > maxDexModifier) {
    maxDexModifier = itemDexMaxAdjustment;
  }

  return {
    type: armorType,
    value: baseArmorClass + bonusArmorClass,
    dex: maxDexModifier,
  };
}

/**
 * Gets the strength requirement to wear this armor, if any
 * @param {obj} data Item data
 */
function getStrength(data) {
  return data.definition.strengthRequirement ?? 0; // in future null might be permitted again
}

/**
 * Wearing this armor can give a disadvantage on stealth checks
 */
function getStealthPenalty(data) {
  return data.definition.stealthCheck === 2;
}

/**
 * Checks the proficiency of the character with this specific weapon
 * @param {obj} data Item data
 * @param {array} proficiencies The character's proficiencies as an array of `{ name: 'PROFICIENCYNAME' }` objects
 */
function getProficient(data, proficiencies) {
  // Proficiency in armor category (Light Armor, Shield)
  if (proficiencies.some((proficiency) => proficiency.name === data.definition.type)) return true;
  // Specific proficiency
  if (proficiencies.some((proficiency) => proficiency.name === data.definition.baseArmorName)) return true;
  return null;
}

function getMagicalArmorBonus(data) {
  const boni = data.definition.grantedModifiers.filter(
    (mod) => mod.type === "bonus" && mod.subType === "armor-class" && mod.value && mod.value !== 0
  );
  const bonus = boni.reduce((prev, cur) => prev + cur.value, 0);
  return bonus;
}

function parseArmor(data, character, flags) {
  let armor = {
    _id: foundry.utils.randomID(),
    name: data.definition.name,
    type: "equipment",
    system: utils/* default.getTemplate */.Z.getTemplate("armor"),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: data.definition.type,
        },
      },
    },
  };

  const armorType = getArmorType(data, character, flags);

  const magicBonus = getMagicalArmorBonus(data);

  armor.system.armor.value = armorType.value - magicBonus;
  if (magicBonus > 0) {
    armor.system.armor.magicalBonus = magicBonus;
    armor.system.properties.push("mgc");
  }
  armor.system.armor.dex = armorType.dex;
  armor.system.type.value = armorType.type;
  armor.system.type.baseItem = getBaseItem(data).baseItem;
  armor.system.strength = getStrength(data);
  if (getStealthPenalty(data)) armor.system.properties.push("stealthDisadvantage");
  const proficiencies = foundry.utils.getProperty(character, "flags.ddbimporter.dndbeyond.proficienciesIncludingEffects") ?? [];
  armor.system.proficient = getProficient(data, proficiencies);
  armor.system.description = getDescription(data, armor);
  armor.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  armor.system.quantity = getQuantity(data);
  armor.system.weight = getSingleItemWeight(data);
  armor.system.equipped = getEquipped(data);
  armor.system.rarity = getItemRarity(data);
  armor.system.identified = true;
  armor.system.uses = getUses(data);

  if (!armor.name.toLowerCase().includes("armor")) {
    foundry.utils.setProperty(armor, "flags.ddbimporter.dndbeyond.alternativeNames", [`${armor.name} Armor`]);
  }

  return armor;
}

;// CONCATENATED MODULE: ./src/parser/item/wonderous.js





function getSavingThrow(description) {
  const save = description.match(/DC ([0-9]+) (.*?) saving throw|\(save DC ([0-9]+)\)/);
  if (save && save[2]) {
    return {
      dc: save[1],
      ability: save[2].toLowerCase().substr(0, 3),
    };
  } else {
    return null;
  }
}


function getActivation(description) {

  let action = "";
  const actionRegex = /(bonus) action|(reaction)|as (?:an|a) (action)/i;

  const match = description.match(actionRegex);
  if (match) {
    if (match[1]) action = "bonus";
    else if (match[2]) action = "reaction";
    else if (match[3]) action = "action";
  }

  return {
    type: action,
    cost: action ? 1 : null,
    condition: "",
  };
}

/**
 *
 * @param {obj} ddbData item data
 * /* damage: { parts: [], versatile: '' }, * /
 */
function wonderous_getDamage(ddbData) {
  const parts = [];

  // additional damage parts
  ddbData.definition.grantedModifiers
    .filter((mod) => mod.type === "damage" && CONFIG.DND5E.damageTypes[mod.subType])
    .forEach((mod) => {
      const die = mod.dice
        ? mod.dice
        : mod.die
          ? mod.die
          : undefined;
      if (die?.diceString) {
        parts.push([die.diceString, mod.subType]);
      } else if (mod.value) {
        parts.push([`${mod.value}`, mod.subType]);
      }
    });

  const result = {
    parts,
    versatile: "",
  };

  return result;
}

// eslint-disable-next-line complexity
function parseWonderous(ddbData, { ddbTypeOverride = null, armorType = "trinket" } = {}) {
  const isContainer = ddbData.definition.isContainer;
  const isClothingTag = ddbData.definition.tags.includes('Outerwear')
    || ddbData.definition.tags.includes('Footwear')
    || ddbData.definition.tags.includes('Clothing');
  const tashasInstalled = game.modules.get("dnd-tashas-cauldron")?.active;
  const isTattoo = ddbData.definition.name.toLowerCase().includes("tattoo");
  const tattooType = tashasInstalled && isTattoo;

  ddbTypeOverride = isTattoo
    ? "Tattoo"
    : isClothingTag && !isContainer ? "Clothing" : ddbTypeOverride;

  const type = tattooType
    ? "dnd-tashas-cauldron.tattoo"
    : isContainer ? "container" : "equipment";
  /**
   * MAIN parseEquipment
   */
  let item = {
    _id: foundry.utils.randomID(),
    name: ddbData.definition.name,
    type,
    system: utils/* default.getTemplate */.Z.getTemplate(type),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: ddbTypeOverride ?? ddbData.definition.type,
        },
      },
    },
  };

  if (isContainer) {
    if (ddbData.currency) item.system.currency = getCurrency(ddbData);
    if (getWeightless(ddbData)) {
      item.system.properties = utils/* default.addToProperties */.Z.addToProperties(item.system.properties, "weightlessContents");
    }
  } else if (tattooType) {
    item.system.type.value = ddbData.definition.name.toLowerCase().includes("spellwrought")
      ? "spellwrought"
      : "permanent";
    utils/* default.addToProperties */.Z.addToProperties(item.system.properties, "mgc");
  } else {
    //
    // "armor": {
    // "type": "trinket",
    // "value": 10,
    // "dex": null
    // }
    item.system.armor = {
      value: null,
      dex: null,
    };

    item.system.type.value = isClothingTag && !isContainer ? "clothing" : armorType;

    /* "strength": 0 */
    item.system.strength = 0;

    /* "stealth": false,*/
    utils/* default.removeFromProperties */.Z.removeFromProperties(item.system.properties, "stealthDisadvantage");
    item.system.proficient = null;
  }

  item.system.description = getDescription(ddbData, item);
  item.system.source = DDBHelper/* default.parseSource */.Z.parseSource(ddbData.definition);
  item.system.quantity = getQuantity(ddbData);
  item.system.weight = getSingleItemWeight(ddbData);
  item.system.equipped = getEquipped(ddbData);
  item.system.rarity = getItemRarity(ddbData);
  item.system.identified = true;
  item.system.uses = getUses(ddbData, true);
  if (!isTattoo) item.system.capacity = getCapacity(ddbData);

  item.system.activation = getActivation(ddbData.definition.description);

  if (foundry.utils.hasProperty(item, "system.damage")) {
    item.system.damage = wonderous_getDamage(ddbData);

    if (item.system.damage.parts.length > 0) {
      const saveDetails = getSavingThrow(ddbData.definition.description);
      if (saveDetails) {
        item.system.actionType = "save";
        item.system.save = { ability: saveDetails.ability, dc: saveDetails.dc, scaling: "flat" };
      } else {
        item.system.actionType = "util";
      }
      // console.warn(`Added damage to ${item.name}`, { item, damage: item.system.damage });
    }
    if (item.system.activation.value === "") item.system.activation.value = "special";
  }


  return item;
}

;// CONCATENATED MODULE: ./src/parser/item/tool.js





function isHalfProficiencyRoundedUp(data, ab) {
  const longAbility = dictionary/* default.character.abilities.filter */.Z.character.abilities.filter((ability) => ab === ability.value)
    .map((ability) => ability.long)[0];
  const roundUp = DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(data, "half-proficiency-round-up", { subType: `${longAbility}-ability-checks` });
  return Array.isArray(roundUp) && roundUp.length;
}

function getProficiency(data, toolName, ability) {
  const mods = DDBHelper/* default.getAllModifiers */.Z.getAllModifiers(data, { includeExcludedEffects: true });
  const modifiers = mods
    .filter((modifier) => modifier.friendlySubtypeName === toolName)
    .map((mod) => mod.type);

  const toolExpertise = data.character?.classes
    ? data.character.classes.some((cls) =>
      cls.classFeatures.some((feature) => feature.definition.name === "Tool Expertise" && cls.level >= feature.definition.requiredLevel)
    )
      ? 2
      : 1
    : 1;

  const halfProficiency
    = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(data).find(
      (modifier) =>
        // Jack of All trades/half-rounded down
        (modifier.type === "half-proficiency" && modifier.subType === "ability-checks")
        // e.g. champion for specific ability checks
        || isHalfProficiencyRoundedUp(data, ability)
    ) !== undefined
      ? 0.5
      : 0;

  const proficient = modifiers.includes("expertise")
    ? 2
    : modifiers.includes("proficiency")
      ? toolExpertise
      : halfProficiency;

  return proficient;
}

function parseTool(ddb, data, itemType) {
  /**
   * MAIN parseTool
   */
  let tool = {
    _id: foundry.utils.randomID(),
    name: data.definition.name,
    type: "tool",
    system: utils/* default.getTemplate */.Z.getTemplate("tool"),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  const defaultAbility = dictionary/* default.character.proficiencies.find */.Z.character.proficiencies.find((prof) => prof.name === tool.name);

  tool.system.ability = defaultAbility?.ability ?? "dex";
  tool.system.description = getDescription(data, tool);
  tool.system.proficient = (ddb) ? getProficiency(ddb, tool.name, tool.system.ability) : 0;
  tool.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  tool.system.quantity = getQuantity(data);
  tool.system.weight = getSingleItemWeight(data);
  tool.system.equipped = getEquipped(data);
  tool.system.rarity = getItemRarity(data);
  tool.system.identified = true;
  tool.system.uses = getUses(data);

  return tool;
}

;// CONCATENATED MODULE: ./src/parser/item/consumable.js





function consumable_getActionType(data) {
  if (data.definition.tags.includes("Healing")) {
    return "heal";
  } else if (data.definition.tags.includes("Damage")) {
    // ranged spell attack. This is a good guess
    return "rsak";
  } else {
    return "other";
  }
}

function consumable_getDamage(data, actionType) {
  let damage = { parts: [], versatile: "" };
  // is this a damage potion
  switch (actionType) {
    case "heal": {
      // healing potion
      // we only get the first matching modifier
      const healingModifier = data.definition.grantedModifiers.find(
        (mod) => mod.type === "bonus" && mod.subType === "hit-points"
      );
      if (healingModifier) {
        const healingDie = healingModifier.dice
          ? healingModifier.dice
          : healingModifier.die
            ? healingModifier.die
            : undefined;
        if (healingDie?.diceString) {
          damage.parts = [[healingDie.diceString + "[healing] ", "healing"]];
        } else if (healingModifier.fixedValue) {
          damage.parts = [[healingModifier.fixedValue + "[healing] ", "healing"]];
        }
      }
      break;
    }
    case "rsak": {
      // damage potion
      const damageModifier = data.definition.grantedModifiers.find((mod) =>
        mod.type === "damage" && (mod.dice || mod.die)
      );
      if (damageModifier) {
        const damageDie = damageModifier.dice
          ? damageModifier.dice
          : damageModifier.die
            ? damageModifier.die
            : undefined;
        if (damageDie?.diceString) {
          damage.parts = [[damageDie.diceString + `[${damageModifier.subType}] `, damageModifier.subType]];
        } else if (damageModifier.fixedValue) {
          damage.parts = [[damageModifier.fixedValue + `[${damageModifier.subType}] `, damageModifier.subType]];
        }
      }
      break;
    }
    // no default
  }
  return damage;
}

function getDuration(data) {
  let duration = {
    value: null,
    units: "",
  };

  if (data.definition.duration) {
    if (data.definition.duration.durationUnit !== null) {
      duration.units = data.definition.duration.durationUnit.toLowerCase();
    } else {
      duration.units = data.definition.duration.durationType.toLowerCase().substring(0, 4);
    }
    if (data.definition.duration.durationInterval) duration.value = data.definition.duration.durationInterval;
  } else {
    const durationArray = [
      { foundryUnit: "day", descriptionMatches: ["day", "days"] },
      { foundryUnit: "hour", descriptionMatches: ["hour", "hours"] },
      { foundryUnit: "inst", descriptionMatches: ["instant", "instantaneous"] },
      { foundryUnit: "minute", descriptionMatches: ["minute", "minutes"] },
      { foundryUnit: "month", descriptionMatches: ["month", "months"] },
      { foundryUnit: "perm", descriptionMatches: ["permanent"] },
      { foundryUnit: "round", descriptionMatches: ["round", "rounds"] },
      // { foundryUnit: "spec", descriptionMatches: [null] },
      { foundryUnit: "turn", descriptionMatches: ["turn", "turns"] },
      { foundryUnit: "year", descriptionMatches: ["year", "years"] },
    ];
    // attempt to parse duration
    const descriptionUnits = durationArray.map((unit) => unit.descriptionMatches).flat().join("|");
    const durationExpression = new RegExp(`(\\d*)(?:\\s)(${descriptionUnits})`);
    const durationMatch = data.definition.description.match(durationExpression);

    if (durationMatch) {
      duration.units = durationArray.find((duration) => duration.descriptionMatches.includes(durationMatch[2])).foundryUnit;
      duration.value = durationMatch[1];
    }
  }
  return duration;
}


function parseConsumable(ddbItem, { consumableTypeOverride = null, ddbTypeOverride = null } = {}) {
  let item = {
    _id: foundry.utils.randomID(),
    name: ddbItem.definition.name,
    type: "consumable",
    system: utils/* default.getTemplate */.Z.getTemplate("consumable"),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: ddbTypeOverride ?? ddbItem.definition.type,
        },
      },
    },
  };

  item.system.type.value = consumableTypeOverride?.toLowerCase() ?? ddbItem.definition.filterType.toLowerCase();
  item.system.uses = getConsumableUses(ddbItem);
  item.system.description = getDescription(ddbItem, item);
  item.system.source = DDBHelper/* default.parseSource */.Z.parseSource(ddbItem.definition);
  item.system.quantity = getQuantity(ddbItem);
  item.system.weight = getSingleItemWeight(ddbItem);
  item.system.equipped = getEquipped(ddbItem);
  item.system.rarity = getItemRarity(ddbItem);
  item.system.identified = true;
  item.system.activation = { type: "action", cost: 1, condition: "" };
  item.system.duration = getDuration(ddbItem);
  item.system.actionType = consumable_getActionType(ddbItem);

  if (item.system.type.value === "potion") {
    item.system.damage = consumable_getDamage(ddbItem, consumable_getActionType(ddbItem));
  } else if (item.system.type.value === "wand") {
    item.system.properties.push("mgc");
  }

  return item;
}

;// CONCATENATED MODULE: ./src/parser/item/loot.js






const LOOT_ITEM = [
  "Abacus",
  "Barding",
  "Basic Fishing Equipment",
  "Bedroll",
  "Bell",
  "Bit and Bridle",
  "Blanket",
  "Block and Tackle",
  "Book",
  "Magnifying Glass",
  "Scale, Merchant's",
  "Signet Ring",
  "String",
];

const LOOT_TYPES = {
  "Gemstone": "gem",
  "Gem": "gem",
  "Art Object": "art",
  "Art": "art",
  "Material": "material",
  "Resource": "resource",
  "Treasure": "treasure",
  "Adventuring Gear": "gear",
  "Junk": "junk",
};

function getItemType(data, typeHint) {
  let result = {
    type: "loot"
  };

  if (data.definition.isContainer
    || ["Mount", "Vehicle"].includes(data.definition.subType)
    || ["Vehicle", "Mount"].includes(typeHint)
  ) {
    return {
      type: "container",
    };
  } else if (data.definition.name.startsWith("Lantern,")
    || ["Lamp", "Healer's Kit"].includes(data.definition.name)
  ) {
    return {
      type: "consumable",
      consumableType: "trinket",
    };
  } else if (["Waterskin"].includes(data.definition.name)) {
    return {
      type: "consumable",
      consumableType: "food",
    };
  } else if (data.definition.name.startsWith("Spell Scroll:")) {
    return {
      type: "consumable",
      consumableType: "scroll",
    };
  }

  const itemTypes = data.definition.tags && Array.isArray(data.definition.tags)
    ? [data.definition.type.toLowerCase(), ...data.definition.tags.map((t) => t.toLowerCase())]
    : [data.definition.type.toLowerCase()];

  let itemType = itemTypes
    .map((itemType) => {
      if (itemType === "container") return "container";
      if (itemType === "consumable") return "consumable";
      return dictionary/* default.types.full.find */.Z.types.full.find((t) => t.indexOf(itemType) !== -1 || itemType.indexOf(t) !== -1);
    })
    .reduce(
      (itemType, currentType) => (currentType !== undefined && itemType === undefined ? currentType : itemType),
      undefined
    );

  if (!itemType && data.definition.type === "Gear"
    && ["Adventuring Gear"].includes(data.definition.subType)
    && !LOOT_ITEM.includes(data.definition.name)
  ) {
    // && data.definition.subType === "Adventuring Gear"
    // && data.definition.tags.includes('Utility')
    // && ((data.definition.tags.includes('Damage')
    // && data.definition.tags.includes('Combat'))
    // || data.definition.tags.includes('Healing'));
    itemType = "consumable";
  }

  if (itemType) {
    result.type = itemType;
    if (itemType === "consumable") {
      if (data.definition.name.includes('vial') || data.definition.name.includes('flask')) {
        result.consumableType = "potion";
      } else if (data.definition.name.startsWith("Ration")) {
        result.consumableType = "food";
      } else {
        result.consumableType = "trinket";
      }
    }
  }

  return result;
}

function parseLoot(data, itemType) {
  const type = getItemType(data, itemType);

  let loot = {
    _id: foundry.utils.randomID(),
    name: data.definition.name,
    type: type.type,
    system: utils/* default.getTemplate */.Z.getTemplate(type.type),
    flags: {
      ddbimporter: {
        dndbeyond: {
          type: itemType,
        },
      },
    },
  };

  if (type.consumableType) {
    loot.system.type.value = type.consumableType;
    loot.system.uses = getConsumableUses(data);
  }
  loot.system.description = getDescription(data, loot);
  loot.system.source = DDBHelper/* default.parseSource */.Z.parseSource(data.definition);
  loot.system.quantity = getQuantity(data);
  loot.system.weight = getSingleItemWeight(data);
  loot.system.equipped = getEquipped(data);
  loot.system.rarity = getItemRarity(data);
  loot.system.identified = true;
  loot.system.price = getPrice(data);

  if (type.type === "loot") {
    const lookup = LOOT_TYPES[itemType];
    if (lookup) foundry.utils.setProperty(loot, "system.type.value", lookup);
  } else if (type.type === "container") {
    loot.system.capacity = getCapacity(data);
    if (data.currency) loot.system.currency = getCurrency(data);
    if (getWeightless(data)) {
      loot.system.properties = utils/* default.addToProperties */.Z.addToProperties(loot.system.properties, "weightlessContents");
    }
  }
  return loot;
}

;// CONCATENATED MODULE: ./src/parser/item/custom.js



function parseCustomItem(data) {
  const type = data.definition.name.startsWith("Spell Scroll:") ? "consumable" : "loot";
  let customItem = {
    name: data.definition.name,
    type,
    system: utils/* default.getTemplate */.Z.getTemplate(type),
    flags: {
      ddbimporter: {
        id: data.id,
        custom: true,
        dndbeyond: {
          type: "Custom Item",
        },
      },
    },
  };

  if (data.definition.name.startsWith("Spell Scroll:")) {
    customItem.type = "consumable";
    customItem.system.type.value = "scroll";
  }

  let description = data.definition.description && data.definition.description !== "null"
    ? data.definition.description
    : "";
  description = data.definition.notes
    ? description + `<p><blockquote>${data.definition.notes}</blockquote></p>`
    : description;

  const chatAdd = game.settings.get("ddb-importer", "add-description-to-chat");
  customItem.system.description = {
    value: description,
    chat: chatAdd ? description : "",
  };

  customItem.system.source = "Custom item";
  customItem.system.quantity = getQuantity(data);
  customItem.system.weight = getSingleItemWeight(data);
  customItem.system.price = getPrice(data);
  customItem.system.equipped = getEquipped(data);
  customItem.system.identified = true;
  customItem.system.rarity = getItemRarity(data);

  return customItem;
}

;// CONCATENATED MODULE: ./src/parser/item/index.js





// magic items support




// effects support





// tables















const CLOTHING_ITEMS = [
  "Helm",
  "Boots",
  "Snowshoes",
  "Vestments",
  "Saddle, Exotic",
  "Saddle, Military",
  "Saddle, Pack",
  "Saddle, Riding",
];

const EQUIPMENT_TRINKET = [
  "Canoe",
  "Censer",
  "Crowbar",
  "Grenade Launcher",
  "Hammer",
  "Hammer, Sledge",
  "Hourglass",
  "Ladder (10 foot)",
  "Mess Kit",
  "Mirror, Steel",
  "Pick, Miner's",
  "Pole (10-foot)",
  "Shovel",
  "Signal Whistle",
  "Small Knife",
  "Spellbook",
  "Spyglass",
  "Tent, Two-Person",
  "Whetstone",
];

function getItemFromGearTypeIdOne(ddb, ddbItem) {
  let item = {};

  switch (ddbItem.definition.subType) {
    case "Potion":
      item = parseConsumable(ddbItem, { consumableTypeOverride: "potion", ddbTypeOverride: ddbItem.definition.subType });
      break;
    case "Tool":
      item = parseTool(ddb, ddbItem, ddbItem.definition.subType);
      break;
    case "Ammunition":
      item = parseAmmunition(ddbItem, ddbItem.definition.subType);
      break;
    case "Arcane Focus":
    case "Holy Symbol":
    case "Druidic Focus":
      item = parseWonderous(ddbItem, { ddbTypeOverride: ddbItem.definition.subType });
      break;
    case "Mount":
      item = parseLoot(ddbItem, "Mount");
      break;
    case "Vehicle":
      item = parseLoot(ddbItem, "Vehicle");
      break;
    default: {
      const isContainerTag = ddbItem.definition.tags.includes('Container');
      const isOuterwearTag = ddbItem.definition.tags.includes('Outerwear')
        || ddbItem.definition.tags.includes('Footwear');
      if ((!ddbItem.definition.isContainer && isOuterwearTag && !isContainerTag)
        || CLOTHING_ITEMS.includes(ddbItem.definition.name)
      ) {
        item = parseWonderous(ddbItem, { ddbTypeOverride: "Clothing", armorType: "clothing" });
      } else if (EQUIPMENT_TRINKET.includes(ddbItem.definition.name)) {
        item = parseWonderous(ddbItem, { ddbTypeOverride: ddbItem.definition.subType });
      } else {
        item = parseLoot(ddbItem, ddbItem.definition.subType);
      }
    }
  }
  return item;
}

function fallbackParse(ddb, ddbItem) {
  if (ddbItem.definition.name.includes(" Ring")) {
    return parseWonderous(ddbItem, { ddbTypeOverride: "Ring" });
  } else if (ddbItem.definition.subType) {
    return parseLoot(ddbItem, ddbItem.definition.subType);
  } else {
    return parseLoot(ddbItem, "Miscellaneous");
  }
}

function otherGear(ddb, ddbItem) {
  let item = {};

  switch (ddbItem.definition.gearTypeId) {
    case 1:
      item = getItemFromGearTypeIdOne(ddb, ddbItem);
      break;
    case 4:
      item = parseLoot(ddbItem, "Mount");
      break;
    case 5:
      item = parseConsumable(ddbItem, { consumableTypeOverride: "potion", ddbTypeOverride: "Poison" });
      break;
    case 6:
      item = parseConsumable(ddbItem, { consumableTypeOverride: "potion", ddbTypeOverride: "Potion" });
      break;
    case 11:
      item = parseTool(ddb, ddbItem, "Tool");
      break;
    case 12:
    case 17:
    case 19:
      item = parseLoot(ddbItem, "Vehicle");
      break;
    case 16:
      item = parseLoot(ddbItem, "Equipment Pack");
      break;
    case 18:
      // Change to parseGemstone (consummable) ?
      item = parseLoot(ddbItem, "Gemstone");
      break;
    default:
      item = fallbackParse(ddb, ddbItem);
      logger/* default.warn */.Z.warn("Other Gear type missing from " + ddbItem.definition.name, ddbItem);
  }
  return item;
}

function addExtraDDBFlags(ddbItem, item) {
  item.flags.ddbimporter['id'] = ddbItem.id;
  item.flags.ddbimporter['entityTypeId'] = ddbItem.entityTypeId;

  if (ddbItem.definition.avatarUrl) item.flags.ddbimporter.dndbeyond['avatarUrl'] = ddbItem.definition.avatarUrl.split('?')[0];
  if (ddbItem.definition.largeAvatarUrl) item.flags.ddbimporter.dndbeyond['largeAvatarUrl'] = ddbItem.definition.largeAvatarUrl.split('?')[0];
  if (ddbItem.definition.filterType) {
    const filter = dictionary/* default.items.find */.Z.items.find((i) => i.filterType === ddbItem.definition.filterType);
    if (filter) item.flags.ddbimporter.dndbeyond['filterType'] = filter.filterType;
  }

  // container info
  if (ddbItem.containerEntityId) foundry.utils.setProperty(item, "flags.ddbimporter.containerEntityId", ddbItem.containerEntityId);
  if (ddbItem.containerEntityTypeId) foundry.utils.setProperty(item, "flags.ddbimporter.containerEntityTypeId", ddbItem.containerEntityTypeId);

  foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.isConsumable", ddbItem.definition.isConsumable);
  foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.isContainer", ddbItem.definition.isContainer);
  foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.isCustomItem", ddbItem.definition.isCustomItem);
  foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.isHomebrew", ddbItem.definition.isHomebrew);
  foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.isMonkWeapon", ddbItem.definition.isMonkWeapon);
  foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.isPack", ddbItem.definition.isPack);
  foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.levelInfusionGranted", ddbItem.definition.levelInfusionGranted);

  return item;
}

function enrichFlags(ddbItem, item) {
  if (ddbItem.definition?.entityTypeId) item.flags.ddbimporter['definitionEntityTypeId'] = ddbItem.definition.entityTypeId;
  if (ddbItem.definition?.id) item.flags.ddbimporter['definitionId'] = ddbItem.definition.id;
  if (ddbItem.entityTypeId) item.flags.ddbimporter['entityTypeId'] = ddbItem.entityTypeId;
  if (ddbItem.id) item.flags.ddbimporter['id'] = ddbItem.id;
  if (ddbItem.definition?.tags) item.flags.ddbimporter.dndbeyond['tags'] = ddbItem.definition.tags;
  if (ddbItem.definition?.sources) item.flags.ddbimporter.dndbeyond['sources'] = ddbItem.definition.sources;
  if (ddbItem.definition?.stackable) item.flags.ddbimporter.dndbeyond['stackable'] = ddbItem.definition.stackable;
}

// the filter type "Other Gear" represents the equipment while the other filters represents the magic items in ddb
function parseItem(ddb, ddbItem, character, flags) {
  try {
    // is it a weapon?
    let item = {};
    const name = ddbItem.definition.name;
    if (ddbItem.definition.filterType) {
      switch (ddbItem.definition.filterType) {
        case "Weapon": {
          if (ddbItem.definition.type === "Ammunition" || ddbItem.definition.subType === "Ammunition") {
            item = parseAmmunition(ddbItem, "Ammunition");
          } else {
            item = parseWeapon(ddbItem, character, flags);
          }
          break;
        }
        case "Armor":
          item = parseArmor(ddbItem, character, flags);
          break;
        case "Ring":
        case "Wondrous item": {
          if ([
            "bead of",
            "dust of",
            "elemental gem",
          ].some((consumablePrefix) => name.toLowerCase().startsWith(consumablePrefix.toLowerCase()))) {
            item = parseConsumable(ddbItem, { consumableTypeOverride: "trinket", ddbTypeOverride: ddbItem.definition.type });
          } else {
            item = parseWonderous(ddbItem);
          }
          break;
        }
        case "Scroll":
        case "Wand":
        case "Rod":
          item = parseConsumable(ddbItem);
          break;
        case "Staff":
          item = parseStaff(ddbItem, character);
          break;
        case "Potion":
          item = parseConsumable(ddbItem, { consumableTypeOverride: "potion", ddbTypeOverride: ddbItem.definition.type });
          break;
        case "Other Gear":
          item = otherGear(ddb, ddbItem);
          break;
        default:
          logger/* default.warn */.Z.warn("Item filterType not implemented for " + ddbItem.definition.name, ddbItem);
          break;
      }
    } else {
      // try parsing it as a custom item
      item = parseCustomItem(ddbItem);
    }
    const baseItem = getBaseItem(ddbItem);
    if (baseItem.baseItem) foundry.utils.setProperty(item, "system.type.baseItem", baseItem.baseItem);
    if (baseItem.toolType) foundry.utils.setProperty(item, "system.type.value", baseItem.toolType);
    item.system.attuned = ddbItem.isAttuned;
    item.system.attunement = getAttunement(ddbItem);
    item.system.price = getPrice(ddbItem);
    if (ddbItem.definition.magic) item.system.properties = utils/* default.addToProperties */.Z.addToProperties(item.system.properties, "mgc");

    item = addExtraDDBFlags(ddbItem, item);
    item = DDBHelper/* default.addCustomValues */.Z.addCustomValues(ddb, item);
    enrichFlags(ddbItem, item);

    return item;
  } catch (err) {
    logger/* default.warn */.Z.warn(
      `Unable to parse item: ${ddbItem.definition.name}, ${ddbItem.definition.type}/${ddbItem.definition.filterType}. ${err.message}`,
      ddbItem
    );
    logger/* default.error */.Z.error(err.stack);
    return { // return empty strut
      name: ddbItem.definition.name,
      flags: {
        ddbimporter: {
          dndbeyond: {
          },
        },
      },
    };
  }
}


/**
 * We get extra damage to a weapon attack here, for example Improved
 * Divine Smite
 * @param {*} data
 * @param {*} restrictions (array)
 */
function getExtraDamage(ddb, restrictions) {
  return DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "damage", { restriction: restrictions }).map((mod) => {
    const die = mod.dice ? mod.dice : mod.die ? mod.die : undefined;
    if (die) {
      return [die.diceString, mod.subType];
    } else if (mod.value) {
      return [mod.value, mod.subType];
    } else {
      return [null, null];
    }
  });
}

function isMartialArtists(classes) {
  return classes.some((cls) => cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts"));
}

function getWarlockFeatures(ddb, weapon) {
  // Some features, notably hexblade abilities we scrape out here
  const warlockFeatures = ddb.character.characterValues
    .filter(
      (characterValue) =>
        characterValue.value
        && characterValue.valueId == weapon.id
        && dictionary/* default.character.characterValuesLookup.some */.Z.character.characterValuesLookup.some(
          (entry) => entry.typeId == characterValue.typeId
        )
    )
    .map(
      (characterValue) =>
        dictionary/* default.character.characterValuesLookup.find */.Z.character.characterValuesLookup.find(
          (entry) => entry.typeId == characterValue.typeId
        ).name
    );

  // Any Pact Weapon Features
  const pactFeatures = ddb.character.options.class
    .filter(
      (option) =>
        warlockFeatures.includes("pactWeapon")
        && option.definition.name
        && dictionary/* default.character.pactFeatures.includes */.Z.character.pactFeatures.includes(option.definition.name)
    )
    .map((option) => option.definition.name);

  const features = warlockFeatures.concat(pactFeatures);
  return features;
}

function getMonkFeatures(ddb, weapon) {
  const kenseiWeapon = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb).some((mod) =>
    mod.friendlySubtypeName === weapon.definition.type
    && mod.type === "kensei"
  );

  const monkWeapon = DDBHelper/* default.getChosenClassModifiers */.Z.getChosenClassModifiers(ddb).some((mod) =>
    mod.friendlySubtypeName === weapon.definition.type
    && mod.type == "monk-weapon"
  ) || (weapon.definition.isMonkWeapon && isMartialArtists(ddb.character.classes));

  let features = [];

  if (kenseiWeapon) features.push("kenseiWeapon");
  if (monkWeapon) features.push("monkWeapon");

  return features;
}


function getMartialArtsDie(ddb) {
  let result = {
    diceCount: null,
    diceMultiplier: null,
    diceString: null,
    diceValue: null,
    fixedValue: null,
  };

  const die = ddb.character.classes
    // is a martial artist
    .filter((cls) => cls.classFeatures.some((feature) => feature.definition.name === "Martial Arts"))
    // get class features
    .map((cls) => cls.classFeatures)
    .flat()
    // filter relevant features, those that are martial arts and have a levelscaling hd
    .filter((feature) => feature.definition.name === "Martial Arts" && feature.levelScale && feature.levelScale.dice)
    // get this dice object
    .map((feature) => feature.levelScale.dice);

  if (die && die.length > 0) {
    result = die[0];
  }

  return result;

}

function getClassFeatures(ddb, weapon) {
  const warlockFeatures = getWarlockFeatures(ddb, weapon);
  const monkFeatures = getMonkFeatures(ddb, weapon);
  return warlockFeatures.concat(monkFeatures);
}

DDBCharacter/* default.prototype.getItemFlags */.Z.prototype.getItemFlags = function getItemFlags(ddbItem) {
  const ddb = this.source.ddb;
  const character = this.raw.character;
  let flags = {
    damage: {
      parts: [],
    },
    // Some features, notably hexblade abilities we scrape out here
    classFeatures: getClassFeatures(ddb, ddbItem),
    martialArtsDie: getMartialArtsDie(ddb),
    maxMediumArmorDex: Math.max(
      ...DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "set", { subType: "ac-max-dex-armored-modifier", includeExcludedEffects: true }).map((mod) => mod.value),
      ...DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(ddbItem.definition?.grantedModifiers ?? ddbItem.grantedModifiers ?? [], "set", "ac-max-dex-armored-modifier", ["", null], true).map((mod) => mod.value),
      ...DDBHelper/* default.filterModifiersOld */.Z.filterModifiersOld(ddbItem.definition?.grantedModifiers ?? ddbItem.grantedModifiers ?? [], "set", "ac-max-dex-modifier", ["", null], true).map((mod) => mod.value),
      2,
    ),
    magicItemAttackInt: DDBHelper/* default.filterBaseModifiers */.Z.filterBaseModifiers(ddb, "bonus", { subType: "magic-item-attack-with-intelligence" }).length > 0,
  };

  if (flags.classFeatures.includes("Lifedrinker")) {
    flags.damage.parts.push(["@abilities.cha.mod", "necrotic"]);
  }

  // for melee attacks get extras
  if (ddbItem.definition.attackType === 1) {
    // get improved divine smite etc for melee attacks
    const extraDamage = getExtraDamage(ddb, ["Melee Weapon Attacks"]);

    if (!!extraDamage.length > 0) {
      flags.damage.parts = flags.damage.parts.concat(extraDamage);
    }
    // do we have great weapon fighting?
    if (DDBHelper/* default.hasChosenCharacterOption */.Z.hasChosenCharacterOption(ddb, "Great Weapon Fighting")) {
      flags.classFeatures.push("greatWeaponFighting");
    }
    // do we have two weapon fighting style?
    if (DDBHelper/* default.hasChosenCharacterOption */.Z.hasChosenCharacterOption(ddb, "Two-Weapon Fighting")) {
      flags.classFeatures.push("Two-Weapon Fighting");
    }
    if (DDBHelper/* default.getCustomValueFromCharacter */.Z.getCustomValueFromCharacter(ddbItem, character, 18)) {
      flags.classFeatures.push("OffHand");
    }
  }
  // ranged fighting style is added as a global modifier elsewhere
  // as is defensive style

  logger/* default.debug */.Z.debug(`Flags for ${ddbItem.name ?? ddbItem.definition.name}`, { ddbItem, flags });

  return flags;
};

// TO DO: revisit to break up item parsing
// eslint-disable-next-line complexity
DDBCharacter/* default.prototype.getInventory */.Z.prototype.getInventory = async function getInventory() {

  let items = [];
  // first, check custom name, price or weight
  this.source.ddb.character.characterValues.forEach((cv) => {
    // try to find a matching item based on the characterValues (an array of custom adjustements to different parts of the character)
    let item = this.source.ddb.character.inventory.find((item) => item.id === cv.valueId);
    if (item) {
      // check if this property is in the list of supported ones, based on our DICT
      let property = dictionary/* default.item.characterValues.find */.Z.item.characterValues.find((entry) => entry.typeId === cv.typeId);
      // overwrite the name, weight or price with the custom value
      if (property && cv.value.length !== 0) item.definition[property.value] = cv.value;
    }
  });

  // now parse all items
  const isCompendiumItem = foundry.utils.getProperty(this.raw.character, "flags.ddbimporter.compendium") ?? false;
  const addAutomationEffects = (isCompendiumItem)
    ? game.settings.get("ddb-importer", "munching-policy-add-effects")
    : game.settings.get("ddb-importer", "character-update-policy-add-item-effects");

  for (let ddbItem of this.source.ddb.character.inventory) {
    const originalName = ddbItem.definition.name;
    const adjustedName = DDBHelper/* default.getName */.Z.getName(this.source.ddb, ddbItem, this.raw.character);
    const flags = this.getItemFlags(ddbItem);
    foundry.utils.setProperty(ddbItem, "isCompendiumItem", isCompendiumItem);

    const updateExisting = isCompendiumItem
      ? game.settings.get("ddb-importer", "munching-policy-update-existing")
      : false;
    ddbItem.definition.description = await (0,DDBTable/* generateTable */.p)(adjustedName, ddbItem.definition.description, updateExisting);

    let item = Object.assign({}, parseItem(this.source.ddb, ddbItem, this.raw.character, flags));

    if (item) {
      item.name = adjustedName;
      item = parseMagicItem(item, ddbItem, this.raw.itemSpells, isCompendiumItem);
      item.flags.ddbimporter.originalName = originalName;
      item.flags.ddbimporter.version = CONFIG.DDBI.version;
      if (!item.effects) item.effects = [];
      if (!item.name || item.name === "") item.name = "Item";

      // if (addEffects) {
      item = (0,effects_effects/* generateEffects */.K7)({
        ddb: this.source.ddb,
        character: this.raw.character,
        ddbItem,
        foundryItem: item,
        isCompendiumItem,
        type: "item",
        description: item.system.description.chat !== ""
          ? item.system.description.chat
          : item.system.description.value,
      });
      // } else if (item.type === "equipment") {
      //   if (foundry.utils.hasProperty(item, "system.armor.type") && ["trinket", "clothing"].includes(item.system.armor.type)) {
      //     item = generateBaseACItemEffect(this.source.ddb, this.raw.character, ddbItem, item, isCompendiumItem);
      //   }
      // } else {
      //   item = generateBaseACItemEffect(this.source.ddb, this.raw.character, ddbItem, item, isCompendiumItem);
      // }
      item = await addRestrictionFlags(item, addAutomationEffects);

      if (!isCompendiumItem) item = parseInfusion(this.source.ddb, this.raw.character, item, ddbItem, isCompendiumItem);
      if (addAutomationEffects) item = await (0,specialEquipment/* midiItemEffects */.i)(item);
      // item = await getIcon(item, ddbItem);

      items.push(item);
    }
  }

  (0,item_special/* fixItems */.x)(items);
  this.updateItemIds(items);
  return items;
};

// EXTERNAL MODULE: ./src/parser/companions/DDBCompanionFactory.js
var DDBCompanionFactory = __webpack_require__(3972);
;// CONCATENATED MODULE: ./src/parser/companions/companions.js






DDBCharacter/* default.prototype.getClassFeature */.Z.prototype.getClassFeature = function(name) {
  const klass = this.source.ddb.character.classes
    .find((k) => k.classFeatures.some((f) => f.definition.name == name));
  return klass?.classFeatures?.find((f) => f.definition.name == name);
};


DDBCharacter/* default.prototype._parseCompanion */.Z.prototype._parseCompanion = async function(html, type, originDocument) {
  const ddbCompanionFactory = new DDBCompanionFactory/* default */.Z(html, { type, originDocument });
  await ddbCompanionFactory.parse();
  this.companionFactories.push(ddbCompanionFactory);
};

DDBCharacter/* default.prototype._importCompanions */.Z.prototype._importCompanions = async function() {
  for (const factory of this.companionFactories) {
    await factory.updateOrCreateCompanions();
  }
};

DDBCharacter/* default.prototype._getCompanionFeature */.Z.prototype._getCompanionFeature = async function(featureName) {
  const feature = this.data.features.concat(this.data.actions).find((s) =>
    s.name === featureName || s.flags.ddbimporter?.originalName === featureName
  );
  if (!feature) return;
  const ddbFeature = this.getClassFeature(featureName);
  if (!ddbFeature) return;
  await this._parseCompanion(ddbFeature.definition.description, "feature", feature);
};

DDBCharacter/* default.prototype._getCompanionOption */.Z.prototype._getCompanionOption = async function(parentFeature, childName) {
  const feature = this.data.features.concat(this.data.actions).find((s) =>
    s.name === parentFeature
    || s.flags.ddbimporter?.originalName === parentFeature
    || s.name === `${parentFeature}: ${childName}`
    || s.flags.ddbimporter?.originalName === `${parentFeature}: ${childName}`
  );
  if (!feature) return;
  const ddbOption = this.source.ddb.character.options.class.find((o) => o.definition.name == childName);
  if (!ddbOption) return;
  await this._parseCompanion(ddbOption.definition.description, "feature", feature);
};

DDBCharacter/* default.prototype.generateCompanions */.Z.prototype.generateCompanions = async function() {
  for (const name of src_settings/* default.COMPANIONS.COMPANION_FEATURES */.Z.COMPANIONS.COMPANION_FEATURES) {
    await this._getCompanionFeature(name);
  }
  // spells now munched during spell munch
  for (const [parentFeature, childNames] of Object.entries(src_settings/* default.COMPANIONS.COMPANION_OPTIONS */.Z.COMPANIONS.COMPANION_OPTIONS)) {
    for (const name of childNames) {
      await this._getCompanionOption(parentFeature, name);
    }
  }

  await this._importCompanions();

  this.companions = this.companionFactories.map((factory) => factory.companions);

  logger/* default.debug */.Z.debug("parsed companions", {
    factories: this.companionFactories,
    parsed: this.companions,
  });

  for (const factory of this.companionFactories) {
    await factory.addCompanionsToDocuments(this.data.features.concat(this.data.actions));
  }

  // different types of companion
  // ranger beast companions, classic and new
  // ranger drake warden
  // ranger other?
  // artificer steel defender
  // artificer homunculus
  // new summon spells
  // classic summons (not handled here)
  // druid circle of fire companion

};


;// CONCATENATED MODULE: ./src/parser/extendParsers.js
// monster parser

// load files with extensions here. this will add the functions to the class















// character parser

// load files with extensions here. this will add the functions to the class



























;// CONCATENATED MODULE: ./src/hooks/init/extendClasses.js


// EXTERNAL MODULE: ./src/parser/DDBMonsterFactory.js
var DDBMonsterFactory = __webpack_require__(4029);
// EXTERNAL MODULE: ./src/muncher/spells.js + 1 modules
var spells = __webpack_require__(6502);
// EXTERNAL MODULE: ./src/muncher/items.js
var items = __webpack_require__(8638);
// EXTERNAL MODULE: ./src/muncher/vehicles.js + 10 modules
var vehicles = __webpack_require__(1187);
// EXTERNAL MODULE: ./src/muncher/tools.js
var tools = __webpack_require__(8089);
// EXTERNAL MODULE: ./src/lib/PatreonHelper.js
var PatreonHelper = __webpack_require__(8636);
// EXTERNAL MODULE: ./src/lib/MuncherSettings.js
var MuncherSettings = __webpack_require__(6886);
// EXTERNAL MODULE: ./src/lib/DDBCampaigns.js
var DDBCampaigns = __webpack_require__(9771);
// EXTERNAL MODULE: ./src/lib/FileHelper.js
var FileHelper = __webpack_require__(2397);
// EXTERNAL MODULE: ./src/lib/Iconizer.js
var Iconizer = __webpack_require__(306);
// EXTERNAL MODULE: ./vendor/lowdash/isequal.js
var isequal = __webpack_require__(846);
// EXTERNAL MODULE: ./src/lib/Secrets.js
var Secrets = __webpack_require__(2048);
// EXTERNAL MODULE: ./src/effects/DDBEffectHelper.js
var DDBEffectHelper = __webpack_require__(2010);
;// CONCATENATED MODULE: ./src/parser/special/conditions.js




function getCondition(conditionDDBName) {
  return dictionary/* default.conditions.find */.Z.conditions.find((condition) => condition.label === conditionDDBName);
}

function getActorConditionStates(actor, ddb, keepLocal = false) {
  const conditions = dictionary/* default.conditions.filter */.Z.conditions.filter((condition) => Number.isInteger(condition.ddbId)) // only ddb conditions
    .map((condition) => {
      const conditionApplied = DDBEffectHelper/* default.getConditionEffectAppliedAndActive */.Z.getConditionEffectAppliedAndActive(condition.label, actor);
      const ddbCondition = ddb.character.conditions.some((conditionState) =>
        conditionState.id === condition.ddbId
        && conditionState.level === condition.levelId
      );
      condition.ddbCondition = ddbCondition;
      condition.applied = conditionApplied !== undefined;
      condition.conditionApplied = conditionApplied;
      condition.needsAdd = ddbCondition && !conditionApplied;
      condition.needsRemove = !ddbCondition && conditionApplied && !keepLocal;
      condition.needsUpdate = (ddbCondition && !conditionApplied) || (!ddbCondition && conditionApplied && !keepLocal);
      return condition;
    });
  return conditions;
}

/**
 * Set conditions
 * @param {*} ddb
 * @param {*} actor
 */
async function setConditions(actor, ddb, keepLocal = false) {
  const conditionStates = getActorConditionStates(actor, ddb, keepLocal);
  // console.warn(conditionStates);
  logger/* default.debug */.Z.debug(`Condition states for ${actor.name}`, conditionStates);

  // remove conditions first
  for (const condition of conditionStates.filter((c) => c.needsRemove)) {
    logger/* default.debug */.Z.debug(`removing ${condition.label}`, { condition });
    const existing = actor.document?.effects?.get(game.dnd5e.utils.staticID(`dnd5e${condition.foundry}`));
    if (existing) await existing.delete();
    if (condition.foundry === "exhaustion") {
      logger/* default.debug */.Z.debug("Removing exhaustion", condition.levelId);
      await actor.update({ "system.attributes.exhaustion": 0 });
    }
  }
  for (const condition of conditionStates.filter((c) => c.needsAdd)) {
    logger/* default.debug */.Z.debug(`adding ${condition.label}`, { condition });
    const effect = await ActiveEffect.implementation.fromStatusEffect(condition.foundry);
    effect.updateSource({ "flags.dnd5e.exhaustionLevel": condition.levelId });
    const effectData = effect.toObject();
    // console.warn("effect", {effect, effectData});
    // await ActiveEffect.implementation.create(effectData, { parent: actor.document, keepId: true });
    await actor.createEmbeddedDocuments("ActiveEffect", [effectData], { keepId: true });
    if (condition.foundry === "exhaustion") {
      logger/* default.debug */.Z.debug("Updating actor exhaustion", condition.levelId);
      await actor.update({ "system.attributes.exhaustion": condition.levelId });
    }
  }
}

// EXTERNAL MODULE: ./src/lib/DDBProxy.js
var DDBProxy = __webpack_require__(546);
// EXTERNAL MODULE: ./src/lib/NameMatcher.js
var NameMatcher = __webpack_require__(3901);
;// CONCATENATED MODULE: ./src/updater/character.js














function getContainerItems(actor) {
  return actor.items
    .filter((item) =>
      foundry.utils.hasProperty(item, "flags.ddbimporter.id")
      && foundry.utils.hasProperty(item, "flags.ddbimporter.containerEntityId")
      && item.flags.ddbimporter.containerEntityId === parseInt(actor.flags.ddbimporter.dndbeyond.characterId)
      && !item.flags.ddbimporter?.ignoreItemImport
      && !item.system.container
    );
}

function getItemRollData(actor, itemId) {
  const item = actor.items.get(itemId);
  const rollData = item.getRollData();
  return {
    item,
    rollData,
  };
}

function setContainerDetails(actor, item, containerItems = null) {
  const characterId = actor.flags.ddbimporter.dndbeyond.characterId;
  const ddbContainers = containerItems ?? getContainerItems(actor);

  const containerItem = item.system.container
    ? ddbContainers.find((container) => container._id === item.system.container)
    : null;

  if (containerItem) {
    const containerId = foundry.utils.getProperty(containerItem, "flags.ddbimporter.id");
    const containerEntityTypeId = foundry.utils.getProperty(containerItem, "flags.ddbimporter.entityTypeId");
    foundry.utils.setProperty(item, "flags.ddbimporter.containerEntityId", containerId);
    foundry.utils.setProperty(item, "flags.ddbimporter.containerEntityTypeId", containerEntityTypeId);
  } else {
    // set the container entity id to the id of the character, if the character is the "container"
    foundry.utils.setProperty(item, "flags.ddbimporter.containerEntityId", parseInt(characterId));
  }

  return item;
}

function getFoundryItems(actor) {
  const ddbContainers = getContainerItems(actor);

  const actorItems = foundry.utils.duplicate(actor.items)
    .filter((item) => !(item.flags.ddbimporter?.ignoreItemUpdate ?? false))
    .map((rawItem) => {
      const item = getItemRollData(actor, rawItem._id).item;
      return setContainerDetails(actor, item, ddbContainers);
    });
  // don't return update ignored items
  return actorItems;
}

function getCustomItemDescription(text) {
  return utils/* default.stripHtml */.Z.stripHtml(text).substring(0, 2055);
}

async function getUpdateItemIndex() {
  if (foundry.utils.hasProperty(CONFIG, "DDBI.update.itemIndex")) return foundry.utils.getProperty(CONFIG, "DDBI.update.itemIndex");
  const compendium = await CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("item", false);

  const indexFields = [
    "name",
    "type",
    "flags.ddbimporter.definitionId",
    "flags.ddbimporter.definitionEntityTypeId",
  ];
  // eslint-disable-next-line require-atomic-updates
  const itemIndex = await compendium.getIndex({ fields: indexFields });
  foundry.utils.setProperty(CONFIG, "DDBI.update.itemIndex", itemIndex);

  return itemIndex;
}

async function getCompendiumItemInfo(item) {
  const index = await getUpdateItemIndex();
  const match = NameMatcher/* default.looseItemNameMatch */.Z.looseItemNameMatch(item, index, true, false, true);
  return match;
}

// flavor is just useful for debugging
async function updateCharacterCall(actor, path, bodyContent, flavor) {
  const characterId = actor.flags.ddbimporter.dndbeyond.characterId;
  const cobaltCookie = (0,Secrets/* getCobalt */.HF)(actor.id);
  const dynamicSync = src_settings/* default.STATUS.activeUpdate */.Z.STATUS.activeUpdate();
  const parsingApi = dynamicSync
    ? DDBProxy/* default.getDynamicProxy */.Z.getDynamicProxy()
    : DDBProxy/* default.getProxy */.Z.getProxy();
  const useCharacterKey = foundry.utils.getProperty(actor, "flags.ddbimporter.useLocalPatreonKey") ?? false;
  const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey(useCharacterKey);
  const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
  const proxyCampaignId = campaignId === "" ? null : campaignId;
  const coreBody = {
    cobalt: cobaltCookie,
    betaKey,
    characterId,
    campaignId: proxyCampaignId,
    dynamicSync,
    customApiVersion: 5.1,
  };
  const body = { ...coreBody, ...bodyContent };

  const url = dynamicSync
    ? `${parsingApi}/dynamic/update/${path}`
    : `${parsingApi}/proxy/update/${path}`;

  logger/* default.debug */.Z.debug("Update info:", {
    url,
    path,
    characterId,
    bodyContent,
    dynamicSync,
    flavor,
  });

  return new Promise((resolve, reject) => {
    fetch(url, {
      method: "POST",
      cache: "no-cache",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body), // body data type must match "Content-Type" header
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          const errorData = {
            url,
            path,
            errorData: data,
            bodyContent,
            characterId,
            dynamicSync,
            flavor,
          };
          logger/* default.error */.Z.error(`Update failed for ${actor.name}:`, errorData);
          ui.notifications.error(`Update failed: (${actor.name}) ${data.message} (see console log (F12) for more details)`);
          resolve(data);
        }
        logger/* default.debug */.Z.debug(`${path} updated, response`, data);
        return data;
      })
      .then((data) => resolve(data))
      .catch((error) => {
        const errorData = {
          error,
          bodyContent,
          characterId,
          dynamicSync,
        };
        logger/* default.error */.Z.error(`Setting ${path} failed`, errorData);
        logger/* default.error */.Z.error(error.stack);
        reject(error);
      });
  });
}

async function updateDDBSpellSlotsPact(actor) {
  return new Promise((resolve) => {
    let spellSlotPackData = {
      spellslots: {},
      pact: true,
    };
    spellSlotPackData.spellslots[`level${actor.system.spells.pact.level}`] = actor.system.spells.pact.value;
    const spellPactSlots = updateCharacterCall(actor, "spell/slots", spellSlotPackData, "Pact Spell Slots");
    resolve(spellPactSlots);
  });
}

async function spellSlotsPact(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-spells-slots")) resolve();
    if (
      actor.system.spells.pact.max > 0
      && ddbCharacter.data.character.system.spells.pact.value !== actor.system.spells.pact.value
    ) {
      resolve(updateDDBSpellSlotsPact(actor));
    } else {
      resolve();
    }
  });
}

async function updateDynamicDDBSpellSlots(actor, update) {
  return new Promise((resolve) => {
    let spellSlotData = { spellslots: {}, update: false };
    for (let i = 1; i <= 9; i++) {
      let spellData = actor.system.spells[`spell${i}`];
      if (spellData.max > 0 && update.system.spells[`spell${i}`]) {
        const used = spellData.max - spellData.value;
        spellSlotData.spellslots[`level${i}`] = used;
        spellSlotData["update"] = true;
      }
    }
    if (spellSlotData["update"]) {
      resolve(updateCharacterCall(actor, "spells/slots", spellSlotData, "Spell slots"));
    } else {
      resolve();
    }
  });
}

async function spellSlots(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-spells-slots")) resolve();

    let spellSlotData = { spellslots: {}, update: false };
    for (let i = 1; i <= 9; i++) {
      let spellData = actor.system.spells[`spell${i}`];
      if (spellData.max > 0 && ddbCharacter.data.character.system.spells[`spell${i}`].value !== spellData.value) {
        const used = spellData.max - spellData.value;
        spellSlotData.spellslots[`level${i}`] = used;
        spellSlotData["update"] = true;
      }
    }
    if (spellSlotData["update"]) {
      resolve(updateCharacterCall(actor, "spells/slots", spellSlotData, "Spell slots"));
    } else {
      resolve();
    }
  });
}

async function updateDDBCurrency(actor) {
  return new Promise((resolve) => {
    const value = {
      pp: Number.isInteger(actor.system.currency.pp) ? actor.system.currency.pp : 0,
      gp: Number.isInteger(actor.system.currency.gp) ? actor.system.currency.gp : 0,
      ep: Number.isInteger(actor.system.currency.ep) ? actor.system.currency.ep : 0,
      sp: Number.isInteger(actor.system.currency.sp) ? actor.system.currency.sp : 0,
      cp: Number.isInteger(actor.system.currency.cp) ? actor.system.currency.cp : 0,
    };

    resolve(updateCharacterCall(actor, "currency", value, "Currency"));

  });
}

async function currency(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-currency")) resolve();

    const value = {
      pp: Number.isInteger(actor.system.currency.pp) ? actor.system.currency.pp : 0,
      gp: Number.isInteger(actor.system.currency.gp) ? actor.system.currency.gp : 0,
      ep: Number.isInteger(actor.system.currency.ep) ? actor.system.currency.ep : 0,
      sp: Number.isInteger(actor.system.currency.sp) ? actor.system.currency.sp : 0,
      cp: Number.isInteger(actor.system.currency.cp) ? actor.system.currency.cp : 0,
    };

    const same = (0,isequal/* isEqual */.X)(ddbCharacter._currency, value);

    if (!same) {
      resolve(updateCharacterCall(actor, "currency", value));
    } else {
      resolve();
    }

  });
}

// async function itemCurrencyUpdate(actor, foundryItem, type, value) {
//   return new Promise((resolve) => {
//     const currency = {
//       amount: value,
//       characterId: actor.flags.ddbimporter.dndbeyond.characterId,
//       destinationEntityId: foundryItem.id,
//       destinationEntityTypeId: foundryItem.entityTypeId,
//     };
//     resolve(updateCharacterCall(actor, `currency/individual`, { type, currency }, `Currency - ${type}`));
//   });
// }

// async function itemCurrency(actor, ddbItem, foundryItem) {
//   if (!game.settings.get(SETTINGS.MODULE_ID, "sync-policy-currency")) return [];
//   if (!game.modules.get("itemcollection")?.active) return [];
//   if (!foundry.utils.hasProperty(foundryItem, "system.currency")) return [];

//   const promises = [];

//   ["pp", "gp", "ep", "sp", "cp"].forEach((type) => {
//     const same = isEqual(foundryItem.system.currency[type], ddbItem.currency[type]);
//     if (!same) {
//       promises.push(itemCurrencyUpdate(actor, foundryItem, type, foundryItem.system.currency[type]));
//     }
//   });

//   return Promise.all(promises);
// }

async function updateDDBXP(actor) {
  return new Promise((resolve) => {
    resolve(updateCharacterCall(actor, "xp", { currentXp: actor.system.details.xp.value ?? 0 }, "XP"));
  });
}

async function xp(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-xp")) resolve();
    const same = ddbCharacter.data.character.system.details.xp.value === actor.system.details.xp.value;

    if (!same) {
      resolve(updateDDBXP(actor));
    } else {
      resolve();
    }
  });
}

async function updateDDBHitPoints(actor) {
  return new Promise((resolve) => {
    const temporaryHitPoints = actor.system.attributes.hp.temp ?? 0;
    const bonusHitPoints = actor.system.attributes.hp.tempmax ?? 0;
    const removedHitPoints = (actor.system.attributes.hp.max + bonusHitPoints) - (actor.system.attributes.hp.value ?? 0);
    const hitPointData = {
      removedHitPoints,
      temporaryHitPoints,
    };
    resolve(updateCharacterCall(actor, "hitpoints", hitPointData, "HP"));
  });
}

async function updateTempMaxDDBHitPoints(actor) {
  return new Promise((resolve) => {

    const bonusHitPoints = {
      bonusHitPoints: actor.system.attributes.hp.tempmax ?? 0,
    };
    resolve(updateCharacterCall(actor, "hpbonus", bonusHitPoints, "HPBonus"));
  });
}


async function hitPoints(actor, ddbCharacter) {
  if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-hitpoints")) return [];
  let promises = [];
  const same
    = ddbCharacter.data.character.system.attributes.hp.value === (actor.system.attributes.hp.value ?? 0)
    && (ddbCharacter.data.character.system.attributes.hp.temp ?? 0) === (actor.system.attributes.hp.temp ?? 0);

  if (!same) {
    promises.push(updateDDBHitPoints(actor));
  }

  const hpSame = ddbCharacter.data.character.system.attributes.hp.tempmax === (actor.system.attributes.hp.tempmax ?? 0);

  if (!hpSame) {
    promises.push(updateTempMaxDDBHitPoints(actor));
  }

  return Promise.all(promises);
}

async function updateDDBInspiration(actor) {
  return new Promise((resolve) => {
    const inspiration = updateCharacterCall(actor, "inspiration", {
      inspiration: actor.system.attributes.inspiration,
    }, "Inspiration");
    resolve(inspiration);
  });
}

async function inspiration(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-inspiration")) resolve();
    const same = ddbCharacter.data.character.system.attributes.inspiration === actor.system.attributes.inspiration;

    if (!same) {
      resolve(updateDDBInspiration(actor));
    } else {
      resolve();
    }
  });
}

async function updateDDBExhaustion(actor) {
  return new Promise((resolve) => {
    let exhaustionData = {
      conditionId: 4,
      addCondition: false,
    };
    if (actor.system.attributes.exhaustion !== 0) {
      exhaustionData["level"] = actor.system.attributes.exhaustion;
      exhaustionData["totalHP"] = actor.system.attributes.hp.max;
      exhaustionData["addCondition"] = true;
    }
    resolve(updateCharacterCall(actor, "condition", exhaustionData, "Exhaustion"));
  });
}


async function exhaustion(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-condition")) resolve();
    const same = ddbCharacter.data.character.system.attributes.exhaustion === actor.system.attributes.exhaustion;

    if (!same) {
      resolve(updateDDBExhaustion(actor));
    } else {
      resolve();
    }

  });
}

async function updateDDBCondition(actor, condition) {
  return new Promise((resolve) => {
    const conditionData = {
      conditionId: condition.ddbId,
      addCondition: condition.applied,
      level: null,
      totalHP: actor.system.attributes.hp.max,
    };

    resolve(updateCharacterCall(actor, "condition", conditionData, { condition }));
  });
}

async function conditions(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-condition")) resolve([]);
    const conditions = getActorConditionStates(actor, ddbCharacter.source.ddb);
    let results = [];
    conditions.forEach((condition) => {
      // exhaustion handled separately
      if (condition.needsUpdate && condition.ddbId !== 4) {
        results.push(updateDDBCondition(actor, condition));
      }
    });
    resolve(results);
  });
}

async function updateDDBDeathSaves(actor) {
  return new Promise((resolve) => {
    const deathSaveData = {
      failCount: actor.system.attributes.death.failure ?? 0,
      successCount: actor.system.attributes.death.success ?? 0,
    };
    resolve(updateCharacterCall(actor, "deathsaves", deathSaveData, "Death Saves"));
  });
}

async function deathSaves(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-deathsaves")) resolve();
    const same = (0,isequal/* isEqual */.X)(ddbCharacter.data.character.system.attributes.death, actor.system.attributes.death);

    if (!same) {
      resolve(updateDDBDeathSaves(actor));
    } else {
      resolve();
    }
  });
}

async function updateDDBHitDice(actor, klass, update) {
  return new Promise((resolve) => {
    if (klass.flags?.ddbimporter?.id) {
      let hitDiceData = {
        classHitDiceUsed: {},
        resetMaxHpModifier: false,
      };
      hitDiceData.classHitDiceUsed[klass.flags.ddbimporter.id] = update.system.hitDiceUsed;
      resolve(updateCharacterCall(actor, "hitdice", { shortRest: hitDiceData }, "Hit Dice"));
    } else {
      resolve();
    }
  });
}

async function hitDice(actor, ddbCharacter) {
  return new Promise((resolve) => {
    if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-hitdice")) resolve();

    const ddbClasses = ddbCharacter.data.classes;

    const klasses = actor.items.filter(
      (item) => item.type === "class" && item.flags.ddbimporter.id && item.flags.ddbimporter.definitionId
    );

    let hitDiceData = {
      classHitDiceUsed: {},
      resetMaxHpModifier: false,
    };

    klasses.forEach((klass) => {
      const classMatch = ddbClasses.find((ddbClass) => ddbClass.flags.ddbimporter.id === klass.flags.ddbimporter.id);
      if (classMatch && classMatch.system.hitDiceUsed !== klass.system.hitDiceUsed) {
        hitDiceData.classHitDiceUsed[klass.flags.ddbimporter.id] = klass.system.hitDiceUsed;
      }
    });

    const same = (0,isequal/* isEqual */.X)({}, hitDiceData.classHitDiceUsed);
    if (!same) {
      resolve(updateCharacterCall(actor, "hitdice", { shortRest: hitDiceData }));
    }

    resolve();
  });
}

async function updateSpellsPrepared(actor, spellPreparedData) {
  return new Promise((resolve) => {
    resolve(updateCharacterCall(actor, "spell/prepare", spellPreparedData, "Spells Prepared"));
  });
}

async function updateDDBSpellsPrepared(actor, spells) {
  let promises = [];

  const preparedSpells = spells.filter((spell) =>
    spell.type === "spell"
    && spell.system.preparation?.mode === "prepared"
    && spell.flags.ddbimporter?.dndbeyond?.characterClassId
    && !spell.flags.ddbimporter.dndbeyond.granted
  ).map((spell) => {
    let spellPreparedData = {
      spellInfo: {
        spellId: spell.flags.ddbimporter.definitionId,
        characterClassId: spell.flags.ddbimporter.dndbeyond.characterClassId,
        entityTypeId: spell.flags.ddbimporter.entityTypeId,
        id: spell.flags.ddbimporter.id,
        prepared: spell.system.preparation.prepared === true,
      }
    };
    logger/* default.debug */.Z.debug(`Updating spell prepared state for ${spell.name} to ${spellPreparedData.spellInfo.prepared}`);
    return spellPreparedData;
  });

  preparedSpells.forEach((spellPreparedData) => {
    promises.push(updateSpellsPrepared(actor, spellPreparedData));
  });

  return Promise.all(promises);
}

async function spellsPrepared(actor, ddbCharacter) {
  if (!game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-spells-prepared")) return [];
  const ddbSpells = ddbCharacter.data.spells;

  const preparedSpells = actor.items.filter((item) => {
    const spellMatch = ddbSpells.find((s) =>
      s.name === item.name
      && item.system.preparation?.mode === "prepared"
      && item.flags.ddbimporter?.dndbeyond?.characterClassId
      && item.flags.ddbimporter?.dndbeyond?.characterClassId === s.flags.ddbimporter?.dndbeyond?.characterClassId
    );
    if (!spellMatch) return false;
    const select = item.type === "spell"
      && item.system.preparation?.mode === "prepared"
      && item.system.preparation.prepared !== spellMatch.system.preparation?.prepared;
    return spellMatch && select;
  });

  const results = updateDDBSpellsPrepared(actor, preparedSpells);

  return results;
}

async function updateItemsWithDDBInfo(itemsToAdd) {
  return Promise.all(itemsToAdd.map(async (item) => {
    if (!item.flags.ddbimporter?.definitionId && !item.flags.ddbimporter?.definitionEntityTypeId) {
      const ddbCompendiumMatch = await getCompendiumItemInfo(item);
      logger/* default.debug */.Z.debug(`Found item`, ddbCompendiumMatch);
      if (ddbCompendiumMatch
        && ddbCompendiumMatch.flags?.ddbimporter?.definitionId
        && ddbCompendiumMatch.flags?.ddbimporter?.definitionEntityTypeId
      ) {
        logger/* default.debug */.Z.debug(`Adding ${item.name} from DDB compendium match:`, ddbCompendiumMatch);
        foundry.utils.setProperty(item, "flags.ddbimporter.definitionId", ddbCompendiumMatch.flags.ddbimporter.definitionId);
        foundry.utils.setProperty(item, "flags.ddbimporter.definitionEntityTypeId", ddbCompendiumMatch.flags.ddbimporter.definitionEntityTypeId);
        foundry.utils.setProperty(item, "name", ddbCompendiumMatch.name);
        foundry.utils.setProperty(item, "type", ddbCompendiumMatch.type);
      }
    }
    return item;
  }));
}

function getValidContainer(actor, containerEntityId) {
  if (!containerEntityId) return undefined;
  if (parseInt(containerEntityId) === parseInt(actor.flags.ddbimporter.dndbeyond.characterId)) return true;
  const containers = actor.items.filter((i) => foundry.utils.getProperty(i, "flags.ddbimporter.dndbeyond.isContainer") === true);
  return containers.find((c) => parseInt(foundry.utils.getProperty(c, "flags.ddbimporter.id")) === parseInt(containerEntityId));
}

function generateItemsToAdd(actor, itemsToAdd) {
  const results = {
    items: [],
    toAdd: [],
    custom: [],
  };

  const characterId = parseInt(actor.flags.ddbimporter.dndbeyond.characterId);

  for (let i = 0; i < itemsToAdd.length; i++) {
    let item = itemsToAdd[i];
    if (item.flags.ddbimporter?.definitionId && item.flags.ddbimporter?.definitionEntityTypeId) {
      const containerItem = getValidContainer(actor, foundry.utils.hasProperty(item, "flags.ddbimporter.containerEntityId"));
      const containerEntityId = containerItem
        ? parseInt(foundry.utils.getProperty(containerItem, "flags.ddbimporter.id"))
        : characterId;
      const containerEntityTypeId = containerItem && containerEntityId !== characterId
        ? parseInt(foundry.utils.getProperty(containerItem, "flags.ddbimporter.entityTypeId"))
        : parseInt("1581111423");
      results.toAdd.push({
        containerEntityId,
        containerEntityTypeId,
        entityId: parseInt(item.flags.ddbimporter.definitionId),
        entityTypeId: parseInt(item.flags.ddbimporter.definitionEntityTypeId),
        quantity: parseInt(item.system.quantity),
      });
    } else {
      results.custom.push(item);
    }
    results.items.push(item);
  }
  return results;
}

async function deleteDDBCustomItems(actor, itemsToDelete) {
  return new Promise((resolve) => {
    let customItemResults = [];
    for (let i = 0; i < itemsToDelete.length; i++) {
      const item = itemsToDelete[i];
      const customData = {
        itemState: "DELETE",
        customValues: {
          characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
          id: item.flags.ddbimporter.definitionId,
          mappingId: item.flags.ddbimporter.id,
          partyId: null,
        }
      };
      if (foundry.utils.getProperty(customData, "customValues.id") !== undefined
        && foundry.utils.getProperty(customData, "customValues.mappingId") !== undefined
      ) {
        const result = updateCharacterCall(actor, "custom/item", customData, { name: item.name }).then((data) => {
          foundry.utils.setProperty(item, "flags.ddbimporter.delete", data);
          foundry.utils.setProperty(item, "flags.ddbimporter.custom", true);
          foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.isCustomItem", true);
          return item;
        });
        customItemResults.push(result);
      } else {
        logger/* default.error */.Z.error(`Custom item ${item.name} is missing metadata, please manually update and re-import`);
        ui.notifications.error(`Custom item ${item.name} is missing metadata, please manually update and re-import`);
      }
    }

    resolve(customItemResults);
  });
}

async function addDDBCustomItems(actor, itemsToAdd) {
  let customItemResults = [];
  for (let i = 0; i < itemsToAdd.length; i++) {
    const item = itemsToAdd[i];
    const containerEntityId = foundry.utils.hasProperty(item, "flags.ddbimporter.containerEntityId")
      ? parseInt(item.flags.ddbimporter.containerEntityId)
      : parseInt(actor.flags.ddbimporter.dndbeyond.characterId);
    const containerEntityTypeId = foundry.utils.hasProperty(item, "flags.ddbimporter.containerEntityTypeId")
      ? parseInt(item.flags.ddbimporter.containerEntityTypeId)
      : parseInt("1581111423");
    const customData = {
      itemState: "NEW",
      customValues: {
        characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
        containerEntityId,
        containerEntityTypeId,
        name: item.name,
        description: getCustomItemDescription(item.system.description.value),
        quantity: parseInt(item.system.quantity),
        cost: null,
        weight: Number.isInteger(item.system.weight) ? parseInt(item.system.weight) : 0,
      }
    };
    const result = updateCharacterCall(actor, "custom/item", customData, { name: item.name }).then((data) => {
      foundry.utils.setProperty(item, "flags.ddbimporter.id", data.data.addItems[0].id);
      foundry.utils.setProperty(item, "flags.ddbimporter.custom", true);
      foundry.utils.setProperty(item, "flags.ddbimporter.ddbCustomAdded", true);
      foundry.utils.setProperty(item, "flags.ddbimporter.dndbeyond.isCustomItem", true);
      foundry.utils.setProperty(item, "flags.ddbimporter.definitionId", data.data.addItems[0].definition.id);
      foundry.utils.setProperty(item, "flags.ddbimporter.containerEntityId", data.data.addItems[0].definition.containerEntityId);
      foundry.utils.setProperty(item, "flags.ddbimporter.containerEntityTypeId", data.data.addItems[0].definition.containerEntityTypeId);
      return item;
    });
    customItemResults.push(result);
  }

  return Promise.all(customItemResults);
}

async function addDDBEquipment(actor, itemsToAdd) {
  const ddbEnrichedItems = await updateItemsWithDDBInfo(itemsToAdd);
  const generatedItemsToAddData = generateItemsToAdd(actor, ddbEnrichedItems);

  const addDebugData = generatedItemsToAddData.items.map((i) => {
    return {
      name: i.name,
      definitionId: i.flags.ddbimporter.definitionId,
      definitionEntityTypeId: i.flags.ddbimporter.definitionEntityTypeId,
      containerEntityId: i.flags.ddbimporter.containerEntityId,
      containerEntityTypeId: i.flags.ddbimporter.containerEntityTypeId,
      entityTypeId: i.flags.ddbimporter.entityTypeId,
    };
  });

  logger/* default.debug */.Z.debug(`Generated items data`, generatedItemsToAddData);
  logger/* default.debug */.Z.debug(`Generated items data light`, addDebugData);

  const addItemData = {
    equipment: generatedItemsToAddData.toAdd,
  };

  const customItems = await addDDBCustomItems(actor, generatedItemsToAddData.custom);
  logger/* default.debug */.Z.debug("Adding custom items:", customItems);

  try {
    const customItemResults = await actor.updateEmbeddedDocuments("Item", customItems);
    logger/* default.debug */.Z.debug("customItemResults", customItemResults);
  } catch (err) {
    logger/* default.error */.Z.error(`Unable to update character with equipment, got the error:`, err);
    logger/* default.error */.Z.error(err.stack);
    logger/* default.error */.Z.error(`Update payload:`, customItems);
  }

  if (addItemData.equipment.length > 0) {
    const itemResults = await updateCharacterCall(actor, "equipment/add", addItemData, "Adding equipment");
    try {
      const itemUpdates = itemResults.data.addItems
        .filter((addedItem) => ddbEnrichedItems.some((i) =>
          i.flags.ddbimporter
          && i.flags.ddbimporter.definitionId === addedItem.definition.id
          && i.flags.ddbimporter.definitionEntityTypeId === addedItem.definition.entityTypeId
        ))
        .map((addedItem) => {
          let updatedItem = ddbEnrichedItems.find((i) =>
            i.flags.ddbimporter
            && i.flags.ddbimporter.definitionId === addedItem.definition.id
            && i.flags.ddbimporter.definitionEntityTypeId === addedItem.definition.entityTypeId
          );
          foundry.utils.setProperty(updatedItem, "flags.ddbimporter.id", addedItem.id);
          foundry.utils.setProperty(updatedItem, "flags.ddbimporter.containerEntityId", addedItem.containerEntityId);
          foundry.utils.setProperty(updatedItem, "flags.ddbimporter.containerEntityTypeId", addedItem.containerEntityTypeId);
          return updatedItem;
        });

      logger/* default.debug */.Z.debug("Character item updates:", itemUpdates);
      logger/* default.debug */.Z.debug("Character custom item updates:", customItems);

      try {
        if (itemUpdates.length > 0) await actor.updateEmbeddedDocuments("Item", itemUpdates);
        if (customItems.length > 0) await actor.updateEmbeddedDocuments("Item", customItems);
      } catch (err) {
        logger/* default.error */.Z.error(`Unable to update character with equipment, got the error:`, err);
        logger/* default.error */.Z.error(`Update payload:`, itemUpdates);
        logger/* default.error */.Z.error(`Update custom payload:`, customItems);
        logger/* default.error */.Z.error("Update Item Information:", addDebugData);
      }

    } catch (err) {
      logger/* default.error */.Z.error(`Unable to filter updated equipment, got the error:`, err);
      logger/* default.error */.Z.error(`itemsToAdd`, itemsToAdd);
      logger/* default.error */.Z.error(`ddbEnrichedItems`, ddbEnrichedItems);
      logger/* default.error */.Z.error(`equipmentToAdd`, generatedItemsToAddData);
      logger/* default.error */.Z.error(`itemResults`, itemResults);
      logger/* default.error */.Z.error(`customItems`, customItems);
      logger/* default.error */.Z.error("Update Item Information:", addDebugData);
    }

    return itemResults;
  } else {
    return [];
  }
}

async function addEquipment(actor, ddbCharacter) {
  const syncItemReady = actor.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-equipment")) return [];
  const ddbItems = ddbCharacter.data.inventory;

  const items = getFoundryItems(actor);
  const itemsToAdd = items.filter((item) =>
    !(item.flags.ddbimporter?.action ?? false)
    && item.system.quantity !== 0
    && dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type)
    && !item.flags.ddbimporter?.custom
    && (!item.flags.ddbimporter?.id
    || !ddbItems.some((s) => s.flags.ddbimporter?.id === item.flags.ddbimporter?.id && s.type === item.type))
  );

  return addDDBEquipment(actor, itemsToAdd);
}


// updates custom names on regular items
async function updateDDBCustomNames(actor, items) {
  let promises = [];

  items.forEach((item) => {
    const customData = {
      customValues: {
        characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
        contextId: null,
        contextTypeId: null,
        notes: null,
        typeId: 8,
        value: item.name.replaceAll("[Infusion]", "").trim(),
        valueId: `${item.flags.ddbimporter.id}`,
        valueTypeId: `${item.flags.ddbimporter.entityTypeId}`,
      }
    };
    // custom name on standard equipment
    promises.push(updateCharacterCall(actor, "equipment/custom", customData, "Updating custom names"));
  });

  return Promise.all(promises);

}

// updates names of items and actions
async function updateCustomNames(actor, ddbCharacter) {
  const syncItemReady = actor.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-equipment")) return [];
  const ddbItems = ddbCharacter.data.inventory;

  const foundryItems = getFoundryItems(actor);

  const itemsToName = foundryItems.filter((item) =>
    item.system.quantity !== 0
    && (dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type) || item.flags.ddbimporter?.action)
    && item.flags.ddbimporter?.id
    && ddbItems.some((ddbItem) =>
      ddbItem.flags.ddbimporter?.id === item.flags.ddbimporter.id
      && ddbItem.type === item.type
      && ddbItem.name.replaceAll("[Infusion]", "").trim() !== item.name.replaceAll("[Infusion]", "").trim()
    )
  );

  return updateDDBCustomNames(actor, itemsToName);
}

async function removeDDBEquipment(actor, itemsToRemove) {
  let promises = [];

  itemsToRemove.forEach((item) => {
    if (item.flags?.ddbimporter?.id) {
      logger/* default.debug */.Z.debug(`Removing item ${item.name}`);
      if (item.flags?.ddbimporter?.custom) {
        promises.push(deleteDDBCustomItems(actor, [item]));
      } else {
        promises.push(updateCharacterCall(actor, "equipment/remove", { itemId: parseInt(item.flags.ddbimporter.id) }, "Removing equipment"));
      }
    }
  });

  return Promise.all(promises);
}

async function removeEquipment(actor, ddbCharacter) {
  const syncItemReady = actor.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-equipment")) return [];
  const ddbItems = ddbCharacter.data.inventory;

  const items = getFoundryItems(actor);
  const itemsToRemove = ddbItems.filter((item) =>
    (!items.some((s) => (item.flags.ddbimporter?.id === s.flags.ddbimporter?.id && s.type === item.type) && !s.flags.ddbimporter?.action)
    || items.some((s) => (item.flags.ddbimporter?.id === s.flags.ddbimporter?.id && s.type === item.type) && !s.flags.ddbimporter?.action && s.system.quantity == 0))
    && dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(item.type)
    && item.flags.ddbimporter?.id
  );

  return removeDDBEquipment(actor, itemsToRemove);
}

async function updateDDBEquipmentStatus(actor, updateItemDetails, ddbItems) {
  const itemsToEquip = updateItemDetails.itemsToEquip || [];
  const itemsToAttune = updateItemDetails.itemsToAttune || [];
  const itemsToCharge = updateItemDetails.itemsToCharge || [];
  const itemsToQuantity = updateItemDetails.itemsToQuantity || [];
  const itemsToName = updateItemDetails.itemsToName || [];
  const customItems = updateItemDetails.customItems || [];
  const itemsToMove = updateItemDetails.itemsToMove || [];
  const currencyItems = updateItemDetails.itemsToCurrency || [];

  let promises = [];

  itemsToMove.forEach((item) => {
    const itemData = {
      itemId: item.flags.ddbimporter.id,
      containerEntityId: item.flags.ddbimporter.containerEntityId,
      containerEntityTypeId: item.flags.ddbimporter.containerEntityTypeId,
    };
    promises.push(updateCharacterCall(actor, "equipment/move", itemData, { name: item.name }));
  });
  itemsToEquip.forEach((item) => {
    const itemData = { itemId: item.flags.ddbimporter.id, value: item.system.equipped };
    promises.push(updateCharacterCall(actor, "equipment/equipped", itemData, { name: item.name }));
  });
  itemsToAttune.forEach((item) => {
    // console.warn(item)
    const itemData = { itemId: item.flags.ddbimporter.id, value: item.system.attuned };
    promises.push(updateCharacterCall(actor, "equipment/attuned", itemData, { name: item.name }));
  });
  itemsToCharge.forEach((rawItem) => {
    const item = getItemRollData(actor, rawItem._id).item;
    const itemData = {
      itemId: item.flags.ddbimporter.id,
      charges: Math.max(0, parseInt(item.system.uses.max) - parseInt(item.system.uses.value)),
    };
    if (Number.isInteger(itemData.charges)) {
      promises.push(updateCharacterCall(actor, "equipment/charges", itemData, { name: item.name }));
    }
  });
  itemsToQuantity.forEach((item) => {
    const itemData = {
      itemId: item.flags.ddbimporter.id,
      quantity: parseInt(item.system.quantity),
    };
    promises.push(updateCharacterCall(actor, "equipment/quantity", itemData, { name: item.name }));
  });
  itemsToName.forEach((item) => {
    // historically items may not have this metadata
    const entityTypeId = item.flags?.ddbimporter?.entityTypeId
      ? item.flags.ddbimporter.entityTypeId
      : ddbItems.find((dItem) => dItem.id === item.flags.ddbimporter.id).entityTypeId;
    const customData = {
      customValues: {
        characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
        contextId: null,
        contextTypeId: null,
        notes: null,
        typeId: 8,
        value: item.name.replaceAll("[Infusion]", "").trim(),
        valueId: `${item.flags.ddbimporter.id}`,
        valueTypeId: `${entityTypeId}`,
      }
    };
    const flavor = { detail: "Updating Name", name: item.name, originalName: item.flags?.ddbimporter?.originalName };
    promises.push(updateCharacterCall(actor, "equipment/custom", customData, flavor));
  });

  for (const item of currencyItems) {
    // eslint-disable-next-line no-continue
    if (!foundry.utils.hasProperty(item, "system.currency.gp")) continue;
    const ddbItem = ddbItems.find((dItem) =>
      item.flags.ddbimporter.id === dItem.id
    );
    // eslint-disable-next-line no-continue
    if (ddbItem && !foundry.utils.hasProperty(ddbItem, "currency.gp")) continue;
    ["pp", "gp", "ep", "sp", "cp"].forEach((t) => {
      if (item.system.currency[t] !== ddbItem.currency[t]) {
        const currency = {
          amount: item.system.currency[t],
          characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
          destinationEntityId: item.flags.ddbimporter.id,
          destinationEntityTypeId: item.flags.ddbimporter.entityTypeId,
        };
        const type = dictionary/* default.currency */.Z.currency[t];
        promises.push(updateCharacterCall(actor, `currency/individual`, { type, currency }, `Currency - ${t}`));
      }
    });
  }

  customItems
    .filter((item) => {
      const isValid = foundry.utils.getProperty(item, "flags.ddbimporter.id") !== undefined
       && foundry.utils.getProperty(item, "flags.ddbimporter.definitionId") !== undefined;
      if (!isValid) {
        logger/* default.error */.Z.error(`Custom item ${item.name} is missing metadata, please manually update and re-import`);
        ui.notifications.error(`Custom item ${item.name} is missing metadata, please manually update and re-import`);
      }
      return isValid;
    })
    .forEach((item) => {
      const customData = {
        itemState: "UPDATE",
        customValues: {
          characterId: parseInt(actor.flags.ddbimporter.dndbeyond.characterId),
          id: item.flags.ddbimporter.definitionId,
          mappingId: item.flags.ddbimporter.id,
          name: item.name,
          description: getCustomItemDescription(item.system.description.value),
          // revist these need to be ints
          // weight: `${item.data.weight}`,
          // cost: item.data.price.value,
          cost: null,
          weight: Number.isInteger(item.system.weight) ? parseInt(item.system.weight) : 0,
          quantity: parseInt(item.system.quantity),
        }
      };
      promises.push(updateCharacterCall(actor, "custom/item", customData, "Updating Custom Item"));
    });

  return Promise.all(promises);
}


async function equipmentStatus(actor, ddbCharacter, addEquipmentResults) {
  const syncItemReady = actor.flags.ddbimporter?.syncItemReady;
  if (syncItemReady && !game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-equipment")) return [];
  // reload the actor following potential updates to equipment
  let ddbItems = ddbCharacter.source.ddb.character.inventory;
  let customDDBItems = ddbCharacter.source.ddb.character.customItems;
  if (addEquipmentResults?.system) {
    actor = game.actors.get(actor.id);
    ddbItems = ddbItems.concat(addEquipmentResults.system.addItems);
  }

  const foundryItems = getFoundryItems(actor);

  const itemsToEquip = foundryItems.filter((item) =>
    foundry.utils.hasProperty(item, "system.equipped")
    && foundry.utils.hasProperty(item, "flags.ddbimporter.id")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.action")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      foundry.utils.getProperty(item, "flags.ddbimporter.id") === dItem.id
      && item.system.equipped !== dItem.equipped
    )
  );
  const itemsToAttune = foundryItems.filter((item) =>
    ["optional", "required"].includes(foundry.utils.getProperty(item, "system.attunement"))
    && foundry.utils.hasProperty(item, "flags.ddbimporter.id")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.action")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      foundry.utils.getProperty(item, "flags.ddbimporter.id") === dItem.id
      && item.system.attuned !== dItem.isAttuned
    )
  );
  const itemsToCharge = foundryItems.filter((rawItem) => {
    const item = getItemRollData(actor, rawItem._id).item;
    return foundry.utils.hasProperty(item, "system.uses")
    && foundry.utils.hasProperty(item, "flags.ddbimporter.id")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.action")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      foundry.utils.getProperty(item, "flags.ddbimporter.id") === dItem.id
      && Number.isInteger(parseInt(item.system.uses?.max)) && Number.isInteger(parseInt(dItem.limitedUse?.numberUsed))
      && ((parseInt(item.system.uses.max) - parseInt(item.system.uses.value)) !== dItem.limitedUse.numberUsed)
    );
  });
  const itemsToQuantity = foundryItems.filter((item) =>
    foundry.utils.hasProperty(item, "system.quantity")
    && item.system.quantity !== 0
    && !foundry.utils.getProperty(item, "system.armor.type")
    && ((item.type !== "weapon" && item.type !== "armor") || foundry.utils.getProperty(item, "flags.ddbimporter.dndbeyond.stackable"))
    && foundry.utils.hasProperty(item, "flags.ddbimporter.id")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.action")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      foundry.utils.getProperty(item, "flags.ddbimporter.id") === dItem.id
      && item.system.quantity !== dItem.quantity
    )
  );
  // this is for items that have been added and might have a different name
  const itemsToName = foundryItems.filter((item) =>
    foundry.utils.hasProperty(item, "flags.ddbimporter.id")
    && item.system?.quantity !== 0
    && !foundry.utils.getProperty(item, "flags.ddbimporter.custom")
    && ddbItems.some((dItem) =>
      item.flags.ddbimporter.originalName === dItem.definition.name
      && item.flags.ddbimporter.originalName !== item.name.replaceAll("[Infusion]", "").trim()
      && foundry.utils.getProperty(item, "flags.ddbimporter.id") === dItem.id
      && item.name.replaceAll("[Infusion]", "").trim() !== dItem.definition.name
    )
  );

  // update.name || update.data?.description || update.data?.weight || update.data?.price || update.data?.quantity
  const customItems = foundryItems.filter((item) =>
    foundry.utils.hasProperty(item, "flags.ddbimporter.id")
    && item.system?.quantity !== 0
    && (foundry.utils.getProperty(item, "flags.ddbimporter.custom") === true || foundry.utils.getProperty(item, "flags.ddbimporter.isCustom") === true)
    && customDDBItems.some((dItem) => dItem.id === item.flags.ddbimporter.id
      && (
        item.name !== dItem.name
        || getCustomItemDescription(item.system.description.value) != dItem.description
        || (foundry.utils.hasProperty(item, "system.quantity") && item.system.quantity != dItem.quantity)
        || (foundry.utils.hasProperty(item, "system.weight") && item.system.weight != dItem.weight)
        //  ||
        // item.data.price != dItem.cost
      )
    )
  );

  const itemsToMove = foundryItems.filter((item) =>
    foundry.utils.hasProperty(item, "flags.ddbimporter.id")
    && !foundry.utils.getProperty(item, "flags.ddbimporter.action")
    && foundry.utils.hasProperty(item, "flags.ddbimporter.containerEntityId")
    && ddbItems.some((dItem) =>
      item.flags.ddbimporter.id === dItem.id
      && parseInt(item.flags.ddbimporter.containerEntityId) !== parseInt(dItem.containerEntityId)
    ));

  const itemsToCurrency = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-currency")
    ? foundryItems.filter((item) =>
      foundry.utils.hasProperty(item, "flags.ddbimporter.id")
      && foundry.utils.hasProperty(item, "flags.ddbimporter.entityTypeId")
      && !foundry.utils.getProperty(item, "flags.ddbimporter.action")
      && !foundry.utils.getProperty(item, "flags.ddbimporter.custom")
      && foundry.utils.hasProperty(item, "system.currency.gp")
      && ddbItems.some((dItem) =>
        item.flags.ddbimporter.id === dItem.id
        && !(0,isequal/* isEqual */.X)(dItem.currency, item.system.currency)
      ))
    : [];

  const itemsToUpdate = {
    itemsToEquip,
    itemsToAttune,
    itemsToCharge,
    itemsToQuantity,
    itemsToName,
    customItems,
    itemsToMove,
    itemsToCurrency,
  };

  logger/* default.debug */.Z.debug("Calling DDB Item Update with", {
    actor,
    itemsToUpdate,
    ddbItems
  });

  return updateDDBEquipmentStatus(actor, itemsToUpdate, ddbItems);

}

async function updateActionUseStatus(actor, actionData, actionName) {
  return new Promise((resolve) => {
    resolve(updateCharacterCall(actor, "action/use", actionData, `Action Use for ${actionName}`));
  });
}

async function updateDDBActionUseStatus(actor, actions) {
  let promises = [];
  actions.forEach((rawAction) => {
    const action = getItemRollData(actor, rawAction._id).item;
    const actionData = {
      actionId: action.flags.ddbimporter.id,
      entityTypeId: action.flags.ddbimporter.entityTypeId,
      uses: Math.max(0, parseInt(action.system.uses.max) - parseInt(action.system.uses.value)),
    };
    promises.push(updateActionUseStatus(actor, actionData, action.name));
  });
  return Promise.all(promises);
}

async function actionUseStatus(actor, ddbCharacter) {
  const syncActionReady = actor.flags.ddbimporter?.syncActionReady;
  if (syncActionReady && !game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "sync-policy-action-use")) return [];

  let ddbActions = ddbCharacter.data.actions;

  const foundryItems = getFoundryItems(actor);

  const actionsToChange = foundryItems.filter((item) =>
    (item.flags.ddbimporter?.action || item.type === "feat")
    && item.flags.ddbimporter?.id && item.flags.ddbimporter?.entityTypeId
    && ddbActions.some((dItem) =>
      item.flags.ddbimporter.id === dItem.flags.ddbimporter.id
      && item.flags.ddbimporter.entityTypeId === dItem.flags.ddbimporter.entityTypeId
      && item.name === dItem.name && item.type === dItem.type
      && Number.isInteger(parseInt(item.system.uses?.value))
      && Number.parseInt(item.system.uses.value) !== Number.parseInt(dItem.system.uses.value)
    )
  );
  const actionChanges = updateDDBActionUseStatus(actor, actionsToChange);

  return actionChanges;
}

async function updateDDBCharacter(actor) {
  const cobaltCheck = await (0,Secrets/* checkCobalt */.B)(actor.id);

  if (cobaltCheck.success) {
    logger/* default.debug */.Z.debug(`Cobalt checked`);
  } else {
    logger/* default.error */.Z.error(`Cobalt cookie expired, please reset`);
    logger/* default.error */.Z.error(cobaltCheck.message);
    throw cobaltCheck.message;
  }

  const characterId = actor.flags.ddbimporter.dndbeyond.characterId;
  const syncId = actor.flags["ddb-importer"]?.syncId ? actor.flags["ddb-importer"].syncId + 1 : 0;

  const ddbCharacterOptions = {
    currentActor: actor,
    characterId,
    selectResources: false,
    enableCompanions: false,
  };
  const getOptions = {
    syncId,
    localCobaltPostFix: actor.id,
  };
  const ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
  const activeUpdateState = ddbCharacter.getCurrentDynamicUpdateState();
  await ddbCharacter.disableDynamicUpdates();
  await ddbCharacter.getCharacterData(getOptions);

  if (!ddbCharacter.source.ddb.character.canEdit) {
    logger/* default.debug */.Z.debug("Update DDB", { ddbCharacter, source: ddbCharacter.source });
    throw new Error("User is not allowed to edit character on D&D Beyond.");
  }

  logger/* default.debug */.Z.debug("Current actor:", foundry.utils.duplicate(actor));
  logger/* default.debug */.Z.debug("DDB Parsed data:", { data: ddbCharacter.data, source: ddbCharacter.source });

  let singlePromises = []
    .concat(
      currency(actor, ddbCharacter),
      hitDice(actor, ddbCharacter),
      spellSlots(actor, ddbCharacter),
      spellSlotsPact(actor, ddbCharacter),
      inspiration(actor, ddbCharacter),
      exhaustion(actor, ddbCharacter),
      deathSaves(actor, ddbCharacter),
      xp(actor, ddbCharacter),
    ).flat();

  const singleResults = await Promise.all(singlePromises);
  const hpResults = await hitPoints(actor, ddbCharacter);
  const spellsPreparedResults = await spellsPrepared(actor, ddbCharacter);
  const actionStatusResults = await actionUseStatus(actor, ddbCharacter);
  const nameUpdateResults = await updateCustomNames(actor, ddbCharacter);
  const addEquipmentResults = await addEquipment(actor, ddbCharacter);
  const removeEquipmentResults = await removeEquipment(actor, ddbCharacter);
  const equipmentStatusResults = await equipmentStatus(actor, ddbCharacter, addEquipmentResults);
  const conditionResults = await conditions(actor, ddbCharacter);
  // if a known/choice spellcaster
  // and new spell/ spells removed
  // for each spell add or remove, e.g.
  // const spellsData = {
  //   characterClassId: 52134801,
  //   spellId: 2019,
  //   id: 136157,
  //   entityTypeId: 435869154,
  //   remove: true,
  // };
  // const spellSlots = updateCharacterCall(actor, "spells", spellsData);
  // promises.push(spellSlots);

  actor.setFlag("ddb-importer", "syncId", syncId);
  await ddbCharacter.setActiveSyncSpellsFlag(true);

  // we can now process item attunements and uses (not yet done)

  const results = singleResults.concat(
    hpResults,
    nameUpdateResults,
    addEquipmentResults,
    spellsPreparedResults,
    removeEquipmentResults,
    equipmentStatusResults,
    actionStatusResults,
    conditionResults,
  ).filter((result) => result !== undefined);

  logger/* default.debug */.Z.debug("Update results", results);
  await ddbCharacter.updateDynamicUpdates(activeUpdateState);

  return results;
}

// Called when characters are updated
// will dynamically sync status back to DDB
async function activeUpdateActor(actor, update) {
  // eslint-disable-next-line complexity
  return new Promise((resolve) => {

    const promises = [];

    const actorActiveUpdate = actor.flags.ddbimporter?.activeUpdate;

    if (actorActiveUpdate) {
      const syncHP = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-hitpoints");
      const syncCurrency = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-currency");
      const syncSpellSlots = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-spells-slots");
      const syncInspiration = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-inspiration");
      const syncConditions = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-condition");
      const syncDeathSaves = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-deathsaves");
      const syncXP = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-xp");


      if (syncHP && (update.system?.attributes?.hp?.value
        || update.system?.attributes?.hp?.temp)
      ) {
        logger/* default.debug */.Z.debug("Updating DDB Hitpoints...");
        promises.push(updateDDBHitPoints(actor));
      }
      if (syncHP && update.system?.attributes?.hp?.tempmax) {
        logger/* default.debug */.Z.debug("Updating DDB Bonus Hitpoints...");
        promises.push(updateTempMaxDDBHitPoints(actor));
      }
      if (syncCurrency && update.system?.currency) {
        logger/* default.debug */.Z.debug("Updating DDB Currency...");
        promises.push(updateDDBCurrency(actor));
      }
      if (syncSpellSlots && update.system?.spells) {
        const spellKeys = Object.keys(update.system.spells);
        if (spellKeys.includes("pact")) {
          logger/* default.debug */.Z.debug("Updating DDB SpellSlots Pack...");
          promises.push(updateDDBSpellSlotsPact(actor));
        }
        const spellLevelKeys = ["spell1", "spell2", "spell3", "spell4", "spell5", "spell6", "spell7", "spell8", "spell9"];
        const foundSpells = spellKeys.some((spellKey) => spellLevelKeys.includes(spellKey));
        if (foundSpells) {
          logger/* default.debug */.Z.debug("Updating DDB SpellSlots...");
          promises.push(updateDynamicDDBSpellSlots(actor, update));
        }
      }
      if (syncInspiration
        && (update.system?.attributes?.inspiration === true || update.system?.attributes?.inspiration === false)
      ) {
        logger/* default.debug */.Z.debug("Updating DDB Inspiration...");
        promises.push(updateDDBInspiration(actor));
      }
      if (syncConditions && update.system?.attributes?.exhaustion) {
        logger/* default.debug */.Z.debug("Updating DDB Exhaustion...");
        promises.push(updateDDBExhaustion(actor));
      }
      if (syncDeathSaves && update.system?.attributes?.death) {
        logger/* default.debug */.Z.debug("Updating DDB DeathSaves...");
        promises.push(updateDDBDeathSaves(actor));
      }
      if (syncXP && update.system?.attributes?.xp) {
        logger/* default.debug */.Z.debug("Updating DDB XP...");
        promises.push(updateDDBXP(actor));
      }
    }
    resolve(promises);

  });
}

const DISABLE_FOUNDRY_UPGRADE = {
  applyFeatures: false,
  addFeatures: false,
  promptAddFeatures: false,
};

// eslint-disable-next-line complexity
async function generateDynamicItemChange(actor, document, update) {
  const updateItemDetails = {
    itemsToEquip: [],
    itemsToAttune: [],
    itemsToCharge: [],
    itemsToQuantity: [],
    itemsToName: [],
    customItems: [],
    itemsToMove: [],
  };

  // console.warn("Document", document);
  // console.warn("ItemUpdate", update);

  if (foundry.utils.getProperty(document, "flags.ddbimporter.custom") === true || foundry.utils.getProperty(document, "flags.ddbimporter.isCustom") === true) {
    if (update.name || update.system?.description || update.system?.weight || update.system?.price || update.system?.quantity) {
      updateItemDetails.customItems.push(foundry.utils.duplicate(document));
    }
  } else {
    if (update.system?.uses) {
      updateItemDetails.itemsToCharge.push(foundry.utils.duplicate(document));
    }
    if (update.system?.attuned) {
      updateItemDetails.itemsToAttune.push(foundry.utils.duplicate(document));
    }
    if (update.system?.quantity) {
      // if its a weapon or armor we actually need to push a new one
      if (!document.flags.ddbimporter?.dndbeyond?.stackable && update.system.quantity > 1) {
        // Some items are not stackable on DDB

        await document.update({ system: { quantity: 1 } });
        let newDocument = foundry.utils.duplicate(document.toObject());
        delete newDocument._id;
        delete newDocument.flags.ddbimporter.id;

        let results = [];
        for (let i = 1; i < update.system.quantity; i++) {
          logger/* default.debug */.Z.debug(`Adding item # ${i}`);
          let newDoc = await actor.createEmbeddedDocuments("Item", [newDocument], DISABLE_FOUNDRY_UPGRADE);
          results.push(newDoc);
          // new doc/item push to ddb handled by the add item hook
        }
        return results;
      } else {
        updateItemDetails.itemsToQuantity.push(foundry.utils.duplicate(document));
      }
    }
    if (update.system?.equipped) {
      updateItemDetails.itemsToEquip.push(foundry.utils.duplicate(document));
    }
    if (update.name) {
      updateItemDetails.itemsToName.push(foundry.utils.duplicate(document));
    }
    if (update.system?.container) {
      const containerisedDocument = foundry.utils.duplicate(document);
      setContainerDetails(actor, containerisedDocument);
      updateItemDetails.itemsToMove.push(containerisedDocument);
    }
    if (update.system?.currency) {
      updateItemDetails.itemsToCurrency.push(foundry.utils.duplicate(document));
    }
  }

  logger/* default.debug */.Z.debug("UpdateItemDetails", updateItemDetails);

  return updateDDBEquipmentStatus(actor, updateItemDetails, []);

}

async function updateSpellPrep(actor, document) {
  return new Promise((resolve) => {
    const spellSyncFlag = actor.flags.ddbimporter?.activeSyncSpells;
    if (spellSyncFlag) {
      logger/* default.debug */.Z.debug("Updating DDB SpellsPrepared...");
      // get spells class
      const klassName = document.flags.ddbimporter?.dndbeyond?.class;
      const klass = actor.items.find((item) => item.name === klassName && item.type === "class");
      if (klass) {
        resolve(updateDDBSpellsPrepared(actor, [document]));
      } else {
        resolve([]);
      }
    } else {
      logger/* default.warn */.Z.warn("Unable to sync spell prep status until character is imported or updated to DDB");
      resolve([]);
    }
  });
}

// Called when characters items are updated
// will dynamically sync status back to DDB
async function activeUpdateUpdateItem(document, update) {
  // eslint-disable-next-line complexity
  return new Promise((resolve) => {

    // we check to see if this is actually an embedded item
    const parentActor = document.parent;
    const actorActiveUpdate = parentActor && parentActor.flags.ddbimporter?.activeUpdate;
    const ignore = foundry.utils.getProperty(document, "flags.ddbimporter.ignoreItemUpdate") ?? false;

    if (!parentActor || !actorActiveUpdate || ignore) {
      resolve([]);
    } else {
      logger/* default.debug */.Z.debug("Preparing to sync item change to DDB...");
      const action = document.flags.ddbimporter?.action || document.type === "feat";
      const syncEquipment = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-equipment");
      const syncActionUse = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-action-use");
      const syncHD = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-hitdice");
      const syncSpellsPrepared = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-spells-prepared");
      const isDDBItem = document.flags.ddbimporter?.id;
      const customItem = document.flags.ddbimporter?.custom || false;

      const customNameAllowed = dictionary/* default.types.inventory.includes */.Z.types.inventory.includes(document.type) || document.flags.ddbimporter?.action;
      if (!customItem && update.name && customNameAllowed) {
        updateDDBCustomNames(parentActor, [document.toObject()]);
      }

      logger/* default.debug */.Z.debug("active update item details", { action, syncActionUse, isDDBItem });
      // is this a DDB action, or do we treat this as an item?
      if (action && syncActionUse && isDDBItem) {
        if (update.system?.uses) {
          logger/* default.debug */.Z.debug("Updating action uses", update);
          updateDDBActionUseStatus(parentActor, [foundry.utils.duplicate(document)]);
        } else {
          resolve([]);
        }
      } else if (document.type === "class" && syncHD && update.system?.hitDiceUsed) {
        logger/* default.debug */.Z.debug("Updating hitdice on DDB");
        resolve(updateDDBHitDice(parentActor, document, update));
      } else if (document.type === "spell" && syncSpellsPrepared
        && update.system?.preparation && document.system.preparation.mode === "prepared"
      ) {
        logger/* default.debug */.Z.debug("Updating DDB SpellsPrepared...");
        updateSpellPrep(parentActor, document).then((results) => {
          logger/* default.debug */.Z.debug("Spell prep results", results);
          const failures = results.find((result) => result.success !== true);
          const ddbCharacterOptions = {
            currentActor: parentActor,
            characterId: undefined,
            selectResources: false
          };
          // when update is refactored to a class, change this
          const ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
          if (failures) ddbCharacter.setActiveSyncSpellsFlag(false);
          resolve(results);
        });
      } else if (syncEquipment && !action) {
        resolve(generateDynamicItemChange(parentActor, document, update));
      }
    }
  });
}


// Called when characters items are added/deleted
// will dynamically sync status back to DDB
async function activeUpdateAddOrDeleteItem(document, state) {
  return new Promise((resolve) => {
    let promises = [];

    const syncEquipment = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-equipment");
    // we check to see if this is actually an embedded item
    const parentActor = document.parent;
    const actorActiveUpdate = parentActor && foundry.utils.getProperty(parentActor, "flags.ddbimporter.activeUpdate");
    const ignore = foundry.utils.getProperty(document, "flags.ddbimporter.ignoreItemUpdate") ?? false;

    if (parentActor && actorActiveUpdate && syncEquipment && !ignore) {
      logger/* default.debug */.Z.debug(`Checking to see if ${state.toLowerCase()} can be added to DDB...`);
      const action = document.flags.ddbimporter?.action || ["feat", "class", "subclass", "spell", "background", "race"].includes(document.type);
      if (!action) {
        logger/* default.debug */.Z.debug(`Attempting to ${state.toLowerCase()} new Item`, document);

        switch (state) {
          case "CREATE": {
            // const characterId = parseInt(parentActor.flags.ddbimporter.dndbeyond.characterId);
            // const containerId = document.flags?.ddbimporter?.containerEntityId;
            // if (Number.isInteger(containerId) && characterId != parseInt(containerId)) {
            //   // update item container
            //   logger.debug(`Moving item from container`, document);
            //   document.update({
            //     "flags.ddbimporter.containerEntityId": characterId,
            //   });
            //   const itemData = {
            //     itemId: parseInt(document.flags.ddbimporter.id),
            //     containerEntityId: characterId,
            //     containerEntityTypeId: 1581111423,
            //   };
            //   const flavor = { summary: "Moving item to character", name: document.name, containerId: foundry.utils.duplicate(containerId) };
            //   promises.push(updateCharacterCall(parentActor, "equipment/move", itemData, flavor));
            // } else {
            logger/* default.debug */.Z.debug(`Creating item`, document);
            promises.push(addDDBEquipment(parentActor, [document.toObject()]));
            // }
            break;
          }
          case "DELETE": {
            // const collectionItems = getItemCollectionItems(parentActor);
            // const collectionItemDDBIds = collectionItems
            //   .filter((item) => foundry.utils.hasProperty(item, "flags.ddbimporter.id"))
            //   .map((item) => item.flags.ddbimporter.id);
            // if (foundry.utils.hasProperty(document, "flags.ddbimporter.id")
            //   && collectionItemDDBIds.includes(document.flags.ddbimporter.id)
            // ) {
            //   // we don't have to handle deletes as the item collection move is handled above
            //   logger.debug(`Moving item to container`, document);
            // } else {
            logger/* default.debug */.Z.debug(`Deleting item`, document);
            promises.push(removeDDBEquipment(parentActor, [document.toObject()]));
            // }
            // break;
          }
          // no default
        }
      }
    }
    resolve(promises);
  });
}

// called when effects are added/deleted/updated
async function activeUpdateEffectTrigger(document, state) {
  return new Promise((resolve) => {
    let promises = [];

    const syncConditions = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-policy-condition");
    // we check to see if this is actually an embedded item
    const parentActor = document.parent;
    const actorActiveUpdate = parentActor && parentActor.flags.ddbimporter?.activeUpdate;

    if (parentActor && actorActiveUpdate && syncConditions) {
      logger/* default.debug */.Z.debug(`Preparing to ${state.toLowerCase()} condition on DDB...`);
      // is it a condition?
      // is it a suitable type?
      const condition = getCondition(document.system?.name ?? document.system?.label);
      // exhaustion is a special case, but also a condition effect, handled by character update
      const notExhaustion = condition ? condition.ddbId !== 4 : false;

      if (condition && notExhaustion) {
        logger/* default.debug */.Z.debug(`Attempting to ${state.toLowerCase()} Condition`, document);
        switch (state) {
          case "CREATE":
            condition.applied = true;
            promises.push(updateDDBCondition(parentActor, condition));
            break;
          case "UPDATE":
            condition.applied = !document.system.disabled;
            promises.push(updateDDBCondition(parentActor, condition));
            break;
          case "DELETE":
            condition.applied = false;
            promises.push(updateDDBCondition(parentActor, condition));
            break;
          // no default
        }
      }
    }
    resolve(promises);
  });
}

function activateUpdateHooks() {
  // check to make sure we can sync back, currently only works for 1 gm user
  if (src_settings/* default.STATUS.activeUpdate */.Z.STATUS.activeUpdate()) {
    Hooks.on("updateActor", activeUpdateActor);
    Hooks.on("updateItem", activeUpdateUpdateItem);
    Hooks.on("createItem", (document) => activeUpdateAddOrDeleteItem(document, "CREATE"));
    Hooks.on("deleteItem", (document) => activeUpdateAddOrDeleteItem(document, "DELETE"));
    Hooks.on("createActiveEffect", (document) => activeUpdateEffectTrigger(document, "CREATE"));
    Hooks.on("updateActiveEffect", (document) => activeUpdateEffectTrigger(document, "UPDATE"));
    Hooks.on("deleteActiveEffect", (document) => activeUpdateEffectTrigger(document, "DELETE"));
  }
}

// EXTERNAL MODULE: ./src/parser/DDBExtras.js
var DDBExtras = __webpack_require__(3671);
// EXTERNAL MODULE: ./src/apps/DDBMuncher.js + 17 modules
var DDBMuncher = __webpack_require__(2449);
;// CONCATENATED MODULE: ./src/apps/DDBCookie.js




class DDBCookie extends FormApplication {

  constructor(options, actor = null, localCobalt = false) {
    super(options);
    this.localCobalt = localCobalt;
    this.actor = actor;
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-cobalt-change";
    options.template = "modules/ddb-importer/handlebars/cobalt.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Cobalt Cookie";
  }

  /** @override */
  async getData() {
    const keyPostFix = this.localCobalt && this.actor ? this.actor.id : null;
    const cobalt = (0,Secrets/* getCobalt */.HF)(keyPostFix);
    const cobaltStatus = cobalt == "" ? { success: true } : await (0,Secrets/* checkCobalt */.B)();
    const expired = !cobaltStatus.success;

    return {
      expired: expired,
      cobaltCookie: cobalt,
      localCobalt: this.localCobalt && this.actor,
      actor: this.actor,
    };
  }

  /** @override */
  async _updateObject(event, formData) {
    event.preventDefault();
    const keyPostFix = this.localCobalt && this.actor ? this.actor.id : null;
    await (0,Secrets/* setCobalt */.hc)(formData['cobalt-cookie'], keyPostFix);

    const cobaltStatus = await (0,Secrets/* checkCobalt */.B)();
    if (!cobaltStatus.success) {
      new DDBCookie().render(true);
    } else {
      const callMuncher = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "settings-call-muncher");

      if (callMuncher) {
        game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "settings-call-muncher", false);
        new DDBMuncher/* default */.Z().render(true);
      }
    }
  }
}

;// CONCATENATED MODULE: ./src/apps/DDBKeyChange.js




class DDBKeyChange extends FormApplication {

  constructor({ local = false, success = null } = {}, options = {}) {
    options.template = local
      ? "modules/ddb-importer/handlebars/local-key.hbs"
      : "modules/ddb-importer/handlebars/key-change.hbs";
    super({}, options);
    this.local = local;
    this.success = success;
  }

  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "ddb-importer-key-change",
      // template: "modules/ddb-importer/handlebars/key-change.hbs",
      width: 500,
    });
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return this.local ? "DDB Importer Local Key" : "DDB Importer Key Change";
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#patreon-button").click(async (event) => {
      event.preventDefault();
      PatreonHelper/* default.linkToPatreon */.Z.linkToPatreon();
    });
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const key = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey(this.local);
    const setupConfig = {
      "beta-key": key ?? "",
    };
    const patreonUser = key && key !== ""
      ? PatreonHelper/* default.getPatreonUser */.Z.getPatreonUser(this.local)
      : "";

    const newKey = key === null || !key || key === "";
    const check = newKey
      ? { success: true, message: "" }
      : await PatreonHelper/* default.getPatreonValidity */.Z.getPatreonValidity(key);

    return {
      success: (check && check.success) ? check.success : false,
      message: (check && check.message) ? check.message : "Unable to check patreon key status",
      setupConfig: setupConfig,
      patreonLinked: patreonUser && patreonUser != "",
      patreonUser: patreonUser ?? "",
      local: this.local,
    };
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    const currentKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey(this.local);
    if (currentKey !== formData['beta-key']) {
      await PatreonHelper/* default.setPatreonKey */.Z.setPatreonKey(formData['beta-key'], this.local);
      await PatreonHelper/* default.setPatreonTier */.Z.setPatreonTier(this.local);
      if (this.success) {
        this.success();
      }
    }

    const callMuncher = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "settings-call-muncher");

    if (callMuncher) {
      game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "settings-call-muncher", false);
      new DDBMuncher/* default */.Z().render(true);
    }

  }
}

async function isValidKey() {
  let validKey = false;

  const key = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
  if (key === "") {
    validKey = true;
  } else {
    const check = await PatreonHelper/* default.getPatreonValidity */.Z.getPatreonValidity(key);
    if (check.success && check.data) {
      validKey = true;
    } else {
      validKey = false;
      game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "settings-call-muncher", true);
      new DDBKeyChange().render(true);
    }
  }
  return validKey;
}

;// CONCATENATED MODULE: ./src/effects/abilityOverrides.js



function buildBaseOverrideEffect(label) {
  let effect = {
    changes: [],
    duration: {
      seconds: null,
      startTime: null,
      rounds: null,
      turns: null,
      startRound: null,
      startTurn: null,
    },
    origin: "Ability.Override",
    tint: "",
    disabled: false,
    transfer: true,
    selectedKey: [],
    img: "icons/svg/anchor.svg",
    flags: {
      dae: { transfer: true },
      ddbimporter: { disabled: false, itemId: null, entityTypeId: null }
    },
  };
  effect.name = label;
  return effect;
}


function abilityOverrideEffects(overrides) {
  let effects = buildBaseOverrideEffect("Ability Overrides");

  dictionary/* default.character.abilities.forEach */.Z.character.abilities.forEach((ability) => {
    if (overrides[ability.value] === 0) return;
    effects.changes.push((0,effects_effects/* generateOverrideChange */.Pk)(overrides[ability.value], 50, `system.abilities.${ability.value}.value`));
  });

  return effects;
}

// EXTERNAL MODULE: ./src/lib/FolderHelper.js
var FolderHelper = __webpack_require__(7407);
;// CONCATENATED MODULE: ./src/parser/item/itemSpells.js





async function getCompendiumItemSpells(spells) {
  const getItemsOptions = {
    looseMatch: true,
    keepId: true,
    deleteCompendiumId: false,
  };
  const itemImporter = new DDBItemImporter/* default */.Z("spell", spells);
  await itemImporter.init();
  const compendiumSpells = await itemImporter.loadPassedItemsFromCompendium(spells, getItemsOptions);
  itemImporter.removeItems(compendiumSpells);
  const srdSpells = await itemImporter.getSRDCompendiumItems(true, true);
  const foundSpells = compendiumSpells.concat(srdSpells);

  const itemSpells = foundSpells.map((result) => {
    return {
      magicItem: {
        _id: result._id,
        id: result._id,
        pack: result.flags.ddbimporter.pack,
        img: result.img,
        name: result.name,
        flatDc: result.flags.ddbimporter.dndbeyond?.overrideDC,
        dc: result.flags.ddbimporter.dndbeyond?.dc,
      },
      _id: result._id,
      name: result.name,
      compendium: true,
    };
  });

  return [foundSpells, itemSpells];
}

/**
 * This adds magic item spells to an item, by looking in compendium or from a world.
 */
async function addMagicItemSpells(input) {
  // check for existing spells in spell compendium & srdCompendium
  const [compendiumSpells, compendiumItemSpells] = await getCompendiumItemSpells(input.itemSpells);
  // if spells not found create world version
  const itemImporter = new DDBItemImporter/* default */.Z("spell", input.itemSpells);
  itemImporter.removeItems(compendiumSpells);
  const remainingSpells = {
    itemSpells: await Iconizer/* default.updateMagicItemImages */.Z.updateMagicItemImages(itemImporter.documents),
  };
  const worldSpells = remainingSpells.length > 0
    ? await FolderHelper/* default.updateFolderItems */.Z.updateFolderItems("itemSpells", remainingSpells)
    : [];
  const itemSpells = worldSpells.concat(compendiumItemSpells);

  logger/* default.debug */.Z.debug("itemSpells fetched", itemSpells);

  // scan the inventory for each item with spells and copy the imported data over
  input.inventory.forEach((item) => {
    logger/* default.debug */.Z.debug("replacing spells for item", item);
    const magicItemsSpells = foundry.utils.getProperty(item, "flags.magicitems.spells");
    if (magicItemsSpells) {
      logger/* default.debug */.Z.debug("item.flags.magicitems.spells", magicItemsSpells);
      for (let [i, spell] of Object.entries(magicItemsSpells)) {
        const itemSpell = itemSpells.find((iSpell) => iSpell.name === spell.name
          && (iSpell.compendium || iSpell.magicItem.subFolder === item.name)
        );
        if (itemSpell) {
          for (const [key, value] of Object.entries(itemSpell.magicItem)) {
            item.flags.magicitems.spells[i][key] = value;
          }
        } else if (!game.user.can("ITEM_CREATE")) {
          ui.notifications.warn(`Magic Item ${item.name} cannot be enriched because of lacking player permissions`);
        } else {
          ui.notifications.warn(`Magic Item ${item.name}: cannot add spell ${spell.name}`);
        }
      }
    }
    // {
    //   magicItem: {
    //     _id: result._id,
    //     id: result._id,
    //     pack: result.flags.ddbimporter.pack,
    //     img: result.img,
    //     name: result.name,
    //     flatDc: result.flags.ddbimporter.dndbeyond?.overrideDC,
    //     dc: result.flags.ddbimporter.dndbeyond?.dc,
    //   },
    //   _id: result._id,
    //   name: result.name,
    //   compendium: true,
    // };
    const itemsWithSpells = foundry.utils.getProperty(item, "flags.items-with-spells-5e.item-spells");
    if (itemsWithSpells) {
      logger/* default.debug */.Z.debug("item.flags.items-with-spells-5e.item-spells", item.flags["items-with-spells-5e"]["item-spells"]);
      itemsWithSpells.forEach((spellData, i) => {
        const itemSpell = itemSpells.find((iSpell) => iSpell.name === spellData.flags.ddbimporter.spellName
          && (iSpell.compendium || iSpell.magicItem.subFolder === item.name)
        );
        if (itemSpell) {
          item.flags["items-with-spells-5e"]["item-spells"][i].uuid = `Compendium.${itemSpell.magicItem.pack}.${itemSpell._id}`;
          if (item._id) {
            foundry.utils.setProperty(item.flags["items-with-spells-5e"]["item-spells"][i], "flags.items-with-spells-5e.item-spells.parent-item", item._id);
          }
        } else if (!game.user.can("ITEM_CREATE")) {
          ui.notifications.warn(`Magic Item ${item.name} cannot be enriched because of lacking player permissions`);
        } else {
          ui.notifications.warn(`Magic Item ${item.name}: cannot add spell ${spellData.name}`);
        }
      });
    }
  });
}

// EXTERNAL MODULE: ./src/effects/external/ExternalAutomations.js
var ExternalAutomations = __webpack_require__(767);
;// CONCATENATED MODULE: ./src/apps/DDBCharacterManager.js
























class DDBCharacterManager extends FormApplication {
  constructor(options, actor, ddbCharacter = null) {
    super(options);
    this.actor = game.actors.get(actor._id);
    this.migrateMetadata();
    this.actorOriginal = foundry.utils.duplicate(this.actor);
    logger/* default.debug */.Z.debug("Current Actor (Original):", this.actorOriginal);
    this.result = {};
    this.nonMatchedItemIds = [];
    this.settings = {};
    this.ddbCharacter = ddbCharacter;
  }

  migrateMetadata() {
    if (this.actor.flags?.ddbimporter?.dndbeyond) {
      const url = this.actor.flags.ddbimporter.dndbeyond.url;

      if (url && !this.actor.flags.ddbimporter.characterId) {
        const characterId = DDBCharacter/* default.getCharacterId */.Z.getCharacterId(url);
        if (characterId) {
          this.actor.flags.ddbimporter.dndbeyond.characterId = characterId;
          this.actor.flags.ddbimporter.dndbeyond.url = url;
        } else {
          // clear the url, because it's malformed anyway
          this.actor.flags.ddbimporter.dndbeyond.url = null;
        }
      }
    }
  }

  static renderPopup(type, url) {
    if (src_settings/* default.POPUPS */.Z.POPUPS[type] && !src_settings/* default.POPUPS */.Z.POPUPS[type].close) {
      src_settings/* default.POPUPS */.Z.POPUPS[type].focus();
      src_settings/* default.POPUPS */.Z.POPUPS[type].location.href = url;
    } else {
      const ratio = window.innerWidth / window.innerHeight;
      const width = Math.round(window.innerWidth * 0.5);
      const height = Math.round(window.innerWidth * 0.5 * ratio);
      src_settings/* default.POPUPS */.Z.POPUPS[type] = window.open(
        url,
        "ddb_sheet_popup",
        `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
      );
    }
    return true;
  }

  /**
   * Define default options
   */
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = game.i18n.localize("ddb-importer.module-name");
    options.template = "modules/ddb-importer/handlebars/character.hbs";
    options.width = 900;
    options.height = "auto";
    options.classes = ["ddbimporter", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "form", initial: "import" }];

    return options;
  }

  showCurrentTask(title, message = null, isError = false) {
    let element = $(this.html).find(".task-name");
    element.html(`<h2 ${isError ? " style='color:red'" : ""}>${title}</h2>${message ? `<p>${message}</p>` : ""}`);
    $(this.html).parent().parent().css("height", "auto");
  }

  static getCharacterUpdatePolicyTypes(invert = false) {
    let itemTypes = ["background", "race"];

    if (invert) {
      if (!game.settings.get("ddb-importer", "character-update-policy-class")) {
        itemTypes.push("class");
        itemTypes.push("subclass");
      }
      if (!game.settings.get("ddb-importer", "character-update-policy-feat")) itemTypes.push("feat");
      if (!game.settings.get("ddb-importer", "character-update-policy-weapon")) itemTypes.push("weapon");
      if (!game.settings.get("ddb-importer", "character-update-policy-equipment"))
        itemTypes = itemTypes.concat(dictionary/* default.types.equipment */.Z.types.equipment);
      if (!game.settings.get("ddb-importer", "character-update-policy-spell")) itemTypes.push("spell");
    } else {
      if (game.settings.get("ddb-importer", "character-update-policy-class")) {
        itemTypes.push("class");
        itemTypes.push("subclass");
      }
      if (game.settings.get("ddb-importer", "character-update-policy-feat")) itemTypes.push("feat");
      if (game.settings.get("ddb-importer", "character-update-policy-weapon")) itemTypes.push("weapon");
      if (game.settings.get("ddb-importer", "character-update-policy-equipment"))
        itemTypes = itemTypes.concat(dictionary/* default.types.equipment */.Z.types.equipment);
      if (game.settings.get("ddb-importer", "character-update-policy-spell")) itemTypes.push("spell");
    }
    return itemTypes;
  }

  /**
   * Returns a combined array of all items to process, filtered by the user's selection on what to skip and what to include
   * @param {object} result object containing all character items sectioned as individual properties
   * @param {array[string]} sections an array of object properties which should be filtered
   */
  filterItemsByUserSelection(invert = false) {
    let items = [];
    const validItemTypes = DDBCharacterManager.getCharacterUpdatePolicyTypes(invert);

    for (const section of src_settings/* default.FILTER_SECTIONS */.Z.FILTER_SECTIONS) {
      items = items.concat(this.result[section]).filter((item) => validItemTypes.includes(item.type));
    }
    return items;
  }

  filterActorItemsByUserSelection(invert = false) {
    const validItemTypes = DDBCharacterManager.getCharacterUpdatePolicyTypes(invert);

    const items = this.actorOriginal.items.filter((item) => validItemTypes.includes(item.type));

    return items;
  }

  /**
   * Loops through a characters items and updates flags
   * @param {*} items
   */
  async copySupportedCharacterItemFlags(items) {
    items.forEach((item) => {
      const originalItem = this.actorOriginal.items.find(
        (originalItem) => item.name === originalItem.name && item.type === originalItem.type
      );
      if (originalItem) {
        DDBItemImporter/* default.copySupportedItemFlags */.Z.copySupportedItemFlags(originalItem, item);
      }
    });
  }

  copyExistingJournalNotes() {
    if (!this.actorOriginal) return;
    const journalFields = [
      "notes1name",
      "notes2name",
      "notes3name",
      "notes4name",
      "notes1",
      "notes2",
      "notes3",
      "notes4",
      "notes",
    ];
    journalFields.forEach((field) => {
      if (this.actorOriginal.system.details[field]) {
        this.actor.system.details[field] = this.actorOriginal.system.details[field];
      }
    });
  }

  async copyCharacterItemEffects(items) {
    return new Promise((resolve) => {
      resolve(
        items.map((item) => {
          const originalItem = this.actorOriginal.items.find((originalItem) =>
            item.name === originalItem.name
            && item.type === originalItem.type
            && item.flags?.ddbimporter?.id === originalItem.flags?.ddbimporter?.id
          );
          if (originalItem) {
            if (!item.effects) item.effects = [];
            if (originalItem.effects) {
              logger/* default.info */.Z.info(`Copying Effects for ${originalItem.name}`);
              item.effects = originalItem.effects.map((m) => {
                delete m._id;
                return m;
              });
            }
          }
          return item;
        })
      );
    });
  }

  /**
   * Removes items
   * @param {*} items
   * @param {*} itemsToRemove
   */
  static async removeItems(items, itemsToRemove) {
    return new Promise((resolve) => {
      resolve(
        items.filter(
          (item) =>
            !itemsToRemove.some((originalItem) => {
              const originalNameMatch = originalItem.flags?.ddbimporter?.originalItemName
                ? originalItem.flags.ddbimporter.originalItemName === item.name
                : false;
              const nameMatch = item.name === originalItem.name || originalNameMatch;
              return nameMatch && item.type === originalItem.type;
            })
        )
      );
    });
  }

  /**
   * Deletes items from the inventory bases on which sections a user wants to update
   * Possible sections:
   * - class
   * - feat
   * - weapon
   * - equipment
   * - inventory: consumable, loot, tool and container
   * - spell
   */
  async clearItemsByUserSelection(excludedList = []) {
    const includedItems = DDBCharacterManager.getCharacterUpdatePolicyTypes();
    // collect all items belonging to one of those inventory item categories
    const ownedItems = this.actor.getEmbeddedCollection("Item");
    const toRemove = ownedItems
      .filter(
        (item) =>
          includedItems.includes(item.type)
          && !excludedList.some((excluded) => excluded._id === item.id)
          && !this.nonMatchedItemIds.includes(item.id)
      )
      .filter((item) => !item.flags.ddbimporter?.ignoreItemImport)
      .map((item) => item.id);

    logger/* default.debug */.Z.debug("Removing the following character items", toRemove);
    if (toRemove.length > 0) {
      await this.actor.deleteEmbeddedDocuments("Item", toRemove, {
        itemsWithSpells5e: { alsoDeleteChildSpells: false }
      });
    }
    return toRemove;
  }

  async updateImage() {
    const data = this.ddbCharacter.source.ddb;
    logger/* default.debug */.Z.debug("Checking if image needs updating");
    // updating the image?
    let imagePath = this.actor.img;
    const decorations = data.character.decorations;
    const userHasPermission = !(game.settings.get("ddb-importer", "restrict-to-trusted") && !game.user.isTrusted);
    if (
      userHasPermission
      && decorations?.avatarUrl
      && decorations.avatarUrl !== ""
      && (!imagePath || imagePath.includes("mystery-man") || this.settings.updatePolicyImage)
    ) {
      this.showCurrentTask("Uploading avatar image");
      const filename = utils/* default.referenceNameString */.Z.referenceNameString(`${data.character.id}-${data.character.name}`);

      const uploadDirectory = game.settings.get("ddb-importer", "image-upload-directory").replace(/^\/|\/$/g, "");
      imagePath = await FileHelper/* default.uploadRemoteImage */.Z.uploadRemoteImage(decorations.avatarUrl, uploadDirectory, filename);
      this.result.character.img = imagePath;
      if (decorations?.frameAvatarUrl && decorations.frameAvatarUrl !== "") {
        const framePath = await FileHelper/* default.uploadRemoteImage */.Z.uploadRemoteImage(decorations.frameAvatarUrl, uploadDirectory, `frame-${filename}`);
        this.result.character.flags.ddbimporter["framePath"] = framePath;
      }
    } else {
      this.result.character.img = this.actor.img;
    }

    if (this.actorOriginal.prototypeToken.texture.src.includes("mystery-man")) {
      foundry.utils.setProperty(this.result.character, "prototypeToken.texture.src", this.result.character.img);
    } else if (foundry.utils.hasProperty(this.actorOriginal, "prototypeToken.texture.src")) {
      foundry.utils.setProperty(this.result.character, "prototypeToken.texture.src", this.actorOriginal.prototypeToken.texture.src);
    }
  }


  static async itemsMunched() {
    const itemCompendium = await CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("item", false);
    const itemsMunched = itemCompendium ? (await itemCompendium.index.size) !== 0 : false;
    return itemsMunched;
  }

  /* -------------------------------------------- */

  async getData() {
    // loads settings for actor
    this.importSettings = MuncherSettings/* default.getCharacterImportSettings */.Z.getCharacterImportSettings();
    const useLocalPatreonKey = this.actor.flags?.ddbimporter?.useLocalPatreonKey;

    const characterId = this.actor.flags?.ddbimporter?.dndbeyond?.characterId;
    this.dmSyncEnabled = characterId && this.importSettings.tiers.all;
    this.activateListenersplayerSyncEnabled = characterId && useLocalPatreonKey;
    const syncEnabled = characterId && (this.importSettings.tiers.all || useLocalPatreonKey);

    const trustedUsersOnly = game.settings.get("ddb-importer", "restrict-to-trusted");
    const allowAllSync = game.settings.get("ddb-importer", "allow-all-sync");
    const syncOnly = trustedUsersOnly && allowAllSync && !game.user.isTrusted;

    const localCobalt = (0,Secrets/* isLocalCobalt */.Mi)(this.actor.id);
    const cobaltCookie = (0,Secrets/* getCobalt */.HF)(this.actor.id);
    const cobaltSet = localCobalt && cobaltCookie && cobaltCookie != "";

    const dynamicSync = game.settings.get("ddb-importer", "dynamic-sync");
    const updateUser = game.settings.get("ddb-importer", "dynamic-sync-user");
    const gmSyncUser = game.user.isGM && game.user.id == updateUser;
    const dynamicUpdateAllowed = dynamicSync && gmSyncUser && this.importSettings.tiers.experimentalMid;
    const dynamicUpdateStatus = this.actor.flags?.ddbimporter?.activeUpdate;
    const resourceSelection = !foundry.utils.hasProperty(this.actor, "flags.ddbimporter.resources.ask")
      || foundry.utils.getProperty(this.actor, "flags.ddbimporter.resources.ask") === true;

    const itemCompendium = await CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("item", false);
    this.itemsMunched = itemCompendium ? (await itemCompendium.index.size) !== 0 : false;

    this.actorSettings = {
      actor: this.actor,
      localCobalt: localCobalt,
      cobaltSet: cobaltSet,
      syncEnabled: syncEnabled && this.itemsMunched,
      importAllowed: !syncOnly,
      itemsMunched: this.itemsMunched,
      dynamicUpdateAllowed,
      dynamicUpdateStatus,
      resourceSelection,
      useLocalPatreonKey: useLocalPatreonKey && this.itemsMunched,
    };

    return foundry.utils.mergeObject(this.importSettings, this.actorSettings);
  }

  /* -------------------------------------------- */

  activateListeners(html) {
    super.activateListeners(html);
    // watch the change of the import-policy-selector checkboxes
    $(html)
      .find(
        [
          '.import-policy input[type="checkbox"]',
          '.advanced-import-config input[type="checkbox"]',
          '.effect-policy input[type="checkbox"]',
          '.effect-import-config input[type="checkbox"]',
          '.extras-import-config input[type="checkbox"]',
          '.import-config input[type="checkbox"]',
        ].join(",")
      )
      .on("change", (event) => {
        this.html = html;
        MuncherSettings/* default.updateActorSettings */.Z.updateActorSettings(html, event);
      });

    $(html)
      .find("#default-effects")
      .on("click", async (event) => {
        event.preventDefault();
        MuncherSettings/* default.setRecommendedCharacterActiveEffectSettings */.Z.setRecommendedCharacterActiveEffectSettings(html);
      });

    $(html)
      .find(['.resource-selection input[type="checkbox"]'].join(","))
      .on("change", async (event) => {
        const updateData = { flags: { ddbimporter: { resources: { ask: event.currentTarget.checked } } } };
        await this.actor.update(updateData);
      });

    $(html)
      .find('.sync-policy input[type="checkbox"]')
      .on("change", (event) => {
        game.settings.set(
          "ddb-importer",
          "sync-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    $(html)
      .find("#dndbeyond-character-dynamic-update")
      .on("change", async (event) => {
        const activeUpdateData = { flags: { ddbimporter: { activeUpdate: event.currentTarget.checked } } };
        await this.actor.update(activeUpdateData);
      });

    $(html)
      .find("#dndbeyond-character-import-start")
      .on("click", async (event) => {
        // retrieve the character data from the proxy
        event.preventDefault();
        this.html = html;

        try {
          $(html).find("#dndbeyond-character-import-start").prop("disabled", true);
          this.showCurrentTask("Getting Character data");
          const characterId = this.actor.flags.ddbimporter.dndbeyond.characterId;
          const ddbCharacterOptions = {
            currentActor: this.actor,
            characterId,
            selectResources: true,
            enableCompanions: true,
          };
          const getOptions = {
            syncId: null,
            localCobaltPostFix: this.actor.id,
          };
          this.ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
          await this.ddbCharacter.getCharacterData(getOptions);
          logger/* default.debug */.Z.debug("import.js getCharacterData result", this.ddbCharacter);
          if (game.settings.get("ddb-importer", "debug-json")) {
            FileHelper/* default.download */.Z.download(JSON.stringify(this.ddbCharacter.source), `${characterId}.json`, "application/json");
          }
          if (this.ddbCharacter.source?.success) {
            // begin parsing the character data
            await this.processCharacterData();
            this.showCurrentTask("Loading Character data", "Done.", false);
            logger/* default.debug */.Z.debug("Character Load complete", { ddbCharacter: this.ddbCharacter, result: this.result, actor: this.actor, actorOriginal: this.actorOriginal });
            this.close();
          } else {
            this.showCurrentTask(this.ddbCharacter.source.message, null, true);
            return false;
          }
        } catch (error) {
          switch (error.message) {
            case "ImportFailure":
              logger/* default.error */.Z.error("Failure", { ddbCharacter: this.ddbCharacter, result: this.result });
              break;
            case "Forbidden":
              this.showCurrentTask("Error retrieving Character: " + error, error, true);
              break;
            default:
              logger/* default.error */.Z.error(error);
              logger/* default.error */.Z.error(error.stack);
              this.showCurrentTask("Error processing Character: " + error, error, true);
              logger/* default.error */.Z.error("Failure", { ddbCharacter: this.ddbCharacter, result: this.result });
              break;
          }
          return false;
        }

        $(html).find("#dndbeyond-character-import-start").prop("disabled", false);
        return true;
      });

    $(html)
      .find("#dndbeyond-character-update")
      .on("click", async () => {
        this.html = html;
        try {
          $(html).find("#dndbeyond-character-update").prop("disabled", true);
          await updateDDBCharacter(this.actor).then((result) => {
            const updateNotes = result
              .flat()
              .filter((r) => r !== undefined)
              .map((r) => r.message)
              .join(" ");
            logger/* default.debug */.Z.debug(updateNotes);
            this.showCurrentTask("Update complete", updateNotes);
            $(html).find("#dndbeyond-character-update").prop("disabled", false);
          });
        } catch (error) {
          logger/* default.error */.Z.error(error);
          logger/* default.error */.Z.error(error.stack);
          this.showCurrentTask("Error updating character", error, true);
        }
      });

    $(html)
      .find("#delete-local-cobalt")
      .on("click", async () => {
        this.html = html;
        try {
          (0,Secrets/* deleteLocalCobalt */.Tl)(this.actor.id);
          $(html).find("#delete-local-cobalt").prop("disabled", true);
          $(html).find("#set-local-cobalt").text("Add Cobalt Cookie");
        } catch (error) {
          logger/* default.error */.Z.error(error);
          logger/* default.error */.Z.error(error.stack);
          this.showCurrentTask("Error deleting local cookie", error, true);
        }
      });

    $(html)
      .find("#set-local-cobalt")
      .on("click", async () => {
        this.html = html;
        try {
          new DDBCookie({}, this.actor, true).render(true);
          $(html).find("#delete-local-cobalt").prop("disabled", false);
          $(html).find("#set-local-cobalt").text("Update Cobalt Cookie");
        } catch (error) {
          logger/* default.error */.Z.error(error);
          logger/* default.error */.Z.error(error.stack);
          this.showCurrentTask("Error setting local cookie", error, true);
        }
      });

    $(html)
      .find("#delete-local-patreon-key")
      .on("click", async () => {
        this.html = html;
        try {
          await PatreonHelper/* default.setPatreonKey */.Z.setPatreonKey(null, true);
          await this.actor.update({ flags: { ddbimporter: { useLocalPatreonKey: false } } });
          $(html).find("#delete-local-patreon-key").prop("disabled", true);
          $(html).find("#set-local-patreon-key").text("Add Patreon Key");
          if (!this.dmSyncEnabled) {
            $(html).find("#dndbeyond-character-update").prop("disabled", true);
            $(html).find("#dndbeyond-character-update").text("D&D Beyond Update Available to Patreon Supporters");
          }
        } catch (error) {
          logger/* default.error */.Z.error(error);
          logger/* default.error */.Z.error(error.stack);
          this.showCurrentTask("Error deleting local cookie", error, true);
        }
      });

    $(html)
      .find("#set-local-patreon-key")
      .on("click", async () => {
        this.html = html;
        const updateActorState = async () => {
          await this.actor.update({ flags: { ddbimporter: { useLocalPatreonKey: true } } });
          $(html).find("#delete-local-patreon-key").prop("disabled", false);
          $(html).find("#set-local-patreon-key").text("Update Patreon Key");
          if (this.itemsMunched) {
            $(html).find("#dndbeyond-character-update").prop("disabled", false);
            $(html).find("#dndbeyond-character-update").text("Update D&D Beyond with changes");
          } else {
            $(html).find("#dndbeyond-character-update").text("Your DM needs to import D&D Beyond items and spells into the DDB compendiums first.");
          }
        };
        try {
          const existingKey = await PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey(true);
          if (!this.actor.flags.ddbimporter?.useLocalPatreonKey && existingKey && existingKey !== "") {
            await updateActorState();
          } else {
            new DDBKeyChange({
              local: true,
              success: updateActorState,
            }).render(true);
          }
        } catch (error) {
          logger/* default.error */.Z.error(error);
          logger/* default.error */.Z.error(error.stack);
          this.showCurrentTask("Error setting local patreon key", error, true);
        }
      });

    $(html)
      .find("#dndbeyond-character-extras-start")
      .on("click", async () => {
        this.html = html;
        try {
          $(html).find("#dndbeyond-character-extras-start").prop("disabled", true);
          this.showCurrentTask("Fetching character data");
          const characterId = this.actor.flags.ddbimporter.dndbeyond.characterId;
          const ddbCharacterOptions = {
            currentActor: this.actor,
            ddb: null,
            characterId,
            selectResources: false
          };
          const getOptions = {
            syncId: null,
            localCobaltPostFix: this.actor.id,
          };
          this.ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
          await this.ddbCharacter.getCharacterData(getOptions);
          logger/* default.debug */.Z.debug("import.js getCharacterData result", this.ddbCharacter);
          const debugJson = game.settings.get("ddb-importer", "debug-json");
          if (debugJson) {
            FileHelper/* default.download */.Z.download(JSON.stringify(this.ddbCharacter.source), `${characterId}.json`, "application/json");
          }
          if (this.ddbCharacter.source?.success) {
            await (0,DDBExtras/* generateCharacterExtras */._)(html, this.ddbCharacter, this.actor);
            this.showCurrentTask("Loading Extras", "Done.", false);
            $(html).find("#dndbeyond-character-extras-start").prop("disabled", true);
            this.close();
          } else {
            this.showCurrentTask(this.ddbCharacter.source.message, null, true);
            return false;
          }
        } catch (error) {
          switch (error.message) {
            case "ImportFailure":
              logger/* default.error */.Z.error("Failure");
              break;
            case "Forbidden":
              this.showCurrentTask("Error retrieving Character: " + error, error, true);
              break;
            default:
              logger/* default.error */.Z.error(error);
              logger/* default.error */.Z.error(error.stack);
              this.showCurrentTask("Error processing Character: " + error, error, true);
              break;
          }
          return false;
        }
        return true;
      });

    $(html)
      .find("input[name=dndbeyond-url]")
      .on("input", async (event) => {
        this.html = html;
        let URL = event.target.value;
        const characterId = DDBCharacter/* default.getCharacterId */.Z.getCharacterId(URL);

        if (characterId) {
          $(html)
            .find(".dndbeyond-url-status i")
            .replaceWith('<i class="fas fa-check-circle" style="color: green"></i>');
          $(html).find("span.dndbeyond-character-id").text(characterId);
          $(html).find("#dndbeyond-character-import-start").prop("disabled", false);
          $(html).find("#open-dndbeyond-url").prop("disabled", false);

          this.showCurrentTask("Saving reference");
          await this.actor.update({
            "flags.ddbimporter.dndbeyond": {
              url: URL,
              characterId,
            },
          });
          this.showCurrentTask("Status");
        } else {
          this.showCurrentTask("URL format incorrect", "That seems not to be the URL we expected...", true);
          $(html)
            .find(".dndbeyond-url-status i")
            .replaceWith('<i class="fas fa-exclamation-triangle" style="color:red"></i>');
        }
      });

    $(html)
      .find("#open-dndbeyond-url")
      .on("click", () => {
        this.html = html;
        try {
          const characterUrl = this.actor.flags.ddbimporter.dndbeyond.url;
          DDBCharacterManager.renderPopup("json", characterUrl);
        } catch (error) {
          this.showCurrentTask("Error opening JSON URL", error, true);
        }
      });
  }

  async enrichCharacterItems(items) {
    const useInbuiltIcons = game.settings.get("ddb-importer", "character-update-policy-use-inbuilt-icons");
    const useSRDCompendiumItems = game.settings.get("ddb-importer", "character-update-policy-use-srd");
    const useSRDCompendiumIcons = game.settings.get("ddb-importer", "character-update-policy-use-srd-icons");
    const ddbSpellIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-spell-icons");
    const ddbItemIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-item-icons");
    const ddbGenericItemIcons = game.settings.get("ddb-importer", "character-update-policy-use-ddb-generic-item-icons");

    await Iconizer/* default.preFetchDDBIconImages */.Z.preFetchDDBIconImages();

    // if we still have items to add, add them
    if (items.length > 0) {
      this.showCurrentTask("Copying existing data flags");
      await this.copySupportedCharacterItemFlags(items);

      if (ddbItemIcons) {
        this.showCurrentTask("Fetching DDB Inventory Images");
        items = await Iconizer/* default.getDDBEquipmentIcons */.Z.getDDBEquipmentIcons(items, true);
      }

      if (useInbuiltIcons) {
        this.showCurrentTask("Adding Inbuilt Icons");
        items = await Iconizer/* default.getDDBHintImages */.Z.getDDBHintImages("class", items);
        items = await Iconizer/* default.getDDBHintImages */.Z.getDDBHintImages("subclass", items);
        items = await Iconizer/* default.copyInbuiltIcons */.Z.copyInbuiltIcons(items);
      }

      if (useSRDCompendiumIcons && !useSRDCompendiumItems) {
        this.showCurrentTask("Adding SRD Icons");
        items = await Iconizer/* default.copySRDIcons */.Z.copySRDIcons(items);
      }

      if (ddbSpellIcons) {
        this.showCurrentTask("Fetching DDB Spell School Images");
        items = await Iconizer/* default.getDDBSpellSchoolIcons */.Z.getDDBSpellSchoolIcons(items, true);
      }

      if (ddbGenericItemIcons) {
        this.showCurrentTask("Fetching DDB Generic Item Images");
        items = await Iconizer/* default.getDDBGenericItemIcons */.Z.getDDBGenericItemIcons(items, true);
      }

      if (this.settings.activeEffectCopy) {
        this.showCurrentTask("Copying Item Active Effects");
        items = await this.copyCharacterItemEffects(items);
      }

      items = await Iconizer/* default.addItemEffectIcons */.Z.addItemEffectIcons(items);
      items = await Iconizer/* default.retainExistingIcons */.Z.retainExistingIcons(items);
    }

    items = items.map((item) => {
      if (!item.effects) item.effects = [];
      if (foundry.utils.hasProperty(item, "system.description.value")) {
        item.system.description.value = `<div class="ddb">
${item.system.description.value}
</div>`;
        item.system.description.chat = item.system.description.chat.trim() !== ""
          ? `<div class="ddb">
${item.system.description.chat}
</div>`
          : "";
      }
      return item;
    });

    return Promise.all(items);
  }

  async createCharacterItems(items, keepIds) {
    const options = foundry.utils.duplicate(src_settings/* default.DISABLE_FOUNDRY_UPGRADE */.Z.DISABLE_FOUNDRY_UPGRADE);
    if (keepIds) options["keepId"] = true;

    // we have to break these out into class and non-class because of
    // https://gitlab.com/foundrynet/foundryvtt/-/issues/5312
    const klassItems = items.filter((item) => ["class", "subclass"].includes(item.type));
    const nonKlassItems = items.filter((item) => !["class", "subclass"].includes(item.type));

    if (klassItems.length > 0) {
      logger/* default.debug */.Z.debug(`Adding the following class items, keep Ids? ${keepIds}`, { options, items: foundry.utils.duplicate(klassItems) });
      await this.actor.createEmbeddedDocuments("Item", klassItems, options);
    }
    if (nonKlassItems.length > 0) {
      logger/* default.debug */.Z.debug(`Adding the following non-class items, keep Ids? ${keepIds}`, { options, items: foundry.utils.duplicate(nonKlassItems) });
      await this.actor.createEmbeddedDocuments("Item", nonKlassItems, options);
    }
  }

  async importCharacterItems(items, keepIds = false) {
    if (items.length > 0) {
      this.showCurrentTask("Adding items to character");

      const newItems = items.filter((i) => !i._id || i._id === null || i._id === undefined);
      const updateItems = items.filter((i) => i._id && i._id !== null && i._id !== undefined);

      await this.createCharacterItems(newItems, false);
      await this.createCharacterItems(updateItems, keepIds);
    }
  }

  async keepNonDDBItems(ddbItems) {
    const lastImportId = foundry.utils.getProperty(this.actorOriginal, "flags.ddbimporter.importId");
    if (this.settings.ignoreNonDDBItems) {
      const items = this.actor.getEmbeddedCollection("Item");
      await items.forEach((item) => {
        const ddbMatchedItem = ddbItems.some((ddbItem) =>
          item.name === ddbItem.name
          && item.type === ddbItem.type
          && item.flags?.ddbimporter?.id === ddbItem.flags?.ddbimporter?.id
        );
        if (!ddbMatchedItem) {
          // if item not replaced by compendium swap or
          if (item.flags?.ddbimporter?.importId !== lastImportId) {
            this.nonMatchedItemIds.push(item.id);
          }
        }
      });
    }
  }

  static async getIndividualOverrideItems(overrideItems) {
    const label = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("custom");
    const compendium = CompendiumHelper/* default.getCompendium */.Z.getCompendium(label);

    const compendiumItems = await Promise.all(overrideItems
      .filter((item) => foundry.utils.hasProperty(item, "flags.ddbimporter.overrideId") && compendium.index.has(item.flags.ddbimporter.overrideId))
      .map(async (item) => {
        const compendiumItem = foundry.utils.duplicate(await compendium.getDocument(item.flags.ddbimporter.overrideId));
        foundry.utils.setProperty(compendiumItem, "flags.ddbimporter.pack", `${compendium.metadata.id}`);
        if (foundry.utils.hasProperty(item, "flags.ddbimporter.overrideItem")) {
          foundry.utils.setProperty(compendiumItem, "flags.ddbimporter.overrideItem", item.flags.ddbimporter.overrideItem);
        } else {
          foundry.utils.setProperty(compendiumItem, "flags.ddbimporter.overrideItem", {
            name: item.name,
            type: item.type,
            ddbId: item.flags.ddbimporter?.id
          });
        }

        return compendiumItem;
      }));

    const matchingOptions = {
      looseMatch: false,
      monster: false,
      keepId: true,
      keepDDBId: true,
      overrideId: true,
      linkItemFlags: true,
    };
    const remappedItems = await DDBItemImporter/* default.updateMatchingItems */.Z.updateMatchingItems(overrideItems, compendiumItems, matchingOptions);

    return remappedItems;
  }

  static restoreDDBMatchedFlags(existingItem, item) {
    const ddbItemFlags = foundry.utils.getProperty(existingItem, "flags.ddbimporter");
    logger/* default.debug */.Z.debug(`Item flags for ${ddbItemFlags}`, ddbItemFlags);
    // we retain some flags that might change the nature of the import for this item
    // these flags are used elsewhere
    [
      "ignoreItemForChrisPremades",
      "ignoreItemImport",
      "ignoreItemUpdate",
      "overrideId",
      "overrideItem",
      "ddbCustomAdded",
    ].forEach((flag) => {
      if (foundry.utils.hasProperty(ddbItemFlags, flag)) {
        logger/* default.debug */.Z.debug(`Overriding ${flag} for ${item.name} to ${ddbItemFlags[flag]}`);
        foundry.utils.setProperty(item, `flags.ddbimporter.${flag}`, ddbItemFlags[flag]);
      }
    });
    // some items get ignored completly, if so we don't match these
    if (!foundry.utils.getProperty(ddbItemFlags, "ignoreItemImport") ?? false) {
      logger/* default.debug */.Z.debug(`Updating ${item.name} with id`);
      item["_id"] = existingItem["id"];
      if (foundry.utils.getProperty(ddbItemFlags, "ignoreIcon") ?? false) {
        logger/* default.debug */.Z.debug(`Retaining icons for ${item.name}`);
        item.flags.ddbimporter.matchedImg = existingItem.img;
        item.flags.ddbimporter.ignoreIcon = true;
      }
      if (foundry.utils.getProperty(ddbItemFlags, "retainResourceConsumption") ?? false) {
        logger/* default.debug */.Z.debug(`Retaining resources for ${item.name}`);
        item.system.consume = foundry.utils.deepClone(existingItem.system.consume);
        item.flags.ddbimporter.retainResourceConsumption = true;
        if (foundry.utils.hasProperty(existingItem, "flags.link-item-resource-5e") ?? false) {
          foundry.utils.setProperty(item, "flags.link-item-resource-5e", existingItem.flags["link-item-resource-5e"]);
        }
      }
    }
    if (foundry.utils.getProperty(ddbItemFlags, "ddbCustomAdded") ?? false) {
      item.system = existingItem.system;
      item.type = existingItem.type;
    }
    return item;
  }

  // checks for existing items, and depending on options will keep or replace with imported item
  async mergeExistingItems(items) {
    if (this.actorOriginal.flags.ddbimporter) {
      const ownedItems = this.actor.getEmbeddedCollection("Item");

      let nonMatchedItems = [];
      let matchedItems = [];

      for (let item of items) {
        let existingItem = DDBHelper/* default.findMatchedDDBItem */.Z.findMatchedDDBItem(item, ownedItems, matchedItems);
        // let existingItem = ownedItems.find((owned) => {
        //   // have we already matched against this id? lets not double dip
        //   const existingMatch = matchedItems.find((matched) => {
        //     return foundry.utils.getProperty(owned, "flags.ddbimporter.id") === foundry.utils.getProperty(matched, "flags.ddbimporter.id");
        //   });
        //   if (existingMatch) return false;
        //   // the simple match
        //   const simpleMatch
        //     = item.name === owned.name
        //     && item.type === owned.type
        //     && item.flags?.ddbimporter?.id === owned.flags?.ddbimporter?.id;
        //   // account for choices in ddb
        //   const isChoice
        //     = foundry.utils.hasProperty(item, "flags.ddbimporter.dndbeyond.choice.choiceId")
        //     && foundry.utils.hasProperty(owned, "flags.ddbimporter.dndbeyond.choice.choiceId");
        //   const choiceMatch = isChoice
        //     ? item.flags.ddbimporter.dndbeyond.choice.choiceId
        //       === owned.flags.ddbimporter.dndbeyond.choice.choiceId
        //     : true;
        //   // force an override
        //   const overrideDetails = foundry.utils.getProperty(owned, "flags.ddbimporter.overrideItem");
        //   const overrideMatch
        //     = overrideDetails
        //     && item.name === overrideDetails.name
        //     && item.type === overrideDetails.type
        //     && item.flags?.ddbimporter?.id === overrideDetails.ddbId;

        //   return (simpleMatch && choiceMatch) || overrideMatch;
        // });

        logger/* default.debug */.Z.debug(`Checking ${item.name} for existing match`, existingItem);

        if (existingItem) {
          // we use flags on the item to determine if we keep various properties
          // NOW IS THE TIME!
          item = DDBCharacterManager.restoreDDBMatchedFlags(existingItem, item);
          // we can now determine if we are going to ignore this item or not,
          // this effectively filters out the items we don't want and they don't
          // get returned from this function
          const ignoreItemImport = foundry.utils.getProperty(item, "flags.ddbimporter.ignoreItemImport") ?? false;
          if (!ignoreItemImport) {
            logger/* default.debug */.Z.debug(`Importing matched item ${item.name}`);
            matchedItems.push(item);
          }
        } else {
          nonMatchedItems.push(item);
        }
      }

      logger/* default.debug */.Z.debug("Finished retaining items");
      return nonMatchedItems.concat(matchedItems);
    } else {
      return items;
    }
  }

  async fetchCharacterItems() {
    const magicItemsInstalled = game.modules.get("magicitems")?.active || game.modules.get("magic-items-2")?.active;
    const itemsWithSpellsInstalled = game.modules.get("items-with-spells-5e")?.active;
    // items for actor
    let items = [];

    // process spells for magic items
    if ((magicItemsInstalled || itemsWithSpellsInstalled) && Array.isArray(this.result.itemSpells)) {
      this.showCurrentTask("Preparing magicitem spells");
      logger/* default.debug */.Z.debug("Preparing magicitem spells");
      await addMagicItemSpells(this.result);
    }

    logger/* default.debug */.Z.debug("Calculating items to create and update...");
    this.showCurrentTask("Calculating items to create and update...");
    items = this.filterItemsByUserSelection();

    logger/* default.debug */.Z.debug("Checking existing items for details...");
    this.showCurrentTask("Checking existing items for details...");

    items = await this.mergeExistingItems(items);
    await this.keepNonDDBItems(items);

    logger/* default.debug */.Z.debug("Removing found items...");
    this.showCurrentTask("Clearing items for recreation...");
    await this.clearItemsByUserSelection();

    // If there is no magicitems module fall back to importing the magic
    // item spells as normal spells fo the character
    if (!magicItemsInstalled && !itemsWithSpellsInstalled) {
      logger/* default.debug */.Z.debug("No magic items module(s) found, adding spells to sheet.");
      items.push(
        this.result.itemSpells.filter((item) => {
          const active = item.flags.ddbimporter.dndbeyond && item.flags.ddbimporter.dndbeyond.active === true;
          if (!active) logger/* default.warn */.Z.warn(`Missing active flag on item spell ${item.name}`);
          return active;
        })
      );
      items = items.flat();
    }
    logger/* default.debug */.Z.debug("Finished item fetch");
    return items;
  }

  async processCharacterItems(items) {
    let compendiumItems = [];
    let srdCompendiumItems = [];
    let overrideCompendiumItems = [];
    let individualCompendiumItems = [];

    // First we do items that are individually marked as override
    const individualOverrideItems = items.filter((item) => {
      const overrideId = foundry.utils.getProperty(item, "flags.ddbimporter.overrideId");
      return overrideId !== undefined && overrideId !== "NONE";
    });

    if (individualOverrideItems.length > 0) {
      const individualOverrideCompendiumItems = await DDBCharacterManager.getIndividualOverrideItems(individualOverrideItems);
      individualCompendiumItems = individualOverrideCompendiumItems;
      // remove existing items from those to be imported
      logger/* default.info */.Z.info("Removing matching Override compendium items");
      items = await DDBCharacterManager.removeItems(items, individualCompendiumItems);
    }

    /**
     * First choice is override compendium
     */
    if (this.settings.useOverrideCompendiumItems) {
      logger/* default.info */.Z.info("Removing matching Override compendium items");
      const compendiumOverrideItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "custom", { linkItemFlags: true });
      overrideCompendiumItems = compendiumOverrideItems;
      // remove existing items from those to be imported
      items = await DDBCharacterManager.removeItems(items, overrideCompendiumItems);
    }

    /**
     * If SRD is selected, we prefer this
     */
    if (this.settings.useSRDCompendiumItems) {
      logger/* default.info */.Z.info("Removing compendium items");
      const featureManager = new DDBItemImporter/* default */.Z("features", items);
      const inventoryManager = new DDBItemImporter/* default */.Z("inventory", items);
      const spellManager = new DDBItemImporter/* default */.Z("spells", items);

      await featureManager.init();
      await inventoryManager.init();
      await spellManager.init();

      const compendiumFeatureItems = await featureManager.getSRDCompendiumItems();
      const compendiumInventoryItems = await inventoryManager.getSRDCompendiumItems();
      const compendiumSpellItems = await spellManager.getSRDCompendiumItems();

      srdCompendiumItems = compendiumItems.concat(
        compendiumInventoryItems,
        compendiumSpellItems,
        compendiumFeatureItems
      );
      // remove existing items from those to be imported
      items = await DDBCharacterManager.removeItems(items, srdCompendiumItems);
    }

    if (this.settings.useExistingCompendiumItems) {
      logger/* default.info */.Z.info("Removing compendium items");
      const compendiumFeatureItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "features");
      const compendiumInventoryItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "inventory");
      const compendiumSpellItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "spells");
      const compendiumClassItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "classes");
      const compendiumSubClassItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "subclasses");
      const compendiumRaceItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "races");
      const compendiumTraitsItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "traits");
      const compendiumBackgroundsItems = await DDBItemImporter/* default.getCompendiumItems */.Z.getCompendiumItems(items, "backgrounds");

      compendiumItems = compendiumItems.concat(
        compendiumInventoryItems,
        compendiumSpellItems,
        compendiumFeatureItems,
        compendiumClassItems,
        compendiumSubClassItems,
        compendiumRaceItems,
        compendiumTraitsItems,
        compendiumBackgroundsItems,
      );
      // remove existing items from those to be imported
      items = await DDBCharacterManager.removeItems(items, compendiumItems);
    }

    // import remaining items to character
    if (items.length > 0) {
      this.showCurrentTask("Adding DDB generated items");
      logger/* default.debug */.Z.debug(`Adding DDB generated items...`, items);
      items = await this.enrichCharacterItems(items);
      await this.importCharacterItems(items, true);
    }

    // now import any compendium items that we matched
    if (this.settings.useExistingCompendiumItems) {
      this.showCurrentTask("Adding DDB compendium items");
      logger/* default.info */.Z.info("Adding DDB compendium items:", compendiumItems);
      await this.createCharacterItems(compendiumItems, false);
    }

    if (this.settings.useSRDCompendiumItems) {
      this.showCurrentTask("Adding SRD compendium items");
      logger/* default.info */.Z.info("Adding SRD compendium items:", srdCompendiumItems);
      await this.createCharacterItems(srdCompendiumItems, false);
    }

    if (this.settings.useOverrideCompendiumItems) {
      this.showCurrentTask("Adding Override compendium items");
      logger/* default.info */.Z.info("Adding Override compendium items:", overrideCompendiumItems);
      await this.createCharacterItems(overrideCompendiumItems, false);
    }

    if (individualCompendiumItems.length > 0) {
      this.showCurrentTask("Adding Individual Override compendium items");
      logger/* default.info */.Z.info("Adding Individual Override compendium items:", individualCompendiumItems);
      await this.createCharacterItems(individualCompendiumItems, false);
    }

    logger/* default.debug */.Z.debug("Finished importing items");
  }

  async preActiveEffects() {
    this.effectBackup = foundry.utils.duplicate(this.actor.effects);
    for (const e of this.effectBackup) {
      if (e.origin?.includes(".Item.")) {
        const parent = await fromUuid(e.origin);
        logger/* default.debug */.Z.debug("Effect Backup flags", { e, parent });
        if (parent) foundry.utils.setProperty(e, "flags.ddbimporter.type", parent.type);
      }
    }
    await this.actor.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
  }

  async processActiveEffects() {
    logger/* default.debug */.Z.debug("Removing active effects");

    // remove current active effects
    const excludedItems = this.filterActorItemsByUserSelection(true);
    const ignoredItemIds = this.actorOriginal.items
      .filter((item) =>
        item.effects
        && item.effects.length > 0
        && (item.flags.ddbimporter?.ignoreItemImport
          || excludedItems.some((ei) => ei._id === item._id)
          || this.nonMatchedItemIds.includes(item._id)
        )
      )
      .map((item) => item._id);

    const itemEffects = this.effectBackup.filter((ae) =>
      ae.origin?.includes(".Item.")
    );
    const ignoredEffects = this.effectBackup.filter((ae) =>
      ignoredItemIds.includes(ae.origin?.split(".").slice(-1)[0])
    );
    const coreStatusEffects = this.effectBackup.filter((ae) => {
      const isStatus = ae.statuses.length > 0;
      const itemEffect = ae.origin?.includes(".Item.");
      return isStatus && !itemEffect;
    });
    // effects on the character that are not from items, or corestatuses
    // nor added by ddb importer
    const charEffects = this.effectBackup.filter((ae) =>
      !ignoredItemIds.some((id) => ae._id === id)
      && !ae.flags.ddbimporter?.characterEffect
      && !ae.statuses.length > 0
      && !ae.origin?.includes(".Item.")
    );
    // effects that are added by the ddb importer that are not item effects
    const ddbGeneratedCharEffects = this.effectBackup.filter((ae) =>
      !ae.origin?.includes(".Item.") && ae.flags.ddbimporter?.characterEffect
    );

    const spellEffects = [];
    for (const e of itemEffects) {
      const isOther = coreStatusEffects.some((ae) => ae._id === e._id)
        || charEffects.some((ae) => ae._id === e._id)
        || ddbGeneratedCharEffects.some((ae) => ae._id === e._id);
      if (!isOther && foundry.utils.getProperty(e, "flags.ddbimporter.type") === "spell") {
        spellEffects.push(e);
      }
    }

    const remainingEffects = this.effectBackup
      .filter((e) =>
        // remove existing active item effects
        !itemEffects.map((ae) => ae._id).includes(e._id)
        // clear down ddb generated character effects such as skill bonuses
        && !ddbGeneratedCharEffects.map((ae) => ae._id).includes(e._id)
        // ignored effects always remain
        && !ignoredEffects.map((ae) => ae._id).includes(e._id)
        // clear down char effects
        && !charEffects.map((ae) => ae._id).includes(e._id)
        // clear down status effects
        && !coreStatusEffects.map((ae) => ae._id).includes(e._id)
        // ignore spell effects
        && !spellEffects.map((ae) => ae._id).includes(e._id)
      );

    logger/* default.debug */.Z.debug("Effect Removal Results", {
      ignoredItemIds, itemEffects, ignoredEffects, charEffects, coreStatusEffects, spellEffects,
      ddbGeneratedCharEffects, remainingEffects, backupEffects: this.effectBackup,
    });

    // are we trying to retain existing effects?
    if (this.settings.activeEffectCopy) {
      // add retained character effects to result
      const effects = ignoredEffects.concat(charEffects, coreStatusEffects, spellEffects, remainingEffects);
      this.result.character.effects = this.result.character.effects.concat(effects);
    } else {
      this.result.character.effects = this.result.character.effects.concat(ignoredEffects);
    }
  }

  fixUpCharacterEffects() {
    // if (!CONFIG.ActiveEffect.legacyTransferral) return;
    let abilityOverrides = abilityOverrideEffects(this.result.character.flags.ddbimporter.dndbeyond.abilityOverrides);
    if (abilityOverrides.changes.length > 0) {
      this.result.character.effects = this.result.character.effects.concat(abilityOverrides);
    }
    this.result.character.effects = this.result.character.effects.filter((e) => e !== undefined);
    this.result.character.effects.forEach((effect) => {
      const origins = ["Ability.Override", "AC", `Actor.${this.actor.flags.ddbimporter.dndbeyond.characterId}`];
      if (origins.includes(effect.origin)) {
        effect.origin = `Actor.${this.actor.id}`;
      }
    });
  }

  async addImportIdToItems() {
    const importId = this.importId;
    function addImportId(items) {
      return items.map((item) => {
        foundry.utils.setProperty(item, "flags.ddbimporter.importId", importId);
        return item;
      });
    }
    this.result.actions = addImportId(this.result.actions);
    this.result.classes = addImportId(this.result.classes);
    this.result.features = addImportId(this.result.features);
    this.result.inventory = addImportId(this.result.inventory);
    this.result.itemSpells = addImportId(this.result.itemSpells);
    this.result.spells = addImportId(this.result.spells);
  }

  async resetActor() {
    await this.actor.deleteEmbeddedDocuments("Item", [], {
      deleteAll: true,
      itemsWithSpells5e: { alsoDeleteChildSpells: false },
    });
    await this.actor.deleteEmbeddedDocuments("ActiveEffect", [], { deleteAll: true });
    await this.actor.update(this.actorOriginal, { recursive: true, keepId: true });
  }

  getSettings() {
    this.settings = {
      updatePolicyName: game.settings.get("ddb-importer", "character-update-policy-name"),
      updatePolicyHP: game.settings.get("ddb-importer", "character-update-policy-hp"),
      updatePolicyHitDie: game.settings.get("ddb-importer", "character-update-policy-hit-die"),
      updatePolicyCurrency: game.settings.get("ddb-importer", "character-update-policy-currency"),
      updatePolicyBio: game.settings.get("ddb-importer", "character-update-policy-bio"),
      updatePolicyXP: game.settings.get("ddb-importer", "character-update-policy-xp"),
      updatePolicySpellUse: game.settings.get("ddb-importer", "character-update-policy-spell-use"),
      updatePolicyLanguages: game.settings.get("ddb-importer", "character-update-policy-languages"),
      updatePolicyImage: game.settings.get("ddb-importer", "character-update-policy-image"),
      activeEffectCopy: game.settings.get("ddb-importer", "character-update-policy-active-effect-copy"),
      // daeEffectCopy: game.settings.get("ddb-importer", "character-update-policy-dae-effect-copy"),
      // addItemEffects: game.settings.get("ddb-importer", "character-update-policy-add-item-effects"),
      addCharacterEffects: game.settings.get("ddb-importer", "character-update-policy-add-character-effects"),
      ignoreNonDDBItems: game.settings.get("ddb-importer", "character-update-policy-ignore-non-ddb-items"),
      useExistingCompendiumItems: game.settings.get("ddb-importer", "character-update-policy-use-existing"),
      useSRDCompendiumItems: game.settings.get("ddb-importer", "character-update-policy-use-srd"),
      useOverrideCompendiumItems: game.settings.get("ddb-importer", "character-update-policy-use-override"),
      useChrisPremades: game.settings.get("ddb-importer", "character-update-policy-use-chris-premades")
        && (game.modules.get("chris-premades")?.active ?? false),
    };
  }

  async processCharacterData() {
    this.getSettings();
    if (!CONFIG.DDBI.EFFECT_CONFIG.MODULES.configured) {
      // eslint-disable-next-line require-atomic-updates
      CONFIG.DDBI.EFFECT_CONFIG.MODULES.configured = await DDBMacros/* default.configureDependencies */.Z.configureDependencies();
    }
    this.result = foundry.utils.deepClone(this.ddbCharacter.data);

    // disable active sync
    const activeUpdateState = this.ddbCharacter.getCurrentDynamicUpdateState();
    await this.ddbCharacter.disableDynamicUpdates();

    try {
      this.importId = foundry.utils.randomID();
      foundry.utils.setProperty(this.result.character, "flags.ddbimporter.importId", this.importId);
      await this.addImportIdToItems();

      // handle active effects
      this.showCurrentTask("Calculating Active Effect Changes");
      this.fixUpCharacterEffects();
      await this.preActiveEffects();
      // we need to process the items first to find out if we are ignoring any effects
      let items = await this.fetchCharacterItems();
      await this.processActiveEffects();

      // update image
      await this.updateImage();

      // manage updates of basic character data more intelligently
      // revert some data if update not wanted
      if (!this.settings.updatePolicyName) {
        this.result.character.name = this.actorOriginal.name;
        this.result.character.prototypeToken.name = this.actorOriginal.prototypeToken.name;
      }
      if (!this.settings.updatePolicyHP) {
        this.result.character.system.attributes.hp = this.actorOriginal.system.attributes.hp;
      }
      if (!this.settings.updatePolicyXP) {
        this.result.character.system.details.xp = this.actorOriginal.system.details.xp;
      }
      if (!this.settings.updatePolicyHitDie) {
        this.result.character.system.attributes.hd = this.actorOriginal.system.attributes.hd;
        this.result.classes = this.result.classes.map((klass) => {
          const originalKlass = this.actorOriginal.items.find(
            (original) => original.name === klass.name && original.type === "class"
          );
          if (originalKlass) {
            klass.system.hitDiceUsed = originalKlass.system.hitDiceUsed;
          }
          return klass;
        });
      }
      if (!this.settings.updatePolicyCurrency) {
        this.result.character.system.currency = this.actorOriginal.system.currency;
      }
      if (!this.settings.updatePolicyBio) {
        const bioUpdates = ["alignment", "appearance", "background", "biography", "bond", "flaw", "ideal", "trait"];
        bioUpdates.forEach((option) => {
          this.result.character.system.details[option] = this.actorOriginal.system.details[option];
        });
      }
      if (!this.settings.updatePolicySpellUse) {
        this.result.character.system.spells = this.actorOriginal.system.spells;
      }
      if (!this.settings.updatePolicyLanguages) {
        this.result.character.system.traits.languages = this.actorOriginal.system.traits.languages;
      }
      // if resource mode is in disable and not asking, then we use the previous resources
      const resourceFlags = foundry.utils.getProperty(this.result.character, "flags.ddbimporter.resources");
      if (resourceFlags.type === "disable") {
        this.result.character.system.resources = foundry.utils.duplicate(this.actorOriginal.system.resources);
      }

      // flag as having items ids
      this.result.character.flags.ddbimporter["syncItemReady"] = true;
      this.result.character.flags.ddbimporter["syncActionReady"] = true;
      this.result.character.flags.ddbimporter["activeUpdate"] = false;
      this.result.character.flags.ddbimporter["activeSyncSpells"] = true;
      // remove unneeded flags (used for character parsing)
      this.result.character.flags.ddbimporter.dndbeyond["templateStrings"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["characterValues"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["proficiencies"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["proficienciesIncludingEffects"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["effectAbilities"] = null;
      this.result.character.flags.ddbimporter.dndbeyond["abilityOverrides"] = null;
      foundry.utils.setProperty(this.result.character.flags, "ddb-importer.version", CONFIG.DDBI.version);

      if (this.actorOriginal.flags.dnd5e?.wildMagic === true) {
        this.result.character.flags.dnd5e["wildMagic"] = true;
      }

      // midi fixes
      const actorOnUseMacroName = foundry.utils.getProperty(this.result.character, "flags.midi-qol.onUseMacroName");
      if (!actorOnUseMacroName || actorOnUseMacroName === "") {
        foundry.utils.setProperty(this.result.character, "flags.midi-qol.onUseMacroName", "[postActiveEffects]");
      }

      // basic import
      this.showCurrentTask("Updating core character information");
      logger/* default.debug */.Z.debug("Character data importing: ", this.result.character);
      await this.actor.update(this.result.character);

      // copy existing journal notes
      this.copyExistingJournalNotes();

      // items import
      await this.processCharacterItems(items);

      if (this.settings.activeEffectCopy) {
        // find effects with a matching name that existed on previous actor
        // and that have a different active state and activate them
        const targetEffects = this.actor.effects.filter((ae) => {
          const previousEffectDiff = this.actorOriginal.effects.find(
            (oae) => oae.name === ae.name && oae.disabled !== ae.disabled
          );
          if (previousEffectDiff) return true;
          return false;
        });
        const updatedEffects = targetEffects.map((ae) => {
          return { _id: ae._id, disabled: !ae.disabled };
        });
        await this.actor.updateEmbeddedDocuments("ActiveEffect", updatedEffects);
      }

      const favorites = foundry.utils.deepClone(this.actorOriginal.system.favorites ?? []);
      if (favorites.length > 0) {
        await this.actor.update({ system: { favorites } });
      }

      // add infusions to actors items
      await createInfusedItems(this.ddbCharacter.source.ddb, this.actor);

      await this.ddbCharacter.autoLinkResources();
      await this.ddbCharacter.fixItemSpellResources();

      if (this.settings.useChrisPremades) {
        await ExternalAutomations/* default.addChrisEffectsToActorDocuments */.Z.addChrisEffectsToActorDocuments(this.actor);
      }
      await setConditions(this.actor, this.ddbCharacter.source.ddb, this.settings.activeEffectCopy);

    } catch (error) {
      logger/* default.error */.Z.error("Error importing character: ", { error, ddbCharacter: this.ddbCharacter, result: this.result });
      logger/* default.error */.Z.error(error.stack);
      this.showCurrentTask("Error importing character, attempting rolling back, see console (F12) for details.", error, true);
      await this.resetActor();
      throw new Error("ImportFailure");
    } finally {
      await this.ddbCharacter.updateDynamicUpdates(activeUpdateState);
      this.actor.render();
    }
  }
}

async function importCharacter(actor, html) {
  try {
    const actorData = actor.toObject();
    const characterId = actorData.flags.ddbimporter.dndbeyond.characterId;

    const ddbCharacterOptions = {
      currentActor: actor,
      characterId,
      selectResources: true
    };
    const getOptions = {
      syncId: null,
      localCobaltPostFix: actorData._id,
    };
    const ddbCharacter = new DDBCharacter/* default */.Z(ddbCharacterOptions);
    await ddbCharacter.getCharacterData(getOptions);

    logger/* default.debug */.Z.debug("import.js importCharacter getCharacterData result", ddbCharacter.source);
    if (game.settings.get("ddb-importer", "debug-json")) {
      FileHelper/* default.download */.Z.download(JSON.stringify(ddbCharacter.source), `${characterId}.json`, "application/json");
    }
    if (ddbCharacter.source.success) {
      // begin parsing the character data
      const importer = new DDBCharacterManager(DDBCharacterManager.defaultOptions, actorData, ddbCharacter);
      importer.html = html ? html : utils/* default.htmlToDoc */.Z.htmlToDoc("");
      await importer.processCharacterData();
      importer.showCurrentTask("Loading Character data", "Done.", false);
      logger/* default.info */.Z.info("Loading Character data");
      return true;
    } else {
      logger/* default.error */.Z.error("Error Loading Character data", { message: ddbCharacter.source.message, ddbCharacter });
      return false;
    }
  } catch (error) {
    switch (error.message) {
      case "ImportFailure":
        logger/* default.error */.Z.error("Failure");
        break;
      case "Forbidden":
        logger/* default.error */.Z.error("Error retrieving Character: ", error);
        break;
      default:
        logger/* default.error */.Z.error("Error processing Character: ", error);
        logger/* default.error */.Z.error(error.stack);
        break;
    }
    return false;
  }
}

async function importCharacterById(characterId, html) {
  const actor = await Actor.create({
    name: "New Actor",
    type: "character",
    flags: {
      ddbimporter: {
        dndbeyond: {
          characterId: characterId,
          url: `https://www.dndbeyond.com/characters/${characterId}`,
        },
      },
    },
  });

  const result = await importCharacter(actor, html);
  return result;
}

;// CONCATENATED MODULE: ./src/parser/DDBEncounters.js










class DDBEncounters {

  constructor() {
    this.encounters = [];
  }

  static DIFFICULTY_LEVELS = [
    { id: null, name: "No challenge", color: "grey" },
    { id: 1, name: "Easy", color: "green" },
    { id: 2, name: "Medium", color: "brown" },
    { id: 3, name: "Hard", color: "orange" },
    { id: 4, name: "Deadly", color: "red" },
  ];

  static async getEncounterData() {
    const cobaltCookie = (0,Secrets/* getCobalt */.HF)();
    const betaKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
    const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
    const debugJson = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

    const body = {
      cobalt: cobaltCookie,
      betaKey: betaKey,
    };

    return new Promise((resolve, reject) => {
      fetch(`${parsingApi}/proxy/encounters`, {
        method: "POST",
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body), // body data type must match "Content-Type" header
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success) {
            DDBEncounterMunch.munchNote(`API Failure: ${data.message}`);
            reject(data.message);
          }
          if (debugJson) {
            FileHelper/* default.download */.Z.download(JSON.stringify(data), `encounters-raw.json`, "application/json");
          }
          return data;
        })
        .then((data) => {
          DDBEncounterMunch.munchNote(`Retrieved ${data.data.length} encounters, starting parse...`, true, false);
          logger/* default.info */.Z.info(`Retrieved ${data.data.length} encounters`);
          resolve(data.data);
        })
        .catch((error) => reject(error));
    });
  }

  async parseEncounters() {
    this.encounters = await DDBEncounters.getEncounterData();
    logger/* default.debug */.Z.debug("Fetched encounters", this.encounters);
    DDBEncounterMunch.munchNote(`Fetched Available DDB Encounters`);
    DDBEncounterMunch.munchNote("");
    return this.encounters;
  }

  async filterEncounters(campaignId) {
    const campaigns = await DDBCampaigns/* default.getAvailableCampaigns */.Z.getAvailableCampaigns();
    const campaignIds = campaigns.map((c) => c.id);
    const allEncounters = this.encounters.length !== 0 ? this.encounters : await this.parseEncounters();

    logger/* default.debug */.Z.debug(`${allEncounters.length} encounters`, allEncounters);
    logger/* default.debug */.Z.debug("CampaignIds", campaignIds);
    if (!campaignId || campaignId === "" || !campaignIds.includes(parseInt(campaignId))) return allEncounters;
    logger/* default.debug */.Z.debug(`CampaignId to find ${campaignId}`, { allEncounters, campaignId });
    const filteredEncounters = allEncounters.filter((encounter) => encounter.campaign?.id == campaignId);
    logger/* default.debug */.Z.debug(`${filteredEncounters.length} filtered encounters`, filteredEncounters);
    return filteredEncounters;
  }
}

;// CONCATENATED MODULE: ./src/apps/DDBEncounterMunch.js












class DDBEncounterMunch extends Application {

  constructor(options = {}) {
    super(options);
    this.encounter = {};
    this.img = "";
    this.sceneId = "";
    this.journal = undefined;
    this.combat = undefined;
    this.tokens = [];
    this.folders = {};
    this.ddbEncounters = new DDBEncounters();
  }

  static SCENE_IMG = [
    { name: "Bar", img: "modules/ddb-importer/img/encounters/bar.webp" },
    { name: "Cobbles", img: "modules/ddb-importer/img/encounters/cobbles.webp" },
    { name: "Dungeon", img: "modules/ddb-importer/img/encounters/dungeon.png" },
    { name: "Grass", img: "modules/ddb-importer/img/encounters/grass.webp" },
    { name: "Snow", img: "modules/ddb-importer/img/encounters/snow.webp" },
    { name: "Stone", img: "modules/ddb-importer/img/encounters/stone.webp" },
    { name: "Void", img: "modules/ddb-importer/img/encounters/void.webp" },
  ];

  /**
   * Display information when Munching
   * @param {*} note
   * @param {*} nameField
   * @param {*} monsterNote
   */
  static munchNote(note, nameField = false, monsterNote = false) {
    if (nameField) {
      $("#munching-task-name").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    } else if (monsterNote) {
      $("#munching-task-monster").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    } else {
      $("#munching-task-notes").text(note);
      $("#ddb-importer-monsters").css("height", "auto");
    }
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.baseApplication = "DDBEncounterMuncher";
    options.id = "ddb-importer-encounters";
    options.template = "modules/ddb-importer/handlebars/encounters.hbs";
    options.resizable = false;
    options.height = "auto";
    options.width = 800;
    options.title = "MrPrimate's DDB Encounter Muncher";
    options.classes = ["ddb-muncher", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "div", initial: "settings" }];
    return options;
  }

  async parseEncounter(id) {
    logger/* default.debug */.Z.debug(`Looking for Encounter "${id}"`);
    if (this.ddbEncounters.encounters.length === 0) return this.encounter;
    const monsterPack = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("monster", false);
    await monsterPack.getIndex({ fields: ["name", "flags.ddbimporter.id"] });

    const encounter = this.ddbEncounters.encounters.find((e) => e.id == id.trim());

    let goodMonsterIds = [];
    let missingMonsterIds = [];
    logger/* default.debug */.Z.debug("Parsing encounter", encounter);
    encounter.monsters.forEach((monster) => {
      const id = monster.id;
      const monsterInPack = monsterPack.index.find((f) => f.flags?.ddbimporter?.id == id);
      if (monsterInPack) {
        goodMonsterIds.push({ ddbId: id, name: monsterInPack.name, id: monsterInPack._id, quantity: monster.quantity });
      } else {
        missingMonsterIds.push({ ddbId: id, quantity: monster.quantity });
      }
    });

    let goodCharacterData = [];
    let missingCharacterData = [];
    encounter.players
      .filter((character) => !character.hidden)
      .forEach((character) => {
        const characterInGame = game.actors.find(
          (actor) =>
            actor.flags?.ddbimporter?.dndbeyond?.characterId
            && actor.flags.ddbimporter.dndbeyond.characterId == character.id
        );
        if (characterInGame) {
          goodCharacterData.push({ id: characterInGame.id, name: characterInGame.name, ddbId: character.id });
        } else {
          missingCharacterData.push({ ddbId: character.id, name: character.name });
        }
      });

    const difficulty = DDBEncounters.DIFFICULTY_LEVELS.find((level) => level.id == encounter.difficulty);

    this.encounter = {
      id,
      name: encounter.name,
      inProgress: encounter.inProgress,
      turnNum: encounter.turnNum,
      roundNum: encounter.roundNum,
      difficulty,
      description: encounter.description,
      rewards: encounter.rewards,
      summary: encounter.flavorText,
      campaign: encounter.campaign,
      monsters: encounter.monsters,
      characters: encounter.players,
      goodMonsterIds,
      missingMonsterIds,
      goodCharacterData,
      missingCharacterData,
      missingMonsters: missingMonsterIds.length !== 0,
      missingCharacters: missingCharacterData.length !== 0,
    };

    this.folders = {};

    logger/* default.debug */.Z.debug("Current encounter", this.encounter);

    return this.encounter;
  }

  resetEncounter(html) {
    const nameHtml = html.find("#ddb-encounter-name");
    const summaryHtml = html.find("#ddb-encounter-summary");
    const charactersHtml = html.find("#ddb-encounter-characters");
    const monstersHtml = html.find("#ddb-encounter-monsters");
    const difficultyHtml = html.find("#ddb-encounter-difficulty");
    const rewardsHtml = html.find("#ddb-encounter-rewards");
    const progressHtml = html.find("#ddb-encounter-progress");

    nameHtml[0].innerHTML = `<p id="ddb-encounter-name"><i class='fas fa-question'></i> <b>Encounter:</b></p>`;
    summaryHtml[0].innerHTML = `<p id="ddb-encounter-summary"><i class='fas fa-question'></i> <b>Summary:</b></p>`;
    charactersHtml[0].innerHTML = `<p id="ddb-encounter-characters"><i class='fas fa-question'></i> <b>Characters:</b></p>`;
    monstersHtml[0].innerHTML = `<p id="ddb-encounter-monsters"><i class='fas fa-question'></i> <b>Monsters:</b></p>`;
    difficultyHtml[0].innerHTML = `<p id="ddb-encounter-difficulty"><i class='fas fa-question'></i> <b>Difficulty:</b></p>`;
    rewardsHtml[0].innerHTML = `<p id="ddb-encounter-rewards"><i class='fas fa-question'></i> <b>Rewards:</b></p>`;
    progressHtml[0].innerHTML = `<p id="ddb-encounter-progress"><i class='fas fa-question'></i> <b>In Progress:</b></p>`;

    $("#ddb-importer-encounters").css("height", "auto");
    $("#encounter-button").prop("disabled", true);
    $("#encounter-button").prop("innerText", "Import Encounter");
    $("#encounter-import-policy-use-ddb-save").prop("disabled", true);
    this.encounter = {};
    this.journal = undefined;
    this.combat = undefined;
    this.tokens = [];
  }

  async importMonsters() {
    const importMonsters = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-missing-monsters");

    if (importMonsters && this.encounter.missingMonsters && this.encounter.missingMonsterIds.length > 0) {
      logger/* default.debug */.Z.debug("Importing missing monsters from DDB");
      const monsterFactory = new DDBMonsterFactory/* default */.Z({ munchNote: DDBEncounterMunch.munchNote });
      await monsterFactory.processIntoCompendium(this.encounter.missingMonsterIds.map((monster) => monster.ddbId));
      logger/* default.debug */.Z.debug("Finised Importing missing monsters from DDB");
    }

    const monsterPack = CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType("monster", false);
    await monsterPack.getIndex({ fields: ["name", "flags.ddbimporter.id"] });
    const compendiumName = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("monster");

    let monstersToAddToWorld = [];
    this.encounter.monsterData = [];
    this.encounter.worldMonsters = [];
    let journalMonsterInfo = new Map();
    this.encounter.monsters.forEach((monster) => {
      const id = monster.id;
      const monsterInPack = monsterPack.index.find((f) => f.flags?.ddbimporter?.id == id);
      if (monsterInPack) {
        let monsterData = {
          ddbId: id,
          name: monsterInPack.name,
          id: monsterInPack._id,
          quantity: monster.quantity,
          journalLink: `@Compendium[${compendiumName}.${monsterInPack._id}]{${monsterInPack.name}}`,
        };
        if (journalMonsterInfo.has(monsterData.ddbId)) {
          monsterData = journalMonsterInfo.get(monsterData.ddbId);
          monsterData.quantity += monster.quantity;
        }
        journalMonsterInfo.set(monsterData.ddbId, monsterData);

        for (let i = 0; i < monster.quantity; i++) {
          let addData = foundry.utils.deepClone(monsterData);
          addData.quantity = 1;
          addData.uniqueId = monster.uniqueId;
          addData.initiative = monster.initiative;
          addData.currentHitPoints = monster.currentHitPoints;
          addData.maximumHitPoints = monster.maximumHitPoints;
          addData.temporaryHitPoints = monster.temporaryHitPoints;
          addData.ddbName = monster.name ? monster.name : monsterInPack.name;
          monstersToAddToWorld.push(addData);
        }
      }
    });
    this.encounter.monsterData = Object.values(journalMonsterInfo);

    const encounterMonsterFolder = await FolderHelper/* default.getFolder */.Z.getFolder(
      "npc",
      this.encounter.name,
      "D&D Beyond Encounters",
      "#6f0006",
      "#98020a",
      false
    );

    logger/* default.debug */.Z.debug("Trying to import monsters from compendium", monstersToAddToWorld);
    await utils/* default.asyncForEach */.Z.asyncForEach(monstersToAddToWorld, async (actor) => {
      let worldActor = game.actors.find(
        (a) => a.folder?.id == encounterMonsterFolder.id && a.flags?.ddbimporter?.id == actor.ddbId
      );
      if (!worldActor) {
        logger/* default.info */.Z.info(
          `Importing monster ${actor.name} with DDB ID ${actor.ddbId} from ${monsterPack.metadata.name} with id ${actor.id}`
        );
        try {
          worldActor = await game.actors.importFromCompendium(monsterPack, actor.id, {
            folder: encounterMonsterFolder.id,
          });
        } catch (err) {
          logger/* default.error */.Z.error(err);
          logger/* default.warn */.Z.warn(`Unable to import actor ${actor.name} with id ${actor.id} from DDB Compendium`);
          logger/* default.debug */.Z.debug(
            `Failed on: game.actors.importFromCompendium(monsterCompendium, "${actor.id}", { folder: "${encounterMonsterFolder.id}" });`
          );
        }
      }
      this.encounter.worldMonsters.push(foundry.utils.mergeObject(actor, { id: worldActor.id }));
    });

    return new Promise((resolve) => {
      resolve(this.encounter.worldMonsters);
    });
  }

  async importCharacters(html) {
    const importCharacters = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-missing-characters");
    if (importCharacters && this.encounter.missingCharacters) {
      await utils/* default.asyncForEach */.Z.asyncForEach(this.encounter.missingCharacterData, async (character) => {
        await importCharacterById(character.ddbId, html);
      });
    }
  }

  async createJournalEntry() {
    logger/* default.debug */.Z.debug(`Creating journal entry`);
    const journal = {
      name: this.encounter.name,
      flags: {
        ddbimporter: {
          encounterId: this.encounter.id,
        },
      },
    };

    const importJournal = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-journal");
    if (importJournal) {
      const journalFolder = await FolderHelper/* default.getFolder */.Z.getFolder(
        "journal",
        this.encounter.name,
        "D&D Beyond Encounters",
        "#6f0006",
        "#98020a",
        false
      );
      journal.folder = journalFolder.id;
      journal.content = `<h1>${this.encounter.name}</h1>`;
      if (this.encounter.summary && this.encounter.summary != "") {
        journal.content += `<h2>Summary</h2>${this.encounter.summary}`;
      }
      if (this.encounter.monsterData && this.encounter.monsterData.length > 0) {
        journal.content += `<h2>Monsters</h2><ul>`;
        this.encounter.monsterData.forEach((monster) => {
          journal.content += `<li><p>${monster.journalLink} x${monster.quantity}</p></li>`;
        });
        journal.content += `</ul>`;
      }
      if (this.encounter.difficulty && this.encounter.difficulty != "") {
        journal.content += `<h2>Difficulty: <span style="color: ${this.encounter.difficulty.color}">${this.encounter.difficulty.name}</span></h3>`;
      }
      if (this.encounter.description && this.encounter.description != "") {
        journal.content += `<h2>Description</h2>${this.encounter.description}`;
      }
      if (this.encounter.rewards && this.encounter.rewards != "") {
        journal.content += `<h2>Rewards</h2>${this.encounter.rewards}`;
      }

      let worldJournal = game.journal.find(
        (a) => a.folder == journalFolder.id && a.flags?.ddbimporter?.encounterId == this.encounter.id
      );
      if (!worldJournal) {
        logger/* default.info */.Z.info(`Importing journal ${journal.name}`);
        try {
          worldJournal = await JournalEntry.create(journal);
        } catch (err) {
          logger/* default.error */.Z.error(err);
          logger/* default.warn */.Z.warn(`Unable to create journal ${journal.name}`);
        }
      } else {
        logger/* default.info */.Z.info(`Updating journal ${journal.name}`);
        journal._id = worldJournal.id;
        await worldJournal.update(journal);
      }
      this.journal = worldJournal;
    }

    return new Promise((resolve) => {
      resolve(journal);
    });
  }


  async createNewScene() {
    this.folders["scene"] = await FolderHelper/* default.getFolder */.Z.getFolder(
      "scene",
      this.encounter.name,
      "D&D Beyond Encounters",
      "#6f0006",
      "#98020a",
      false
    );

    let sceneData = {
      name: this.encounter.name,
      flags: {
        ddbimporter: {
          encounterId: this.encounter.id,
          encounters: true,
        },
      },
      width: 1000,
      height: 1000,
      grid: {
        type: 1,
        size: 100,
        distance: 5,
        units: "ft",
      },
      padding: 0.25,
      initial: {
        x: 500,
        y: 500,
        scale: 0.57,
      },
      img: this.img,
      tokenVision: false,
      fogExploration: false,
      folder: this.folders["scene"].id,
    };

    return sceneData;

  }

  // eslint-disable-next-line complexity
  async createScene() {
    const importDDBIScene = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene");
    const useExistingScene = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene");

    if (!importDDBIScene && !useExistingScene) return undefined;

    let sceneData;
    let worldScene;

    if (importDDBIScene) {
      logger/* default.debug */.Z.debug(`Creating scene for encounter "${this.encounter.name}""`);
      sceneData = await this.createNewScene();
    } else if (useExistingScene) {
      worldScene = game.scenes.find((s) => s.id == this.sceneId);
      if (worldScene) {
        sceneData = worldScene.toObject();
        logger/* default.debug */.Z.debug(`Using existing scene "${worldScene.name}" for encounter "${this.encounter.name}""`, { worldScene, sceneData });
      } else {
        logger/* default.warn */.Z.warn(`Unable to find scene ${this.sceneId}, creating a new scene `);
        throw new Error(`Unable to find scene ${this.sceneId}, creating a new scene `);
      }
      this.scene = worldScene;
    }

    if (sceneData) {
      let tokenData = [];
      const useDDBSave
        = this.encounter.inProgress && game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-use-ddb-save");
      const xSquares = sceneData.width / sceneData.grid.size;
      const ySquares = sceneData.height / sceneData.grid.size;
      const midSquareOffset = sceneData.grid.size / 2;
      const widthPaddingOffset = sceneData.width * sceneData.padding;
      const heightPaddingOffset = sceneData.height * sceneData.padding;
      const xPCOffset = sceneData.grid.size * (xSquares - 1);
      const xStartPixelMonster = widthPaddingOffset + midSquareOffset;
      const xStartPixelPC = xStartPixelMonster + xPCOffset;
      const yStartPixel = heightPaddingOffset + midSquareOffset;
      let characterCount = 0;
      this.encounter.characters
        .filter((character) => !character.hidden)
        .forEach(async (character) => {
          logger/* default.info */.Z.info(`Generating token ${character.name} for ${this.encounter.name}`);
          const characterInGame = game.actors.find(
            (actor) =>
              actor.flags?.ddbimporter?.dndbeyond?.characterId
              && actor.flags.ddbimporter.dndbeyond.characterId == character.id
          );
          if (characterInGame) {
            const onScene = useExistingScene && worldScene.tokens
              .some((t) => t.actor.flags?.ddbimporter?.id == character.id && t.actor.type == "character");

            if (!onScene) {
              const linkedToken = foundry.utils.duplicate(await characterInGame.getTokenDocument());
              if (useDDBSave) {
                foundry.utils.setProperty(linkedToken, "flags.ddbimporter.dndbeyond.initiative", character.initiative);
              }
              foundry.utils.setProperty(linkedToken, `delta.flags.ddbimporter.encounters`, true);
              foundry.utils.setProperty(linkedToken, `delta.flags.ddbimporter.encounterId`, this.encounter.id);
              linkedToken.x = xStartPixelPC;
              const yOffsetChange = characterCount * sceneData.grid.size;
              linkedToken.y = yStartPixel + yOffsetChange;
              tokenData.push(linkedToken);
              characterCount++;
            }
          }
        });

      let monsterDepth = 0;
      let monsterRows = 0;
      let rowMonsterWidth = 1;
      for (const worldMonster of this.encounter.worldMonsters) {
        logger/* default.info */.Z.info(`Generating token ${worldMonster.ddbName} (${worldMonster.name}) for ${this.encounter.name}`);
        const monster = game.actors.get(worldMonster.id);
        const linkedToken = foundry.utils.duplicate(await monster.getTokenDocument());
        if (monsterDepth + linkedToken.height > ySquares) {
          monsterDepth = 0;
          monsterRows += rowMonsterWidth;
          rowMonsterWidth = 1;
        }

        foundry.utils.setProperty(linkedToken, "name", worldMonster.ddbName);
        foundry.utils.setProperty(linkedToken, `delta.name`, worldMonster.ddbName);
        foundry.utils.setProperty(linkedToken, "flags.ddbimporter.dndbeyond.uniqueId", worldMonster.uniqueId);
        foundry.utils.setProperty(linkedToken, "flags.ddbimporter.encounterId", this.encounter.id);
        foundry.utils.setProperty(linkedToken, `delta.flags.ddbimporter.dndbeyond.uniqueId`, worldMonster.uniqueId);
        foundry.utils.setProperty(linkedToken, `delta.flags.ddbimporter.encounters`, true);
        foundry.utils.setProperty(linkedToken, `delta.flags.ddbimporter.encounterId`, this.encounter.id);
        const xOffsetChange = sceneData.grid.size * monsterRows;
        const yOffsetChange = monsterDepth * sceneData.grid.size;
        linkedToken.x = xStartPixelMonster + xOffsetChange;
        linkedToken.y = yStartPixel + yOffsetChange;
        if (useDDBSave) {
          foundry.utils.setProperty(linkedToken, "flags.ddbimporter.dndbeyond.initiative", worldMonster.initiative);
          // if no hp changes have been made on a monster on ddb it says 0 here
          if (worldMonster.maximumHitPoints !== 0) {
            foundry.utils.setProperty(linkedToken, `delta.system.attributes.hp.max`, worldMonster.maximumHitPoints);
            foundry.utils.setProperty(
              linkedToken,
              `delta.system.attributes.hp.value`,
              worldMonster.currentHitPoints + worldMonster.temporaryHitPoints
            );
          }
        }

        tokenData.push(linkedToken);
        monsterDepth += linkedToken.height;
        if (linkedToken.width > rowMonsterWidth) rowMonsterWidth = linkedToken.width;
      }

      if (this.journal?.id) sceneData.journal = this.journal.id;

      if (importDDBIScene) {
        worldScene = game.scenes.find(
          (a) => a.folder == this.folders["scene"].id
          && a.flags?.ddbimporter?.encounterId == this.encounter.id
        );
      }

      if (worldScene) {
        logger/* default.info */.Z.info(`Updating scene ${sceneData.name}`);
        const existingCombats = game.combats.filter((c) =>
          c.scene?.id == worldScene.id
          && c.flags?.ddbimporter?.encounterId == this.encounter.id
        );
        await Combat.deleteDocuments(existingCombats.map((c) => c.id));
        if (importDDBIScene) {
          logger/* default.info */.Z.info(`Updating DDBI scene ${sceneData.name}`);
          sceneData._id = worldScene.id;
          await worldScene.deleteEmbeddedDocuments("Token", [], { deleteAll: true });
          await worldScene.update(foundry.utils.mergeObject(worldScene.toObject(), sceneData));
        } else if (useExistingScene) {
          logger/* default.info */.Z.info(`Checking existing scene ${sceneData.name} for encounter monsters`);
          const existingSceneMonsterIds = worldScene.tokens
            .filter((t) => t.flags?.ddbimporter?.encounterId == this.encounter.id && t.actor.type == "npc")
            .map((t) => t.id);
          await worldScene.deleteEmbeddedDocuments("Token", existingSceneMonsterIds);
        }
      } else if (importDDBIScene) {
        logger/* default.info */.Z.info(`Importing scene ${sceneData.name}`);
        try {
          // eslint-disable-next-line require-atomic-updates
          worldScene = await Scene.create(sceneData);
        } catch (err) {
          logger/* default.error */.Z.error(err);
          logger/* default.warn */.Z.warn(`Unable to create scene ${sceneData.name}`);
        }
      }

      const thumbData = await worldScene.createThumbnail();
      const thumbScene = worldScene.toObject();
      thumbScene["thumb"] = thumbData.thumb;

      logger/* default.debug */.Z.debug("Creating tokenens on scene", tokenData);
      // eslint-disable-next-line require-atomic-updates
      worldScene = await worldScene.update(thumbScene, { keepId: true });

      await worldScene.createEmbeddedDocuments("Token", tokenData);

      this.scene = worldScene;
    }
    logger/* default.debug */.Z.debug("Scene created", this.scene);

    this.scene.render();

    return this.scene;
  }

  async createCombatEncounter() {
    const importCombat = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene")
      || game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene");

    if (!importCombat) return undefined;
    logger/* default.debug */.Z.debug(`Creating combat for encounter ${this.encounter.name}`);

    const useDDBSave
      = this.encounter.inProgress && game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-use-ddb-save");

    await this.scene.view();
    const flags = {
      "ddbimporter.encounterId": this.encounter.id,
    };
    this.combat = await Combat.create({ scene: this.scene.id, flags: flags });
    await this.combat.activate();

    let toCreate = [];
    const tokens = canvas.tokens.placeables
      .filter((t) => t.document.flags?.ddbimporter?.encounterId == this.encounter.id || t.actor.type == "character");
    if (tokens.length) {
      tokens.forEach((t) => {
        let combatant = { tokenId: t.id, actorId: t.document.actorId, hidden: t.document.hidden };
        if (useDDBSave && t.document.flags.ddbimporter?.dndbeyond?.initiative)
          combatant.initiative = t.document.flags.ddbimporter.dndbeyond.initiative;
        if (!t.inCombat) toCreate.push(combatant);
      });
      const combatants = await this.combat.createEmbeddedDocuments("Combatant", toCreate);

      const rollMonsterInitiative = game.settings.get(
        "ddb-importer",
        "encounter-import-policy-roll-monster-initiative"
      );
      combatants
        .filter((c) => rollMonsterInitiative && c.actor.type === "npc" && c.initiative === null)
        .forEach(async (c) => {
          if (c.initiative === null) await this.combat.rollInitiative(c.id);
        });
    }

    return this.combat;
  }

  activateListeners(html) {
    super.activateListeners(html);

    $(html)
      .find(
        ['.munching-generic-config input[type="checkbox"]', '.munching-monster-config input[type="checkbox"]'].join(",")
      )
      .on("change", (event) => {
        MuncherSettings/* default.updateMuncherSettings */.Z.updateMuncherSettings(html, event);
      });

    $(html)
      .find(
        [
          '.import-policy input[type="checkbox"]',
          '.advanced-import-config input[type="checkbox"]',
          '.effect-policy input[type="checkbox"]',
          '.effect-import-config input[type="checkbox"]',
          '.extras-import-config input[type="checkbox"]',
          '.import-config input[type="checkbox"]',
        ].join(",")
      )
      .on("change", (event) => {
        MuncherSettings/* default.updateActorSettings */.Z.updateActorSettings(html, event);
      });

    $(html)
      .find("#default-effects")
      .on("click", async (event) => {
        event.preventDefault();
        MuncherSettings/* default.setRecommendedCharacterActiveEffectSettings */.Z.setRecommendedCharacterActiveEffectSettings(html);
      });

    $(html)
      .find('.sync-policy input[type="checkbox"]')
      .on("change", (event) => {
        game.settings.set(
          "ddb-importer",
          "sync-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    $(html)
      .find('.encounter-config input[type="checkbox"]')
      .on("change", (event) => {
        switch (event.currentTarget.dataset.section) {
          case "create-scene": {
            game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene", false);
            if (event.currentTarget.checked) $("#encounter-scene-select").prop("disabled", true);
            $("#encounter-scene-img-select").prop("disabled", !event.currentTarget.checked);
            $("#encounter-import-policy-existing-scene").prop('checked', false);
            break;
          }
          case "existing-scene": {
            game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene", false);
            if (event.currentTarget.checked) $("#encounter-scene-img-select").prop("disabled", true);
            $("#encounter-scene-select").prop("disabled", !event.currentTarget.checked);
            $("#encounter-import-policy-create-scene").prop('checked', false);
            break;
          }
          // no default
        };
        game.settings.set(
          "ddb-importer",
          "encounter-import-policy-" + event.currentTarget.dataset.section,
          event.currentTarget.checked
        );
      });

    // img change
    html.find("#encounter-scene-img-select").on("change", async () => {
      const imgSelect = html.find("#encounter-scene-img-select");
      this.img = imgSelect[0].selectedOptions[0] ? imgSelect[0].selectedOptions[0].value : "";
    });

    html.find("#encounter-scene-select").on("change", async () => {
      const imgSelect = html.find("#encounter-scene-select");
      this.sceneId = imgSelect[0].selectedOptions[0] ? imgSelect[0].selectedOptions[0].value : "";
    });

    // filter campaigns
    html.find("#encounter-campaign-select").on("change", async () => {
      const campaignSelection = html.find("#encounter-campaign-select");
      // get selected campaign from html selection
      const campaignId = campaignSelection[0].selectedOptions[0]
        ? campaignSelection[0].selectedOptions[0].value
        : undefined;
      const encounters = await this.ddbEncounters.filterEncounters(campaignId);
      const campaignSelected = campaignId && campaignId !== "";
      let encounterList = `<option value="">Select encounter:</option>`;
      encounters.forEach((encounter) => {
        encounterList += `<option value="${encounter.id}">${encounter.name}${
          campaignSelected || !encounter.campaign ? "" : ` (${encounter.campaign.name})`
        }</option>\n`;
      });
      const list = html.find("#encounter-select");
      list[0].innerHTML = encounterList;
      this.resetEncounter(html);
    });

    // encounter change
    html.find("#encounter-select").on("change", async () => {
      this.resetEncounter(html);
      const encounterSelection = html.find("#encounter-select");
      const encounterId = encounterSelection[0].selectedOptions[0]
        ? encounterSelection[0].selectedOptions[0].value
        : undefined;

      const encounter = await this.parseEncounter(encounterId);
      // console.warn(encounter);

      const nameHtml = html.find("#ddb-encounter-name");
      const summaryHtml = html.find("#ddb-encounter-summary");
      const charactersHtml = html.find("#ddb-encounter-characters");
      const monstersHtml = html.find("#ddb-encounter-monsters");
      const difficultyHtml = html.find("#ddb-encounter-difficulty");
      const rewardsHtml = html.find("#ddb-encounter-rewards");
      const progressHtml = html.find("#ddb-encounter-progress");

      const missingCharacters = encounter.missingCharacters
        ? `fa-times-circle' style='color: red`
        : `fa-check-circle' style='color: green`;
      const missingMonsters = encounter.missingMonsters
        ? `fa-times-circle' style='color: red`
        : `fa-check-circle' style='color: green`;

      const goodCharacters = encounter.goodCharacterData.map((character) => `${character.name}`).join(", ");
      const goodMonsters = encounter.goodMonsterIds.map((monster) => `${monster.name}`).join(", ");
      const neededCharactersHTML = encounter.missingCharacters
        ? ` <span style="color: red"> Missing ${
          encounter.missingCharacterData.length
        }: ${encounter.missingCharacterData.map((character) => character.name).join(", ")}</span>`
        : "";
      const neededMonstersHTML = encounter.missingMonsters
        ? ` <span style="color: red"> Missing ${
          encounter.missingMonsterIds.length
        }. DDB Id's: ${encounter.missingMonsterIds.map((monster) => monster.ddbId).join(", ")}</span>`
        : "";

      nameHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Encounter:</b> ${encounter.name}`;
      if (encounter.summary && encounter.summary.trim() !== "") {
        summaryHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Summary:</b> ${encounter.summary}`;
      }
      if (encounter.goodCharacterData.length > 0 || encounter.missingCharacterData.length > 0) {
        charactersHtml[0].innerHTML = `<i class='fas ${missingCharacters}'></i> <b>Characters:</b> ${goodCharacters}${neededCharactersHTML}`;
      }
      if (encounter.goodMonsterIds.length > 0 || encounter.missingMonsterIds.length > 0) {
        monstersHtml[0].innerHTML = `<i class='fas ${missingMonsters}'></i> <b>Monsters:</b> ${goodMonsters}${neededMonstersHTML}`;
      }
      difficultyHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Difficulty:</b> <span style="color: ${encounter.difficulty.color}">${encounter.difficulty.name}</span>`;
      if (encounter.rewards && encounter.rewards.trim() !== "") {
        rewardsHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Rewards:</b> ${encounter.rewards}`;
      }

      progressHtml[0].innerHTML = encounter.inProgress
        ? `<i class='fas fa-times-circle' style='color: red'></i> <b>In Progress:</b> <span style="color: red"> Encounter in progress on <a href="https://www.dndbeyond.com/combat-tracker/${this.encounter.id}">D&D Beyond!</a></span>`
        : `<i class='fas fa-check-circle' style='color: green'></i> <b>In Progress:</b> No`;

      $("#encounter-import-policy-use-ddb-save").prop("disabled", !encounter.inProgress);
      $("#ddb-importer-encounters").css("height", "auto");
      $("#encounter-button").prop("disabled", false);
    });

    // import encounter
    html.find("#encounter-button").click(async (event) => {
      event.preventDefault();
      $("#encounter-button").prop("disabled", true);
      $("#encounter-button").prop("innerText", "Munching...");

      await this.importMonsters();
      await this.importCharacters(html);
      await this.createJournalEntry();
      const scene = await this.createScene();
      if (scene) {
        logger/* default.info */.Z.info(`Scene ${scene.id} created`);
        await this.createCombatEncounter();
      };

      // to do:
      // adjust monsters hp?
      // add initiative if combat in progress?
      // - extra import?
      // - attempt to find magic items and add them to the world?

      $("#encounter-button").prop("innerText", "Encounter Munched");
      const campaignFluff
        = this.encounter.campaign?.name && this.encounter.campaign.name.trim() !== "" ? ` of ${this.encounter.name}` : "";
      ui.notifications.warn(`Prepare to battle heroes${campaignFluff}, your doom awaits in ${this.encounter.name}!`);
    });
  }

  // eslint-disable-next-line class-methods-use-this
  async getData() {
    const tier = PatreonHelper/* default.getPatreonTier */.Z.getPatreonTier();
    const tiers = PatreonHelper/* default.calculateAccessMatrix */.Z.calculateAccessMatrix(tier);
    const availableCampaigns = await DDBCampaigns/* default.getAvailableCampaigns */.Z.getAvailableCampaigns();
    const availableEncounters = await this.ddbEncounters.filterEncounters();

    const characterSettings = MuncherSettings/* default.getCharacterImportSettings */.Z.getCharacterImportSettings();
    const muncherSettings = MuncherSettings/* default.getMuncherSettings */.Z.getMuncherSettings(false);

    const importSettings = foundry.utils.mergeObject(characterSettings, muncherSettings);

    const encounterConfig = [
      {
        name: "missing-characters",
        isChecked: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-missing-characters"),
        enabled: true,
        description: "Import missing characters?",
      },
      {
        name: "missing-monsters",
        isChecked: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-missing-monsters"),
        enabled: true,
        description: "Import missing monsters?",
      },
      {
        name: "create-journal",
        isChecked: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-journal"),
        enabled: true,
        description: "Create encounter journal entry?",
      },
      {
        name: "use-ddb-save",
        isChecked: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-use-ddb-save"),
        enabled: false,
        description: "Use save information from Encounter (HP for monsters and initiative for all)?",
      },
      {
        name: "create-scene",
        isChecked: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene"),
        enabled: true,
        description: "Create/update a scene to use, and add available characters and NPC's?",
      },
      {
        name: "existing-scene",
        isChecked: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene"),
        enabled: true,
        description: "Use an existing scene?",
      },
    ];

    const scenes = game.scenes.filter((scene) => !scene.flags?.ddbimporter?.encounters)
      .map((scene) => {
        const folderName = scene.folder ? `[${scene.folder.name}] ` : "";
        const s = {
          name: `${folderName}${scene.name}`,
          id: scene.id,
        };
        return s;
      })
      .sort((a, b) => a.name.localeCompare(b.name));

    const encounterSettings = {
      tiers,
      availableCampaigns,
      availableEncounters,
      encounterConfig,
      sceneImg: DDBEncounterMunch.SCENE_IMG,
      scenes,
      createSceneSelect: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-create-scene"),
      existingSceneSelect: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "encounter-import-policy-existing-scene"),
    };

    const data = foundry.utils.mergeObject(importSettings, encounterSettings);
    logger/* default.debug */.Z.debug("Encounter muncher form data", data);

    return data;
  }
}

// EXTERNAL MODULE: ./src/muncher/adventure.js
var adventure = __webpack_require__(9441);
// EXTERNAL MODULE: ./src/muncher/feats/feats.js
var feats = __webpack_require__(267);
// EXTERNAL MODULE: ./src/muncher/importMonster.js
var importMonster = __webpack_require__(9633);
// EXTERNAL MODULE: ./src/lib/DirectoryPicker.js
var DirectoryPicker = __webpack_require__(4222);
// EXTERNAL MODULE: ./src/parser/companions/DDBCompanion.js
var DDBCompanion = __webpack_require__(1126);
// EXTERNAL MODULE: ./src/lib/DDBCompendiumFolders.js
var DDBCompendiumFolders = __webpack_require__(819);
;// CONCATENATED MODULE: ./src/lib/OriginFixer.js




class OriginFixer {

  static ORIGIN_RE = /(.*)Actor\.([^.]+)(.*)$/g;

  // Some old DDB Actor parsings would add bad origins here
  static COMPENDIUM_ORIGIN_RE = /Compendium\.(.*)(?:Actor|null)\.([^.]+)(.*)$/g;

  static TOKEN_ORIGIN_RE = /(Scene.[^.]+.Token.[^.]+.Actor\.[^.]+)(.*)$/g;

  static _getEffectOrigin(effect, actorUuid, compendium = false) {
    if (compendium) {
      return effect.origin.replace(OriginFixer.COMPENDIUM_ORIGIN_RE, `${actorUuid}.$2$3`);
    } else if (effect.origin.match(OriginFixer.TOKEN_ORIGIN_RE)) {
      return effect.origin.replace(OriginFixer.TOKEN_ORIGIN_RE, `${actorUuid}$2`);
    } else {
      return effect.origin.replace(OriginFixer.ORIGIN_RE, `${actorUuid}$3`);
    }
  }

  static async updateActorEffects(actor, compendiumOnly = false) {
    if (!actor) return;
    const newEffects = [];
    const actorUuid = actor.uuid.replace("..", ".");
    let changesMade = false;

    for (const effect of actor.effects) {
      const newEffect = effect.toObject();
      const isDDBMonsterCompendium = effect.origin?.startsWith(`Compendium.${CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("monsters")}.`);
      const matchRe = compendiumOnly || isDDBMonsterCompendium ? OriginFixer.COMPENDIUM_ORIGIN_RE : OriginFixer.ORIGIN_RE;
      if (typeof effect.origin === "string"
        && effect.origin.match(matchRe)
        && (!effect.origin.startsWith("Compendium") || isDDBMonsterCompendium)
      ) {
        const testOrigin = OriginFixer._getEffectOrigin(effect, actorUuid, (compendiumOnly || isDDBMonsterCompendium));
        const originLoaded = await fromUuid(testOrigin);
        if (originLoaded && testOrigin !== effect.origin) {
          changesMade = true;
          logger/* default.debug */.Z.debug(`${actor.name} effect ${effect.name} origin ${effect.origin} -> ${testOrigin} ${actorUuid}`);
          newEffect.origin = testOrigin;
        }
      }
      newEffects.push(newEffect);
    }
    if (changesMade) {
      logger/* default.debug */.Z.debug(`Replacing effects on actor ${actor.name} [${actorUuid}]`, newEffects);
      await actor.updateEmbeddedDocuments("ActiveEffect", newEffects);
    }
  }

  static async fixActorOrigins(actor) {
    await OriginFixer.updateActorEffects(actor);
  }

  static async fixTokenOrigins(tokenOrTokenDocument) {
    if (!tokenOrTokenDocument.actor) return;
    await OriginFixer.updateActorEffects(tokenOrTokenDocument.actor);
  }

  static async fixActorOriginsForAllActors() {
    for (const actor of game.actors) {
      await OriginFixer.updateActorEffects(actor);
    }
  }

  static async fixTokenOriginsForScene(scene) {
    for (const token of scene.tokens) {
      await OriginFixer.updateActorEffects(token.actor);
    }
  }

  static async fixTokenOriginsForActiveScene() {
    await OriginFixer.fixTokenOriginsForScene(game.scenes.active);
  }

  static async fixTokenOriginsForAllScenes() {
    for (const scene of game.scenes) {
      await OriginFixer.fixTokenOriginsForScene(scene);
    }
  }

}

// EXTERNAL MODULE: ./src/lib/DialogHelper.js + 1 modules
var DialogHelper = __webpack_require__(7073);
// EXTERNAL MODULE: ./src/muncher/prices.js
var prices = __webpack_require__(3466);
// EXTERNAL MODULE: ./src/effects/external/ChrisPremadesHelper.js
var ChrisPremadesHelper = __webpack_require__(7252);
// EXTERNAL MODULE: ./src/effects/DDBSimpleMacro.js
var DDBSimpleMacro = __webpack_require__(4536);
// EXTERNAL MODULE: ./src/parser/companions/DDBSummonsManager.js
var DDBSummonsManager = __webpack_require__(6843);
;// CONCATENATED MODULE: ./src/api.js
// for exports












// import { base64Check } from "./lib/base64Check.js";































function resetSecrets() {
  game.settings.set("ddb-importer", "cobalt-cookie-local", false);
  game.settings.set("ddb-importer", "cobalt-cookie", "");
  game.settings.set("ddb-importer", "campaign-id", "");
}

// eslint-disable-next-line no-unused-vars
function migrateAllCompendiums(value, key, map) {
  if (!value.locked) game.dnd5e.migrations.migrateCompendium(value);
}

function migrateCompendiums() {
  const compendiumNames = CompendiumHelper/* default.getCompendiumNames */.Z.getCompendiumNames();
  game.packs.filter((pack) => compendiumNames.includes(pack.collection)).forEach(migrateAllCompendiums);
}

function debugStart() {
  CONFIG.debug.ddbimporter.record = true;
}

function debugStop() {
  CONFIG.debug.ddbimporter.download();
}

function testFunction(testName) {
  logger/* default.debug */.Z.debug(`generating test function: ${testName}`, testName);
  const print = (...params) => {
    logger/* default.warn */.Z.warn(`test function "${testName}" called with params`, { params });
  };
  return print;
}

function simpleTest(...params) {
  logger/* default.warn */.Z.warn(`running simple test with params`, { params });
}

async function updateFoundryCharacters() {
  for (const actor of game.actors.values()) {
    const ddbImported = 'ddbimporter' in actor.flags;
    if (ddbImported && actor.type === "character") {
      logger/* default.info */.Z.info(`Updating ${actor.name} to DDB`);
      await importCharacter(actor);
    }
  }
}

async function updateDDBCharacters() {
  for (const actor of game.actors.values()) {
    const ddbImported = 'ddbimporter' in actor.flags;
    if (ddbImported && actor.type === "character") {
      logger/* default.info */.Z.info(`Updating ${actor.name} to DDB`);
      await updateDDBCharacter(actor);
    }
  }
}

function registerApi() {
  const API = {
    migrateCompendiums,
    compendiums: {
      migrateCompendiums,
      DDBCompendiumFolders: DDBCompendiumFolders/* DDBCompendiumFolders */.Z,
      getCompendiumLabel: CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel,
      getCompendiumType: CompendiumHelper/* default.getCompendiumType */.Z.getCompendiumType,
      getCompendiumNames: CompendiumHelper/* default.getCompendiumNames */.Z.getCompendiumNames,
      deleteDefaultCompendiums: CompendiumHelper/* default.deleteDefaultCompendiums */.Z.deleteDefaultCompendiums,
    },
    patreon: {
      checkPatreon: PatreonHelper/* default.checkPatreon */.Z.checkPatreon,
      getPatreonTier: PatreonHelper/* default.getPatreonTier */.Z.getPatreonTier,
      getPatreonUser: PatreonHelper/* default.getPatreonUser */.Z.getPatreonUser,
      calculateAccessMatrix: PatreonHelper/* default.calculateAccessMatrix */.Z.calculateAccessMatrix,
      setPatreonTier: PatreonHelper/* default.setPatreonTier */.Z.setPatreonTier,
      fetchPatreonTier: PatreonHelper/* default.fetchPatreonTier */.Z.fetchPatreonTier,
      getPatreonValidity: PatreonHelper/* default.getPatreonValidity */.Z.getPatreonValidity,
    },
    lib: {
      ChrisPremadesHelper: ChrisPremadesHelper/* default */.Z,
      CompendiumHelper: CompendiumHelper/* default */.Z,
      DDBCampaigns: DDBCampaigns/* default */.Z,
      DDBCharacterManager: DDBCharacterManager,
      DDBCompanion: DDBCompanion/* default */.Z,
      DDBCompanionFactory: DDBCompanionFactory/* default */.Z,
      DDBCompendiumFolders: DDBCompendiumFolders/* DDBCompendiumFolders */.Z,
      DDBSimpleMacro: DDBSimpleMacro/* default */.Z,
      DDBEffectHelper: DDBEffectHelper/* default */.Z,
      DDBEncounterMunch: DDBEncounterMunch,
      DDBEncounters: DDBEncounters,
      DDBHelper: DDBHelper/* default */.Z,
      DDBItemImporter: DDBItemImporter/* default */.Z,
      DDBMacros: DDBMacros/* default */.Z,
      DDBMonster: DDBMonster/* default */.Z,
      DDBMonsterFactory: DDBMonsterFactory/* default */.Z,
      DDBProxy: DDBProxy/* default */.Z,
      DDBSummonsManager: DDBSummonsManager/* default */.Z,
      DialogHelper: DialogHelper/* default */.Z,
      DirectoryPicker: DirectoryPicker/* DirectoryPicker */.B,
      FileHelper: FileHelper/* default */.Z,
      MuncherSettings: MuncherSettings/* default */.Z,
      NameMatcher: NameMatcher/* default */.Z,
      OriginFixer: OriginFixer,
    },
    settings: {
      muncherSettings: MuncherSettings/* default.getMuncherSettings */.Z.getMuncherSettings,
      characterSettings: MuncherSettings/* default.getCharacterImportSettings */.Z.getCharacterImportSettings,
    },

    // base64Check: base64Check,
    checkCobalt: Secrets/* checkCobalt */.B,
    resetProxy: DDBProxy/* default.resetProxy */.Z.resetProxy,
    resetSecrets,

    generateAdventureConfig: adventure/* generateAdventureConfig */.k,
    downloadAdventureConfig: adventure/* downloadAdventureConfig */.T,

    importCharacter: importCharacter, // imports an actor
    importCharacterById: importCharacterById, // imports and actor by id
    updateDDBCharacter: updateDDBCharacter, // updates an actor back to ddb

    // bulk update
    updateAllPCs: {
      foundry: updateFoundryCharacters,
      ddb: updateDDBCharacters,
    },

    parse: {
      monsters: tools/* parseCritters */.CY,
      vehicles: vehicles/* parseTransports */.b,
      feats: feats/* getFeats */.S,
      items: items/* parseItems */.S,
      spells: spells/* parseSpells */.Z,
    },

    prices: {
      generateXgtePrices: prices/* updateItemPrices */.L,
      calculateXgtePrice: prices/* calculatePrice */.e,
    },

    updateWorldMonsters: tools/* updateWorldMonsters */.BU,

    getIconPath: Iconizer/* default.iconPath */.Z.iconPath,
    iconPath: Iconizer/* default.iconPath */.Z.iconPath,
    generateIcon: Iconizer/* default.generateIcon */.Z.generateIcon,

    importCacheLoad: DDBReferenceLinker/* importCacheLoad */.uB,
    getNPCImage: importMonster/* getNPCImage */.xD,
    resetCompendiumActorImages: tools/* resetCompendiumActorImages */.mk,

    generateItemMacroFlag: DDBMacros/* default.generateItemMacroFlag */.Z.generateItemMacroFlag,
    EffectHelper: DDBEffectHelper/* default */.Z,
    DialogHelper: DialogHelper/* default */.Z,
    effects: {
      helpers: DDBEffectHelper/* default */.Z,
      ChrisPremadesHelper: ChrisPremadesHelper/* default */.Z,
      addChrisEffectsToActorDocuments: ExternalAutomations/* default.addChrisEffectsToActorDocuments */.Z.addChrisEffectsToActorDocuments,
      addDDBIEffectsToActorDocuments: DDBEffectHelper/* default.addDDBIEffectsToActorDocuments */.Z.addDDBIEffectsToActorDocuments,
      addDDBIEffectToDocument: DDBEffectHelper/* default.addDDBIEffectToDocument */.Z.addDDBIEffectToDocument,
      // these are now in DDBEffectHelper, wrapped here for historical reasons
      addSaveAdvantageToTarget: DDBEffectHelper/* default.addSaveAdvantageToTarget */.Z.addSaveAdvantageToTarget,
      attachSequencerFileToTemplate: DDBEffectHelper/* default.attachSequencerFileToTemplate */.Z.attachSequencerFileToTemplate,
      checkCollision: DDBEffectHelper/* default.checkCollision */.Z.checkCollision,
      checkJB2a: DDBEffectHelper/* default.checkJB2a */.Z.checkJB2a,
      checkTargetInRange: DDBEffectHelper/* default.checkTargetInRange */.Z.checkTargetInRange,
      configureCustomAAForCondition: DDBEffectHelper/* default.configureCustomAAForCondition */.Z.configureCustomAAForCondition,
      findContainedTokensInTemplate: DDBEffectHelper/* default.findContainedTokensInTemplate */.Z.findContainedTokensInTemplate,
      findEffect: DDBEffectHelper/* default.findEffect */.Z.findEffect,
      findEffects: DDBEffectHelper/* default.findEffects */.Z.findEffects,
      getCantripDice: DDBEffectHelper/* default.getCantripDice */.Z.getCantripDice,
      getHighestAbility: DDBEffectHelper/* default.getHighestAbility */.Z.getHighestAbility,
      getRemainingDuration: DDBEffectHelper/* default.getRemainingDuration */.Z.getRemainingDuration,
      isRangedWeaponAttack: DDBEffectHelper/* default.isRangedWeaponAttack */.Z.isRangedWeaponAttack,
      requirementsSatisfied: DDBEffectHelper/* default.requirementsSatisfied */.Z.requirementsSatisfied,
      selectTargetsWithinX: DDBEffectHelper/* default.selectTargetsWithinX */.Z.selectTargetsWithinX,
      wait: DDBEffectHelper/* default.wait */.Z.wait,
    },
    executeDDBMacro: DDBMacros/* default.executeDDBMacro */.Z.executeDDBMacro,
    // macro tools
    macros: {
      createMacro: DDBMacros/* default.createMacro */.Z.createMacro,
      executeMacro: DDBMacros/* default.executeDDBMacro */.Z.executeDDBMacro,
      getMacroFunction: DDBMacros/* default.getMacroFunction */.Z.getMacroFunction,
      loadMacroFile: DDBMacros/* default.loadMacroFile */.Z.loadMacroFile,
      macros: DDBMacros/* default.MACROS */.Z.MACROS,
      getMacro: DDBMacros/* default.getMacro */.Z.getMacro,
      executeSimpleMacro: DDBSimpleMacro/* default.execute */.Z.execute
    },
    chris: {
      generateEffect: ExternalAutomations/* default.applyChrisPremadeEffect */.Z.applyChrisPremadeEffect,
      generateEffects: ExternalAutomations/* default.applyChrisPremadeEffects */.Z.applyChrisPremadeEffects,
      adjustActor: ExternalAutomations/* default.addChrisEffectsToActorDocuments */.Z.addChrisEffectsToActorDocuments,
    },
    debug: {
      start: debugStart,
      stop: debugStop,
      test: testFunction,
      simpleTest: simpleTest,
      utils: utils/* default */.Z,
    },
    DICTIONARY: dictionary/* default */.Z,
  };

  globalThis['DDBImporter'] = API;
  game.modules.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID).api = API;
  game.modules.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID).DICTIONARY = dictionary/* default */.Z;
}

;// CONCATENATED MODULE: ./src/hooks/init/chatHooks.js

function chatHooks() {
  Hooks.on("renderChatMessage", (message, html) => {
    const chatImg = html.find("img.ddbimporter-chat-image");
    chatImg.click((event) => {
      event.preventDefault();
      event.stopPropagation();
      new ImagePopout($(chatImg).attr("src"), { shareable: true }).render(true);
    });
  });
}

;// CONCATENATED MODULE: ./src/apps/DDBAdventureImporter.js



class DDBAdventureImporter extends AdventureImporter {

  constructor(adventure, options) {
    super(adventure, options);
    this.options.classes.push(src_settings/* default.ADVENTURE_CSS */.Z.ADVENTURE_CSS);
    this.importOptions = {};
  }

  /** @inheritDoc */
  async getData() {
    return foundry.utils.mergeObject(await super.getData(), {
      importOptions: this.importOptions || {}
    });
  }

  /** @inheritDoc */
  async _renderInner(data) {
    const html = await super._renderInner(data);

    let options = `<section class="import-form"><h2>Importer Options</h2>`;
    for (const [name, option] of Object.entries(this.importOptions)) {
      options += `<div class="form-group">
        <label class="checkbox">
            <input type="checkbox" name="${name}" title="${option.label}" ${option.default ? "checked" : ""}/>
            ${option.label}
        </label>
    </div>`;
    }
    options += `</section>`;

    html.find(".adventure-contents").append(options);
    return html;
  }

  /** @inheritDoc */
  async importContent(toCreate, toUpdate, documentCount) {
    const importResult = await super.importContent(toCreate, toUpdate, documentCount);
    for (let [name, option] of Object.entries(this.importOptions || {})) {
      if (option.handler) {
        await option.handler(this.document, option, this.submitOptions[name]);
      }
    }
    return importResult;
  }

}

;// CONCATENATED MODULE: ./src/hooks/init/adventureImporter.js



/* harmony default export */ function adventureImporter() {
  DocumentSheetConfig.registerSheet(Adventure, src_settings/* default.MODULE_ID */.Z.MODULE_ID, DDBAdventureImporter, {
    label: "DDB Adventure Importer"
  });

  // Hooks.on("renderJournalSheet", (app, html) => {
  //   const journal = app.document;
  //   if (journal.getFlag(SETTINGS.FLAG_NAME, SETTINGS.ADVENTURE_FLAG)) html[0].classList.add(SETTINGS.ADVENTURE_CSS);
  // });

  // Hooks.on("renderJournalPageSheet", (app, html) => {
  //   const journal = app.document.parent;
  //   if (journal.getFlag(SETTINGS.FLAG_NAME, SETTINGS.ADVENTURE_FLAG)) html[0].classList.add(SETTINGS.ADVENTURE_CSS);
  // });

}

;// CONCATENATED MODULE: ./src/apps/DDBSetup.js









// eslint-disable-next-line no-unused-vars
Hooks.on("renderma", (app, html, user) => {
  DirectoryPicker/* DirectoryPicker.processHtml */.B.processHtml(html);
});

class DDBSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-settings";
    options.template = "modules/ddb-importer/handlebars/settings.hbs";
    options.width = 500;
    return options;
  }

  static isSetupComplete(needsCobalt = true) {
    const uploadDir = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "image-upload-directory");
    const dataDirSet = !FileHelper/* default.BAD_DIRS.includes */.Z.BAD_DIRS.includes(uploadDir);
    const cobalt = (0,Secrets/* getCobalt */.HF)() != "";
    const setupComplete = dataDirSet && (cobalt || !needsCobalt);
    return setupComplete;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Settings";
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const cobalt = (0,Secrets/* getCobalt */.HF)();
    const isCobalt = cobalt !== "";
    const cobaltStatus = await (0,Secrets/* checkCobalt */.B)("", cobalt);
    const cobaltLocal = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie-local");
    const key = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();
    const hasKey = key !== "";
    const campaignId = DDBCampaigns/* default.getCampaignId */.Z.getCampaignId();
    const tier = PatreonHelper/* default.getPatreonTier */.Z.getPatreonTier();
    const patreonUser = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "patreon-user");
    const validKeyObject = hasKey ? (await PatreonHelper/* default.getPatreonValidity */.Z.getPatreonValidity(key)) : false;
    const validKey = validKeyObject && validKeyObject.success && validKeyObject.data;
    const availableCampaigns = isCobalt && cobaltStatus.success ? await DDBCampaigns/* default.getAvailableCampaigns */.Z.getAvailableCampaigns() : [];

    this.campaignFallback = false;

    availableCampaigns.forEach((campaign) => {
      const selected = campaign.id == campaignId;
      campaign.selected = selected;
    });

    const setupConfig = {
      "cobalt-cookie": cobalt,
      "available-campaigns": availableCampaigns,
      "campaign-id": campaignId,
      "beta-key": key,
    };

    const setupComplete = isCobalt;

    return {
      campaignId,
      cobalt: isCobalt,
      cobaltLocal,
      setupConfig,
      setupComplete,
      tier,
      patreonLinked: patreonUser && patreonUser != "",
      patreonUser,
      validKey,
    };
  }

  activateListeners(html) {
    super.activateListeners(html);
    html.find("#patreon-button").click(async (event) => {
      event.preventDefault();
      PatreonHelper/* default.linkToPatreon */.Z.linkToPatreon();
    });
    html.find("#campaign-button").click(async (event) => {
      event.preventDefault();
      const cookie = html.find("#cobalt-cookie-input");
      const cookieStatus = await DDBSetup.checkCobaltCookie(cookie[0].value);
      if (!cookieStatus.success) return;
      const campaigns = await DDBCampaigns/* default.refreshCampaigns */.Z.refreshCampaigns(cookie[0].value);
      const list = html.find("#campaign-select");
      let campaignList = `<option value="">Select campaign:</option>`;
      if (!campaigns || (Array.isArray(campaigns) && campaigns.length === 0)) {
        this.campaignFallback = true;
        const fallback = html.find("#ddb-campaign-fallback");
        list[0].classList.add("ddbimporter-none");
        fallback[0].classList.remove("ddbimporter-none");
        logger/* default.warn */.Z.warn("Unable to fetch campaigns", campaigns);
      } else {
        if (Array.isArray(campaigns) && campaigns.length > 0) {
          campaigns.forEach((campaign) => {
            campaignList += `<option value="${campaign.id}">${campaign.name} (${campaign.dmUsername}) - ${campaign.id}</option>\n`;
          });
        }

        list[0].innerHTML = campaignList;
      }

    });
    html.find("#check-cobalt-button").click(async (event) => {
      event.preventDefault();
      const cookie = html.find("#cobalt-cookie-input");
      if (cookie[0].value === undefined) throw new Error("undefined");
      const cobaltStatus = await (0,Secrets/* checkCobalt */.B)("", cookie[0].value);
      const button = html.find("#check-cobalt-button");
      if (cobaltStatus.success) {
        button[0].innerHTML = "Check Cobalt Cookie - Success!";
      } else {
        button[0].innerHTML = "Check Cobalt Cookie - Failure!";
      }
    });


  }

  // eslint-disable-next-line class-methods-use-this
  static async checkCobaltCookie(value) {
    const cookieStatus = await (0,Secrets/* checkCobalt */.B)("", value);
    if (value !== "" && !cookieStatus.success) {
      $('#munching-task-setup').text(`Your Cobalt Cookie is invalid, please check that you pasted the right information.`);
      $('#ddb-importer-settings').css("height", "auto");
      throw new Error(`Your Cobalt Cookie is invalid, please check that you pasted the right information.`);
    }
    return cookieStatus;
  }

  static async setCobaltCookie(value, local) {
    await DDBSetup.checkCobaltCookie(value);
    await (0,Secrets/* setCobalt */.hc)(value);
    await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie-local", local);
    const runCookieMigrate = local != game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie-local");
    if (runCookieMigrate && local) {
      (0,Secrets/* moveCobaltToLocal */.Nr)();
    } else if (runCookieMigrate && !local) {
      (0,Secrets/* moveCobaltToSettings */.pC)();
    }
  }

  /** @override */
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    const campaignSelect = formData['campaign-select'];
    const fallbackCampaign = formData['campaign-fallback'];
    const campaignId = this.campaignFallback && fallbackCampaign && fallbackCampaign !== ""
      ? (fallbackCampaign ?? "")
      : campaignSelect == 0
        ? ""
        : campaignSelect;
    const cobaltCookie = formData['cobalt-cookie'];
    const cobaltCookieLocal = formData['cobalt-cookie-local'];
    const currentKey = PatreonHelper/* default.getPatreonKey */.Z.getPatreonKey();

    if (currentKey !== formData['beta-key']) {
      await PatreonHelper/* default.setPatreonKey */.Z.setPatreonKey(formData['beta-key']);
      await PatreonHelper/* default.setPatreonTier */.Z.setPatreonTier();
    }

    await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "campaign-id", campaignId);
    await DDBSetup.setCobaltCookie(cobaltCookie, cobaltCookieLocal);

    const callMuncher = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "settings-call-muncher");

    if (callMuncher && cobaltCookie === "") {
      $('#munching-task-setup').text(`To use Muncher you need to set a Cobalt Cookie value!`);
      $('#ddb-importer-settings').css("height", "auto");
      throw new Error(`To use Muncher you need to set a Cobalt Cookie value!`);
    } else if (callMuncher) {
      game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "settings-call-muncher", false);
      new DDBMuncher/* default */.Z().render(true);
    }
  }
}

;// CONCATENATED MODULE: ./src/apps/DDBAdventureFlags.js



class DDBAdventureFlags extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = "DDB Adventure Imported Flags";
    options.template = "modules/ddb-importer/handlebars/flag-details.hbs";
    options.classes = ["ddb-importer-flags", "sheet"];
    options.width = 800;
    return options;
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    // console.warn(this);
    // console.warn(this.object);
    const item = this.object;

    let flags = {};

    const flagGroups = ["ddb", "ddbimporter", "monsterMunch", "ddb-importer"];
    const ignoredSubFlagGroups = ["ddbimporter.acEffects", "ddbimporter.autoAC"];

    function generateFlagLookup(flagData, flagName, flagGroupName) {
      logger/* default.debug */.Z.debug(`FlagName ${flagName}, flagGroupName ${flagGroupName}`, flagData);
      for (const flagKey in flagData) {
        logger/* default.debug */.Z.debug("flagkey", flagKey);
        const flagValue = (flagKey === "userData") ? flagData[flagKey]["userDisplayName"] : flagData[flagKey];
        const flagGroupSubName = `${flagGroupName}.${flagKey}`;
        if (typeof flagValue === "object" && !ignoredSubFlagGroups.includes(flagGroupName) && !Array.isArray(flagValue)) {
          logger/* default.info */.Z.info(`recursive generateFlag call for ${flagName}`);
          generateFlagLookup(flagValue, flagKey, flagGroupSubName);
        } else if (!ignoredSubFlagGroups.includes(flagGroupName) && !ignoredSubFlagGroups.includes(flagGroupSubName)) {
          if (!flags[flagGroupName]) flags[flagGroupName] = [];
          flags[flagGroupName].push({
            key: flagKey,
            value: Array.isArray(flagValue) ? JSON.stringify(flagValue) : flagValue,
          });
        }
      }
    };

    flagGroups.forEach((flagGroup) => {
      logger/* default.debug */.Z.debug(`Flag group ${flagGroup}`, item.flags);
      generateFlagLookup(item.flags[flagGroup], flagGroup, flagGroup);
    });

    const result = {
      name: item.name,
      flags,
      monster: {
        isMonster: this.object.type == "npc",
        flags: [
          {
            name: "keepItems",
            description: "Keep this monsters item configuration for Adventure Muncher",
            isChecked: item.flags?.ddbimporter?.keepItems ?? false,
          },
          {
            name: "keepToken",
            description: "Keep token? (The image needs to be manually set in the export data)",
            isChecked: item.flags?.ddbimporter?.keepToken ?? false,
          },
          {
            name: "keepAvatar",
            description: "Keep avatar?  (The image needs to be manually set in the export data)",
            isChecked: item.flags?.ddbimporter?.keepAvatar ?? false,
          },
        ]
      },
      item: {
        isItem: dictionary/* default.types.monster.includes */.Z.types.monster.includes(this.object.type) || this.object.type === "spell",
        flags: [
          {
            name: "customItem",
            description: "Keep this custom item",
            isChecked: item.flags?.ddbimporter?.customItem ?? false,
          }
        ]
      },
    };

    if (item.link) result["link"] = item.link;
    if (flags.bookCode && flags.slug) result["ddbLink"] = `https://www.dndbeyond.com/${flags.bookCode}/${flags.slug}`;

    logger/* default.debug */.Z.debug("flags", flags);
    return result;
  }


  activateListeners(html) {
    super.activateListeners(html);
    // watch the change of the import-policy-selector checkboxes
    $(html)
      .find(
        [
          '.flag-policy input[type="checkbox"]',
        ].join(",")
      )
      .on("change", async (event) => {
        const selection = event.currentTarget.dataset.section;
        const checked = event.currentTarget.checked;
        logger/* default.debug */.Z.debug(`Updating flag-policy for ${this.object.name}, ${selection} to ${checked}`);

        await this.object.update({
          flags: {
            "ddbimporter": {
              [selection]: checked
            }
          }
        });
      });
  }
}

;// CONCATENATED MODULE: ./src/hooks/ready/registerSheets.js





const API_ENDPOINT = "https://character-service.dndbeyond.com/character/v5/character/";
// reference to the D&D Beyond popup
const POPUPS = {
  json: null,
  web: null,
};
const renderPopup = (type, url) => {
  if (POPUPS[type] && !POPUPS[type].close) {
    POPUPS[type].focus();
    POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
};

function getCharacterButton(document, actor) {

  const characterLink = game.settings.get("ddb-importer", "character-link-title");
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";
  const buttonText = characterLink
    ? `<a class="ddb-open-url" title="DDB Importer"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`
    : '<button type="button" id="ddbImporterButton" class="inactive"><i class="fab fa-d-and-d-beyond"></button>';

  let url = foundry.utils.hasProperty(document, "flags.ddbimporter.dndbeyond.url")
    ? document.flags.ddbimporter.dndbeyond.url
    : null;

  let jsonURL = foundry.utils.hasProperty(document, "flags.ddbimporter.dndbeyond.json")
    ? document.flags.ddbimporter.dndbeyond.json
    : null;

  let button = $(buttonText);
  if (!characterLink && (!url || url.trim() === "")) button.removeClass("inactive");

  button.click((event) => {
    if (event.shiftKey && (event.ctrlKey || event.metaKey)) {
      new DDBAdventureFlags(document, {}).render(true);
    } else if (event.shiftKey) {
      event.preventDefault();
      return renderPopup("web", url);
    } else if (event.altKey && jsonURL) {
      event.preventDefault();
      return renderPopup("json", jsonURL);
    } else if (event.altKey && !jsonURL) {
      // get the character ID
      const characterId = url.split("/").pop();
      if (characterId) {
        event.preventDefault();
        return renderPopup("json", API_ENDPOINT + characterId);
      }
    } else if ((!event.shiftKey && !event.ctrlKey && !event.altKey) || url === null) {
      const setupComplete = DDBSetup.isSetupComplete(false);

      if (setupComplete) {
        const characterImport = new DDBCharacterManager(DDBCharacterManager.defaultOptions, actor);
        characterImport.render(true);
      } else {
        new DDBSetup().render(true);
      }

      return true;
    }

    return false;
  });

  return button;
}

function getNPCButton(document) {
  const monsterLink = game.settings.get("ddb-importer", "monster-link-title");
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";

  let url = document.flags.monsterMunch.url;

  let button = monsterLink
    ? $(`<a class="ddb-open-url" title="D&D Beyond"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`)
    : $('<button type="button" id="ddbImporterButton"><i class="fab fa-d-and-d-beyond"></button>');

  // eslint-disable-next-line no-unused-vars
  button.click((event) => {
    if (event.shiftKey && (event.ctrlKey || event.metaKey)) {
      new DDBAdventureFlags(document, {}).render(true);
    } else {
      logger/* default.debug */.Z.debug(`Clicked for url ${url}`);
      renderPopup("web", url);
    }
  });

  return button;
}

function tidySheets() {
  const api = game.modules.get('tidy5e-sheet-kgar')?.api ?? game.modules.get('tidy5e-sheet')?.api;
  if (!api) return;

  api.registerCharacterContent(
    new api.models.HtmlContent({
      html: `<div class="ddbCharacterName"></div>`,
      injectParams: {
        selector: `[data-tidy-sheet-part="name-header-row"]`,
        position: "afterbegin",
      },
      enabled: (data) => {
        const trustedUsersOnly = game.settings.get("ddb-importer", "restrict-to-trusted");
        const allowAllSync = game.settings.get("ddb-importer", "allow-all-sync");
        const titleLink = game.settings.get("ddb-importer", "character-link-title");
        const onlyTrustedUser = !allowAllSync && trustedUsersOnly && !game.user.isTrusted;
        return (data.owner || onlyTrustedUser) && !titleLink;
      },
      onRender: (params) => {
        const $ddbCharacterName = $(params.element).find(".ddbCharacterName");
        const button = getCharacterButton(params.app.document, params.data.actor);
        $ddbCharacterName.append(button);
      },
    })
  );

  // api.registerNpcContent(
  //   new api.models.HtmlContent({
  //     html: `<div class="ddbCharacterName"></div>`,
  //     injectParams: {
  //       selector: `[data-tidy-sheet-part="name-header-row"]`,
  //       position: "afterbegin",
  //     },
  //     enabled: (params) => {
  //       return foundry.utils.hasProperty(params, "app.document.flags.monsterMunch.url");
  //     },
  //     onRender: (params) => {
  //       const $ddbCharacterName = $(params.element).find(".ddbCharacterName");
  //       const button = getCharacterButton(params.app.document, params.data.actor);
  //       $ddbCharacterName.append(button);
  //     },
  //   })
  // );
}

/* harmony default export */ function registerSheets() {
  /**
   * Character sheets
   */
  const pcSheetNames = Object.values(CONFIG.Actor.sheetClasses.character)
    .map((sheetClass) => sheetClass.cls)
    .map((sheet) => sheet.name);

  const trustedUsersOnly = game.settings.get("ddb-importer", "restrict-to-trusted");
  const allowAllSync = game.settings.get("ddb-importer", "allow-all-sync");
  const characterLink = game.settings.get("ddb-importer", "character-link-title");
  const monsterLink = game.settings.get("ddb-importer", "monster-link-title");

  // const buttonText = characterLink
  //   ? `<a class="ddb-open-url" title="DDB Importer"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`
  //   : '<button type="button" id="ddbImporterButton" class="inactive"><i class="fab fa-d-and-d-beyond"></button>';

  tidySheets();
  pcSheetNames.forEach((sheetName) => {
    Hooks.on("render" + sheetName, (app, html, data) => {
      // only for GMs or the owner of this character
      if (!data.owner || !data.actor || (!allowAllSync && trustedUsersOnly && !game.user.isTrusted)) return;
      if ($(html).find("#ddbImporterButton").length > 0) return;

      const button = getCharacterButton(app.document, data.actor);

      if (characterLink) {
        html.closest('.app').find('.ddb-open-url').remove();
        let titleElement = html.closest('.app').find('.window-title');
        if (!app._minimized) button.insertAfter(titleElement);
      } else {
        let wrap = $('<div class="ddbCharacterName"></div>');
        $(html).find("input[name='name']").wrap(wrap);
        $(html).find("input[name='name']").parent().prepend(button);
      }
    });
  });


  /**
   * NPC sheets
   */
  const npcSheetNames = Object.values(CONFIG.Actor.sheetClasses.npc)
    .map((sheetClass) => sheetClass.cls)
    .map((sheet) => sheet.name);

  npcSheetNames.forEach((sheetName) => {
    Hooks.on("render" + sheetName, (app, html, data) => {
      // only for GMs or the owner of this npc
      if (!data.owner || !data.actor) return;
      if (!app.document.flags?.monsterMunch?.url) return;
      if ($(html).find("#ddbImporterButton").length > 0) return;

      let button = getNPCButton(app.document);

      if (monsterLink) {
        html.closest('.app').find('.ddb-open-url').remove();
        let titleElement = html.closest('.app').find('.window-title');
        if (!app._minimized) button.insertAfter(titleElement);
      } else {
        let wrap = $('<div class="ddbCharacterName"></div>');
        $(html).find("input[name='name']").wrap(wrap);
        $(html).find("input[name='name']").parent().prepend(button);
      }
    });
  });
}

// EXTERNAL MODULE: ./src/hooks/ready/checkCompendiums.js
var checkCompendiums = __webpack_require__(9187);
;// CONCATENATED MODULE: ./src/apps/DDBProxySetup.js




class DDBProxySetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-proxy";
    options.template = "modules/ddb-importer/handlebars/ddbProxySetup.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    return game.i18n.localize(`${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.DDBProxy.AppTitle`);
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const useCustomProxy = DDBProxy/* default.isCustom */.Z.isCustom();
    const defaultAddress = src_settings/* default.URLS.PROXY */.Z.URLS.PROXY;
    const proxyAddress = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "api-endpoint");

    return {
      useCustomProxy,
      proxyAddress,
      defaultAddress,
    };
  }

  /** @override */
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();

    const useCustomProxy = formData['custom-proxy'];
    const proxyAddress = formData['api-endpoint'];

    await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "custom-proxy", useCustomProxy);
    await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "api-endpoint", proxyAddress);
  }
}

;// CONCATENATED MODULE: ./src/apps/DDBDynamicUpdateSetup.js




class DDBDynamicUpdateSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-settings-dynamic-updates";
    options.template = "modules/ddb-importer/handlebars/dynamic-updates.hbs";
    options.width = 500;
    return options;
  }

  static getGMUsers() {
    const updateUser = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-user");

    const gmUsers = game.users
      .filter((user) => user.isGM)
      .reduce((choices, user) => {
        choices.push({
          userId: user.id,
          userName: user.name,
          selected: user.id === updateUser,
        });
        return choices;
      }, []);

    return gmUsers;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Dynamic Update Settings";
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const tier = PatreonHelper/* default.getPatreonTier */.Z.getPatreonTier();
    const tiers = PatreonHelper/* default.calculateAccessMatrix */.Z.calculateAccessMatrix(tier);
    const enabled = tiers.experimentalMid;

    const policySettings = Object.keys(src_settings/* default.DEFAULT_SETTINGS.READY.CHARACTER.DYNAMIC_SYNC */.Z.DEFAULT_SETTINGS.READY.CHARACTER.DYNAMIC_SYNC)
      .map((key) => {
        return {
          name: key,
          isChecked: enabled && game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, key),
          description: game.i18n.localize(`${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.dynamic-sync.${key}`),
          enabled,
        };
      });
    const settings = [
      {
        name: "dynamic-sync",
        isChecked: enabled && game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync"),
        description: game.i18n.localize(`${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.dynamic-sync.dynamic-sync`),
        enabled,
      },
    ].concat(policySettings);
    const gmUsers = DDBDynamicUpdateSetup.getGMUsers();

    return {
      settings,
      gmUsers,
    };
  }

  /** @override */
  // eslint-disable-next-line class-methods-use-this
  async _updateObject(event, formData) {
    event.preventDefault();
    const initial = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync");
    for (const [key, value] of Object.entries(formData)) {
      await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, key, value);
    }
    const post = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync");

    if (initial != post) {
      logger/* default.warn */.Z.warn("RELOADING!");
      foundry.utils.debounce(window.location.reload(), 100);
    }
  }
}

;// CONCATENATED MODULE: ./src/apps/DDBCompendiumSetup.js


class DDBCompendiumSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-settings-compendium";
    options.template = "modules/ddb-importer/handlebars/compendium.hbs";
    options.width = 500;
    return options;
  }

  static getCompendiumLookups(type, selected) {
    const excludedCompendiumPackages = [
      "dnd5e",
      "dae",
      "midiqol",
      "magicitems",
      "midi-srd",
      "dae-srd",
      "midi-qol",
      "magic-items-2",
      "chris-premades",
      "ATL",
      "ActiveAuras",
      "token-attacher",
    ];

    const selections = game.packs
      .filter((pack) =>
        pack.documentName === type
      && !excludedCompendiumPackages.includes(pack.metadata.packageName)
      )
      .reduce((choices, pack) => {
        choices[pack.collection] = {
          label: `[${pack.metadata.packageName}] ${pack.metadata.label}`,
          selected: pack.collection === selected,
        };
        return choices;
      }, {});

    return selections;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Compendium Settings";
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    const settings = [
      {
        name: "auto-create-compendium",
        isChecked: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "auto-create-compendium"),
        description: "Create default compendiums if missing?",
        enabled: true,
      },
    ];

    const compendiums = src_settings/* default.COMPENDIUMS.map */.Z.COMPENDIUMS.map((comp) => ({
      setting: comp.setting,
      name: comp.title,
      current: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, comp.setting),
      compendiums: DDBCompendiumSetup.getCompendiumLookups(comp.type, game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, comp.setting)),
      auto: comp.auto,
    }));

    return {
      settings,
      compendiums,
    };
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();
    for (const [key, value] of Object.entries(formData)) {
      game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, key, value);
    }
  }
}

;// CONCATENATED MODULE: ./src/apps/DDBLocationSetup.js





class DDBLocationSetup extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "ddb-importer-folders";
    options.template = "modules/ddb-importer/handlebars/filePaths.hbs";
    options.width = 500;
    return options;
  }

  get title() { // eslint-disable-line class-methods-use-this
    // improve localisation
    // game.i18n.localize("")
    return "DDB Importer Location Settings";
  }

  // in foundry v10 we no longer get read only form elements back
  /** @override */
  _getSubmitData(updateData = {}) {
    let data = super._getSubmitData(updateData);

    for (const element of this.form.elements) {
      if (element.readOnly) {
        const name = element.name;
        const field = this.form.elements[name];
        foundry.utils.setProperty(data, name, field.value);
      }
    }

    return data;
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    this.useWebP = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "use-webp");
    this.useDeepFilePaths = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "use-deep-file-paths");
    const directories = [];

    for (const [key, value] of Object.entries(src_settings/* default.DEFAULT_SETTINGS.READY.DIRECTORIES */.Z.DEFAULT_SETTINGS.READY.DIRECTORIES)) {
      directories.push({
        key,
        value: game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, key),
        name: game.i18n.localize(value.name),
        description: game.i18n.localize(value.hint),
      });
    }

    return {
      directories,
      useWebP: this.useWebP,
      useDeepFilePaths: this.useDeepFilePaths,
    };
  }

  /** @override */
  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();

    const useWebP = formData['image-use-webp'];
    const useDeepFilePaths = formData['image-use-deep-file-paths'];

    if (this.useWebP !== useWebP) await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "use-webp", useWebP);
    if (this.useDeepFilePaths !== useDeepFilePaths) {
      await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "use-deep-file-paths", useDeepFilePaths);
    }

    const directoryStatus = [];

    for (const key of Object.keys(src_settings/* default.DEFAULT_SETTINGS.READY.DIRECTORIES */.Z.DEFAULT_SETTINGS.READY.DIRECTORIES)) {
      const value = formData[key];
      await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, key, value);
      directoryStatus.push({
        key,
        value,
        isBad: FileHelper/* default.BAD_DIRS.includes */.Z.BAD_DIRS.includes(value),
        isValid: await DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(value)),
      });
    }

    if (directoryStatus.some((dir) => dir.isBad)) {
      $('#munching-folder-setup').text(`Please set the image upload directory(s) to something other than the root.`);
      $('#ddb-importer-folders').css("height", "auto");
      logger/* default.error */.Z.error("Error setting Image directory", {
        directoryStatus,
      });
      throw new Error(`Please set the image upload directory to something other than the root.`);
    } else if (directoryStatus.some((dir) => !dir.isValid)) {
      $('#munching-folder-setup').text(`Directory Validation Failed.`);
      $('#ddb-importer-folders').css("height", "auto");
      logger/* default.error */.Z.error("Error validating Image directory", {
        directoryStatus,
      });
      throw new Error(`Directory Validation Failed.`);
    }
  }
}

// eslint-disable-next-line no-unused-vars
Hooks.on("renderDDBLocationSetup", (app, html, user) => {
  DirectoryPicker/* DirectoryPicker.processHtml */.B.processHtml(html);
});

;// CONCATENATED MODULE: ./src/hooks/ready/registerGameSettings.js










foundry.utils.setProperty(CONFIG, "DDBI", {
  module: "DDB Importer",
  schemaVersion: 5.0,
  DICTIONARY: dictionary/* default */.Z,
  ADVENTURE: {},
  MACROS: {
    spell: {},
    gm: {},
    item: {},
    feat: {},
  },
  KNOWN: {
    CHECKED_DIRS: new Set(),
    FILES: new Set(),
    DIRS: new Set(),
    LOOKUPS: new Map(),
    TOKEN_LOOKUPS: new Map(),
    AVATAR_LOOKUPS: new Map(),
    FORGE: {
      TARGET_URL_PREFIX: {},
      TARGETS: {},
    },
  },
  ICONS: {},
  TABLES: {},
  SRD_LOAD: {
    mapLoaded: false,
    iconMap: {},
    packsLoaded: {},
    packs: {},
  },
  DEV: {
    enabled: false,
    clippy: {},
    tableInUse: false,
  },
  EFFECT_CONFIG: {
    MODULES: {
      installedModules: null,
      configured: false,
    },
  },
  POPUPS: {
    json: null,
    web: null,
  },
});

async function resetSettings() {
  for (const [name, data] of Object.entries(src_settings/* default.GET_DEFAULT_SETTINGS */.Z.GET_DEFAULT_SETTINGS())) {
    await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, name, data.default);
  }
  for (const [name, data] of Object.entries(src_settings/* default.GET_DEFAULT_SETTINGS */.Z.GET_DEFAULT_SETTINGS(true))) {
    await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, name, data.default);
  }
  window.location.reload();
}

class ResetSettingsDialog extends FormApplication {
  constructor(...args) {
    super(...args);
    // eslint-disable-next-line no-constructor-return
    return new Dialog({
      title: game.i18n.localize(`${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Title`),
      content: `<p class="${src_settings/* default.MODULE_ID */.Z.MODULE_ID}-dialog-important">${game.i18n.localize(
        `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Content`
      )}</p>`,
      buttons: {
        confirm: {
          icon: '<i class="fas fa-check"></i>',
          label: game.i18n.localize(`${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Confirm`),
          callback: () => {
            resetSettings();
          },
        },
        cancel: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize(`${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Cancel`),
        },
      },
      default: "cancel",
    });
  }
}

async function createFolderPaths() {
  if (game.user.isGM) {
    const characterUploads = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "image-upload-directory");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(characterUploads));

    const otherUploads = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "other-image-upload-directory");
    if (!(await FileHelper/* default.doesDirExist */.Z.doesDirExist(otherUploads))) {
      await game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "use-deep-file-paths", true);
    }
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(otherUploads));


    const frameUploads = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "frame-image-upload-directory");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(frameUploads));

    const adventureUploads = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-upload-path");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(adventureUploads));

    const iconUploads = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "adventure-misc-path");
    DirectoryPicker/* DirectoryPicker.verifyPath */.B.verifyPath(DirectoryPicker/* DirectoryPicker.parse */.B.parse(iconUploads));
  }
}

/* harmony default export */ async function registerGameSettings() {

  game.settings.registerMenu(src_settings/* default.MODULE_ID */.Z.MODULE_ID, 'setupMenu', {
    name: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.setup.name`,
    label: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.setup.name`,
    hint: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.setup.hint`,
    icon: 'fas fa-wrench',
    type: DDBSetup,
    restricted: true
  });

  game.settings.registerMenu(src_settings/* default.MODULE_ID */.Z.MODULE_ID, 'compendiumMenu', {
    name: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.compendium-setup.name`,
    label: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.compendium-setup.name`,
    hint: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.compendium-setup.hint`,
    icon: 'fas fa-wrench',
    type: DDBCompendiumSetup,
    restricted: true
  });

  game.settings.registerMenu(src_settings/* default.MODULE_ID */.Z.MODULE_ID, 'folderMenu', {
    name: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.folder-setup.name`,
    label: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.folder-setup.name`,
    hint: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.folder-setup.hint`,
    icon: 'fas fa-wrench',
    type: DDBLocationSetup,
    restricted: true
  });

  game.settings.registerMenu(src_settings/* default.MODULE_ID */.Z.MODULE_ID, 'dynamicUpdateMenu', {
    name: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.dynamic-update-setup.name`,
    label: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.dynamic-update-setup.name`,
    hint: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.settings.dynamic-update-setup.hint`,
    icon: 'fas fa-wrench',
    type: DDBDynamicUpdateSetup,
    restricted: true,
  });

  for (const [name, data] of Object.entries(src_settings/* default.GET_DEFAULT_SETTINGS */.Z.GET_DEFAULT_SETTINGS())) {
    game.settings.register(src_settings/* default.MODULE_ID */.Z.MODULE_ID, name, data);
  }

  // SETTING TWEAKS AND MIGRATIONS
  await createFolderPaths();

  if (game.user.isGM && game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie-local")
    && game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie") != "") {
    game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "cobalt-cookie-local", false);
  }

  if (game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-user") === "" && game.user.isGM) {
    game.settings.set(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "dynamic-sync-user", game.user.id);
  }

  // reset settings
  game.settings.registerMenu(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "resetToDefaults", {
    name: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Title`,
    label: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Label`,
    hint: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.ResetSettings.Hint`,
    icon: "fas fa-refresh",
    type: ResetSettingsDialog,
    restricted: true,
  });

  // reset settings
  game.settings.registerMenu(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "ddbProxy", {
    name: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.DDBProxy.Title`,
    label: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.DDBProxy.Label`,
    hint: `${src_settings/* default.MODULE_ID */.Z.MODULE_ID}.Dialogs.DDBProxy.Hint`,
    icon: "fas fa-ethernet",
    type: DDBProxySetup,
    restricted: true,
  });


  if (game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "developer-mode")) {
    CONFIG.DDBI.DEV.enabled = true;
  }

}

;// CONCATENATED MODULE: ./src/apps/DDBItemConfig.js


class DDBItemConfig extends FormApplication {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.title = "DDB Owned Item Config";
    options.template = "modules/ddb-importer/handlebars/item-config.hbs";
    options.classes = ["ddbimporter", "sheet"];
    options.width = 500;
    return options;
  }

  /** @override */
  async getData() { // eslint-disable-line class-methods-use-this
    // console.warn(this);
    // console.warn(this.object);
    let item = this.object;

    const icon = item.flags.ddbimporter?.ignoreIcon;
    const itemImport = item.flags.ddbimporter?.ignoreItemImport;
    const resource = item.flags.ddbimporter?.retainResourceConsumption;
    const chris = item.flags.ddbimporter?.ignoreItemForChrisPremades;
    const ignoreItemUpdate = item.flags.ddbimporter?.ignoreItemUpdate;
    const overrideId = item.flags.ddbimporter?.overrideId;

    const settings = [
      {
        name: "ignoreItemImport",
        isChecked: itemImport,
        description: "Ignore this item when importing the character (implies all other settings here).",
      },
      {
        name: "ignoreItemUpdate",
        isChecked: ignoreItemUpdate,
        description: "Ignore this item when when updating the character back to DDB?",
      },
      {
        name: "ignoreItemForChrisPremades",
        isChecked: chris,
        description: "Ignore this item when replacing Active Effects with those from Chris's Premades module.",
      },
      {
        name: "ignoreIcon",
        isChecked: icon,
        description: "Ignore icon updates.",
      },
      {
        name: "retainResourceConsumption",
        isChecked: resource,
        description: "Retain Resource Consumption linking.",
      },
    ];

    const overrides = {
      "NONE": {
        label: `None`,
        selected: true
      }
    };

    const label = CompendiumHelper/* default.getCompendiumLabel */.Z.getCompendiumLabel("custom");
    const compendium = CompendiumHelper/* default.getCompendium */.Z.getCompendium(label);
    const index = await compendium.getIndex();

    index.forEach((item) => {
      overrides[item._id] = {
        label: `${item.name} (${item.type})`,
        selected: false,
      };
    });

    const selectedOverrideId = overrideId ?? "NONE";
    if (overrideId && overrides[selectedOverrideId]) {
      overrides[selectedOverrideId].selected = true;
    }

    const result = {
      name: item.name,
      img: item.img,
      character: this.object.actor.name,
      settings,
      overrides,
    };

    return result;
  }

  get id() {
    const actor = this.object;
    let id = `ddb-actor-${actor.id}`;
    return id;
  }

  /** @override */
  // eslint-disable-next-line no-unused-vars
  async _updateObject(event, formData) {
    event.preventDefault();

    let item = {
      _id: this.object._id,
      flags: this.object.flags,
    };

    if (!item.flags.ddbimporter) item.flags.ddbimporter = {};
    item.flags.ddbimporter['overrideId'] = formData['override'];
    item.flags.ddbimporter['ignoreIcon'] = formData['ignoreIcon'];
    item.flags.ddbimporter['ignoreItemImport'] = formData['ignoreItemImport'];
    item.flags.ddbimporter['ignoreItemForChrisPremades'] = formData['ignoreItemForChrisPremades'];
    item.flags.ddbimporter['retainResourceConsumption'] = formData['retainResourceConsumption'];
    item.flags.ddbimporter['ignoreItemUpdate'] = formData['ignoreItemUpdate'];

    this.object.actor.updateEmbeddedDocuments("Item", [item]);

  }
}

;// CONCATENATED MODULE: ./src/hooks/ready/items.js



function initItemSheetHook(app, html) {
  if (!app.document.isOwned) return;
  // console.error(app.entity);
  // console.log(data);
  const title = `DDB Importer Item Config`;
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";
  let button = $(`<a class="open-item-ddb-importer" title="${title}"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
  button.click((event) => {
    if (event.shiftKey && (event.ctrlKey || event.metaKey)) {
      new DDBAdventureFlags(app.document, {}).render(true);
    } else {
      new DDBItemConfig(app.document, {}).render(true);
    }
  });
  html.closest('.app').find('.open-item-ddb-importer').remove();
  let titleElement = html.closest('.app').find('.window-title');
  button.insertAfter(titleElement);
}

function itemSheets() {
  Hooks.on('renderItemSheet', initItemSheetHook);
}


;// CONCATENATED MODULE: ./src/hooks/ready/checkVersion.js



const MODULE_TITLE = "DDB Importer";
const MODULE_NAME = "ddb-importer";
const MODULE_AUTHOR = "MrPrimate";
const _GITHUB_API_LATEST = `https://api.github.com/repos/${MODULE_AUTHOR}/${MODULE_NAME}/releases/latest`;
const _GITHUB_MODULE_JSON_LATEST = `https://raw.githubusercontent.com/${MODULE_AUTHOR}/${MODULE_NAME}/master/module-template.json`;
const MINIMUM_5E_VERSION = "3.0.0";
const PREVIOUS_VERSION = "3.7.17";

// eslint-disable-next-line consistent-return
async function getLatestModuleVersion() {
  try {
    const { tag_name: latestVersion, prerelease } = await $.getJSON(_GITHUB_API_LATEST);
    return { latestVersion, prerelease };
  } catch (error) {
    logger/* default.error */.Z.error(error);
  }
}

// eslint-disable-next-line consistent-return
async function getCompatibility() {
  try {
    const { compatibility, relationships } = await $.getJSON(_GITHUB_MODULE_JSON_LATEST);
    return { minimumCoreVersion: compatibility.minimum, minimumSystemVersion: relationships.systems[0].compatibility.minimum };
  } catch (error) {
    logger/* default.error */.Z.error(error);
  }
}

/* harmony default export */ const checkVersion = (async () => {
  const moduleInfo = game.modules.get(MODULE_NAME);
  const installedVersion = moduleInfo.version;
  foundry.utils.setProperty(CONFIG, "DDBI.version", installedVersion);
  try {
    if (!game.user.isGM) return;
    const compatibleMinimumSystem = utils/* default.versionCompare */.Z.versionCompare(game.data.system.version, MINIMUM_5E_VERSION) >= 0;

    if (!compatibleMinimumSystem) {
      ui.notifications.error(`${MODULE_TITLE} requires 5e system v${MINIMUM_5E_VERSION} to run correctly. Please update your 5e version, or roll DDB Importer back to version ${PREVIOUS_VERSION}.`, { permanent: true });
      return;
    }

    // check version number only for GMs
    const coreCheck = game.settings.get("ddb-importer", "update-check");
    if (!coreCheck) return;
    const { minimumCoreVersion, minimumSystemVersion } = await getCompatibility();
    const { latestVersion, prerelease: preRelease } = await getLatestModuleVersion();

    const newModuleVersion = utils/* default.versionCompare */.Z.versionCompare(latestVersion, installedVersion) === 1;
    const compatibleSystem = utils/* default.versionCompare */.Z.versionCompare(game.version, minimumSystemVersion) >= 0;
    const compatibleMinimumCore = utils/* default.versionCompare */.Z.versionCompare(game.version, minimumCoreVersion) >= 0;

    const needToUpdate = newModuleVersion && compatibleSystem && compatibleMinimumCore;

    logger/* default.debug */.Z.debug("Module Update data", {
      newModuleVersion,
      compatibleSystem,
      compatibleMinimumCore,
      needToUpdate,
      minimumCoreVersion,
      minimumSystemVersion
    });

    if (preRelease) logger/* default.debug */.Z.debug(`Prerelease of ${MODULE_TITLE} detected`);

    if (needToUpdate) {
      let text = $(
        `<h2>${MODULE_TITLE} Update!</h2><p>A new <b>${MODULE_NAME}</b> version is available. Please update to <b>v${latestVersion}</b> if you are experiencing issues and before reporting a bug.</p>`
      );
      game.modules.get("ddb-importer").api?.notification.show(text, null);
    }
  } catch (error) {
    logger/* default.warn */.Z.warn(error);
    game.modules.get("ddb-importer").api?.notification.show(`Could not retrieve latest ${MODULE_NAME} version`);
  }
});

;// CONCATENATED MODULE: ./src/hooks/ready/fallbackConfig.js
const fallbackDDBConfig = {
  armor: [
    {
      id: 3,
      entityTypeId: 701257905,
      name: "Studded Leather",
      categoryId: 1,
    },
    {
      id: 6,
      entityTypeId: 701257905,
      name: "Scale Mail",
      categoryId: 2,
    },
    {
      id: 8,
      entityTypeId: 701257905,
      name: "Shield",
      categoryId: 4,
    },
    {
      id: 9,
      entityTypeId: 701257905,
      name: "Padded",
      categoryId: 1,
    },
    {
      id: 10,
      entityTypeId: 701257905,
      name: "Leather",
      categoryId: 1,
    },
    {
      id: 11,
      entityTypeId: 701257905,
      name: "Hide",
      categoryId: 2,
    },
    {
      id: 12,
      entityTypeId: 701257905,
      name: "Chain Shirt",
      categoryId: 2,
    },
    {
      id: 13,
      entityTypeId: 701257905,
      name: "Breastplate",
      categoryId: 2,
    },
    {
      id: 14,
      entityTypeId: 701257905,
      name: "Half Plate",
      categoryId: 2,
    },
    {
      id: 15,
      entityTypeId: 701257905,
      name: "Ring Mail",
      categoryId: 3,
    },
    {
      id: 16,
      entityTypeId: 701257905,
      name: "Chain Mail",
      categoryId: 3,
    },
    {
      id: 17,
      entityTypeId: 701257905,
      name: "Splint",
      categoryId: 3,
    },
    {
      id: 18,
      entityTypeId: 701257905,
      name: "Plate",
      categoryId: 3,
    },
    {
      id: 19,
      entityTypeId: 701257905,
      name: "Spiked Armor",
      categoryId: 2,
    },
    {
      id: 20,
      entityTypeId: 701257905,
      name: "Pride Silk Outfit",
      categoryId: 1,
    },
  ],
  tools: [
    {
      id: 102,
      name: "Alchemist's Supplies",
    },
    {
      id: 103,
      name: "Brewer's Supplies",
    },
    {
      id: 104,
      name: "Calligrapher's Supplies",
    },
    {
      id: 105,
      name: "Carpenter's Tools",
    },
    {
      id: 106,
      name: "Cartographer's Tools",
    },
    {
      id: 107,
      name: "Cobbler's Tools",
    },
    {
      id: 108,
      name: "Cook's Utensils",
    },
    {
      id: 109,
      name: "Glassblower's Tools",
    },
    {
      id: 110,
      name: "Jeweler's Tools",
    },
    {
      id: 111,
      name: "Leatherworker's Tools",
    },
    {
      id: 112,
      name: "Mason's Tools",
    },
    {
      id: 113,
      name: "Painter's Supplies",
    },
    {
      id: 114,
      name: "Potter's Tools",
    },
    {
      id: 115,
      name: "Smith's Tools",
    },
    {
      id: 116,
      name: "Tinker's Tools",
    },
    {
      id: 117,
      name: "Weaver's Tools",
    },
    {
      id: 118,
      name: "Woodcarver's Tools",
    },
    {
      id: 119,
      name: "Disguise Kit",
    },
    {
      id: 120,
      name: "Forgery Kit",
    },
    {
      id: 121,
      name: "Dice Set",
    },
    {
      id: 122,
      name: "Playing Card Set",
    },
    {
      id: 123,
      name: "Herbalism Kit",
    },
    {
      id: 124,
      name: "Navigator's Tools",
    },
    {
      id: 125,
      name: "Poisoner's Kit",
    },
    {
      id: 126,
      name: "Thieves' Tools",
    },
    {
      id: 127,
      name: "Bagpipes",
    },
    {
      id: 128,
      name: "Drum",
    },
    {
      id: 129,
      name: "Dulcimer",
    },
    {
      id: 130,
      name: "Flute",
    },
    {
      id: 131,
      name: "Lute",
    },
    {
      id: 132,
      name: "Horn",
    },
    {
      id: 133,
      name: "Pan Flute",
    },
    {
      id: 134,
      name: "Shawm",
    },
    {
      id: 135,
      name: "Lyre",
    },
    {
      id: 136,
      name: "Viol",
    },
    {
      id: 189,
      name: "Three-Dragon Ante Set",
    },
    {
      id: 190,
      name: "Dragonchess Set",
    },
    {
      id: 232,
      name: "Birdpipes",
    },
    {
      id: 233,
      name: "Glaur",
    },
    {
      id: 234,
      name: "Hand Drum",
    },
    {
      id: 235,
      name: "Longhorn",
    },
    {
      id: 236,
      name: "Songhorn",
    },
    {
      id: 237,
      name: "Tantan",
    },
    {
      id: 238,
      name: "Thelarr",
    },
    {
      id: 239,
      name: "Tocken",
    },
    {
      id: 240,
      name: "Wargong",
    },
    {
      id: 241,
      name: "Yarting",
    },
    {
      id: 242,
      name: "Zulkoon",
    },
    {
      id: 301,
      name: "Whistle-Stick",
    },
  ],
  weapons: [
    {
      id: 1,
      entityTypeId: 1782728300,
      name: "Crossbow, Hand",
      categoryId: 2,
    },
    {
      id: 2,
      entityTypeId: 1782728300,
      name: "Glaive",
      categoryId: 2,
    },
    {
      id: 3,
      entityTypeId: 1782728300,
      name: "Dagger",
      categoryId: 1,
    },
    {
      id: 4,
      entityTypeId: 1782728300,
      name: "Longsword",
      categoryId: 2,
    },
    {
      id: 5,
      entityTypeId: 1782728300,
      name: "Club",
      categoryId: 1,
    },
    {
      id: 6,
      entityTypeId: 1782728300,
      name: "Greatclub",
      categoryId: 1,
    },
    {
      id: 7,
      entityTypeId: 1782728300,
      name: "Handaxe",
      categoryId: 1,
    },
    {
      id: 8,
      entityTypeId: 1782728300,
      name: "Javelin",
      categoryId: 1,
    },
    {
      id: 10,
      entityTypeId: 1782728300,
      name: "Light Hammer",
      categoryId: 1,
    },
    {
      id: 11,
      entityTypeId: 1782728300,
      name: "Mace",
      categoryId: 1,
    },
    {
      id: 12,
      entityTypeId: 1782728300,
      name: "Quarterstaff",
      categoryId: 1,
    },
    {
      id: 13,
      entityTypeId: 1782728300,
      name: "Sickle",
      categoryId: 1,
    },
    {
      id: 14,
      entityTypeId: 1782728300,
      name: "Spear",
      categoryId: 1,
    },
    {
      id: 15,
      entityTypeId: 1782728300,
      name: "Crossbow, Light",
      categoryId: 1,
    },
    {
      id: 16,
      entityTypeId: 1782728300,
      name: "Dart",
      categoryId: 1,
    },
    {
      id: 17,
      entityTypeId: 1782728300,
      name: "Shortbow",
      categoryId: 1,
    },
    {
      id: 18,
      entityTypeId: 1782728300,
      name: "Sling",
      categoryId: 1,
    },
    {
      id: 19,
      entityTypeId: 1782728300,
      name: "Battleaxe",
      categoryId: 2,
    },
    {
      id: 20,
      entityTypeId: 1782728300,
      name: "Flail",
      categoryId: 2,
    },
    {
      id: 21,
      entityTypeId: 1782728300,
      name: "Greataxe",
      categoryId: 2,
    },
    {
      id: 22,
      entityTypeId: 1782728300,
      name: "Greatsword",
      categoryId: 2,
    },
    {
      id: 23,
      entityTypeId: 1782728300,
      name: "Halberd",
      categoryId: 2,
    },
    {
      id: 24,
      entityTypeId: 1782728300,
      name: "Lance",
      categoryId: 2,
    },
    {
      id: 25,
      entityTypeId: 1782728300,
      name: "Maul",
      categoryId: 2,
    },
    {
      id: 26,
      entityTypeId: 1782728300,
      name: "Morningstar",
      categoryId: 2,
    },
    {
      id: 27,
      entityTypeId: 1782728300,
      name: "Pike",
      categoryId: 2,
    },
    {
      id: 28,
      entityTypeId: 1782728300,
      name: "Rapier",
      categoryId: 2,
    },
    {
      id: 29,
      entityTypeId: 1782728300,
      name: "Scimitar",
      categoryId: 2,
    },
    {
      id: 30,
      entityTypeId: 1782728300,
      name: "Shortsword",
      categoryId: 2,
    },
    {
      id: 31,
      entityTypeId: 1782728300,
      name: "Trident",
      categoryId: 2,
    },
    {
      id: 32,
      entityTypeId: 1782728300,
      name: "War Pick",
      categoryId: 2,
    },
    {
      id: 33,
      entityTypeId: 1782728300,
      name: "Warhammer",
      categoryId: 2,
    },
    {
      id: 34,
      entityTypeId: 1782728300,
      name: "Whip",
      categoryId: 2,
    },
    {
      id: 35,
      entityTypeId: 1782728300,
      name: "Blowgun",
      categoryId: 2,
    },
    {
      id: 36,
      entityTypeId: 1782728300,
      name: "Crossbow, Heavy",
      categoryId: 2,
    },
    {
      id: 37,
      entityTypeId: 1782728300,
      name: "Longbow",
      categoryId: 2,
    },
    {
      id: 38,
      entityTypeId: 1782728300,
      name: "Net",
      categoryId: 2,
    },
    {
      id: 40,
      entityTypeId: 1782728300,
      name: "Boomerang",
      categoryId: 1,
    },
    {
      id: 41,
      entityTypeId: 1782728300,
      name: "Yklwa",
      categoryId: 1,
    },
    {
      id: 42,
      entityTypeId: 1782728300,
      name: "Pistol",
      categoryId: 3,
    },
    {
      id: 43,
      entityTypeId: 1782728300,
      name: "Musket",
      categoryId: 3,
    },
    {
      id: 44,
      entityTypeId: 1782728300,
      name: "Pistol, Automatic",
      categoryId: 3,
    },
    {
      id: 45,
      entityTypeId: 1782728300,
      name: "Revolver",
      categoryId: 3,
    },
    {
      id: 46,
      entityTypeId: 1782728300,
      name: "Rifle, Hunting",
      categoryId: 3,
    },
    {
      id: 47,
      entityTypeId: 1782728300,
      name: "Rifle, Automatic",
      categoryId: 3,
    },
    {
      id: 48,
      entityTypeId: 1782728300,
      name: "Shotgun",
      categoryId: 3,
    },
    {
      id: 49,
      entityTypeId: 1782728300,
      name: "Laser Pistol",
      categoryId: 3,
    },
    {
      id: 50,
      entityTypeId: 1782728300,
      name: "Antimatter Rifle",
      categoryId: 3,
    },
    {
      id: 51,
      entityTypeId: 1782728300,
      name: "Laser Rifle",
      categoryId: 3,
    },
    {
      id: 52,
      entityTypeId: 1782728300,
      name: "Palm Pistol (Exandria)",
      categoryId: 3,
    },
    {
      id: 53,
      entityTypeId: 1782728300,
      name: "Pepperbox (Exandria)",
      categoryId: 3,
    },
    {
      id: 54,
      entityTypeId: 1782728300,
      name: "Pistol (Exandria)",
      categoryId: 3,
    },
    {
      id: 55,
      entityTypeId: 1782728300,
      name: "Blunderbuss (Exandria)",
      categoryId: 3,
    },
    {
      id: 56,
      entityTypeId: 1782728300,
      name: "Bad News (Exandria)",
      categoryId: 3,
    },
    {
      id: 57,
      entityTypeId: 1782728300,
      name: "Hand Mortar (Exandria)",
      categoryId: 3,
    },
    {
      id: 58,
      entityTypeId: 1782728300,
      name: "Musket (Exandria)",
      categoryId: 3,
    },
    {
      id: 59,
      entityTypeId: 1782728300,
      name: "Double-Bladed Scimitar",
      categoryId: 2,
    },
  ],
  languages: [
    { id: 1, name: "Common" },
    { id: 2, name: "Dwarvish" },
    { id: 3, name: "Elvish" },
    { id: 4, name: "Giant" },
    { id: 5, name: "Gnomish" },
    { id: 6, name: "Goblin" },
    { id: 7, name: "Halfling" },
    { id: 8, name: "Orc" },
    { id: 9, name: "Abyssal" },
    { id: 10, name: "Celestial" },
    { id: 11, name: "Draconic" },
    { id: 12, name: "Deep Speech" },
    { id: 13, name: "Infernal" },
    { id: 14, name: "Primordial" },
    { id: 15, name: "Sylvan" },
    { id: 16, name: "Undercommon" },
    { id: 18, name: "Telepathy" },
    { id: 19, name: "Aquan" },
    { id: 20, name: "Auran" },
    { id: 21, name: "Ignan" },
    { id: 22, name: "Terran" },
    { id: 23, name: "Druidic" },
    { id: 24, name: "Giant Eagle" },
    { id: 25, name: "Giant Elk" },
    { id: 26, name: "Giant Owl" },
    { id: 27, name: "Gnoll" },
    { id: 28, name: "Otyugh" },
    { id: 29, name: "Sahuagin" },
    { id: 30, name: "Sphinx" },
    { id: 31, name: "Winter Wolf" },
    { id: 32, name: "Worg" },
    { id: 33, name: "Blink Dog" },
    { id: 34, name: "Yeti" },
    { id: 35, name: "All" },
    { id: 36, name: "Aarakocra" },
    { id: 37, name: "Slaad" },
    { id: 38, name: "Bullywug" },
    { id: 39, name: "Gith" },
    { id: 40, name: "Grell" },
    { id: 41, name: "Hook Horror" },
    { id: 42, name: "Modron" },
    { id: 43, name: "Thri-kreen" },
    { id: 44, name: "Troglodyte" },
    { id: 45, name: "Umber Hulk" },
    { id: 46, name: "Thieves' Cant" },
    { id: 47, name: "Grung" },
    { id: 48, name: "Tlincalli" },
    { id: 49, name: "Vegepygmy" },
    { id: 50, name: "Yikaria" },
    { id: 51, name: "Bothii" },
    { id: 52, name: "Ixitxachitl" },
    { id: 53, name: "Thayan" },
    { id: 54, name: "Netherese" },
    { id: 55, name: "Ice Toad" },
    { id: 56, name: "Olman" },
    { id: 57, name: "Quori" },
    { id: 58, name: "Minotaur" },
    { id: 59, name: "Loxodon" },
    { id: 60, name: "Kraul" },
    { id: 61, name: "Vedalken" },
    { id: 62, name: "Daelkyr" },
    { id: 64, name: "Riedran" },
    { id: 66, name: "Zemnian" },
    { id: 67, name: "Marquesian" },
    { id: 68, name: "Naush" },
    { id: 69, name: "Leonin" },
    { id: 70, name: "Grippli" },
    { id: 71, name: "Skitterwidget" },
    { id: 72, name: "Ziklight" },
    { id: 73, name: "Kruthik" },
    { id: 74, name: "Citlans" },
    { id: 75, name: "Djaynaian" },
    { id: 76, name: "Godstongue" },
    { id: 77, name: "Halri" },
    { id: 78, name: "Maynah" },
    { id: 79, name: "Nwarian" },
    { id: 80, name: "Quirapu" },
    { id: 81, name: "Sensan" },
    { id: 82, name: "Shankhi" },
    { id: 83, name: "Tletlahtolli" },
    { id: 84, name: "Xingyu" },
    { id: 85, name: "Zabaani" },
    { id: 86, name: "Dohwar" },
    { id: 87, name: "Hadozee" },
    { id: 88, name: "Aartuk" },
    { id: 89, name: "Abanasinian" },
    { id: 90, name: "Ergot" },
    { id: 91, name: "Istarian" },
    { id: 92, name: "Kenderspeak" },
    { id: 93, name: "Kharolian" },
    { id: 94, name: "Khur" },
    { id: 95, name: "Kothian" },
    { id: 96, name: "Nerakese" },
    { id: 97, name: "Nordmaarian" },
    { id: 98, name: "Ogre" },
    { id: 99, name: "Solamnic" },
    { id: 100, name: "Thieves Cant" },
    { id: 101, name: "Demodand" },
    { id: 102, name: "Birdfolk" },
    { id: 103, name: "Cervan" },
    { id: 104, name: "Feather Speech" },
    { id: 105, name: "Hedge" },
    { id: 106, name: "Jerbeen" },
    { id: 107, name: "Mapach" },
    { id: 108, name: "Vulpin" },
    {
      id: 109,
      name: "Darakhul",
    },
    {
      id: 110,
      name: "Derro",
    },
    {
      id: 111,
      name: "Eonic",
    },
    {
      id: 112,
      name: "Erina",
    },
    {
      id: 113,
      name: "Lemurfolk",
    },
    {
      id: 114,
      name: " Loxodan",
    },
    {
      id: 115,
      name: "Millitaur",
    },
    {
      id: 116,
      name: "Ravenfolk",
    },
    {
      id: 117,
      name: "Tosculi",
    },
    {
      id: 118,
      name: "Trollkin",
    },
    {
      id: 119,
      name: "Umbral",
    },
    {
      id: 120,
      name: "Void Speech",
    },
    {
      id: 121,
      name: "Angulotl",
    },
    {
      id: 122,
      name: "Kuranzoi",
    },
    {
      id: 123,
      name: "Gibberling",
    },
    {
      id: 124,
      name: "Huginn's Speech",
    },
    {
      id: 125,
      name: "Northern Tongue",
    },
  ],
  restoreTypes: [
    { id: 1, name: "Full", description: "Restore life with full HP" },
    { id: 2, name: "OneHP", description: "Restore life with 1 HP" },
  ],
  raceGroups: [
    { id: 1, name: "Human", avatarUrl: "https://www.dndbeyond.com/avatars/316/819/636620994416798583.jpeg" },
    { id: 2, name: "Half-Orc", avatarUrl: "https://www.dndbeyond.com/avatars/316/817/636620994330373054.jpeg" },
    { id: 3, name: "Elf", avatarUrl: "https://www.dndbeyond.com/avatars/316/807/636620993866733375.jpeg" },
    { id: 4, name: "Aarakocra", avatarUrl: "https://www.dndbeyond.com/avatars/316/802/636620993394513358.jpeg" },
    { id: 5, name: "Tiefling", avatarUrl: "https://www.dndbeyond.com/avatars/316/825/636620994695575306.jpeg" },
    { id: 6, name: "Dwarf", avatarUrl: "https://www.dndbeyond.com/avatars/316/806/636620993762055484.jpeg" },
    { id: 7, name: "Halfling", avatarUrl: "https://www.dndbeyond.com/avatars/316/816/636620994265008086.jpeg" },
    { id: 8, name: "Dragonborn", avatarUrl: "https://www.dndbeyond.com/avatars/316/805/636620993696690483.jpeg" },
    { id: 9, name: "Gnome", avatarUrl: "https://www.dndbeyond.com/avatars/316/811/636620994035528201.jpeg" },
    { id: 10, name: "Half-Elf", avatarUrl: "https://www.dndbeyond.com/avatars/316/814/636620994184198696.jpeg" },
    { id: 11, name: "Goliath", avatarUrl: "https://www.dndbeyond.com/avatars/316/813/636620994135369890.jpeg" },
    { id: 12, name: "Genasi", avatarUrl: "https://www.dndbeyond.com/avatars/316/809/636620993978899042.jpeg" },
    { id: 13, name: "Aasimar", avatarUrl: "https://www.dndbeyond.com/avatars/316/803/636620993510579220.jpeg" },
    { id: 14, name: "Firbolg", avatarUrl: "https://www.dndbeyond.com/avatars/316/808/636620993924142291.jpeg" },
    { id: 15, name: "Kenku", avatarUrl: "https://www.dndbeyond.com/avatars/316/820/636620994458763373.jpeg" },
    { id: 16, name: "Lizardfolk", avatarUrl: "https://www.dndbeyond.com/avatars/316/822/636620994561880989.jpeg" },
    { id: 17, name: "Tabaxi", avatarUrl: "https://www.dndbeyond.com/avatars/316/824/636620994652518517.jpeg" },
    { id: 18, name: "Triton", avatarUrl: "https://www.dndbeyond.com/avatars/316/827/636620994792452860.jpeg" },
    { id: 19, name: "Bugbear", avatarUrl: "https://www.dndbeyond.com/avatars/316/804/636620993577660502.jpeg" },
    { id: 20, name: "Goblin", avatarUrl: "https://www.dndbeyond.com/avatars/316/812/636620994081080899.jpeg" },
    { id: 21, name: "Hobgoblin", avatarUrl: "https://www.dndbeyond.com/avatars/316/818/636620994370309752.jpeg" },
    { id: 22, name: "Kobold", avatarUrl: "https://www.dndbeyond.com/avatars/316/821/636620994500727959.jpeg" },
    { id: 23, name: "Orc", avatarUrl: "https://www.dndbeyond.com/avatars/316/823/636620994608993950.jpeg" },
    {
      id: 24,
      name: "Yuan-ti Pureblood",
      avatarUrl: "https://www.dndbeyond.com/avatars/316/828/636620994846117422.jpeg",
    },
    { id: 25, name: "Tortle", avatarUrl: "https://www.dndbeyond.com/avatars/316/826/636620994747056231.jpeg" },
    { id: 27, name: "Gith", avatarUrl: "https://www.dndbeyond.com/avatars/318/759/636621911421792248.jpeg" },
    { id: 28, name: "Warforged", avatarUrl: "https://www.dndbeyond.com/avatars/2490/554/636680421772857650.jpeg" },
    { id: 29, name: "Shifter", avatarUrl: "https://www.dndbeyond.com/avatars/2490/562/636680421866916694.jpeg" },
    { id: 30, name: "Draconic Races", avatarUrl: null },
    { id: 31, name: "Lineages", avatarUrl: null },
  ],
  spellRangeTypes: [
    { id: 1, name: "Self" },
    { id: 2, name: "Touch" },
    { id: 3, name: "Ranged" },
    { id: 4, name: "Sight" },
    { id: 9, name: "Unlimited" },
  ],
  adjustmentDataTypes: [
    { id: 1, name: "Integer" },
    { id: 2, name: "Decimal" },
    { id: 3, name: "String" },
    { id: 4, name: "Boolean" },
  ],
  coverTypes: [
    { type: "half", name: "Half" },
    { type: "three-quarters", name: "Three-Quarters" },
    { type: "full", name: "Full" },
  ],
  spellConditionTypes: [
    { id: 1, name: "Apply" },
    { id: 2, name: "Remove" },
    { id: 3, name: "Suppress" },
  ],
  rangeTypes: [
    { id: 1, name: "Melee" },
    { id: 2, name: "Ranged" },
  ],
  damageTypes: [
    { id: 1, name: "Bludgeoning" },
    { id: 2, name: "Piercing" },
    { id: 3, name: "Slashing" },
    { id: 4, name: "Necrotic" },
    { id: 5, name: "Acid" },
    { id: 6, name: "Cold" },
    { id: 7, name: "Fire" },
    { id: 8, name: "Lightning" },
    { id: 9, name: "Thunder" },
    { id: 10, name: "Poison" },
    { id: 11, name: "Psychic" },
    { id: 12, name: "Radiant" },
    { id: 13, name: "Force" },
  ],
  privacyTypes: [
    { id: 1, name: "Private" },
    { id: 2, name: "CampaignOnly" },
    { id: 3, name: "Public" },
  ],
  sharingTypes: [
    { id: 1, name: "Full" },
    { id: 2, name: "Limited" },
    { id: 3, name: "StatBlock" },
  ],
  abilityScoreDisplayTypes: [
    { id: 1, name: "ScoresTop" },
    { id: 2, name: "ModifiersTop" },
  ],
  stealthCheckTypes: [
    { id: 1, name: "None" },
    { id: 2, name: "Disadvantage" },
  ],
  conditionTypes: [
    { id: 1, name: "Standard" },
    { id: 2, name: "Special" },
  ],
  operators: [
    { id: 1, name: "Addition" },
    { id: 2, name: "Multiplication" },
  ],
  monsterSubTypes: [
    { id: 1, name: "aarakocra" },
    { id: 2, name: "gnome" },
    { id: 3, name: "gnoll" },
    { id: 4, name: "grimlock" },
    { id: 5, name: "any race" },
    { id: 6, name: "elf" },
    { id: 7, name: "tortle" },
    { id: 8, name: "yugoloth" },
    { id: 9, name: "demon" },
    { id: 10, name: "devil" },
    { id: 11, name: "shapechanger" },
    { id: 12, name: "nagpa" },
    { id: 13, name: "meazel" },
    { id: 14, name: "inevitable" },
    { id: 15, name: "gith" },
    { id: 16, name: "dwarf" },
    { id: 17, name: "derro" },
    { id: 18, name: "kuo-toa" },
    { id: 19, name: "titan" },
    { id: 20, name: "yuan-ti" },
    { id: 21, name: "xvart" },
    { id: 22, name: "orc" },
    { id: 23, name: "goblinoid" },
    { id: 24, name: "kobold" },
    { id: 25, name: "grung" },
    { id: 26, name: "kenku" },
    { id: 27, name: "firenewt" },
    { id: 28, name: "troglodyte" },
    { id: 29, name: "thri-kreen" },
    { id: 30, name: "sahuagin" },
    { id: 31, name: "quaggoth" },
    { id: 32, name: "merfolk" },
    { id: 33, name: "human" },
    { id: 34, name: "lizardfolk" },
    { id: 35, name: "cloud giant" },
    { id: 36, name: "fire giant" },
    { id: 37, name: "frost giant" },
    { id: 38, name: "hill giant" },
    { id: 39, name: "stone giant" },
    { id: 40, name: "storm giant" },
    { id: 41, name: "bullywug" },
    { id: 42, name: "saurial" },
    { id: 43, name: "tabaxi" },
    { id: 44, name: "half-elf" },
    { id: 45, name: "half-dragon" },
    { id: 46, name: "simic hybrid" },
    { id: 47, name: "angel" },
    { id: 48, name: "kraul" },
    { id: 49, name: "tiefling" },
    { id: 50, name: "half-orc" },
    { id: 51, name: "halfling" },
    { id: 52, name: "locathah" },
    { id: 53, name: "triton" },
    { id: 54, name: "dragonborn" },
    { id: 55, name: "warforged" },
    { id: 56, name: "water genasi" },
    { id: 57, name: "fire genasi" },
    { id: 58, name: "earth genasi" },
    { id: 59, name: "air genasi" },
    { id: 60, name: "changeling" },
    { id: 61, name: "kalashtar" },
    { id: 62, name: "shifter" },
    { id: 63, name: "blindheim" },
    { id: 64, name: "dire corby" },
    { id: 65, name: "jermlaine" },
    { id: 66, name: "goliath" },
    { id: 67, name: "Giff" },
    { id: 68, name: "Skulk" },
    { id: 69, name: "Leonin" },
    { id: 70, name: "grippli" },
    { id: 71, name: "mongrelfolk" },
    { id: 72, name: "Harengon" },
    { id: 73, name: "Hag" },
    { id: 74, name: "Wizard" },
    { id: 75, name: "Sorcerer" },
    { id: 76, name: "Warlock" },
    { id: 77, name: "Cleric" },
    { id: 78, name: "Shadar-Kai" },
    { id: 79, name: "Paladin" },
    { id: 80, name: "Gem" },
    { id: 81, name: "Metallic" },
    { id: 82, name: "Chromatic" },
    { id: 83, name: "High-Elf" },
    { id: 84, name: "half-black dragon" },
    { id: 85, name: "Druid" },
    { id: 89, name: "Bard" },
    { id: 90, name: "shield dwarf" },
    { id: 91, name: "Ranger" },
    { id: 92, name: "Goblin" },
    { id: 93, name: "Drow" },
    { id: 94, name: "Ogre" },
    { id: 95, name: "Monk" },
    {
      id: 96,
      name: "Mind Flayer",
    },
    {
      id: 97,
      name: "Cattle",
    },
    {
      id: 98,
      name: "Dinosaur",
    },
    {
      id: 99,
      name: "Beholder",
    },
    {
      id: 100,
      name: "Myconid",
    },
    {
      id: 101,
      name: "Kender",
    },
    {
      id: 102,
      name: "Adult Chromatic",
    },
    {
      id: 103,
      name: "Unicorn",
    },
    {
      id: 104,
      name: "half-blue dragon",
    },
    {
      id: 105,
      name: "Archfey",
    },
    {
      id: 106,
      name: "any",
    },
    {
      id: 107,
      name: "half-giant",
    },
    {
      id: 108,
      name: "brown bear",
    },
    {
      id: 109,
      name: "Young Gem",
    },
    {
      id: 110,
      name: "Minotaur",
    },
    {
      id: 111,
      name: "Medusa",
    },
    {
      id: 112,
      name: "Moonstone",
    },
  ],
  creatureGroupFlags: [
    { id: 1, name: "Armor Add Proficiency Bonus", key: "ACPB", value: null, valueContextId: null },
    { id: 2, name: "Attack Rolls Add Proficiency Bonus", key: "ARPB", value: null, valueContextId: null },
    { id: 3, name: "Damage Rolls Add Proficiency Bonus", key: "DRPB", value: null, valueContextId: null },
    { id: 4, name: "Proficient Skills Add Proficiency Bonus", key: "PSPB", value: null, valueContextId: null },
    { id: 5, name: "Proficient Saving Throws Add Proficiency Bonus", key: "STPB", value: null, valueContextId: null },
    { id: 6, name: "Max Hit Points Level Multiplier Option", key: "HPLM", value: 4, valueContextId: 5 },
    { id: 7, name: "Evaluate Owner Skill Proficiencies", key: "EOSKP", value: null, valueContextId: null },
    { id: 8, name: "Evaluate Owner Save Proficiencies", key: "EOSVP", value: null, valueContextId: null },
    { id: 9, name: "Cannot Be Swarm", key: "CBS", value: null, valueContextId: null },
    { id: 10, name: "Cannot Use Legendary Actions", key: "CULGA", value: null, valueContextId: null },
    { id: 11, name: "Cannot Use Lair Actions", key: "CULRA", value: null, valueContextId: null },
    { id: 12, name: "Evaluate_Updated_Passive_Perception", key: "EUPP", value: null, valueContextId: null },
    { id: 13, name: "Evaluate Owner Passive Perception", key: "EOPP", value: null, valueContextId: null },
    { id: 14, name: "Artificer HP Multiplier", key: "AHM", value: 5, valueContextId: 252717 },
    { id: 15, name: "Max Hit Points Add Int Modifier", key: "MHPAIM", value: null, valueContextId: 4 },
    { id: 16, name: "Max Hit Points Add Monster CON Modifier", key: "MHPAMCM", value: null, valueContextId: 3 },
    { id: 17, name: "Use Challenge Rating As Level", key: "UCRAL", value: null, valueContextId: null },
    { id: 18, name: "Max Hit Points Base Artificer Level", key: "MHPBAL", value: null, valueContextId: 252717 },
  ],
  monsterTypes: [
    {
      pluralizedName: "aberrations",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/665/636747837392078487.jpeg",
      id: 1,
      name: "Aberration",
      description:
        "Aberrations are utterly alien beings. Many of them have innate magical abilities drawn from the creature's alien mind rather than the mystical forces of the world. The quintessential aberrations are aboleths, and slaadi. ",
    },
    {
      pluralizedName: "beasts",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/664/636747837303835953.jpeg",
      id: 2,
      name: "Beast",
      description:
        "Beasts are nonhumanoid creatures that are a natural part of the fantasy ecology. Some of them have magical powers, but most are unintelligent and lack any society or language. Beasts include all varieties of ordinary animals, dinosaurs, and giant versions of animals. ",
    },
    {
      pluralizedName: "celestials",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/666/636747837434463638.jpeg",
      id: 3,
      name: "Celestial",
      description:
        "Celestials are creatures native to the Upper Planes. Many of them are the servants of deities, employed as messengers or agents in the mortal realm and throughout the planes. Celestials are good by nature, so the exceptional celestial who strays from a good alignment is a horrifying rarity. ",
    },
    {
      pluralizedName: "constructs",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/667/636747837482013331.jpeg",
      id: 4,
      name: "Construct",
      description:
        "Constructs include angels, couatls, and pegasi. Constructs are made, not born. Some are programmed by their creators to follow a simple set of instructions, while others are imbued with sentience and capable of independent thought. Golems are the iconic constructs. Many creatures native to the outer plane of Mechanus, such as modrons, are constructs shaped from the raw material of the plane by the will of more powerful creatures. ",
    },
    {
      pluralizedName: "dragons",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/668/636747837521115242.jpeg",
      id: 6,
      name: "Dragon",
      description:
        "Dragons are large reptilian creatures of ancient origin and tremendous power. True dragons, including the good metallic dragons and the evil chromatic dragons, are highly intelligent and have innate magic. Also in this category are creatures distantly related to true dragons, but less powerful, less intelligent, and less magical, such as wyverns and pseudodragons. ",
    },
    {
      pluralizedName: "elementals",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/669/636747837569942785.jpeg",
      id: 7,
      name: "Elemental",
      description:
        "Elementals are creatures native to the elemental planes. Some creatures of this type are little more than animate masses of their respective elements, including the creatures simply called elementals. Others have biological forms infused with elemental energy. The races of genies, including djinn and efreet, form the most important civilizations on the elemental planes. Other elemental creatures include azers, invisible stalkers, and water weirds. ",
    },
    {
      pluralizedName: "fey",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/671/636747837638112910.jpeg",
      id: 8,
      name: "Fey",
      description:
        "Fey are magical creatures closely tied to the forces of nature. They dwell in twilight groves and misty forests. In some worlds, they are closely tied to the Feywild, also called the Plane of Faerie. Some are also found in the Outer Planes, particularly the planes of Arborea and the Beastlands. Fey include dryads, pixies, and satyrs. ",
    },
    {
      pluralizedName: "fiends",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/672/636747837699453839.jpeg",
      id: 9,
      name: "Fiend",
      description:
        "Fiends are creatures of wickedness that are native to the Lower Planes. A few are the servants of deities, but many more labor under the leadership of archdevils and demon princes. Evil priests and mages sometimes summon fiends to the material world to do their bidding. If an evil celestial is a rarity, a good fiend is almost inconceivable. Fiends include demons, devils, hell hounds, rakshasas, and yugoloths.",
    },
    {
      pluralizedName: "giants",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/674/636747837751071918.jpeg",
      id: 10,
      name: "Giant",
      description:
        "Giants tower over humans and their kind. They are humanlike in shape, though some have multiple heads (ettins) or deformities (fomorians). The six varieties of true giant are hill giants, stone giants, frost giants, fire giants, cloud giants, and storm giants. Besides these, creatures such as ogres and trolls are giants. ",
    },
    {
      pluralizedName: "humanoids",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/675/636747837794884984.jpeg",
      id: 11,
      name: "Humanoid",
      description:
        "Humanoids are the main peoples of a fantasy gaming world, both civilized and savage, including humans and a tremendous variety of other species. They have language and culture, few if any innate magical abilities (though most humanoids can learn spellcasting), and a bipedal form. The most common humanoid races are the ones most suitable as player characters: humans, dwarves, elves, and halflings. Almost as numerous but far more savage and brutal, and almost uniformly evil, are the races of goblinoids (goblins, hobgoblins, and bugbears), orcs, gnolls, lizardfolk, and kobolds. ",
    },
    {
      pluralizedName: "monstrosities",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/676/636747837839875603.jpeg",
      id: 13,
      name: "Monstrosity",
      description:
        "Monstrosities are monsters in the strictest sense--frightening creatures that are not ordinary, not truly natural, and almost never benign. Some are the results of magical experimentation gone awry (such as owlbears), and others are the product of terrible curses (including minotaurs). They defy categorization, and in some sense serve as a catch-all category for creatures that don't fit into any other type.",
    },
    {
      pluralizedName: "oozes",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/678/636747837893364274.jpeg",
      id: 14,
      name: "Ooze",
      description:
        "Oozes are gelatinous creatures that rarely have a fixed shape. They are mostly subterranean, dwelling in caves and dungeons and feeding on refuse, carrion, or creatures unlucky enough to get in their way. Black puddings and gelatinous cubes are among the most recognizable oozes. ",
    },
    {
      pluralizedName: "plants",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/679/636747837952193011.jpeg",
      id: 15,
      name: "Plant",
      description:
        "Plants in this context are vegetable creatures, not ordinary flora. Most of them are ambulatory, and some are carnivorous. The quintessential plants are the shambling mound and the treant. Fungal creatures such as the gas spore and the myconid also fall into this category. ",
    },
    {
      pluralizedName: "undead",
      avatarUrl: "https://www.dndbeyond.com/avatars/4675/680/636747837998336262.jpeg",
      id: 16,
      name: "Undead",
      description:
        "Undead are once-living creatures brought to a horrifying state of undeath through the practice of necromantic magic or some unholy curse. Undead include walking corpses, such as vampires and zombies, as well as bodiless spirits, such as ghosts and specters.\n\n",
    },
  ],
  challengeRatings: [
    { id: 1, value: 0.0, proficiencyBonus: 2, xp: 10 },
    { id: 2, value: 0.125, proficiencyBonus: 2, xp: 25 },
    { id: 3, value: 0.25, proficiencyBonus: 2, xp: 50 },
    { id: 4, value: 0.5, proficiencyBonus: 2, xp: 100 },
    { id: 5, value: 1.0, proficiencyBonus: 2, xp: 200 },
    { id: 6, value: 2.0, proficiencyBonus: 2, xp: 450 },
    { id: 7, value: 3.0, proficiencyBonus: 2, xp: 700 },
    { id: 8, value: 4.0, proficiencyBonus: 2, xp: 1100 },
    { id: 9, value: 5.0, proficiencyBonus: 3, xp: 1800 },
    { id: 10, value: 6.0, proficiencyBonus: 3, xp: 2300 },
    { id: 11, value: 7.0, proficiencyBonus: 3, xp: 2900 },
    { id: 12, value: 8.0, proficiencyBonus: 3, xp: 3900 },
    { id: 13, value: 9.0, proficiencyBonus: 4, xp: 5000 },
    { id: 14, value: 10.0, proficiencyBonus: 4, xp: 5900 },
    { id: 15, value: 11.0, proficiencyBonus: 4, xp: 7200 },
    { id: 16, value: 12.0, proficiencyBonus: 4, xp: 8400 },
    { id: 17, value: 13.0, proficiencyBonus: 5, xp: 10000 },
    { id: 18, value: 14.0, proficiencyBonus: 5, xp: 11500 },
    { id: 19, value: 15.0, proficiencyBonus: 5, xp: 13000 },
    { id: 20, value: 16.0, proficiencyBonus: 5, xp: 15000 },
    { id: 21, value: 17.0, proficiencyBonus: 6, xp: 18000 },
    { id: 22, value: 18.0, proficiencyBonus: 6, xp: 20000 },
    { id: 23, value: 19.0, proficiencyBonus: 6, xp: 22000 },
    { id: 24, value: 20.0, proficiencyBonus: 6, xp: 25000 },
    { id: 25, value: 21.0, proficiencyBonus: 7, xp: 33000 },
    { id: 26, value: 22.0, proficiencyBonus: 7, xp: 41000 },
    { id: 27, value: 23.0, proficiencyBonus: 7, xp: 50000 },
    { id: 29, value: 24.0, proficiencyBonus: 7, xp: 62000 },
    { id: 30, value: 25.0, proficiencyBonus: 8, xp: 75000 },
    { id: 31, value: 26.0, proficiencyBonus: 8, xp: 90000 },
    { id: 32, value: 27.0, proficiencyBonus: 8, xp: 105000 },
    { id: 33, value: 28.0, proficiencyBonus: 8, xp: 120000 },
    { id: 34, value: 29.0, proficiencyBonus: 9, xp: 135000 },
    { id: 35, value: 30.0, proficiencyBonus: 9, xp: 155000 },
  ],
  creatureGroups: [
    {
      id: 1,
      name: "Wild Shape",
      categoryId: 2,
      enabledByDefault: false,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: "Wild Shape",
      specialQualityText:
        "You can stay in a beast shape for a number of hours equal to half your druid level (rounded down). You then revert to your normal form unless you expend another use of this feature. You can revert to your normal form earlier by using a bonus action on your turn. You automatically revert if you fall unconscious, drop to 0 hit points, or die.",
      flags: ["EOSKP", "EOSVP", "CBS", "CULGA", "CULRA", "EUPP", "EOPP"],
      monsterTypes: [],
      ownerStats: [4, 5, 6],
      description:
        "<p>You can use your action to magically assume the shape of a beast (or sometimes another creature) that you have seen before.</p>",
      actionSnippet:
        "<p><strong><em>Revert Form.</em></strong> You can revert to your normal form by using a bonus action on your turn.</p>",
    },
    {
      id: 2,
      name: "Familiar",
      categoryId: 1,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: false,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: "Familiar",
      specialQualityText:
        "In combat, a familiar rolls its own initiative and acts on its own turn. A familiar can't attack, but it can take other actions as normal. When a familiar drops to 0 hit points, it disappears, leaving behind no physical form.",
      flags: [],
      monsterTypes: [3, 8, 9],
      ownerStats: [],
      description:
        "<p>You gain the service of a familiar, a spirit that takes an animal (or sometimes another creature) form you choose.</p>",
      actionSnippet:
        "<p><strong><em>Attack Restriction.</em></strong> A familiar can't attack, but it can take other actions as normal.</p>",
    },
    {
      id: 3,
      name: "Beast Companion",
      categoryId: 1,
      enabledByDefault: false,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: "Ranger's Companion",
      specialQualityText:
        "The beast obeys your commands as best as it can. It takes its turn on your initiative. On your turn, you can verbally command the beast where to move (no action required by you). You can use your action to verbally command it to take the Attack, Dash, Disengage, or Help action. If you don't issue a command, the beast takes the Dodge action. Once you have the Extra Attack feature, you can make one weapon attack yourself when you command the beast to take the Attack action.\n\nIf you are incapacitated or absent, the beast acts on its own, focusing on protecting you and itself. The beast never requires your command to use its reaction, such as when making an opportunity attack.",
      flags: ["ACPB", "ARPB", "DRPB", "PSPB", "STPB", "HPLM", "EUPP"],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>You gain a beast companion that accompanies you on your adventures and is trained to fight alongside you.</p>",
      actionSnippet:
        "<p><strong><em>Beast Master Bonus.</em></strong> The companion gains an additional bonus to attack and damage rolls equal to the ranger's proficiency bonus (not included in the attack descriptions below).</p>",
    },
    {
      id: 4,
      name: "Mount",
      categoryId: 1,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: false,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>A good mount can help you move more quickly through the wilderness, but its primary purpose is to carry the gear that would otherwise slow you down.</p>",
      actionSnippet: null,
    },
    {
      id: 5,
      name: "Pet",
      categoryId: 1,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: false,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>Allows you to display a creature special to you, such as a <em>figurine of wondrous power</em>.</p>",
      actionSnippet: null,
    },
    {
      id: 6,
      name: "Summoned",
      categoryId: 1,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: false,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>Allows you to display stat block references to summoned creatures from spells such as <em>conjure woodland beings</em>.</p>",
      actionSnippet: null,
    },
    {
      id: 7,
      name: "Misc",
      categoryId: 3,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: false,
      isMisc: true,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description: "<p>Allows you to display any other type of monster or NPC stat block.</p>",
      actionSnippet: null,
    },
    {
      id: 10,
      name: "Battle Smith Defender",
      categoryId: 3,
      enabledByDefault: false,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: ["ARPB", "DRPB", "PSPB", "AHM", "MHPAIM", "MHPAMCM"],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>The tinkering you have done in your free time has borne you a faithful companion, an iron defender.</p>",
      actionSnippet: null,
    },
    {
      id: 11,
      name: "Sidekick",
      categoryId: 3,
      enabledByDefault: true,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: false,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: ["UCRAL"],
      monsterTypes: [],
      ownerStats: [],
      description:
        "<p>On your adventures, the DM might reveal that youve befriended a special character called a sidekick, who joins your party.</p><p>The DM will either tell you which type of sidekick to use or let you choose one. Its up to you and the DM to decide who controls the sidekick in play.</p>",
      actionSnippet: null,
    },
    {
      id: 12,
      name: "Infusion",
      categoryId: 3,
      enabledByDefault: false,
      allowDuplicates: true,
      allowCombat: true,
      isPrimary: true,
      isMisc: true,
      specialQualityTitle: null,
      specialQualityText: null,
      flags: [],
      monsterTypes: [],
      ownerStats: [],
      description: "<p>You learn intricate methods for magically creating a creature that serves you.</p>",
      actionSnippet: null,
    },
  ],
  creatureGroupCategories: [
    { id: 1, name: "Companion" },
    { id: 2, name: "Shapechange" },
    { id: 3, name: "Other" },
  ],
  environments: [
    { id: 1, name: "Arctic" },
    { id: 2, name: "Coastal" },
    { id: 3, name: "Desert" },
    { id: 4, name: "Forest" },
    { id: 5, name: "Grassland" },
    { id: 6, name: "Hill" },
    { id: 7, name: "Mountain" },
    { id: 8, name: "Swamp" },
    { id: 9, name: "Underdark" },
    { id: 10, name: "Underwater" },
    { id: 11, name: "Urban" },
  ],
  armorTypes: [
    { id: 1, name: "Light Armor" },
    { id: 2, name: "Medium Armor" },
    { id: 3, name: "Heavy Armor" },
    { id: 4, name: "Shield" },
  ],
  gearTypes: [
    { id: 1, name: "Adventuring Gear" },
    { id: 2, name: "Armor" },
    { id: 3, name: "Artifact" },
    { id: 4, name: "Mount" },
    { id: 5, name: "Poison" },
    { id: 6, name: "Potion" },
    { id: 7, name: "Ring" },
    { id: 8, name: "Rod" },
    { id: 9, name: "Scroll" },
    { id: 10, name: "Staff" },
    { id: 11, name: "Tool" },
    { id: 12, name: "Vehicle (Land)" },
    { id: 13, name: "Wand" },
    { id: 14, name: "Weapon" },
    { id: 15, name: "Wondrous Item" },
    { id: 16, name: "Equipment Pack" },
    { id: 17, name: "Vehicle (Water)" },
    { id: 18, name: "Gemstone" },
  ],
  naturalActions: [
    {
      id: 1,
      entityTypeId: 1120657896,
      limitedUse: null,
      name: "Unarmed Strike",
      description:
        "Instead of using a weapon to make a melee weapon attack, you can use an unarmed strike: a punch, kick, head-butt, or similar forceful blow (none of which count as weapons). On a hit, an unarmed strike deals bludgeoning damage equal to 1 + your Strength modifier. You are proficient with your unarmed strikes.",
      snippet:
        "You can punch, kick, head-butt, or use a similar forceful blow and deal bludgeoning damage equal to 1 + STR modifier",
      abilityModifierStatId: 1,
      onMissDescription: null,
      saveFailDescription: null,
      saveSuccessDescription: null,
      saveStatId: null,
      fixedSaveDc: null,
      attackTypeRange: 1,
      actionType: 1,
      attackSubtype: 3,
      dice: null,
      value: 1,
      damageTypeId: 1,
      isMartialArts: true,
      isProficient: true,
      spellRangeType: null,
      displayAsAttack: null,
      range: null,
      activation: { activationTime: 1, activationType: 1 },
      attackCustomData: {
        name: null,
        notes: null,
        damageBonus: null,
        toHitBonus: null,
        toHit: null,
        isOffhand: null,
        isSilver: null,
        isAdamantine: null,
        isProficient: null,
        saveDcBonus: null,
        saveDc: null,
        weight: null,
        displayAsAttack: null,
        cost: null,
      },
      componentId: 0,
      componentTypeId: 0,
    },
  ],
  adjustmentTypes: [
    {
      id: 2,
      name: "Additional Magic Bonus",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: -10 },
        { id: 2, name: "Maximum", value: 10 },
      ],
    },
    {
      id: 3,
      name: "Additional Misc Bonus",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: -10 },
        { id: 2, name: "Maximum", value: 10 },
      ],
    },
    { id: 32, name: "Armor Proficiency Level", dataType: 1, constraints: [] },
    { id: 49, name: "Capacity Override", dataType: 3, constraints: [] },
    { id: 50, name: "Capacity Weight Override", dataType: 2, constraints: [] },
    { id: 19, name: "Cost Override", dataType: 2, constraints: [] },
    {
      id: 42,
      name: "Creature AC",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 1 },
        { id: 2, name: "Maximum", value: 999 },
      ],
    },
    { id: 45, name: "Creature Alignment", dataType: 1, constraints: [] },
    {
      id: 43,
      name: "Creature Hit Points",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 1 },
        { id: 2, name: "Maximum", value: 999 },
      ],
    },
    { id: 47, name: "Creature Notes", dataType: 3, constraints: [] },
    { id: 46, name: "Creature Size", dataType: 1, constraints: [] },
    { id: 44, name: "Creature Type Override", dataType: 1, constraints: [] },
    { id: 31, name: "Dice Count Override", dataType: 1, constraints: [] },
    { id: 30, name: "Dice Type Override", dataType: 1, constraints: [] },
    { id: 16, name: "Display As Attack", dataType: 4, constraints: [] },
    { id: 18, name: "Dual Wield", dataType: 4, constraints: [] },
    { id: 10, name: "Fixed Value Bonus", dataType: 1, constraints: [] },
    { id: 11, name: "Fixed Value Override", dataType: 1, constraints: [] },
    { id: 21, name: "Is Adamantine", dataType: 4, constraints: [] },
    { id: 48, name: "Is Dedicated Weapon", dataType: 4, constraints: [] },
    { id: 29, name: "Is Hexblade", dataType: 4, constraints: [] },
    { id: 28, name: "Is Pact Weapon", dataType: 4, constraints: [] },
    { id: 17, name: "Is Proficient", dataType: 4, constraints: [] },
    { id: 20, name: "Is Silver", dataType: 4, constraints: [] },
    { id: 35, name: "Language Proficiency Level", dataType: 1, constraints: [] },
    { id: 37, name: "Movement Override", dataType: 1, constraints: [] },
    { id: 8, name: "Name Override", dataType: 3, constraints: [] },
    { id: 9, name: "Notes", dataType: 3, constraints: [] },
    {
      id: 1,
      name: "Override AC",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    {
      id: 4,
      name: "Override Base Armor + DEX",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    {
      id: 7,
      name: "Override Passive Insight",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    {
      id: 6,
      name: "Override Passive Investigation",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    {
      id: 5,
      name: "Override Passive Perception",
      dataType: 1,
      constraints: [
        { id: 1, name: "Minimum", value: 0 },
        { id: 2, name: "Maximum", value: 2000000000 },
      ],
    },
    { id: 14, name: "Save DC Bonus", dataType: 1, constraints: [] },
    { id: 15, name: "Save DC Override", dataType: 1, constraints: [] },
    { id: 40, name: "Saving Throw Magic Bonus", dataType: 1, constraints: [] },
    { id: 39, name: "Saving Throw Misc Bonus", dataType: 1, constraints: [] },
    { id: 38, name: "Saving Throw Override", dataType: 1, constraints: [] },
    { id: 41, name: "Saving Throw Proficiency Level", dataType: 1, constraints: [] },
    { id: 36, name: "Sense Override", dataType: 1, constraints: [] },
    { id: 25, name: "Skill Magic Bonus", dataType: 1, constraints: [] },
    { id: 24, name: "Skill Misc Bonus", dataType: 1, constraints: [] },
    { id: 23, name: "Skill Override", dataType: 1, constraints: [] },
    { id: 26, name: "Skill Proficiency Level", dataType: 1, constraints: [] },
    { id: 27, name: "Skill Stat Override", dataType: 1, constraints: [] },
    { id: 12, name: "To Hit Bonus", dataType: 1, constraints: [] },
    { id: 13, name: "To Hit Override", dataType: 1, constraints: [] },
    { id: 34, name: "Tool Proficiency Level", dataType: 1, constraints: [] },
    { id: 33, name: "Weapon Proficiency Level", dataType: 1, constraints: [] },
    { id: 22, name: "Weight Override", dataType: 2, constraints: [] },
  ],
  weaponCategories: [
    { id: 1, entityTypeId: 660121713, name: "Simple" },
    { id: 2, entityTypeId: 660121713, name: "Martial" },
    { id: 3, entityTypeId: 660121713, name: "Firearms" },
  ],
  spellComponents: [
    {
      id: 1,
      name: "Verbal",
      shortName: "V",
      description:
        "Most spells require the chanting of mystic words. The words themselves aren't the source of the spell's power; rather, the particular combination of sounds, with specific pitch and resonance, sets the threads of magic in motion. Thus, a character who is gagged or in an area of silence, such as one created by the silence spell, can't cast a spell with a verbal component.\n\n",
    },
    {
      id: 2,
      name: "Somatic",
      shortName: "S",
      description:
        "Spellcasting gestures might include a forceful gesticulation or an intricate set of gestures. If a spell requires a somatic component, the caster must have free use of at least one hand to perform these gestures.\n\n",
    },
    {
      id: 3,
      name: "Material",
      shortName: "M",
      description:
        "Casting some spells requires particular objects, specified in parentheses in the component entry. A character can use a component pouch or a spellcasting focus (found in Equipment) in place of the components specified for a spell. But if a cost is indicated for a component, a character must have that specific component before he or she can cast the spell. \nIf a spell states that a material component is consumed by the spell, the caster must provide this component for each casting of the spell. A spellcaster must have a hand free to access a spell's material components--or to hold a spellcasting focus--but it can be the same hand that he or she uses to perform somatic components.\n\n",
    },
    {
      id: 4,
      name: "Royalty",
      shortName: "R",
      description:
        "To cast a spell that employs a royalty component (including using a spell scroll or other magic item that stores such a spell), a caster must have sufficient funds on their person. The cost of the casting is set by the caster who creates the spell, but is typically 1 gp per spell slot level. When the spell is cast, the royalty is magically transported to a coffer or other object designated by the creating spellcaster. This payment is made whether the caster using the spell is aware of the royalty component or not. If the caster does not have sufficient funds, the spell is not lost but it cannot be cast.\n\nThough many casters have tried to circumvent the royalty component, none have ever fully succeeded. However, it is said that a character can attempt a DC 15 Intelligence (Arcana) check while casting a spell with a royalty component. With a successful check, the payment is taken from a random creature within 10 feet of the caster, without that creatures knowledge.",
    },
  ],
  activationTypes: [
    { id: 1, name: "Action", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 2, name: "No Action", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 3, name: "Bonus Action", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 4, name: "Reaction", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 6, name: "Minute", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 7, name: "Hour", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 8, name: "Special", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
  ],
  basicActions: [
    {
      id: 1,
      name: "Attack",
      description:
        '<p>The most common action to take in combat is the Attack action, whether you are swinging a sword, firing an arrow from a bow, or brawling with your fists.</p>\n<p>With this action, you make one melee or ranged attack. See the "Making an Attack" section for the rules that govern attacks.</p>\n<p>Certain features, such as the Extra Attack feature of the fighter, allow you to make more than one attack with this action.</p>',
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 2,
      name: "Cast a Spell",
      description:
        "<p>Spellcasters such as wizards and clerics, as well as many monsters, have access to spells and can use them to great effect in combat. Each spell has a casting time, which specifies whether the caster must use an action, a reaction, minutes, or even hours to cast the spell. Casting a spell is, therefore, not necessarily an action. Most spells do have a casting time of 1 action, so a spellcaster often uses his or her action in combat to cast such a spell.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 4,
      name: "Dash",
      description:
        "<p>When you take the Dash action, you gain extra movement for the current turn. The increase equals your speed, after applying any modifiers. With a speed of 30 feet, for example, you can move up to 60 feet on your turn if you dash.</p>\n<p>Any increase or decrease to your speed changes this additional movement by the same amount. If your speed of 30 feet is reduced to 15 feet, for instance, you can move up to 30 feet this turn if you dash.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 5,
      name: "Disengage",
      description:
        "<p>If you take the Disengage action, your movement doesn't provoke opportunity attacks for the rest of the turn.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 6,
      name: "Dodge",
      description:
        "<p>When you take the Dodge action, you focus entirely on avoiding attacks. Until the start of your next turn, any attack roll made against you has disadvantage if you can see the attacker, and you make Dexterity saving throws with advantage. You lose this benefit if you are incapacitated or if your speed drops to 0.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 7,
      name: "Help",
      description:
        "<p>You can lend your aid to another creature in the completion of a task. When you take the Help action, the creature you aid gains advantage on the next ability check it makes to perform the task you are helping with, provided that it makes the check before the start of your next turn.</p>\n<p>Alternatively, you can aid a friendly creature in attacking a creature within 5 feet of you. You feint, distract the target, or in some other way team up to make your ally's attack more effective. If your ally attacks the target before your next turn, the first attack roll is made with advantage.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 8,
      name: "Hide",
      description:
        '<p>When you take the Hide action, you make a Dexterity (Stealth) check in an attempt to hide, following the rules for hiding. If you succeed, you gain certain benefits, as described in the "Unseen Attackers and Targets" section later in this chapter.</p>',
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 9,
      name: "Ready",
      description:
        '<p>Sometimes you want to get the jump on a foe or wait for a particular circumstance before you act. To do so, you can take the Ready action on your turn, which lets you act using your reaction before the start of your next turn.</p>\n<p>First, you decide what perceivable circumstance will trigger your reaction. Then, you choose the action you will take in response to that trigger, or you choose to move up to your speed in response to it. Examples include "If the cultist steps on the trapdoor, I\'ll pull the lever that opens it," and "If the goblin steps next to me, I move away."</p>\n<p>When the trigger occurs, you can either take your reaction right after the trigger finishes or ignore the trigger. Remember that you can take only one reaction per round.</p>\n<p>When you ready a spell, you cast it as normal but hold its energy, which you release with your reaction when the trigger occurs. To be readied, a spell must have a casting time of 1 action, and holding onto the spell\'s magic requires concentration. If your concentration is broken, the spell dissipates without taking effect. For example, if you are concentrating on the <strong>web</strong> spell and ready <strong>magic missile</strong>, your <strong>web</strong> spell ends, and if you take damage before you release <strong>magic missile</strong> with your reaction, your concentration might be broken.</p>',
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 10,
      name: "Search",
      description:
        "<p>When you take the Search action, you devote your attention to finding something. Depending on the nature of your search, the GM might have you make a Wisdom (Perception) check or an Intelligence (Investigation) check.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 11,
      name: "Use an Object",
      description:
        "<p>You normally interact with an object while doing something else, such as when you draw a sword as part of an attack. When an object requires your action for its use, you take the Use an Object action. This action is also useful when you want to interact with more than one object on your turn.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 1001,
      name: "Opportunity Attack",
      description:
        "<p>You can make an opportunity attack when a hostile creature that you can see moves out of your reach. To make the opportunity attack, you use your reaction to make one melee attack against the provoking creature. The attack occurs right before the creature leaves your reach</p><p></p>",
      activation: { activationTime: null, activationType: 4 },
    },
    {
      id: 1002,
      name: "Grapple",
      description:
        "<p>When you want to grab a creature or wrestle with it, you can use the Attack action to make a special melee attack, a grapple. If you're able to make multiple attacks with the Attack action, this attack replaces one of them.</p>\n<p>The target of your grapple must be no more than one size larger than you and must be within your reach. Using at least one free hand, you try to seize the target by making a grapple check instead of an attack roll: a Strength (Athletics) check contested by the target's Strength (Athletics) or Dexterity (Acrobatics) check (the target chooses the ability to use). If you succeed, you subject the target to the grappled condition. The condition specifies the things that end it, and you can release the target whenever you like (no action required).</p>\n<p><strong>Escaping a Grapple.</strong> A grappled creature can use its action to escape. To do so, it must succeed on a Strength (Athletics) or Dexterity (Acrobatics) check contested by your Strength (Athletics) check.</p>\n<p><strong>Moving a Grappled Creature.</strong> When you move, you can drag or carry the grappled creature with you, but your speed is halved, unless the creature is two or more sizes smaller than you.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 1003,
      name: "Shove",
      description:
        "<p>Using the Attack action, you can make a special melee attack to shove a creature, either to knock it prone or push it away from you. If you're able to make multiple attacks with the Attack action, this attack replaces one of them.</p>\n<p>The target must be no more than one size larger than you and must be within your reach. Instead of making an attack roll, you make a Strength (Athletics) check contested by the target's Strength (Athletics) or Dexterity (Acrobatics) check (the target chooses the ability to use). You succeed automatically if the target is incapacitated. If you succeed, you either knock the target prone or push it 5 feet away from you.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 1004,
      name: "Improvise",
      description:
        "<p>Your character can do things not covered by the actions in this chapter, such as breaking down doors, intimidating enemies, sensing weaknesses in magical defenses, or calling for a parley with a foe. The only limits to the actions you can attempt are your imagination and your character's ability scores. See the descriptions of the ability scores in chapter 7 for inspiration as you improvise.</p>\n<p>When you describe an action not detailed elsewhere in the rules, the DM tells you whether that action is possible and what kind of roll you need to make, if any, to determine success or failure.</p>",
      activation: { activationTime: null, activationType: 1 },
    },
    {
      id: 1005,
      name: "Two-Weapon Fighting",
      description:
        "<p>When you take the Attack action and attack with a light melee weapon that you're holding in one hand, you can use a bonus action to attack with a different light melee weapon that you're holding in the other hand. You don't add your ability modifier to the damage of the bonus attack, unless that modifier is negative.</p>\n<p>If either weapon has the thrown property, you can throw the weapon, instead of making a melee attack with it.</p>",
      activation: { activationTime: null, activationType: 3 },
    },
    {
      id: 1006,
      name: "Interact with an Object",
      description:
        "<p>Here are a few examples of the sorts of thing you can do in tandem with your movement and action:</p>\n<ul>\n<li>draw or sheathe a sword</li>\n<li>open or close a door</li>\n<li>withdraw a potion from your backpack</li>\n<li>pick up a dropped axe</li>\n<li>take a bauble from a table</li>\n<li>remove a ring from your finger</li>\n<li>stuff some food into your mouth</li>\n<li>plant a banner in the ground</li>\n<li>fish a few coins from your belt pouch</li>\n<li>drink all the ale in a flagon</li>\n<li>throw a lever or a switch</li>\n<li>pull a torch from a sconce</li>\n<li>take a book from a shelf you can reach</li>\n<li>extinguish a small flame</li>\n<li>don a mask</li>\n<li>pull the hood of your cloak up and over your head</li>\n<li>put your ear to a door</li>\n<li>kick a small stone</li>\n<li>turn a key in a lock</li>\n<li>tap the floor with a 10-foot pole</li>\n<li>hand an item to another character</li>\n</ul>",
      activation: { activationTime: null, activationType: 8 },
    },
  ],
  rules: [
    {
      id: 34,
      name: "Race",
      description:
        "Your choice of race affects many different aspects of your character. It establishes fundamental qualities that exist throughout your characters adventuring career. When making this decision, keep in mind the kind of character you want to play. For example, a halfling could be a good choice for a sneaky rogue, a dwarf makes a tough warrior, and an elf can be a master of arcane magic.",
    },
    {
      id: 35,
      name: "Class",
      description:
        "Class is the primary definition of what your character can do. Its more than a profession; its your characters calling. Class shapes the way you think about the world and interact with it and your relationship with other people and powers in the multiverse. A fighter, for example, might view the world in pragmatic terms of strategy and maneuvering, and see herself as just a pawn in a much larger game. A cleric, by contrast, might see himself as a willing servant in a gods unfolding plan or a conflict brewing among various deities. While the fighter has contacts in a mercenary company or army, the cleric might know a number of priests, paladins, and devotees who share his faith.",
    },
    {
      id: 36,
      name: "Level",
      description:
        "Starting off at 1st level marks your characters entry into the adventuring life. As your character goes on adventures and overcomes challenges, he or she gains experience, represented by experience points. A character who reaches a specified experience point total advances in capability. This advancement is called gaining a level.",
    },
    {
      id: 37,
      name: "Experience Points",
      description:
        "As your character goes on adventures and overcomes challenges, he or she gains experience, represented by experience points. A character who reaches a specified experience point total advances in capability. This advancement is called gaining a level.",
    },
    {
      id: 38,
      name: "Hit Points",
      description:
        "Hit points represent a combination of physical and mental durability, the will to live, and luck. Creatures with more hit points are more difficult to kill. Those with fewer hit points are more fragile. \n\nA creature's current hit points (usually just called hit points) can be any number from the creature's hit point maximum down to 0. This number changes frequently as a creature takes damage or receives healing. \n\nWhenever a creature takes damage, that damage is subtracted from its hit points. The loss of hit points has no effect on a creature's capabilities until the creature drops to 0 hit points.",
    },
    {
      id: 39,
      name: "Hit Dice",
      description:
        "Your hit points are determined by your Hit Dice (short for Hit Point Dice).\n\nAt 1st level, your character has 1 Hit Die, and the die type is determined by your class. You start with hit points equal to the highest roll of that die, as indicated in your class description. (You also add your Constitution modifier.)",
    },
    {
      id: 40,
      name: "Proficiency Bonus",
      description:
        '<p>Characters have a proficiency bonus determined by level, as detailed in <a href="https://www.dndbeyond.com/compendium/rules/phb/step-by-step-characters">chapter 1</a>. Monsters also have this bonus, which is incorporated in their stat blocks. The bonus is used in the rules on ability checks, saving throws, and attack rolls.</p>\n<p>Your proficiency bonus cant be added to a single die roll or other number more than once. For example, if two different rules say you can add your proficiency bonus to a Wisdom saving throw, you nevertheless add the bonus only once when you make the save.</p>\n<p>Occasionally, your proficiency bonus might be multiplied or divided (doubled or halved, for example) before you apply it. For example, the rogues Expertise feature doubles the proficiency bonus for certain ability checks. If a circumstance suggests that your proficiency bonus applies more than once to the same roll, you still add it only once and multiply or divide it only once.</p>\n<p>By the same token, if a feature or effect allows you to multiply your proficiency bonus when making an ability check that wouldnt normally benefit from your proficiency bonus, you still dont add the bonus to the check. For that check your proficiency bonus is 0, given the fact that multiplying 0 by any number is still 0. For instance, if you lack proficiency in the History skill, you gain no benefit from a feature that lets you double your proficiency bonus when you make Intelligence (History) checks.</p>\n<p>In general, you dont multiply your proficiency bonus for attack rolls or saving throws. If a feature or effect allows you to do so, these same rules apply.</p>',
    },
    {
      id: 41,
      name: "Ability Scores",
      description:
        "Each of a creature's abilities has a score, a number that defines the magnitude of that ability. An ability score is not just a measure of innate capabilities, but also encompasses a creature's training and competence in activities related to that ability. \n\nA score of 10 or 11 is the normal human average, but adventurers and many monsters are a cut above average in most abilities. A score of 18 is the highest that a person usually reaches. Adventurers can have scores as high as 20, and monsters and divine beings can have scores as high as 30. \n\nEach ability also has a modifier, derived from the score and ranging from -5 (for an ability score of 1) to +10 (for a score of 30). The Ability Scores and Modifiers table notes the ability modifiers for the range of possible ability scores, from 1 to 30.",
    },
    {
      id: 42,
      name: "Alignment",
      description:
        "A typical creature in the game world has an alignment, which broadly describes its moral and personal attitudes. Alignment is a combination of two factors: one identifies morality (good, evil, or neutral), and the other describes attitudes toward society and order (lawful, chaotic, or neutral). Thus, nine distinct alignments define the possible combinations.",
    },
    {
      id: 43,
      name: "Lawful Good",
      description:
        "Lawful good (LG) creatures can be counted on to do the right thing as expected by society. Gold dragons, paladins, and most dwarves are lawful good.",
    },
    {
      id: 44,
      name: "Neutral Good",
      description:
        "Neutral good (NG) folk do the best they can to help others according to their needs. Many celestials, some cloud giants, and most gnomes are neutral good.",
    },
    {
      id: 45,
      name: "Chaotic Good",
      description:
        "Chaotic good (CG) creatures act as their conscience directs, with little regard for what others expect. Copper dragons, many elves, and unicorns are chaotic good.",
    },
    {
      id: 46,
      name: "Neutral",
      description:
        "Neutral (N) is the alignment of those who prefer to steer clear of moral questions and dont take sides, doing what seems best at the time. Lizardfolk, most druids, and many humans are neutral.",
    },
    {
      id: 47,
      name: "Lawful Evil",
      description:
        "Lawful evil (LE) creatures methodically take what they want, within the limits of a code of tradition, loyalty, or order. Devils, blue dragons, and hobgoblins are lawful evil.",
    },
    {
      id: 48,
      name: "Neutral Evil",
      description:
        "Neutral evil (NE) is the alignment of those who do whatever they can get away with, without compassion or qualms. Many drow, some cloud giants, and goblins are neutral evil.",
    },
    {
      id: 49,
      name: "Chaotic Evil",
      description:
        "Chaotic evil (CE) creatures act with arbitrary violence, spurred by their greed, hatred, or bloodlust. Demons, red dragons, and orcs are chaotic evil.",
    },
    {
      id: 50,
      name: "Lawful Neutral",
      description:
        "Lawful neutral (LN) individuals act in accordance with law, tradition, or personal codes. Many monks and some wizards are lawful neutral.",
    },
    {
      id: 51,
      name: "Chaotic Neutral",
      description:
        "Chaotic neutral (CN) creatures follow their whims, holding their personal freedom above all else. Many barbarians and rogues, and some bards, are chaotic neutral.",
    },
    {
      id: 52,
      name: "Background",
      description:
        "Every story has a beginning. Your characters background reveals where you came from, how you became an adventurer, and your place in the world. Your fighter might have been a courageous knight or a grizzled soldier. Your wizard could have been a sage or an artisan. Your rogue might have gotten by as a guild thief or commanded audiences as a jester.",
    },
    {
      id: 53,
      name: "Personality Traits",
      description:
        "Personality traits are small, simple ways to help you set your character apart from every other character. Your personality traits should tell you something interesting and fun about your character. They should be self-descriptions that are specific about what makes your character stand out.\n\nPersonality traits might describe the things your character likes, his or her past accomplishments, things your character dislikes or fears, your characters self-attitude or mannerisms, or the influence of his or her ability scores.",
    },
    {
      id: 54,
      name: "Bonds",
      description:
        "Bonds represent a characters connections to people, places, and events in the world. They tie you to things from your background. They might inspire you to heights of heroism, or lead you to act against your own best interests if they are threatened. They can work very much like ideals, driving a characters motivations and goals. \n\nBonds might answer any of these questions: Whom do you care most about? To what place do you feel a special connection? What is your most treasured possession?",
    },
    {
      id: 55,
      name: "Ideals",
      description:
        "Your ideals are the things that you believe in most strongly, the fundamental moral and ethical principles that compel you to act as you do. Ideals encompass everything from your life goals to your core belief system. \n\nIdeals might answer any of these questions: What are the principles that you will never betray? What would prompt you to make sacrifices? What drives you to act and guides your goals and ambitions? What is the single most important thing you strive for?",
    },
    {
      id: 56,
      name: "Flaws",
      description:
        "Your characters flaw represents some vice, compulsion, fear, or weaknessin particular, anything that someone else could exploit to bring you to ruin or cause you to act against your best interests. More significant than negative personality traits, a flaw might answer any of these questions: What enrages you? Whats the one person, concept, or event that you are terrified of? What are your vices?",
    },
    {
      id: 57,
      name: "Armor Class",
      description:
        "Your Armor Class (AC) represents how well your character avoids being wounded in battle. Things that contribute to your AC include the armor you wear, the shield you carry, and your Dexterity modifier. Not all characters wear armor or carry shields, however. \n\nWithout armor or a shield, your characters AC equals 10 + his or her Dexterity modifier. If your character wears armor, carries a shield, or both, calculate your AC using the rules in the Equipment section. Record your AC on your character sheet.",
    },
    {
      id: 58,
      name: "Acid Damage",
      description:
        "The corrosive spray of an adult black dragon's breath and the dissolving enzymes secreted by a black pudding deal acid damage.",
    },
    {
      id: 59,
      name: "Bludgeoning Damage",
      description: "Blunt force attacks--hammers, falling, constriction, and the like--deal bludgeoning damage.",
    },
    {
      id: 60,
      name: "Cold Damage",
      description:
        "The infernal chill radiating from an ice devil's spear and the frigid blast of a young white dragon's breath deal cold damage.",
    },
    {
      id: 61,
      name: "Fire Damage",
      description: "Ancient red dragons breathe fire, and many spells conjure flames to deal fire damage.",
    },
    {
      id: 62,
      name: "Force Damage",
      description:
        "Force is pure magical energy focused into a damaging form. Most effects that deal force damage are spells, including magic missile and spiritual weapon.",
    },
    {
      id: 63,
      name: "Lightning Damage",
      description: "A lightning bolt spell and a blue dragon wyrmling's breath deal lightning damage.",
    },
    {
      id: 64,
      name: "Necrotic Damage",
      description:
        "Necrotic damage, dealt by certain undead and a spell such as chill touch, withers matter and even the soul.",
    },
    {
      id: 65,
      name: "Piercing Damage",
      description: "Puncturing and impaling attacks, including spears and monsters' bites, deal piercing damage.",
    },
    {
      id: 66,
      name: "Poison Damage",
      description: "Venomous stings and the toxic gas of an adult green dragon's breath deal poison damage.",
    },
    { id: 67, name: "Psychic Damage", description: "Mental abilities such as a psionic blast deal psychic damage." },
    {
      id: 68,
      name: "Radiant Damage",
      description:
        "Radiant damage, dealt by a cleric's flame strike spell or an angel's smiting weapon, sears the flesh like fire and overloads the spirit with power.",
    },
    { id: 69, name: "Slashing Damage", description: "Swords, axes, and monsters' claws deal slashing damage." },
    {
      id: 70,
      name: "Thunder Damage",
      description: "A concussive burst of sound, such as the effect of the thunderwave spell, deals thunder damage.",
    },
    {
      id: 71,
      name: "Critical Hits",
      description:
        "When you score a critical hit, you get to roll extra dice for the attack's damage against the target. Roll all of the attack's damage dice twice and add them together. Then add any relevant modifiers as normal. To speed up play, you can roll all the damage dice at once.",
    },
    {
      id: 72,
      name: "Damage Resistance",
      description:
        "Some creatures and objects are exceedingly difficult to hurt with certain types of damage.\n\nIf a creature or an object has resistance to a damage type, damage of that type is halved against it.\n\nResistance is applied after all other modifiers to damage. For example, a creature has resistance to bludgeoning damage and is hit by an attack that deals 25 bludgeoning damage. The creature is also within a magical aura that reduces all damage by 5. The 25 damage is first reduced by 5 and then halved, so the creature takes 10 damage.\n\nMultiple instances of resistance that affect the same damage type count as only one instance. For example, if a creature has resistance to fire damage as well as resistance to all nonmagical damage, the damage of a nonmagical fire is reduced by half against the creature, not reduced by three-quarters.",
    },
    {
      id: 73,
      name: "Damage Vulnerability",
      description:
        "Some creatures and objects are unusually easy to hurt with certain types of damage. \n\nIf a creature or an object has vulnerability to a damage type, damage of that type is doubled against it. \n\nMultiple instances of vulnerability that affect the same damage type count as only one instance.",
    },
    {
      id: 74,
      name: "Instant Death",
      description:
        "Massive damage can kill you instantly. When damage reduces you to 0 hit points and there is damage remaining, you die if the remaining damage equals or exceeds your hit point maximum. \n\nFor example, a cleric with a maximum of 12 hit points currently has 6 hit points. If she takes 18 damage from an attack, she is reduced to 0 hit points, but 12 damage remains. Because the remaining damage equals her hit point maximum, the cleric dies.",
    },
    {
      id: 75,
      name: "Death Saving Throws",
      description:
        "Whenever you start your turn with 0 hit points, you must make a special saving throw, called a death saving throw, to determine whether you creep closer to death or hang onto life. Unlike other saving throws, this one isn't tied to any ability score. You are in the hands of fate now, aided only by spells and features that improve your chances of succeeding on a saving throw. \n\nRoll a d20. If the roll is 10 or higher, you succeed. Otherwise, you fail. A success or failure has no effect by itself. On your third success, you become stable (see below). On your third failure, you die. The successes and failures don't need to be consecutive; keep track of both until you collect three of a kind. The number of both is reset to zero when you regain any hit points or become stable.",
    },
    {
      id: 76,
      name: "Temporary Hit Points",
      description:
        "Some spells and special abilities confer temporary hit points to a creature. Temporary hit points aren't actual hit points; they are a buffer against damage, a pool of hit points that protect you from injury. \n\nWhen you have temporary hit points and take damage, the temporary hit points are lost first, and any leftover damage carries over to your normal hit points. For example, if you have 5 temporary hit points and take 7 damage, you lose the temporary hit points and then take 2 damage. \n\nBecause temporary hit points are separate from your actual hit points, they can exceed your hit point maximum. A character can, therefore, be at full hit points and receive temporary hit points.",
    },
    {
      id: 77,
      name: "Saving Throws",
      description:
        "<p>A saving throw  also called a save  represents an attempt to resist a spell, a trap, a poison, a disease, or a similar threat. You dont normally decide to make a saving throw; you are forced to make one because your character or monster is at risk of harm.</p>\n<p>To make a saving throw, roll a d20 and add the appropriate ability modifier. For example, you use your Dexterity modifier for a Dexterity saving throw.</p>\n<p>A saving throw can be modified by a situational bonus or penalty and can be affected by advantage and disadvantage, as determined by the DM.</p>\n<p>Each class gives proficiency in at least two saving throws. The wizard, for example, is proficient in Intelligence saves. As with skill proficiencies, proficiency in a saving throw lets a character add his or her proficiency bonus to saving throws made using a particular ability score. Some monsters have saving throw proficiencies as well.</p>\n<p>The Difficulty Class for a saving throw is determined by the effect that causes it. For example, the DC for a saving throw allowed by a spell is determined by the casters spellcasting ability and proficiency bonus.</p>\n<p>The result of a successful or failed saving throw is also detailed in the effect that allows the save. Usually, a successful save means that a creature suffers no harm, or reduced harm, from an effect.</p>",
    },
    {
      id: 78,
      name: "Senses (Passive Checks)",
      description:
        '<h3 id="PassiveChecks">Passive Checks</h3>\n<p>A passive check is a special kind of ability check that doesn\'t involve any die rolls. Such a check can represent the average result for a task done repeatedly, such as searching for secret doors over and over again, or can be used when the DM wants to secretly determine whether the characters succeed at something without rolling dice, such as noticing a hidden monster.</p>\n<p>Here\'s how to determine a character\'s total for a passive check:</p>\n<p><strong>10 + all modifiers that normally apply to the check</strong></p>\n<p>If the character has advantage on the check, add 5. For disadvantage, subtract 5. The game refers to a passive check total as a <strong>score</strong>.</p>\n<p>For example, if a 1st-level character has a Wisdom of 15 and proficiency in Perception, he or she has a passive Wisdom (Perception) score of 14.</p>\n<p>The rules on hiding in the <a href="https://www.dndbeyond.com/compendium/rules/phb/using-ability-scores#Dexterity">Dexterity</a> section below rely on passive checks, as do the exploration rules in chapter 8, <a href="https://www.dndbeyond.com/compendium/rules/phb/adventuring">Adventuring</a><span class="No-Break">.</span></p>',
    },
    {
      id: 79,
      name: "Initiative",
      description:
        "<p>Initiative determines the order of turns during combat. When combat starts, every participant makes a Dexterity check to determine their place in the initiative order. The DM makes one roll for an entire group of identical creatures, so each member of the group acts at the same time.</p>\n<p>The DM ranks the combatants in order from the one with the highest Dexterity check total to the one with the lowest. This is the order (called the initiative order) in which they act during each round. The initiative order remains the same from round to round.</p>\n<p>If a tie occurs, the DM decides the order among tied DM-controlled creatures, and the players decide the order among their tied characters. The DM can decide the order if the tie is between a monster and a player character. Optionally, the DM can have the tied characters and monsters each roll a d20 to determine the order, highest roll going first.</p>",
    },
    {
      id: 80,
      name: "Inspiration",
      description:
        '<p>Inspiration is a rule the game master can use to reward you for playing your character in a way thats true to his or her personality traits, ideal, bond, and flaw. By using inspiration, you can draw on your personality trait of compassion for the downtrodden to give you an edge in negotiating with the Beggar Prince. Or inspiration can let you call on your bond to the defense of your home village to push past the effect of a spell that has been laid on you.</p>\n<h3 id="GainingInspiration">Gaining Inspiration</h3>\n<p>Your DM can choose to give you inspiration for a variety of reasons. Typically, DMs award it when you play out your personality traits, give in to the drawbacks presented by a flaw or bond, and otherwise portray your character in a compelling way. Your DM will tell you how you can earn inspiration in the game.</p>\n<p>You either have inspiration or you dont - you cant stockpile multiple inspirations for later use.</p>\n<h3 id="UsingInspiration">Using Inspiration</h3>\n<p>If you have inspiration, you can expend it when you make an attack roll, saving throw, or ability check. Spending your inspiration gives you advantage on that roll.</p>\n<p>Additionally, if you have inspiration, you can reward another player for good roleplaying, clever thinking, or simply doing something exciting in the game. When another player character does something that really contributes to the story in a fun and interesting way, you can give up your inspiration to give that character inspiration.</p>',
    },
    {
      id: 81,
      name: "Speed",
      description:
        '<p>Every character has a speed, which is the distance in feet that the character can walk in 1 round. This number assumes short bursts of energetic movement in the midst of a life-threatening situation.</p>\n<p>While climbing or swimming, each foot of movement costs 1 extra foot (2 extra feet in difficult terrain), unless a creature has a climbing or swimming speed. At the DMs option, climbing a slippery vertical surface or one with few handholds requires a successful Strength (<span class="error"></span>Athletics<span class="error"></span>) check. Similarly, gaining any distance in rough water might require a successful Strength (<span class="error"></span>Athletics<span class="error"></span>) check.</p>\n<p>Your Strength determines how far you can jump.</p>\n<p><b>Long Jump.</b>&nbsp;When you make a long jump, you cover a number of feet up to your Strength score if you move at least 10 feet on foot immediately before the jump. When you make a standing long jump, you can leap only half that distance. Either way, each foot you clear on the jump costs a foot of movement.</p>\n<p>This rule assumes that the height of your jump doesn\'t matter, such as a jump across a stream or chasm. At your DM\'s option, you must succeed on a DC 10 Strength (Athletics) check to clear a low obstacle (no taller than a quarter of the jump\'s distance), such as a hedge or low wall. Otherwise, you hit it.</p>\n<p>When you land in difficult terrain, you must succeed on a DC 10 Dexterity (Acrobatics) check to land on your feet. Otherwise, you land prone.</p>\n<p><b>High Jump.</b>&nbsp;When you make a high jump, you leap into the air a number of feet equal to 3 + your Strength modifier (minimum of 0 feet) if you move at least 10 feet on foot immediately before the jump. When you make a standing high jump, you can jump only half that distance. Either way, each foot you clear on the jump costs a foot of movement. In some circumstances, your DM might allow you to make a Strength (Athletics) check to jump higher than you normally can.</p>\n<p>You can extend your arms half your height above yourself during the jump. Thus, you can reach above you a distance equal to the height of the jump plus 1 1/2 times your height.</p>',
    },
    {
      id: 82,
      name: "Senses",
      description:
        "<p><b>Passive Checks</b><br>A passive check is a special kind of ability check that doesn't involve any die rolls. Such a check can represent the average result for a task done repeatedly, such as searching for secret doors over and over again, or can be used when the DM wants to secretly determine whether the characters succeed at something without rolling dice, such as noticing a hidden monster.</p>\n<p>Special senses are described below.</p>\n<p><b>Blindsight</b><br>A monster with blindsight can perceive its surroundings without relying on sight, within a specific radius.</p>\n<p>Creatures without eyes, such as grimlocks and gray oozes, typically have this special sense, as do creatures with echolocation or heightened senses, such as bats and true dragons.</p>\n<p>If a monster is naturally blind, it has a parenthetical note to this effect, indicating that the radius of its blindsight defines the maximum range of its perception.</p>\n<p><b>Darkvision</b><br>A monster with darkvision can see in the dark within a specific radius. The monster can see in dim light within the radius as if it were bright light, and in darkness as if it were dim light. The monster can't discern color in darkness, only shades of gray. Many creatures that live underground have this special sense.</p>\n<p><b>Tremorsense</b><br>A monster with tremorsense can detect and pinpoint the origin of vibrations within a specific radius, provided that the monster and the source of the vibrations are in contact with the same ground or substance.</p>\n<p>Tremorsense can't be used to detect flying or incorporeal creatures. Many burrowing creatures, such as ankhegs, have this special sense.</p>\n<p><b>Truesight</b><br>A monster with truesight can, out to a specific range, see in normal and magical darkness, see invisible creatures and objects, automatically detect visual illusions and succeed on saving throws against them, and perceive the original form of a shapechanger or a creature that is transformed by magic. Furthermore, the monster can see into the Ethereal Plane within the same range.</p>",
    },
    {
      id: 83,
      name: "Half Cover",
      description:
        "A target with half cover has a +2 bonus to AC and Dexterity saving throws. A target has half cover if an obstacle blocks at least half of its body. The obstacle might be a low wall, a large piece of furniture, a narrow tree trunk, or a creature, whether that creature is an enemy or a friend.",
    },
    {
      id: 84,
      name: "Three-Quarters Cover",
      description:
        "A target with three-quarters cover has a +5 bonus to AC and Dexterity saving throws. A target has three-quarters cover if about three-quarters of it is covered by an obstacle. The obstacle might be a portcullis, an arrow slit, or a thick tree trunk.",
    },
    {
      id: 85,
      name: "Total Cover",
      description:
        "A target with total cover cannot be targeted directly by an attack or a spell, although some spells can reach such a target by including it in an area of effect. A target has total cover if it is completely concealed by an obstacle.",
    },
    {
      id: 86,
      name: "Difficult Terrain",
      description:
        "You move at half speed in difficult terrain--moving 1 foot in difficult terrain costs 2 feet of speed--so you can cover only half the normal distance in a minute, an hour, or a day.",
    },
    {
      id: 87,
      name: "Falling",
      description:
        "A fall from a great height is one of the most common hazards facing an adventurer. At the end of a fall, a creature takes 1d6 bludgeoning damage for every 10 feet it fell, to a maximum of 20d6. The creature lands prone, unless it avoids taking damage from the fall.",
    },
    {
      id: 88,
      name: "Suffocating",
      description:
        "A creature can hold its breath for a number of minutes equal to 1 + its Constitution modifier (minimum of 30 seconds). When a creature runs out of breath or is choking, it can survive for a number of rounds equal to its Constitution modifier (minimum of 1 round). At the start of its next turn, it drops to 0 hit points and is dying, and it cannot regain hit points or be stabilized until it can breathe again.",
    },
    {
      id: 89,
      name: "Lightly Obscured",
      description:
        "In a lightly obscured area, such as dim light, patchy fog, or moderate foliage, creatures have disadvantage on Wisdom (Perception) checks that rely on sight.",
    },
    {
      id: 90,
      name: "Heavily Obscured",
      description:
        "A heavily obscured area--such as darkness, opaque fog, or dense foliage--blocks vision entirely. A creature effectively suffers from the blinded condition when trying to see something in that area.",
    },
    {
      id: 91,
      name: "Climbing Swimming Crawling",
      description:
        "Each foot of movement costs 1 extra foot (2 extra feet in difficult terrain) when youre climbing, swimming, or crawling. You ignore this extra cost if you have a climbing speed and use it to climb or a swimming speed and use it to swim. At the DMs option, climbing a slippery vertical surface or one with few handholds requires a successful Strength (Athletics) check. Similarly, gaining any distance in rough water might require a successful Strength (Athletics) check.",
    },
    {
      id: 92,
      name: "Surprise",
      description:
        "If you are surprised, you cannot move or take an action on your first turn of the combat, and you cannot take a reaction until that turn ends. A member of a group can be surprised even if the other members are not.",
    },
    {
      id: 93,
      name: "Flying",
      description:
        "Flying creatures enjoy many benefits of mobility, but they must also deal with the danger of falling. If a flying creature is knocked prone, has its speed reduced to 0, or is otherwise deprived of the ability to move, the creature falls, unless it has the ability to hover or it is being held aloft by magic, such as by the fly spell.",
    },
    {
      id: 94,
      name: "Underwater",
      description:
        "When making a melee weapon attack, a creature that does not have a swimming speed (either natural or granted by magic) has disadvantage on the attack roll unless the weapon is a dagger, javelin, shortsword, spear, or trident. A ranged weapon attack automatically misses a target beyond the weapon's normal range. Even against a target within normal range, the attack roll has disadvantage unless the weapon is a crossbow, a net, or a weapon that is thrown like a javelin (including a spear, trident, or dart). Creatures and objects that are fully immersed in water have resistance to fire damage.",
    },
    {
      id: 96,
      name: "Advantage",
      description:
        "Sometimes a special ability or spell tells you that you have advantage or disadvantage on an ability check, a saving throw, or an attack roll. When that happens, you roll a second d20 when you make the roll. Use the higher of the two rolls if you have advantage.",
    },
    {
      id: 98,
      name: "Disadvantage",
      description:
        "Sometimes a special ability or spell tells you that you have advantage or disadvantage on an ability check, a saving throw, or an attack roll. When that happens, you roll a second d20 when you make the roll. Use the lower roll if you have disadvantage.",
    },
  ],
  additionalLevelTypes: [
    { id: 1, name: "Additional Targets", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 3, name: "Extended Duration", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 9, name: "Extended Area", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    {
      id: 11,
      name: "Additional Creatures",
      prerequisite: null,
      description: "",
      requiredLevel: null,
      displayOrder: null,
    },
    { id: 12, name: "Special", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 15, name: "Additional Points", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 16, name: "Additional Count", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 17, name: "Extended Range", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
  ],
  weaponProperties: [
    {
      id: 1,
      name: "Ammunition",
      prerequisite: null,
      description:
        'You can use a weapon that has the ammunition property to make a ranged attack only if you have ammunition to fire from the weapon. Each time you attack with the weapon, you expend one piece of ammunition. Drawing the ammunition from a quiver, case, or other container is part of the attack (you need a free hand to load a one-handed weapon). At the end of the battle, you can recover half your expended ammunition by taking a minute to search the battlefield. \nIf you use a weapon that has the ammunition property to make a melee attack, you treat the weapon as an improvised weapon (see "Improvised Weapons" later in the section). A sling must be loaded to deal any damage when used in this way. ',
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 2,
      name: "Finesse",
      prerequisite: null,
      description:
        "When making an attack with a finesse weapon, you use your choice of your Strength or Dexterity modifier for the attack and damage rolls. You must use the same modifier for both rolls. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 3,
      name: "Heavy",
      prerequisite: null,
      description:
        "Creatures that are Small or Tiny have disadvantage on attack rolls with heavy weapons. A heavy weapon's size and bulk make it too large for a Small or Tiny creature to use effectively.",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 4,
      name: "Light",
      prerequisite: null,
      description:
        "A light weapon is small and easy to handle, making it ideal for use when fighting with two weapons. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 5,
      name: "Loading",
      prerequisite: null,
      description:
        "Because of the time required to load this weapon, you can fire only one piece of ammunition from it when you use an action, bonus action, or reaction to fire it, regardless of the number of attacks you can normally make. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 7,
      name: "Range",
      prerequisite: null,
      description:
        "A weapon that can be used to make a ranged attack has a range in parentheses after the ammunition or thrown property. The range lists two numbers. The first is the weapon's normal range in feet, and the second indicates the weapon's long range. When attacking a target beyond normal range, you have disadvantage on the attack roll. You can't attack a target beyond the weapon's long range. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 8,
      name: "Reach",
      prerequisite: null,
      description:
        "This weapon adds 5 feet to your reach when you attack with it, as well as when determining your reach for opportunity attacks with it. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 9,
      name: "Special",
      prerequisite: null,
      description:
        "A weapon with the special property has unusual rules governing its use, explained in the weapon's description .",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 10,
      name: "Thrown",
      prerequisite: null,
      description:
        "If a weapon has the thrown property, you can throw the weapon to make a ranged attack. If the weapon is a melee weapon, you use the same ability modifier for that attack roll and damage roll that you would use for a melee attack with the weapon. For example, if you throw a handaxe, you use your Strength, but if you throw a dagger, you can use either your Strength or your Dexterity, since the dagger has the finesse property. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 11,
      name: "Two-Handed",
      prerequisite: null,
      description: "This weapon requires two hands when you attack with it. ",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 12,
      name: "Versatile",
      prerequisite: null,
      description:
        "This weapon can be used with one or two hands. A damage value in parentheses appears with the property--the damage when the weapon is used with two hands to make a melee attack.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 13,
      name: "Ammunition (Firearms)",
      prerequisite: null,
      description:
        "The ammunition of a firearm is destroyed upon use. Renaissance and modern firearms use bullets. Futuristic firearms are powered by a special type of ammunition called energy cells. An energy cell contains enough power for all the shots its firearm can make.",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 14,
      name: "Burst Fire",
      prerequisite: null,
      description:
        "A weapon that has the burst fire property can make a normal single-target attack, or it can spray a 10-foot-cube area within normal range with shots. Each creature in the area must succeed on a DC 15 Dexterity saving throw or take the weapons normal damage. This action uses ten pieces of ammunition.",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 15,
      name: "Reload",
      prerequisite: null,
      description:
        "A limited number of shots can be made with a weapon that has the reload property. A character must then reload it using an action or a bonus action (the characters choice).",
      requiredLevel: null,
      displayOrder: null,
    },
    { id: 16, name: "Misfire", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 17, name: "Explosive", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
  ],
  aoeTypes: [
    {
      id: 1,
      name: "Cone",
      prerequisite: null,
      description:
        "A cone extends in a direction you choose from its point of origin. A cone's width at a given point along its length is equal to that point's distance from the point of origin. A cone's area of effect specifies its maximum length. \nA cone's point of origin is not included in the cone's area of effect, unless you decide otherwise.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 2,
      name: "Cube",
      prerequisite: null,
      description:
        "You select a cube's point of origin, which lies anywhere on a face of the cubic effect. The cube's size is expressed as the length of each side. \nA cube's point of origin is not included in the cube's area of effect, unless you decide otherwise.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 3,
      name: "Cylinder",
      prerequisite: null,
      description:
        "A cylinder's point of origin is the center of a circle of a particular radius, as given in the spell description. The circle must either be on the ground or at the height of the spell effect. The energy in a cylinder expands in straight lines from the point of origin to the perimeter of the circle, forming the base of the cylinder. The spell's effect then shoots up from the base or down from the top, to a distance equal to the height of the cylinder. \nA cylinder's point of origin is included in the cylinder's area of effect.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 4,
      name: "Line",
      prerequisite: null,
      description:
        "A line extends from its point of origin in a straight path up to its length and covers an area defined by its width. \nA line's point of origin is not included in the line's area of effect, unless you decide otherwise.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    {
      id: 5,
      name: "Sphere",
      prerequisite: null,
      description:
        "You select a sphere's point of origin, and the sphere extends outward from that point. The sphere's size is expressed as a radius in feet that extends from the point. \nA sphere's point of origin is included in the sphere's area of effect.\n\n",
      requiredLevel: null,
      displayOrder: null,
    },
    { id: 9, name: "Square", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
    { id: 13, name: "Square Feet", prerequisite: null, description: "", requiredLevel: null, displayOrder: null },
  ],
  lifestyles: [
    {
      id: 1,
      name: "Wretched",
      description:
        "You live in inhumane conditions. With no place to call home, you shelter wherever you can, sneaking into barns, huddling in old crates, and relying on the good graces of people better off than you. A wretched lifestyle presents abundant dangers. Violence, disease, and hunger follow you wherever you go. Other wretched people covet your armor, weapons, and adventuring gear, which represent a fortune by their standards. You are beneath the notice of most people. ",
      cost: "-",
    },
    {
      id: 3,
      name: "Squalid",
      description:
        "You live in a leaky stable, a mud-floored hut just outside town, or a vermin-infested boarding house in the worst part of town. You have shelter from the elements, but you live in a desperate and often violent environment, in places rife with disease, hunger, and misfortune. You are beneath the notice of most people, and you have few legal protections. Most people at this lifestyle level have suffered some terrible setback. They might be disturbed, marked as exiles, or suffer from disease. ",
      cost: "1SP",
    },
    {
      id: 4,
      name: "Poor",
      description:
        "A poor lifestyle means going without the comforts available in a stable community. Simple food and lodgings, threadbare clothing, and unpredictable conditions result in a sufficient, though probably unpleasant, experience. Your accommodations might be a room in a flophouse or in the common room above a tavern. You benefit from some legal protections, but you still have to contend with violence, crime, and disease. People at this lifestyle level tend to be unskilled laborers, costermongers, peddlers, thieves, mercenaries, and other disreputable types. ",
      cost: "2SP",
    },
    {
      id: 5,
      name: "Modest",
      description:
        "A modest lifestyle keeps you out of the slums and ensures that you can maintain your equipment. You live in an older part of town, renting a room in a boarding house, inn, or temple. You don't go hungry or thirsty, and your living conditions are clean, if simple. Ordinary people living modest lifestyles include soldiers with families, laborers, students, priests, hedge wizards, and the like.",
      cost: "1GP",
    },
    {
      id: 6,
      name: "Comfortable",
      description:
        "Choosing a comfortable lifestyle means that you can afford nicer clothing and can easily maintain your equipment. You live in a small cottage in a middle-class neighborhood or in a private room at a fine inn. You associate with merchants, skilled tradespeople, and military officers. ",
      cost: "2GP",
    },
    {
      id: 7,
      name: "Wealthy",
      description:
        "Choosing a wealthy lifestyle means living a life of luxury, though you might not have achieved the social status associated with the old money of nobility or royalty. You live a lifestyle comparable to that of a highly successful merchant, a favored servant of the royalty, or the owner of a few small businesses. You have respectable lodgings, usually a spacious home in a good part of town or a comfortable suite at a fine inn. You likely have a small staff of servants. ",
      cost: "4GP",
    },
    {
      id: 8,
      name: "Aristocratic",
      description:
        "You live a life of plenty and comfort. You move in circles populated by the most powerful people in the community. You have excellent lodgings, perhaps a townhouse in the nicest part of town or rooms in the finest inn. You dine at the best restaurants, retain the most skilled and fashionable tailor, and have servants attending to your every need. You receive invitations to the social gatherings of the rich and powerful, and spend evenings in the company of politicians, guild leaders, high priests, and nobility. You must also contend with the highest levels of deceit and treachery. The wealthier you are, the greater the chance you will be drawn into political intrigue as a pawn or participant.\n\n",
      cost: "10GP minimum",
    },
  ],
  conditions: [
    {
      definition: {
        id: 1,
        entityTypeId: 1737492944,
        name: "Blinded",
        type: 1,
        description:
          "<ul>\n<li>A blinded creature can't see and automatically fails any ability check that requires sight.</li>\n<li>Attack rolls against the creature have advantage, and the creature's attack rolls have disadvantage.</li>\n</ul>",
        slug: "blinded",
        levels: [],
      },
    },
    {
      definition: {
        id: 2,
        entityTypeId: 1737492944,
        name: "Charmed",
        type: 1,
        description:
          "<ul>\n<li>A charmed creature can't attack the charmer or target the charmer with harmful abilities or magical effects.</li>\n<li>The charmer has advantage on any ability check to interact socially with the creature.</li>\n</ul>",
        slug: "charmed",
        levels: [],
      },
    },
    {
      definition: {
        id: 3,
        entityTypeId: 1737492944,
        name: "Deafened",
        type: 1,
        description:
          "<ul>\n<li>A deafened creature can't hear and automatically fails any ability check that requires hearing.</li>\n</ul>",
        slug: "deafened",
        levels: [],
      },
    },
    {
      definition: {
        id: 4,
        entityTypeId: 1737492944,
        name: "Exhaustion",
        type: 2,
        description:
          '<p>Some special abilities and environmental hazards, such as starvation and the long-term effects of freezing or scorching temperatures, can lead to a special condition called exhaustion. Exhaustion is measured in six levels. An effect can give a creature one or more levels of exhaustion, as specified in the effect\'s description.</p>\n<table class="exhaustion-levels">\n<thead>\n<tr>\n<th class="exhaustionlevel">Level</th>\n<th>Effect</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td style="text-align: left">Disadvantage on ability checks</td>\n</tr>\n<tr>\n<td>2</td>\n<td style="text-align: left">Speed halved</td>\n</tr>\n<tr>\n<td>3</td>\n<td style="text-align: left">Disadvantage on attack rolls and saving throws</td>\n</tr>\n<tr>\n<td>4</td>\n<td style="text-align: left">Hit point maximum halved</td>\n</tr>\n<tr>\n<td>5</td>\n<td style="text-align: left">Speed reduced to 0</td>\n</tr>\n<tr>\n<td>6</td>\n<td style="text-align: left">Death</td>\n</tr>\n</tbody>\n</table>\n<p>If an already exhausted creature suffers another effect that causes exhaustion, its current level of exhaustion increases by the amount specified in the effect\'s description.</p>\n<p>A creature suffers the effect of its current level of exhaustion as well as all lower levels. For example, a creature suffering level 2 exhaustion has its speed halved and has disadvantage on ability checks.</p>\n<p>An effect that removes exhaustion reduces its level as specified in the effect\'s description, with all exhaustion effects ending if a creature\'s exhaustion level is reduced below 1. <br> Finishing a long rest reduces a creature\'s exhaustion level by 1, provided that the creature has also ingested some food and drink.</p>',
        slug: "exhaustion",
        levels: [
          { definition: { id: 1, entityTypeId: 2064013312, level: 1, effect: "Disadvantage on ability checks" } },
          { definition: { id: 2, entityTypeId: 2064013312, level: 2, effect: "Speed halved" } },
          {
            definition: {
              id: 3,
              entityTypeId: 2064013312,
              level: 3,
              effect: "Disadvantage on attack rolls and saving throws",
            },
          },
          { definition: { id: 4, entityTypeId: 2064013312, level: 4, effect: "Hit point maximum halved" } },
          { definition: { id: 5, entityTypeId: 2064013312, level: 5, effect: "Speed reduced to 0" } },
          { definition: { id: 6, entityTypeId: 2064013312, level: 6, effect: "Death" } },
        ],
      },
    },
    {
      definition: {
        id: 5,
        entityTypeId: 1737492944,
        name: "Frightened",
        type: 1,
        description:
          "<ul>\n<li>A frightened creature has disadvantage on ability checks and attack rolls while the source of its fear is within line of sight.</li>\n<li>The creature can't willingly move closer to the source of its fear.</li>\n</ul>",
        slug: "frightened",
        levels: [],
      },
    },
    {
      definition: {
        id: 6,
        entityTypeId: 1737492944,
        name: "Grappled",
        type: 1,
        description:
          "<ul>\n<li>A grappled creature's speed becomes 0, and it can't benefit from any bonus to its speed.</li>\n<li>The condition ends if the grappler is incapacitated (see the condition).</li>\n<li>The condition also ends if an effect removes the grappled creature from the reach of the grappler or grappling effect, such as when a creature is hurled away by the <strong>thunder-wave</strong> spell.</li>\n</ul>",
        slug: "grappled",
        levels: [],
      },
    },
    {
      definition: {
        id: 7,
        entityTypeId: 1737492944,
        name: "Incapacitated",
        type: 1,
        description: "<ul>\n<li>An incapacitated creature can't take actions or reactions.</li>\n</ul>",
        slug: "incapacitated",
        levels: [],
      },
    },
    {
      definition: {
        id: 8,
        entityTypeId: 1737492944,
        name: "Invisible",
        type: 1,
        description:
          "<ul>\n<li>An invisible creature is impossible to see without the aid of magic or a special sense. For the purpose of hiding, the creature is heavily obscured. The creature's location can be detected by any noise it makes or any tracks it leaves.</li>\n<li>Attack rolls against the creature have disadvantage, and the creature's attack rolls have advantage.</li>\n</ul>",
        slug: "invisible",
        levels: [],
      },
    },
    {
      definition: {
        id: 9,
        entityTypeId: 1737492944,
        name: "Paralyzed",
        type: 1,
        description:
          "<ul>\n<li>A paralyzed creature is incapacitated (see the condition) and can't move or speak.</li>\n<li>The creature automatically fails Strength and Dexterity saving throws. Attack rolls against the creature have advantage.</li>\n<li>Any attack that hits the creature is a critical hit if the attacker is within 5 feet of the creature.</li>\n</ul>",
        slug: "paralyzed",
        levels: [],
      },
    },
    {
      definition: {
        id: 10,
        entityTypeId: 1737492944,
        name: "Petrified",
        type: 1,
        description:
          "<ul>\n<li>A petrified creature is transformed, along with any nonmagical object it is wearing or carrying, into a solid inanimate substance (usually stone). Its weight increases by a factor of ten, and it ceases aging.</li>\n<li>The creature is incapacitated (see the condition), can't move or speak, and is unaware of its surroundings.</li>\n<li>Attack rolls against the creature have advantage.</li>\n<li>The creature automatically fails Strength and Dexterity saving throws.</li>\n<li>The creature has resistance to all damage.</li>\n<li>The creature is immune to poison and disease, although a poison or disease already in its system is suspended, not neutralized.</li>\n</ul>",
        slug: "petrified",
        levels: [],
      },
    },
    {
      definition: {
        id: 11,
        entityTypeId: 1737492944,
        name: "Poisoned",
        type: 1,
        description: "<ul>\n<li>A poisoned creature has disadvantage on attack rolls and ability checks.</li>\n</ul>",
        slug: "poisoned",
        levels: [],
      },
    },
    {
      definition: {
        id: 12,
        entityTypeId: 1737492944,
        name: "Prone",
        type: 1,
        description:
          "<ul>\n<li>A prone creature's only movement option is to crawl, unless it stands up and thereby ends the condition.</li>\n<li>The creature has disadvantage on attack rolls.</li>\n<li>An attack roll against the creature has advantage if the attacker is within 5 feet of the creature. Otherwise, the attack roll has disadvantage.</li>\n</ul>",
        slug: "prone",
        levels: [],
      },
    },
    {
      definition: {
        id: 13,
        entityTypeId: 1737492944,
        name: "Restrained",
        type: 1,
        description:
          "<ul>\n<li>A restrained creature's speed becomes 0, and it can't benefit from any bonus to its speed.</li>\n<li>Attack rolls against the creature have advantage, and the creature's attack rolls have disadvantage.</li>\n<li>The creature has disadvantage on Dexterity saving throws.</li>\n</ul>",
        slug: "restrained",
        levels: [],
      },
    },
    {
      definition: {
        id: 14,
        entityTypeId: 1737492944,
        name: "Stunned",
        type: 1,
        description:
          "<ul>\n<li>A stunned creature is incapacitated (see the condition), can't move, and can speak only falteringly.</li>\n<li>The creature automatically fails Strength and Dexterity saving throws.</li>\n<li>Attack rolls against the creature have advantage.</li>\n</ul>",
        slug: "stunned",
        levels: [],
      },
    },
    {
      definition: {
        id: 15,
        entityTypeId: 1737492944,
        name: "Unconscious",
        type: 1,
        description:
          "<ul>\n<li>An unconscious creature is incapacitated (see the condition), can't move or speak, and is unaware of its surroundings</li>\n<li>The creature drops whatever it's holding and falls prone.</li>\n<li>The creature automatically fails Strength and Dexterity saving throws.</li>\n<li>Attack rolls against the creature have advantage.</li>\n<li>Any attack that hits the creature is a critical hit if the attacker is within 5 feet of the creature.</li>\n</ul>",
        slug: "unconscious",
        levels: [],
      },
    },
  ],
  damageAdjustments: [
    { id: 1, name: "Bludgeoning", type: 1, slug: "bludgeoning", isMulti: false, displayOrder: 2 },
    { id: 2, name: "Piercing", type: 1, slug: "piercing", isMulti: false, displayOrder: 8 },
    { id: 3, name: "Slashing", type: 1, slug: "slashing", isMulti: false, displayOrder: 12 },
    { id: 4, name: "Lightning", type: 1, slug: "lightning", isMulti: false, displayOrder: 6 },
    { id: 5, name: "Thunder", type: 1, slug: "thunder", isMulti: false, displayOrder: 13 },
    { id: 6, name: "Poison", type: 1, slug: "poison", isMulti: false, displayOrder: 9 },
    { id: 7, name: "Cold", type: 1, slug: "cold", isMulti: false, displayOrder: 3 },
    { id: 8, name: "Radiant", type: 1, slug: "radiant", isMulti: false, displayOrder: 11 },
    { id: 9, name: "Fire", type: 1, slug: "fire", isMulti: false, displayOrder: 4 },
    { id: 10, name: "Necrotic", type: 1, slug: "necrotic", isMulti: false, displayOrder: 7 },
    { id: 11, name: "Acid", type: 1, slug: "acid", isMulti: false, displayOrder: 1 },
    { id: 12, name: "Psychic", type: 1, slug: "psychic", isMulti: false, displayOrder: 10 },
    {
      id: 13,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks",
      isMulti: true,
      displayOrder: 14,
    },
    {
      id: 14,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Silvered",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-silvered",
      isMulti: true,
      displayOrder: 15,
    },
    {
      id: 15,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Adamantine",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine",
      isMulti: true,
      displayOrder: 16,
    },
    {
      id: 16,
      name: "Piercing and Slashing from Nonmagical Attacks that aren't Adamantine",
      type: 1,
      slug: "piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine",
      isMulti: true,
      displayOrder: 17,
    },
    { id: 17, name: "Bludgeoning", type: 2, slug: "bludgeoning", isMulti: false, displayOrder: 2 },
    { id: 18, name: "Piercing", type: 2, slug: "piercing", isMulti: false, displayOrder: 8 },
    { id: 19, name: "Slashing", type: 2, slug: "slashing", isMulti: false, displayOrder: 12 },
    { id: 20, name: "Lightning", type: 2, slug: "lightning", isMulti: false, displayOrder: 6 },
    { id: 21, name: "Thunder", type: 2, slug: "thunder", isMulti: false, displayOrder: 13 },
    { id: 22, name: "Poison", type: 2, slug: "poison", isMulti: false, displayOrder: 9 },
    { id: 23, name: "Cold", type: 2, slug: "cold", isMulti: false, displayOrder: 3 },
    { id: 24, name: "Radiant", type: 2, slug: "radiant", isMulti: false, displayOrder: 11 },
    { id: 25, name: "Fire", type: 2, slug: "fire", isMulti: false, displayOrder: 4 },
    { id: 26, name: "Necrotic", type: 2, slug: "necrotic", isMulti: false, displayOrder: 7 },
    { id: 27, name: "Acid", type: 2, slug: "acid", isMulti: false, displayOrder: 1 },
    { id: 28, name: "Psychic", type: 2, slug: "psychic", isMulti: false, displayOrder: 10 },
    {
      id: 29,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks",
      isMulti: true,
      displayOrder: 14,
    },
    {
      id: 30,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Silvered",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical",
      isMulti: true,
      displayOrder: 16,
    },
    {
      id: 31,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Adamantine",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical",
      isMulti: true,
      displayOrder: 15,
    },
    {
      id: 32,
      name: "Piercing and Slashing from Nonmagical Attacks that aren't Adamantine",
      type: 2,
      slug: "piercing-and-slashing-from-nonmagical-attacks-that",
      isMulti: true,
      displayOrder: 17,
    },
    { id: 33, name: "Bludgeoning", type: 3, slug: "bludgeoning", isMulti: false, displayOrder: 2 },
    { id: 34, name: "Piercing", type: 3, slug: "piercing", isMulti: false, displayOrder: 8 },
    { id: 35, name: "Slashing", type: 3, slug: "slashing", isMulti: false, displayOrder: 12 },
    { id: 36, name: "Lightning", type: 3, slug: "lightning", isMulti: false, displayOrder: 6 },
    { id: 37, name: "Thunder", type: 3, slug: "thunder", isMulti: false, displayOrder: 13 },
    { id: 38, name: "Poison", type: 3, slug: "poison", isMulti: false, displayOrder: 9 },
    { id: 39, name: "Cold", type: 3, slug: "cold", isMulti: false, displayOrder: 3 },
    { id: 40, name: "Radiant", type: 3, slug: "radiant", isMulti: false, displayOrder: 11 },
    { id: 41, name: "Fire", type: 3, slug: "fire", isMulti: false, displayOrder: 4 },
    { id: 42, name: "Necrotic", type: 3, slug: "necrotic", isMulti: false, displayOrder: 7 },
    { id: 43, name: "Acid", type: 3, slug: "acid", isMulti: false, displayOrder: 1 },
    { id: 44, name: "Psychic", type: 3, slug: "psychic", isMulti: false, displayOrder: 10 },
    {
      id: 45,
      name: "Piercing from Magic Weapons Wielded by Good Creatures",
      type: 3,
      slug: "piercing-from-magic-weapons-wielded-by-good",
      isMulti: true,
      displayOrder: 14,
    },
    {
      id: 46,
      name: "Bludgeoning, Piercing, and Slashing from Magic Weapons",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-magic-weapons",
      isMulti: true,
      displayOrder: 18,
    },
    { id: 47, name: "Force", type: 1, slug: "force", isMulti: false, displayOrder: 5 },
    { id: 48, name: "Force", type: 2, slug: "force", isMulti: false, displayOrder: 5 },
    { id: 49, name: "Force", type: 3, slug: "force", isMulti: false, displayOrder: 5 },
    {
      id: 50,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks while in Dim Light or Darkness",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-while-in-dim-light-or-darkness",
      isMulti: true,
      displayOrder: 19,
    },
    { id: 51, name: "Ranged Attacks", type: 1, slug: "ranged-attacks", isMulti: false, displayOrder: 20 },
    { id: 52, name: "Damage Dealt By Traps", type: 1, slug: "damage-dealt-by-traps", isMulti: false, displayOrder: 21 },
    { id: 53, name: "All", type: 1, slug: "all", isMulti: true, displayOrder: 22 },
    {
      id: 54,
      name: "Bludgeoning from non magical attacks",
      type: 1,
      slug: "bludgeoning-from-non-magical-attacks",
      isMulti: false,
      displayOrder: 23,
    },
    {
      id: 55,
      name: "Bludgeoning, Piercing, and Slashing from Metal Weapons",
      type: 2,
      slug: "slashing-from-metal-weapons",
      isMulti: true,
      displayOrder: 18,
    },
    {
      id: 56,
      name: "Bludgeoning, Piercing, and Slashing while in Dim Light or Darkness",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-while-in-dim-or-light-darkness",
      isMulti: true,
      displayOrder: 24,
    },
    { id: 57, name: "Damage from Spells", type: 1, slug: "damage-from-spells", isMulti: false, displayOrder: 25 },
    {
      id: 60,
      name: "Bludgeoning, Piercing, and Slashing from Nonmagical Attacks that aren't Adamantine or Silvered",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine-or-silvered",
      isMulti: true,
      displayOrder: 19,
    },
    {
      id: 61,
      name: "Nonmagical Bludgeoning, Piercing, and Slashing (from Stoneskin)",
      type: 1,
      slug: "nonmagical-bludgeoning-piercing-and-slashing-from-stoneskin",
      isMulti: true,
      displayOrder: 27,
    },
    {
      id: 62,
      name: "All damage but Force, Radiant, and Psychic",
      type: 1,
      slug: "all-damage-but-force-radiant-and-psychic",
      isMulti: true,
      displayOrder: 29,
    },
    {
      id: 63,
      name: "Petrified (Aberrant Armor Only)",
      type: 2,
      slug: "petrified-aberrant-armor-only",
      isMulti: false,
      displayOrder: 28,
    },
    {
      id: 64,
      name: "Slashing from a Vorpal Sword",
      type: 3,
      slug: "slashing-from-a-vorpal-sword",
      isMulti: false,
      displayOrder: 30,
    },
    {
      id: 65,
      name: "Damage of the type matching the animated breath's form (acid, cold, fire, lightning, or poison)",
      type: 1,
      slug: "damage-of-the-type-matching-the-animated-breaths-form-acid-cold-fire-lightning-or-poison",
      isMulti: false,
      displayOrder: 31,
    },
    {
      id: 66,
      name: "Psychic (granted by Ruidium Armor)",
      type: 1,
      slug: "psychic-granted-by-ruidium-armor",
      isMulti: false,
      displayOrder: 32,
    },
    {
      id: 67,
      name: "Bludgeoning, Piercing, and Slashing that is Nonmagical",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-that-is-nonmagical",
      isMulti: true,
      displayOrder: 29,
    },
    {
      id: 68,
      name: "One of the following: acid, cold, fire, lightning, or poison",
      type: 1,
      slug: "one-of-the-following-acid-cold-fire-lightning-or",
      isMulti: false,
      displayOrder: 33,
    },
    {
      id: 69,
      name: "Lightning (granted by darksteel greataxe)",
      type: 1,
      slug: "lightning-granted-by-darksteel-greataxe",
      isMulti: false,
      displayOrder: 34,
    },
    {
      id: 70,
      name: "Slashing and Piercing from Nonmagical Attacks",
      type: 1,
      slug: "slashing-and-piercing-from-nonmagical-attacks",
      isMulti: true,
      displayOrder: 17,
    },
    {
      id: 83,
      name: "Bludgeoning, Piercing, and Slashing from Mundane Attacks",
      type: 1,
      slug: "bludgeoning-piercing-and-slashing-from-mundane",
      isMulti: true,
      displayOrder: 36,
    },
    {
      id: 84,
      name: "Bludgeoning damage from falling",
      type: 2,
      slug: "bludgeoning-damage-from-falling",
      isMulti: false,
      displayOrder: 37,
    },
    {
      id: 85,
      name: "Bludgeoning, Piercing, and Slashing from Mundane Attacks",
      type: 2,
      slug: "bludgeoning-piercing-and-slashing-from-mundane",
      isMulti: true,
      displayOrder: 36,
    },
  ],
  statModifiers: [
    { value: 1, modifier: -5 },
    { value: 2, modifier: -4 },
    { value: 3, modifier: -4 },
    { value: 4, modifier: -3 },
    { value: 5, modifier: -3 },
    { value: 6, modifier: -2 },
    { value: 7, modifier: -2 },
    { value: 8, modifier: -1 },
    { value: 9, modifier: -1 },
    { value: 10, modifier: 0 },
    { value: 11, modifier: 0 },
    { value: 12, modifier: 1 },
    { value: 13, modifier: 1 },
    { value: 14, modifier: 2 },
    { value: 15, modifier: 2 },
    { value: 16, modifier: 3 },
    { value: 17, modifier: 3 },
    { value: 18, modifier: 4 },
    { value: 19, modifier: 4 },
    { value: 20, modifier: 5 },
    { value: 21, modifier: 5 },
    { value: 22, modifier: 6 },
    { value: 23, modifier: 6 },
    { value: 24, modifier: 7 },
    { value: 25, modifier: 7 },
    { value: 26, modifier: 8 },
    { value: 27, modifier: 8 },
    { value: 28, modifier: 9 },
    { value: 29, modifier: 9 },
    { value: 30, modifier: 10 },
  ],
  alignments: [
    {
      id: 1,
      name: "Lawful Good",
      description:
        "Lawful good (LG) creatures can be counted on to do the right thing as expected by society. Gold dragons, paladins, and most dwarves are lawful good.",
      availableToCharacter: true,
    },
    {
      id: 2,
      name: "Neutral Good",
      description:
        "Neutral good (NG) folk do the best they can to help others according to their needs. Many celestials, some cloud giants, and most gnomes are neutral good.",
      availableToCharacter: true,
    },
    {
      id: 3,
      name: "Chaotic Good",
      description:
        "Chaotic good (CG) creatures act as their conscience directs, with little regard for what others expect. Copper dragons, many elves, and unicorns are chaotic good.",
      availableToCharacter: true,
    },
    {
      id: 4,
      name: "Lawful Neutral",
      description:
        "Lawful neutral (LN) individuals act in accordance with law, tradition, or personal codes. Many monks and some wizards are lawful neutral.",
      availableToCharacter: true,
    },
    {
      id: 5,
      name: "Neutral",
      description:
        "Neutral (N) is the alignment of those who prefer to steer clear of moral questions and don't take sides, doing what seems best at the time. Lizardfolk, most druids, and many humans are neutral.",
      availableToCharacter: true,
    },
    {
      id: 6,
      name: "Chaotic Neutral",
      description:
        "Chaotic neutral (CN) creatures follow their whims, holding their personal freedom above all else. Many barbarians and rogues, and some bards, are chaotic neutral.",
      availableToCharacter: true,
    },
    {
      id: 7,
      name: "Lawful Evil",
      description:
        "Lawful evil (LE) creatures methodically take what they want, within the limits of a code of tradition, loyalty, or order. Devils, blue dragons, and hobgoblins are lawful evil.",
      availableToCharacter: true,
    },
    {
      id: 8,
      name: "Neutral Evil",
      description:
        "Neutral evil (NE) is the alignment of those who do whatever they can get away with, without compassion or qualms. Many drow, some cloud giants, and goblins are neutral evil.",
      availableToCharacter: true,
    },
    {
      id: 9,
      name: "Chaotic Evil",
      description:
        "Chaotic evil (CE) creatures act with arbitrary violence, spurred by their greed, hatred, or bloodlust. Demons, red dragons, and orcs are chaotic evil.",
      availableToCharacter: true,
    },
    { id: 10, name: "Unaligned", description: null, availableToCharacter: false },
    { id: 11, name: "Any Alignment", description: "Any Alignment", availableToCharacter: false },
    { id: 13, name: "Any Evil Alignment", description: "Any Evil Alignment", availableToCharacter: false },
    { id: 14, name: "Any Good Alignment", description: "Any Good Alignment", availableToCharacter: false },
    { id: 15, name: "Any Chaotic Alignment", description: "Any Chaotic Alignment", availableToCharacter: false },
    { id: 16, name: "Any Lawful Alignment", description: "Any Lawful Alignment", availableToCharacter: false },
    { id: 18, name: "Any Non-Good Alignment", description: "Any Non-Good Alignment", availableToCharacter: false },
    { id: 19, name: "Any Non-Lawful Alignment", description: "Any Non-Lawful Alignment", availableToCharacter: false },
    {
      id: 20,
      name: "Typically Chaotic Neutral",
      description: "Typically Chaotic Neutral",
      availableToCharacter: false,
    },
    { id: 21, name: "Typically Neutral Good", description: "Typically Neutral Good", availableToCharacter: false },
    { id: 22, name: "Typically Lawful Good", description: "Typically Lawful Good", availableToCharacter: false },
    { id: 23, name: "Typically Chaotic Evil", description: "Typically Chaotic Evil", availableToCharacter: false },
    { id: 24, name: "Typically Neutral Evil", description: "Typically Neutral Evil", availableToCharacter: false },
    { id: 25, name: "Typically Chaotic Good", description: "Typically Chaotic Good", availableToCharacter: false },
    { id: 26, name: "Typically Neutral", description: "Typically Neutral", availableToCharacter: false },
    { id: 27, name: "Typically Lawful Evil", description: "Typically Lawful Evil", availableToCharacter: false },
    { id: 28, name: "Typically Lawful Neutral", description: "Typically Lawful Neutral", availableToCharacter: false },
  ],
  sources: [
    {
      id: 1,
      name: "BR",
      description: "Basic Rules",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/136/637248073409717512.jpeg",
      sourceURL: "sources/basic-rules",
    },
    {
      id: 2,
      name: "PHB",
      description: "Player's Handbook",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/389/637248131811862290.jpeg",
      sourceURL: "sources/phb",
    },
    {
      id: 3,
      name: "DMG",
      description: "Dungeon Master's Guide",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10367/593/637245347063211867.jpeg",
      sourceURL: "sources/dmg",
    },
    {
      id: 4,
      name: "EE",
      description: "Elemental Evil Player's Companion",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/",
      sourceURL: "",
    },
    {
      id: 5,
      name: "MM",
      description: "Monster Manual",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/816/637248105832999293.jpeg",
      sourceURL: "sources/mm",
    },
    {
      id: 6,
      name: "CoS",
      description: "Curse of Strahd",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10349/296/637244603965977140.jpeg",
      sourceURL: "sources/cos",
    },
    {
      id: 7,
      name: "HotDQ",
      description: "Hoard of the Dragon Queen",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10432/68/637247937818392417.jpeg",
      sourceURL: "sources/hotdq",
    },
    {
      id: 8,
      name: "LMoP",
      description: "Lost Mine of Phandelver",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/616/637248096401764265.jpeg",
      sourceURL: "sources/lmop",
    },
    {
      id: 9,
      name: "OotA",
      description: "Out of the Abyss",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/19/735/636383500945700817.jpeg",
      sourceURL: "sources/oota",
    },
    {
      id: 10,
      name: "PotA",
      description: "Princes of the Apocalypse",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/524/637248137744435932.jpeg",
      sourceURL: "sources/pota",
    },
    {
      id: 11,
      name: "RoT",
      description: "Rise of Tiamat",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/605/637248141604547323.jpeg",
      sourceURL: "sources/rot",
    },
    {
      id: 12,
      name: "SKT",
      description: "Storm King's Thunder",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/19/740/636383501361665378.jpeg",
      sourceURL: "sources/skt",
    },
    {
      id: 13,
      name: "SCAG",
      description: "Sword Coast Adventurer's Guide",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/793/637248149475504723.jpeg",
      sourceURL: "sources/scag",
    },
    {
      id: 14,
      name: "TftYP",
      description: "Tales from the Yawning Portal",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/177/637248652153094716.jpeg",
      sourceURL: "sources/tftyp",
    },
    {
      id: 15,
      name: "VGtM",
      description: "Volo's Guide to Monsters",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/464/637248679743732719.jpeg",
      sourceURL: "sources/vgtm",
    },
    {
      id: 16,
      name: "TSC",
      description: "The Sunless Citadel",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/402/637248674372576676.jpeg",
      sourceURL: "sources/tftyp/a1",
    },
    {
      id: 17,
      name: "TFoF",
      description: "The Forge of Fury",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10436/4/637248156999902689.jpeg",
      sourceURL: "sources/tftyp/a2",
    },
    {
      id: 18,
      name: "THSoT",
      description: "The Hidden Shrine of Tamoachan",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/236/637248657347161458.jpeg",
      sourceURL: "sources/tftyp/a3",
    },
    {
      id: 19,
      name: "WPM",
      description: "White Plume Mountain",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/751/637248705560259195.jpeg",
      sourceURL: "sources/tftyp/a4",
    },
    {
      id: 20,
      name: "DiT",
      description: "Dead in Thay",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/246/637248079254127234.jpeg",
      sourceURL: "sources/tftyp/a5",
    },
    {
      id: 21,
      name: "AtG",
      description: "Against the Giants",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10433/315/637248029897296032.jpeg",
      sourceURL: "sources/tftyp/a6",
    },
    {
      id: 22,
      name: "ToH",
      description: "Tomb of Horrors",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/371/637248671854035769.jpeg",
      sourceURL: "sources/tftyp/a7",
    },
    {
      id: 25,
      name: "ToA",
      description: "Tomb of Annihilation",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/339/637248669136195626.jpeg",
      sourceURL: "sources/toa",
    },
    {
      id: 26,
      name: "CoSCO",
      description: "Curse of Strahd: Character Options",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10349/289/637244603748885696.jpeg",
      sourceURL: "",
    },
    {
      id: 27,
      name: "XGtE",
      description: "Xanathar's Guide to Everything",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/803/637248709455777906.jpeg",
      sourceURL: "sources/xgte",
    },
    {
      id: 28,
      name: "TTP",
      description: "The Tortle Package",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/39/300/636411199124473334.png",
      sourceURL: "sources/ttp",
    },
    {
      id: 29,
      name: "UA",
      description: "Unearthed Arcana",
      sourceCategoryId: 3,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/100/464/636506973225556542.png",
      sourceURL: "",
    },
    {
      id: 31,
      name: "CR",
      description: "Critical Role",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/",
      sourceURL: "",
    },
    {
      id: 33,
      name: "MToF",
      description: "Mordenkainens Tome of Foes",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/949/637248111148617766.jpeg",
      sourceURL: "sources/mtof",
    },
    {
      id: 34,
      name: "DDIA-MORD",
      description: "Rrakkma",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/319/345/636622116959280867.jpeg",
      sourceURL: "sources/ddia-mord",
    },
    {
      id: 35,
      name: "WDH",
      description: "Waterdeep: Dragon Heist",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/343/499/636632335939805190.jpeg",
      sourceURL: "sources/wdh",
    },
    {
      id: 36,
      name: "WDotMM",
      description: "Waterdeep: Dungeon of the Mad Mage",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/493/637248684031810278.jpeg",
      sourceURL: "sources/wdotmm",
    },
    {
      id: 37,
      name: "WGtE",
      description: "Wayfinder's Guide to Eberron",
      sourceCategoryId: 8,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10449/715/637248702538222765.jpeg",
      sourceURL: "sources/wgte",
    },
    {
      id: 38,
      name: "GGtR",
      description: "Guildmasters' Guide to Ravnica",
      sourceCategoryId: 7,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10369/823/637245482341163840.jpeg",
      sourceURL: "sources/ggtr",
    },
    {
      id: 40,
      name: "LLoK",
      description: "Lost Laboratory of Kwalish",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/498/637248091075319276.jpeg",
      sourceURL: "sources/llok",
    },
    {
      id: 41,
      name: "DoIP",
      description: "Dragon of Icespire Peak",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/957/637244676648122088.jpeg",
      sourceURL: "sources/doip",
    },
    {
      id: 42,
      name: "TMR",
      description: "Tactical Maps Reincarnated",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/5336/630/636850745475942698.jpeg",
      sourceURL: "",
    },
    {
      id: 43,
      name: "GoS",
      description: "Ghosts of Saltmarsh",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10370/66/637245493047936420.jpeg",
      sourceURL: "sources/gos",
    },
    {
      id: 44,
      name: "AI",
      description: "Acquisitions Incorporated",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/905/637244674570907870.jpeg",
      sourceURL: "sources/ai",
    },
    {
      id: 47,
      name: "HftT",
      description: "Hunt for the Thessalhydra",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10432/12/637247932786703735.jpeg",
      sourceURL: "sources/hftt",
    },
    {
      id: 48,
      name: "BGDiA",
      description: "Baldur's Gate: Descent into Avernus",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/927/637244675832719441.jpeg",
      sourceURL: "sources/bgdia",
    },
    {
      id: 49,
      name: "ERftLW",
      description: "Eberron: Rising from the Last War",
      sourceCategoryId: 8,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10368/6/637245381196842264.jpeg",
      sourceURL: "sources/erftlw",
    },
    {
      id: 50,
      name: "SLW",
      description: "Storm Lords Wrath",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/964/637244676927254855.jpeg",
      sourceURL: "sources/slw",
    },
    {
      id: 51,
      name: "SDW",
      description: "Sleeping Dragons Wake",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/959/637244676820916158.jpeg",
      sourceURL: "sources/sdw",
    },
    {
      id: 52,
      name: "DC",
      description: "Divine Contention",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10350/951/637244676535367295.jpeg",
      sourceURL: "sources/dc",
    },
    {
      id: 53,
      name: "SAC",
      description: "Sage Advice Compendium",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/702/637248145947271474.jpeg",
      sourceURL: "sources/sac",
    },
    {
      id: 54,
      name: "DDvRaM",
      description: "Dungeons &amp; Dragons vs. Rick and Morty",
      sourceCategoryId: 10,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10367/229/637245316031917098.jpeg",
      sourceURL: "sources/ddvram",
    },
    {
      id: 55,
      name: "LR",
      description: "Locathah Rising",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/650/637248098360957592.jpeg",
      sourceURL: "sources/lr",
    },
    {
      id: 56,
      name: "IMR",
      description: "Infernal Machine Rebuild",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/395/637248086063224834.jpeg",
      sourceURL: "sources/imr",
    },
    {
      id: 57,
      name: "MFFV1",
      description: "Mordenkainen's Fiendish Folio Volume 1",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/743/637248102793792401.jpeg",
      sourceURL: "sources/mffv1",
    },
    {
      id: 58,
      name: "SD",
      description: "Sapphire Dragon",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/899/637248153278056972.jpeg",
      sourceURL: "",
    },
    {
      id: 59,
      name: "EGtW",
      description: "Explorer's Guide to Wildemount",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10367/769/637245363413951140.jpeg",
      sourceURL: "sources/egtw",
    },
    {
      id: 60,
      name: "OGA",
      description: "One Grung Above",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10435/68/637248116464990081.jpeg",
      sourceURL: "sources/oga",
    },
    {
      id: 61,
      name: "MOoT",
      description: "Mythic Odysseys of Theros",
      sourceCategoryId: 7,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/10434/885/637248108609488365.jpeg",
      sourceURL: "sources/moot",
    },
    {
      id: 62,
      name: "WA",
      description: "Frozen Sick",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/9193/755/637200909525723425.jpeg",
      sourceURL: "sources/wa",
    },
    {
      id: 66,
      name: "IDRotF",
      description: "Icewind Dale: Rime of the Frostmaiden",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/11095/550/637278965847502335.jpeg",
      sourceURL: "sources/idrotf",
    },
    {
      id: 67,
      name: "TCoE",
      description: "Tashas Cauldron of Everything",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/13665/613/637400361423035085.jpeg",
      sourceURL: "sources/tcoe",
    },
    {
      id: 68,
      name: "CM",
      description: "Candlekeep Mysteries",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/14917/783/637456355214291364.jpeg",
      sourceURL: "sources/cm",
    },
    {
      id: 69,
      name: "VRGtR",
      description: "Van Richtens Guide to Ravenloft",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/15973/81/637496917952314322.jpeg",
      sourceURL: "sources/vrgtr",
    },
    {
      id: 79,
      name: "TWBtW",
      description: "The Wild Beyond the Witchlight",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/18223/997/637587419509160992.jpeg",
      sourceURL: "sources/twbtw",
    },
    {
      id: 80,
      name: "SACoC",
      description: "Strixhaven: A Curriculum of Chaos",
      sourceCategoryId: 7,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/18228/52/637587668398315568.jpeg",
      sourceURL: "sources/sacoc",
    },
    {
      id: 81,
      name: "FToD",
      description: "Fizban's Treasury of Dragons",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/19075/983/637620380256293999.jpeg",
      sourceURL: "sources/ftod",
    },
    {
      id: 83,
      name: "CotN",
      description: "Critical Role: Call of the Netherdeep",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/20906/943/637695655261542821.jpeg",
      sourceURL: "sources/cotn",
    },
    {
      id: 85,
      name: "MotM",
      description: "Mordenkainen Presents: Monsters of the Multiverse",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/22937/354/637776964748720726.jpeg",
      sourceURL: "sources/motm",
    },
    {
      id: 87,
      name: "JttRC",
      description: "Journeys through the Radiant Citadel",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/24454/511/637830510509865265.jpeg",
      sourceURL: "sources/jttrc",
    },
    {
      id: 89,
      name: "MCv1",
      description: "Monstrous Compendium Volume One: Spelljammer Creatures",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/25098/972/637854763136224645.jpeg",
      sourceURL: "sources/mcv1",
    },
    {
      id: 90,
      name: "SAiS",
      description: "Spelljammer: Adventures in Space",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/25228/876/637859890823057854.jpeg",
      sourceURL: "sources/sais",
    },
    {
      id: 91,
      name: "TVD",
      description: "The Vecna Dossier",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/26305/340/637901114717317528.jpeg",
      sourceURL: "sources/tvd",
    },
    {
      id: 92,
      name: "TRC",
      description: "The Radiant Citadel",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/26479/568/637907273106559243.jpeg",
      sourceURL: "sources/trc",
    },
    {
      id: 93,
      name: "SJA",
      description: "Spelljammer Academy",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/26848/192/637920417931102595.jpeg",
      sourceURL: "sources/sja",
    },
    {
      id: 94,
      name: "DoSI",
      description: "Dragons of Stormwreck Isle",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/26865/226/637921086362458107.jpeg",
      sourceURL: "sources/dosi",
    },
    {
      id: 95,
      name: "SotDQ",
      description: "Dragonlance: Shadow of the Dragon Queen",
      sourceCategoryId: 14,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/27777/666/637951679601337771.jpeg",
      sourceURL: "sources/sotdq",
    },
    {
      id: 101,
      name: "MCv2",
      description: "Monstrous Compendium Volume Two: Dragonlance Creatures",
      sourceCategoryId: 14,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/30591/814/638054153540284547.jpeg",
      sourceURL: "sources/mcv2",
    },
    {
      id: 102,
      name: "ToD",
      description: "Tyranny of Dragons",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/31000/357/638070661674299942.jpeg",
      sourceURL: "sources/tod",
    },
    {
      id: 103,
      name: "KftGV",
      description: "Keys from the Golden Vault",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/31000/595/638070671792143197.jpeg",
      sourceURL: "sources/kftgv",
    },
    {
      id: 104,
      name: "TG",
      description: "Thieves Gallery",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/32269/153/638120143799885947.jpeg",
      sourceURL: "sources/tg",
    },
    {
      id: 105,
      name: "P13",
      description: "Prisoner 13",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/31678/948/638097617627683009.jpeg",
      sourceURL: "sources/p13",
    },
    {
      id: 109,
      name: "TBoMT",
      description: "The Book of Many Things ",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/34541/95/638205353415863412.jpeg",
      sourceURL: "sources/tbomt",
    },
    {
      id: 110,
      name: "GotG",
      description: "Bigby Presents: Glory of the Giants",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/33889/811/638179362850507516.jpeg",
      sourceURL: "sources/gotg",
    },
    {
      id: 111,
      name: "LMI",
      description: "Legendary Magic Items",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/32967/633/638146612553084319.jpeg",
      sourceURL: "sources/lmi",
    },
    {
      id: 112,
      name: "MPMv1",
      description: "Misplaced Monsters: Volume One",
      sourceCategoryId: 12,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/33375/579/638161401159084318.jpeg",
      sourceURL: "sources/mpmv1",
    },
    {
      id: 113,
      name: "PBTSO",
      description: "Phandelver and Below: The Shattered Obelisk",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/35214/280/638233891719898500.jpeg",
      sourceURL: "sources/pbtso",
    },
    {
      id: 114,
      name: "PAitM",
      description: "Planescape: Adventures in the Multiverse",
      sourceCategoryId: 17,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/33644/785/638170881547396926.jpeg",
      sourceURL: "sources/paitm",
    },
    {
      id: 115,
      name: "MCv3",
      description: "Monstrous Compendium Volume 3: Minecraft Creatures",
      sourceCategoryId: 15,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/33103/791/638151695270317390.jpeg",
      sourceURL: "sources/mcv3",
    },
    {
      id: 116,
      name: "DoD",
      description: "Domains of Delight: A Feywild Accessory",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/33298/313/638158863440629290.jpeg",
      sourceURL: "sources/dod",
    },
    {
      id: 121,
      name: "GotSF",
      description: "Giants of the Star Forge",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/36103/73/638271109629954129.jpeg",
      sourceURL: "sources/gotsf",
    },
    {
      id: 122,
      name: "BGG",
      description: "Baldurs Gate Gazetteer",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/35728/82/638254794193165644.jpeg",
      sourceURL: "sources/bgg",
    },
    {
      id: 123,
      name: "TCSR",
      description: "Taldorei Campaign Setting Reborn",
      sourceCategoryId: 2,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/36235/402/638277146643998518.jpeg",
      sourceURL: "sources/tcsr",
    },
    {
      id: 124,
      name: "MCv4",
      description: "Monstrous Compendium Vol. 4: Eldraine Creatures",
      sourceCategoryId: 7,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/36797/447/638301391860014579.jpeg",
      sourceURL: "sources/mcv4",
    },
    {
      id: 125,
      name: "AATM",
      description: "Adventure Atlas: The Mortuary",
      sourceCategoryId: 17,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/36921/396/638306623652011464.jpeg",
      sourceURL: "sources/aatm",
    },
    {
      id: 126,
      name: "LKE",
      description: "Lightning Keep",
      sourceCategoryId: 15,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/36974/217/638309001082198146.jpeg",
      sourceURL: "sources/lke",
    },
    {
      id: 128,
      name: "ItSI",
      description: "Intro to Stormwreck Isle",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/37224/332/638319433931865291.jpeg",
      sourceURL: "sources/itsi",
    },
    {
      id: 129,
      name: "HFSCM",
      description: "Heroes Feast: Saving the Childrens Menu ",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/37957/430/638350488745211592.jpeg",
      sourceURL: "sources/hfscm",
    },
    {
      id: 130,
      name: "LoE",
      description: "Lairs of Etharis",
      sourceCategoryId: 18,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/38227/385/638361857871304044.jpeg",
      sourceURL: "sources/loe",
    },
    {
      id: 131,
      name: "DoDR",
      description: "Dungeons of Drakkenheim",
      sourceCategoryId: 19,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/38226/811/638361838185130525.jpeg",
      sourceURL: "sources/dodr",
    },
    {
      id: 132,
      name: "VEoR",
      description: "Vecna: Eve of Ruin",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/39768/808/638427681488703113.jpeg",
      sourceURL: "sources/veor",
    },
    {
      id: 133,
      name: "HCS",
      description: "Humblewood Campaign Setting",
      sourceCategoryId: 20,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/39695/377/638425036767623471.jpeg",
      sourceURL: "sources/hcs",
    },
    {
      id: 135,
      name: "VNEE",
      description: "Vecna: Nest of the Eldritch Eye",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/40687/843/638465408127994219.jpeg",
      sourceURL: "sources/vnee",
    },
    {
      id: 136,
      name: "DiLCT",
      description: "Descent into the Lost Caverns of Tsojcanth",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/40132/872/638442415700463413.jpeg",
      sourceURL: "sources/dilct",
    },
    {
      id: 137,
      name: "QftIS",
      description: "Quests from the Infinite Staircase",
      sourceCategoryId: 1,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/40544/16/638459335923192808.jpeg",
      sourceURL: "sources/qftis",
    },
    {
      id: 139,
      name: "ToB1",
      description: "Tome of Beasts 1",
      sourceCategoryId: 21,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/40544/209/638459347386150459.jpeg",
      sourceURL: "sources/tob1",
    },
    {
      id: 140,
      name: "FMRP",
      description: "Flee Mortals: Rule Primer",
      sourceCategoryId: 22,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/41760/824/638512293338393278.jpeg",
      sourceURL: "sources/fmrp",
    },
    {
      id: 142,
      name: "FM",
      description: "Flee, Mortals!",
      sourceCategoryId: 22,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/41757/185/638512177128217264.jpeg",
      sourceURL: "sources/fm",
    },
    {
      id: 143,
      name: "WEL",
      description: "Where Evil Lives",
      sourceCategoryId: 22,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/41757/270/638512180375164348.jpeg",
      sourceURL: "sources/wel",
    },
    {
      id: 150,
      name: "GHPP",
      description: "Grim Hollow: Player Pack",
      sourceCategoryId: 18,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/42333/528/638537169036542469.jpeg",
      sourceURL: "sources/ghpp",
    },
    {
      id: 151,
      name: "BoET",
      description: "Book of Ebon Tides",
      sourceCategoryId: 21,
      isReleased: true,
      avatarURL: "https://www.dndbeyond.com/avatars/42930/371/638563983452341674.jpeg",
      sourceURL: "sources/dnd/boet",
    },
  ],
  levelProficiencyBonuses: [
    { level: 1, bonus: 2 },
    { level: 2, bonus: 2 },
    { level: 3, bonus: 2 },
    { level: 4, bonus: 2 },
    { level: 5, bonus: 3 },
    { level: 6, bonus: 3 },
    { level: 7, bonus: 3 },
    { level: 8, bonus: 3 },
    { level: 9, bonus: 4 },
    { level: 10, bonus: 4 },
    { level: 11, bonus: 4 },
    { level: 12, bonus: 4 },
    { level: 13, bonus: 5 },
    { level: 14, bonus: 5 },
    { level: 15, bonus: 5 },
    { level: 16, bonus: 5 },
    { level: 17, bonus: 6 },
    { level: 18, bonus: 6 },
    { level: 19, bonus: 6 },
    { level: 20, bonus: 6 },
  ],
  levelExperiencePoints: [
    0, 300, 900, 2700, 6500, 14000, 23000, 34000, 48000, 64000, 85000, 100000, 120000, 140000, 165000, 195000, 225000,
    265000, 305000, 355000,
  ],
  diceValues: [4, 6, 8, 10, 12, 20],
  stats: [
    {
      id: 1,
      entityTypeId: 1472902489,
      key: "STR",
      name: "Strength",
      compendiumText:
        '<p>Strength measures bodily power, athletic training, and the extent to which you can exert raw physical force.</p>\n<h4 id="StrengthChecks">Strength Checks</h4>\n<p>A Strength check can model any attempt to lift, push, pull, or break something, to force your body through a space, or to otherwise apply brute force to a situation. The Athletics skill reflects aptitude in certain kinds of Strength checks.</p>\n<h5 id="Athletics">Athletics</h5>\n<p>Your Strength (Athletics) check covers difficult situations you encounter while climbing, jumping, or swimming. Examples include the following activities:</p>\n<ul>\n<li>You attempt to climb a sheer or slippery cliff, avoid hazards while scaling a wall, or cling to a surface while something is trying to knock you off.</li>\n<li>You try to jump an unusually long distance or pull off a stunt midjump.</li>\n<li>You struggle to swim or stay afloat in treacherous currents, storm-tossed waves, or areas of thick seaweed. Or another creature tries to push or pull you underwater or otherwise interfere with your swimming.</li>\n</ul>\n<h5 id="OtherStrengthChecks">Other Strength Checks</h5>\n<p>The DM might also call for a Strength check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Force open a stuck, locked, or barred door</li>\n<li>Break free of bonds</li>\n<li>Push through a tunnel that is too small</li>\n<li>Hang on to a wagon while being dragged behind it</li>\n<li>Tip over a statue</li>\n<li>Keep a boulder from rolling</li>\n</ul>\n<h4 id="AttackRollsandDamage">Attack Rolls and Damage</h4>\n<p>You add your Strength modifier to your attack roll and your damage roll when attacking with a melee weapon such as a mace, a battleaxe, or a javelin. You use melee weapons to make melee attacks in hand-to-hand combat, and some of them can be thrown to make a ranged attack.</p>\n<h4 id="LiftingandCarrying">Lifting and Carrying</h4>\n<p>Your Strength score determines the amount of weight you can bear. The following terms define what you can lift or carry.</p>\n<p><strong>Carrying Capacity.</strong> Your carrying capacity is your Strength score multiplied by 15. This is the weight (in pounds) that you can carry, which is high enough that most characters don\'t usually have to worry about it.</p>\n<p><strong>Push, Drag, or Lift.</strong> You can push, drag, or lift a weight in pounds up to twice your carrying capacity (or 30 times your Strength score). While pushing or dragging weight in excess of your carrying capacity, your speed drops to 5 feet.</p>\n<p><strong>Size and Strength.</strong> Larger creatures can bear more weight, whereas Tiny creatures can carry less. For each size category above Medium, double the creature\'s carrying capacity and the amount it can push, drag, or lift. For a Tiny creature, halve these weights.</p>\n<h4 id="VariantEncumbrance">Variant: Encumbrance</h4>\n<p>The rules for lifting and carrying are intentionally simple. Here is a variant if you are looking for more detailed rules for determining how a character is hindered by the weight of equipment. When you use this variant, ignore the Strength column of the Armor table in <a href="https://www.dndbeyond.com/compendium/rules/phb/equipment#ArmorandShields">chapter 5</a>.</p>\n<p>If you carry weight in excess of 5 times your Strength score, you are <strong>encumbered</strong>, which means your speed drops by 10 feet.</p>\n<p>If you carry weight in excess of 10 times your Strength score, up to your maximum carrying capacity, you are instead <strong>heavily encumbered</strong>, which means your speed drops by 20 feet and you have disadvantage on ability checks, attack rolls, and saving throws that use Strength, Dexterity, or Constitution.</p>',
    },
    {
      id: 2,
      entityTypeId: 1472902489,
      key: "DEX",
      name: "Dexterity",
      compendiumText:
        '<p>Dexterity measures agility, reflexes, and balance.</p>\n<h4 id="DexterityChecks">Dexterity Checks</h4>\n<p>A Dexterity check can model any attempt to move nimbly, quickly, or quietly, or to keep from falling on tricky footing. The Acrobatics, Sleight of Hand, and Stealth skills reflect aptitude in certain kinds of Dexterity checks.</p>\n<h5 id="Acrobatics">Acrobatics</h5>\n<p>Your Dexterity (Acrobatics) check covers your attempt to stay on your feet in a tricky situation, such as when you\'re trying to run across a sheet of ice, balance on a tightrope, or stay upright on a rocking ship\'s deck. The DM might also call for a Dexterity (Acrobatics) check to see if you can perform acrobatic stunts, including dives, rolls, somersaults, and flips.</p>\n<h5 id="SleightofHand">Sleight of Hand</h5>\n<p>Whenever you attempt an act of legerdemain or manual trickery, such as planting something on someone else or concealing an object on your person, make a Dexterity (Sleight of Hand) check. The DM might also call for a Dexterity (Sleight of Hand) check to determine whether you can lift a coin purse off another person or slip something out of another person\'s pocket.</p>\n<h5 id="Stealth">Stealth</h5>\n<p>Make a Dexterity (Stealth) check when you attempt to conceal yourself from enemies, slink past guards, slip away without being noticed, or sneak up on someone without being seen or heard.</p>\n<h5 id="OtherDexterityChecks">Other Dexterity Checks</h5>\n<p>The DM might call for a Dexterity check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Control a heavily laden cart on a steep descent</li>\n<li>Steer a chariot around a tight turn</li>\n<li>Pick a lock</li>\n<li>Disable a trap</li>\n<li>Securely tie up a prisoner</li>\n<li>Wriggle free of bonds</li>\n<li>Play a stringed instrument</li>\n<li>Craft a small or detailed object</li>\n</ul>\n<h4 id="AttackRollsandDamage">Attack Rolls and Damage</h4>\n<p>You add your Dexterity modifier to your attack roll and your damage roll when attacking with a ranged weapon, such as a sling or a longbow. You can also add your Dexterity modifier to your attack roll and your damage roll when attacking with a melee weapon that has the finesse property, such as a dagger or a rapier.</p>\n<h4 id="ArmorClass">Armor Class</h4>\n<p>Depending on the armor you wear, you might add some or all of your Dexterity modifier to your Armor Class, as described in chapter 5, "<a href="https://www.dndbeyond.com/compendium/rules/phb/equipment#ArmorandShields">Equipment</a>."</p>\n<h4 id="Initiative">Initiative</h4>\n<p>At the beginning of every combat, you roll initiative by making a Dexterity check. Initiative determines the order of creatures\' turns in combat, as described in chapter 9, "<a href="https://www.dndbeyond.com/compendium/rules/phb/combat#Initiative">Combat</a>."</p>\n<blockquote>\n<p><strong>HIDING</strong></p>\n<p>The DM decides when circumstances are appropriate for hiding. When you try to hide, make a Dexterity (Stealth) check. Until you are discovered or you stop hiding, that check\'s total is contested by the Wisdom (Perception) check of any creature that actively searches for signs of your presence.</p>\n<p>You can\'t hide from a creature that can see you clearly, and you give away your position if you make noise, such as shouting a warning or knocking over a vase. An invisible creature can always try to hide. Signs of its passage might still be noticed, and it does have to stay quiet.</p>\n<p>In combat, most creatures stay alert for signs of danger all around, so if you come out of hiding and approach a creature, it usually sees you. However, under certain circumstances, the DM might allow you to stay hidden as you approach a creature that is distracted, allowing you to gain advantage on an attack roll before you are seen.</p>\n<p><strong>Passive Perception.</strong> When you hide, there\'s a chance someone will notice you even if they aren\'t searching. To determine whether such a creature notices you, the DM compares your Dexterity (Stealth) check with that creature\'s passive Wisdom (Perception) score, which equals 10 + the creature\'s Wisdom modifier, as well as any other bonuses or penalties. If the creature has advantage, add 5. For disadvantage, subtract 5.</p>\n<p>For example, if a 1st-level character (with a proficiency bonus of +2) has a Wisdom of 15 (a +2 modifier) and proficiency in Perception, he or she has a passive Wisdom (Perception) of 14.</p>\n<p><strong>What Can You See?</strong> One of the main factors in determining whether you can find a hidden creature or object is how well you can see in an area, which might be <strong>lightly</strong> or <strong>heavily obscured&nbsp;</strong>as explained in chapter 8, <a href="https://www.dndbeyond.com/compendium/rules/phb/adventuring#VisionandLight">Adventuring</a>.</p>\n</blockquote>',
    },
    {
      id: 3,
      entityTypeId: 1472902489,
      key: "CON",
      name: "Constitution",
      compendiumText:
        '<p>Constitution measures health, stamina, and vital force.</p>\n<h4 id="ConstitutionChecks">Constitution Checks</h4>\n<p>Constitution checks are uncommon, and no skills apply to Constitution checks, because the endurance this ability represents is largely passive rather than involving a specific effort on the part of a character or monster. A Constitution check can model your attempt to push beyond normal limits, however.</p>\n<p>The DM might call for a Constitution check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Hold your breath</li>\n<li>March or labor for hours without rest</li>\n<li>Go without sleep</li>\n<li>Survive without food or water</li>\n<li>Quaff an entire stein of ale in one go</li>\n</ul>\n<h4 id="HitPoints">Hit Points</h4>\n<p>Your Constitution modifier contributes to your hit points. Typically, you add your Constitution modifier to each Hit Die you roll for your hit points.</p>\n<p>If your Constitution modifier changes, your hit point maximum changes as well, as though you had the new modifier from 1st level. For example, if you raise your Constitution score when you reach 4th level and your Constitution modifier increases from +1 to +2, you adjust your hit point maximum as though the modifier had always been +2. So you add 3 hit points for your first three levels, and then roll your hit points for 4th level using your new modifier. Or if you\'re 7th level and some effect lowers your Constitution score so as to reduce your Constitution modifier by 1, your hit point maximum is reduced by 7.</p>',
    },
    {
      id: 4,
      entityTypeId: 1472902489,
      key: "INT",
      name: "Intelligence",
      compendiumText:
        '<p>Intelligence measures mental acuity, accuracy of recall, and the ability to reason.</p>\n<h4 id="IntelligenceChecks">Intelligence Checks</h4>\n<p>An Intelligence check comes into play when you need to draw on logic, education, memory, or deductive reasoning. The Arcana, History, Investigation, Nature, and Religion skills reflect aptitude in certain kinds of Intelligence checks.</p>\n<h5 id="Arcana">Arcana</h5>\n<p>Your Intelligence (Arcana) check measures your ability to recall lore about spells, magic items, eldritch symbols, magical traditions, the planes of existence, and the inhabitants of those planes.</p>\n<h5 id="History">History</h5>\n<p>Your Intelligence (History) check measures your ability to recall lore about historical events, legendary people, ancient kingdoms, past disputes, recent wars, and lost civilizations.</p>\n<h5 id="Investigation">Investigation</h5>\n<p>When you look around for clues and make deductions based on those clues, you make an Intelligence (Investigation) check. You might deduce the location of a hidden object, discern from the appearance of a wound what kind of weapon dealt it, or determine the weakest point in a tunnel that could cause it to collapse. Poring through ancient scrolls in search of a hidden fragment of knowledge might also call for an Intelligence (Investigation) check.</p>\n<h5 id="Nature">Nature</h5>\n<p>Your Intelligence (Nature) check measures your ability to recall lore about terrain, plants and animals, the weather, and natural cycles.</p>\n<h5 id="Religion">Religion</h5>\n<p>Your Intelligence (Religion) check measures your ability to recall lore about deities, rites and prayers, religious hierarchies, holy symbols, and the practices of secret cults.</p>\n<h5 id="OtherIntelligenceChecks">Other Intelligence Checks</h5>\n<p>The DM might call for an Intelligence check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Communicate with a creature without using words</li>\n<li>Estimate the value of a precious item</li>\n<li>Pull together a disguise to pass as a city guard</li>\n<li>Forge a document</li>\n<li>Recall lore about a craft or trade</li>\n<li>Win a game of skill</li>\n</ul>\n<h4 id="SpellcastingAbility">Spellcasting Ability</h4>\n<p>Wizards use Intelligence as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</p>',
    },
    {
      id: 5,
      entityTypeId: 1472902489,
      key: "WIS",
      name: "Wisdom",
      compendiumText:
        '<p>Wisdom reflects how attuned you are to the world around you and represents perceptiveness and intuition.</p>\n<h4 id="WisdomChecks">Wisdom Checks</h4>\n<p>A Wisdom check might reflect an effort to read body language, understand someones feelings, notice things about the environment, or care for an injured person. The Animal Handling, Insight, Medicine, Perception, and Survival skills reflect aptitude in certain kinds of Wisdom checks.</p>\n<h5 id="AnimalHandling">Animal Handling</h5>\n<p>When there is any question whether you can calm down a domesticated animal, keep a mount from getting spooked, or intuit an animals intentions, the DM might call for a Wisdom (Animal Handling) check. You also make a Wisdom (Animal Handling) check to control your mount when you attempt a risky maneuver.</p>\n<h5 id="Insight">Insight</h5>\n<p>Your Wisdom (Insight) check decides whether you can determine the true intentions of a creature, such as when searching out a lie or predicting someones next move. Doing so involves gleaning clues from body language, speech habits, and changes in mannerisms.</p>\n<h5 id="Medicine">Medicine</h5>\n<p>A Wisdom (Medicine) check lets you try to stabilize a dying companion or diagnose an illness.</p>\n<h5 id="Perception">Perception</h5>\n<p>Your Wisdom (Perception) check lets you spot, hear, or otherwise detect the presence of something. It measures your general awareness of your surroundings and the keenness of your senses. For example, you might try to hear a conversation through a closed door, eavesdrop under an open window, or hear monsters moving stealthily in the forest. Or you might try to spot things that are obscured or easy to miss, whether they are orcs lying in ambush on a road, thugs hiding in the shadows of an alley, or candlelight under a closed secret door.</p>\n<aside>\n<blockquote>\n<p id="finding-a-hidden-object"><strong>FINDING A HIDDEN OBJECT</strong></p>\n<p>When your character searches for a hidden object such as a secret door or a trap, the DM typically asks you to make a Wisdom (Perception) check. Such a check can be used to find hidden details or other information and clues that you might otherwise overlook.</p>\n<p>In most cases, you need to describe where you are looking in order for the DM to determine your chance of success. For example, a key is hidden beneath a set of folded clothes in the top drawer of a bureau. If you tell the DM that you pace around the room, looking at the walls and furniture for clues, you have no chance of finding the key, regardless of your Wisdom (Perception) check result. You would have to specify that you were opening the drawers or searching the bureau in order to have any chance of success.</p>\n</blockquote>\n</aside>\n<h5 id="Survival">Survival</h5>\n<p>The DM might ask you to make a Wisdom (Survival) check to follow tracks, hunt wild game, guide your group through frozen wastelands, identify signs that owlbears live nearby, predict the weather, or avoid quicksand and other natural hazards.</p>\n<h5 id="OtherWisdomChecks">Other Wisdom Checks</h5>\n<p>The DM might call for a Wisdom check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Get a gut feeling about what course of action to follow</li>\n<li>Discern whether a seemingly dead or living creature is undead</li>\n</ul>\n<h4 id="SpellcastingAbility">Spellcasting Ability</h4>\n<p>Clerics, druids, and rangers use Wisdom as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</p>',
    },
    {
      id: 6,
      entityTypeId: 1472902489,
      key: "CHA",
      name: "Charisma",
      compendiumText:
        '<p>Charisma measures your ability to interact effectively with others. It includes such factors as confidence and eloquence, and it can represent a charming or commanding personality.</p>\n<h4 id="CharismaChecks">Charisma Checks</h4>\n<p>A Charisma check might arise when you try to influence or entertain others, when you try to make an impression or tell a convincing lie, or when you are navigating a tricky social situation. The Deception, Intimidation, Performance, and Persuasion skills reflect aptitude in certain kinds of Charisma checks.</p>\n<h5 id="Deception">Deception</h5>\n<p>Your Charisma (Deception) check determines whether you can convincingly hide the truth, either verbally or through your actions. This deception can encompass everything from misleading others through ambiguity to telling outright lies. Typical situations include trying to fast-talk a guard, con a merchant, earn money through gambling, pass yourself off in a disguise, dull someone\'s suspicions with false assurances, or maintain a straight face while telling a blatant lie.</p>\n<h5 id="Intimidation">Intimidation</h5>\n<p>When you attempt to influence someone through overt threats, hostile actions, and physical violence, the DM might ask you to make a Charisma (Intimidation) check. Examples include trying to pry information out of a prisoner, convincing street thugs to back down from a confrontation, or using the edge of a broken bottle to convince a sneering vizier to reconsider a decision.</p>\n<h5 id="Performance">Performance</h5>\n<p>Your Charisma (Performance) check determines how well you can delight an audience with music, dance, acting, storytelling, or some other form of entertainment.</p>\n<h5 id="Persuasion">Persuasion</h5>\n<p>When you attempt to influence someone or a group of people with tact, social graces, or good nature, the DM might ask you to make a Charisma (Persuasion) check. Typically, you use persuasion when acting in good faith, to foster friendships, make cordial requests, or exhibit proper etiquette. Examples of persuading others include convincing a chamberlain to let your party see the king, negotiating peace between warring tribes, or inspiring a crowd of townsfolk.</p>\n<h5 id="OtherCharismaChecks">Other Charisma Checks</h5>\n<p>The DM might call for a Charisma check when you try to accomplish tasks like the following:</p>\n<ul>\n<li>Find the best person to talk to for news, rumors, and gossip</li>\n<li>Blend into a crowd to get the sense of key topics of conversation</li>\n</ul>\n<h4 id="SpellcastingAbility">Spellcasting Ability</h4>\n<p>Bards, paladins, sorcerers, and warlocks use Charisma as their spellcasting ability, which helps determine the saving throw DCs of spells they cast.</p>',
    },
  ],
  currencyData: [
    { id: 1, name: "PP", conversionFromGp: 10.0, weight: 0.02 },
    { id: 2, name: "GP", conversionFromGp: 1.0, weight: 0.02 },
    { id: 3, name: "EP", conversionFromGp: 0.5, weight: 0.02 },
    { id: 4, name: "SP", conversionFromGp: 0.1, weight: 0.02 },
    { id: 5, name: "CP", conversionFromGp: 0.01, weight: 0.02 },
  ],
  classConfigurations: [
    {
      id: 357975,
      name: "Blood Hunter",
      primaryAbilities: [],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Intelligence 13",
          prerequisiteMappings: [
            {
              id: 146776,
              entityId: 4,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "intelligence",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Intelligence",
            },
          ],
        },
      ],
    },
    {
      id: 117,
      name: "Blood Hunter (archived)",
      primaryAbilities: [],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [],
    },
    {
      id: 1,
      name: "Bard",
      primaryAbilities: [6],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: [0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 15, 16, 18, 19, 19, 20, 22, 22, 22],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Charisma 13",
          prerequisiteMappings: [
            {
              id: 10356,
              entityId: 6,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "charisma",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Charisma",
            },
          ],
        },
      ],
    },
    {
      id: 2,
      name: "Cleric",
      primaryAbilities: [5],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Wisdom 13",
          prerequisiteMappings: [
            {
              id: 10357,
              entityId: 5,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "wisdom",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Wisdom",
            },
          ],
        },
      ],
    },
    {
      id: 3,
      name: "Druid",
      primaryAbilities: [5],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Wisdom 13",
          prerequisiteMappings: [
            {
              id: 10358,
              entityId: 5,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "wisdom",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Wisdom",
            },
          ],
        },
      ],
    },
    {
      id: 4,
      name: "Paladin",
      primaryAbilities: [6],
      spellRules: {
        multiClassSpellSlotDivisor: 2,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Strength 13 and Charisma 13",
          prerequisiteMappings: [
            {
              id: 10359,
              entityId: 1,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "strength",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Strength",
            },
            {
              id: 10360,
              entityId: 6,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "charisma",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Charisma",
            },
          ],
        },
      ],
    },
    {
      id: 5,
      name: "Ranger",
      primaryAbilities: [5],
      spellRules: {
        multiClassSpellSlotDivisor: 2,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        levelSpellKnownMaxes: [0, 0, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Dexterity 13 and Wisdom 13",
          prerequisiteMappings: [
            {
              id: 10361,
              entityId: 2,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "dexterity",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Dexterity",
            },
            {
              id: 10362,
              entityId: 5,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "wisdom",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Wisdom",
            },
          ],
        },
      ],
    },
    {
      id: 6,
      name: "Sorcerer",
      primaryAbilities: [6],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        levelSpellKnownMaxes: [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Charisma 13",
          prerequisiteMappings: [
            {
              id: 10363,
              entityId: 6,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "charisma",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Charisma",
            },
          ],
        },
      ],
    },
    {
      id: 7,
      name: "Warlock",
      primaryAbilities: [6],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
          [0, 0, 0, 2, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 2, 0, 0, 0, 0],
          [0, 0, 0, 0, 2, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0],
          [0, 0, 0, 0, 4, 0, 0, 0, 0],
          [0, 0, 0, 0, 4, 0, 0, 0, 0],
          [0, 0, 0, 0, 4, 0, 0, 0, 0],
          [0, 0, 0, 0, 4, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Charisma 13",
          prerequisiteMappings: [
            {
              id: 10364,
              entityId: 6,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "charisma",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Charisma",
            },
          ],
        },
      ],
    },
    {
      id: 8,
      name: "Wizard",
      primaryAbilities: [4],
      spellRules: {
        multiClassSpellSlotDivisor: 1,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 0, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 0, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 0],
          [4, 3, 3, 3, 2, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 1, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 1, 1, 1],
          [4, 3, 3, 3, 3, 2, 2, 1, 1],
        ],
      },
      prerequisites: [
        {
          description: "Intelligence 13",
          prerequisiteMappings: [
            {
              id: 10365,
              entityId: 4,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "intelligence",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Intelligence",
            },
          ],
        },
      ],
    },
    {
      id: 9,
      name: "Barbarian",
      primaryAbilities: [1],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 3, 4, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 11, 11, 12, 13],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Strength 13",
          prerequisiteMappings: [
            {
              id: 10366,
              entityId: 1,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "strength",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Strength",
            },
          ],
        },
      ],
    },
    {
      id: 10,
      name: "Fighter",
      primaryAbilities: [1, 2],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 3, 4, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 11, 11, 12, 13],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Strength 13",
          prerequisiteMappings: [
            {
              id: 10367,
              entityId: 1,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "strength",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Strength",
            },
          ],
        },
        {
          description: "or Dexterity 13",
          prerequisiteMappings: [
            {
              id: 10368,
              entityId: 2,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "dexterity",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Dexterity",
            },
          ],
        },
      ],
    },
    {
      id: 11,
      name: "Monk",
      primaryAbilities: [5],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
        levelSpellKnownMaxes: [0, 0, 0, 3, 4, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 11, 11, 12, 13],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Dexterity 13 and Wisdom 13",
          prerequisiteMappings: [
            {
              id: 10369,
              entityId: 2,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "dexterity",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Dexterity",
            },
            {
              id: 10370,
              entityId: 5,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "wisdom",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Wisdom",
            },
          ],
        },
      ],
    },
    {
      id: 12,
      name: "Rogue",
      primaryAbilities: [2],
      spellRules: {
        multiClassSpellSlotDivisor: 3,
        multiClassSpellSlotRounding: 1,
        isRitualSpellCaster: false,
        levelCantripsKnownMaxes: [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: [0, 0, 0, 3, 4, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 11, 11, 12, 13],
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Dexterity 13",
          prerequisiteMappings: [
            {
              id: 10371,
              entityId: 2,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "dexterity",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Dexterity",
            },
          ],
        },
      ],
    },
    {
      id: 124727,
      name: "Artificer (UA)",
      primaryAbilities: [4],
      spellRules: {
        multiClassSpellSlotDivisor: 2,
        multiClassSpellSlotRounding: 2,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Intelligence 13",
          prerequisiteMappings: [
            {
              id: 32395,
              entityId: 4,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "intelligence",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Intelligence",
            },
          ],
        },
      ],
    },
    {
      id: 252717,
      name: "Artificer",
      primaryAbilities: [4],
      spellRules: {
        multiClassSpellSlotDivisor: 2,
        multiClassSpellSlotRounding: 2,
        isRitualSpellCaster: true,
        levelCantripsKnownMaxes: [0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4],
        levelSpellKnownMaxes: null,
        levelSpellSlots: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [2, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [3, 0, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 2, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 0, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 2, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 0, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 1, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 2, 0, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 1, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
          [4, 3, 3, 3, 2, 0, 0, 0, 0],
        ],
      },
      prerequisites: [
        {
          description: "Intelligence 13",
          prerequisiteMappings: [
            {
              id: 74766,
              entityId: 4,
              entityTypeId: 1472902489,
              type: "ability-score",
              subType: "intelligence",
              value: 13,
              friendlyTypeName: "Ability Score",
              friendlySubTypeName: "Intelligence",
            },
          ],
        },
      ],
    },
  ],
  abilitySkills: [
    {
      id: 2,
      entityTypeId: 1958004211,
      stat: 1,
      name: "Athletics",
      description:
        "<p>Your Strength (Athletics) check covers difficult situations you encounter while climbing, jumping, or swimming. Examples include the following activities:</p>\n<ul>\n<li>You attempt to climb a sheer or slippery cliff, avoid hazards while scaling a wall, or cling to a surface while something is trying to knock you off.</li>\n<li>You try to jump an unusually long distance or pull off a stunt midjump.</li>\n<li>You struggle to swim or stay afloat in treacherous currents, storm-tossed waves, or areas of thick seaweed. Or another creature tries to push or pull you underwater or otherwise interfere with your swimming.</li>\n</ul>",
    },
    {
      id: 3,
      entityTypeId: 1958004211,
      stat: 2,
      name: "Acrobatics",
      description:
        "<p>Your Dexterity (Acrobatics) check covers your attempt to stay on your feet in a tricky situation, such as when you're trying to run across a sheet of ice, balance on a tightrope, or stay upright on a rocking ship's deck. The GM might also call for a Dexterity (Acrobatics) check to see if you can perform acrobatic stunts, including dives, rolls, somersaults, and flips.</p>",
    },
    {
      id: 4,
      entityTypeId: 1958004211,
      stat: 2,
      name: "Sleight of Hand",
      description:
        "<p>Whenever you attempt an act of legerdemain or manual trickery, such as planting something on someone else or concealing an object on your person, make a Dexterity (Sleight of Hand) check. The GM might also call for a Dexterity (Sleight of Hand) check to determine whether you can lift a coin purse off another person or slip something out of another person's pocket.</p>\n",
    },
    {
      id: 5,
      entityTypeId: 1958004211,
      stat: 2,
      name: "Stealth",
      description:
        "<p>Make a Dexterity (Stealth) check when you attempt to conceal yourself from enemies, slink past guards, slip away without being noticed, or sneak up on someone without being seen or heard.</p>",
    },
    {
      id: 6,
      entityTypeId: 1958004211,
      stat: 4,
      name: "Arcana",
      description:
        "<p>Your Intelligence (Arcana) check measures your ability to recall lore about spells, magic items, eldritch symbols, magical traditions, the planes of existence, and the inhabitants of those planes.</p>",
    },
    {
      id: 7,
      entityTypeId: 1958004211,
      stat: 4,
      name: "History",
      description:
        "<p>Your Intelligence (History) check measures your ability to recall lore about historical events, legendary people, ancient kingdoms, past disputes, recent wars, and lost civilizations.</p>",
    },
    {
      id: 8,
      entityTypeId: 1958004211,
      stat: 4,
      name: "Investigation",
      description:
        "<p>When you look around for clues and make deductions based on those clues, you make an Intelligence (Investigation) check. You might deduce the location of a hidden object, discern from the appearance of a wound what kind of weapon dealt it, or determine the weakest point in a tunnel that could cause it to collapse. Poring through ancient scrolls in search of a hidden fragment of knowledge might also call for an Intelligence (Investigation) check.</p>\n",
    },
    {
      id: 9,
      entityTypeId: 1958004211,
      stat: 4,
      name: "Nature",
      description:
        "<p>Your Intelligence (Nature) check measures your ability to recall lore about terrain, plants and animals, the weather, and natural cycles.</p>",
    },
    {
      id: 10,
      entityTypeId: 1958004211,
      stat: 4,
      name: "Religion",
      description:
        "<p>Your Intelligence (Religion) check measures your ability to recall lore about deities, rites and prayers, religious hierarchies, holy symbols, and the practices of secret cults.</p>",
    },
    {
      id: 11,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Animal Handling",
      description:
        "<p>When there is any question whether you can calm down a domesticated animal, keep a mount from getting spooked, or intuit an animals intentions, the GM might call for a Wisdom (Animal Handling) check. You also make a Wisdom (Animal Handling) check to control your mount when you attempt a risky maneuver.</p>",
    },
    {
      id: 12,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Insight",
      description:
        "<p>Your Wisdom (Insight) check decides whether you can determine the true intentions of a creature, such as when searching out a lie or predicting someones next move. Doing so involves gleaning clues from body language, speech habits, and changes in mannerisms.</p>\n",
    },
    {
      id: 13,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Medicine",
      description:
        "<p>A Wisdom (Medicine) check lets you try to stabilize a dying companion or diagnose an illness.</p>",
    },
    {
      id: 14,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Perception",
      description:
        "<p>Your Wisdom (Perception) check lets you spot, hear, or otherwise detect the presence of something. It measures your general awareness of your surroundings and the keenness of your senses. For example, you might try to hear a conversation through a closed door, eavesdrop under an open window, or hear monsters moving stealthily in the forest. Or you might try to spot things that are obscured or easy to miss, whether they are orcs lying in ambush on a road, thugs hiding in the shadows of an alley, or candlelight under a closed secret door.</p>\n",
    },
    {
      id: 15,
      entityTypeId: 1958004211,
      stat: 5,
      name: "Survival",
      description:
        "<p>The GM might ask you to make a Wisdom (Survival) check to follow tracks, hunt wild game, guide your group through frozen wastelands, identify signs that owlbears live nearby, predict the weather, or avoid quicksand and other natural hazards.</p>",
    },
    {
      id: 16,
      entityTypeId: 1958004211,
      stat: 6,
      name: "Deception",
      description:
        "<p>Your Charisma (Deception) check determines whether you can convincingly hide the truth, either verbally or through your actions. This deception can encompass everything from misleading others through ambiguity to telling outright lies. Typical situations include trying to fast-talk a guard, con a merchant, earn money through gambling, pass yourself off in a disguise, dull someone's suspicions with false assurances, or maintain a straight face while telling a blatant lie.</p>\n",
    },
    {
      id: 17,
      entityTypeId: 1958004211,
      stat: 6,
      name: "Intimidation",
      description:
        "<p>When you attempt to influence someone through overt threats, hostile actions, and physical violence, the GM might ask you to make a Charisma (Intimidation) check. Examples include trying to pry information out of a prisoner, convincing street thugs to back down from a confrontation, or using the edge of a broken bottle to convince a sneering vizier to reconsider a decision.</p>\n",
    },
    {
      id: 18,
      entityTypeId: 1958004211,
      stat: 6,
      name: "Performance",
      description:
        "<p>Your Charisma (Performance) check determines how well you can delight an audience with music, dance, acting, storytelling, or some other form of entertainment.</p>",
    },
    {
      id: 19,
      entityTypeId: 1958004211,
      stat: 6,
      name: "Persuasion",
      description:
        "<p>When you attempt to influence someone or a group of people with tact, social graces, or good nature, the GM might ask you to make a Charisma (Persuasion) check. Typically, you use persuasion when acting in good faith, to foster friendships, make cordial requests, or exhibit proper etiquette. Examples of persuading others include convincing a chamberlain to let your party see the king, negotiating peace between warring tribes, or inspiring a crowd of townsfolk.</p>\n",
    },
  ],
  senses: [
    { id: 1, entityTypeId: 668550506, name: "Blindsight" },
    { id: 2, entityTypeId: 668550506, name: "Darkvision" },
    { id: 3, entityTypeId: 668550506, name: "Tremorsense" },
    { id: 4, entityTypeId: 668550506, name: "Truesight" },
    { id: 5, entityTypeId: 668550506, name: "Unknown" },
  ],
  creatureSizes: [
    { id: 2, entityTypeId: 127108918, name: "Tiny", weightType: 1 },
    { id: 3, entityTypeId: 127108918, name: "Small", weightType: 2 },
    { id: 4, entityTypeId: 127108918, name: "Medium", weightType: 2 },
    { id: 5, entityTypeId: 127108918, name: "Large", weightType: 3 },
    { id: 6, entityTypeId: 127108918, name: "Huge", weightType: 3 },
    { id: 7, entityTypeId: 127108918, name: "Gargantuan", weightType: 3 },
    { id: 10, entityTypeId: 127108918, name: "Medium or Small", weightType: 2 },
  ],
  limitedUseResetTypes: [
    { id: 1, name: "Short Rest" },
    { id: 2, name: "Long Rest" },
    { id: 3, name: "Dawn" },
    { id: 4, name: "Other" },
  ],
  sourceCategories: [
    {
      id: 1,
      name: "Core D&amp;D",
      description: null,
      isHideable: false,
      isEnabledByDefault: true,
      isToggleable: false,
      avatarUrl: "",
    },
    {
      id: 2,
      name: "Critical Role",
      description: null,
      isHideable: true,
      isEnabledByDefault: false,
      isToggleable: true,
      avatarUrl: "https://www.dndbeyond.com/avatars/105/174/636512853628516966.png",
    },
    {
      id: 3,
      name: "Playtest",
      description:
        '<p><span style="color: rgba(255, 0, 0, 1)"><strong>THIS IS UNOFFICIAL MATERIAL</strong></span></p>\n<p>The material here is presented for playtesting and to spark your imagination. These game mechanics are in draft form, usable in your campaign but not refined by&nbsp;full game design and editing. They arent officially part of the game and arent permitted in D&amp;D Adventurers League events.</p>\n<p>If this material is made official, it will be refined based on your feedback, and then it will appear in a D&amp;D product that you can unlock on DDB.</p>\n<p>If this material is not made official, it will be removed from D&amp;D Beyond following the playtest period and you will need to replace it with another option.</p>',
      isHideable: true,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "https://www.dndbeyond.com/avatars/110/171/636516074887091041.png",
    },
    {
      id: 6,
      name: "D&amp;D Beyond",
      description: "<p>D&amp;D Beyond</p>",
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "",
    },
    {
      id: 7,
      name: "Magic: The Gathering",
      description: "<p>Magic: The Gathering content for fifth edition Dungeons &amp; Dragons</p>",
      isHideable: false,
      isEnabledByDefault: true,
      isToggleable: true,
      avatarUrl: "",
    },
    {
      id: 8,
      name: "Eberron",
      description: "<p>The Eberron campaign setting for&nbsp;fifth edition Dungeons &amp; Dragons</p>",
      isHideable: false,
      isEnabledByDefault: true,
      isToggleable: true,
      avatarUrl: "https://www.dndbeyond.com/avatars/2588/861/636681435608150525.png",
    },
    {
      id: 9,
      name: "Archived",
      description: "<p>The Graveyard</p>",
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "",
    },
    {
      id: 10,
      name: "Rick and Morty",
      description: "<p>Source category for Rick and Morty products.</p>",
      isHideable: true,
      isEnabledByDefault: false,
      isToggleable: true,
      avatarUrl: "",
    },
    {
      id: 11,
      name: "Runeterra",
      description:
        '<p><span style="color: rgba(255, 0, 0, 1)"><strong>THIS IS UNOFFICIAL MATERIAL</strong></span></p>\n<p>These game mechanics are usable in your campaign if your DM allows them but not refined by final game design and editing. They arent officially part of the Dungeons &amp; Dragons game and arent permitted in D&amp;D Adventurers League events unless otherwise stated.</p>',
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "https://www.dndbeyond.com/avatars/11008/904/637274855809570341.png",
    },
    {
      id: 12,
      name: "Noncore D&amp;D",
      description:
        '<p><span style="color: rgba(255, 0, 0, 1)"><strong>THIS IS NONCORE D&amp;D MATERIAL</strong></span></p>\n<p>These game mechanics are usable in your campaign if your DM allows them but not refined by final game design and editing.</p>',
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: true,
      avatarUrl: "",
    },
    {
      id: 13,
      name: "Adventurers League",
      description: "<p>Adventurers League content for fifth edition Dungeons &amp; Dragons</p>",
      isHideable: false,
      isEnabledByDefault: false,
      isToggleable: false,
      avatarUrl: "",
    },
  ],
  movements: [
    { id: 1, name: "Walk", description: "Walking" },
    { id: 2, name: "Burrow", description: "Burrowing" },
    { id: 3, name: "Climb", description: "Climbing" },
    { id: 4, name: "Fly", description: "Flying" },
    { id: 5, name: "Swim", description: "Swimming" },
  ],
  multiClassSpellSlots: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [2, 0, 0, 0, 0, 0, 0, 0, 0],
    [3, 0, 0, 0, 0, 0, 0, 0, 0],
    [4, 2, 0, 0, 0, 0, 0, 0, 0],
    [4, 3, 0, 0, 0, 0, 0, 0, 0],
    [4, 3, 2, 0, 0, 0, 0, 0, 0],
    [4, 3, 3, 0, 0, 0, 0, 0, 0],
    [4, 3, 3, 1, 0, 0, 0, 0, 0],
    [4, 3, 3, 2, 0, 0, 0, 0, 0],
    [4, 3, 3, 3, 1, 0, 0, 0, 0],
    [4, 3, 3, 3, 2, 0, 0, 0, 0],
    [4, 3, 3, 3, 2, 1, 0, 0, 0],
    [4, 3, 3, 3, 2, 1, 0, 0, 0],
    [4, 3, 3, 3, 2, 1, 1, 0, 0],
    [4, 3, 3, 3, 2, 1, 1, 0, 0],
    [4, 3, 3, 3, 2, 1, 1, 1, 0],
    [4, 3, 3, 3, 2, 1, 1, 1, 0],
    [4, 3, 3, 3, 2, 1, 1, 1, 1],
    [4, 3, 3, 3, 3, 1, 1, 1, 1],
    [4, 3, 3, 3, 3, 2, 1, 1, 1],
    [4, 3, 3, 3, 3, 2, 2, 1, 1],
  ],
  pactMagicMultiClassSpellSlots: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0, 0],
    [2, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 2, 0, 0, 0, 0, 0, 0, 0],
    [0, 2, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 2, 0, 0, 0, 0, 0, 0],
    [0, 0, 2, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 2, 0, 0, 0, 0, 0],
    [0, 0, 0, 2, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 2, 0, 0, 0, 0],
    [0, 0, 0, 0, 2, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 3, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 0],
  ],
  proficiencyGroups: [
    { label: "Armor", customProficiencyGroup: 4, customAdjustments: [32], entityTypeIds: [701257905, 174869515] },
    { label: "Weapons", customProficiencyGroup: 5, customAdjustments: [33], entityTypeIds: [1782728300, 660121713] },
    { label: "Tools", customProficiencyGroup: 2, customAdjustments: [34], entityTypeIds: [2103445194, 1452973421] },
    { label: "Languages", customProficiencyGroup: 3, customAdjustments: [35], entityTypeIds: [906033267] },
  ],
  vehicleConfiguration: null,
};

;// CONCATENATED MODULE: ./src/hooks/ready/addDDBConfig.js




function addLanguages() {
  if (game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "add-ddb-languages")) {
    const ddbRaw = foundry.utils.getProperty(CONFIG, "DDB.languages");
    if (!ddbRaw) return;

    const ddbFiltered = [...new Set(ddbRaw
      .map((lang) => utils/* default.nameString */.Z.nameString(lang.name))
      .filter((lang) =>
        !dictionary/* default.character.languages.some */.Z.character.languages.some((l) => l.name === lang)
        && !["All"].includes(lang)
      ))];

    CONFIG.DND5E.languages.ddb = {
      label: "D&D Beyond",
      children: {
      }
    };
    ddbFiltered.forEach((lang) => {
      const stub = utils/* default.normalizeString */.Z.normalizeString(lang);
      CONFIG.DND5E.languages.ddb.children[stub] = lang;
      dictionary/* default.character.languages.push */.Z.character.languages.push({
        name: lang,
        value: stub,
        advancement: "ddb",
      });
    });
  }
}

function addDDBConfig() {
  addLanguages();
}

;// CONCATENATED MODULE: ./src/hooks/ready/ddbConfig.js







function directConfig() {
  $.getJSON("https://www.dndbeyond.com/api/config/json")
    .then((config) => {
      if (config && config.sources) {
        foundry.utils.setProperty(CONFIG, "DDB", config);
        logger/* default.info */.Z.info("Loaded DDB live config");
      }
      return config;
    })
    .catch((err) => {
      logger/* default.warn */.Z.warn("Failed to load DDB config, caught error using fallback.", err);
      return err;
    })
    .always(() => {
      if (!CONFIG.DDB?.sources) {
        foundry.utils.setProperty(CONFIG, "DDB", fallbackDDBConfig);
        logger/* default.warn */.Z.warn("Failed to load DDB config, using fallback.");
      } else {
        logger/* default.info */.Z.info("A DDB config was loaded");
      }
      logger/* default.debug */.Z.debug("DDB_CONFIG", CONFIG.DDB);
    });
}

function proxyConfig() {
  const parsingApi = DDBProxy/* default.getProxy */.Z.getProxy();
  const debugJson = game.settings.get(src_settings/* default.MODULE_ID */.Z.MODULE_ID, "debug-json");

  const url = `${parsingApi}/proxy/api/config/json`;
  return new Promise((resolve, reject) => {
    fetch(url, {
      method: "GET",
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
      },
    })
      .then((response) => response.json())
      .then((data) => {
        if (!data.success) {
          logger/* default.error */.Z.error(`API Failure: ${data.message}`);
          foundry.utils.setProperty(CONFIG, "DDB", fallbackDDBConfig);
          reject(data.message);
        }
        if (debugJson) {
          FileHelper/* default.download */.Z.download(JSON.stringify(data), `config-raw.json`, "application/json");
        }
        return data;
      })
      .then((data) => {
        if (data.success) {
          logger/* default.info */.Z.info(`Retrieved DDB CONFIG DATA via proxy`);
          foundry.utils.setProperty(CONFIG, "DDB", data.data);
        }
        logger/* default.debug */.Z.debug("DDB_CONFIG", CONFIG.DDB);
        resolve(data.data);
      })
      .catch((error) => reject(error));
  });
}

function loadDDBConfig() {
  if (!foundry.utils.hasProperty(CONFIG, "DDB")) {
    foundry.utils.setProperty(CONFIG, "DDB", fallbackDDBConfig);
    if (foundry.utils.getProperty(CONFIG, "DEBUG.DDBI.DIRECT_CONFIG")) {
      if ((/electron/i).test(navigator.userAgent)) {
        logger/* default.info */.Z.info("Electron detected using DDB Config stub");
        logger/* default.debug */.Z.debug("DDB_CONFIG", CONFIG.DDB);
      } else {
        logger/* default.info */.Z.info("Loaded default DDB config, checking for live config access.");
        directConfig().then(() => {
          addDDBConfig();
        });
      }
    } else {
      proxyConfig().then(() => {
        addDDBConfig();
      });
    }
  }
}

;// CONCATENATED MODULE: ./src/hooks/ready/anchorInjection.js



function getOptions(page, current) {
  let options = "<option></option>";
  if (page?.toc) {
    for (const section of Object.values(page.toc)) {
      options += `<option value="${section.slug}"${section.slug === current ? " selected" : ""}>${section.text}</option>`;
    }
  }
  return options;
}

function addSlugField(element, slug, document) {
  const titleInput = element.querySelector("input[name='text']");
  const slugHTML = `<div class="form-group">
  <label>Jump to HTML Slug</label>
  <div class="form-fields">
      <select name="slug" >${getOptions(document.page, slug)}</select>
  </div>
</div>`;

  const div = utils/* default.htmlToElement */.Z.htmlToElement(slugHTML);
  titleInput.parentNode.parentNode.parentNode.insertBefore(div, titleInput.parentNode.parentNode.nextSibling.nextSibling);
}

function setSlugProperties(doc, slug, label) {
  foundry.utils.setProperty(doc, "flags.anchor.slug", slug);
  foundry.utils.setProperty(doc, "flags.ddb.slugLink", slug);
  foundry.utils.setProperty(doc, "flags.ddb.labelName", label);
  return doc;
}

function getSlug(doc) {
  return doc.flags.ddb?.slugLink
      ?? doc.flags.anchor?.slug
      ?? "";
}

function updateNotePage(noteConfig, slug) {
  const journalId = noteConfig.form.elements.entryId?.value;
  const pageId = noteConfig.form.elements.pageId?.value;
  const journal = game.journal.get(journalId);
  const page = journal?.pages.get(pageId);
  noteConfig.form.elements["slug"].innerHTML = getOptions(page, slug);
}

function anchorInjection() {
  // don't load if similar modules present
  if (game.modules.get("jal")?.active) {
    logger/* default.warn */.Z.warn("Anchor injection already loaded from JAL.");
    return;
  }

  Hooks.on("activateNote", (note, options) => {
    const slug = getSlug(note.document);
    if (slug) {
      logger/* default.debug */.Z.debug("Injecting note anchor", slug);
      options["anchor"] = slug;
    }
  });

  // when we render a note we add the anchor links box
  Hooks.on("renderNoteConfig", (noteConfig, html, data) => {
    const slug = getSlug(noteConfig.document);
    if (!noteConfig.element[0].querySelector("input[name='slug']")) {
      addSlugField(noteConfig.element[0], slug, data.document);
      if (!noteConfig._minimized) {
        const pos = noteConfig.position;
        pos.height = 'auto';
        noteConfig.setPosition(pos);
      }
    }
    noteConfig.element[0].style.height = "auto";
    const isExistingNote = noteConfig.document.id !== null;

    html.find("select[name='entryId']").change(() => updateNotePage(noteConfig, slug));
    html.find("select[name='pageId']").change(() => updateNotePage(noteConfig, slug));

    if (isExistingNote) {
      const closeHookId = Hooks.on("closeDocumentSheet", async (documentSheet, html) => {
        if (!(documentSheet instanceof NoteConfig)) return;
        if (noteConfig.document.id !== documentSheet.document.id) return;
        Hooks.off("closeNoteConfig", closeHookId);
        const slugInput = html[0].querySelector("select[name='slug']");
        const selectedSlug = slugInput?.value;
        if (selectedSlug && selectedSlug.trim() !== "" && selectedSlug !== documentSheet.document.flags.ddb?.slugLink) {
          const update = setSlugProperties({ _id: documentSheet.document.id }, selectedSlug, documentSheet.document.label);
          await canvas.scene.updateEmbeddedDocuments("Note", [update]);
        }
      });
    }
  });

  // handle new notes, we just inject the slug properties into the source from the sheet data
  Hooks.on("preCreateNote", (note, data) => {
    if (data.slug) {
      const flagData = setSlugProperties(foundry.utils.deepClone(note), data.slug, data.text);
      note.updateSource({ flags: flagData.flags });
    };
  });

  Hooks.on("dropCanvasData", (_, dropData) => {
    if (dropData.type !== "JournalEntryPage" && !dropData.anchor?.slug) return;

    // when we create from the side bar we fill in the input label name to match
    // the anchor name and set the slug value to the anchor slug
    Hooks.once("renderNoteConfig", (noteConfig, _html, app) => {
      const titleInput = noteConfig.element[0].querySelector("input[name='text']");
      titleInput.setAttribute('value', dropData.anchor.name);
      if (dropData.anchor.slug) {
        titleInput.setAttribute('value', dropData.anchor.name);
        updateNotePage(noteConfig, dropData.anchor.slug);
      } else {
        titleInput.setAttribute('value', app.label);
      }
    });
  });
}

;// CONCATENATED MODULE: ./src/hooks/ready/originFixing.js



async function createActorHook(actor, options, user) {
  // Can't do this in preCreate because the actor id doesn't exist yet.
  if (options.keepId) return;
  if (game.user?.id !== user) return;
  if (game.modules.get("dnd5e-scriptlets")?.active && game.settings.get("dnd5e-scriptlets", "UpdateCreatedOrigins")) {
    await OriginFixer.updateActorEffects(actor, true);
  } else {
    await OriginFixer.updateActorEffects(actor);
  }
}

async function createTokenHook(tokenDocument, options, user) {
  if (options.keepId) return;
  if (game.user.id !== user) return;
  if (game.modules.get("dnd5e-scriptlets")?.active && game.settings.get("dnd5e-scriptlets", "UpdateCreatedOrigins")) {
    await OriginFixer.updateActorEffects(tokenDocument.actor, true);
  } else {
    await OriginFixer.updateActorEffects(tokenDocument.actor);
  }
}

function setupUpdateCreatedOrigins() {
  Hooks.on("createActor", createActorHook);
  Hooks.on("createToken", createTokenHook);
}

;// CONCATENATED MODULE: ./src/effects/DDBEffectHooks.js
// import logger from "../logger.js";



class DDBEffectHooks {

  // eslint-disable-next-line no-unused-vars
  static ddbMacro(actor, change, ..._params) {
    const scope = { actor, token: null };
    const data = JSON.parse(change.value);

    DDBMacros/* default.executeDDBMacro */.Z.executeDDBMacro(data.type, data.name, scope);
  }

  // eslint-disable-next-line no-unused-vars
  static processCustomApplyEffectHooks(actor, change, current, delta, changes) {
    // eslint-disable-next-line no-useless-return
    if (change.mode !== CONST.ACTIVE_EFFECT_MODES.CUSTOM) return;

  }

  static loadHooks() {
    // special effect functions
    Hooks.on("applyActiveEffect", DDBEffectHooks.processCustomApplyEffectHooks);
  }

}

;// CONCATENATED MODULE: ./src/hooks/renderMuncher/earlySettings.js


function earlySettings() {
  for (const [name, data] of Object.entries(src_settings/* default.GET_DEFAULT_SETTINGS */.Z.GET_DEFAULT_SETTINGS(true))) {
    game.settings.register(src_settings/* default.MODULE_ID */.Z.MODULE_ID, name, data);
  }
}

;// CONCATENATED MODULE: ./src/hooks/renderMuncher/addMuncher.js






function addMuncher(app, html) {
  if (app.options.id == "compendium" && game.user.isGM) {
    let button = $("<div class='header-actions action-buttons flexrow'><button class='ddb-muncher'><i class='fas fa-pastafarianism'></i> DDB Muncher</button></div>");

    button.click(async () => {
      ui.notifications.info("Checking your DDB details - this might take a few seconds!");
      const setupComplete = DDBSetup.isSetupComplete();

      if (setupComplete) {
        const cobaltStatus = await (0,Secrets/* checkCobalt */.B)();
        if (cobaltStatus.success) {
          let validKey = await isValidKey();
          if (validKey) {
            new DDBMuncher/* default */.Z().render(true);
          }
        } else {
          new DDBCookie().render(true);
        }
      } else {
        game.settings.set("ddb-importer", "settings-call-muncher", true);
        new DDBSetup().render(true);
      }
    });

    const top = game.settings.get("ddb-importer", "show-munch-top");
    if (top) {
      $(html).find(".directory-header").append(button);
    } else {
      $(html).find(".directory-footer").append(button);
    }
  }
}

;// CONCATENATED MODULE: ./src/hooks/renderMuncher/addEncounterMuncher.js









function addEncounterMuncher (app, html) {
  const tier = PatreonHelper/* default.getPatreonTier */.Z.getPatreonTier();
  const tiers = PatreonHelper/* default.calculateAccessMatrix */.Z.calculateAccessMatrix(tier);
  const enabled = game.settings.get("ddb-importer", "encounter-muncher-enabled");

  const scenesTab = app.options.id == "scenes" || app.id === "scenes";

  if (enabled && scenesTab && game.user.isGM && tiers.supporter) {
    let button = $("<div class='header-actions action-buttons flexrow'><button class='ddb-muncher' id='ddb-encounter-munch-open'><i class='fas fa-dungeon'></i> DDB Encounter Muncher</button></div>");

    const actualButton = button.find('#ddb-encounter-munch-open');
    actualButton.click(async () => {
      actualButton.prop('disabled', true);
      ui.notifications.info("Fetching your DDB Encounter Information, this might take a few seconds!");
      try {
        const setupComplete = DDBSetup.isSetupComplete();

        if (setupComplete) {
          const cobaltStatus = await (0,Secrets/* checkCobalt */.B)();
          if (cobaltStatus.success) {
            let validKey = await isValidKey();
            if (validKey) {
              new DDBEncounterMunch().render(true);
            }
          } else {
            actualButton.prop('disabled', false);
            new DDBCookie().render(true);
          }
        } else {
          actualButton.prop('disabled', false);
          new DDBSetup().render(true);
        }

        const hookId = Hooks.on("closeApplication", (app) => {
          if (app instanceof DDBEncounterMunch) {
            actualButton.prop('disabled', false);
            Hooks.off("closeApplication", hookId);
          }
        });
      } catch (e) {
        logger/* default.error */.Z.error(e);
        actualButton.prop('disabled', false);
      }
    });

    const top = game.settings.get("ddb-importer", "show-munch-top");
    if (top) {
      $(html).find(".directory-header").prepend(button);
    } else {
      $(html).find(".directory-footer").append(button);
    }
  }
}

;// CONCATENATED MODULE: ./src/hooks/socket/sockets.js


/**
 * This is a stripped down socketlib like implementation
 *  for some unique circumstances where confusion arises when using
 * with DAE GM Macros
 *
 * This is a MIT license and the inspiration is https://github.com/manuelVo/foundryvtt-socketlib/
 */

class DDBSocket {

  constructor() {
    this.functions = new Map();
    this.requests = new Map();
    this.name = "module.ddb-importer";

    game.socket.on(this.name, this._received.bind(this));
  }

  register(name, f) {
    this.functions.set(name, f);
  }

  static isExecutingGM() {
    if (!game.user.isGM) return false;
    const online = game.users.filter((u) => u.isGM && u.active);
    // run as lowest ranking online GM
    return !online.some((u) => u.id < game.user.id);
  }

  #getFunction(func) {
    if (func instanceof Function) {
      for (const [key, value] of this.functions.entries()) {
        if (value === func) return [key, func];
      }
      throw new Error(`Function '${func.name}' has not been registered with DDB Importer Socket`);
    } else {
      const fn = this.functions.get(func);
      if (fn) return [func, fn];
      throw new Error(`No DDB socket function with the name '${func}' has been registered.`);
    }
  }

  async _receiveRequest(message, senderId) {
    const { functionName, args, recipient, id } = message;
    if (recipient instanceof Array) {
      if (!recipient.includes(game.userId)) return;
    } else {
      switch (recipient) {
        case "GM":
        case "gm":
          if (!DDBSocket.isExecutingGM()) return;
          break;
        default:
          logger/* default.error */.Z.error(
            `Unknown recipient '${recipient}' when trying to execute '${functionName}' for 'DDB Importer internal socket handler.`
          );
          return;
      }
    }

    const [name, func] = this.#getFunction(functionName);
    const socketData = { userId: senderId };

    try {
      const result = await func.call({ socketData }, ...args);
      game.socket.emit(this.name, { id, result, type: "RESULT" });
    } catch (e) {
      logger/* default.error */.Z.error(`An exception occurred while executing ddb macro function '${name}'.`, { name, func });
      game.socket.emit(this.name, { id, type: "EXCEPTION", userId: game.userId });
      throw e;
    }
  }

  // eslint-disable-next-line no-unused-vars
  _receiveResponse(message, _senderId) {
    const { id, result, type } = message;
    const request = this.requests.get(id);
    if (!request) return;
    switch (type) {
      case "RESULT":
        request.resolve(result);
        break;
      case "EXCEPTION":
        request.reject(
          new Error(`An exception occurred during remote execution of DDB function '${request.functionName}'. Please see ${game.users.get(message.userId).name}'s error console for details.`)
        );
        break;
      default:
        request.reject(
          new Error(`Unknown result type '${type}' for DDB function '${request.functionName}'. Catastrophic error.`)
        );
        break;
    }
    this.requests.delete(id);
  }

  _received(message, senderId) {
    if (["REQUEST"].includes(message.type)) {
      this._receiveRequest(message, senderId);
    } else {
      this._receiveResponse(message, senderId);
    }
  }

  _sendRequest(functionName, args, recipient) {
    const message = {
      functionName,
      args,
      recipient,
      type: "REQUEST",
      id: foundry.utils.randomID(),
    };
    const promise = new Promise((resolve, reject) =>
      this.requests.set(message.id, { functionName, resolve, reject, recipient })
    );
    game.socket.emit(this.name, message);
    return promise;
  }

  static _executeLocal(func, ...args) {
    const socketData = { userId: game.userId };
    return func.call({ socketData }, ...args);
  }

  async executeAsGM(functionName, ...args) {
    const [name, func] = this.#getFunction(functionName);
    if (game.user.isGM) {
      return DDBSocket._executeLocal(func, ...args);
    } else {
      if (!game.users.find((u) => u.isGM && u.active)) {
        throw new Error(`Could not execute DDB function '${name}' (${func.name}) as GM, because no GM is connected.`);
      }
      return this._sendRequest(name, args, "GM");
    }
  }

  async executeAsUser(functionName, userId, ...args) {
    const [name, func] = this.#getFunction(functionName);
    if (userId === game.userId) return DDBSocket._executeLocal(func, ...args);
    const user = game.users.get(userId);
    if (!user) throw new Error(`No user with id '${userId}' exists.`);
    if (!user.active) throw new Error(`User '${user.name}' (${userId}) is not online.`);
    return this._sendRequest(name, args, [userId]);
  }

}

function setupSockets() {
  const socket = new DDBSocket();
  socket.register("simpleButtonDialog", DDBImporter.lib.DialogHelper.buttonDialog);
  socket.register("chooserDialog", DDBImporter.lib.DialogHelper.ChooserDialog.Ask);
  socket.register("ddbMacro", DDBImporter.lib.DDBMacros.executeDDBMacro);
  socket.register("ddbMacroFunction", DDBImporter.lib.DDBSimpleMacro.execute);
  socket.register("ddbSimpleMacro", DDBImporter.lib.DDBSimpleMacro.execute);
  socket.register("addCondition", DDBImporter.lib.DDBEffectHelper.addCondition);
  socket.register("removeCondition", DDBImporter.lib.DDBEffectHelper.removeCondition);

  globalThis.DDBImporter.socket = socket;
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/linkTables.js
function linkTables(type, html) {

  // if journal
  let content;
  let findString;
  switch (type) {
    case "journal":
      content = $(html).find(`div[data-edit="content"]`);
      findString = "a.content-link[data-entity='RollTable']";
      break;
    case "item": {
      const tableCompendium = game.settings.get("ddb-importer", "entity-table-compendium");
      content = $(html).find(`div[data-edit="data.description.value"]`);
      findString = `a.content-link[data-pack='${tableCompendium}']`;
      break;
    }
    // no default
  }


  // Add a direct roll button into DDB-imported rolltables
  $(content)
    .find(findString)
    .each(async (_, link) => {
      const data = $(link).data();
      const pack = game.packs.get(data.pack);

      const table = pack
        ? await pack.getDocument(data.id)
        : game.tables.get(data.id);

      if (table?.flags?.ddb?.contentChunkId || pack) {
        const button = $(
          `<a title="Click: Roll | Shift-Click: Self Roll" class="ddbimporter roll"><i class="fas fa-dice-d20"></i>  Roll!</a>`
        );

        $(link).after(button);
        $(button).on("click", async (event) => {
          event.preventDefault();
          const rollMode = event.shiftKey ? "selfroll" : "roll";

          // fix: Table description is undefined
          if (!table.description) table.description = table.name;

          const draw = await table.roll();

          draw.results = draw.results.map((result) => {
            if (!result.img)
              result.img = "icons/svg/d20-highlight.svg";
            return result;
          });

          await table.toMessage(draw.results, {
            roll: draw.roll,
            messageOptions: {
              speaker: game.user.name,
              rollMode: rollMode,
            },
          });

        });
      }
    });
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/shared.js



function imageToChat(src) {
  const content = `<img class="ddbimporter-chat-image" data-src="${src}" src="${src}">`;

  ChatMessage.create({
    content,
  });
}

async function getJournal(bookCode) {
  const folder = await FolderHelper/* default.getFolder */.Z.getFolder("journal", "", "Player Handouts", "#515fc8", "#515fc8", false);
  const journalName = bookCode
    ? DDBHelper/* default.getBookName */.Z.getBookName(bookCode)
    : "Handout Pages";
  const existingJournal = game.journal.find((journal) =>
    journal.name === journalName && journal.folder.id === folder.id
  );
  if (existingJournal) {
    return existingJournal;
  } else {
    const journal = await JournalEntry.create(
      {
        name: journalName,
        folder: folder.id,
        ownership: {
          default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER,
        },
        flags: {
          ddb: {
            bookCode,
          },
        },
      },
      {
        displaySheet: false,
      }
    );
    return journal;
  }
}

async function createPage(journal, name, type, content) {
  const page = {
    _id: foundry.utils.randomID(),
    name,
    type,
    text: {},
    title: {
      show: true,
    },
    ownership: {
      default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER,
    }
  };
  switch (type) {
    case "image": {
      page.title.show = true;
      page.src = content;
      break;
    }
    case "text":
    default: {
      page.text.content = content;
    }
  }

  await JournalEntryPage.create(page, { parent: journal, keepId: true, displaySheet: false });
  return journal.pages.find((jp) => page._id === jp._id);
}

async function createAndShowPlayerHandout(name, content, type, bookCode) {

  const journal = await getJournal(bookCode);

  const existingPage = journal.pages.find((page) => {
    const nameCheck = page.name === name;
    const typeCheck = type === "image"
      ? page.src === content
      : type === "text"
        ? page.text?.content === content
        : true;
    return nameCheck && typeCheck;
  });

  const page = existingPage
    ? existingPage
    : await createPage(journal, name, type, content);

  Journal.showDialog(page);
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/linkImages.js



function linkImages(html, data) {
  if (!game.user.isGM) return;
  const displayImages = game.settings.get("ddb-importer", "show-image-to-players");
  // does this functionality exist from anther module?
  const funcExists = !displayImages || game.modules.get("token-hud-art-button")?.active;

  if (funcExists) return;

  // mark all images
  $(html)
    .find('img')
    .each((index, element) => {
      const showPlayersButton = $("<a class='ddbimporter-show-image'><i class='fas fa-eye'></i>&nbsp;Show Players Image</a>");
      const toChatButton = $("<a class='ddbimporter-to-chat'><i class='fas fa-comment'></i>&nbsp;To Chat</a>");

      $(element).wrap("<div class='ddbimporter-image-container'></div>");
      // show the button on mouseenter of the image
      $(element)
        .parent()
        .mouseenter(function addHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).append(showPlayersButton);
          $(showPlayersButton).click((event) => {
            event.preventDefault();
            event.stopPropagation();
            const src = $(element).attr("src");
            Dialog.confirm({
              title: "Would you like to create a handout for the image?",
              content: "<p>Create a player viewable handout? (No will show the image only)</p>",
              yes: async () => {
                const name = await utils/* default.namePrompt */.Z.namePrompt("What would you like to call the Handout?");
                if (name && name !== "") {
                  const bookCode = data.flags?.ddb?.bookCode;
                  createAndShowPlayerHandout(name, src, "image", bookCode);
                }
              },
              no: () => {
                const popOut = new ImagePopout(src, { shareable: true });
                popOut.shareImage();
              },
              defaultYes: true
            });
          });
          // eslint-disable-next-line no-invalid-this
          $(this).append(toChatButton);
          $(toChatButton).click((event) => {
            event.preventDefault();
            event.stopPropagation();
            imageToChat($(element).attr("src"));
          });
        });
      $(element)
        .parent()
        .mouseleave(function removeHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).find("a.ddbimporter-show-image, a.ddbimporter-to-chat").remove();
        });
    });
}

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/buildNotes.js


function copyToClipboard(text) {
  logger/* default.debug */.Z.debug("Copy block", text);
  let dummy = document.createElement("textarea");
  document.body.appendChild(dummy);
  dummy.value = text;
  dummy.select();
  document.execCommand("copy");
  document.body.removeChild(dummy);
}

function getNoteButton(name, type) {
  return $(
    `<a id='ddb-note-${name}' class='ddb-button'><i class='fas fa-clipboard-check'></i>&nbsp;Copy ${type} ${name} </a>`
  );
}

function getTableButton() {
  return $(
    `<a id='ddb-table-name' class='ddb-button'><i class='fas fa-clipboard-check'></i>&nbsp;Copy table details </a>`
  );
}

function buildNotes(html, data) {
  if (!game.user.isGM) return;
  const allow = game.settings.get("ddb-importer", "allow-note-generation");
  if (!allow) return;

  // mark all headers
  $(html)
    .find("h1, h2, h3, h4, h5, figure, p")
    .each((index, element) => {
      $(element).wrap("<div class='ddbimporter-note-container'></div>");
      // show the button on mouseenter
      $(element)
        .parent()
        .mouseenter(function Hovering() {
          if (CONFIG.DDBI.DEV.tableInUse) return;
          const tagName = $(element).prop("tagName");
          const showStartButton = $(this).append(getNoteButton("start", tagName));
          const showEndButton = $(this).append(getNoteButton("end", tagName));
          $(showStartButton).click((e) => {
            if (e.target.id === "ddb-note-start") {
              CONFIG.DDBI.DEV.clippy = {
                ddbId: data.document.flags.ddb.ddbId,
                cobaltId: data.document.flags.ddb.cobaltId,
                parentId: data.document.flags.ddb.parentId,
                splitTag: tagName.toLowerCase(),
                slug: data.document.flags.ddb.slug,
                tagIdFirst: $(element).prop("id"),
                contentChunkIdStart: $(element).attr("data-content-chunk-id"),
                tagIdLast: "",
                contentChunkIdStop: "EOF",
                sceneName: data.document.name,
              };
              copyToClipboard(JSON.stringify(CONFIG.DDBI.DEV.clippy, null, 2));
            }
          });
          $(showEndButton).click((e) => {
            if (e.target.id === "ddb-note-end") {
              CONFIG.DDBI.DEV.clippy.tagIdLast = $(element).prop("id");
              CONFIG.DDBI.DEV.clippy.contentChunkIdStop = $(element).attr("data-content-chunk-id");
              copyToClipboard(JSON.stringify(CONFIG.DDBI.DEV.clippy, null, 2));
            }
          });
        });
      $(element)
        .parent()
        .mouseleave(function Unhovering() {
          $(this).find("#ddb-note-start").remove();
          $(this).find("#ddb-note-end").remove();
        });
    });

  // mark all headers
  $(html)
    .find("table")
    .each((index, element) => {
      $(element).wrap("<div class='ddbimporter-table-container'></div>");
      // show the button on mouseenter
      $(element)
        .parent()
        .mouseenter(function Hovering() {
          CONFIG.DDBI.DEV.tableInUse = true;
          const showButton = $(this).append(getTableButton());
          $(showButton).click((e) => {
            if (e.target.id === "ddb-table-name") {
              CONFIG.DDBI.DEV.clippy = {
                ddbId: data.flags.ddb.ddbId,
                cobaltId: data.flags.ddb.cobaltId,
                parentId: data.flags.ddb.parentId,
                slug: data.flags.ddb.slug,
                tagIdFirst: $(element).prop("id"),
                contentChunkId: $(element).attr("data-content-chunk-id"),
                sceneName: data.name,
                tableName: "",
              };
              copyToClipboard(JSON.stringify(CONFIG.DDBI.DEV.clippy, null, 2));
            }
          });
        });
      $(element)
        .parent()
        .mouseleave(function Unhovering() {
          $(this).find("#ddb-table-name").remove();
          CONFIG.DDBI.DEV.tableInUse = false;
        });
    });
}

/* harmony default export */ const renderJournalSheet_buildNotes = (buildNotes);

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/adventure.js



const adventure_POPUPS = {
  json: null,
  web: null,
};
const adventure_renderPopup = (type, url) => {
  if (adventure_POPUPS[type] && !adventure_POPUPS[type].close) {
    adventure_POPUPS[type].focus();
    adventure_POPUPS[type].location.href = url;
  } else {
    const ratio = window.innerWidth / window.innerHeight;
    const width = Math.round(window.innerWidth * 0.5);
    const height = Math.round(window.innerWidth * 0.5 * ratio);
    adventure_POPUPS[type] = window.open(
      url,
      "ddb_sheet_popup",
      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`
    );
  }
  return true;
};

function adventureFlags(app, html, data) {
  if (!app.document.flags.ddb) return;
  let journalContent = html.closest('.app').find('section.journal-page-content');
  journalContent.addClass("ddb");

  if (!game.user.isGM) return;
  const existingLink = html.closest('.app').find('.open-adventure-ddb-importer');
  if (existingLink.length > 0) return;

  const title = `Go to DDB`;
  const whiteTitle = (game.settings.get("ddb-importer", "link-title-colour-white")) ? " white" : "";
  let button = $(`<a class="open-adventure-ddb-importer" title="${title}"><i class="fab fa-d-and-d-beyond${whiteTitle}"></i></a>`);
  button.click((event) => {
    if (event.shiftKey && event.ctrlKey) {
      new DDBAdventureFlags(app.document, {}).render(true);
    } else {
      event.preventDefault();
      const flags = app.document.flags.ddb;
      const bookSource = CONFIG.DDB.sources.find((book) => flags.bookCode.toLowerCase() === book.name.toLowerCase());
      return adventure_renderPopup("web", `https://www.dndbeyond.com/${bookSource.sourceURL}/${flags.slug}`);
    }
    return true;
  });

  let titleElement = html.closest('.app').find('.window-title');
  button.insertAfter(titleElement);
  renderJournalSheet_buildNotes(html, data);

}


/* harmony default export */ const renderJournalSheet_adventure = (adventureFlags);

;// CONCATENATED MODULE: ./src/hooks/renderJournalSheet/linkReadAlouds.js



function showReadAlouds(html, data) {
  if (!game.user.isGM) return;
  const displayImages = game.settings.get("ddb-importer", "show-read-alouds-button");
  if (!displayImages) return;

  // mark all read alouds
  $(html)
    .find("aside, blockquote, .read-aloud-text, .read-aloud, .adventure-read-aloud-text, .ddb-blockquote")
    .each((index, element) => {
      const showPlayersJournalButton = $("<a class='ddbimporter-show-image'><i class='fas fa-book-open'></i>&nbsp;Create and Show Handout</a>");
      const toChatButton = $("<a class='ddbimporter-to-chat'><i class='fas fa-comment '></i>&nbsp;To Chat</a>");

      $(element).wrap("<div class='ddbimporter-image-container'></div>");
      // show the button on mouseenter of the image
      $(element)
        .parent()
        .mouseenter(function addHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).append(showPlayersJournalButton);
          $(showPlayersJournalButton).click(async (event) => {
            event.preventDefault();
            event.stopPropagation();
            const name = await utils/* default.namePrompt */.Z.namePrompt("What would you like to call the Handout?");
            if (name && name !== "") {
              const bookCode = data.data?.flags?.ddb?.bookCode;
              createAndShowPlayerHandout(name, element.outerHTML, "text", bookCode);
            }
          });
          // eslint-disable-next-line no-invalid-this
          $(this).append(toChatButton);
          $(toChatButton).click((event) => {
            event.preventDefault();
            event.stopPropagation();
            ChatMessage.create({ content: element.outerHTML });
          });
        });
      $(element)
        .parent()
        .mouseleave(function removeHover() {
          // eslint-disable-next-line no-invalid-this
          $(this).find("a.ddbimporter-show-image, a.ddbimporter-to-chat").remove();
        });
    });
}

;// CONCATENATED MODULE: ./src/lib/Notification.js
/**
 * Shows notifcations and hints to the user
 */
const MARGIN = 10;

const registerNotifications = () => {
  // register the notification global object

  if ($("#ddbimporter-notifications").length === 0) {
    $("body").append(`<div id="ddbimporter-notifications"></div>`);
  }
  if ($("#ddbimporter-hints").length === 0) {
    $("body").append(`<div id="ddbimporter-hints"></div>`);
  }

  game.modules.get("ddb-importer").api.notification = {
    clear: () => {
      $("#ddbimporter-notifications div").fadeOut(200, () => {
        $("#ddbimporter-notifications").empty();
      });
    },
    show: (message, timeout = 4000) => {
      $("#ddbimporter-notifications").css("left", $("#players").css("left"));
      // prettier-ignore
      $("#ddbimporter-notifications").css("bottom", $("#players").height() + (2 * MARGIN));

      let note = $(`<div style="display: none"></div>`).append(message);
      $("#ddbimporter-notifications").append(note);
      $(note).fadeIn(200);

      if (timeout)
        setTimeout(() => {
          $(note).fadeOut(200, () => {
            $(note).remove();
          });
        }, timeout);
      else
        $(note).append('<p style="text-align: center; color: #7e7e7e; margin: 0px;"><small>Click to close</small>');

      $(note).on("click", () => {
        $(note).fadeOut(200, () => {
          $(note).remove();
        });
      });
    },
  };
  game.modules.get("ddb-importer").api.hint = {
    clear: () => {
      $("#ddbimporter-hints div").hide(200, () => {
        $("#ddbimporter-hints").empty();
      });
    },
    show: (message, options = {}) => {
      return new Promise((resolve) => {
        $("#ddbimporter-hints").css("width", options.width ? options.width : 300);

        // construct the note
        let note = $(`<div style="display: none"></div>`);
        $(note).append(message);
        $(note).append('<div class="buttons"></div>');
        $("#ddbimporter-hints").append(note);
        $(note).fadeIn(200);

        if (!options.align) options.align = options.element ? "RIGHT" : "CENTER";

        let anchor = {
          width: 0,
          height: 0,
          top: Math.round(window.innerHeight / 2),
          left: Math.round(window.innerWidth / 2),
        };

        if (options.element) {
          anchor = Object.assign(
            { width: $(options.element).width(), height: $(options.element).height() },
            $(options.element).offset()
          );
        }
        const noteInfo = Object.assign(
          { width: $("#ddbimporter-hints").width(), height: $("#ddbimporter-hints").height() },
          $("#ddbimporter-hints").position()
        );

        switch (options.align) {
          case "RIGHT":
            $("#ddbimporter-hints").css("top", anchor.top);
            $("#ddbimporter-hints").css("left", anchor.left + anchor.width + MARGIN);
            break;
          case "LEFT":
            $("#ddbimporter-hints").css("top", anchor.top);
            $("#ddbimporter-hints").css("left", anchor.left - noteInfo.width - MARGIN);
            break;
          case "TOP":
            $("#ddbimporter-hints").css("top", anchor.top - noteInfo.height - MARGIN);
            $("#ddbimporter-hints").css("left", anchor.left);
            break;
          case "BOTTOM":
            $("#ddbimporter-hints").css("top", anchor.top + anchor.height + MARGIN);
            $("#ddbimporter-hints").css("left", anchor.left);
            break;

          default:
            // eslint-disable-next-line no-mixed-operators
            $("#ddbimporter-hints").css("top", anchor.top - Math.round(noteInfo.height / 2));
            // eslint-disable-next-line no-mixed-operators
            $("#ddbimporter-hints").css("left", anchor.left - Math.round(noteInfo.width / 2));
        }

        if (options.buttons) {
          for (let name of options.buttons) {
            let btn = $("<button>" + name + "</button>");
            $("div.buttons", note).append(btn);
            $(btn).on("click", () => {
              $(note).fadeOut(100, () => {
                $(note).remove();
                resolve(name);
              });
            });
          }
        }
        if (options.hide) {
          $(options.hide.selector).on(options.hide.event, () => {
            $(note).fadeOut(100, () => {
              $(note).remove();
              resolve(true);
            });
          });
        }
      });
    },
  };
};

/* harmony default export */ const Notification = (registerNotifications);

;// CONCATENATED MODULE: ./src/hooks/ready/enrichers.js
/* eslint-disable no-continue */




/**
 * Parse a roll string into a configuration object.
 * @param {string} match  Matched configuration string.
 * @returns {object}
 */
function parseConfig(match) {
  const config = { _config: match, values: [] };
  for (const part of match.match(/(?:[^\s"]+|"[^"]*")+/g)) {
    if (!part) continue;
    const [key, value] = part.split("=");
    const valueLower = value?.toLowerCase();
    if (value === undefined) config.values.push(key.replace(/(^"|"$)/g, ""));
    else if (["true", "false"].includes(valueLower)) config[key] = valueLower === "true";
    else if (Number.isNumeric(value)) config[key] = Number(value);
    else config[key] = value.replace(/(^"|"$)/g, "");
  }
  return config;
}

/**
 * Add a dataset object to the provided element.
 * @param {HTMLElement} element  Element to modify.
 * @param {object} dataset       Data properties to add.
 * @private
 */
function _addDataset(element, dataset) {
  for (const [key, value] of Object.entries(dataset)) {
    if (!key.startsWith("_") && (key !== "values") && value) element.dataset[key] = value;
  }
}

/* -------------------------------------------- */

/**
 * Create a rollable link.
 * @param {string} label    Label to display.
 * @param {object} dataset  Data that will be added to the link for the rolling method.
 * @returns {HTMLElement}
 */
function createFunctionLink(label, dataset) {
  const span = document.createElement("span");
  span.classList.add("roll-link");
  _addDataset(span, dataset);

  // Add main link
  const link = document.createElement("a");
  link.dataset.action = "roll";
  link.innerHTML = `<i class="fa-solid fa-wand"></i>${label}`;
  span.insertAdjacentElement("afterbegin", link);

  return span;
}


async function enrichFunction(config, label, options) {
  // console.warn("ENRICHER DEGUG", {
  //   config,
  //   label,
  //   options,
  // });

  if (!config.functionName || !config.functionType) return "";

  const dataset = {
    type: "ddbfunction",
    functionName: config.functionName,
    functionType: config.functionType,
    functionParams: config.functionParams ?? null,
  };

  let foundItem;

  const foundActor = options.relativeTo instanceof Item
    ? options.relativeTo.parent
    : options.relativeTo instanceof Actor ? options.relativeTo : null;

  // If config is an Item ID
  if (config.itemName && (/^\w{16}$/).test(config.itemName) && foundActor) foundItem = foundActor.items.get(config.itemName);

  // If config is a relative UUID
  if (config.itemName?.startsWith(".")) {
    try {
      foundItem = await fromUuid(config.itemName, { relative: options.relativeTo });
    } catch {
      return null;
    }
  }

  if (foundItem) {
    if (!label) label = foundItem.name;
    dataset.rollItemUuid = foundItem.uuid;
    return createFunctionLink(label, dataset);
  }

  // if itemName is provided, use that as the relative item
  dataset.rollItemActor = foundActor?.uuid;
  if (!label) label = `DDB Macro`;
  if (config.itemName) {
    dataset.rollItemName = config.itemName;
    return createFunctionLink(label, dataset);
  }

  // Finally, use relative item
  dataset.rollItemUuid = options.relativeTo.uuid;
  return createFunctionLink(label, dataset);
}

/**
 * Run the macro from the enricher
 * @param {RegExpMatchArray} match       The regular expression match result.
 * @param {EnrichmentOptions} options    Options provided to customize text enrichment.
 * @returns {Promise<HTMLElement|null>}  An HTML element to insert in place of the matched text or null to
 *                                       indicate that no replacement should be made.
 */
async function macroEnricher(match, options) {
  let { type, config, label } = match.groups;
  config = parseConfig(config);
  config._input = match[0];
  switch (type.toLowerCase()) {
    case "dbbfunc":
    case "dbbifunc":
    case "ddbfunc":
    case "ddbifunc":
      return enrichFunction(config, label, options);
    // no default
  }
  return null;
}

/**
 * Perform the provided function call.
 * @param {Event} event  The click event triggering the action.
 * @returns {Promise}
 */
async function runFunction(event) {
  const target = event.target.closest('.roll-link, [data-action="rollRequest"], [data-action="concentration"]');
  if (!target) return;
  event.stopPropagation();

  const { functionName, functionParams, functionType, rollItemActor, rollItemUuid, type, rollItemName } = target.dataset;

  if (type !== "ddbfunction") return;

  const action = event.target.closest("a")?.dataset.action ?? "roll";

  if (action !== "roll") return;

  target.disabled = true;

  const actor = rollItemActor ? await fromUuid(rollItemActor) : null;

  try {
    const ids = {
      effect: null,
      actor: rollItemActor,
      token: actor?.isOwner ? canvas.tokens.controlled[0]?.document?.uuid : null,
      item: rollItemUuid,
      origin: rollItemUuid,
    };
    const context = {};
    const scope = {
      rollItemName,
      functionParams,
      rollItemActor,
      rollItemUuid,
    };

    logger/* default.debug */.Z.debug(`Calling DDBSimpleMacro execution`, {
      functionType,
      functionName,
      context,
      ids,
      functionParams,
      scope,
    });


    await DDBSimpleMacro/* default.execute */.Z.execute(functionType, functionName, context, ids, scope);
  } finally {
    target.disabled = false;
  }
}

function registerCustomEnrichers() {
  CONFIG.TextEditor.enrichers.push(
    {
      pattern:
        /\[\[\/(?<type>ddbifunc) (?<config>[^\]]+)]](?:{(?<label>[^}]+)})?/gi,
      enricher: macroEnricher,
    },
  );

  document.body.addEventListener("click", runFunction);
}

;// CONCATENATED MODULE: ./src/hooks.js



// init hooks




// ready hooks










// monster muncher




// socket messaging


// image hooks












// foundry is initializing
function init() {
  earlySettings();
  (0,logger/* setupLogger */.F)();
  registerApi();
  chatHooks();
  adventureImporter();
  logger/* default.info */.Z.info("Init complete");
  DDBEffectHooks.loadHooks();
  registerCustomEnrichers();
}

// foundry is ready
async function onceReady() {
  // register the game settings
  await registerGameSettings();

  // check for valid compendiums
  (0,checkCompendiums/* default */.Z)().then(() => {
    DDBSummonsManager/* default.generateFixedSummons */.Z.generateFixedSummons();
  });

  // notificaitons
  Notification();
  loadDDBConfig();

  // delay the startup just a tiny little bit
  setTimeout(() => {
    checkVersion();
    // register the D&DBeyond Button on the character sheets
    registerSheets();
    itemSheets();
    setupUpdateCreatedOrigins();
    activateUpdateHooks();
  }, 500);

  anchorInjection();
  logger/* default.info */.Z.info("OnceReady complete");
}

function onReady() {
  setupSockets();
}

function renderSidebarTab(app, html) {
  addEncounterMuncher(app, html);
  addMuncher(app, html);
}

function renderItemSheet(sheet, html) {
  linkTables("item", html);
  // link images disabled un v10
  // linkImages(html);
}

function renderJournalSheet(sheet, html, data) {
  if (data.cssClass !== "editable") {
    linkTables("journal", html);
    linkImages(html, data);
    showReadAlouds(html, data);
  }
  renderJournalSheet_adventure(sheet, html, data);
}

// EXTERNAL MODULE: ./src/apps/DDBSources.js
var DDBSources = __webpack_require__(5982);
;// CONCATENATED MODULE: ./src/apps/SceneEnhancerExport.js




/**
   * Extracts all notes that have been placed by ddb-importer
   * Creates the expected data structure for the database by
   * getting the real label from the appropriate Journal Entry
   * @param {Scene} scene The scene to extract the notes from
  */
function getNotes(scene, bookCode) {
  // get all notes in the Journal related to this scene
  const relatedJournalEntries = game.journal.filter((journal) =>
    journal.flags.ddb?.bookCode && journal.flags.ddb.bookCode === bookCode
  );

  // get all notes placed on the map
  const journalNotes = scene.notes
    // the user might have placed a note, unless it is based on an imported Journal Entry, we will not carry
    // that one over
    .filter((note) => relatedJournalEntries.some((journal) => journal.id === note.entryId))
    .map((note) => {
      const journal = relatedJournalEntries.find((journal) => journal.id === note.entryId);
      const page = note.pageId
        ? journal.pages.find((page) => page._id === note.pageId)
        : journal;
      const index = parseInt(journal.flags.ddb.ddbId);
      // removed un-needed userdata
      const pageFlags = page.flags.ddb;
      const noteFlags = note.flags.ddb;
      const flags = foundry.utils.duplicate(pageFlags);
      foundry.utils.mergeObject(flags, noteFlags, { overwrite: true, insertKeys: true, insertValues: true });
      if (flags?.userData) delete flags.userData;
      const label = flags?.labelName && flags.labelName.trim() !== ""
        ? flags.labelName
        : noteFlags?.slugLink && noteFlags.slugLink.trim() !== ""
          ? note.text
          : page.name;

      logger/* default.warn */.Z.warn("note details", {
        note,
        page,
        icon: note.texture.src,
        journal,
        flags,
        pageFlags,
        noteFlags,
        label,
      });

      return {
        index,
        pageId: page._id,
        texture: note.texture,
        label,
        flags: {
          ddb: flags,
        },
        iconSize: note.iconSize,
        iconTint: note.iconTint,
        textColor: note.textColor,
        textAnchor: note.textAnchor,
        x: note.x,
        y: note.y,
      };
    })
    .reduce((notes, note) => {
      const idx = notes.find((n) => n.index === note.index && n.pageId === note.pageId && note.label === n.label);
      if (idx) {
        idx.positions.push({ x: note.x, y: note.y });
      } else {
        const n = {
          label: note.label,
          texture: note.texture,
          flags: note.flags,
          index: note.index,
          iconSize: note.iconSize,
          iconTint: note.iconTint,
          textColor: note.textColor,
          textAnchor: note.textAnchor,
          positions: [{ x: note.x, y: note.y }]
        };
        notes.push(n);
      }
      return notes;
    }, [])
    .sort((a, b) => {
      return a.index - b.index;
    });

  const unLinkedNotes = scene.notes
    .filter((note) => !note.entryId)
    .map((note) => ({
      label: note.text,
      texture: note.texture,
      flags: { ddb: {
        noLink: true,
      } },
      iconSize: note.iconSize,
      iconTint: note.iconTint,
      textColor: note.textColor,
      textAnchor: note.textAnchor,
      positions: [{ x: note.x, y: note.y }]
    }));

  const notes = journalNotes.concat(unLinkedNotes)
    .map((note) => ({
      label: note.label,
      flags: note.flags,
      texture: note.texture,
      positions: note.positions,
      iconSize: note.iconSize,
      iconTint: note.iconTint,
      textColor: note.textColor,
      textAnchor: note.textAnchor,
    }));

  return notes;
}

/**
 * Prepares the scene data for download
 * @param {Scene} scene
 */
function collectSceneData(scene, bookCode) {
  const notes = getNotes(scene, bookCode);

  const data = {
    flags: scene.flags,
    background: foundry.utils.deepClone(scene.background),
    name: scene.name,
    navName: scene.navName,
    // dimensions
    width: scene.width,
    height: scene.height,
    // grid
    grid: scene.grid,
    padding: scene.padding,
    // initial
    initial: scene.initial,
    // customization
    backgroundColor: scene.backgroundColor,
    walls: scene.walls.map((wall) => {
      const w = wall.toObject();
      delete w._id;
      return w;
    }),
    //
    drawings: scene.drawings,
    weather: scene.weather,
    // lights
    darkness: scene.darkness,
    tokenVision: scene.tokenVision,
    globalLight: scene.globalLight,
    globalLightThreshold: scene.globalLightThreshold,
    lights: scene.lights.map((light) => {
      const l = light.toObject();
      delete l._id;
      return l;
    }),
  };

  delete data.background.src;

  if (!data.flags.ddb) data.flags.ddb = {};
  data.flags.ddb.foundryVersion = game.version;

  if (data.flags.ddb.tokens) delete data.flags.ddb.tokens;
  data.flags.ddb.tokens = scene.tokens
    .filter((token) => !token.actorLink)
    .map((token) => {
      let result = {
        _id: token._id,
        name: token.name,
        width: token.width,
        height: token.height,
        scale: token.scale,
        x: token.x,
        y: token.y,
        disposition: token.disposition,
        flags: token.flags,
        actorLink: false,
        bar1: { attribute: "attributes.hp" },
        effects: [],
        elevation: token.elevation,
        hidden: token.hidden,
        tint: token.tint,
        actorData: token.delta.toObject(),
        light: token.light,
      };

      // the token actor flags here help us match up actors using the DDB ID
      if (token.actor) {
        if (token.actor.flags.ddbimporter) {
          result.flags.ddbActorFlags = token.actor.flags.ddbimporter;
          result.flags.ddbActorFlags.name = token.actor.prototypeToken?.name ? token.actor.prototypeToken.name : token.actor.name;
        }
      }
      if (foundry.utils.hasProperty(token, "token.actorData.flags")) delete token.actorData.flags["token-action-hud-core"];
      delete token.flags["token-action-hud-core"];
      delete token.flags["simbuls-cover-calculator"];
      delete token.flags["monks-enhanced-journal"];
      delete token.flags["monks-tokenbar"];
      delete token.flags["tagger"];
      delete token.flags["monks-combat-marker"];
      delete token.flags["image-hover"];
      delete token.flags["elevation-drag-ruler"];

      return result;
    });


  // removed un-needed userdata
  if (data.flags.ddb?.userData) delete data.flags.ddb.userData;

  data.flags.ddb.notes = notes;
  data.flags.ddb.img = `assets/${scene.background.src.split("assets/").pop()}`;

  if (!data.flags.ddbimporter) data.flags.ddbimporter = {};
  data.flags.ddbimporter['version'] = game.modules.get("ddb-importer").version;

  return data;
}

function getCompendiumScenes(compendiumCollection, selectedId = null, selectedName = null) {
  let scenes = [];
  const compendium = game.packs.find((pack) => pack.collection === compendiumCollection);
  if (compendium) {
    compendium.index.forEach((scene) => {
      const option = {
        _id: scene._id,
        name: scene.name,
        selected: (selectedId && selectedId == scene._id) || (selectedName && selectedName.trim().includes(scene.name)),
      };
      scenes.push(option);
    });
  }

  return scenes;
}

const ddbFlags = ["ddb", "ddbimporter"];
const allowedFlags = ["stairways", "perfect-vision", "dynamic-illumination"];

class SceneEnhancerExport extends Application {

  // eslint-disable-next-line complexity
  constructor(scene) {
    super();
    this.sceneSet = false;
    this.compendiumBookSet = false;
    this.downloadBookSet = false;

    this.scene = scene;
    const sceneExportFlags = this.scene.flags.ddbimporter?.export;
    const lastCompendium = localStorage.getItem("ddb-last-compendium");
    const lastBook = localStorage.getItem("ddb-last-book");

    this.description = sceneExportFlags?.description || "";
    this.url = sceneExportFlags?.url || "";
    this.compendium = sceneExportFlags?.compendium ?? lastCompendium;
    this.compendiumSceneId = sceneExportFlags?.scene;
    this.bookCode = this.scene.flags?.ddb?.bookCode.toLowerCase() ?? lastBook;
    this.compendiumScenes = this.compendium ? getCompendiumScenes(this.compendium, this.compendiumSceneId, this.scene.name) : [];

    if (this.compendiumScenes && this.compendiumScenes.some((s) => s.selected === true)) this.sceneSet = true;

    this.compendiums = game.packs
      .filter((pack) => pack.metadata?.type === "Scene")
      .map((pack) => {
        if (this.compendium && this.compendium === pack.collection) pack.selected = true;
        else pack.selected = false;
        return pack;
      })
      .sort((a, b) => a.metadata.label.localeCompare(b.metadata.label));

    const selectedBooks = this.bookCode
      ? CONFIG.DDB.sources.filter((s) => s.name.toLowerCase() === this.bookCode).map((s) => s.id)
      : [];
    this.books = DDBSources/* default.getSourcesLookups */.Z.getSourcesLookups(selectedBooks).map((b) => {
      if (b.selected) {
        this.compendiumBookSet = true;
        this.downloadBookSet = true;
      }
      return {
        code: b.acronym.toLowerCase(),
        name: b.label,
        selected: b.selected,
      };
    }).sort((a, b) => a.name.localeCompare(b.name));

    this.exportOptionsCompendium = {
      actors: sceneExportFlags?.actors !== undefined ? sceneExportFlags.actors : true,
      notes: sceneExportFlags?.notes !== undefined ? sceneExportFlags.notes : true,
      lights: sceneExportFlags?.lights !== undefined ? sceneExportFlags.lights : false,
      walls: sceneExportFlags?.walls !== undefined ? sceneExportFlags.walls : false,
      drawings: sceneExportFlags?.drawings !== undefined ? sceneExportFlags.drawings : false,
      config: sceneExportFlags?.config !== undefined ? sceneExportFlags.config : false,
    };
    this.exportOptionsDownload = {
      actors: sceneExportFlags?.actors !== undefined ? sceneExportFlags.actors : true,
      notes: sceneExportFlags?.notes !== undefined ? sceneExportFlags.notes : true,
      lights: sceneExportFlags?.lights !== undefined ? sceneExportFlags.lights : true,
      walls: sceneExportFlags?.walls !== undefined ? sceneExportFlags.walls : true,
      drawings: sceneExportFlags?.drawings !== undefined ? sceneExportFlags.drawings : true,
      config: sceneExportFlags?.config !== undefined ? sceneExportFlags.config : true,
    };
    this.compendiumDisabled = !this.sceneSet || !this.compendiumBookSet;
    this.downloadDisabled = !this.downloadBookSet || this.url === "" || !this.url.startsWith("http");
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    options.baseApplication = "SceneEnhancerExport";
    options.id = "ddb-importer-scene-enhancer";
    options.template = "modules/ddb-importer/handlebars/enhance-export.hbs";
    options.width = 500;
    options.resizable = false;
    options.height = "auto";
    options.classes = ["ddb-muncher", "sheet"];
    options.tabs = [{ navSelector: ".tabs", contentSelector: "div", initial: "compendium" }];
    return options;
  }

  get title() {
    return `DDB Importer Scene Enhancer Exporter: ${this.scene.name}`;
  }

  /** @override */
  getData() {
    let templateData = {
      sceneName: this.scene.name,
      compendiums: this.compendiums,
      compendiumScenes: this.compendiumScenes,
      description: this.description,
      books: this.books,
      url: this.url,
      exportOptionsCompendium: this.exportOptionsCompendium,
      exportOptionsDownload: this.exportOptionsDownload,
      compendiumDisabled: this.compendiumDisabled,
      downloadDisabled: this.downloadDisabled,
    };

    return templateData;
  }

  checkState() {
    if (this.sceneSet && this.compendiumBookSet) {
      this.compendiumDisabled = false;
      $("#compendium-button").prop("disabled", false);
    } else {
      $("#compendium-button").prop("disabled", true);
    }
    if (this.downloadBookSet && this.url !== "" && this.url.startsWith("http")) {
      this.downloadDisabled = false;
      $("#download-button").prop("disabled", false);
    } else {
      $("#download-button").prop("disabled", true);
    }
  }

  activateListeners(html) {
    super.activateListeners(html);
    $("#ddb-importer-scene-enhancer").css("height", "auto");

    html.find('#compendium-form').submit(async (event) => {
      const form = document.querySelector('#compendium-form');
      const data = Object.fromEntries(new FormData(form).entries());
      this.buttonClick(event, data);
    });

    html.find('#download-form').submit(async (event) => {
      const form = document.querySelector('#download-form');
      const data = Object.fromEntries(new FormData(form).entries());
      this.buttonClick(event, data);
    });

    html.find("#select-compendium").on("change", async () => {
      const compendiumSelection = html.find("#select-compendium");

      // get selected campaign from html selection
      const compendiumCollection = compendiumSelection[0].selectedOptions[0]
        ? compendiumSelection[0].selectedOptions[0].value
        : undefined;

      let sceneList = "";

      if (compendiumCollection && compendiumCollection !== "") {
        const scenes = getCompendiumScenes(compendiumCollection);
        sceneList = `<option value="">Select...</option>`;
        scenes.forEach((scene) => {
          const selected = scene.selected ? " selected" : "";
          sceneList += `<option value="${scene._id}"${selected}>${scene.name}</option>`;
        });
      }
      const sceneSelection = html.find("#select-scene");
      sceneSelection[0].innerHTML = sceneList;
    });

    html.find("#select-scene").on("change", async () => {
      const sceneSelection = html.find("#select-scene");
      const scene = sceneSelection[0].selectedOptions[0]
        ? sceneSelection[0].selectedOptions[0].value
        : undefined;
      this.sceneSet = scene && scene !== "";
      this.checkState();
    });

    html.find("#select-book-compendium").on("change", async () => {
      const bookSelection = html.find("#select-book-compendium");
      const book = bookSelection[0].selectedOptions[0]
        ? bookSelection[0].selectedOptions[0].value
        : undefined;
      this.compendiumBookSet = book && book !== "";
      this.checkState();
    });

    html.find("#select-book-download").on("change", async () => {
      const bookSelection = html.find("#select-book-download");
      const book = bookSelection[0].selectedOptions[0]
        ? bookSelection[0].selectedOptions[0].value
        : undefined;
      this.downloadBookSet = book && book !== "";
      this.checkState();
    });

    html.find("#download-url").on("change", async () => {
      const bookSelection = html.find("#download-url");
      const url = bookSelection[0].value;
      if (url && url !== "" && url.startsWith("http")) {
        this.url = url;
      }
      this.checkState();
    });

  }


  async buttonClick(event, formData) { // eslint-disable-line class-methods-use-this
    event.preventDefault();

    let sceneFlags = foundry.utils.duplicate(this.scene.flags);

    if (!sceneFlags.ddb) sceneFlags.ddb = {};
    if (!sceneFlags.ddbimporter) sceneFlags.ddbimporter = {};
    if (!sceneFlags.ddbimporter.export) sceneFlags.ddbimporter.export = {};

    sceneFlags.ddb["bookCode"] = formData["select-book"];
    localStorage.setItem("ddb-last-book", formData["select-book"]);
    sceneFlags.ddbimporter.export['description'] = formData["description"];
    sceneFlags.ddbimporter.export['actors'] = formData["export-actors"] == "on";
    sceneFlags.ddbimporter.export['notes'] = formData["export-notes"] == "on";
    sceneFlags.ddbimporter.export['lights'] = formData["export-lights"] == "on";
    sceneFlags.ddbimporter.export['walls'] = formData["export-walls"] == "on";
    sceneFlags.ddbimporter.export['drawings'] = formData["export-drawings"] == "on";
    sceneFlags.ddbimporter.export['config'] = formData["export-config"] == "on";

    if (formData["download-url"]) {
      sceneFlags.ddbimporter.export['url'] = formData["download-url"];
    } else {
      sceneFlags.ddbimporter.export['compendium'] = formData["select-compendium"];
      localStorage.setItem("ddb-last-compendium", formData["select-compendium"]);
      sceneFlags.ddbimporter.export['scene'] = formData["select-scene"];
    }

    await this.scene.update({ flags: sceneFlags });

    let sceneData = collectSceneData(this.scene, formData["select-book"]);

    Object.keys(sceneData.flags).forEach((flag) => {
      if (!allowedFlags.includes(flag) && !ddbFlags.includes(flag)) delete sceneData.flags[flag];
    });

    if (formData["export-actors"] !== "on") delete sceneData.flags.ddb.tokens;
    if (formData["export-notes"] !== "on") delete sceneData.flags.ddb.notes;
    if (formData["export-lights"] !== "on") delete sceneData.lights;
    if (formData["export-walls"] !== "on") delete sceneData.walls;
    if (formData["export-drawings"] !== "on") delete sceneData.drawings;
    if (formData["export-config"] !== "on") {
      delete sceneData.navName;
      delete sceneData.width;
      delete sceneData.height;
      delete sceneData.grid;
      delete sceneData.gridDistance;
      delete sceneData.gridType;
      delete sceneData.gridUnits;
      delete sceneData.shiftX;
      delete sceneData.shiftY;
      delete sceneData.padding;
      delete sceneData.weather;
      delete sceneData.darkness;
      delete sceneData.tokenVision;
      delete sceneData.globalLight;
      delete sceneData.globalLightThreshold;
      delete sceneData.backgroundColor;
      delete sceneData.initial;
      Object.keys(sceneData.flags).forEach((flag) => {
        if (!ddbFlags.includes(flag)) delete sceneData.flags[flag];
      });
    }

    logger/* default.debug */.Z.debug(sceneData);
    const name = sceneData.name.replace(/[^a-z0-9_-]/gi, '').toLowerCase();
    const sceneRef = `ddb-enhanced-scene-${name}`;
    FileHelper/* default.download */.Z.download(JSON.stringify(sceneData, null, 4), `${sceneRef}.json`, "application/json");

    this.close();
  }
}


;// CONCATENATED MODULE: ./src/hooks/navigationContext/extendSceneNavigationContext.js
// import utils from "../../lib/utils.js";



function getSceneId(li) {
  return $(li).attr("data-document-id")
    ? $(li).attr("data-document-id")
    : $(li).attr("data-scene-id")
      ? $(li).attr("data-scene-id")
      : $(li).attr("data-entity-id");
}

/* harmony default export */ function extendSceneNavigationContext(html, contextOptions) {
  contextOptions.push({
    name: "ddb-importer.scenes.download",
    callback: (li) => {
      const scene = game.scenes.get(getSceneId(li));
      const data = collectSceneData(scene, scene.flags.ddb.bookCode);
      const bookCode = `${scene.flags.ddb.bookCode}-${scene.flags.ddb.ddbId}`;
      const cobaltId = scene.flags.ddb?.cobaltId ? `-${scene.flags.ddb.cobaltId}` : "";
      const parentId = scene.flags.ddb?.parentId ? `-${scene.flags.ddb.parentId}` : "";
      const contentChunkId = scene.flags.ddb?.contentChunkId ? `-${scene.flags.ddb.contentChunkId}` : "";
      const name = scene.name.replace(/[^a-z0-9_-]/gi, '').toLowerCase();
      const sceneRef = `${bookCode}${cobaltId}${parentId}${contentChunkId}-${name}`;
      return FileHelper/* default.download */.Z.download(JSON.stringify(data, null, 4), `${sceneRef}-scene.json`, "application/json");
    },
    condition: (li) => {
      const scene = game.scenes.get(getSceneId(li));
      const sceneDownload = game.settings.get("ddb-importer", "allow-scene-download");
      const allowDownload = game.user.isGM && sceneDownload && scene.flags.ddb?.ddbId;
      return allowDownload;
    },
    icon: '<i class="fas fa-share-alt"></i>',
  });

  contextOptions.push({
    name: "ddb-importer.scenes.third-party-download",
    callback: (li) => {
      const scene = game.scenes.get(getSceneId(li));
      new SceneEnhancerExport(scene).render(true);
    },
    condition: (li) => {
      const scene = game.scenes.get(getSceneId(li));
      const sceneDownload = game.settings.get("ddb-importer", "allow-third-party-scene-download");
      const allowDownload = game.user.isGM && sceneDownload && !scene.flags.ddb?.ddbId;
      return allowDownload;
    },
    icon: '<i class="fas fa-share-alt"></i>',
  });
}

;// CONCATENATED MODULE: ./src/index.js



// register hooks
Hooks.once("init", init);
Hooks.once("ready", onceReady);
Hooks.on("ready", onReady);
Hooks.on("renderSidebarTab", renderSidebarTab);
Hooks.on("renderJournalPageSheet", renderJournalSheet);
Hooks.on("renderItemSheet", renderItemSheet);
Hooks.on("getSceneNavigationContext", extendSceneNavigationContext);
Hooks.on("getSceneDirectoryEntryContext", extendSceneNavigationContext);

// console.warn("SILENT MODE FOR DEBUG");
// const includeRgx = new RegExp("/module/ddb-importer/");
// CONFIG.compatibility.includePatterns.push(includeRgx);

})();

/******/ })()
;
//# sourceMappingURL=main.js.map